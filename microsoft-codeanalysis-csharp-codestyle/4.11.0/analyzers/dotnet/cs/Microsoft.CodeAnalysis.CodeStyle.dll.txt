[NullableContextAttribute("1")]
[NullableAttribute("0")]
[NonCopyableAttribute]
internal class FixedSizeArrayBuilder`1 : ValueType {
    private T[] _values;
    private int _index;
    public FixedSizeArrayBuilder`1(int capacity);
    public void Add(T value);
    public void AddRange(ImmutableArray`1<T> values);
    public void AddRange(List`1<T> values);
    public void AddRange(HashSet`1<T> values);
    public void AddRange(ArrayBuilder`1<T> values);
    public void AddRange(IEnumerable`1<T> values);
    [IsReadOnlyAttribute]
public void Sort();
    [IsReadOnlyAttribute]
public void Sort(IComparer`1<T> comparer);
    public ImmutableArray`1<T> MoveToImmutable();
    public T[] MoveToArray();
}
internal abstract class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiers`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, SyntaxNode member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifierAdded);
    [NullableContextAttribute("1")]
public abstract virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, TMemberDeclarationSyntax member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifierAdded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected static ImmutableDictionary`2<string, string> ModifiersAddedProperties;
    private static AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    protected abstract virtual void ProcessCompilationUnit(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, TCompilationUnitSyntax compilationUnitSyntax);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AddAccessibilityModifiersConstants : object {
    [NullableAttribute("1")]
public static string ModifiersAdded;
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.AddAccessibilityModifiers.IAddAccessibilityModifiers {
    public abstract virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, SyntaxNode member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifiersAdded);
}
internal enum Microsoft.CodeAnalysis.AddImport.AddImportPlacement : Enum {
    public int value__;
    public static AddImportPlacement InsideNamespace;
    public static AddImportPlacement OutsideNamespace;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions : object {
    public static CodeStyleOption2`1<AddImportPlacement> s_outsideNamespacePlacementWithSilentEnforcement;
    [CompilerGeneratedAttribute]
private bool <PlaceSystemNamespaceFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<AddImportPlacement> <UsingDirectivePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowInHiddenRegions>k__BackingField;
    public static AddImportPlacementOptions Default;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [DataMemberAttribute]
public bool PlaceSystemNamespaceFirst { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<AddImportPlacement> UsingDirectivePlacement { get; public set; }
    [DataMemberAttribute]
public bool AllowInHiddenRegions { get; public set; }
    public bool PlaceImportsInsideNamespaces { get; }
    [CompilerGeneratedAttribute]
private AddImportPlacementOptions(AddImportPlacementOptions original);
    private static AddImportPlacementOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_PlaceSystemNamespaceFirst();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PlaceSystemNamespaceFirst(bool value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<AddImportPlacement> get_UsingDirectivePlacement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UsingDirectivePlacement(CodeStyleOption2`1<AddImportPlacement> value);
    [CompilerGeneratedAttribute]
public bool get_AllowInHiddenRegions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowInHiddenRegions(bool value);
    public bool get_PlaceImportsInsideNamespaces();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(AddImportPlacementOptions left, AddImportPlacementOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(AddImportPlacementOptions left, AddImportPlacementOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(AddImportPlacementOptions other);
    [CompilerGeneratedAttribute]
public AddImportPlacementOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProvider {
}
internal static class Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProviders : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddRequiredParentheses.AbstractAddRequiredParenthesesDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<ValueTuple`2<bool, string>, ImmutableDictionary`2<string, string>> s_cachedProperties;
    private IPrecedenceService _precedenceService;
    private static AbstractAddRequiredParenthesesDiagnosticAnalyzer`3();
    protected AbstractAddRequiredParenthesesDiagnosticAnalyzer`3(IPrecedenceService precedenceService);
    protected static string GetEquivalenceKey(PrecedenceKind precedenceKind);
    protected static ImmutableArray`1<string> GetAllEquivalenceKeys();
    private static ImmutableDictionary`2<string, string> GetProperties(bool includeInFixAll, string equivalenceKey);
    protected abstract virtual int GetPrecedence(TBinaryLikeExpressionSyntax binaryLike);
    protected abstract virtual TExpressionSyntax TryGetAppropriateParent(TBinaryLikeExpressionSyntax binaryLike);
    protected abstract virtual bool IsBinaryLike(TExpressionSyntax node);
    protected abstract virtual ValueTuple`3<TExpressionSyntax, SyntaxToken, TExpressionSyntax> GetPartsOfBinaryLike(TBinaryLikeExpressionSyntax binaryLike);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TLanguageKindEnum> GetSyntaxNodeKinds();
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private void AddDiagnostics(SyntaxNodeAnalysisContext context, TBinaryLikeExpressionSyntax binaryLikeOpt, int precedence, NotificationOption2 notificationOption, ImmutableArray`1<Location> additionalLocations, string equivalenceKey, bool includeInFixAll);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddRequiredParentheses.AddRequiredParenthesesConstants : object {
    public static string EquivalenceKey;
    public static string IncludeInFixAll;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AnalysisContextExtensions : object {
    private static bool ShouldAnalyze(Nullable`1<TextSpan> contextFilterSpan, TextSpan span);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(SyntaxTreeAnalysisContext context, TextSpan span);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(SemanticModelAnalysisContext context, TextSpan span);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(SymbolStartAnalysisContext context, TextSpan span, SyntaxTree tree);
    [ExtensionAttribute]
public static bool ShouldAnalyzeLocation(SymbolStartAnalysisContext context, Location location);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(SymbolAnalysisContext context, TextSpan span, SyntaxTree tree);
    [ExtensionAttribute]
public static bool ShouldAnalyzeLocation(SymbolAnalysisContext context, Location location);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(AdditionalFileAnalysisContext context, TextSpan span);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(OperationBlockStartAnalysisContext context, TextSpan span);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(OperationBlockAnalysisContext context, TextSpan span);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(OperationAnalysisContext context, TextSpan span);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(SyntaxNodeAnalysisContext context, TextSpan span);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool ShouldAnalyzeSpan(CodeBlockStartAnalysisContext`1<TSytnaxKind> context, TextSpan span);
    [ExtensionAttribute]
public static bool ShouldAnalyzeSpan(CodeBlockAnalysisContext context, TextSpan span);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(SyntaxTreeAnalysisContext context, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(SemanticModelAnalysisContext context, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(SymbolStartAnalysisContext context, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(SymbolAnalysisContext context, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(OperationBlockStartAnalysisContext context, IOperation operationBlock, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(OperationBlockAnalysisContext context, IOperation operationBlock, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(OperationAnalysisContext context, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(SyntaxNodeAnalysisContext context, bool findInTrivia, bool getInnermostNodeForTie);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(CodeBlockStartAnalysisContext`1<TSyntaxKind> context, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetAnalysisRoot(CodeBlockAnalysisContext context, bool findInTrivia, bool getInnermostNodeForTie);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AnalyzerConfigOptionsExtensions : object {
    [ExtensionAttribute]
public static T GetEditorConfigOption(AnalyzerConfigOptions analyzerConfigOptions, IOption2 option, T defaultValue);
    [ExtensionAttribute]
public static T GetEditorConfigOptionValue(AnalyzerConfigOptions analyzerConfigOptions, IOption2 option, T defaultValue);
    [ExtensionAttribute]
public static bool TryGetEditorConfigOption(AnalyzerConfigOptions analyzerConfigOptions, IOption2 option, T& value);
    [ExtensionAttribute]
public static bool IsAnalysisLevelGreaterThanOrEquals(AnalyzerConfigOptions analyzerConfigOptions, int minAnalysisLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Analyzers.MatchFolderAndNamespace.AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableResourceString s_localizableTitle;
    private static LocalizableResourceString s_localizableInsideMessage;
    private static SymbolDisplayFormat s_namespaceDisplayFormat;
    private static AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TSyntaxKind> GetSyntaxKindsToAnalyze();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    private void AnalyzeNamespaceNode(SyntaxNodeAnalysisContext context);
    private bool IsFixSupported(SemanticModel semanticModel, TNamespaceSyntax namespaceDeclaration, CancellationToken cancellationToken);
    private bool IsFileAndNamespaceMismatch(TNamespaceSyntax namespaceDeclaration, string rootNamespace, string projectDir, string currentNamespace, String& targetNamespace);
    protected bool ContainsPartialTypeWithMultipleDeclarations(TNamespaceSyntax namespaceDeclaration, SemanticModel semanticModel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Analyzers.MatchFolderAndNamespace.MatchFolderAndNamespaceConstants : object {
    public static string RootNamespaceOption;
    public static string ProjectDirOption;
    public static string TargetNamespace;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Analyzers.UseCoalesceExpression.AbstractUseCoalesceExpressionForIfNullStatementCheckDiagnosticAnalyzer`5 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("0")]
protected TSyntaxKind IfStatementKind { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    [NullableContextAttribute("0")]
protected abstract virtual TSyntaxKind get_IfStatementKind();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual bool IsSingle(TVariableDeclarator declarator);
    protected abstract virtual bool IsNullCheck(TExpressionSyntax condition, TExpressionSyntax& checkedExpression);
    protected abstract virtual bool HasElseBlock(TIfStatementSyntax ifStatement);
    protected abstract virtual SyntaxNode GetDeclarationNode(TVariableDeclarator declarator);
    protected abstract virtual TExpressionSyntax GetConditionOfIfStatement(TIfStatementSyntax ifStatement);
    protected abstract virtual bool TryGetEmbeddedStatement(TIfStatementSyntax ifStatement, TStatementSyntax& whenTrueStatement);
    protected abstract virtual TStatementSyntax TryGetPreviousStatement(TIfStatementSyntax ifStatement);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeSyntax>g__AnalyzeLocalDeclarationForm|14_0(TStatementSyntax localDeclarationStatement, TExpressionSyntax& expressionToCoalesce, <>c__DisplayClass14_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeSyntax>g__IsLegalWhenTrueStatementForAssignment|14_2(SyntaxNode& whenPartToAnalyze, <>c__DisplayClass14_0& , <>c__DisplayClass14_1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeSyntax>g__AnalyzeAssignmentForm|14_1(TStatementSyntax assignmentStatement, TExpressionSyntax& expressionToCoalesce, <>c__DisplayClass14_0& );
}
internal static class Microsoft.CodeAnalysis.AnalyzersResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Remove_Unnecessary_Cast { get; }
    internal static string Remove_unused_member { get; }
    internal static string Private_member_0_is_unused { get; }
    internal static string Remove_unused_private_members { get; }
    internal static string Remove_unread_private_members { get; }
    internal static string Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read { get; }
    internal static string Private_method_0_can_be_removed_as_it_is_never_invoked { get; }
    internal static string Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked { get; }
    internal static string A_source_file_is_missing_a_required_header { get; }
    internal static string The_file_header_is_missing_or_not_located_at_the_top_of_the_file { get; }
    internal static string A_source_file_contains_a_header_that_does_not_match_the_required_text { get; }
    internal static string The_file_header_does_not_match_the_required_text { get; }
    internal static string Use_throw_expression { get; }
    internal static string Add_this_or_Me_qualification { get; }
    internal static string Member_access_should_be_qualified { get; }
    internal static string Null_check_can_be_simplified { get; }
    internal static string Simplify_collection_initialization { get; }
    internal static string Collection_initialization_can_be_simplified { get; }
    internal static string Simplify_object_initialization { get; }
    internal static string Object_initialization_can_be_simplified { get; }
    internal static string Add_readonly_modifier { get; }
    internal static string Make_field_readonly { get; }
    internal static string Naming_rule_violation_0 { get; }
    internal static string Naming_Styles { get; }
    internal static string Add_missing_cases { get; }
    internal static string Populate_switch { get; }
    internal static string Modifiers_are_not_ordered { get; }
    internal static string Order_modifiers { get; }
    internal static string Expression_value_is_never_used { get; }
    internal static string Unnecessary_assignment_of_a_value_to_0 { get; }
    internal static string Unnecessary_assignment_of_a_value { get; }
    internal static string Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc { get; }
    internal static string Remove_unused_parameter { get; }
    internal static string Remove_unused_parameter_0 { get; }
    internal static string Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names { get; }
    internal static string Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API { get; }
    internal static string Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used { get; }
    internal static string Parameter_0_can_be_removed_its_initial_value_is_never_used { get; }
    internal static string Add_accessibility_modifiers { get; }
    internal static string Accessibility_modifiers_required { get; }
    internal static string Convert_to_conditional_expression { get; }
    internal static string Use_coalesce_expression { get; }
    internal static string Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime { get; }
    internal static string Parentheses_can_be_removed { get; }
    internal static string Remove_unnecessary_parentheses { get; }
    internal static string Add_parentheses_for_clarity { get; }
    internal static string Parentheses_should_be_added_for_clarity { get; }
    internal static string Prefer_explicitly_provided_tuple_element_name { get; }
    internal static string Use_explicitly_provided_tuple_name { get; }
    internal static string Use_System_HashCode { get; }
    internal static string GetHashCode_implementation_can_be_simplified { get; }
    internal static string Use_compound_assignment { get; }
    internal static string Use_null_propagation { get; }
    internal static string Use_inferred_member_name { get; }
    internal static string Member_name_can_be_simplified { get; }
    internal static string Interpolation_can_be_simplified { get; }
    internal static string Simplify_interpolation { get; }
    internal static string Use_auto_property { get; }
    internal static string Format_string_contains_invalid_placeholder { get; }
    internal static string Invalid_format_string { get; }
    internal static string Simplify_conditional_expression { get; }
    internal static string Conditional_expression_can_be_simplified { get; }
    internal static string Invalid_global_SuppressMessageAttribute { get; }
    internal static string Invalid_scope_for_SuppressMessageAttribute { get; }
    internal static string Invalid_or_missing_target_for_SuppressMessageAttribute { get; }
    internal static string Avoid_legacy_format_target_in_SuppressMessageAttribute { get; }
    internal static string Avoid_legacy_format_target_0_in_SuppressMessageAttribute { get; }
    internal static string Remove_unnecessary_suppression { get; }
    internal static string Remove_redundant_equality { get; }
    internal static string Use_decrement_operator { get; }
    internal static string Use_increment_operator { get; }
    internal static string Avoid_multiple_blank_lines { get; }
    internal static string Blank_line_required_between_block_and_subsequent_statement { get; }
    internal static string Change_namespace_to_match_folder_structure { get; }
    internal static string Namespace_0_does_not_match_folder_structure_expected_1 { get; }
    internal static string Namespace_does_not_match_folder_structure { get; }
    internal static string Simplify_LINQ_expression { get; }
    internal static string Set_MSBuild_Property_GenerateDocumentationFile_to_true { get; }
    internal static string Set_MSBuild_Property_GenerateDocumentationFile_to_true_in_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build { get; }
    internal static string Add_the_following_PropertyGroup_to_your_MSBuild_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build { get; }
    internal static string Fix_formatting { get; }
    internal static string _0_statement_implicitly_converts_1_to_2_Add_an_explicit_cast_to_make_intent_clearer_as_it_may_fail_at_runtime { get; }
    internal static string Add_explicit_cast { get; }
    internal static string Name_can_be_simplified { get; }
    internal static string Simplify_Names { get; }
    internal static string Simplify_Member_Access { get; }
    internal static string Remove_accessibility_modifiers { get; }
    internal static string Simplify_check { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Remove_Unnecessary_Cast();
    internal static string get_Remove_unused_member();
    internal static string get_Private_member_0_is_unused();
    internal static string get_Remove_unused_private_members();
    internal static string get_Remove_unread_private_members();
    internal static string get_Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read();
    internal static string get_Private_method_0_can_be_removed_as_it_is_never_invoked();
    internal static string get_Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked();
    internal static string get_A_source_file_is_missing_a_required_header();
    internal static string get_The_file_header_is_missing_or_not_located_at_the_top_of_the_file();
    internal static string get_A_source_file_contains_a_header_that_does_not_match_the_required_text();
    internal static string get_The_file_header_does_not_match_the_required_text();
    internal static string get_Use_throw_expression();
    internal static string get_Add_this_or_Me_qualification();
    internal static string get_Member_access_should_be_qualified();
    internal static string get_Null_check_can_be_simplified();
    internal static string get_Simplify_collection_initialization();
    internal static string get_Collection_initialization_can_be_simplified();
    internal static string get_Simplify_object_initialization();
    internal static string get_Object_initialization_can_be_simplified();
    internal static string get_Add_readonly_modifier();
    internal static string get_Make_field_readonly();
    internal static string get_Naming_rule_violation_0();
    internal static string get_Naming_Styles();
    internal static string get_Add_missing_cases();
    internal static string get_Populate_switch();
    internal static string get_Modifiers_are_not_ordered();
    internal static string get_Order_modifiers();
    internal static string get_Expression_value_is_never_used();
    internal static string get_Unnecessary_assignment_of_a_value_to_0();
    internal static string get_Unnecessary_assignment_of_a_value();
    internal static string get_Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc();
    internal static string get_Remove_unused_parameter();
    internal static string get_Remove_unused_parameter_0();
    internal static string get_Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names();
    internal static string get_Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API();
    internal static string get_Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used();
    internal static string get_Parameter_0_can_be_removed_its_initial_value_is_never_used();
    internal static string get_Add_accessibility_modifiers();
    internal static string get_Accessibility_modifiers_required();
    internal static string get_Convert_to_conditional_expression();
    internal static string get_Use_coalesce_expression();
    internal static string get_Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime();
    internal static string get_Parentheses_can_be_removed();
    internal static string get_Remove_unnecessary_parentheses();
    internal static string get_Add_parentheses_for_clarity();
    internal static string get_Parentheses_should_be_added_for_clarity();
    internal static string get_Prefer_explicitly_provided_tuple_element_name();
    internal static string get_Use_explicitly_provided_tuple_name();
    internal static string get_Use_System_HashCode();
    internal static string get_GetHashCode_implementation_can_be_simplified();
    internal static string get_Use_compound_assignment();
    internal static string get_Use_null_propagation();
    internal static string get_Use_inferred_member_name();
    internal static string get_Member_name_can_be_simplified();
    internal static string get_Interpolation_can_be_simplified();
    internal static string get_Simplify_interpolation();
    internal static string get_Use_auto_property();
    internal static string get_Format_string_contains_invalid_placeholder();
    internal static string get_Invalid_format_string();
    internal static string get_Simplify_conditional_expression();
    internal static string get_Conditional_expression_can_be_simplified();
    internal static string get_Invalid_global_SuppressMessageAttribute();
    internal static string get_Invalid_scope_for_SuppressMessageAttribute();
    internal static string get_Invalid_or_missing_target_for_SuppressMessageAttribute();
    internal static string get_Avoid_legacy_format_target_in_SuppressMessageAttribute();
    internal static string get_Avoid_legacy_format_target_0_in_SuppressMessageAttribute();
    internal static string get_Remove_unnecessary_suppression();
    internal static string get_Remove_redundant_equality();
    internal static string get_Use_decrement_operator();
    internal static string get_Use_increment_operator();
    internal static string get_Avoid_multiple_blank_lines();
    internal static string get_Blank_line_required_between_block_and_subsequent_statement();
    internal static string get_Change_namespace_to_match_folder_structure();
    internal static string get_Namespace_0_does_not_match_folder_structure_expected_1();
    internal static string get_Namespace_does_not_match_folder_structure();
    internal static string get_Simplify_LINQ_expression();
    internal static string get_Set_MSBuild_Property_GenerateDocumentationFile_to_true();
    internal static string get_Set_MSBuild_Property_GenerateDocumentationFile_to_true_in_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build();
    internal static string get_Add_the_following_PropertyGroup_to_your_MSBuild_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build();
    internal static string get_Fix_formatting();
    internal static string get__0_statement_implicitly_converts_1_to_2_Add_an_explicit_cast_to_make_intent_clearer_as_it_may_fail_at_runtime();
    internal static string get_Add_explicit_cast();
    internal static string get_Name_can_be_simplified();
    internal static string get_Simplify_Names();
    internal static string get_Simplify_Member_Access();
    internal static string get_Remove_accessibility_modifiers();
    internal static string get_Simplify_check();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`3<T, A, bool> predicate, A arg);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`3<T, A, bool> predicate, A arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArrayWithIndex(ArrayBuilder`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static void AddOptional(ArrayBuilder`1<T> builder, T item);
    [ExtensionAttribute]
public static void Push(ArrayBuilder`1<T> builder, T e);
    [ExtensionAttribute]
public static T Pop(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static bool TryPop(ArrayBuilder`1<T> builder, T& result);
    [ExtensionAttribute]
public static T Peek(ArrayBuilder`1<T> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableOrEmptyAndFree(ArrayBuilder`1<T> builder);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, Nullable`1<T> value);
    [ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, T value);
    [ExtensionAttribute]
public static void FreeAll(ArrayBuilder`1<T> builder, Func`2<T, ArrayBuilder`1<T>> getNested);
}
internal static class Microsoft.CodeAnalysis.AssemblyIdentityUtils : object {
    [NullableContextAttribute("1")]
public static AssemblyIdentity TryGetAssemblyIdentity(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.BitVector : ValueType {
    private static ulong ZeroWord;
    private static int Log2BitsPerWord;
    public static int BitsPerWord;
    private static BitVector s_nullValue;
    private static BitVector s_emptyValue;
    private ulong _bits0;
    private UInt64[] _bits;
    private int _capacity;
    private static UInt64[] s_emptyArray { get; }
    public int Capacity { get; }
    public bool IsNull { get; }
    public static BitVector Null { get; }
    public static BitVector Empty { get; }
    public bool Item { get; public set; }
    private BitVector(ulong bits0, UInt64[] bits, int capacity);
    private static BitVector();
    private static UInt64[] get_s_emptyArray();
    public sealed virtual bool Equals(BitVector other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(BitVector left, BitVector right);
    public static bool op_Inequality(BitVector left, BitVector right);
    public virtual int GetHashCode();
    private static int WordsForCapacity(int capacity);
    public int get_Capacity();
    [ConditionalAttribute("DEBUG_BITARRAY")]
private void Check();
    public void EnsureCapacity(int newCapacity);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<Words>d__21")]
public IEnumerable`1<ulong> Words();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<TrueBits>d__22")]
public IEnumerable`1<int> TrueBits();
    public static BitVector FromWords(ulong bits0, UInt64[] bits, int capacity);
    public static BitVector Create(int capacity);
    public static BitVector AllSet(int capacity);
    public BitVector Clone();
    public void Invert();
    public bool get_IsNull();
    public static BitVector get_Null();
    public static BitVector get_Empty();
    public bool IntersectWith(BitVector& other);
    public bool UnionWith(BitVector& other);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public void Clear();
    public static bool IsTrue(ulong word, int index);
    public static int WordsRequired(int capacity);
    internal string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Boxes : object {
    public static object BoxedTrue;
    public static object BoxedFalse;
    public static object BoxedByteZero;
    public static object BoxedSByteZero;
    public static object BoxedInt16Zero;
    public static object BoxedUInt16Zero;
    public static object BoxedInt32Zero;
    public static object BoxedInt32One;
    public static object BoxedUInt32Zero;
    public static object BoxedInt64Zero;
    public static object BoxedUInt64Zero;
    public static object BoxedSingleZero;
    public static object BoxedDoubleZero;
    public static object BoxedDecimalZero;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Object[] s_boxedAsciiChars;
    private static Boxes();
    public static object Box(bool b);
    public static object Box(byte b);
    public static object Box(sbyte sb);
    public static object Box(short s);
    public static object Box(ushort us);
    public static object Box(int i);
    public static object Box(UInt32 u);
    public static object Box(long l);
    public static object Box(ulong ul);
    public static object Box(float f);
    public static object Box(double d);
    public static object Box(char c);
    public static object Box(decimal d);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions : object {
    [CompilerGeneratedAttribute]
private SyntaxFormattingOptions <FormattingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SimplifierOptions <SimplifierOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AddImportPlacementOptions <AddImportOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentFormattingOptions <DocumentFormattingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [RequiredMemberAttribute]
[DataMemberAttribute]
public SyntaxFormattingOptions FormattingOptions { get; public set; }
    [RequiredMemberAttribute]
[DataMemberAttribute]
public SimplifierOptions SimplifierOptions { get; public set; }
    [DataMemberAttribute]
public AddImportPlacementOptions AddImportOptions { get; public set; }
    [DataMemberAttribute]
public DocumentFormattingOptions DocumentFormattingOptions { get; public set; }
    [CompilerGeneratedAttribute]
[SetsRequiredMembersAttribute]
private CodeCleanupOptions(CodeCleanupOptions original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public SyntaxFormattingOptions get_FormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormattingOptions(SyntaxFormattingOptions value);
    [CompilerGeneratedAttribute]
public SimplifierOptions get_SimplifierOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SimplifierOptions(SimplifierOptions value);
    [CompilerGeneratedAttribute]
public AddImportPlacementOptions get_AddImportOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AddImportOptions(AddImportPlacementOptions value);
    [CompilerGeneratedAttribute]
public DocumentFormattingOptions get_DocumentFormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocumentFormattingOptions(DocumentFormattingOptions value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CodeCleanupOptions left, CodeCleanupOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CodeCleanupOptions left, CodeCleanupOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeCleanupOptions other);
    [CompilerGeneratedAttribute]
public CodeCleanupOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptionsProvider {
}
internal static class Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptionsProviders : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[RequiredMemberAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptions : ValueType {
    [CompilerGeneratedAttribute]
private CodeGenerationOptions <GenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCleanupOptions <CleanupOptions>k__BackingField;
    [RequiredMemberAttribute]
[DataMemberAttribute]
public CodeGenerationOptions GenerationOptions { get; public set; }
    [RequiredMemberAttribute]
[DataMemberAttribute]
public CodeCleanupOptions CleanupOptions { get; public set; }
    [CompilerGeneratedAttribute]
public CodeGenerationOptions get_GenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GenerationOptions(CodeGenerationOptions value);
    [CompilerGeneratedAttribute]
public CodeCleanupOptions get_CleanupOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CleanupOptions(CodeCleanupOptions value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CleanCodeGenerationOptions left, CleanCodeGenerationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CleanCodeGenerationOptions left, CleanCodeGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CleanCodeGenerationOptions other);
}
internal interface Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[RequiredMemberAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeAndImportGenerationOptions : ValueType {
    [CompilerGeneratedAttribute]
private CodeGenerationOptions <GenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AddImportPlacementOptions <AddImportOptions>k__BackingField;
    [RequiredMemberAttribute]
[DataMemberAttribute]
public CodeGenerationOptions GenerationOptions { get; public set; }
    [RequiredMemberAttribute]
[DataMemberAttribute]
public AddImportPlacementOptions AddImportOptions { get; public set; }
    [CompilerGeneratedAttribute]
public CodeGenerationOptions get_GenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GenerationOptions(CodeGenerationOptions value);
    [CompilerGeneratedAttribute]
public AddImportPlacementOptions get_AddImportOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AddImportOptions(AddImportPlacementOptions value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CodeAndImportGenerationOptions left, CodeAndImportGenerationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CodeAndImportGenerationOptions left, CodeAndImportGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeAndImportGenerationOptions other);
}
internal interface Microsoft.CodeAnalysis.CodeGeneration.CodeAndImportGenerationOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions : object {
    internal static CodeGenerationOptions CommonDefaults;
    [CompilerGeneratedAttribute]
private NamingStylePreferences <NamingStyle>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public NamingStylePreferences NamingStyle { get; public set; }
    private protected CodeGenerationOptions(IOptionsReader options, CodeGenerationOptions fallbackOptions, string language);
    [CompilerGeneratedAttribute]
protected CodeGenerationOptions(CodeGenerationOptions original);
    private static CodeGenerationOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public NamingStylePreferences get_NamingStyle();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamingStyle(NamingStylePreferences value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CodeGenerationOptions left, CodeGenerationOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CodeGenerationOptions left, CodeGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(CodeGenerationOptions other);
    [CompilerGeneratedAttribute]
public virtual CodeGenerationOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptionsProvider {
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptionsProviders : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeQuality.AbstractCodeQualityDiagnosticAnalyzer : DiagnosticAnalyzer {
    private GeneratedCodeAnalysisFlags _generatedCodeAnalysisFlags;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public bool IsHighPriority { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected AbstractCodeQualityDiagnosticAnalyzer(ImmutableArray`1<DiagnosticDescriptor> descriptors, GeneratedCodeAnalysisFlags generatedCodeAnalysisFlags);
    public sealed virtual bool get_IsHighPriority();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    protected abstract virtual void InitializeWorker(AnalysisContext context);
    public abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("2")]
public sealed virtual bool OpenFileOnly(SimplifierOptions options);
    protected static DiagnosticDescriptor CreateDescriptor(string id, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString messageFormat, bool hasAnyCodeStyleOption, bool isUnnecessary, bool isEnabledByDefault, bool isConfigurable, LocalizableString description);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer : DiagnosticAnalyzer {
    protected DiagnosticDescriptor Descriptor;
    private Nullable`1<DiagnosticSeverity> _minimumReportedSeverity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public bool IsHighPriority { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, IOption2 option, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, ImmutableHashSet`1<IOption2> options, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, IOption2>> supportedDiagnosticsWithOptions);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, ImmutableHashSet`1<IOption2>>> supportedDiagnosticsWithOptions);
    private AbstractBuiltInCodeStyleDiagnosticAnalyzer(string descriptorId, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable, bool hasAnyCodeStyleOption);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics);
    private static void AddDiagnosticIdToOptionMapping(string diagnosticId, IOption2 option);
    private static void AddDiagnosticIdToOptionMapping(string diagnosticId, ImmutableHashSet`1<IOption2> options);
    public abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    public virtual bool get_IsHighPriority();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected static DiagnosticDescriptor CreateDescriptorWithId(string id, EnforceOnBuild enforceOnBuild, bool hasAnyCodeStyleOption, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool isConfigurable, LocalizableString description);
    protected virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    public sealed virtual void Initialize(AnalysisContext context);
    protected abstract virtual void InitializeWorker(AnalysisContext context);
    protected static bool IsAnalysisLevelGreaterThanOrEquals(int minAnalysisLevel, AnalyzerOptions analyzerOptions);
    protected bool ShouldSkipAnalysis(SemanticModelAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(SyntaxNodeAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(CodeBlockAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(OperationAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(OperationBlockAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(SyntaxTree tree, AnalyzerOptions analyzerOptions, CompilationOptions compilationOptions, Nullable`1<NotificationOption2> notification, CancellationToken cancellationToken);
    protected bool ShouldSkipAnalysis(SyntaxTree tree, AnalyzerOptions analyzerOptions, CompilationOptions compilationOptions, ImmutableArray`1<NotificationOption2> notifications, CancellationToken cancellationToken);
    private bool ShouldSkipAnalysis(SyntaxTree tree, AnalyzerOptions analyzerOptions, CompilationOptions compilationOptions, Nullable`1<NotificationOption2> notification, bool performDescriptorsCheck, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableContextAttribute("2")]
protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, IOption2 option, PerLanguageOption2`1<bool> fadingOption, LocalizableString title, LocalizableString messageFormat, bool configurable);
    protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, ImmutableHashSet`1<IOption2> options, PerLanguageOption2`1<bool> fadingOption, LocalizableString title, LocalizableString messageFormat, bool configurable);
    protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(ImmutableArray`1<DiagnosticDescriptor> descriptors, PerLanguageOption2`1<bool> fadingOption);
    [NullableContextAttribute("2")]
protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, IOption2>> supportedDiagnosticsWithOptions, PerLanguageOption2`1<bool> fadingOption);
    [NullableContextAttribute("2")]
protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, ImmutableHashSet`1<IOption2>>> supportedDiagnosticsWithOptions, PerLanguageOption2`1<bool> fadingOption);
    private static void AddDiagnosticIdToFadingOptionMapping(string diagnosticId, PerLanguageOption2`1<bool> fadingOption);
    private static void AddDescriptorsToFadingOptionMapping(IEnumerable`1<DiagnosticDescriptor> descriptors, PerLanguageOption2`1<bool> fadingOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ISyntaxFormatting SyntaxFormatting { get; }
    public bool IsHighPriority { get; }
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFormatting get_SyntaxFormatting();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    public virtual bool get_IsHighPriority();
    private void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext context);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.AccessibilityModifiersRequired : Enum {
    public int value__;
    public static AccessibilityModifiersRequired Never;
    public static AccessibilityModifiersRequired Always;
    public static AccessibilityModifiersRequired ForNonInterfaceMembers;
    public static AccessibilityModifiersRequired OmitIfDefault;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeStyle.CodeStyleHelpers : object {
    private static CodeStyleOption2`1<UnusedValuePreference> s_preferNoneUnusedValuePreference;
    private static BidirectionalMap`2<string, UnusedValuePreference> s_unusedExpressionAssignmentPreferenceMap;
    private static CodeStyleHelpers();
    public static bool TryParseStringEditorConfigCodeStyleOption(string arg, CodeStyleOption2`1<string> defaultValue, CodeStyleOption2`1& option);
    public static bool TryParseBoolEditorConfigCodeStyleOption(string arg, CodeStyleOption2`1<bool> defaultValue, CodeStyleOption2`1& option);
    public static bool TryGetCodeStyleValue(string arg, String& value);
    public static bool TryGetCodeStyleValueAndOptionalNotification(string arg, NotificationOption2 defaultNotification, String& value, NotificationOption2& notification);
    [NullableContextAttribute("0")]
private static bool TryParseNotification(ReadOnlySpan`1<char> value, NotificationOption2& notification);
    [ExtensionAttribute]
public static Option2`1<CodeStyleOption2`1<T>> CreateEditorConfigOption(Builder<IOption2> optionsBuilder, string name, CodeStyleOption2`1<T> defaultValue, OptionGroup group, string languageName, Func`2<CodeStyleOption2`1<T>, EditorConfigValueSerializer`1<CodeStyleOption2`1<T>>> serializerFactory);
    [ExtensionAttribute]
public static Option2`1<T> CreateEditorConfigOption(Builder<IOption2> optionsBuilder, string name, T defaultValue, OptionGroup group, EditorConfigValueSerializer`1<T> serializer);
    [ExtensionAttribute]
public static PerLanguageOption2`1<CodeStyleOption2`1<T>> CreatePerLanguageEditorConfigOption(Builder<IOption2> optionsBuilder, string name, CodeStyleOption2`1<T> defaultValue, OptionGroup group, Func`2<CodeStyleOption2`1<T>, EditorConfigValueSerializer`1<CodeStyleOption2`1<T>>> serializerFactory);
    internal static EditorConfigValueSerializer`1<CodeStyleOption2`1<UnusedValuePreference>> GetUnusedValuePreferenceSerializer(CodeStyleOption2`1<UnusedValuePreference> defaultValue);
    private static Optional`1<CodeStyleOption2`1<UnusedValuePreference>> ParseUnusedExpressionAssignmentPreference(string optionString, CodeStyleOption2`1<UnusedValuePreference> defaultCodeStyleOption);
    private static string GetUnusedExpressionAssignmentPreferenceEditorConfigString(CodeStyleOption2`1<UnusedValuePreference> option, CodeStyleOption2`1<UnusedValuePreference> defaultValue);
    internal static string GetEditorConfigStringNotificationPart(CodeStyleOption2`1<T> option, CodeStyleOption2`1<T> defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2 : object {
    public static CodeStyleOption2`1<bool> TrueWithSilentEnforcement;
    public static CodeStyleOption2`1<bool> FalseWithSilentEnforcement;
    public static CodeStyleOption2`1<bool> TrueWithSuggestionEnforcement;
    public static CodeStyleOption2`1<bool> FalseWithSuggestionEnforcement;
    private static CodeStyleOption2();
    public static CodeStyleOption2`1<bool> GetCodeStyle(bool value, NotificationOption2 notification);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2`1 : object {
    public static CodeStyleOption2`1<T> Default;
    private static int SerializationVersion;
    private static string XmlElement_CodeStyleOption;
    private static string XmlAttribute_SerializationVersion;
    private static string XmlAttribute_Type;
    private static string XmlAttribute_Value;
    private static string XmlAttribute_DiagnosticSeverity;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationOption2 <Notification>k__BackingField;
    [DataMemberAttribute]
public T Value { get; }
    [DataMemberAttribute]
public NotificationOption2 Notification { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2.Value { get; }
    private int EnumValueAsInt32 { get; }
    public CodeStyleOption2`1(T value, NotificationOption2 notification);
    private static CodeStyleOption2`1();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual NotificationOption2 get_Notification();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2.get_Value();
    private sealed virtual override ICodeStyleOption2 Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2.WithValue(object value);
    private sealed virtual override ICodeStyleOption2 Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2.WithNotification(NotificationOption2 notification);
    public CodeStyleOption2`1<T> WithValue(T value);
    private int get_EnumValueAsInt32();
    public sealed virtual XElement ToXElement();
    private object GetValueForSerialization();
    private string GetTypeNameForSerialization();
    private bool IsZeroOrOneValueOfEnum();
    private sealed virtual override ICodeStyleOption2 Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2.FromXElement(XElement element);
    public static CodeStyleOption2`1<T> FromXElement(XElement element);
    private static Func`2<string, T> GetParser(string type);
    private static T Convert(bool b);
    private static T Convert(int i);
    public sealed virtual bool Equals(CodeStyleOption2`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptionGroups : object {
    public static OptionGroup CodeStyle;
    public static OptionGroup Usings;
    public static OptionGroup ThisOrMe;
    public static OptionGroup PredefinedTypeNameUsage;
    public static OptionGroup Parentheses;
    public static OptionGroup Modifier;
    public static OptionGroup ExpressionLevelPreferences;
    public static OptionGroup Field;
    public static OptionGroup Parameter;
    public static OptionGroup Suppressions;
    public static OptionGroup NewLinePreferences;
    private static CodeStyleOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2 : object {
    private static string PublicFeatureName;
    private static Builder<IOption2> s_editorConfigOptionsBuilder;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> QualifyFieldAccess;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> QualifyPropertyAccess;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> QualifyMethodAccess;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> QualifyEventAccess;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferIntrinsicPredefinedTypeKeywordInDeclaration;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferIntrinsicPredefinedTypeKeywordInMemberAccess;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferObjectInitializer;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferCollectionInitializer;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<CollectionExpressionPreference>> PreferCollectionExpression;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferSimplifiedBooleanExpressions;
    internal static Option2`1<OperatorPlacementWhenWrappingPreference> OperatorPlacementWhenWrapping;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferCoalesceExpression;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferNullPropagation;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferExplicitTupleNames;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferAutoProperties;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferInferredTupleNames;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferInferredAnonymousTypeMemberNames;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferIsNullCheckOverReferenceEqualityMethod;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferConditionalExpressionOverAssignment;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferConditionalExpressionOverReturn;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferCompoundAssignment;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferSimplifiedInterpolation;
    private static BidirectionalMap`2<string, UnusedParametersPreference> s_unusedParametersPreferenceMap;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<UnusedParametersPreference>> UnusedParameters;
    private static BidirectionalMap`2<string, AccessibilityModifiersRequired> s_accessibilityModifiersRequiredMap;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<AccessibilityModifiersRequired>> AccessibilityModifiersRequired;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferReadonly;
    internal static Option2`1<string> FileHeaderTemplate;
    internal static Option2`1<string> RemoveUnnecessarySuppressionExclusions;
    private static BidirectionalMap`2<string, ParenthesesPreference> s_parenthesesPreferenceMap;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> ArithmeticBinaryParentheses;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> OtherBinaryParentheses;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> RelationalBinaryParentheses;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> OtherParentheses;
    private static BidirectionalMap`2<string, ForEachExplicitCastInSourcePreference> s_forEachExplicitCastInSourcePreferencePreferenceMap;
    internal static Option2`1<CodeStyleOption2`1<ForEachExplicitCastInSourcePreference>> ForEachExplicitCastInSource;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferSystemHashCode;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferNamespaceAndFolderMatchStructure;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> AllowMultipleBlankLines;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> AllowStatementImmediatelyAfterBlock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> EditorConfigOptions;
    private static CodeStyleOptions2();
    private static PerLanguageOption2`1<CodeStyleOption2`1<T>> CreatePerLanguageOption(OptionGroup group, string name, CodeStyleOption2`1<T> defaultValue, Func`2<CodeStyleOption2`1<T>, EditorConfigValueSerializer`1<CodeStyleOption2`1<T>>> serializerFactory);
    private static Option2`1<CodeStyleOption2`1<T>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<T> defaultValue, Func`2<CodeStyleOption2`1<T>, EditorConfigValueSerializer`1<CodeStyleOption2`1<T>>> serializerFactory);
    private static Option2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, EditorConfigValueSerializer`1<T> serializer);
    private static PerLanguageOption2`1<CodeStyleOption2`1<bool>> CreateQualifyAccessOption(string name);
    private static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> CreateParenthesesOption(CodeStyleOption2`1<ParenthesesPreference> defaultValue, string name);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild : Enum {
    public int value__;
    public static EnforceOnBuild Never;
    public static EnforceOnBuild WhenExplicitlyEnabled;
    public static EnforceOnBuild Recommended;
    public static EnforceOnBuild HighlyRecommended;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuildExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToCustomTag(EnforceOnBuild enforceOnBuild);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.ExpressionBodyPreference : Enum {
    public int value__;
    public static ExpressionBodyPreference Never;
    public static ExpressionBodyPreference WhenPossible;
    public static ExpressionBodyPreference WhenOnSingleLine;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.FadingOptions : object {
    public static PerLanguageOption2`1<bool> FadeOutUnusedImports;
    public static PerLanguageOption2`1<bool> FadeOutUnreachableCode;
    private static FadingOptions();
}
internal enum Microsoft.CodeAnalysis.CodeStyle.ForEachExplicitCastInSourcePreference : Enum {
    public int value__;
    public static ForEachExplicitCastInSourcePreference Always;
    public static ForEachExplicitCastInSourcePreference WhenStronglyTyped;
}
internal static class Microsoft.CodeAnalysis.CodeStyle.FormattingAnalyzerHelper : object {
    internal static void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context, ISyntaxFormatting formattingProvider, DiagnosticDescriptor descriptor, SyntaxFormattingOptions options);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption2 {
    [NullableAttribute("2")]
public object Value { get; }
    public NotificationOption2 Notification { get; }
    public abstract virtual XElement ToXElement();
    [NullableContextAttribute("2")]
public abstract virtual object get_Value();
    public abstract virtual NotificationOption2 get_Notification();
    public abstract virtual ICodeStyleOption2 WithValue(object value);
    public abstract virtual ICodeStyleOption2 WithNotification(NotificationOption2 notification);
    public abstract virtual ICodeStyleOption2 FromXElement(XElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeStyle.IdeCodeStyleOptions : object {
    private static CodeStyleOption2`1<UnusedParametersPreference> s_preferAllMethodsUnusedParametersPreference;
    private static CodeStyleOption2`1<AccessibilityModifiersRequired> s_accessibilityModifiersRequiredDefault;
    private static CodeStyleOption2`1<ParenthesesPreference> s_alwaysForClarityPreference;
    private static CodeStyleOption2`1<ParenthesesPreference> s_neverIfUnnecessaryPreference;
    private static CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> s_forEachExplicitCastInSourceNonLegacyPreference;
    internal static IdeCodeStyleOptions CommonDefaults;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferObjectInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<CollectionExpressionPreference> <PreferCollectionExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferCollectionInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSimplifiedBooleanExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private OperatorPlacementWhenWrappingPreference <OperatorPlacementWhenWrapping>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferCoalesceExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferNullPropagation>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferExplicitTupleNames>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferAutoProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferInferredTupleNames>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferInferredAnonymousTypeMemberNames>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferIsNullCheckOverReferenceEqualityMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferConditionalExpressionOverAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferConditionalExpressionOverReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferCompoundAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSimplifiedInterpolation>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<UnusedParametersPreference> <UnusedParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<AccessibilityModifiersRequired> <AccessibilityModifiersRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferReadonly>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ParenthesesPreference> <ArithmeticBinaryParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ParenthesesPreference> <OtherBinaryParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ParenthesesPreference> <RelationalBinaryParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ParenthesesPreference> <OtherParentheses>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> <ForEachExplicitCastInSource>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferNamespaceAndFolderMatchStructure>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowMultipleBlankLines>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <AllowStatementImmediatelyAfterBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoveUnnecessarySuppressionExclusions>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferObjectInitializer { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<CollectionExpressionPreference> PreferCollectionExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferCollectionInitializer { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSimplifiedBooleanExpressions { get; public set; }
    [DataMemberAttribute]
public OperatorPlacementWhenWrappingPreference OperatorPlacementWhenWrapping { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferCoalesceExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferNullPropagation { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferExplicitTupleNames { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferAutoProperties { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferInferredTupleNames { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferInferredAnonymousTypeMemberNames { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferIsNullCheckOverReferenceEqualityMethod { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferConditionalExpressionOverAssignment { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferConditionalExpressionOverReturn { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferCompoundAssignment { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSimplifiedInterpolation { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<UnusedParametersPreference> UnusedParameters { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<AccessibilityModifiersRequired> AccessibilityModifiersRequired { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferReadonly { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ParenthesesPreference> ArithmeticBinaryParentheses { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ParenthesesPreference> OtherBinaryParentheses { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ParenthesesPreference> RelationalBinaryParentheses { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ParenthesesPreference> OtherParentheses { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> ForEachExplicitCastInSource { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferNamespaceAndFolderMatchStructure { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowMultipleBlankLines { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> AllowStatementImmediatelyAfterBlock { get; public set; }
    [DataMemberAttribute]
public string RemoveUnnecessarySuppressionExclusions { get; public set; }
    private protected IdeCodeStyleOptions(IOptionsReader options, IdeCodeStyleOptions fallbackOptions, string language);
    [CompilerGeneratedAttribute]
protected IdeCodeStyleOptions(IdeCodeStyleOptions original);
    private static IdeCodeStyleOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferObjectInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferObjectInitializer(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<CollectionExpressionPreference> get_PreferCollectionExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferCollectionExpression(CodeStyleOption2`1<CollectionExpressionPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferCollectionInitializer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferCollectionInitializer(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSimplifiedBooleanExpressions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSimplifiedBooleanExpressions(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public OperatorPlacementWhenWrappingPreference get_OperatorPlacementWhenWrapping();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OperatorPlacementWhenWrapping(OperatorPlacementWhenWrappingPreference value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferCoalesceExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferCoalesceExpression(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferNullPropagation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferNullPropagation(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferExplicitTupleNames();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferExplicitTupleNames(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferAutoProperties();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferAutoProperties(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferInferredTupleNames();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferInferredTupleNames(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferInferredAnonymousTypeMemberNames();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferInferredAnonymousTypeMemberNames(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferIsNullCheckOverReferenceEqualityMethod();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferIsNullCheckOverReferenceEqualityMethod(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferConditionalExpressionOverAssignment();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferConditionalExpressionOverAssignment(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferConditionalExpressionOverReturn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferConditionalExpressionOverReturn(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferCompoundAssignment();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferCompoundAssignment(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSimplifiedInterpolation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSimplifiedInterpolation(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<UnusedParametersPreference> get_UnusedParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnusedParameters(CodeStyleOption2`1<UnusedParametersPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<AccessibilityModifiersRequired> get_AccessibilityModifiersRequired();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AccessibilityModifiersRequired(CodeStyleOption2`1<AccessibilityModifiersRequired> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferReadonly();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferReadonly(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ParenthesesPreference> get_ArithmeticBinaryParentheses();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ArithmeticBinaryParentheses(CodeStyleOption2`1<ParenthesesPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ParenthesesPreference> get_OtherBinaryParentheses();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OtherBinaryParentheses(CodeStyleOption2`1<ParenthesesPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ParenthesesPreference> get_RelationalBinaryParentheses();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RelationalBinaryParentheses(CodeStyleOption2`1<ParenthesesPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ParenthesesPreference> get_OtherParentheses();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OtherParentheses(CodeStyleOption2`1<ParenthesesPreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> get_ForEachExplicitCastInSource();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForEachExplicitCastInSource(CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferNamespaceAndFolderMatchStructure();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferNamespaceAndFolderMatchStructure(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowMultipleBlankLines();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowMultipleBlankLines(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_AllowStatementImmediatelyAfterBlock();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowStatementImmediatelyAfterBlock(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_RemoveUnnecessarySuppressionExclusions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RemoveUnnecessarySuppressionExclusions(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(IdeCodeStyleOptions left, IdeCodeStyleOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(IdeCodeStyleOptions left, IdeCodeStyleOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(IdeCodeStyleOptions other);
    [CompilerGeneratedAttribute]
public virtual IdeCodeStyleOptions <Clone>$();
}
internal enum Microsoft.CodeAnalysis.CodeStyle.NamespaceDeclarationPreference : Enum {
    public int value__;
    public static NamespaceDeclarationPreference BlockScoped;
    public static NamespaceDeclarationPreference FileScoped;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.NamingStyleOptions : object {
    public static string NamingPreferencesOptionName;
    [CompilerGeneratedAttribute]
private static PerLanguageOption2`1<NamingStylePreferences> <NamingPreferences>k__BackingField;
    internal static PerLanguageOption2`1<NamingStylePreferences> NamingPreferences { get; }
    private static NamingStyleOptions();
    [CompilerGeneratedAttribute]
internal static PerLanguageOption2`1<NamingStylePreferences> get_NamingPreferences();
}
internal interface Microsoft.CodeAnalysis.CodeStyle.NamingStylePreferencesProvider {
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeStyle.NotificationOption2 : ValueType {
    [CompilerGeneratedAttribute]
private ReportDiagnostic <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExplicitlySpecified>k__BackingField;
    [DataMemberAttribute]
public ReportDiagnostic Severity { get; public set; }
    [DataMemberAttribute]
public bool IsExplicitlySpecified { get; public set; }
    public static NotificationOption2 None { get; }
    public static NotificationOption2 Silent { get; }
    public static NotificationOption2 Suggestion { get; }
    public static NotificationOption2 Warning { get; }
    public static NotificationOption2 Error { get; }
    public NotificationOption2(ReportDiagnostic Severity, bool IsExplicitlySpecified);
    [CompilerGeneratedAttribute]
public ReportDiagnostic get_Severity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Severity(ReportDiagnostic value);
    [CompilerGeneratedAttribute]
public bool get_IsExplicitlySpecified();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsExplicitlySpecified(bool value);
    public static NotificationOption2 get_None();
    public static NotificationOption2 get_Silent();
    public static NotificationOption2 get_Suggestion();
    public static NotificationOption2 get_Warning();
    public static NotificationOption2 get_Error();
    public NotificationOption2 WithIsExplicitlySpecified(bool isExplicitlySpecified);
    public static NotificationOption2 ForSeverity(ReportDiagnostic reportDiagnostic);
    public static NotificationOption2 ForSeverity(DiagnosticSeverity severity);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NotificationOption2 left, NotificationOption2 right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NotificationOption2 left, NotificationOption2 right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NotificationOption2 other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ReportDiagnostic& Severity, Boolean& IsExplicitlySpecified);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeStyle.NotificationOptionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToEditorConfigString(NotificationOption2 notificationOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.OperatorPlacementUtilities : object {
    private static string end_of_line;
    private static string beginning_of_line;
    public static string GetEditorConfigString(OperatorPlacementWhenWrappingPreference value);
    [NullableContextAttribute("0")]
public static Optional`1<OperatorPlacementWhenWrappingPreference> Parse(string optionString, OperatorPlacementWhenWrappingPreference defaultValue);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.OperatorPlacementWhenWrappingPreference : Enum {
    public int value__;
    public static OperatorPlacementWhenWrappingPreference BeginningOfLine;
    public static OperatorPlacementWhenWrappingPreference EndOfLine;
}
internal enum Microsoft.CodeAnalysis.CodeStyle.ParenthesesPreference : Enum {
    public int value__;
    public static ParenthesesPreference AlwaysForClarity;
    public static ParenthesesPreference NeverIfUnnecessary;
}
internal enum Microsoft.CodeAnalysis.CodeStyle.UnusedParametersPreference : Enum {
    public int value__;
    public static UnusedParametersPreference NonPublicMethods;
    public static UnusedParametersPreference AllMethods;
}
internal enum Microsoft.CodeAnalysis.CodeStyle.UnusedValuePreference : Enum {
    public int value__;
    public static UnusedValuePreference UnusedLocalVariable;
    public static UnusedValuePreference DiscardVariable;
}
internal static class Microsoft.CodeAnalysis.CodeStyleResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string A_language_name_cannot_be_specified_for_this_option { get; }
    internal static string A_language_name_must_be_specified_for_this_option { get; }
    internal static string Indentation_and_spacing { get; }
    internal static string New_line_preferences { get; }
    internal static string Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer { get; }
    internal static string Stream_is_too_long { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_A_language_name_cannot_be_specified_for_this_option();
    internal static string get_A_language_name_must_be_specified_for_this_option();
    internal static string get_Indentation_and_spacing();
    internal static string get_New_line_preferences();
    internal static string get_Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer();
    internal static string get_Stream_is_too_long();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary : object {
    public static ImmutableSegmentedDictionary`2<TKey, TValue> Create();
    public static ImmutableSegmentedDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(Builder<TKey, TValue> builder);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TSource> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TSource> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedDictionary`2<TKey, TValue> Empty;
    private SegmentedDictionary`2<TKey, TValue> _dictionary;
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsDefault { get; }
    public bool IsDefaultOrEmpty { get; }
    [NullableAttribute("0")]
public KeyCollection<TKey, TValue> Keys { get; }
    [NullableAttribute("0")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ImmutableSegmentedDictionary`2(SegmentedDictionary`2<TKey, TValue> dictionary);
    private static ImmutableSegmentedDictionary`2();
    public IEqualityComparer`1<TKey> get_KeyComparer();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public bool get_IsDefault();
    public bool get_IsDefaultOrEmpty();
    [NullableContextAttribute("0")]
public KeyCollection<TKey, TValue> get_Keys();
    [NullableContextAttribute("0")]
public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public static bool op_Equality(ImmutableSegmentedDictionary`2<TKey, TValue> left, ImmutableSegmentedDictionary`2<TKey, TValue> right);
    public static bool op_Inequality(ImmutableSegmentedDictionary`2<TKey, TValue> left, ImmutableSegmentedDictionary`2<TKey, TValue> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> left, Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> left, Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> right);
    public ImmutableSegmentedDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableSegmentedDictionary`2<TKey, TValue> Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    public ImmutableSegmentedDictionary`2<TKey, TValue> Remove(TKey key);
    public ImmutableSegmentedDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableSegmentedDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> WithComparer(IEqualityComparer`1<TKey> keyComparer);
    public Builder<TKey, TValue> ToBuilder();
    [NullableContextAttribute("0")]
private ValueBuilder<TKey, TValue> ToValueBuilder();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedDictionary`2<TKey, TValue> other);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private static bool TryCastToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, ImmutableSegmentedDictionary`2& other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet : object {
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> Create();
    public static ImmutableSegmentedHashSet`1<T> Create(T item);
    public static ImmutableSegmentedHashSet`1<T> Create(T[] items);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T item);
    public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T[] items);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableSegmentedHashSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableSegmentedHashSet`1<T> CreateRange(IEqualityComparer`1<T> equalityComparer, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> equalityComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(Builder<TSource> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedHashSet`1<T> Empty;
    private SegmentedHashSet`1<T> _set;
    public IEqualityComparer`1<T> KeyComparer { get; }
    public int Count { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ImmutableSegmentedHashSet`1(SegmentedHashSet`1<T> set);
    private static ImmutableSegmentedHashSet`1();
    public IEqualityComparer`1<T> get_KeyComparer();
    public sealed virtual int get_Count();
    public bool get_IsDefault();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public static bool op_Equality(ImmutableSegmentedHashSet`1<T> left, ImmutableSegmentedHashSet`1<T> right);
    public static bool op_Inequality(ImmutableSegmentedHashSet`1<T> left, ImmutableSegmentedHashSet`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedHashSet`1<T>> left, Nullable`1<ImmutableSegmentedHashSet`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedHashSet`1<T>> left, Nullable`1<ImmutableSegmentedHashSet`1<T>> right);
    public ImmutableSegmentedHashSet`1<T> Add(T value);
    public ImmutableSegmentedHashSet`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableSegmentedHashSet`1<T> Except(IEnumerable`1<T> other);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public ImmutableSegmentedHashSet`1<T> Intersect(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public ImmutableSegmentedHashSet`1<T> Remove(T value);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public ImmutableSegmentedHashSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableSegmentedHashSet`1<T> Union(IEnumerable`1<T> other);
    public Builder<T> ToBuilder();
    [NullableContextAttribute("0")]
private ValueBuilder<T> ToValueBuilder();
    public ImmutableSegmentedHashSet`1<T> WithComparer(IEqualityComparer`1<T> equalityComparer);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedHashSet`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList : object {
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> Create();
    public static ImmutableSegmentedList`1<T> Create(T item);
    public static ImmutableSegmentedList`1<T> Create(T[] items);
    public static Builder<T> CreateBuilder();
    public static ImmutableSegmentedList`1<T> CreateRange(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableSegmentedList`1<T> ToImmutableSegmentedList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableSegmentedList`1<T> ToImmutableSegmentedList(Builder<T> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedList`1<T> Empty;
    private SegmentedList`1<T> _list;
    public int Count { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private ImmutableSegmentedList`1(SegmentedList`1<T> list);
    private static ImmutableSegmentedList`1();
    public sealed virtual int get_Count();
    public bool get_IsDefault();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public static bool op_Equality(ImmutableSegmentedList`1<T> left, ImmutableSegmentedList`1<T> right);
    public static bool op_Inequality(ImmutableSegmentedList`1<T> left, ImmutableSegmentedList`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedList`1<T>> left, Nullable`1<ImmutableSegmentedList`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedList`1<T>> left, Nullable`1<ImmutableSegmentedList`1<T>> right);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public ImmutableSegmentedList`1<T> Add(T value);
    public ImmutableSegmentedList`1<T> AddRange(IEnumerable`1<T> items);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public ImmutableSegmentedList`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableSegmentedList`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public ImmutableSegmentedList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public ImmutableSegmentedList`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T value);
    public sealed virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Insert(int index, T item);
    public ImmutableSegmentedList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public sealed virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Remove(T value);
    public ImmutableSegmentedList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableSegmentedList`1<T> RemoveAt(int index);
    public ImmutableSegmentedList`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableSegmentedList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> RemoveRange(int index, int count);
    public ImmutableSegmentedList`1<T> Replace(T oldValue, T newValue);
    public ImmutableSegmentedList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Reverse();
    public ImmutableSegmentedList`1<T> Reverse(int index, int count);
    public ImmutableSegmentedList`1<T> SetItem(int index, T value);
    public ImmutableSegmentedList`1<T> Sort();
    public ImmutableSegmentedList`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableSegmentedList`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableSegmentedList`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    public Builder<T> ToBuilder();
    [NullableContextAttribute("0")]
private ValueBuilder<T> ToValueBuilder();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedList`1<T> other);
    public bool TrueForAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T element);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class Microsoft.CodeAnalysis.Collections.Internal.BitHelper : ValueType {
    private static int IntSize;
    private Span`1<int> _span;
    internal BitHelper(Span`1<int> span, bool clear);
    [IsReadOnlyAttribute]
internal void MarkBit(int bitPosition);
    [IsReadOnlyAttribute]
internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument value;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument index;
    public static ExceptionArgument capacity;
    public static ExceptionArgument collection;
    public static ExceptionArgument item;
    public static ExceptionArgument converter;
    public static ExceptionArgument match;
    public static ExceptionArgument count;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument source;
    public static ExceptionArgument length;
    public static ExceptionArgument destinationArray;
    public static ExceptionArgument other;
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArgumentOutOfRange_IndexMustBeLessOrEqual;
    public static ExceptionResource ArgumentOutOfRange_IndexMustBeLess;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource InvalidOperation_IComparerFailed;
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.HashHelpers : object {
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    private static ImmutableArray`1<int> s_primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls : object {
    public static bool IsSynchronized(TCollection& collection);
    public static void CopyTo(TCollection& collection, Array array, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls`1 : object {
    public static bool IsReadOnly(TCollection& collection);
    public static void Add(TCollection& collection, T item);
    public static void CopyTo(TCollection& collection, T[] array, int arrayIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.IDictionaryCalls : object {
    public static bool IsFixedSize(TDictionary& dictionary);
    public static bool IsReadOnly(TDictionary& dictionary);
    public static object GetItem(TDictionary& dictionary, object key);
    public static void SetItem(TDictionary& dictionary, object key, object value);
    public static void Add(TDictionary& dictionary, object key, object value);
    public static bool Contains(TDictionary& dictionary, object key);
    public static void CopyTo(TDictionary& dictionary, Array array, int index);
    public static IDictionaryEnumerator GetEnumerator(TDictionary& dictionary);
    public static void Remove(TDictionary& dictionary, object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls : object {
    [NullableContextAttribute("1")]
public static IEnumerator GetEnumerator(TEnumerable& enumerable);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls`1 : object {
    [NullableContextAttribute("1")]
public static IEnumerator`1<T> GetEnumerator(TEnumerable& enumerable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.IListCalls : object {
    public static object GetItem(TList& list, int index);
    public static void SetItem(TList& list, int index, object value);
    public static bool IsFixedSize(TList& list);
    public static bool IsReadOnly(TList& list);
    public static int Add(TList& list, object value);
    public static bool Contains(TList& list, object value);
    public static int IndexOf(TList& list, object value);
    public static void Insert(TList& list, int index, object value);
    public static void Remove(TList& list, object value);
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe : object {
    public static T& NullRef();
    public static bool IsNullRef(T& source);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper : object {
    internal static int IntrosortSizeThreshold;
    [NullableContextAttribute("2")]
internal static int GetSegmentSize();
    [NullableContextAttribute("2")]
internal static int GetSegmentShift();
    [NullableContextAttribute("2")]
internal static int GetOffsetMask();
    private static int CalculateSegmentSize(int elementSize);
    private static int CalculateSegmentShift(int segmentSize);
    private static int CalculateOffsetMask(int segmentSize);
    [CompilerGeneratedAttribute]
internal static int <CalculateSegmentSize>g__ArraySize|4_0(int elementSize, int segmentSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySegment`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SegmentedArray`1<T> <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SegmentedArray`1<T> Array { get; }
    public int Start { get; }
    public int Length { get; }
    public T& Item { get; }
    public SegmentedArraySegment`1(SegmentedArray`1<T> array, int start, int length);
    [CompilerGeneratedAttribute]
public SegmentedArray`1<T> get_Array();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    public T& get_Item(int index);
    public SegmentedArraySegment`1<T> Slice(int start);
    public SegmentedArraySegment`1<T> Slice(int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortHelper`1 : object {
    public static void Sort(SegmentedArraySegment`1<T> keys, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer, int i, int j);
    private static void Swap(SegmentedArraySegment`1<T> a, int i, int j);
    internal static void IntrospectiveSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void IntroSort(SegmentedArraySegment`1<T> keys, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void HeapSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void DownHeap(SegmentedArraySegment`1<T> keys, int i, int n, Comparison`1<T> comparer);
    private static void InsertionSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortHelper`2 : object {
    public static void Sort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer, int i, int j);
    private static void Swap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    internal static void IntrospectiveSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void IntroSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void HeapSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void DownHeap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int n, IComparer`1<TKey> comparer);
    private static void InsertionSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils : object {
    private static ReadOnlySpan`1<byte> Log2DeBruijn { get; }
    private static ReadOnlySpan`1<byte> get_Log2DeBruijn();
    [NullableContextAttribute("1")]
public static int MoveNansToFront(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    public static int Log2(UInt32 value);
    private static int Log2SoftwareFallback(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1 : object {
    public static void Sort(SegmentedArraySegment`1<T> keys, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value);
    private static void SwapIfGreater(T& i, T& j);
    private static void Swap(T& i, T& j);
    private static void IntroSort(SegmentedArraySegment`1<T> keys, int depthLimit);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<T> keys);
    private static void HeapSort(SegmentedArraySegment`1<T> keys);
    private static void DownHeap(SegmentedArraySegment`1<T> keys, int i, int n);
    private static void InsertionSort(SegmentedArraySegment`1<T> keys);
    private static bool LessThan(T& left, T& right);
    private static bool GreaterThan(T& left, T& right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`2 : object {
    public static void Sort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void Swap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void IntroSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int depthLimit);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static void HeapSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static void DownHeap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int n);
    private static void InsertionSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static bool LessThan(TKey& left, TKey& right);
    private static bool GreaterThan(TKey& left, TKey& right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.SegmentedHashSetEqualityComparer`1 : object {
    public sealed virtual bool Equals(SegmentedHashSet`1<T> x, SegmentedHashSet`1<T> y);
    public sealed virtual int GetHashCode(SegmentedHashSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_LongerThanDestArray { get; }
    internal static string Arg_LongerThanSrcArray { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_IncompatibleArrayType { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string ArgumentOutOfRange_ArrayLB { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLess { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string InvalidOperation_ConcurrentOperationsNotSupported { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string Rank_MustMatch { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string ArgumentException_OtherNotArrayOfCorrectLength { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string CannotFindOldValue { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLessOrEqual { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_LongerThanDestArray();
    internal static string get_Arg_LongerThanSrcArray();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_IncompatibleArrayType();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_ArgumentOutOfRange_ArrayLB();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_IndexMustBeLess();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_InvalidOperation_ConcurrentOperationsNotSupported();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_Rank_MustMatch();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_ArgumentException_OtherNotArrayOfCorrectLength();
    internal static string get_Arg_BogusIComparer();
    internal static string get_CannotFindOldValue();
    internal static string get_ArgumentOutOfRange_IndexMustBeLessOrEqual();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowIndexOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexMustBeLessException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexMustBeLessOrEqualException();
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
internal static void ThrowArgumentException_BadComparer(object comparer);
    [DoesNotReturnAttribute]
internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_IndexMustBeLessOrEqual();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_IndexMustBeLess();
    [DoesNotReturnAttribute]
internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    [DoesNotReturnAttribute]
internal static void ThrowWrongKeyTypeArgumentException(T key, Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowWrongValueTypeArgumentException(T value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    [DoesNotReturnAttribute]
internal static void ThrowAddingDuplicateWithKeyArgumentException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowKeyNotFoundException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_Argument_IncompatibleArrayType();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [NullableContextAttribute("2")]
internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
internal interface Microsoft.CodeAnalysis.Collections.IOrderedReadOnlySet`1 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> _pool;
    private static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> s_poolInstance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<K, ValueSet<K, V>> s_emptyDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledDictionary`2<K, ValueSet<K, V>> _dictionary;
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<V> Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<K, ValueSet<K, V>> Keys { get; }
    private OrderPreservingMultiDictionary`2(ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> pool);
    private static OrderPreservingMultiDictionary`2();
    public void Free();
    public static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> CreatePool();
    public static OrderPreservingMultiDictionary`2<K, V> GetInstance();
    private void EnsureDictionary();
    public bool get_IsEmpty();
    public void Add(K k, V v);
    public bool TryGetValue(K key, Func`3<V, TArg, bool> predicate, TArg arg, V& value);
    public Enumerator<K, ValueSet<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K,V>.ValueSet>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableArray`1<V> get_Item(K k);
    public OneOrMany`1<V> GetAsOneOrMany(K k);
    public bool Contains(K key, V value);
    public KeyCollection<K, ValueSet<K, V>> get_Keys();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked : object {
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedList`1& location, Func`2<ImmutableSegmentedList`1<T>, ImmutableSegmentedList`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedList`1& location, Func`3<ImmutableSegmentedList`1<T>, TArg, ImmutableSegmentedList`1<T>> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> InterlockedExchange(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> InterlockedCompareExchange(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value, ImmutableSegmentedList`1<T> comparand);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedHashSet`1& location, Func`2<ImmutableSegmentedHashSet`1<T>, ImmutableSegmentedHashSet`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedHashSet`1& location, Func`3<ImmutableSegmentedHashSet`1<T>, TArg, ImmutableSegmentedHashSet`1<T>> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> InterlockedExchange(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> InterlockedCompareExchange(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value, ImmutableSegmentedHashSet`1<T> comparand);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value);
    public static bool Update(ImmutableSegmentedDictionary`2& location, Func`2<ImmutableSegmentedDictionary`2<TKey, TValue>, ImmutableSegmentedDictionary`2<TKey, TValue>> transformer);
    public static bool Update(ImmutableSegmentedDictionary`2& location, Func`3<ImmutableSegmentedDictionary`2<TKey, TValue>, TArg, ImmutableSegmentedDictionary`2<TKey, TValue>> transformer, TArg transformerArgument);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> InterlockedExchange(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> InterlockedCompareExchange(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value, ImmutableSegmentedDictionary`2<TKey, TValue> comparand);
    public static bool InterlockedInitialize(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, Func`2<TKey, TValue> valueFactory);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, TValue value);
    public static TValue AddOrUpdate(ImmutableSegmentedDictionary`2& location, TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static TValue AddOrUpdate(ImmutableSegmentedDictionary`2& location, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static bool TryAdd(ImmutableSegmentedDictionary`2& location, TKey key, TValue value);
    public static bool TryUpdate(ImmutableSegmentedDictionary`2& location, TKey key, TValue newValue, TValue comparisonValue);
    public static bool TryRemove(ImmutableSegmentedDictionary`2& location, TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.SegmentedArray : object {
    [NullableContextAttribute("2")]
internal static void Clear(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
internal static void Clear(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
internal static void Copy(SegmentedArray`1<T> sourceArray, SegmentedArray`1<T> destinationArray, int length);
    public static void Copy(SegmentedArray`1<T> sourceArray, Array destinationArray, int length);
    [NullableContextAttribute("2")]
public static void Copy(SegmentedArray`1<T> sourceArray, int sourceIndex, SegmentedArray`1<T> destinationArray, int destinationIndex, int length);
    [NullableContextAttribute("2")]
private static void CopyOverlapped(SegmentedArray`1<T> array, int sourceIndex, int destinationIndex, int length);
    public static void Copy(SegmentedArray`1<T> sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static int BinarySearch(SegmentedArray`1<T> array, T value);
    public static int BinarySearch(SegmentedArray`1<T> array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    public static int IndexOf(SegmentedArray`1<T> array, T value);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count, IEqualityComparer`1<T> comparer);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Reverse(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
public static void Reverse(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(SegmentedArray`1<T> array, Comparison`1<T> comparison);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static SegmentEnumerable`1<T> GetSegments(SegmentedArray`1<T> array, int offset, int length);
    [NullableContextAttribute("2")]
private static AlignedSegmentEnumerable`1<T> GetSegments(SegmentedArray`1<T> first, SegmentedArray`1<T> second, int length);
    [NullableContextAttribute("2")]
private static AlignedSegmentEnumerable`1<T> GetSegmentsAligned(SegmentedArray`1<T> first, int firstOffset, SegmentedArray`1<T> second, int secondOffset, int length);
    [NullableContextAttribute("2")]
private static UnalignedSegmentEnumerable`1<T> GetSegmentsUnaligned(SegmentedArray`1<T> first, int firstOffset, SegmentedArray`1<T> second, int secondOffset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedArray`1 : ValueType {
    private int _length;
    private T[][] _items;
    private static int SegmentSize { get; }
    private static int SegmentShift { get; }
    private static int OffsetMask { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public int Length { get; }
    public object SyncRoot { get; }
    public T& Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public SegmentedArray`1(int length);
    private SegmentedArray`1(int length, T[][] items);
    private static int get_SegmentSize();
    private static int get_SegmentShift();
    private static int get_OffsetMask();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public int get_Length();
    public sealed virtual object get_SyncRoot();
    public T& get_Item(int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual object Clone();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SegmentedArray`1<T> other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal : object {
    public static T[][] AsSegments(SegmentedArray`1<T> array);
    public static TValue& GetValueRefOrNullRef(SegmentedDictionary`2<TKey, TValue> dictionary, TKey key);
    public static TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRef(ImmutableSegmentedDictionary`2<TKey, TValue> dictionary, TKey key);
    public static TValue& GetValueRefOrNullRef(Builder<TKey, TValue> dictionary, TKey key);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> AsImmutableSegmentedList(SegmentedList`1<T> list);
    [NullableContextAttribute("2")]
public static SegmentedList`1<T> AsSegmentedList(ImmutableSegmentedList`1<T> list);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> AsImmutableSegmentedHashSet(SegmentedHashSet`1<T> set);
    [NullableContextAttribute("2")]
public static SegmentedHashSet`1<T> AsSegmentedHashSet(ImmutableSegmentedHashSet`1<T> set);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> AsImmutableSegmentedDictionary(SegmentedDictionary`2<TKey, TValue> dictionary);
    public static SegmentedDictionary`2<TKey, TValue> AsSegmentedDictionary(ImmutableSegmentedDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2 : object {
    private static bool SupportsComparerDevirtualization;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IEnumerator`1<KeyValuePair`2<TKey, TValue>> s_emptyEnumerator;
    [NullableAttribute("0")]
private SegmentedArray`1<int> _buckets;
    [NullableAttribute("0")]
private SegmentedArray`1<Entry<TKey, TValue>> _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> _keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> _values;
    private static int StartOfFreeList;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public SegmentedDictionary`2(int capacity);
    public SegmentedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SegmentedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public SegmentedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    private void AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> enumerable);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private static IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEmptyEnumerator();
    private TValue& FindValue(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    private void Resize();
    private void Resize(int newSize);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    [NullableContextAttribute("0")]
private void CopyEntries(SegmentedArray`1<Entry<TKey, TValue>> entries, int count);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private Int32& GetBucket(UInt32 hashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1 : object {
    private static bool SupportsComparerDevirtualization;
    private static int StackAllocThreshold;
    private static int ShrinkThreshold;
    private static int StartOfFreeList;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IEnumerator`1<T> s_emptyEnumerator;
    [NullableAttribute("0")]
private SegmentedArray`1<int> _buckets;
    [NullableAttribute("0")]
private SegmentedArray`1<Entry<T>> _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<T> _comparer;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public SegmentedHashSet`1(IEqualityComparer`1<T> comparer);
    public SegmentedHashSet`1(int capacity);
    public SegmentedHashSet`1(IEnumerable`1<T> collection);
    public SegmentedHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public SegmentedHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private void ConstructFrom(SegmentedHashSet`1<T> source);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private int FindItemIndex(T item);
    private Int32& GetBucketRef(int hashCode);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static IEnumerator`1<T> GetEmptyEnumerator();
    public sealed virtual bool Add(T item);
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public int RemoveWhere(Predicate`1<T> match);
    public IEqualityComparer`1<T> get_Comparer();
    public int EnsureCapacity(int capacity);
    private void Resize();
    private void Resize(int newSize);
    public void TrimExcess();
    public static IEqualityComparer`1<SegmentedHashSet`1<T>> CreateSetComparer();
    private int Initialize(int capacity);
    private bool AddIfNotPresent(T value, Int32& location);
    internal bool IsSubsetOfHashSetWithSameComparer(SegmentedHashSet`1<T> other);
    private void IntersectWithHashSetWithSameComparer(SegmentedHashSet`1<T> other);
    private void IntersectWithEnumerable(IEnumerable`1<T> other);
    private void SymmetricExceptWithUniqueHashSet(SegmentedHashSet`1<T> other);
    private void SymmetricExceptWithEnumerable(IEnumerable`1<T> other);
    [NullableContextAttribute("0")]
private ValueTuple`2<int, int> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    internal static bool EqualityComparersAreEqual(SegmentedHashSet`1<T> set1, SegmentedHashSet`1<T> set2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedList`1 : object {
    private static int DefaultCapacity;
    private static int MaxLength;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal SegmentedArray`1<T> _items;
    internal int _size;
    internal int _version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static SegmentedArray`1<T> s_emptyArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IEnumerator`1<T> s_emptyEnumerator;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public SegmentedList`1(int capacity);
    public SegmentedList`1(IEnumerable`1<T> collection);
    private static SegmentedList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object item);
    public SegmentedList`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public int EnsureCapacity(int capacity);
    internal void Grow(int capacity);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public SegmentedList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static IEnumerator`1<T> GetEmptyEnumerator();
    public SegmentedList`1<T> GetRange(int index, int count);
    public SegmentedList`1<T> Slice(int start, int length);
    public sealed virtual int IndexOf(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public int IndexOf(T item, int index, int count, IEqualityComparer`1<T> comparer);
    public sealed virtual void Insert(int index, T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> comparer);
    public sealed virtual bool Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
    [NullableContextAttribute("0")]
internal TestAccessor<T> GetTestAccessor();
}
internal static class Microsoft.CodeAnalysis.CompilerExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Absolute_path_expected { get; }
    internal static string Organize_usings { get; }
    internal static string this_dot_and_Me_dot_preferences { get; }
    internal static string Language_keywords_vs_BCL_types_preferences { get; }
    internal static string Parentheses_preferences { get; }
    internal static string Modifier_preferences { get; }
    internal static string Expression_level_preferences { get; }
    internal static string Field_preferences { get; }
    internal static string Parameter_preferences { get; }
    internal static string Suppression_preferences { get; }
    internal static string Pascal_Case { get; }
    internal static string Abstract_Method { get; }
    internal static string Begins_with_I { get; }
    internal static string Class { get; }
    internal static string Delegate { get; }
    internal static string Enum { get; }
    internal static string Event { get; }
    internal static string Interface { get; }
    internal static string Non_Field_Members { get; }
    internal static string Private_Method { get; }
    internal static string Private_or_Internal_Field { get; }
    internal static string Private_or_Internal_Static_Field { get; }
    internal static string Property { get; }
    internal static string Public_or_Protected_Field { get; }
    internal static string Static_Field { get; }
    internal static string Static_Method { get; }
    internal static string Struct { get; }
    internal static string Types { get; }
    internal static string Method { get; }
    internal static string Missing_prefix_colon_0 { get; }
    internal static string Missing_suffix_colon_0 { get; }
    internal static string Prefix_0_does_not_match_expected_prefix_1 { get; }
    internal static string Prefix_0_is_not_expected { get; }
    internal static string These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0 { get; }
    internal static string These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0 { get; }
    internal static string These_words_cannot_contain_lower_case_characters_colon_0 { get; }
    internal static string These_words_cannot_contain_upper_case_characters_colon_0 { get; }
    internal static string These_words_must_begin_with_upper_case_characters_colon_0 { get; }
    internal static string The_first_word_0_must_begin_with_an_upper_case_character { get; }
    internal static string The_first_word_0_must_begin_with_a_lower_case_character { get; }
    internal static string Cast_is_redundant { get; }
    internal static string Naming_styles { get; }
    internal static string Naming_rules { get; }
    internal static string Symbol_specifications { get; }
    internal static string Specified_sequence_has_duplicate_items { get; }
    internal static string New_line_preferences { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Absolute_path_expected();
    internal static string get_Organize_usings();
    internal static string get_this_dot_and_Me_dot_preferences();
    internal static string get_Language_keywords_vs_BCL_types_preferences();
    internal static string get_Parentheses_preferences();
    internal static string get_Modifier_preferences();
    internal static string get_Expression_level_preferences();
    internal static string get_Field_preferences();
    internal static string get_Parameter_preferences();
    internal static string get_Suppression_preferences();
    internal static string get_Pascal_Case();
    internal static string get_Abstract_Method();
    internal static string get_Begins_with_I();
    internal static string get_Class();
    internal static string get_Delegate();
    internal static string get_Enum();
    internal static string get_Event();
    internal static string get_Interface();
    internal static string get_Non_Field_Members();
    internal static string get_Private_Method();
    internal static string get_Private_or_Internal_Field();
    internal static string get_Private_or_Internal_Static_Field();
    internal static string get_Property();
    internal static string get_Public_or_Protected_Field();
    internal static string get_Static_Field();
    internal static string get_Static_Method();
    internal static string get_Struct();
    internal static string get_Types();
    internal static string get_Method();
    internal static string get_Missing_prefix_colon_0();
    internal static string get_Missing_suffix_colon_0();
    internal static string get_Prefix_0_does_not_match_expected_prefix_1();
    internal static string get_Prefix_0_is_not_expected();
    internal static string get_These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0();
    internal static string get_These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0();
    internal static string get_These_words_cannot_contain_lower_case_characters_colon_0();
    internal static string get_These_words_cannot_contain_upper_case_characters_colon_0();
    internal static string get_These_words_must_begin_with_upper_case_characters_colon_0();
    internal static string get_The_first_word_0_must_begin_with_an_upper_case_character();
    internal static string get_The_first_word_0_must_begin_with_a_lower_case_character();
    internal static string get_Cast_is_redundant();
    internal static string get_Naming_styles();
    internal static string get_Naming_rules();
    internal static string get_Symbol_specifications();
    internal static string get_Specified_sequence_has_duplicate_items();
    internal static string get_New_line_preferences();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractConvertTypeOfToNameOfDiagnosticAnalyzer(LocalizableString title);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual bool IsValidTypeofAction(OperationAnalysisContext context);
    protected virtual void InitializeWorker(AnalysisContext context);
    protected void AnalyzeAction(OperationAnalysisContext context);
    private static bool IsValidOperation(IOperation operation);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.DiagnosticArrayExtensions : object {
    [ExtensionAttribute]
internal static bool HasAnyErrors(ImmutableArray`1<T> diagnostics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProvider : ValueType {
    private IOptionsReader _options;
    private IdeAnalyzerOptions _fallbackOptions;
    private string _language;
    public CodeStyleOption2`1<bool> QualifyFieldAccess { get; }
    public CodeStyleOption2`1<bool> QualifyPropertyAccess { get; }
    public CodeStyleOption2`1<bool> QualifyMethodAccess { get; }
    public CodeStyleOption2`1<bool> QualifyEventAccess { get; }
    public CodeStyleOption2`1<bool> PreferPredefinedTypeKeywordInMemberAccess { get; }
    public CodeStyleOption2`1<bool> PreferPredefinedTypeKeywordInDeclaration { get; }
    public NamingStylePreferences NamingPreferences { get; }
    public CodeStyleOption2`1<bool> PreferObjectInitializer { get; }
    public CodeStyleOption2`1<CollectionExpressionPreference> PreferCollectionExpression { get; }
    public CodeStyleOption2`1<bool> PreferCollectionInitializer { get; }
    public CodeStyleOption2`1<bool> PreferSimplifiedBooleanExpressions { get; }
    public OperatorPlacementWhenWrappingPreference OperatorPlacementWhenWrapping { get; }
    public CodeStyleOption2`1<bool> PreferCoalesceExpression { get; }
    public CodeStyleOption2`1<bool> PreferNullPropagation { get; }
    public CodeStyleOption2`1<bool> PreferExplicitTupleNames { get; }
    public CodeStyleOption2`1<bool> PreferAutoProperties { get; }
    public CodeStyleOption2`1<bool> PreferInferredTupleNames { get; }
    public CodeStyleOption2`1<bool> PreferInferredAnonymousTypeMemberNames { get; }
    public CodeStyleOption2`1<bool> PreferIsNullCheckOverReferenceEqualityMethod { get; }
    public CodeStyleOption2`1<bool> PreferConditionalExpressionOverAssignment { get; }
    public CodeStyleOption2`1<bool> PreferConditionalExpressionOverReturn { get; }
    public CodeStyleOption2`1<bool> PreferCompoundAssignment { get; }
    public CodeStyleOption2`1<bool> PreferSimplifiedInterpolation { get; }
    public CodeStyleOption2`1<UnusedParametersPreference> UnusedParameters { get; }
    public CodeStyleOption2`1<AccessibilityModifiersRequired> RequireAccessibilityModifiers { get; }
    public CodeStyleOption2`1<bool> PreferReadonly { get; }
    public CodeStyleOption2`1<ParenthesesPreference> ArithmeticBinaryParentheses { get; }
    public CodeStyleOption2`1<ParenthesesPreference> OtherBinaryParentheses { get; }
    public CodeStyleOption2`1<ParenthesesPreference> RelationalBinaryParentheses { get; }
    public CodeStyleOption2`1<ParenthesesPreference> OtherParentheses { get; }
    public CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> ForEachExplicitCastInSource { get; }
    public CodeStyleOption2`1<bool> PreferNamespaceAndFolderMatchStructure { get; }
    public CodeStyleOption2`1<bool> AllowMultipleBlankLines { get; }
    public CodeStyleOption2`1<bool> AllowStatementImmediatelyAfterBlock { get; }
    public string RemoveUnnecessarySuppressionExclusions { get; }
    public string FileHeaderTemplate { get; }
    private IdeCodeStyleOptions FallbackCodeStyleOptions { get; }
    private SimplifierOptions FallbackSimplifierOptions { get; }
    public AnalyzerOptionsProvider(IOptionsReader options, string language, IdeAnalyzerOptions fallbackOptions);
    public AnalyzerOptionsProvider(IOptionsReader options, string language, AnalyzerOptions fallbackOptions);
    public CodeStyleOption2`1<bool> get_QualifyFieldAccess();
    public CodeStyleOption2`1<bool> get_QualifyPropertyAccess();
    public CodeStyleOption2`1<bool> get_QualifyMethodAccess();
    public CodeStyleOption2`1<bool> get_QualifyEventAccess();
    public CodeStyleOption2`1<bool> get_PreferPredefinedTypeKeywordInMemberAccess();
    public CodeStyleOption2`1<bool> get_PreferPredefinedTypeKeywordInDeclaration();
    public SimplifierOptions GetSimplifierOptions(ISimplification simplification);
    public SyntaxFormattingOptions GetSyntaxFormattingOptions(ISyntaxFormatting formatting);
    public NamingStylePreferences get_NamingPreferences();
    public CodeStyleOption2`1<bool> get_PreferObjectInitializer();
    public CodeStyleOption2`1<CollectionExpressionPreference> get_PreferCollectionExpression();
    public CodeStyleOption2`1<bool> get_PreferCollectionInitializer();
    public CodeStyleOption2`1<bool> get_PreferSimplifiedBooleanExpressions();
    public OperatorPlacementWhenWrappingPreference get_OperatorPlacementWhenWrapping();
    public CodeStyleOption2`1<bool> get_PreferCoalesceExpression();
    public CodeStyleOption2`1<bool> get_PreferNullPropagation();
    public CodeStyleOption2`1<bool> get_PreferExplicitTupleNames();
    public CodeStyleOption2`1<bool> get_PreferAutoProperties();
    public CodeStyleOption2`1<bool> get_PreferInferredTupleNames();
    public CodeStyleOption2`1<bool> get_PreferInferredAnonymousTypeMemberNames();
    public CodeStyleOption2`1<bool> get_PreferIsNullCheckOverReferenceEqualityMethod();
    public CodeStyleOption2`1<bool> get_PreferConditionalExpressionOverAssignment();
    public CodeStyleOption2`1<bool> get_PreferConditionalExpressionOverReturn();
    public CodeStyleOption2`1<bool> get_PreferCompoundAssignment();
    public CodeStyleOption2`1<bool> get_PreferSimplifiedInterpolation();
    public CodeStyleOption2`1<UnusedParametersPreference> get_UnusedParameters();
    public CodeStyleOption2`1<AccessibilityModifiersRequired> get_RequireAccessibilityModifiers();
    public CodeStyleOption2`1<bool> get_PreferReadonly();
    public CodeStyleOption2`1<ParenthesesPreference> get_ArithmeticBinaryParentheses();
    public CodeStyleOption2`1<ParenthesesPreference> get_OtherBinaryParentheses();
    public CodeStyleOption2`1<ParenthesesPreference> get_RelationalBinaryParentheses();
    public CodeStyleOption2`1<ParenthesesPreference> get_OtherParentheses();
    public CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> get_ForEachExplicitCastInSource();
    public CodeStyleOption2`1<bool> get_PreferNamespaceAndFolderMatchStructure();
    public CodeStyleOption2`1<bool> get_AllowMultipleBlankLines();
    public CodeStyleOption2`1<bool> get_AllowStatementImmediatelyAfterBlock();
    public string get_RemoveUnnecessarySuppressionExclusions();
    public string get_FileHeaderTemplate();
    private TValue GetOption(Option2`1<TValue> option, TValue defaultValue);
    private TValue GetOption(PerLanguageOption2`1<TValue> option, TValue defaultValue);
    private IdeCodeStyleOptions get_FallbackCodeStyleOptions();
    private SimplifierOptions get_FallbackSimplifierOptions();
    internal IOptionsReader GetAnalyzerConfigOptions();
    internal IdeAnalyzerOptions GetFallbackOptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProviders : object {
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeOptions(AnalyzerOptions options);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(AnalyzerOptions analyzerOptions, SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(SemanticModelAnalysisContext context);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(SyntaxTreeAnalysisContext context);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(OperationAnalysisContext context);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(CodeBlockAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(SemanticModelAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(SyntaxTreeAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(OperationAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(CodeBlockAnalysisContext context);
}
internal enum Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization : Enum {
    public byte value__;
    public static Capitalization PascalCase;
    public static Capitalization CamelCase;
    public static Capitalization FirstUpper;
    public static Capitalization AllUpper;
    public static Capitalization AllLower;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.EditorConfigNamingStyleParser : object {
    private static SymbolKindOrTypeKind _namespace;
    private static SymbolKindOrTypeKind _class;
    private static SymbolKindOrTypeKind _struct;
    private static SymbolKindOrTypeKind _interface;
    private static SymbolKindOrTypeKind _enum;
    private static SymbolKindOrTypeKind _property;
    private static SymbolKindOrTypeKind _method;
    private static SymbolKindOrTypeKind _localFunction;
    private static SymbolKindOrTypeKind _field;
    private static SymbolKindOrTypeKind _event;
    private static SymbolKindOrTypeKind _delegate;
    private static SymbolKindOrTypeKind _parameter;
    private static SymbolKindOrTypeKind _typeParameter;
    private static SymbolKindOrTypeKind _local;
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKindOrTypeKind> _all;
    [NullableAttribute("0")]
private static ImmutableArray`1<Accessibility> s_allAccessibility;
    private static ModifierKind s_abstractModifierKind;
    private static ModifierKind s_asyncModifierKind;
    private static ModifierKind s_constModifierKind;
    private static ModifierKind s_readonlyModifierKind;
    private static ModifierKind s_staticModifierKind;
    [NullableAttribute("0")]
private static ImmutableArray`1<ModifierKind> _allModifierKind;
    private static EditorConfigNamingStyleParser();
    public static NamingStylePreferences ParseDictionary(AnalyzerConfigOptions allRawConventions);
    internal static Dictionary`2<string, string> TrimDictionary(AnalyzerConfigOptions allRawConventions);
    public static IEnumerable`1<string> GetRuleTitles(IReadOnlyDictionary`2<string, T> allRawConventions);
    private static bool TryGetSerializableNamingRule(string namingRuleTitle, SymbolSpecification symbolSpec, NamingStyle namingStyle, IReadOnlyDictionary`2<string, string> conventionsDictionary, SerializableNamingRule& serializableNamingRule);
    [NullableContextAttribute("0")]
internal static bool TryGetRuleSeverity(string namingRuleName, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> conventionsDictionary, ValueTuple`2& value);
    private static bool TryGetRuleSeverity(string namingRuleName, IReadOnlyDictionary`2<string, string> conventionsDictionary, ReportDiagnostic& severity);
    private static bool TryGetRuleSeverity(string namingRuleName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, string> valueSelector, Func`2<T, V> partSelector, ValueTuple`2& value);
    private static ReportDiagnostic ParseEnforcementLevel(string ruleSeverity);
    internal static bool TryGetNamingStyleData(Section section, string namingRuleName, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> properties, NamingScheme& namingScheme);
    private static bool TryGetNamingStyleData(string namingRuleName, IReadOnlyDictionary`2<string, string> rawOptions, NamingStyle& namingStyle);
    private static bool TryGetNamingStyleData(string namingRuleName, IReadOnlyDictionary`2<string, T> rawOptions, Func`2<T, string> nameSelector, Func`2<T, TData> dataSelector, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`6<ValueTuple`2<string, TData>, ValueTuple`2<string, TData>, ValueTuple`2<string, TData>, ValueTuple`2<string, TData>, ValueTuple`2<Capitalization, TData>, TResult> constructor, TResult& namingStyle);
    private static bool TryGetNamingStyleTitle(string namingRuleName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, string> nameSelector, Func`2<T, TData> dataSelector, ValueTuple`2& result);
    private static ValueTuple`2<string, TData> GetNamingRequiredPrefix(string namingStyleName, IReadOnlyDictionary`2<string, T> properties, Func`2<T, ValueTuple`2<string, TData>> tupleSelector);
    private static ValueTuple`2<string, TData> GetNamingRequiredSuffix(string namingStyleName, IReadOnlyDictionary`2<string, T> properties, Func`2<T, ValueTuple`2<string, TData>> tupleSelector);
    private static ValueTuple`2<string, TData> GetNamingWordSeparator(string namingStyleName, IReadOnlyDictionary`2<string, T> properties, Func`2<T, ValueTuple`2<string, TData>> tupleSelector);
    private static bool TryGetNamingCapitalization(string namingStyleName, IReadOnlyDictionary`2<string, T> properties, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, ValueTuple`2& result);
    private static ValueTuple`2<string, TData> GetValueFromDictionary(string namingStyleName, string optionName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector);
    private static bool TryParseCapitalizationScheme(string namingStyleCapitalization, Nullable`1& capitalization);
    [ExtensionAttribute]
public static string ToEditorConfigString(Capitalization capitalization);
    internal static bool TryGetSymbolSpec(Section section, string namingRuleTitle, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> properties, ApplicableSymbolInfo& applicableSymbolInfo);
    private static bool TryGetSymbolSpec(string namingRuleTitle, IReadOnlyDictionary`2<string, string> conventionsDictionary, SymbolSpecification& symbolSpec);
    [NullableContextAttribute("2")]
private static bool TryGetSymbolSpec(string namingRuleTitle, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`1<TData> defaultValue, Func`5<ValueTuple`2<string, TData>, ValueTuple`2<ImmutableArray`1<SymbolKindOrTypeKind>, TData>, ValueTuple`2<ImmutableArray`1<Accessibility>, TData>, ValueTuple`2<ImmutableArray`1<ModifierKind>, TData>, TResult> constructor, TResult& symbolSpec);
    private static bool TryGetSymbolSpecNameForNamingRule(string namingRuleName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, ValueTuple`2& result);
    private static ValueTuple`2<ImmutableArray`1<SymbolKindOrTypeKind>, TData> GetSymbolsApplicableKinds(string symbolSpecName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`1<TData> defaultValue);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SymbolKindOrTypeKind> ParseSymbolKindList(string symbolSpecApplicableKinds);
    private static ValueTuple`2<ImmutableArray`1<Accessibility>, TData> GetSymbolsApplicableAccessibilities(string symbolSpecName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`1<TData> defaultValue);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<Accessibility> ParseAccessibilityKindList(string symbolSpecApplicableAccessibilities);
    private static ValueTuple`2<ImmutableArray`1<ModifierKind>, TData> GetSymbolsRequiredModifiers(string symbolSpecName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`1<TData> defaultValue);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<ModifierKind> ParseModifiers(string symbolSpecRequiredModifiers);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string ToEditorConfigString(ImmutableArray`1<SymbolKindOrTypeKind> symbols);
    [ExtensionAttribute]
private static string ToEditorConfigString(SymbolKindOrTypeKind symbol);
    [ExtensionAttribute]
public static string ToEditorConfigString(ImmutableArray`1<Accessibility> accessibilities, string languageName);
    [ExtensionAttribute]
private static string ToEditorConfigString(Accessibility accessibility, string languageName);
    [ExtensionAttribute]
public static string ToEditorConfigString(ImmutableArray`1<ModifierKind> modifiers, string languageName);
    [ExtensionAttribute]
private static string ToEditorConfigString(ModifierKind modifier, string languageName);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule : ValueType {
    public SymbolSpecification SymbolSpecification;
    public NamingStyle NamingStyle;
    public ReportDiagnostic EnforcementLevel;
    public NamingRule(SymbolSpecification symbolSpecification, NamingStyle namingStyle, ReportDiagnostic enforcementLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleDiagnosticAnalyzerBase`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_localizableMessageFormat;
    private static LocalizableString s_localizableTitleNamingStyle;
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKind> _symbolKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<Guid, ConcurrentDictionary`2<string, string>> s_createCache;
    [NullableAttribute("0")]
protected ImmutableArray`1<TLanguageKindEnum> SupportedSyntaxKinds { get; }
    private static NamingStyleDiagnosticAnalyzerBase`1();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SupportedSyntaxKinds();
    protected abstract virtual bool ShouldIgnore(ISymbol symbol);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void CompilationStartAction(CompilationStartAnalysisContext context);
    private Diagnostic TryGetDiagnostic(Compilation compilation, ISymbol symbol, SyntaxTree sourceTree, AnalyzerOptions options, ConcurrentDictionary`2<Guid, ConcurrentDictionary`2<string, string>> idToCachedResult);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferences : object {
    private static int s_serializationVersion;
    private static string _defaultNamingPreferencesString;
    [DataMemberAttribute]
public ImmutableArray`1<SymbolSpecification> SymbolSpecifications;
    [DataMemberAttribute]
public ImmutableArray`1<NamingStyle> NamingStyles;
    [DataMemberAttribute]
public ImmutableArray`1<SerializableNamingRule> NamingRules;
    private Lazy`1<NamingStyleRules> _lazyRules;
    [CompilerGeneratedAttribute]
private static NamingStylePreferences <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static NamingStylePreferences <Empty>k__BackingField;
    public static NamingStylePreferences Default { get; }
    public static NamingStylePreferences Empty { get; }
    public static string DefaultNamingPreferencesString { get; }
    public bool IsEmpty { get; }
    public NamingStyleRules Rules { get; }
    public NamingStylePreferences(ImmutableArray`1<SymbolSpecification> symbolSpecifications, ImmutableArray`1<NamingStyle> namingStyles, ImmutableArray`1<SerializableNamingRule> namingRules);
    private static NamingStylePreferences();
    [CompilerGeneratedAttribute]
public static NamingStylePreferences get_Default();
    [CompilerGeneratedAttribute]
public static NamingStylePreferences get_Empty();
    public static string get_DefaultNamingPreferencesString();
    public bool get_IsEmpty();
    internal NamingStyle GetNamingStyle(Guid namingStyleID);
    internal SymbolSpecification GetSymbolSpecification(Guid symbolSpecificationID);
    public NamingStyleRules get_Rules();
    public NamingStyleRules CreateRules();
    internal XElement CreateXElement();
    internal static NamingStylePreferences FromXElement(XElement element);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NamingStylePreferences other);
    public static bool op_Equality(NamingStylePreferences left, NamingStylePreferences right);
    public static bool op_Inequality(NamingStylePreferences left, NamingStylePreferences right);
    public virtual int GetHashCode();
    private static XElement GetUpgradedSerializationIfNecessary(XElement rootElement);
    private static void UpgradeSerialization_4To5(XElement rootElement);
    [CompilerGeneratedAttribute]
private NamingRule <CreateRules>b__21_0(SerializableNamingRule r);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleRules : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<NamingRule> <NamingRules>k__BackingField;
    private ImmutableArray`1<SymbolKind> _symbolKindsThatCanBeOverridden;
    public ImmutableArray`1<NamingRule> NamingRules { get; }
    public NamingStyleRules(ImmutableArray`1<NamingRule> namingRules);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<NamingRule> get_NamingRules();
    internal bool TryGetApplicableRule(ISymbol symbol, NamingRule& applicableRule);
    private bool IsSymbolNameAnalyzable(ISymbol symbol);
    private static bool DoesSymbolImplementAnotherSymbol(ISymbol symbol);
    private static bool IsInterfaceImplementation(ISymbol symbol);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.SerializableNamingRule : object {
    [CompilerGeneratedAttribute]
private Guid <SymbolSpecificationID>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <NamingStyleID>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportDiagnostic <EnforcementLevel>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [DataMemberAttribute]
public Guid SymbolSpecificationID { get; public set; }
    [DataMemberAttribute]
public Guid NamingStyleID { get; public set; }
    [DataMemberAttribute]
public ReportDiagnostic EnforcementLevel { get; public set; }
    [CompilerGeneratedAttribute]
private SerializableNamingRule(SerializableNamingRule original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Guid get_SymbolSpecificationID();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SymbolSpecificationID(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_NamingStyleID();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamingStyleID(Guid value);
    [CompilerGeneratedAttribute]
public ReportDiagnostic get_EnforcementLevel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EnforcementLevel(ReportDiagnostic value);
    public NamingRule GetRule(NamingStylePreferences info);
    internal XElement CreateXElement();
    internal static SerializableNamingRule FromXElement(XElement namingRuleElement);
    public void WriteTo(ObjectWriter writer);
    public static SerializableNamingRule ReadFrom(ObjectReader reader);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SerializableNamingRule left, SerializableNamingRule right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SerializableNamingRule left, SerializableNamingRule right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SerializableNamingRule other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public SerializableNamingRule <Clone>$();
}
[DataContractAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.SymbolSpecification : object {
    private static SymbolSpecification DefaultSymbolSpecificationTemplate;
    [CompilerGeneratedAttribute]
private Guid <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SymbolKindOrTypeKind> <ApplicableSymbolKindList>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Accessibility> <ApplicableAccessibilityList>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ModifierKind> <RequiredModifierList>k__BackingField;
    [DataMemberAttribute]
public Guid ID { get; }
    [DataMemberAttribute]
public string Name { get; }
    [DataMemberAttribute]
public ImmutableArray`1<SymbolKindOrTypeKind> ApplicableSymbolKindList { get; }
    [DataMemberAttribute]
public ImmutableArray`1<Accessibility> ApplicableAccessibilityList { get; }
    [DataMemberAttribute]
public ImmutableArray`1<ModifierKind> RequiredModifierList { get; }
    public SymbolSpecification(Guid id, string name, ImmutableArray`1<SymbolKindOrTypeKind> symbolKindList, ImmutableArray`1<Accessibility> accessibilityList, ImmutableArray`1<ModifierKind> modifiers);
    private static SymbolSpecification();
    [CompilerGeneratedAttribute]
public Guid get_ID();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SymbolKindOrTypeKind> get_ApplicableSymbolKindList();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Accessibility> get_ApplicableAccessibilityList();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ModifierKind> get_RequiredModifierList();
    private string GetDebuggerDisplay();
    public static SymbolSpecification CreateDefaultSymbolSpecification();
    public bool AppliesTo(ISymbol symbol);
    public bool AppliesTo(SymbolKind symbolKind, Accessibility accessibility);
    public bool AppliesTo(SymbolKindOrTypeKind kind, DeclarationModifiers modifiers, Nullable`1<Accessibility> accessibility);
    private static DeclarationModifiers CollapseModifiers(ImmutableArray`1<ModifierKind> requiredModifierList);
    private static Accessibility GetAccessibility(ISymbol symbol);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolSpecification other);
    public virtual int GetHashCode();
    internal XElement CreateXElement();
    public void WriteTo(ObjectWriter writer);
    public static SymbolSpecification ReadFrom(ObjectReader reader);
    private XElement CreateSymbolKindsXElement();
    private XElement CreateAccessibilitiesXElement();
    private XElement CreateModifiersXElement();
    internal static SymbolSpecification FromXElement(XElement symbolSpecificationElement);
    private static ImmutableArray`1<SymbolKindOrTypeKind> GetSymbolKindListFromXElement(XElement symbolKindListElement);
    private static ImmutableArray`1<Accessibility> GetAccessibilityListFromXElement(XElement accessibilityListElement);
    private static Accessibility ParseAccessibility(XElement accessibilityElement);
    private static ImmutableArray`1<ModifierKind> GetModifierListFromXElement(XElement modifierListElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.CompilerDiagnosticAnalyzerNames : object {
    internal static string CSharpCompilerAnalyzerTypeName;
    internal static string VisualBasicCompilerAnalyzerTypeName;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory : Enum {
    public int value__;
    public static DiagnosticAnalyzerCategory None;
    public static DiagnosticAnalyzerCategory SyntaxTreeWithoutSemanticsAnalysis;
    public static DiagnosticAnalyzerCategory SemanticSpanAnalysis;
    public static DiagnosticAnalyzerCategory SemanticDocumentAnalysis;
    public static DiagnosticAnalyzerCategory ProjectAnalysis;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsCompilerAnalyzer(DiagnosticAnalyzer analyzer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticCategory : object {
    public static string Style;
    public static string CodeQuality;
    public static string EditAndContinue;
    public static string Compiler;
}
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticCustomTags : object {
    private static string s_enforceOnBuildNeverTag;
    private static String[] s_microsoftCustomTags;
    private static String[] s_editAndContinueCustomTags;
    private static String[] s_unnecessaryCustomTags;
    private static String[] s_notConfigurableCustomTags;
    private static String[] s_unnecessaryAndNotConfigurableCustomTags;
    public static String[] Microsoft { get; }
    public static String[] EditAndContinue { get; }
    public static String[] Unnecessary { get; }
    public static String[] NotConfigurable { get; }
    public static String[] UnnecessaryAndNotConfigurable { get; }
    private static DiagnosticCustomTags();
    public static String[] get_Microsoft();
    public static String[] get_EditAndContinue();
    public static String[] get_Unnecessary();
    public static String[] get_NotConfigurable();
    public static String[] get_UnnecessaryAndNotConfigurable();
    [ConditionalAttribute("DEBUG")]
private static void Assert(String[] customTags, String[] tags);
    internal static String[] Create(bool isUnnecessary, bool isConfigurable, bool isCustomConfigurable, EnforceOnBuild enforceOnBuild);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper : object {
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, ImmutableArray`1<Location> additionalLocations, ImmutableArray`1<Location> additionalUnnecessaryLocations, Object[] messageArgs);
    public static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, ImmutableArray`1<Location> additionalLocations, ImmutableArray`1<Location> additionalUnnecessaryLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    private static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, IEnumerable`1<Location> additionalLocations, IDictionary`2<string, IEnumerable`1<int>> tagIndices, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic CreateWithMessage(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, LocalizableString message);
    public static string GetHelpLinkForDiagnosticId(string id);
    [CompilerGeneratedAttribute]
internal static string <CreateWithLocationTags>g__EncodeIndices|3_1(IEnumerable`1<int> indices, int additionalLocationsLength);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper/<<CreateWithMessage>g__GetEffectiveCustomTags|4_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <CreateWithMessage>g__GetEffectiveCustomTags|4_0(DiagnosticDescriptor descriptor, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticSeverityExtensions : object {
    [ExtensionAttribute]
public static ReportDiagnostic ToReportDiagnostic(DiagnosticSeverity diagnosticSeverity);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToEditorConfigString(DiagnosticSeverity diagnosticSeverity);
    [ExtensionAttribute]
public static NotificationOption2 ToNotificationOption(DiagnosticSeverity severity, bool isOverridenSeverity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.DictionaryAnalyzerConfigOptions : AnalyzerConfigOptions {
    internal static ImmutableDictionary`2<string, string> EmptyDictionary;
    [CompilerGeneratedAttribute]
private static DictionaryAnalyzerConfigOptions <Empty>k__BackingField;
    internal ImmutableDictionary`2<string, string> Options;
    public static DictionaryAnalyzerConfigOptions Empty { get; }
    public IEnumerable`1<string> Keys { get; }
    public DictionaryAnalyzerConfigOptions(ImmutableDictionary`2<string, string> options);
    private static DictionaryAnalyzerConfigOptions();
    [CompilerGeneratedAttribute]
public static DictionaryAnalyzerConfigOptions get_Empty();
    public virtual bool TryGetValue(string key, String& value);
    public virtual IEnumerable`1<string> get_Keys();
}
internal static class Microsoft.CodeAnalysis.Diagnostics.EnforceOnBuildValues : object {
    public static EnforceOnBuild RemoveUnnecessaryImports;
    public static EnforceOnBuild UseImplicitType;
    public static EnforceOnBuild UseExplicitType;
    public static EnforceOnBuild AddBraces;
    public static EnforceOnBuild OrderModifiers;
    public static EnforceOnBuild AddAccessibilityModifiers;
    public static EnforceOnBuild ValidateFormatString;
    public static EnforceOnBuild MakeFieldReadonly;
    public static EnforceOnBuild RemoveUnusedMembers;
    public static EnforceOnBuild RemoveUnreadMembers;
    public static EnforceOnBuild Formatting;
    public static EnforceOnBuild ValueAssignedIsUnused;
    public static EnforceOnBuild UnusedParameter;
    public static EnforceOnBuild FileHeaderMismatch;
    public static EnforceOnBuild InvalidSuppressMessageAttribute;
    public static EnforceOnBuild LegacyFormatSuppressMessageAttribute;
    public static EnforceOnBuild RemoveConfusingSuppressionForIsExpression;
    public static EnforceOnBuild UseBlockScopedNamespace;
    public static EnforceOnBuild UseFileScopedNamespace;
    public static EnforceOnBuild UseTupleSwap;
    public static EnforceOnBuild UseThrowExpression;
    public static EnforceOnBuild UseObjectInitializer;
    public static EnforceOnBuild InlineDeclaration;
    public static EnforceOnBuild InlineAsType;
    public static EnforceOnBuild InlineIsType;
    public static EnforceOnBuild UseExpressionBodyForConstructors;
    public static EnforceOnBuild UseExpressionBodyForMethods;
    public static EnforceOnBuild UseExpressionBodyForConversionOperators;
    public static EnforceOnBuild UseExpressionBodyForOperators;
    public static EnforceOnBuild UseExpressionBodyForProperties;
    public static EnforceOnBuild UseExpressionBodyForIndexers;
    public static EnforceOnBuild UseExpressionBodyForAccessors;
    public static EnforceOnBuild UseCollectionInitializer;
    public static EnforceOnBuild UseCoalesceExpression;
    public static EnforceOnBuild UseCoalesceExpressionForNullable;
    public static EnforceOnBuild UseNullPropagation;
    public static EnforceOnBuild UseAutoProperty;
    public static EnforceOnBuild UseExplicitTupleName;
    public static EnforceOnBuild UseDefaultLiteral;
    public static EnforceOnBuild InlineIsTypeWithoutName;
    public static EnforceOnBuild UseLocalFunction;
    public static EnforceOnBuild UseDeconstruction;
    public static EnforceOnBuild UseConditionalExpressionForAssignment;
    public static EnforceOnBuild UseConditionalExpressionForReturn;
    public static EnforceOnBuild RemoveUnnecessaryParentheses;
    public static EnforceOnBuild UseExpressionBodyForLambdaExpressions;
    public static EnforceOnBuild UseCompoundAssignment;
    public static EnforceOnBuild UseIndexOperator;
    public static EnforceOnBuild UseRangeOperator;
    public static EnforceOnBuild UseExpressionBodyForLocalFunctions;
    public static EnforceOnBuild MakeLocalFunctionStatic;
    public static EnforceOnBuild UseSimpleUsingStatement;
    public static EnforceOnBuild MoveMisplacedUsingDirectives;
    public static EnforceOnBuild UseSystemHashCode;
    public static EnforceOnBuild SimplifyInterpolation;
    public static EnforceOnBuild UseCoalesceCompoundAssignment;
    public static EnforceOnBuild SimplifyConditionalExpression;
    public static EnforceOnBuild UsePatternCombinators;
    public static EnforceOnBuild RemoveUnnecessaryByVal;
    public static EnforceOnBuild ConvertTypeOfToNameOf;
    public static EnforceOnBuild UseNotPattern;
    public static EnforceOnBuild UseIsNotExpression;
    public static EnforceOnBuild UseImplicitObjectCreation;
    public static EnforceOnBuild RemoveRedundantEquality;
    public static EnforceOnBuild RemoveUnnecessaryDiscardDesignation;
    public static EnforceOnBuild RemoveUnnecessaryLambdaExpression;
    public static EnforceOnBuild InvokeDelegateWithConditionalAccess;
    public static EnforceOnBuild NamingRule;
    public static EnforceOnBuild MatchFolderAndNamespace;
    public static EnforceOnBuild SimplifyObjectCreation;
    public static EnforceOnBuild SimplifyPropertyPattern;
    public static EnforceOnBuild RemoveRedundantNullableDirective;
    public static EnforceOnBuild RemoveUnnecessaryNullableDirective;
    public static EnforceOnBuild MakeStructReadOnly;
    public static EnforceOnBuild MakeStructMemberReadOnly;
    public static EnforceOnBuild UsePatternMatchingAsAndMemberAccess;
    public static EnforceOnBuild UseCoalesceExpressionForIfNullCheck;
    public static EnforceOnBuild UseNameofInAttribute;
    public static EnforceOnBuild UsePrimaryConstructor;
    public static EnforceOnBuild UseCollectionExpressionForArray;
    public static EnforceOnBuild UseCollectionExpressionForEmpty;
    public static EnforceOnBuild UseCollectionExpressionForStackAlloc;
    public static EnforceOnBuild UseCollectionExpressionForCreate;
    public static EnforceOnBuild UseCollectionExpressionForBuilder;
    public static EnforceOnBuild UseCollectionExpressionForFluent;
    public static EnforceOnBuild MakeAnonymousFunctionStatic;
    public static EnforceOnBuild RemoveUnnecessaryCast;
    public static EnforceOnBuild PopulateSwitchStatement;
    public static EnforceOnBuild UseInferredMemberName;
    public static EnforceOnBuild UseIsNullCheck;
    public static EnforceOnBuild AddRequiredParentheses;
    public static EnforceOnBuild ExpressionValueIsUnused;
    public static EnforceOnBuild MakeStructFieldsWritable;
    public static EnforceOnBuild ConvertSwitchStatementToExpression;
    public static EnforceOnBuild PopulateSwitchExpression;
    public static EnforceOnBuild SimplifyLinqExpression;
    public static EnforceOnBuild UseNullCheckOverTypeCheck;
    public static EnforceOnBuild UseTopLevelStatements;
    public static EnforceOnBuild UseProgramMain;
    public static EnforceOnBuild ForEachCast;
    public static EnforceOnBuild UseUtf8StringLiteral;
    public static EnforceOnBuild MultipleBlankLines;
    public static EnforceOnBuild EmbeddedStatementPlacement;
    public static EnforceOnBuild ConsecutiveBracePlacement;
    public static EnforceOnBuild ConsecutiveStatementPlacement;
    public static EnforceOnBuild ConstructorInitializerPlacement;
    public static EnforceOnBuild ConditionalExpressionPlacement;
    public static EnforceOnBuild ArrowExpressionClausePlacement;
    public static EnforceOnBuild Regex;
    public static EnforceOnBuild Json;
    public static EnforceOnBuild SimplifyNames;
    public static EnforceOnBuild SimplifyMemberAccess;
    public static EnforceOnBuild RemoveQualification;
    public static EnforceOnBuild AddQualification;
    public static EnforceOnBuild PreferBuiltInOrFrameworkType;
    public static EnforceOnBuild ConvertAnonymousTypeToTuple;
    public static EnforceOnBuild RemoveUnreachableCode;
    public static EnforceOnBuild RemoveUnnecessarySuppression;
    public static EnforceOnBuild DetectProbableJsonStrings;
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.Diagnostics.IBuiltInAnalyzer {
    public bool IsHighPriority { get; }
    public abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    public abstract virtual bool OpenFileOnly(SimplifierOptions options);
    public abstract virtual bool get_IsHighPriority();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.IdeAnalyzerOptions : object {
    [NullableAttribute("1")]
private static CodeStyleOption2`1<bool> s_defaultPreferSystemHashCode;
    [NullableAttribute("1")]
public static IdeAnalyzerOptions CommonDefault;
    [CompilerGeneratedAttribute]
private bool <CrashOnAnalyzerException>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportInvalidPlaceholdersInStringDotFormatCalls>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportInvalidRegexPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportInvalidJsonPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetectAndOfferEditorFeaturesForProbableJsonStrings>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSystemHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CleanCodeGenerationOptions> <CleanCodeGenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IdeCodeStyleOptions <CodeStyleOptions>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [DataMemberAttribute]
public bool CrashOnAnalyzerException { get; public set; }
    [DataMemberAttribute]
public bool ReportInvalidPlaceholdersInStringDotFormatCalls { get; public set; }
    [DataMemberAttribute]
public bool ReportInvalidRegexPatterns { get; public set; }
    [DataMemberAttribute]
public bool ReportInvalidJsonPatterns { get; public set; }
    [DataMemberAttribute]
public bool DetectAndOfferEditorFeaturesForProbableJsonStrings { get; public set; }
    [NullableAttribute("1")]
[DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSystemHashCode { get; public set; }
    [DataMemberAttribute]
public Nullable`1<CleanCodeGenerationOptions> CleanCodeGenerationOptions { get; public set; }
    [DataMemberAttribute]
public IdeCodeStyleOptions CodeStyleOptions { get; public set; }
    public CodeCleanupOptions CleanupOptions { get; }
    public CodeGenerationOptions GenerationOptions { get; }
    [CompilerGeneratedAttribute]
private IdeAnalyzerOptions(IdeAnalyzerOptions original);
    private static IdeAnalyzerOptions();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_CrashOnAnalyzerException();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CrashOnAnalyzerException(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReportInvalidPlaceholdersInStringDotFormatCalls();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReportInvalidPlaceholdersInStringDotFormatCalls(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReportInvalidRegexPatterns();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReportInvalidRegexPatterns(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReportInvalidJsonPatterns();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReportInvalidJsonPatterns(bool value);
    [CompilerGeneratedAttribute]
public bool get_DetectAndOfferEditorFeaturesForProbableJsonStrings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DetectAndOfferEditorFeaturesForProbableJsonStrings(bool value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSystemHashCode();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSystemHashCode(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<CleanCodeGenerationOptions> get_CleanCodeGenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CleanCodeGenerationOptions(Nullable`1<CleanCodeGenerationOptions> value);
    [CompilerGeneratedAttribute]
public IdeCodeStyleOptions get_CodeStyleOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CodeStyleOptions(IdeCodeStyleOptions value);
    public CodeCleanupOptions get_CleanupOptions();
    public CodeGenerationOptions get_GenerationOptions();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IdeAnalyzerOptions left, IdeAnalyzerOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IdeAnalyzerOptions left, IdeAnalyzerOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IdeAnalyzerOptions other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IdeAnalyzerOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds : object {
    public static string SimplifyNamesDiagnosticId;
    public static string SimplifyMemberAccessDiagnosticId;
    public static string RemoveThisOrMeQualificationDiagnosticId;
    public static string RemoveUnnecessaryCastDiagnosticId;
    public static string RemoveUnnecessaryImportsDiagnosticId;
    public static string IntellisenseBuildFailedDiagnosticId;
    public static string UseImplicitTypeDiagnosticId;
    public static string UseExplicitTypeDiagnosticId;
    public static string AddThisOrMeQualificationDiagnosticId;
    public static string PopulateSwitchStatementDiagnosticId;
    public static string AddBracesDiagnosticId;
    public static string UseThrowExpressionDiagnosticId;
    public static string UseObjectInitializerDiagnosticId;
    public static string InlineDeclarationDiagnosticId;
    public static string InlineAsTypeCheckId;
    public static string InlineIsTypeCheckId;
    public static string UseExpressionBodyForConstructorsDiagnosticId;
    public static string UseExpressionBodyForMethodsDiagnosticId;
    public static string UseExpressionBodyForConversionOperatorsDiagnosticId;
    public static string UseExpressionBodyForOperatorsDiagnosticId;
    public static string UseExpressionBodyForPropertiesDiagnosticId;
    public static string UseExpressionBodyForIndexersDiagnosticId;
    public static string UseExpressionBodyForAccessorsDiagnosticId;
    public static string UseCollectionInitializerDiagnosticId;
    public static string UseCoalesceExpressionForTernaryConditionalCheckDiagnosticId;
    public static string UseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticId;
    public static string UseNullPropagationDiagnosticId;
    public static string UseAutoPropertyDiagnosticId;
    public static string UseExplicitTupleNameDiagnosticId;
    public static string UseDefaultLiteralDiagnosticId;
    public static string RemoveUnreachableCodeDiagnosticId;
    public static string OrderModifiersDiagnosticId;
    public static string UseInferredMemberNameDiagnosticId;
    public static string InlineIsTypeWithoutNameCheckDiagnosticsId;
    public static string UseLocalFunctionDiagnosticId;
    public static string AddAccessibilityModifiersDiagnosticId;
    public static string UseIsNullCheckDiagnosticId;
    public static string UseDeconstructionDiagnosticId;
    public static string ValidateFormatStringDiagnosticID;
    public static string MakeFieldReadonlyDiagnosticId;
    public static string UseConditionalExpressionForAssignmentDiagnosticId;
    public static string UseConditionalExpressionForReturnDiagnosticId;
    public static string RemoveUnnecessaryParenthesesDiagnosticId;
    public static string AddRequiredParenthesesDiagnosticId;
    public static string PreferBuiltInOrFrameworkTypeDiagnosticId;
    public static string RemoveUnusedMembersDiagnosticId;
    public static string RemoveUnreadMembersDiagnosticId;
    public static string UseExpressionBodyForLambdaExpressionsDiagnosticId;
    public static string UseCompoundAssignmentDiagnosticId;
    public static string FormattingDiagnosticId;
    public static string UseIndexOperatorDiagnosticId;
    public static string UseRangeOperatorDiagnosticId;
    public static string ExpressionValueIsUnusedDiagnosticId;
    public static string ValueAssignedIsUnusedDiagnosticId;
    public static string UnusedParameterDiagnosticId;
    public static string UseExpressionBodyForLocalFunctionsDiagnosticId;
    public static string MakeLocalFunctionStaticDiagnosticId;
    public static string UseSimpleUsingStatementDiagnosticId;
    public static string MakeStructFieldsWritable;
    public static string MoveMisplacedUsingDirectivesDiagnosticId;
    public static string ConvertSwitchStatementToExpressionDiagnosticId;
    public static string UseSystemHashCode;
    public static string SimplifyInterpolationId;
    public static string PopulateSwitchExpressionDiagnosticId;
    public static string FileHeaderMismatch;
    public static string UseCoalesceCompoundAssignmentDiagnosticId;
    public static string SimplifyConditionalExpressionDiagnosticId;
    public static string InvalidSuppressMessageAttributeDiagnosticId;
    public static string LegacyFormatSuppressMessageAttributeDiagnosticId;
    public static string UsePatternCombinatorsDiagnosticId;
    public static string RemoveUnnecessarySuppressionDiagnosticId;
    public static string RemoveConfusingSuppressionForIsExpressionDiagnosticId;
    public static string RemoveUnnecessaryByValDiagnosticId;
    public static string ConvertTypeOfToNameOfDiagnosticId;
    public static string UseNotPatternDiagnosticId;
    public static string UseIsNotExpressionDiagnosticId;
    public static string UseImplicitObjectCreationDiagnosticId;
    public static string RemoveRedundantEqualityDiagnosticId;
    public static string RemoveUnnecessaryDiscardDesignationDiagnosticId;
    public static string SimplifyLinqExpressionDiagnosticId;
    public static string MatchFolderAndNamespaceDiagnosticId;
    public static string SimplifyObjectCreationDiagnosticId;
    public static string UseNullCheckOverTypeCheckDiagnosticId;
    public static string UseBlockScopedNamespaceDiagnosticId;
    public static string UseFileScopedNamespaceDiagnosticId;
    public static string SimplifyPropertyPatternDiagnosticId;
    public static string UseTupleSwapDiagnosticId;
    public static string RemoveUnnecessaryLambdaExpressionDiagnosticId;
    public static string UseTopLevelStatementsId;
    public static string UseProgramMainId;
    public static string ForEachCastDiagnosticId;
    public static string UseUtf8StringLiteralDiagnosticId;
    public static string RemoveRedundantNullableDirectiveDiagnosticId;
    public static string RemoveUnnecessaryNullableDirectiveDiagnosticId;
    public static string MakeStructReadOnlyDiagnosticId;
    public static string MakeStructMemberReadOnlyDiagnosticId;
    public static string UsePatternMatchingAsAndMemberAccessDiagnosticId;
    public static string UseCoalesceExpressionForIfNullCheckDiagnosticId;
    public static string UseNameofInAttributeDiagnosticId;
    public static string UsePrimaryConstructorDiagnosticId;
    public static string UseCollectionExpressionForArrayDiagnosticId;
    public static string UseCollectionExpressionForEmptyDiagnosticId;
    public static string UseCollectionExpressionForStackAllocDiagnosticId;
    public static string UseCollectionExpressionForCreateDiagnosticId;
    public static string UseCollectionExpressionForBuilderDiagnosticId;
    public static string UseCollectionExpressionForFluentDiagnosticId;
    public static string MakeAnonymousFunctionStaticDiagnosticId;
    public static string AnalyzerChangedId;
    public static string AnalyzerDependencyConflictId;
    public static string MissingAnalyzerReferenceId;
    public static string InvokeDelegateWithConditionalAccessId;
    public static string NamingRuleId;
    public static string UnboundIdentifierId;
    public static string MultipleBlankLinesDiagnosticId;
    public static string EmbeddedStatementPlacementDiagnosticId;
    public static string ConsecutiveBracePlacementDiagnosticId;
    public static string ConsecutiveStatementPlacementDiagnosticId;
    public static string ConstructorInitializerPlacementDiagnosticId;
    public static string ConditionalExpressionPlacementDiagnosticId;
    public static string ArrowExpressionClausePlacementDiagnosticId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIdToOptionMappingHelper : object {
    private static ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>> s_diagnosticIdToOptionMap;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>>> s_diagnosticIdToLanguageSpecificOptionsMap;
    private static ConcurrentDictionary`2<string, PerLanguageOption2`1<bool>> s_diagnosticIdToFadingOptionMap;
    private static IDEDiagnosticIdToOptionMappingHelper();
    public static bool TryGetMappedOptions(string diagnosticId, string language, ImmutableHashSet`1& options);
    public static bool TryGetMappedFadingOption(string diagnosticId, PerLanguageOption2`1& fadingOption);
    public static bool IsKnownIDEDiagnosticId(string diagnosticId);
    public static void AddOptionMapping(string diagnosticId, ImmutableHashSet`1<IOption2> options);
    private static void AddOptionMapping(ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>> map, string diagnosticId, ImmutableHashSet`1<IOption2> options);
    public static void AddFadingOptionMapping(string diagnosticId, PerLanguageOption2`1<bool> fadingOption);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Diagnostics.IPragmaSuppressionsAnalyzer {
    public abstract virtual Task AnalyzeAsync(SemanticModel semanticModel, Nullable`1<TextSpan> span, CompilationWithAnalyzers compilationWithAnalyzers, Func`2<DiagnosticAnalyzer, ImmutableArray`1<DiagnosticDescriptor>> getSupportedDiagnostics, Action`1<Diagnostic> reportDiagnostic, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.ReportDiagnosticExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<DiagnosticSeverity> ToDiagnosticSeverity(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static ReportDiagnostic WithDefaultSeverity(ReportDiagnostic reportDiagnostic, DiagnosticSeverity defaultSeverity);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToEditorConfigString(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static NotificationOption2 ToNotificationOption(ReportDiagnostic reportDiagnostic, DiagnosticSeverity defaultSeverity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions : AnalyzerConfigOptions {
    public static StructuredAnalyzerConfigOptions Empty;
    private static ConditionalWeakTable`2<AnalyzerConfigOptions, StructuredAnalyzerConfigOptions> s_codeStyleStructuredOptions;
    private static object s_codeStyleStructuredOptionsLock;
    private static StructuredAnalyzerConfigOptions();
    public abstract virtual NamingStylePreferences GetNamingStylePreferences();
    public static StructuredAnalyzerConfigOptions Create(ImmutableDictionary`2<string, string> options);
    public static StructuredAnalyzerConfigOptions Create(AnalyzerConfigOptions options);
    public sealed virtual bool TryGetOption(OptionKey2 optionKey, T& value);
    public static bool TryGetStructuredOptions(AnalyzerConfigOptions configOptions, StructuredAnalyzerConfigOptions& options);
    private static bool TryGetCorrespondingCodeStyleInstance(AnalyzerConfigOptions configOptions, StructuredAnalyzerConfigOptions& options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.SuppressMessageAttributeState : object {
    internal static string SuppressMessageScope;
    internal static string SuppressMessageTarget;
    private static ImmutableDictionary`2<string, TargetScope> s_targetScopesMap;
    private Compilation _compilation;
    private INamedTypeSymbol _suppressMessageAttributeType;
    [NullableAttribute("0")]
private static string s_suppressionPrefix;
    public SuppressMessageAttributeState(Compilation compilation, INamedTypeSymbol suppressMessageAttributeType);
    private static SuppressMessageAttributeState();
    private static ImmutableDictionary`2<string, TargetScope> CreateTargetScopesMap();
    public bool IsSuppressMessageAttributeWithNamedArguments(SyntaxNode attributeSyntax, SemanticModel model, CancellationToken cancellationToken, ImmutableArray`1& namedAttributeArguments);
    public static bool HasValidScope(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, TargetScope& targetScope);
    [NullableContextAttribute("2")]
public bool HasValidTarget(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, TargetScope targetScope, Boolean& targetHasDocCommentIdFormat, String& targetSymbolString, IOperation& targetValueOperation, ImmutableArray`1& resolvedSymbols);
    [NullableContextAttribute("2")]
private static bool TryGetNamedArgument(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, string argumentName, String& argumentValue, IOperation& argumentValueOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrAdd(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool TryAdd(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void AddPooled(IDictionary`2<K, ArrayBuilder`1<V>> dictionary, K key, V value);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<K, ImmutableArray`1<V>> ToImmutableSegmentedDictionaryAndFree(IReadOnlyDictionary`2<K, ArrayBuilder`1<V>> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Editing.GenerationOptions : object {
    public static PerLanguageOption2`1<bool> PlaceSystemNamespaceFirst;
    public static PerLanguageOption2`1<bool> SeparateImportDirectiveGroups;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<IOption2> EditorConfigOptions;
    private static GenerationOptions();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.EditorConfig.Language : Enum {
    public int value__;
    public static Language CSharp;
    public static Language VisualBasic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.EditorConfig.LanguageConstants : object {
    public static string DefaultCSharpPath;
    public static string DefaultCSharpSplat;
    public static string DefaultCSharpExtension;
    public static string DefaultCSharpExtensionWithoutDot;
    public static string DefaultVisualBasicPath;
    public static string DefaultVisualBasicSplat;
    public static string DefaultVisualBasicExtension;
    public static string DefaultVisualBasicExtensionWithoutDot;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EditorConfig.LanguageExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TryGetLanguageFromFilePath(string filePath, Language& language);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1 : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<T> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableArray`1<Section>> _sections;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string FilePath { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<T> Options { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Section> Sections { get; }
    public EditorConfigFile`1(string FilePath, ImmutableArray`1<T> Options);
    [CompilerGeneratedAttribute]
protected EditorConfigFile`1(EditorConfigFile`1<T> original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilePath(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<T> get_Options();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Options(ImmutableArray`1<T> value);
    public ImmutableArray`1<Section> get_Sections();
    public bool TryGetSectionForLanguage(Language language, Section& sectionResult);
    public bool TryGetSectionForLanguage(Language language, SectionMatch matchKind, Section& sectionResult);
    [NullableContextAttribute("1")]
public bool TryGetSectionForFilePath(string filePath, Section& sectionResult);
    [NullableContextAttribute("1")]
public bool TryGetSectionForFilePath(string filePath, SectionMatch matchKind, Section& sectionResult);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EditorConfigFile`1<T> left, EditorConfigFile`1<T> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EditorConfigFile`1<T> left, EditorConfigFile`1<T> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(EditorConfigFile`1<T> other);
    [CompilerGeneratedAttribute]
public virtual EditorConfigFile`1<T> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& FilePath, ImmutableArray`1& Options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption : object {
    [CompilerGeneratedAttribute]
private Section <Section>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <Span>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Section Section { get; public set; }
    public Nullable`1<TextSpan> Span { get; public set; }
    public EditorConfigOption(Section Section, Nullable`1<TextSpan> Span);
    [CompilerGeneratedAttribute]
protected EditorConfigOption(EditorConfigOption original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Section get_Section();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Section(Section value);
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_Span();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Span(Nullable`1<TextSpan> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(EditorConfigOption left, EditorConfigOption right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(EditorConfigOption left, EditorConfigOption right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(EditorConfigOption other);
    [CompilerGeneratedAttribute]
public virtual EditorConfigOption <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Section& Section, Nullable`1& Span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption`1 : EditorConfigOption {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public T Value { get; public set; }
    public EditorConfigOption`1(Section Section, Nullable`1<TextSpan> Span, T Value);
    [CompilerGeneratedAttribute]
protected EditorConfigOption`1(EditorConfigOption`1<T> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(T value);
    public static T op_Implicit(EditorConfigOption`1<T> option);
    public static EditorConfigOption`1<T> op_Implicit(ValueTuple`3<Section, Nullable`1<TextSpan>, T> tuple);
    public static EditorConfigOption`1<T> op_Implicit(ValueTuple`2<Section, T> tuple);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EditorConfigOption`1<T> left, EditorConfigOption`1<T> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EditorConfigOption`1<T> left, EditorConfigOption`1<T> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(EditorConfigOption other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(EditorConfigOption`1<T> other);
    [CompilerGeneratedAttribute]
public virtual EditorConfigOption <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Section& Section, Nullable`1& Span, T& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigParser : object {
    private static Regex s_sectionMatcher;
    private static Regex s_propertyMatcher;
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<string> <ReservedKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<string> <ReservedValues>k__BackingField;
    private static ImmutableHashSet`1<string> ReservedKeys { get; }
    private static ImmutableHashSet`1<string> ReservedValues { get; }
    private static EditorConfigParser();
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<string> get_ReservedKeys();
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<string> get_ReservedValues();
    public static TEditorConfigFile Parse(string text, string pathToFile, TAccumulator accumulator);
    public static TEditorConfigFile Parse(SourceText text, string pathToFile, TAccumulator accumulator);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <Parse>g__ProcessActiveSection|9_0(<>c__DisplayClass9_0`3& );
    [CompilerGeneratedAttribute]
internal static bool <Parse>g__IsComment|9_1(string line);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditorConfig.Parsing.IEditorConfigOptionAccumulator`2 {
    public abstract virtual void ProcessSection(Section section, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> properties);
    public abstract virtual TResults Complete(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo : object {
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <OptionName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> <SymbolKinds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<ImmutableArray`1<Accessibility>> <Accessibilities>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<ImmutableArray`1<ModifierKind>> <Modifiers>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public EditorConfigOption`1<string> OptionName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> SymbolKinds { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<ImmutableArray`1<Accessibility>> Accessibilities { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<ImmutableArray`1<ModifierKind>> Modifiers { get; public set; }
    public ApplicableSymbolInfo(EditorConfigOption`1<string> OptionName, EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> SymbolKinds, EditorConfigOption`1<ImmutableArray`1<Accessibility>> Accessibilities, EditorConfigOption`1<ImmutableArray`1<ModifierKind>> Modifiers);
    [CompilerGeneratedAttribute]
protected ApplicableSymbolInfo(ApplicableSymbolInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_OptionName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OptionName(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> get_SymbolKinds();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SymbolKinds(EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<ImmutableArray`1<Accessibility>> get_Accessibilities();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Accessibilities(EditorConfigOption`1<ImmutableArray`1<Accessibility>> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<ImmutableArray`1<ModifierKind>> get_Modifiers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Modifiers(EditorConfigOption`1<ImmutableArray`1<ModifierKind>> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ApplicableSymbolInfo left, ApplicableSymbolInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ApplicableSymbolInfo left, ApplicableSymbolInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ApplicableSymbolInfo other);
    [CompilerGeneratedAttribute]
public virtual ApplicableSymbolInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(EditorConfigOption`1& OptionName, EditorConfigOption`1& SymbolKinds, EditorConfigOption`1& Accessibilities, EditorConfigOption`1& Modifiers);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStyles : EditorConfigFile`1<NamingStyleOption> {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<NamingStyleOption> <Rules>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string FileName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<NamingStyleOption> Rules { get; public set; }
    public EditorConfigNamingStyles(string FileName, ImmutableArray`1<NamingStyleOption> Rules);
    [CompilerGeneratedAttribute]
protected EditorConfigNamingStyles(EditorConfigNamingStyles original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileName(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<NamingStyleOption> get_Rules();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Rules(ImmutableArray`1<NamingStyleOption> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EditorConfigNamingStyles left, EditorConfigNamingStyles right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EditorConfigNamingStyles left, EditorConfigNamingStyles right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(EditorConfigFile`1<NamingStyleOption> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(EditorConfigNamingStyles other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual EditorConfigFile`1<NamingStyleOption> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& FileName, ImmutableArray`1& Rules);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStylesParser : object {
    public static EditorConfigNamingStyles Parse(string editorConfigText, string pathToEditorConfigFile);
    public static EditorConfigNamingStyles Parse(SourceText editorConfigText, string pathToEditorConfigFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme : object {
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <OptionName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <Prefix>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <Suffix>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <WordSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<Capitalization> <Capitalization>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public EditorConfigOption`1<string> OptionName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<string> Prefix { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<string> Suffix { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<string> WordSeparator { get; public set; }
    public EditorConfigOption`1<Capitalization> Capitalization { get; public set; }
    public NamingScheme(EditorConfigOption`1<string> OptionName, EditorConfigOption`1<string> Prefix, EditorConfigOption`1<string> Suffix, EditorConfigOption`1<string> WordSeparator, EditorConfigOption`1<Capitalization> Capitalization);
    [CompilerGeneratedAttribute]
protected NamingScheme(NamingScheme original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_OptionName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OptionName(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_Suffix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Suffix(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_WordSeparator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WordSeparator(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<Capitalization> get_Capitalization();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Capitalization(EditorConfigOption`1<Capitalization> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NamingScheme left, NamingScheme right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NamingScheme left, NamingScheme right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(NamingScheme other);
    [CompilerGeneratedAttribute]
public virtual NamingScheme <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(EditorConfigOption`1& OptionName, EditorConfigOption`1& Prefix, EditorConfigOption`1& Suffix, EditorConfigOption`1& WordSeparator, EditorConfigOption`1& Capitalization);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption : EditorConfigOption {
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <RuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicableSymbolInfo <ApplicableSymbolInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingScheme <NamingScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<ReportDiagnostic> <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public EditorConfigOption`1<string> RuleName { get; public set; }
    public ApplicableSymbolInfo ApplicableSymbolInfo { get; public set; }
    public NamingScheme NamingScheme { get; public set; }
    public EditorConfigOption`1<ReportDiagnostic> Severity { get; public set; }
    public NamingStyleOption(Section Section, EditorConfigOption`1<string> RuleName, ApplicableSymbolInfo ApplicableSymbolInfo, NamingScheme NamingScheme, EditorConfigOption`1<ReportDiagnostic> Severity);
    [CompilerGeneratedAttribute]
protected NamingStyleOption(NamingStyleOption original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_RuleName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RuleName(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public ApplicableSymbolInfo get_ApplicableSymbolInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ApplicableSymbolInfo(ApplicableSymbolInfo value);
    [CompilerGeneratedAttribute]
public NamingScheme get_NamingScheme();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamingScheme(NamingScheme value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<ReportDiagnostic> get_Severity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Severity(EditorConfigOption`1<ReportDiagnostic> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NamingStyleOption left, NamingStyleOption right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NamingStyleOption left, NamingStyleOption right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(EditorConfigOption other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(NamingStyleOption other);
    [CompilerGeneratedAttribute]
public virtual EditorConfigOption <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Section& Section, EditorConfigOption`1& RuleName, ApplicableSymbolInfo& ApplicableSymbolInfo, NamingScheme& NamingScheme, EditorConfigOption`1& Severity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOptionAccumulator : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<NamingStyleOption> _rules;
    public sealed virtual EditorConfigNamingStyles Complete(string fileName);
    public sealed virtual void ProcessSection(Section section, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.Section : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGlobal>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullText>k__BackingField;
    private Nullable`1<SectionMatcher> _matcher;
    [NullableAttribute("2")]
private string _containingDirectory;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [NullableAttribute("2")]
public string FilePath { get; public set; }
    public bool IsGlobal { get; public set; }
    public TextSpan Span { get; public set; }
    public string Text { get; public set; }
    public string FullText { get; public set; }
    private bool IsSplatHeader { get; }
    public Section(string filePath, bool isGlobal, TextSpan span, string text, string fullText);
    [CompilerGeneratedAttribute]
private Section(Section original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FilePath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilePath(string value);
    [CompilerGeneratedAttribute]
public bool get_IsGlobal();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsGlobal(bool value);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Span(TextSpan value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_FullText();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FullText(string value);
    private bool get_IsSplatHeader();
    [NullableContextAttribute("2")]
public static string GetHeaderTextForLanguage(Language language);
    public bool SupportsLanguage(Language language, SectionMatch matchKind);
    public bool SupportsFilePath(string codeFilePath, SectionMatch matchKind);
    public SectionMatch GetMatchKind(Language language);
    public SectionMatch GetMatchKind(string codeFilePath);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Section other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Section left, Section right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Section left, Section right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public Section <Clone>$();
    [CompilerGeneratedAttribute]
internal static string <GetMatchKind>g__GetPathRelativeToEditorconfig|31_0(string directoryContainingEditorconfig, string codeFilePath);
}
internal enum Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch : Enum {
    public int value__;
    public static SectionMatch ExactLanguageMatch;
    public static SectionMatch ExactLanguageMatchWithOthers;
    public static SectionMatch AnyLanguageMatch;
    public static SectionMatch SupersetFilePatternMatch;
    public static SectionMatch FilePatternMatch;
    public static SectionMatch SplatMatch;
    public static SectionMatch GlobalSectionMatch;
    public static SectionMatch AnyButGlobal;
    public static SectionMatch Any;
    public static SectionMatch NoMatch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatcher : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
private ImmutableArray`1<ValueTuple`2<int, int>> _numberRangePairs;
    private string _headerText;
    private static Regex s_multiFileWithDotOutside;
    private static Regex s_multiFileWithDotInside;
    private static Regex s_fileExtensionMatcher;
    [CompilerGeneratedAttribute]
private Regex <Regex>k__BackingField;
    private Regex Regex { get; }
    private SectionMatcher(Regex regex, string headerText, ImmutableArray`1<ValueTuple`2<int, int>> numberRangePairs);
    private static SectionMatcher();
    [CompilerGeneratedAttribute]
private Regex get_Regex();
    public bool IsLanguageMatch(Language language, SectionMatch matchKind);
    public bool IsPathMatch(string relativePath, SectionMatch matchKind);
    public SectionMatch GetLanguageMatchKind(Language language);
    public SectionMatch GetPathMatchKind(string relativePath);
    private bool IsExactLanguageMatch(Language language);
    private bool IsExactLanguageMatchForCSharp(Language language);
    private bool IsExactLanguageMatchForVisualBasic(Language language);
    private bool IsExactLanguageMatchForBothVisualBasicAndCSharp(Language language);
    private static bool MatchesBothLanguages(string text, Regex pattern, string firstFileExtension, string secondFileExtension);
    private bool IsExactLanguageMatchWithOthers(Language language);
    private bool IsExactMatchForCSharpWithOthers(Language language);
    private bool IsExactMatchForVisualBasicWithOthers(Language language);
    private static bool IsMatchWithOthers(string text, Regex pattern, string mustMatchFileExtension, string mustNotMatchFileExtension);
    private bool IsExactMatchForBothVisualBasicAndCSharpWithOthers(Language language);
    private static bool MatchesBothLanguagesWithOthers(string text, Regex pattern, string firstFileExtension, string secondFileExtension);
    private bool IsAnyLanguageMatch(Language language);
    private bool IsAnyLanguageMatchForCSharp(Language language);
    private bool IsAnyLanguageMatchForVisualBasic(Language language);
    private bool IsFilePatternMatch(Language language);
    private bool IsCSharpFilePatternMatch(Language language);
    private bool IsVisualBasicFilePatternMatch(Language language);
    private bool IsPatternMatchForBothVisualBasicAndCSharp(Language language);
    private static bool IsSuperSet(Language language, string pattern);
    private static bool IsCSharpSuperSet(Language language, string pattern);
    private static bool IsVisualBasicSuperSet(Language language, string pattern);
    private static bool IsCSharpOrVisualBasicSuperSet(Language language, string pattern);
    private bool IsPathMatch(string s);
    public static bool TryParseSection(string headerText, SectionMatcher& matcher);
    private static bool TryCompilePathList(Lexer& lexer, StringBuilder sb, bool parsingChoice, ArrayBuilder`1<ValueTuple`2<int, int>> numberRangePairs);
    private static Nullable`1<ValueTuple`2<string, string>> TryParseNumberRange(Lexer& lexer);
    private static bool TryCompileCharacterClass(Lexer& lexer, StringBuilder sb);
    private static bool TryCompileChoice(Lexer& lexer, StringBuilder sb, ArrayBuilder`1<ValueTuple`2<int, int>> numberRangePairs);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatchExtensions : object {
    [ExtensionAttribute]
public static bool IsWorseMatchThan(SectionMatch actualMatchKind, SectionMatch expectedMatchKind);
    [ExtensionAttribute]
public static bool IsWorseOrEqualMatchThan(SectionMatch actualMatchKind, SectionMatch expectedMatchKind);
    [ExtensionAttribute]
public static bool IsBetterMatchThan(SectionMatch actualMatchKind, SectionMatch expectedMatchKind);
    [ExtensionAttribute]
public static bool IsBetterOrEqualMatchThan(SectionMatch actualMatchKind, SectionMatch expectedMatchKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.EditorConfigSeverityStrings : object {
    public static string None;
    public static string Refactoring;
    public static string Silent;
    public static string Suggestion;
    public static string Warning;
    public static string Error;
    public static bool TryParse(string editorconfigSeverityString, ReportDiagnostic& reportDiagnostic);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic : ValueType {
    public string Message;
    public TextSpan Span;
    public EmbeddedDiagnostic(string message, TextSpan span);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EmbeddedDiagnostic other);
    public virtual string ToString();
    public virtual int GetHashCode();
    public static bool op_Equality(EmbeddedDiagnostic diagnostic1, EmbeddedDiagnostic diagnostic2);
    public static bool op_Inequality(EmbeddedDiagnostic diagnostic1, EmbeddedDiagnostic diagnostic2);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSeparatedSyntaxNodeList`3 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> <NodesAndTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SeparatorLength>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static EmbeddedSeparatedSyntaxNodeList`3<TSyntaxKind, TSyntaxNode, TDerivedNode> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> NodesAndTokens { get; }
    public int Length { get; }
    public int SeparatorLength { get; }
    [NullableAttribute("1")]
public TDerivedNode Item { get; }
    public EmbeddedSeparatedSyntaxNodeList`3(ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> nodesAndTokens);
    private static EmbeddedSeparatedSyntaxNodeList`3();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> get_NodesAndTokens();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public int get_SeparatorLength();
    [ConditionalAttribute("DEBUG")]
private void Verify();
    [NullableContextAttribute("1")]
public TDerivedNode get_Item(int index);
    public Enumerator<TSyntaxKind, TSyntaxNode, TDerivedNode> GetEnumerator();
}
internal static class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxHelpers : object {
    public static TextSpan GetSpan(EmbeddedSyntaxToken`1<TSyntaxKind> token1, EmbeddedSyntaxToken`1<TSyntaxKind> token2);
    public static TextSpan GetSpan(VirtualCharSequence virtualChars);
    public static TextSpan GetSpan(VirtualChar firstChar, VirtualChar lastChar);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNode`2 : object {
    public TSyntaxKind Kind;
    private Nullable`1<TextSpan> _fullSpan;
    internal int ChildCount { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> Item { get; }
    protected EmbeddedSyntaxNode`2(TSyntaxKind kind);
    internal abstract virtual int get_ChildCount();
    internal abstract virtual EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> ChildAt(int index);
    public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> get_Item(int index);
    public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> get_Item(Index index);
    public TextSpan GetSpan();
    public Nullable`1<TextSpan> GetFullSpan();
    private Nullable`1<TextSpan> ComputeFullSpan();
    private void GetSpan(Int32& start, Int32& end);
    public bool Contains(VirtualChar virtualChar);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToFullString();
    [NullableContextAttribute("1")]
public void WriteTo(StringBuilder sb, bool leading, bool trailing);
    public Enumerator<TSyntaxKind, TSyntaxNode> GetEnumerator();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ComputeFullSpan>g__ComputeStart|12_0();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ComputeFullSpan>g__ComputeEnd|12_1();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNodeOrToken`2 : ValueType {
    private EmbeddedSyntaxToken`1<TSyntaxKind> _token;
    [NullableAttribute("2")]
public TSyntaxNode Node;
    public EmbeddedSyntaxToken`1<TSyntaxKind> Token { get; }
    public TSyntaxKind Kind { get; }
    [MemberNotNullWhenAttribute("True", "Node")]
public bool IsNode { get; }
    [NullableContextAttribute("2")]
private EmbeddedSyntaxNodeOrToken`2(TSyntaxNode node);
    private EmbeddedSyntaxNodeOrToken`2(EmbeddedSyntaxToken`1<TSyntaxKind> token);
    public EmbeddedSyntaxToken`1<TSyntaxKind> get_Token();
    public TSyntaxKind get_Kind();
    [MemberNotNullWhenAttribute("True", "Node")]
public bool get_IsNode();
    public Nullable`1<TextSpan> GetFullSpan();
    [NullableContextAttribute("2")]
public static EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> op_Implicit(TSyntaxNode node);
    public static EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> op_Implicit(EmbeddedSyntaxToken`1<TSyntaxKind> token);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1 : ValueType {
    public TSyntaxKind Kind;
    public ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>> LeadingTrivia;
    public VirtualCharSequence VirtualChars;
    public ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>> TrailingTrivia;
    internal ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    [NullableAttribute("1")]
public object Value;
    public bool IsMissing { get; }
    public EmbeddedSyntaxToken`1(TSyntaxKind kind, ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>> leadingTrivia, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>> trailingTrivia, ImmutableArray`1<EmbeddedDiagnostic> diagnostics, object value);
    public bool get_IsMissing();
    public EmbeddedSyntaxToken`1<TSyntaxKind> AddDiagnosticIfNone(EmbeddedDiagnostic diagnostic);
    public EmbeddedSyntaxToken`1<TSyntaxKind> WithDiagnostics(ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public EmbeddedSyntaxToken`1<TSyntaxKind> With(Optional`1<TSyntaxKind> kind, Optional`1<ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>>> leadingTrivia, Optional`1<VirtualCharSequence> virtualChars, Optional`1<ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>>> trailingTrivia, Optional`1<ImmutableArray`1<EmbeddedDiagnostic>> diagnostics, Optional`1<object> value);
    public TextSpan GetSpan();
    public Nullable`1<TextSpan> GetFullSpan();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToFullString();
    [NullableContextAttribute("1")]
public void WriteTo(StringBuilder sb, bool leading, bool trailing);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTree`3 : object {
    public VirtualCharSequence Text;
    [NullableAttribute("1")]
public TCompilationUnitSyntax Root;
    public ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    protected EmbeddedSyntaxTree`3(VirtualCharSequence text, TCompilationUnitSyntax root, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia`1 : ValueType {
    public TSyntaxKind Kind;
    public VirtualCharSequence VirtualChars;
    internal ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    public EmbeddedSyntaxTrivia`1(TSyntaxKind kind, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public TextSpan GetSpan();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService : object {
    protected ISyntaxFacts SyntaxFacts { get; }
    public abstract virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual VirtualCharSequence TryConvertToVirtualCharsWorker(SyntaxToken token);
    protected abstract virtual bool IsMultiLineRawStringToken(SyntaxToken token);
    protected static bool IsLegalBraceEscape(string tokenText, int index, int offset, TextSpan& span);
    public sealed virtual VirtualCharSequence TryConvertToVirtualChars(SyntaxToken token);
    [ConditionalAttribute("DEBUG")]
private void CheckInvariants(SyntaxToken token, VirtualCharSequence result);
    protected static VirtualCharSequence TryConvertSimpleDoubleQuoteString(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    protected static int ConvertTextAtIndexToRune(string tokenText, int index, Builder<VirtualChar> result, int offset);
    protected static int ConvertTextAtIndexToRune(SourceText tokenText, int index, Builder<VirtualChar> result, int offset);
    private static int ConvertTextAtIndexToRune(T tokenText, int index, TTextInfo info, Builder<VirtualChar> result, int offset);
    protected static bool IsOpenOrCloseBrace(char ch);
    protected static VirtualCharSequence CreateVirtualCharSequence(string tokenText, int offset, int startIndexInclusive, int endIndexExclusive, Builder<VirtualChar> result);
}
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService {
    public abstract virtual VirtualCharSequence TryConvertToVirtualChars(SyntaxToken token);
    public abstract virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapeChar);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar : ValueType {
    public Rune Rune;
    public char SurrogateChar;
    public TextSpan Span;
    public int Value { get; }
    public bool IsDigit { get; }
    public bool IsLetter { get; }
    public bool IsLetterOrDigit { get; }
    public bool IsWhiteSpace { get; }
    public int Utf16SequenceLength { get; }
    private VirtualChar(Rune rune, char surrogateChar, TextSpan span);
    public static VirtualChar Create(Rune rune, TextSpan span);
    public static VirtualChar Create(char surrogateChar, TextSpan span);
    public int get_Value();
    public bool get_IsDigit();
    public bool get_IsLetter();
    public bool get_IsLetterOrDigit();
    public bool get_IsWhiteSpace();
    public int get_Utf16SequenceLength();
    public static bool op_Equality(VirtualChar ch1, char ch2);
    public static bool op_Inequality(VirtualChar ch1, char ch2);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public void AppendTo(StringBuilder builder);
    public sealed virtual int CompareTo(VirtualChar other);
    public static bool op_LessThan(VirtualChar ch1, VirtualChar ch2);
    public static bool op_LessThanOrEqual(VirtualChar ch1, VirtualChar ch2);
    public static bool op_GreaterThan(VirtualChar ch1, VirtualChar ch2);
    public static bool op_GreaterThanOrEqual(VirtualChar ch1, VirtualChar ch2);
    public sealed virtual int CompareTo(char other);
    public static bool op_LessThan(VirtualChar ch1, char ch2);
    public static bool op_LessThanOrEqual(VirtualChar ch1, char ch2);
    public static bool op_GreaterThan(VirtualChar ch1, char ch2);
    public static bool op_GreaterThanOrEqual(VirtualChar ch1, char ch2);
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VirtualChar left, VirtualChar right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VirtualChar left, VirtualChar right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VirtualChar other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence : ValueType {
    public static VirtualCharSequence Empty;
    private Chunk _leafCharacters;
    private TextSpan _span;
    public int Length { get; }
    public VirtualChar Item { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    public bool IsDefaultOrEmpty { get; }
    private VirtualCharSequence(Chunk sequence);
    private VirtualCharSequence(Chunk sequence, TextSpan span);
    private static VirtualCharSequence();
    [NullableContextAttribute("0")]
public static VirtualCharSequence Create(ImmutableSegmentedList`1<VirtualChar> virtualChars);
    public static VirtualCharSequence Create(int firstVirtualCharPosition, string underlyingData);
    public int get_Length();
    public VirtualChar get_Item(int index);
    public bool get_IsDefault();
    public bool get_IsEmpty();
    public bool get_IsDefaultOrEmpty();
    public VirtualCharSequence GetSubSequence(TextSpan span);
    public Enumerator GetEnumerator();
    public VirtualChar First();
    public VirtualChar Last();
    public Nullable`1<VirtualChar> Find(int position);
    public bool Contains(VirtualChar char);
    public int IndexOf(VirtualChar char);
    public Nullable`1<VirtualChar> FirstOrNull(Func`2<VirtualChar, bool> predicate);
    public Nullable`1<VirtualChar> LastOrNull(Func`2<VirtualChar, bool> predicate);
    public bool Any(Func`2<VirtualChar, bool> predicate);
    public bool All(Func`2<VirtualChar, bool> predicate);
    public VirtualCharSequence Skip(int count);
    public VirtualCharSequence SkipWhile(Func`2<VirtualChar, bool> predicate);
    public string CreateString();
    [ConditionalAttribute("DEBUG")]
public void AssertAdjacentTo(VirtualCharSequence virtualChars);
    public static VirtualCharSequence FromBounds(VirtualCharSequence chars1, VirtualCharSequence chars2);
}
internal class Microsoft.CodeAnalysis.EmptyReadOnlyMemoryOfCharComparer : object {
    public static EmptyReadOnlyMemoryOfCharComparer Instance;
    private static EmptyReadOnlyMemoryOfCharComparer();
    public sealed virtual bool Equals(ReadOnlyMemory`1<char> a, ReadOnlyMemory`1<char> b);
    public sealed virtual int GetHashCode(ReadOnlyMemory`1<char> s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EncodingExtensions : object {
    internal static TextEncodingKind FirstTextEncodingKind;
    internal static TextEncodingKind LastTextEncodingKind;
    private static Encoding s_encodingUtf8;
    private static Encoding s_encodingUtf32_BE;
    private static Encoding s_encodingUtf32_BE_BOM;
    private static Encoding s_encodingUtf32_LE;
    private static Encoding s_encodingUnicode_BE;
    private static Encoding s_encodingUnicode_LE;
    private static EncodingExtensions();
    [ExtensionAttribute]
internal static bool TryGetMaxCharCount(Encoding encoding, long length, Int32& maxCharCount);
    [ExtensionAttribute]
public static Encoding GetEncoding(TextEncodingKind kind);
    [ExtensionAttribute]
public static bool TryGetEncodingKind(Encoding encoding, TextEncodingKind& kind);
    [ExtensionAttribute]
public static bool HasPreamble(Encoding encoding);
}
internal enum Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity : Enum {
    public int value__;
    public static ErrorSeverity Uncategorized;
    public static ErrorSeverity Diagnostic;
    public static ErrorSeverity General;
    public static ErrorSeverity Critical;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ErrorReporting.FatalError : object {
    [NullableAttribute("2")]
private static ErrorReporterHandler s_handler;
    [NullableAttribute("2")]
private static ErrorReporterHandler s_nonFatalHandler;
    [NullableAttribute("2")]
private static Exception s_reportedException;
    [NullableAttribute("2")]
private static string s_reportedExceptionMessage;
    private static object s_reportedMarker;
    private static FatalError();
    public static void SetHandlers(ErrorReporterHandler handler, ErrorReporterHandler nonFatalHandler);
    [NullableContextAttribute("2")]
public static void OverwriteHandler(ErrorReporterHandler value);
    public static void CopyHandlersTo(Assembly assembly);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagate(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagateUnlessCanceled(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagateUnlessCanceled(Exception exception, CancellationToken contextCancellationToken, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatch(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportWithDumpAndCatch(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatchUnlessCanceled(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatchUnlessCanceled(Exception exception, CancellationToken contextCancellationToken, ErrorSeverity severity);
    private static void Report(Exception exception, ErrorSeverity severity, bool forceDump);
    public static void ReportNonFatalError(Exception exception, ErrorSeverity severity, bool forceDump);
    private static void ReportException(Exception exception, ErrorSeverity severity, bool forceDump, ErrorReporterHandler handler);
    [CompilerGeneratedAttribute]
internal static void <CopyHandlersTo>g__copyHandlerTo|7_0(Assembly assembly, ErrorReporterHandler handler, string handlerName);
}
internal class Microsoft.CodeAnalysis.ErrorReporting.OperationCanceledIgnoringCallerTokenException : OperationCanceledException {
    [NullableContextAttribute("1")]
public OperationCanceledIgnoringCallerTokenException(Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FailFast : object {
    internal static ErrorReporterHandler Handler;
    private static FailFast();
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
internal static void OnFatalException(Exception exception);
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
internal static void Fail(string message);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
internal static void DumpStackTrace(Exception exception, string message);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
internal static void Assert(bool condition, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_invalidHeaderTitle;
    private static LocalizableString s_invalidHeaderMessage;
    private static DiagnosticDescriptor s_invalidHeaderDescriptor;
    private static LocalizableString s_missingHeaderTitle;
    private static LocalizableString s_missingHeaderMessage;
    private static DiagnosticDescriptor s_missingHeaderDescriptor;
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    private static AbstractFileHeaderDiagnosticAnalyzer();
    private static DiagnosticDescriptor CreateDescriptorForFileHeader(LocalizableString title, LocalizableString message);
    protected abstract virtual AbstractFileHeaderHelper get_FileHeaderHelper();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void HandleSyntaxTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private static bool CompareCopyrightText(string expectedFileHeader, string copyrightText);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__11_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper : object {
    [CompilerGeneratedAttribute]
private int <SingleLineCommentTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MultiLineCommentTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WhitespaceTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOfLineTriviaKind>k__BackingField;
    public string CommentPrefix { get; }
    private int SingleLineCommentTriviaKind { get; }
    private Nullable`1<int> MultiLineCommentTriviaKind { get; }
    private int WhitespaceTriviaKind { get; }
    private int EndOfLineTriviaKind { get; }
    protected AbstractFileHeaderHelper(ISyntaxKinds syntaxKinds);
    public abstract virtual string get_CommentPrefix();
    [NullableContextAttribute("0")]
protected abstract virtual ReadOnlyMemory`1<char> GetTextContextOfComment(SyntaxTrivia commentTrivia);
    [CompilerGeneratedAttribute]
private int get_SingleLineCommentTriviaKind();
    [CompilerGeneratedAttribute]
private Nullable`1<int> get_MultiLineCommentTriviaKind();
    [CompilerGeneratedAttribute]
private int get_WhitespaceTriviaKind();
    [CompilerGeneratedAttribute]
private int get_EndOfLineTriviaKind();
    public FileHeader ParseFileHeader(SyntaxNode root);
    private int IndexOfFirstNonWhitespaceTrivia(T triviaList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.FileHeaders.FileHeader : ValueType {
    private int _fileHeaderStart;
    private int _commentPrefixLength;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyrightText>k__BackingField;
    internal bool IsMissing { get; }
    internal string CopyrightText { get; }
    internal FileHeader(string copyrightText, int fileHeaderStart, int fileHeaderEnd, int commentPrefixLength);
    private FileHeader(int fileHeaderStart, bool isMissing);
    [CompilerGeneratedAttribute]
internal bool get_IsMissing();
    [CompilerGeneratedAttribute]
internal string get_CopyrightText();
    internal static FileHeader MissingFileHeader(int fileHeaderStart);
    internal Location GetLocation(SyntaxTree syntaxTree);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions : object {
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions/<DescendantOperations>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(BasicBlock basicBlock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions : object {
    [ExtensionAttribute]
public static BasicBlock EntryBlock(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static BasicBlock ExitBlock(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static IEnumerable`1<T> DescendantOperations(ControlFlowGraph cfg, OperationKind operationKind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool ContainsBlock(ControlFlowRegion region, int destinationOrdinal);
}
internal static class Microsoft.CodeAnalysis.FlowAnalysis.CustomDataFlowAnalysis`1 : object {
    public static TBlockAnalysisData Run(ControlFlowGraph controlFlowGraph, DataFlowAnalyzer`1<TBlockAnalysisData> analyzer, CancellationToken cancellationToken);
    private static TBlockAnalysisData RunCore(ImmutableArray`1<BasicBlock> blocks, DataFlowAnalyzer`1<TBlockAnalysisData> analyzer, int firstBlockOrdinal, int lastBlockOrdinal, TBlockAnalysisData initialAnalysisData, ArrayBuilder`1<BasicBlock> unreachableBlocksToVisit, SortedSet`1<int> outOfRangeBlocksToVisit, PooledDictionary`2<ControlFlowRegion, bool> continueDispatchAfterFinally, PooledHashSet`1<ControlFlowRegion> dispatchedExceptionsFromRegions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <RunCore>g__FollowBranch|1_0(BasicBlock current, ControlFlowBranch branch, TBlockAnalysisData currentAnalsisData, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <RunCore>g__StepThroughFinally|1_1(ControlFlowRegion region, int destinationOrdinal, TBlockAnalysisData& currentAnalysisData, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <RunCore>g__StepThroughSingleFinally|1_2(ControlFlowRegion finally, TBlockAnalysisData& currentAnalysisData, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <RunCore>g__DispatchException|1_3(ControlFlowRegion fromRegion, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <RunCore>g__DispatchExceptionThroughCatches|1_4(ControlFlowRegion tryAndCatch, int startAt, <>c__DisplayClass1_0& );
}
internal abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1 : object {
    public bool AnalyzeUnreachableBlocks { get; }
    public abstract virtual TBlockAnalysisData GetCurrentAnalysisData(BasicBlock basicBlock);
    public abstract virtual TBlockAnalysisData GetEmptyAnalysisData();
    public abstract virtual void SetCurrentAnalysisData(BasicBlock basicBlock, TBlockAnalysisData data, CancellationToken cancellationToken);
    public abstract virtual TBlockAnalysisData AnalyzeBlock(BasicBlock basicBlock, CancellationToken cancellationToken);
    public abstract virtual TBlockAnalysisData AnalyzeNonConditionalBranch(BasicBlock basicBlock, TBlockAnalysisData currentAnalysisData, CancellationToken cancellationToken);
    public abstract virtual ValueTuple`2<TBlockAnalysisData, TBlockAnalysisData> AnalyzeConditionalBranch(BasicBlock basicBlock, TBlockAnalysisData currentAnalysisData, CancellationToken cancellationToken);
    public abstract virtual TBlockAnalysisData Merge(TBlockAnalysisData analysisData1, TBlockAnalysisData analysisData2, CancellationToken cancellationToken);
    public abstract virtual bool IsEqual(TBlockAnalysisData analysisData1, TBlockAnalysisData analysisData2);
    public abstract virtual bool get_AnalyzeUnreachableBlocks();
    public virtual void Dispose();
}
internal enum Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind : Enum {
    public int value__;
    public static FlowCaptureKind RValueCapture;
    public static FlowCaptureKind LValueCapture;
    public static FlowCaptureKind LValueAndRValueCapture;
}
internal static class Microsoft.CodeAnalysis.FlowAnalysis.LValueFlowCapturesProvider : object {
    public static ImmutableDictionary`2<CaptureId, FlowCaptureKind> CreateLValueFlowCaptures(ControlFlowGraph cfg);
}
internal static class Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis : object {
    public static SymbolUsageResult Run(ControlFlowGraph cfg, ISymbol owningSymbol, CancellationToken cancellationToken);
    public static SymbolUsageResult Run(IOperation rootOperation, ISymbol owningSymbol, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<ValueTuple`2<ISymbol, IOperation>, bool> <SymbolWritesMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<ISymbol> <SymbolsRead>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<ValueTuple`2<ISymbol, IOperation>, bool> SymbolWritesMap { get; }
    public ImmutableHashSet`1<ISymbol> SymbolsRead { get; }
    public SymbolUsageResult(ImmutableDictionary`2<ValueTuple`2<ISymbol, IOperation>, bool> symbolWritesMap, ImmutableHashSet`1<ISymbol> symbolsRead);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<ValueTuple`2<ISymbol, IOperation>, bool> get_SymbolWritesMap();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ISymbol> get_SymbolsRead();
    public bool HasUnreadSymbolWrites();
    public IEnumerable`1<ValueTuple`2<ISymbol, IOperation>> GetUnreadSymbolWrites();
    public bool IsInitialParameterValueUsed(IParameterSymbol parameter);
    public int GetSymbolWriteCount(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ForEachCast.AbstractForEachCastDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableDictionary`2<string, string> s_isFixableProperties;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractForEachCastDiagnosticAnalyzer`2();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TSyntaxKind> GetSyntaxKinds();
    protected abstract virtual ValueTuple`2<CommonConversion, ITypeSymbol> GetForEachInfo(SemanticModel semanticModel, TForEachStatementSyntax node);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static bool IsStronglyTyped(ITypeSymbol collectionType, ITypeSymbol collectionElementType);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(SyntaxNodeAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.ForEachCast.ForEachCastHelpers : object {
    [NullableAttribute("1")]
public static string IsFixable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractAggregatedFormattingResult : object {
    protected SyntaxNode Node;
    private IList`1<AbstractFormattingResult> _formattingResults;
    [NullableAttribute("2")]
private TextSpanMutableIntervalTree _formattingSpans;
    private CancellableLazy`1<IList`1<TextChange>> _lazyTextChanges;
    private CancellableLazy`1<SyntaxNode> _lazyNode;
    public bool ContainsChanges { get; }
    public AbstractAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> formattingResults, TextSpanMutableIntervalTree formattingSpans);
    protected abstract virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
    protected TextSpanMutableIntervalTree GetFormattingSpans();
    public bool get_ContainsChanges();
    public sealed virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public sealed virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChanges(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChangesWorker(CancellationToken cancellationToken);
    private SyntaxNode CreateFormattedRoot(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <CreateTextChanges>b__12_0(TextChange s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine : object {
    private static ObjectPool`1<SegmentedList`1<TokenPairWithOperations>> s_tokenPairListPool;
    private ChainedFormattingRules _formattingRules;
    private SyntaxNode _commonRoot;
    private SyntaxToken _startToken;
    private SyntaxToken _endToken;
    protected TextSpan SpanToFormat;
    internal SyntaxFormattingOptions Options;
    internal TreeData TreeData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Tuple`3<ImmutableArray`1<AbstractFormattingRule>, SyntaxFormattingOptions, ChainedFormattingRules> s_lastRulesAndOptions;
    internal IHeaderFacts HeaderFacts { get; }
    public AbstractFormatEngine(TreeData treeData, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> formattingRules, SyntaxToken startToken, SyntaxToken endToken);
    internal AbstractFormatEngine(TreeData treeData, SyntaxFormattingOptions options, ChainedFormattingRules formattingRules, SyntaxToken startToken, SyntaxToken endToken);
    private static AbstractFormatEngine();
    private static ChainedFormattingRules GetChainedFormattingRules(ImmutableArray`1<AbstractFormattingRule> formattingRules, SyntaxFormattingOptions options);
    internal abstract virtual IHeaderFacts get_HeaderFacts();
    protected abstract virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected abstract virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
    public AbstractFormattingResult Format(CancellationToken cancellationToken);
    protected virtual FormattingContext CreateFormattingContext(TokenStream tokenStream, CancellationToken cancellationToken);
    protected virtual NodeOperations CreateNodeOperations(CancellationToken cancellationToken);
    private static void AddOperations(SegmentedList`1<T> operations, List`1<T> scratch, SyntaxNode node, Action`2<List`1<T>, SyntaxNode> addOperations);
    private static void AddOperations(SegmentedList`1<T> operations, ArrayBuilder`1<T> scratch, SyntaxNode node, Action`2<ArrayBuilder`1<T>, SyntaxNode> addOperations);
    private void AddTokenOperations(TokenStream tokenStream, SegmentedList`1<TokenPairWithOperations> list, CancellationToken cancellationToken);
    private void ApplyTokenOperations(FormattingContext context, NodeOperations nodeOperations, SegmentedList`1<TokenPairWithOperations> tokenOperations, CancellationToken cancellationToken);
    private void ApplyBeginningOfTreeTriviaOperation(FormattingContext context, CancellationToken cancellationToken);
    private void ApplyEndOfTreeTriviaOperation(FormattingContext context, CancellationToken cancellationToken);
    private void ApplyTriviaOperations(FormattingContext context, CancellationToken cancellationToken);
    private TextSpan GetSpanToFormat();
    private static void ApplySpecialOperations(FormattingContext context, NodeOperations nodeOperationsCollector, OperationApplier applier, CancellationToken cancellationToken);
    private static void ApplyAnchorOperations(FormattingContext context, SegmentedList`1<TokenPairWithOperations> tokenOperations, OperationApplier applier, CancellationToken cancellationToken);
    private static bool AnchorOperationCandidate(TokenPairWithOperations pair);
    private static SyntaxToken FindCorrectBaseTokenOfRelativeIndentBlockOperation(IndentBlockOperation operation, TokenStream tokenStream);
    private static void ApplySpaceAndWrappingOperations(FormattingContext context, SegmentedList`1<TokenPairWithOperations> tokenOperations, OperationApplier applier, CancellationToken cancellationToken);
    private static void ApplySpaceAndWrappingOperationsBody(FormattingContext context, TokenPairWithOperations operation, OperationApplier applier, CancellationToken cancellationToken);
    private static void BuildContext(FormattingContext context, NodeOperations nodeOperations, CancellationToken cancellationToken);
    private string FormatSummary();
    [CompilerGeneratedAttribute]
internal static void <ApplyBeginningOfTreeTriviaOperation>g__BeginningOfTreeTriviaInfoApplier|23_0(int i, TokenStream ts, TriviaData info);
    [CompilerGeneratedAttribute]
internal static void <ApplyEndOfTreeTriviaOperation>g__EndOfTreeTriviaInfoApplier|24_0(int i, TokenStream ts, TriviaData info);
    [CompilerGeneratedAttribute]
internal static void <ApplyTriviaOperations>g__RegularApplier|25_0(int tokenPairIndex, TokenStream ts, TriviaData info);
    [CompilerGeneratedAttribute]
internal static void <ApplyTriviaOperations>g__TriviaFormatter|25_1(int tokenPairIndex, FormattingContext ctx, ChainedFormattingRules formattingRules, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult : object {
    protected TreeData TreeInfo;
    protected TokenStream TokenStream;
    private CancellableLazy`1<IList`1<TextChange>> _lazyChanges;
    private CancellableLazy`1<SyntaxNode> _lazyNode;
    public TextSpan FormattedSpan;
    internal AbstractFormattingResult(TreeData treeInfo, TokenStream tokenStream, TextSpan formattedSpan);
    protected abstract virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    public sealed virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public sealed virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChanges(CancellationToken cancellationToken);
    private void AddTextChanges(List`1<TextChange> list, SyntaxToken token1, SyntaxToken token2, TriviaData data);
    private SyntaxNode CreateFormattedRoot(CancellationToken cancellationToken);
    internal IEnumerable`1<ValueTuple`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData>> GetChanges(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractSyntaxFormatting : object {
    private static Func`2<TextSpan, bool> s_notEmpty;
    public SyntaxFormattingOptions DefaultOptions { get; }
    private static AbstractSyntaxFormatting();
    public abstract virtual SyntaxFormattingOptions get_DefaultOptions();
    public abstract virtual SyntaxFormattingOptions GetFormattingOptions(IOptionsReader options, SyntaxFormattingOptions fallbackOptions);
    public abstract virtual ImmutableArray`1<AbstractFormattingRule> GetDefaultFormattingRules();
    protected abstract virtual IFormattingResult CreateAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, TextSpanMutableIntervalTree formattingSpans);
    protected abstract virtual AbstractFormattingResult Format(SyntaxNode node, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    public sealed virtual IFormattingResult GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractTriviaDataFactory : object {
    private static int SpaceCacheSize;
    private static int LineBreakCacheSize;
    private static int IndentationLevelCacheSize;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<LineFormattingOptions, ValueTuple`2<Whitespace[], Whitespace[0...,0...]>> s_optionsToWhitespace;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Tuple`2<LineFormattingOptions, ValueTuple`2<Whitespace[], Whitespace[0...,0...]>> s_lastOptionAndWhitespace;
    protected TreeData TreeInfo;
    protected LineFormattingOptions Options;
    private Whitespace[] _spaces;
    private Whitespace[0...,0...] _whitespaces;
    protected AbstractTriviaDataFactory(TreeData treeInfo, LineFormattingOptions options);
    private static AbstractTriviaDataFactory();
    private static ValueTuple`2<Whitespace[], Whitespace[0...,0...]> GetSpacesAndWhitespaces(LineFormattingOptions options);
    protected TriviaData GetSpaceTriviaData(int space, bool elastic);
    protected TriviaData GetWhitespaceTriviaData(int lineBreaks, int indentation, bool useTriviaAsItIs, bool elastic);
    public abstract virtual TriviaData CreateLeadingTrivia(SyntaxToken token);
    public abstract virtual TriviaData CreateTrailingTrivia(SyntaxToken token);
    public abstract virtual TriviaData Create(SyntaxToken token1, SyntaxToken token2);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<Whitespace[], Whitespace[0...,0...]> <GetSpacesAndWhitespaces>g__ComputeAndCacheSpacesAndWhitespaces|11_0(LineFormattingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter : object {
    private static String[] s_spaceCache;
    protected FormattingContext Context;
    protected ChainedFormattingRules FormattingRules;
    protected string OriginalString;
    protected int LineBreaks;
    protected int Spaces;
    protected LineColumn InitialLineColumn;
    protected SyntaxToken Token1;
    protected SyntaxToken Token2;
    private int _indentation;
    private bool _firstLineBlank;
    protected int StartPosition { get; }
    protected int EndPosition { get; }
    protected TreeData TreeInfo { get; }
    protected SyntaxFormattingOptions Options { get; }
    protected TokenStream TokenStream { get; }
    private static AbstractTriviaFormatter();
    public AbstractTriviaFormatter(FormattingContext context, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, string originalString, int lineBreaks, int spaces);
    protected abstract virtual bool Succeeded();
    protected abstract virtual bool IsWhitespace(SyntaxTrivia trivia);
    protected abstract virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected abstract virtual bool LineContinuationFollowedByWhitespaceComment(SyntaxTrivia previousTrivia, SyntaxTrivia nextTrivia);
    protected abstract virtual bool IsVisualBasicComment(SyntaxTrivia trivia);
    [NullableContextAttribute("2")]
protected bool IsNullOrWhitespace(string text);
    protected abstract virtual bool IsWhitespace(char ch);
    protected abstract virtual bool IsNewLine(char ch);
    protected abstract virtual SyntaxTrivia CreateWhitespace(string text);
    protected abstract virtual SyntaxTrivia CreateEndOfLine();
    protected abstract virtual LineColumnRule GetLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2, CancellationToken cancellationToken);
    protected abstract virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    protected abstract virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    protected abstract virtual bool ContainsImplicitLineBreak(SyntaxTrivia trivia);
    protected int get_StartPosition();
    protected int get_EndPosition();
    protected TreeData get_TreeInfo();
    protected SyntaxFormattingOptions get_Options();
    protected TokenStream get_TokenStream();
    public SyntaxTriviaList FormatToSyntaxTrivia(CancellationToken cancellationToken);
    private static void AddRange(ArrayBuilder`1<SyntaxTrivia> result, SyntaxTriviaList triviaList);
    [NullableContextAttribute("0")]
public ImmutableArray`1<TextChange> FormatToTextChanges(CancellationToken cancellationToken);
    private LineColumn FormatTrivia(Formatter`1<T> formatter, WhitespaceAppender`1<T> whitespaceAdder, ArrayBuilder`1<T> changes, CancellationToken cancellationToken);
    private LineColumn FormatFirstTriviaAndWhitespaceAfter(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, Formatter`1<T> format, WhitespaceAppender`1<T> addWhitespaceTrivia, ArrayBuilder`1<T> changes, bool implicitLineBreak, CancellationToken cancellationToken);
    private LineColumnRule GetOverallLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2, CancellationToken cancellationToken);
    private void GetTokensAtEdgeOfStructureTrivia(SyntaxTrivia trivia1, SyntaxTrivia trivia2, SyntaxToken& token1, SyntaxToken& token2);
    private bool ContainsOnlyWhitespace(int start, int end);
    private bool FirstLineBlank();
    private LineColumnDelta Apply(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, LineColumnRule rule);
    private int GetRuleSpacesOrIndentation(LineColumn lineColumnBeforeTrivia1, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, LineColumnRule rule);
    private static int GetRuleLines(LineColumnRule rule, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween);
    private int GetIndentation();
    private static int GetTrailingLinesAtEndOfTrivia1(LineColumn lineColumnAfterTrivia1);
    private void AddExtraLines(int linesBetweenTokens, ArrayBuilder`1<SyntaxTrivia> changes);
    private int GetInsertionIndex(ArrayBuilder`1<SyntaxTrivia> changes);
    private void AddExtraLines(int linesBetweenTokens, ArrayBuilder`1<TextChange> changes);
    private bool TryGetMatchingChangeIndex(ArrayBuilder`1<TextChange> changes, Int32& index);
    private TextSpan GetInsertionSpan(ArrayBuilder`1<TextChange> changes);
    private void AddWhitespaceTrivia(LineColumn lineColumn, LineColumnDelta delta, ArrayBuilder`1<SyntaxTrivia> changes);
    private void AddWhitespaceTrivia(LineColumn lineColumn, LineColumnDelta delta, TextSpan notUsed, ArrayBuilder`1<SyntaxTrivia> changes);
    private string GetWhitespaceString(LineColumn lineColumn, LineColumnDelta delta);
    private TextChange GetWhitespaceTextChange(LineColumn lineColumn, LineColumnDelta delta, TextSpan span);
    private void AddWhitespaceTextChange(LineColumn lineColumn, LineColumnDelta delta, TextSpan span, ArrayBuilder`1<TextChange> changes);
    private TextSpan GetTextSpan(SyntaxTrivia trivia1, SyntaxTrivia trivia2);
    private bool IsWhitespaceOrEndOfLine(SyntaxTrivia trivia);
    private LineColumnDelta GetLineColumnOfWhitespace(LineColumn lineColumn, SyntaxTrivia previousTrivia, SyntaxTrivia trivia1, LineColumnDelta whitespaceBetween, SyntaxTrivia trivia2);
    private LineColumn GetInitialLineColumn();
    protected LineColumn GetLineColumn(LineColumn lineColumn, SyntaxTrivia trivia);
    protected LineColumnDelta GetLineColumnDelta(LineColumn lineColumn, SyntaxTrivia trivia);
    protected LineColumnDelta GetLineColumnDelta(int initialColumn, string text);
    protected int GetExistingIndentation(SyntaxTrivia trivia);
    private static string GetSpaces(int space);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Formatting.AutoFormattingOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <FormatOnReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatOnTyping>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatOnSemicolon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatOnCloseBrace>k__BackingField;
    public static AutoFormattingOptions Default;
    [DataMemberAttribute]
public bool FormatOnReturn { get; public set; }
    [DataMemberAttribute]
public bool FormatOnTyping { get; public set; }
    [DataMemberAttribute]
public bool FormatOnSemicolon { get; public set; }
    [DataMemberAttribute]
public bool FormatOnCloseBrace { get; public set; }
    private static AutoFormattingOptions();
    [CompilerGeneratedAttribute]
public bool get_FormatOnReturn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatOnReturn(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatOnTyping();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatOnTyping(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatOnSemicolon();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatOnSemicolon(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatOnCloseBrace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatOnCloseBrace(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AutoFormattingOptions left, AutoFormattingOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AutoFormattingOptions left, AutoFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AutoFormattingOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder : object {
    [NullableAttribute("2")]
private TokenStream _tokenStream;
    private ChainedFormattingRules _formattingRules;
    private int _tabSize;
    private int _indentationSize;
    private IHeaderFacts _headerFacts;
    public BottomUpBaseIndentationFinder(ChainedFormattingRules formattingRules, int tabSize, int indentationSize, TokenStream tokenStream, IHeaderFacts headerFacts);
    public Nullable`1<int> FromIndentBlockOperations(SyntaxTree tree, SyntaxToken token, int position, CancellationToken cancellationToken);
    public Nullable`1<int> FromAlignTokensOperations(SyntaxTree tree, SyntaxToken token);
    public int GetIndentationOfCurrentPosition(SyntaxTree tree, SyntaxToken token, int position, CancellationToken cancellationToken);
    public int GetIndentationOfCurrentPosition(SyntaxTree tree, SyntaxToken token, int position, int extraSpaces, CancellationToken cancellationToken);
    public int GetIndentationOfCurrentPosition(SyntaxNode root, IndentBlockOperation startingOperation, Func`2<SyntaxToken, int> tokenColumnGetter, CancellationToken cancellationToken);
    private int GetIndentationOfCurrentPosition(SyntaxNode root, List`1<IndentBlockOperation> list, int position, int extraSpaces, Func`2<SyntaxToken, int> tokenColumnGetter, CancellationToken cancellationToken);
    private ValueTuple`2<int, IndentBlockOperation> GetIndentationRuleOfCurrentPosition(SyntaxNode root, List`1<IndentBlockOperation> list, int position);
    private List`1<IndentBlockOperation> GetParentIndentBlockOperations(SyntaxToken token);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder/<GetParentNodes>d__14")]
private static IEnumerable`1<SyntaxNode> GetParentNodes(SyntaxToken token);
    private SyntaxToken GetAlignmentBaseTokenFor(SyntaxToken token);
    private IndentBlockOperation GetIndentationDataFor(SyntaxNode root, SyntaxToken token, int position);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder/<GetIndentBlockOperationsFromSmallestSpan>d__17")]
private static IEnumerable`1<IndentBlockOperation> GetIndentBlockOperationsFromSmallestSpan(SyntaxNode root, List`1<IndentBlockOperation> list, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.ChainedFormattingRules : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`2<Type, string>, Type> s_typeImplementingMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private SyntaxFormattingOptions _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _addSuppressOperationsRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _addAnchorIndentationOperationsRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _addIndentBlockOperationsRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _addAlignTokensOperationsRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _getAdjustNewLinesOperationRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _getAdjustSpacesOperationRules;
    public ChainedFormattingRules(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxFormattingOptions options);
    private static ChainedFormattingRules();
    public void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode currentNode);
    public void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode currentNode);
    public void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode currentNode);
    public void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode currentNode);
    [NullableContextAttribute("2")]
public AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
public AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
    private static ImmutableArray`1<AbstractFormattingRule> FilterToRulesImplementingMethod(ImmutableArray`1<AbstractFormattingRule> rules, string name);
    private static Type GetTypeImplementingMethod(object obj, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Formatting.ContextMutableIntervalTree`2 : SimpleMutableIntervalTree`2<T, TIntrospector> {
    private Func`4<T, int, int, bool> _edgeExclusivePredicate;
    private Func`4<T, int, int, bool> _edgeInclusivePredicate;
    private Func`4<T, int, int, bool> _containPredicate;
    [NullableContextAttribute("0")]
public ContextMutableIntervalTree`2(TIntrospector& introspector);
    [NullableContextAttribute("2")]
public T GetSmallestEdgeExclusivelyContainingInterval(int start, int length);
    [NullableContextAttribute("2")]
public T GetSmallestEdgeInclusivelyContainingInterval(int start, int length);
    [NullableContextAttribute("2")]
public T GetSmallestContainingInterval(int start, int length);
    private bool ContainsEdgeExclusive(T value, int start, int length);
    private bool ContainsEdgeInclusive(T value, int start, int length);
    private T GetSmallestContainingIntervalWorker(int start, int length, Func`4<T, int, int, bool> predicate);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3_0(T value, int start, int end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptions : object {
    public static DocumentFormattingOptions Default;
    [CompilerGeneratedAttribute]
private string <FileHeaderTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsertFinalNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [DataMemberAttribute]
public string FileHeaderTemplate { get; public set; }
    [DataMemberAttribute]
public bool InsertFinalNewLine { get; public set; }
    [CompilerGeneratedAttribute]
private DocumentFormattingOptions(DocumentFormattingOptions original);
    private static DocumentFormattingOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_FileHeaderTemplate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileHeaderTemplate(string value);
    [CompilerGeneratedAttribute]
public bool get_InsertFinalNewLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InsertFinalNewLine(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentFormattingOptions left, DocumentFormattingOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DocumentFormattingOptions left, DocumentFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocumentFormattingOptions other);
    [CompilerGeneratedAttribute]
public DocumentFormattingOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptionsProvider {
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptionsProviders : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static DocumentFormattingOptions GetDocumentFormattingOptions(IOptionsReader options, DocumentFormattingOptions fallbackOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.FormatterHelper : object {
    internal static IEnumerable`1<AbstractFormattingRule> GetDefaultFormattingRules(ISyntaxFormatting syntaxFormattingService);
    public static SyntaxNode Format(SyntaxNode node, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, TextSpan spanToFormat, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static IFormattingResult GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.FormattingContext : object {
    private AbstractFormatEngine _engine;
    private TokenStream _tokenStream;
    private ContextMutableIntervalTree`2<RelativeIndentationData, FormattingContextIntervalIntrospector> _relativeIndentationTree;
    private ContextMutableIntervalTree`2<IndentationData, FormattingContextIntervalIntrospector> _indentationTree;
    private ContextMutableIntervalTree`2<SuppressWrappingData, SuppressIntervalIntrospector> _suppressWrappingTree;
    private ContextMutableIntervalTree`2<SuppressSpacingData, SuppressIntervalIntrospector> _suppressSpacingTree;
    private ContextMutableIntervalTree`2<SuppressSpacingData, SuppressIntervalIntrospector> _suppressFormattingTree;
    private ContextMutableIntervalTree`2<AnchorData, FormattingContextIntervalIntrospector> _anchorTree;
    private SegmentedDictionary`2<SyntaxToken, AnchorData> _anchorBaseTokenMap;
    private HashSet`1<TextSpan> _indentationMap;
    private HashSet`1<TextSpan> _suppressWrappingMap;
    private HashSet`1<TextSpan> _suppressSpacingMap;
    private HashSet`1<TextSpan> _suppressFormattingMap;
    private HashSet`1<TextSpan> _anchorMap;
    private List`1<IndentBlockOperation> _initialIndentBlockOperations;
    public SyntaxFormattingOptions Options { get; }
    public TreeData TreeData { get; }
    public TokenStream TokenStream { get; }
    public FormattingContext(AbstractFormatEngine engine, TokenStream tokenStream);
    public void Initialize(ChainedFormattingRules formattingRules, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    public void AddIndentBlockOperations(SegmentedList`1<IndentBlockOperation> operations, CancellationToken cancellationToken);
    public void AddIndentBlockOperation(IndentBlockOperation operation);
    public void AddInitialSuppressOperation(SuppressOperation operation);
    public void AddSuppressOperations(SegmentedList`1<SuppressOperation> operations, CancellationToken cancellationToken);
    private void AddSuppressOperation(SuppressOperation operation, bool onSameLine);
    private void AddSpacingSuppressOperation(SuppressOperation operation, bool twoTokensOnSameLine);
    private void AddFormattingSuppressOperation(SuppressOperation operation);
    private void AddWrappingSuppressOperation(SuppressOperation operation, bool twoTokensOnSameLine);
    public void AddAnchorIndentationOperation(AnchorIndentationOperation operation);
    [NullableContextAttribute("0")]
[ConditionalAttribute("DEBUG")]
private static void DebugCheckEmpty(ContextMutableIntervalTree`2<T, TIntrospector> tree, TextSpan textSpan);
    public int GetBaseIndentation(SyntaxToken token);
    public int GetBaseIndentation(int position);
    public IEnumerable`1<IndentBlockOperation> GetAllRelativeIndentBlockOperations();
    public bool TryGetEndTokenForRelativeIndentationSpan(SyntaxToken token, int maxChainDepth, SyntaxToken& endToken, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private AnchorData GetAnchorData(SyntaxToken token);
    public int GetAnchorDeltaFromOriginalColumn(SyntaxToken token);
    public SyntaxToken GetAnchorToken(SyntaxToken token);
    public int GetDeltaFromPreviousChangesMap(SyntaxToken token, Dictionary`2<SyntaxToken, int> previousChangesMap);
    public SyntaxToken GetEndTokenForAnchorSpan(TokenData tokenData);
    [NullableContextAttribute("2")]
private AnchorData FindAnchorSpanOnSameLineAfterToken(TokenData tokenData);
    public bool IsWrappingSuppressed(TextSpan textSpan, bool containsElasticTrivia);
    public bool IsSpacingSuppressed(TextSpan textSpan, bool containsElasticTrivia);
    public bool IsSpacingSuppressed(int pairIndex);
    public bool IsFormattingDisabled(TextSpan textSpan);
    public bool IsFormattingDisabled(int pairIndex);
    public SyntaxFormattingOptions get_Options();
    public TreeData get_TreeData();
    public TokenStream get_TokenStream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticIds : object {
    public static string FormattingDiagnosticId;
    public static string FormatDocumentControlDiagnosticId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.FormattingExtensions : object {
    private static Char[] s_trimChars;
    private static FormattingExtensions();
    [ExtensionAttribute]
public static SyntaxNode GetParentWithBiggerSpan(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<AbstractFormattingRule> Concat(AbstractFormattingRule rule, IEnumerable`1<AbstractFormattingRule> rules);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static List`1<T> Combine(List`1<T> list1, List`1<T> list2);
    [ExtensionAttribute]
public static bool ContainsElasticTrivia(SuppressOperation operation, TokenStream tokenStream);
    [ExtensionAttribute]
public static bool HasAnyWhitespaceElasticTrivia(SyntaxTriviaList list);
    [ExtensionAttribute]
public static bool IsOn(IndentBlockOption option, IndentBlockOption flag);
    [ExtensionAttribute]
public static bool IsMaskOn(IndentBlockOption option, IndentBlockOption mask);
    [ExtensionAttribute]
public static bool IsOn(SuppressOption option, SuppressOption flag);
    [ExtensionAttribute]
public static bool IsMaskOn(SuppressOption option, SuppressOption mask);
    [ExtensionAttribute]
public static SuppressOption RemoveFlag(SuppressOption option, SuppressOption flag);
    [ExtensionAttribute]
public static string CreateIndentationString(int desiredIndentation, bool useTab, int tabSize);
    [ExtensionAttribute]
public static StringBuilder AppendIndentationString(StringBuilder sb, int desiredIndentation, bool useTab, int tabSize);
    [ExtensionAttribute]
public static void ProcessTextBetweenTokens(string text, TreeData treeInfo, SyntaxToken baseToken, int tabSize, Int32& lineBreaks, Int32& spaceOrIndentation);
    [ExtensionAttribute]
public static string AdjustIndentForXmlDocExteriorTrivia(string triviaText, bool forceIndentation, int indentation, int indentationDelta, bool useTab, int tabSize);
    [ExtensionAttribute]
public static string ReindentStartOfXmlDocumentationComment(string triviaText, bool forceIndentation, int indentation, int indentationDelta, bool useTab, int tabSize, string newLine);
    [ExtensionAttribute]
private static int GetNewIndentationForComments(string line, int nonWhitespaceCharIndex, bool forceIndentation, int indentation, int indentationDelta, int tabSize);
    [ExtensionAttribute]
public static int GetFirstNonWhitespaceIndexInString(string text);
    [ExtensionAttribute]
public static TextChange SimpleDiff(TextChange textChange, string text);
    internal static IEnumerable`1<TextSpan> GetAnnotatedSpans(SyntaxNode node, SyntaxAnnotation annotation);
    internal static TextSpan GetSpan(SyntaxToken firstToken, SyntaxToken lastToken);
    internal static TextSpan GetElasticSpan(SyntaxToken token);
    private static IEnumerable`1<TextSpan> AggregateSpans(IEnumerable`1<TextSpan> spans);
    [ExtensionAttribute]
internal static int GetAdjustedIndentationDelta(IndentBlockOperation operation, IHeaderFacts headerFacts, SyntaxNode root, SyntaxToken indentationAnchor);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.FormattingExtensions/<<GetAnnotatedSpans>g__EnumerateAnnotatedSpans|19_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TextSpan> <GetAnnotatedSpans>g__EnumerateAnnotatedSpans|19_0(SyntaxNode node, SyntaxAnnotation annotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.FormattingOptionGroups : object {
    public static OptionGroup FormattingOptionGroup;
    public static OptionGroup IndentationAndSpacing;
    public static OptionGroup NewLine;
    private static FormattingOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.FormattingOptions2 : object {
    private static string PublicFeatureName;
    public static PerLanguageOption2`1<bool> UseTabs;
    public static PerLanguageOption2`1<int> TabSize;
    public static PerLanguageOption2`1<int> IndentationSize;
    public static PerLanguageOption2`1<string> NewLine;
    internal static Option2`1<bool> InsertFinalNewLine;
    public static PerLanguageOption2`1<IndentStyle> SmartIndent;
    public static PerLanguageOption2`1<int> WrappingColumn;
    public static PerLanguageOption2`1<int> ConditionalExpressionWrappingLength;
    private static FormattingOptions2();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Formatting.IFormattingResult {
    public abstract virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public abstract virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Formatting.ISyntaxFormatting {
    public SyntaxFormattingOptions DefaultOptions { get; }
    public abstract virtual SyntaxFormattingOptions get_DefaultOptions();
    public abstract virtual SyntaxFormattingOptions GetFormattingOptions(IOptionsReader options, SyntaxFormattingOptions fallbackOptions);
    public abstract virtual ImmutableArray`1<AbstractFormattingRule> GetDefaultFormattingRules();
    public abstract virtual IFormattingResult GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.LineColumn : ValueType {
    public static LineColumn Default;
    public int Line;
    public int Column;
    public bool WhitespaceOnly;
    public LineColumn(int line, int column, bool whitespaceOnly);
    private static LineColumn();
    public LineColumn With(LineColumnDelta delta);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.LineColumnDelta : ValueType {
    public static LineColumnDelta Default;
    public int Lines;
    public int Spaces;
    public bool WhitespaceOnly;
    public bool ForceUpdate;
    public LineColumnDelta(int lines, int spaces);
    public LineColumnDelta(int lines, int spaces, bool whitespaceOnly);
    public LineColumnDelta(int lines, int spaces, bool whitespaceOnly, bool forceUpdate);
    private static LineColumnDelta();
    internal LineColumnDelta With(LineColumnDelta delta);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.LineColumnRule : ValueType {
    public SpaceOperations SpaceOperation;
    public LineOperations LineOperation;
    public IndentationOperations IndentationOperation;
    public int Lines;
    public int Spaces;
    public int Indentation;
    public static LineColumnRule Preserve;
    public static LineColumnRule PreserveLinesWithFollowingPrecedingIndentation;
    public LineColumnRule(SpaceOperations spaceOperation, LineOperations lineOperation, IndentationOperations indentationOperation, int lines, int spaces, int indentation);
    private static LineColumnRule();
    public LineColumnRule With(Nullable`1<int> lines, Nullable`1<int> spaces, Nullable`1<int> indentation, Nullable`1<LineOperations> lineOperation, Nullable`1<SpaceOperations> spaceOperation, Nullable`1<IndentationOperations> indentationOperation);
    public static LineColumnRule PreserveWithGivenSpaces(int spaces);
    public static LineColumnRule PreserveLinesWithDefaultIndentation(int lines);
    public static LineColumnRule PreserveLinesWithGivenIndentation(int lines);
    public static LineColumnRule PreserveLinesWithAbsoluteIndentation(int lines, int indentation);
    public static LineColumnRule ForceSpaces(int spaces);
    public static LineColumnRule PreserveSpacesOrUseDefaultIndentation(int spaces);
    public static LineColumnRule ForceSpacesOrUseDefaultIndentation(int spaces);
    public static LineColumnRule ForceSpacesOrUseFollowIndentation(int indentation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Formatting.LineFormattingOptions : object {
    public static LineFormattingOptions Default;
    [CompilerGeneratedAttribute]
private bool <UseTabs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TabSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentationSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [DataMemberAttribute]
public bool UseTabs { get; public set; }
    [DataMemberAttribute]
public int TabSize { get; public set; }
    [DataMemberAttribute]
public int IndentationSize { get; public set; }
    [DataMemberAttribute]
public string NewLine { get; public set; }
    [CompilerGeneratedAttribute]
private LineFormattingOptions(LineFormattingOptions original);
    private static LineFormattingOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_UseTabs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseTabs(bool value);
    [CompilerGeneratedAttribute]
public int get_TabSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TabSize(int value);
    [CompilerGeneratedAttribute]
public int get_IndentationSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentationSize(int value);
    [CompilerGeneratedAttribute]
public string get_NewLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewLine(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LineFormattingOptions left, LineFormattingOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LineFormattingOptions left, LineFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(LineFormattingOptions other);
    [CompilerGeneratedAttribute]
public LineFormattingOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.Formatting.LineFormattingOptionsProvider {
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.LineFormattingOptionsProviders : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LineFormattingOptions GetLineFormattingOptions(IOptionsReader options, string language, LineFormattingOptions fallbackOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.NodeOperations : object {
    private static ObjectPool`1<SegmentedList`1<IndentBlockOperation>> s_indentBlockOperationPool;
    private static ObjectPool`1<SegmentedList`1<SuppressOperation>> s_suppressOperationPool;
    private static ObjectPool`1<SegmentedList`1<AlignTokensOperation>> s_alignTokensOperationPool;
    private static ObjectPool`1<SegmentedList`1<AnchorIndentationOperation>> s_anchorIndentationOperationPool;
    public static NodeOperations Empty;
    [CompilerGeneratedAttribute]
private SegmentedList`1<IndentBlockOperation> <IndentBlockOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentedList`1<SuppressOperation> <SuppressOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentedList`1<AlignTokensOperation> <AlignmentOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentedList`1<AnchorIndentationOperation> <AnchorIndentationOperations>k__BackingField;
    public SegmentedList`1<IndentBlockOperation> IndentBlockOperation { get; }
    public SegmentedList`1<SuppressOperation> SuppressOperation { get; }
    public SegmentedList`1<AlignTokensOperation> AlignmentOperation { get; }
    public SegmentedList`1<AnchorIndentationOperation> AnchorIndentationOperations { get; }
    private static NodeOperations();
    [CompilerGeneratedAttribute]
public SegmentedList`1<IndentBlockOperation> get_IndentBlockOperation();
    [CompilerGeneratedAttribute]
public SegmentedList`1<SuppressOperation> get_SuppressOperation();
    [CompilerGeneratedAttribute]
public SegmentedList`1<AlignTokensOperation> get_AlignmentOperation();
    [CompilerGeneratedAttribute]
public SegmentedList`1<AnchorIndentationOperation> get_AnchorIndentationOperations();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule : object {
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNewLinesOption <Option>k__BackingField;
    public int Line { get; }
    public AdjustNewLinesOption Option { get; }
    internal AdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public AdjustNewLinesOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption : Enum {
    public int value__;
    public static AdjustNewLinesOption PreserveLines;
    public static AdjustNewLinesOption ForceLines;
    public static AdjustNewLinesOption ForceLinesIfOnSingleLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation : object {
    [CompilerGeneratedAttribute]
private int <Space>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustSpacesOption <Option>k__BackingField;
    public int Space { get; }
    public AdjustSpacesOption Option { get; }
    internal AdjustSpacesOperation(int space, AdjustSpacesOption option);
    [CompilerGeneratedAttribute]
public int get_Space();
    [CompilerGeneratedAttribute]
public AdjustSpacesOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption : Enum {
    public int value__;
    public static AdjustSpacesOption PreserveSpaces;
    public static AdjustSpacesOption DefaultSpacesIfOnSingleLine;
    public static AdjustSpacesOption ForceSpacesIfOnSingleLine;
    public static AdjustSpacesOption ForceSpaces;
    public static AdjustSpacesOption DynamicSpaceToIndentationIfOnSingleLine;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <BaseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxToken> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private AlignTokensOption <Option>k__BackingField;
    public SyntaxToken BaseToken { get; }
    public IEnumerable`1<SyntaxToken> Tokens { get; }
    public AlignTokensOption Option { get; }
    internal AlignTokensOperation(SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    [CompilerGeneratedAttribute]
public SyntaxToken get_BaseToken();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxToken> get_Tokens();
    [CompilerGeneratedAttribute]
public AlignTokensOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption : Enum {
    public int value__;
    public static AlignTokensOption AlignIndentationOfTokensToBaseToken;
    public static AlignTokensOption AlignIndentationOfTokensToFirstTokenOfBaseTokenLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <AnchorToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    public SyntaxToken AnchorToken { get; }
    public TextSpan TextSpan { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    internal AnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken endToken, TextSpan textSpan);
    [CompilerGeneratedAttribute]
public SyntaxToken get_AnchorToken();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.Rules.BaseIndentationFormattingRule : AbstractFormattingRule {
    [NullableAttribute("2")]
private AbstractFormattingRule _vbHelperFormattingRule;
    private int _baseIndentation;
    private SyntaxToken _token1;
    private SyntaxToken _token2;
    [NullableAttribute("2")]
private SyntaxNode _commonNode;
    private TextSpan _span;
    public BaseIndentationFormattingRule(SyntaxNode root, TextSpan span, int baseIndentation, AbstractFormattingRule vbHelperFormattingRule);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private void AddNextIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
    private void AdjustIndentBlockOperation(List`1<IndentBlockOperation> list);
    private bool Myself(IndentBlockOperation operation);
    private IndentBlockOperation CloneAndAdjustFormattingOperation(IndentBlockOperation operation);
    private TextSpan AdjustTextSpan(TextSpan textSpan);
    private static void SetInnermostNodeForSpan(SyntaxNode root, TextSpan& span, SyntaxToken& token1, SyntaxToken& token2, SyntaxNode& commonNode);
    private static void GetTokens(SyntaxNode root, TextSpan span, SyntaxToken& token1, SyntaxToken& token2);
    private static TextSpan GetSpanFromTokens(TextSpan span, SyntaxToken token1, SyntaxToken token2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule : AbstractFormattingRule {
    [ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual void AddSuppressOperations(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddSuppressOperationsSlow(ArrayBuilder`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& nextOperation);
    public virtual void AddAnchorIndentationOperationsSlow(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& nextOperation);
    public virtual void AddIndentBlockOperationsSlow(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
    public virtual void AddAlignTokensOperationsSlow(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustNewLinesOperation& nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustSpacesOperation& nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations : object {
    private static AdjustNewLinesOperation s_preserveZeroLine;
    private static AdjustNewLinesOperation s_preserveOneLine;
    private static AdjustNewLinesOperation s_forceOneLine;
    private static AdjustNewLinesOperation s_forceIfSameLine;
    private static AdjustSpacesOperation s_defaultOneSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceOneSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceZeroSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceZeroLineUsingSpaceForce;
    private static FormattingOperations();
    public static AnchorIndentationOperation CreateAnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken endToken);
    public static AnchorIndentationOperation CreateAnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken endToken, TextSpan textSpan);
    public static SuppressOperation CreateSuppressOperation(SyntaxToken startToken, SyntaxToken endToken, SuppressOption option);
    private static SuppressOperation CreateSuppressOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, SuppressOption option);
    public static IndentBlockOperation CreateIndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateIndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateRelativeIndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateRelativeIndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    public static AlignTokensOperation CreateAlignTokensOperation(SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    public static AdjustNewLinesOperation CreateAdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    public static AdjustSpacesOperation CreateAdjustSpacesOperation(int space, AdjustSpacesOption option);
    internal static IEnumerable`1<AnchorIndentationOperation> GetAnchorIndentationOperations(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxNode node, SyntaxFormattingOptions options);
    internal static IEnumerable`1<IndentBlockOperation> GetIndentBlockOperations(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxNode node, SyntaxFormattingOptions options);
    internal static IEnumerable`1<AlignTokensOperation> GetAlignTokensOperations(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxNode node, SyntaxFormattingOptions options);
    internal static AdjustNewLinesOperation GetAdjustNewLinesOperation(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken previousToken, SyntaxToken currentToken, SyntaxFormattingOptions options);
    internal static AdjustSpacesOperation GetAdjustSpacesOperation(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken previousToken, SyntaxToken currentToken, SyntaxFormattingOptions options);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <BaseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentBlockOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRelativeIndentation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentationDeltaOrPosition>k__BackingField;
    public SyntaxToken BaseToken { get; }
    public TextSpan TextSpan { get; }
    public IndentBlockOption Option { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    public bool IsRelativeIndentation { get; }
    public int IndentationDeltaOrPosition { get; }
    internal IndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    internal IndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    [CompilerGeneratedAttribute]
public SyntaxToken get_BaseToken();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public IndentBlockOption get_Option();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
    [CompilerGeneratedAttribute]
public bool get_IsRelativeIndentation();
    [CompilerGeneratedAttribute]
public int get_IndentationDeltaOrPosition();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption : Enum {
    public int value__;
    public static IndentBlockOption RelativeToFirstTokenOnBaseTokenLine;
    public static IndentBlockOption RelativePosition;
    public static IndentBlockOption AbsolutePosition;
    public static IndentBlockOption RelativePositionMask;
    public static IndentBlockOption PositionMask;
    public static IndentBlockOption IndentIfConditionOfAnchorToken;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AbstractFormattingRule> <formattingRules>P;
    [CompilerGeneratedAttribute]
private int <index>P;
    [CompilerGeneratedAttribute]
private SyntaxNode <node>P;
    [CompilerGeneratedAttribute]
private List`1<AlignTokensOperation> <list>P;
    private NextAlignTokensOperationAction NextAction { get; }
    public NextAlignTokensOperationAction(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index, SyntaxNode node, List`1<AlignTokensOperation> list);
    private NextAlignTokensOperationAction get_NextAction();
    public void Invoke();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AbstractFormattingRule> <formattingRules>P;
    [CompilerGeneratedAttribute]
private int <index>P;
    [CompilerGeneratedAttribute]
private SyntaxNode <node>P;
    [CompilerGeneratedAttribute]
private List`1<AnchorIndentationOperation> <list>P;
    private NextAnchorIndentationOperationAction NextAction { get; }
    public NextAnchorIndentationOperationAction(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index, SyntaxNode node, List`1<AnchorIndentationOperation> list);
    private NextAnchorIndentationOperationAction get_NextAction();
    public void Invoke();
}
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AbstractFormattingRule> <formattingRules>P;
    [CompilerGeneratedAttribute]
private int <index>P;
    private NextGetAdjustNewLinesOperation NextOperation { get; }
    public NextGetAdjustNewLinesOperation(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index);
    private NextGetAdjustNewLinesOperation get_NextOperation();
    [NullableContextAttribute("2")]
public AdjustNewLinesOperation Invoke(SyntaxToken& previousToken, SyntaxToken& currentToken);
}
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AbstractFormattingRule> <formattingRules>P;
    [CompilerGeneratedAttribute]
private int <index>P;
    private NextGetAdjustSpacesOperation NextOperation { get; }
    public NextGetAdjustSpacesOperation(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index);
    private NextGetAdjustSpacesOperation get_NextOperation();
    [NullableContextAttribute("2")]
public AdjustSpacesOperation Invoke(SyntaxToken& previousToken, SyntaxToken& currentToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AbstractFormattingRule> <formattingRules>P;
    [CompilerGeneratedAttribute]
private int <index>P;
    [CompilerGeneratedAttribute]
private SyntaxNode <node>P;
    [CompilerGeneratedAttribute]
private List`1<IndentBlockOperation> <list>P;
    private NextIndentBlockOperationAction NextAction { get; }
    public NextIndentBlockOperationAction(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index, SyntaxNode node, List`1<IndentBlockOperation> list);
    private NextIndentBlockOperationAction get_NextAction();
    public void Invoke();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AbstractFormattingRule> <formattingRules>P;
    [CompilerGeneratedAttribute]
private int <index>P;
    [CompilerGeneratedAttribute]
private SyntaxNode <node>P;
    [CompilerGeneratedAttribute]
private ArrayBuilder`1<SuppressOperation> <list>P;
    private NextSuppressOperationAction NextAction { get; }
    public NextSuppressOperationAction(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index, SyntaxNode node, ArrayBuilder`1<SuppressOperation> list);
    private NextSuppressOperationAction get_NextAction();
    public void Invoke();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.NoOpFormattingRule : AbstractFormattingRule {
    [NullableAttribute("1")]
public static NoOpFormattingRule Instance;
    private static NoOpFormattingRule();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation : ValueType {
    public TextSpan TextSpan;
    public SuppressOption Option;
    public SyntaxToken StartToken;
    public SyntaxToken EndToken;
    internal SuppressOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, SuppressOption option);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption : Enum {
    public int value__;
    public static SuppressOption None;
    public static SuppressOption NoWrappingIfOnSingleLine;
    public static SuppressOption NoWrappingIfOnMultipleLine;
    public static SuppressOption NoWrapping;
    public static SuppressOption NoSpacingIfOnSingleLine;
    public static SuppressOption NoSpacingIfOnMultipleLine;
    public static SuppressOption NoSpacing;
    public static SuppressOption IgnoreElasticWrapping;
    public static SuppressOption DisableFormatting;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.StringBuilderPool : object {
    public static StringBuilder Allocate();
    public static void Free(StringBuilder builder);
    public static string ReturnAndFree(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.SuppressIntervalIntrospector : ValueType {
    private sealed virtual override TextSpan Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressSpacingData>.GetSpan(SuppressSpacingData value);
    private sealed virtual override TextSpan Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressWrappingData>.GetSpan(SuppressWrappingData value);
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressSpacingData : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    public TextSpan TextSpan { get; }
    public SuppressSpacingData(TextSpan textSpan);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressWrappingData : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreElastic>k__BackingField;
    public TextSpan TextSpan { get; }
    public bool IgnoreElastic { get; }
    public SuppressWrappingData(TextSpan textSpan, bool ignoreElastic);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public bool get_IgnoreElastic();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions : object {
    internal static SyntaxFormattingOptions CommonDefaults;
    [CompilerGeneratedAttribute]
private LineFormattingOptions <LineFormatting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SeparateImportDirectiveGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessibilityModifiersRequired <AccessibilityModifiersRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WrappingColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConditionalExpressionWrappingLength>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public LineFormattingOptions LineFormatting { get; public set; }
    [DataMemberAttribute]
public bool SeparateImportDirectiveGroups { get; public set; }
    [DataMemberAttribute]
public AccessibilityModifiersRequired AccessibilityModifiersRequired { get; public set; }
    [DataMemberAttribute]
public int WrappingColumn { get; public set; }
    [DataMemberAttribute]
public int ConditionalExpressionWrappingLength { get; public set; }
    public bool UseTabs { get; }
    public int TabSize { get; }
    public int IndentationSize { get; }
    public string NewLine { get; }
    private protected SyntaxFormattingOptions(IOptionsReader options, SyntaxFormattingOptions fallbackOptions, string language);
    [CompilerGeneratedAttribute]
protected SyntaxFormattingOptions(SyntaxFormattingOptions original);
    private static SyntaxFormattingOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public LineFormattingOptions get_LineFormatting();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineFormatting(LineFormattingOptions value);
    [CompilerGeneratedAttribute]
public bool get_SeparateImportDirectiveGroups();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SeparateImportDirectiveGroups(bool value);
    [CompilerGeneratedAttribute]
public AccessibilityModifiersRequired get_AccessibilityModifiersRequired();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AccessibilityModifiersRequired(AccessibilityModifiersRequired value);
    [CompilerGeneratedAttribute]
public int get_WrappingColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WrappingColumn(int value);
    [CompilerGeneratedAttribute]
public int get_ConditionalExpressionWrappingLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ConditionalExpressionWrappingLength(int value);
    public bool get_UseTabs();
    public int get_TabSize();
    public int get_IndentationSize();
    public string get_NewLine();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SyntaxFormattingOptions left, SyntaxFormattingOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SyntaxFormattingOptions left, SyntaxFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SyntaxFormattingOptions other);
    [CompilerGeneratedAttribute]
public virtual SyntaxFormattingOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptionsProvider {
}
internal static class Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptionsProviders : object {
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.TokenData : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TokenStream <TokenStream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInStream>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    [NullableAttribute("1")]
public TokenStream TokenStream { get; }
    public int IndexInStream { get; }
    public SyntaxToken Token { get; }
    [NullableContextAttribute("1")]
public TokenData(TokenStream tokenStream, int indexInStream, SyntaxToken token);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TokenStream get_TokenStream();
    [CompilerGeneratedAttribute]
public int get_IndexInStream();
    [CompilerGeneratedAttribute]
public SyntaxToken get_Token();
    public TokenData GetPreviousTokenData();
    public TokenData GetNextTokenData();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(TokenData other);
    public sealed virtual int CompareTo(TokenData other);
    public static bool op_LessThan(TokenData left, TokenData right);
    public static bool op_GreaterThan(TokenData left, TokenData right);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TokenData left, TokenData right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TokenData left, TokenData right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static SyntaxNodeOrToken <CompareTo>g__GetAncestorUnderRoot|14_0(SyntaxNodeOrToken start, SyntaxNode root);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.TokenPairWithOperations : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TokenStream <TokenStream>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustSpacesOperation <SpaceOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNewLinesOperation <LineOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PairIndex>k__BackingField;
    [NullableAttribute("1")]
public TokenStream TokenStream { get; }
    public AdjustSpacesOperation SpaceOperation { get; }
    public AdjustNewLinesOperation LineOperation { get; }
    public int PairIndex { get; }
    public SyntaxToken Token1 { get; }
    public SyntaxToken Token2 { get; }
    public TokenPairWithOperations(TokenStream tokenStream, int tokenPairIndex, AdjustSpacesOperation spaceOperations, AdjustNewLinesOperation lineOperations);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TokenStream get_TokenStream();
    [CompilerGeneratedAttribute]
public AdjustSpacesOperation get_SpaceOperation();
    [CompilerGeneratedAttribute]
public AdjustNewLinesOperation get_LineOperation();
    [CompilerGeneratedAttribute]
public int get_PairIndex();
    public SyntaxToken get_Token1();
    public SyntaxToken get_Token2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.TokenStream : object {
    private static int MagicTextLengthToTokensRatio;
    private SegmentedList`1<SyntaxToken> _tokens;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SegmentedArray`1<TriviaData> _cachedOriginalTriviaInfo;
    private TreeData _treeData;
    private SyntaxFormattingOptions _options;
    private Changes _changes;
    private AbstractTriviaDataFactory _factory;
    private Func`3<TokenData, TokenData, TriviaData> _getTriviaData;
    private Func`3<TokenData, TokenData, TriviaData> _getOriginalTriviaData;
    public bool FormatBeginningOfTree { get; }
    public bool FormatEndOfTree { get; }
    public bool IsFormattingWholeDocument { get; }
    public TokenData FirstTokenInStream { get; }
    public TokenData LastTokenInStream { get; }
    public int TokenCount { get; }
    public Iterator TokenIterator { get; }
    public TokenStream(TreeData treeData, SyntaxFormattingOptions options, TextSpan spanToFormat, AbstractTriviaDataFactory factory);
    [ConditionalAttribute("DEBUG")]
private void DebugCheckTokenOrder();
    public bool get_FormatBeginningOfTree();
    public bool get_FormatEndOfTree();
    public bool get_IsFormattingWholeDocument();
    public TokenData get_FirstTokenInStream();
    public TokenData get_LastTokenInStream();
    public int get_TokenCount();
    public SyntaxToken GetToken(int index);
    public TokenData GetTokenData(SyntaxToken token);
    public TokenData GetPreviousTokenData(TokenData tokenData);
    public TokenData GetNextTokenData(TokenData tokenData);
    internal SyntaxToken FirstTokenOfBaseTokenLine(SyntaxToken token);
    public bool TwoTokensOriginallyOnSameLine(SyntaxToken token1, SyntaxToken token2);
    public bool TwoTokensOnSameLine(SyntaxToken token1, SyntaxToken token2);
    private bool TwoTokensOnSameLineWorker(SyntaxToken token1, SyntaxToken token2, Func`3<TokenData, TokenData, TriviaData> triviaDataGetter);
    public void ApplyBeginningOfTreeChange(TriviaData data);
    public void ApplyEndOfTreeChange(TriviaData data);
    public void ApplyChange(int pairIndex, TriviaData data);
    public int GetCurrentColumn(SyntaxToken token);
    public int GetCurrentColumn(TokenData tokenData);
    public int GetOriginalColumn(SyntaxToken token);
    private int GetColumn(TokenData tokenData, Func`3<TokenData, TokenData, TriviaData> triviaDataGetter);
    public void GetTokenLength(SyntaxToken token, Int32& length, Boolean& onMultipleLines);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.TokenStream/<GetTriviaDataWithTokenPair>d__40")]
public IEnumerable`1<ValueTuple`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData>> GetTriviaDataWithTokenPair(CancellationToken cancellationToken);
    public TriviaData GetTriviaData(TokenData token1, TokenData token2);
    private TriviaData GetOriginalTriviaData(TokenData token1, TokenData token2);
    public TriviaData GetTriviaDataAtBeginningOfTree();
    public TriviaData GetTriviaDataAtEndOfTree();
    public TriviaData GetTriviaData(int pairIndex);
    private TriviaData GetOriginalTriviaData(int pairIndex);
    public bool IsFirstTokenOnLine(SyntaxToken token);
    private bool IsFirstTokenOnLine(TokenData tokenData1, TokenData tokenData2);
    private int GetTokenIndexInStream(SyntaxToken token);
    public Iterator get_TokenIterator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.TreeData : object {
    private SyntaxNode _root;
    private SyntaxToken _firstToken;
    private SyntaxToken _lastToken;
    public SyntaxNode Root { get; }
    public int StartPosition { get; }
    public int EndPosition { get; }
    public TreeData(SyntaxNode root);
    public static TreeData Create(SyntaxNode root);
    public static TreeData Create(SyntaxTrivia trivia, int initialColumn);
    public abstract virtual string GetTextBetween(SyntaxToken token1, SyntaxToken token2);
    public abstract virtual int GetOriginalColumn(int tabSize, SyntaxToken token);
    public SyntaxNode get_Root();
    public bool IsFirstToken(SyntaxToken token);
    public bool IsLastToken(SyntaxToken token);
    public int get_StartPosition();
    public int get_EndPosition();
    public IEnumerable`1<SyntaxToken> GetApplicableTokens(TextSpan textSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.TriviaData : object {
    protected static int TokenPairIndexNotNeeded;
    [CompilerGeneratedAttribute]
private LineFormattingOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineBreaks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spaces>k__BackingField;
    protected LineFormattingOptions Options { get; }
    public int LineBreaks { get; protected set; }
    public int Spaces { get; protected set; }
    public bool SecondTokenIsFirstTokenOnLine { get; }
    public bool TreatAsElastic { get; }
    public bool IsWhitespaceOnlyTrivia { get; }
    public bool ContainsChanges { get; }
    protected TriviaData(LineFormattingOptions options);
    [CompilerGeneratedAttribute]
protected LineFormattingOptions get_Options();
    [CompilerGeneratedAttribute]
public int get_LineBreaks();
    [CompilerGeneratedAttribute]
protected void set_LineBreaks(int value);
    [CompilerGeneratedAttribute]
public int get_Spaces();
    [CompilerGeneratedAttribute]
protected void set_Spaces(int value);
    public bool get_SecondTokenIsFirstTokenOnLine();
    public abstract virtual bool get_TreatAsElastic();
    public abstract virtual bool get_IsWhitespaceOnlyTrivia();
    public abstract virtual bool get_ContainsChanges();
    public abstract virtual IEnumerable`1<TextChange> GetTextChanges(TextSpan span);
    public abstract virtual TriviaData WithSpace(int space, FormattingContext context, ChainedFormattingRules formattingRules);
    public abstract virtual TriviaData WithLine(int line, int indentation, FormattingContext context, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    public abstract virtual TriviaData WithIndentation(int indentation, FormattingContext context, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    public abstract virtual void Format(FormattingContext context, ChainedFormattingRules formattingRules, Action`3<int, TokenStream, TriviaData> formattingResultApplier, CancellationToken cancellationToken, int tokenPairIndex);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TriviaDataWithList : TriviaData {
    [NullableContextAttribute("1")]
protected TriviaDataWithList(LineFormattingOptions options);
    public abstract virtual SyntaxTriviaList GetTriviaList(CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Formatting.TriviaHelpers : object {
    public static SyntaxTriviaList CreateTriviaListFromTo(SyntaxTriviaList triviaList, int startIndex, int endIndex);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Formatting.TriviaList : ValueType {
    private SyntaxTriviaList _list1;
    private SyntaxTriviaList _list2;
    public int Count { get; }
    public SyntaxTrivia Item { get; }
    public TriviaList(SyntaxTriviaList list1, SyntaxTriviaList list2);
    public int get_Count();
    public SyntaxTrivia get_Item(int index);
    public Enumerator GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ImmutableArrayExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(IEnumerable`1<T> items);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(T[] items);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<byte> ToImmutable(MemoryStream stream);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, bool> predicate, Func`2<TItem, TResult> selector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> array, Func`3<TItem, TArg, bool> predicate, Func`3<TItem, TArg, TResult> selector, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, ImmutableArray`1<TResult>> selector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, bool> predicate, Func`2<TItem, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, bool> predicate, Func`2<TItem, ImmutableArray`1<TResult>> selector);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<SelectAsArrayAsync>d__16`2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(ImmutableArray`1<TItem> array, Func`3<TItem, CancellationToken, ValueTask`1<TResult>> selector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<SelectAsArrayAsync>d__17`3")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(ImmutableArray`1<TItem> array, Func`4<TItem, TArg, CancellationToken, ValueTask`1<TResult>> selector, TArg arg, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectManyAsArrayAsync(ImmutableArray`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<ImmutableArray`1<TResult>>> selector, TArg arg, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> ZipAsArray(ImmutableArray`1<T1> self, ImmutableArray`1<T2> other, Func`3<T1, T2, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> ZipAsArray(ImmutableArray`1<T1> self, ImmutableArray`1<T2> other, TArg arg, Func`5<T1, T2, int, TArg, TResult> map);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`2<T, bool> predicate);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    private static ImmutableArray`1<T> WhereAsArrayImpl(ImmutableArray`1<T> array, Func`2<T, bool> predicateWithoutArg, Func`3<T, TArg, bool> predicateWithArg, TArg arg);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool All(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<AnyAsync>d__26`1")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(ImmutableArray`1<T> array, Func`2<T, Task`1<bool>> predicateAsync);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<AnyAsync>d__27`2")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(ImmutableArray`1<T> array, Func`3<T, TArg, Task`1<bool>> predicateAsync, TArg arg);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<FirstOrDefaultAsync>d__28`1")]
[ExtensionAttribute]
public static ValueTask`1<T> FirstOrDefaultAsync(ImmutableArray`1<T> array, Func`2<T, Task`1<bool>> predicateAsync);
    [ExtensionAttribute]
public static TValue FirstOrDefault(ImmutableArray`1<TValue> array, Func`3<TValue, TArg, bool> predicate, TArg arg);
    [ExtensionAttribute]
public static TValue Single(ImmutableArray`1<TValue> array, Func`3<TValue, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TBase> Cast(ImmutableArray`1<TDerived> items);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool SetEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(ImmutableArray`1<T> array);
    [ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(Nullable`1<ImmutableArray`1<T>> array);
    [ExtensionAttribute]
public static ImmutableArray`1<T> Distinct(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ConditionallyDeOrder(ImmutableArray`1<T> array);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ImmutableArray`1<TValue> Flatten(Dictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, IComparer`1<TValue> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third, ImmutableArray`1<T> fourth);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third, ImmutableArray`1<T> fourth, ImmutableArray`1<T> fifth);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third, ImmutableArray`1<T> fourth, ImmutableArray`1<T> fifth, ImmutableArray`1<T> sixth);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, T second);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> AddRange(ImmutableArray`1<T> self, TemporaryArray`1& items);
    [ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int Count(ImmutableArray`1<T> items, Func`2<T, bool> predicate);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int Sum(ImmutableArray`1<T> items, Func`2<T, int> selector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int Sum(ImmutableArray`1<T> items, Func`3<T, int, int> selector);
    [NullableContextAttribute("1")]
internal static void AddToMultiValueDictionaryBuilder(Dictionary`2<K, object> accumulator, K key, T item);
    [NullableContextAttribute("1")]
internal static void CreateNameToMembersMap(Dictionary`2<TKey, object> dictionary, Dictionary`2<TKey, ImmutableArray`1<TNamespaceOrTypeSymbol>> result);
    [NullableContextAttribute("1")]
internal static Dictionary`2<TKey, ImmutableArray`1<TNamedTypeSymbol>> GetTypesFromMemberMap(Dictionary`2<TKey, ImmutableArray`1<TNamespaceOrTypeSymbol>> map, IEqualityComparer`1<TKey> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool SequenceEqual(ImmutableArray`1<TElement> array1, ImmutableArray`1<TElement> array2, TArg arg, Func`4<TElement, TElement, TArg, bool> predicate);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int IndexOf(ImmutableArray`1<T> array, T item, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool IsSorted(ImmutableArray`1<T> array, IComparer`1<T> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int BinarySearch(ImmutableArray`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int BinarySearch(ReadOnlySpan`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int BinarySearch(ImmutableSegmentedList`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [ExtensionAttribute]
public static bool IsSubsetOf(ImmutableArray`1<TElement> array, ImmutableArray`1<TElement> other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<TNamespaceOrTypeSymbol> <CreateNameToMembersMap>g__createMembers|51_0(object value);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<TNamedTypeSymbol> <GetTypesFromMemberMap>g__getOrCreateNamedTypes|52_0(ImmutableArray`1<TNamespaceOrTypeSymbol> members);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Indentation.AbstractIndentation`1 : object {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IHeaderFacts HeaderFacts { get; }
    protected ISyntaxFormatting SyntaxFormatting { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual IHeaderFacts get_HeaderFacts();
    protected abstract virtual ISyntaxFormatting get_SyntaxFormatting();
    protected abstract virtual AbstractFormattingRule GetSpecializedIndentationFormattingRule(IndentStyle indentStyle);
    [NullableContextAttribute("0")]
protected abstract virtual bool ShouldUseTokenIndenter(Indenter<TSyntaxRoot> indenter, SyntaxToken& token);
    protected abstract virtual ISmartTokenFormatter CreateSmartTokenFormatter(TSyntaxRoot root, SourceText text, TextLine lineToBeIndented, IndentationOptions options, AbstractFormattingRule baseFormattingRule);
    [NullableContextAttribute("0")]
protected abstract virtual Nullable`1<IndentationResult> GetDesiredIndentationWorker(Indenter<TSyntaxRoot> indenter, Nullable`1<SyntaxToken> token, Nullable`1<SyntaxTrivia> trivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Indentation.IndentationOptions : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxFormattingOptions <FormattingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AutoFormattingOptions <AutoFormattingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentStyle <IndentStyle>k__BackingField;
    public static IndentStyle DefaultIndentStyle;
    [DataMemberAttribute]
public SyntaxFormattingOptions FormattingOptions { get; public set; }
    [DataMemberAttribute]
public AutoFormattingOptions AutoFormattingOptions { get; public set; }
    [DataMemberAttribute]
public IndentStyle IndentStyle { get; public set; }
    public IndentationOptions(SyntaxFormattingOptions FormattingOptions);
    [CompilerGeneratedAttribute]
public SyntaxFormattingOptions get_FormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormattingOptions(SyntaxFormattingOptions value);
    [CompilerGeneratedAttribute]
public AutoFormattingOptions get_AutoFormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AutoFormattingOptions(AutoFormattingOptions value);
    [CompilerGeneratedAttribute]
public IndentStyle get_IndentStyle();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentStyle(IndentStyle value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IndentationOptions left, IndentationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IndentationOptions left, IndentationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IndentationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(SyntaxFormattingOptions& FormattingOptions);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Indentation.IndentationResult : ValueType {
    [CompilerGeneratedAttribute]
private int <BasePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int BasePosition { get; }
    public int Offset { get; }
    public IndentationResult(int basePosition, int offset);
    [CompilerGeneratedAttribute]
public int get_BasePosition();
    [CompilerGeneratedAttribute]
public int get_Offset();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Indentation.ISmartTokenFormatter {
    public abstract virtual IList`1<TextChange> FormatToken(SyntaxToken token, CancellationToken cancellationToken);
}
public enum Microsoft.CodeAnalysis.Internal.Editing.DeclarationKind : Enum {
    public int value__;
    public static DeclarationKind None;
    public static DeclarationKind CompilationUnit;
    public static DeclarationKind Class;
    public static DeclarationKind Struct;
    public static DeclarationKind Interface;
    public static DeclarationKind Enum;
    public static DeclarationKind Delegate;
    public static DeclarationKind Method;
    public static DeclarationKind Operator;
    public static DeclarationKind ConversionOperator;
    public static DeclarationKind Constructor;
    public static DeclarationKind Destructor;
    public static DeclarationKind Field;
    public static DeclarationKind Property;
    public static DeclarationKind Indexer;
    public static DeclarationKind EnumMember;
    public static DeclarationKind Event;
    public static DeclarationKind CustomEvent;
    public static DeclarationKind Namespace;
    public static DeclarationKind NamespaceImport;
    public static DeclarationKind Parameter;
    public static DeclarationKind Variable;
    public static DeclarationKind Attribute;
    public static DeclarationKind LambdaExpression;
    public static DeclarationKind GetAccessor;
    public static DeclarationKind SetAccessor;
    public static DeclarationKind AddAccessor;
    public static DeclarationKind RemoveAccessor;
    public static DeclarationKind RaiseAccessor;
    [ObsoleteAttribute("This value is not used. Use Class instead.")]
[EditorBrowsableAttribute("1")]
public static DeclarationKind RecordClass;
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Internal.Editing.DeclarationModifiers : ValueType {
    private Modifiers _modifiers;
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsNew { get; }
    public bool IsUnsafe { get; }
    public bool IsReadOnly { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsConst { get; }
    public bool IsWithEvents { get; }
    public bool IsPartial { get; }
    public bool IsAsync { get; }
    public bool IsWriteOnly { get; }
    public bool IsRef { get; }
    public bool IsVolatile { get; }
    public bool IsExtern { get; }
    public bool IsRequired { get; }
    public bool IsFile { get; }
    public static DeclarationModifiers None { get; }
    public static DeclarationModifiers Static { get; }
    public static DeclarationModifiers Abstract { get; }
    public static DeclarationModifiers New { get; }
    public static DeclarationModifiers Unsafe { get; }
    public static DeclarationModifiers ReadOnly { get; }
    public static DeclarationModifiers Virtual { get; }
    public static DeclarationModifiers Override { get; }
    public static DeclarationModifiers Sealed { get; }
    public static DeclarationModifiers Const { get; }
    public static DeclarationModifiers WithEvents { get; }
    public static DeclarationModifiers Partial { get; }
    public static DeclarationModifiers Async { get; }
    public static DeclarationModifiers WriteOnly { get; }
    public static DeclarationModifiers Ref { get; }
    public static DeclarationModifiers Volatile { get; }
    public static DeclarationModifiers Extern { get; }
    public static DeclarationModifiers Required { get; }
    public static DeclarationModifiers File { get; }
    private DeclarationModifiers(Modifiers modifiers);
    internal DeclarationModifiers(bool isStatic, bool isAbstract, bool isNew, bool isUnsafe, bool isReadOnly, bool isVirtual, bool isOverride, bool isSealed, bool isConst, bool isWithEvents, bool isPartial, bool isAsync, bool isWriteOnly, bool isRef, bool isVolatile, bool isExtern, bool isRequired, bool isFile);
    public static DeclarationModifiers From(ISymbol symbol);
    public bool get_IsStatic();
    public bool get_IsAbstract();
    public bool get_IsNew();
    public bool get_IsUnsafe();
    public bool get_IsReadOnly();
    public bool get_IsVirtual();
    public bool get_IsOverride();
    public bool get_IsSealed();
    public bool get_IsConst();
    public bool get_IsWithEvents();
    public bool get_IsPartial();
    public bool get_IsAsync();
    public bool get_IsWriteOnly();
    public bool get_IsRef();
    public bool get_IsVolatile();
    public bool get_IsExtern();
    public bool get_IsRequired();
    public bool get_IsFile();
    public DeclarationModifiers WithIsStatic(bool isStatic);
    public DeclarationModifiers WithIsAbstract(bool isAbstract);
    public DeclarationModifiers WithIsNew(bool isNew);
    public DeclarationModifiers WithIsUnsafe(bool isUnsafe);
    public DeclarationModifiers WithIsReadOnly(bool isReadOnly);
    public DeclarationModifiers WithIsVirtual(bool isVirtual);
    public DeclarationModifiers WithIsOverride(bool isOverride);
    public DeclarationModifiers WithIsSealed(bool isSealed);
    public DeclarationModifiers WithIsConst(bool isConst);
    public DeclarationModifiers WithWithEvents(bool withEvents);
    public DeclarationModifiers WithPartial(bool isPartial);
    public DeclarationModifiers WithAsync(bool isAsync);
    public DeclarationModifiers WithIsWriteOnly(bool isWriteOnly);
    public DeclarationModifiers WithIsRef(bool isRef);
    public DeclarationModifiers WithIsVolatile(bool isVolatile);
    public DeclarationModifiers WithIsExtern(bool isExtern);
    public DeclarationModifiers WithIsRequired(bool isRequired);
    public DeclarationModifiers WithIsFile(bool isFile);
    private static Modifiers SetFlag(Modifiers existing, Modifiers modifier, bool isSet);
    public static DeclarationModifiers get_None();
    public static DeclarationModifiers get_Static();
    public static DeclarationModifiers get_Abstract();
    public static DeclarationModifiers get_New();
    public static DeclarationModifiers get_Unsafe();
    public static DeclarationModifiers get_ReadOnly();
    public static DeclarationModifiers get_Virtual();
    public static DeclarationModifiers get_Override();
    public static DeclarationModifiers get_Sealed();
    public static DeclarationModifiers get_Const();
    public static DeclarationModifiers get_WithEvents();
    public static DeclarationModifiers get_Partial();
    public static DeclarationModifiers get_Async();
    public static DeclarationModifiers get_WriteOnly();
    public static DeclarationModifiers get_Ref();
    public static DeclarationModifiers get_Volatile();
    public static DeclarationModifiers get_Extern();
    public static DeclarationModifiers get_Required();
    public static DeclarationModifiers get_File();
    public static DeclarationModifiers op_BitwiseOr(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_BitwiseAnd(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_Addition(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_Subtraction(DeclarationModifiers left, DeclarationModifiers right);
    public virtual string ToString();
    public static bool TryParse(string value, DeclarationModifiers& modifiers);
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DeclarationModifiers left, DeclarationModifiers right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DeclarationModifiers left, DeclarationModifiers right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DeclarationModifiers other);
}
internal class Microsoft.CodeAnalysis.Internal.Log.EmptyLogBlock : object {
    [NullableAttribute("1")]
public static EmptyLogBlock Instance;
    private static EmptyLogBlock();
    public sealed virtual void Dispose();
}
internal enum Microsoft.CodeAnalysis.Internal.Log.FunctionId : Enum {
    public int value__;
    public static FunctionId TestEvent_NotUsed;
    public static FunctionId WorkCoordinator_DocumentWorker_Enqueue;
    public static FunctionId WorkCoordinator_ProcessProjectAsync;
    public static FunctionId WorkCoordinator_ProcessDocumentAsync;
    public static FunctionId WorkCoordinator_SemanticChange_Enqueue;
    public static FunctionId WorkCoordinator_SemanticChange_EnqueueFromMember;
    public static FunctionId WorkCoordinator_SemanticChange_EnqueueFromType;
    public static FunctionId WorkCoordinator_SemanticChange_FullProjects;
    public static FunctionId WorkCoordinator_Project_Enqueue;
    public static FunctionId WorkCoordinator_AsyncWorkItemQueue_LastItem;
    public static FunctionId WorkCoordinator_AsyncWorkItemQueue_FirstItem;
    public static FunctionId Diagnostics_SyntaxDiagnostic;
    public static FunctionId Diagnostics_SemanticDiagnostic;
    public static FunctionId Diagnostics_ProjectDiagnostic;
    public static FunctionId Diagnostics_DocumentReset;
    public static FunctionId Diagnostics_DocumentOpen;
    public static FunctionId Diagnostics_RemoveDocument;
    public static FunctionId Diagnostics_RemoveProject;
    public static FunctionId Diagnostics_DocumentClose;
    public static FunctionId Run_Environment;
    public static FunctionId Run_Environment_Options;
    public static FunctionId Tagger_AdornmentManager_OnLayoutChanged;
    public static FunctionId Tagger_AdornmentManager_UpdateInvalidSpans;
    public static FunctionId Tagger_BatchChangeNotifier_NotifyEditorNow;
    public static FunctionId Tagger_BatchChangeNotifier_NotifyEditor;
    public static FunctionId Tagger_TagSource_RecomputeTags;
    public static FunctionId Tagger_TagSource_ProcessNewTags;
    public static FunctionId Tagger_SyntacticClassification_TagComputer_GetTags;
    public static FunctionId Tagger_SemanticClassification_TagProducer_ProduceTags;
    public static FunctionId Tagger_BraceHighlighting_TagProducer_ProduceTags;
    public static FunctionId Tagger_LineSeparator_TagProducer_ProduceTags;
    public static FunctionId Tagger_Outlining_TagProducer_ProduceTags;
    public static FunctionId Tagger_Highlighter_TagProducer_ProduceTags;
    public static FunctionId Tagger_ReferenceHighlighting_TagProducer_ProduceTags;
    public static FunctionId CaseCorrection_CaseCorrect;
    public static FunctionId CaseCorrection_ReplaceTokens;
    public static FunctionId CaseCorrection_AddReplacements;
    public static FunctionId CodeCleanup_CleanupAsync;
    public static FunctionId CodeCleanup_Cleanup;
    public static FunctionId CodeCleanup_IterateAllCodeCleanupProviders;
    public static FunctionId CodeCleanup_IterateOneCodeCleanup;
    public static FunctionId CommandHandler_GetCommandState;
    public static FunctionId CommandHandler_ExecuteHandlers;
    public static FunctionId CommandHandler_FormatCommand;
    public static FunctionId CommandHandler_CompleteStatement;
    public static FunctionId CommandHandler_ToggleBlockComment;
    public static FunctionId CommandHandler_ToggleLineComment;
    public static FunctionId Workspace_SourceText_GetChangeRanges;
    public static FunctionId Workspace_Recoverable_RecoverRootAsync;
    public static FunctionId Workspace_Recoverable_RecoverRoot;
    public static FunctionId Workspace_Recoverable_RecoverTextAsync;
    public static FunctionId Workspace_Recoverable_RecoverText;
    public static FunctionId Workspace_SkeletonAssembly_GetMetadataOnlyImage;
    public static FunctionId Workspace_SkeletonAssembly_EmitMetadataOnlyImage;
    public static FunctionId Workspace_Document_State_FullyParseSyntaxTree;
    public static FunctionId Workspace_Document_State_IncrementallyParseSyntaxTree;
    public static FunctionId Workspace_Document_GetSemanticModel;
    public static FunctionId Workspace_Document_GetSyntaxTree;
    public static FunctionId Workspace_Document_GetTextChanges;
    public static FunctionId Workspace_Project_GetCompilation;
    public static FunctionId Workspace_Project_CompilationTracker_BuildCompilationAsync;
    public static FunctionId Workspace_ApplyChanges;
    public static FunctionId Workspace_TryGetDocument;
    public static FunctionId Workspace_TryGetDocumentFromInProgressSolution;
    public static FunctionId Workspace_Solution_Info;
    public static FunctionId EndConstruct_DoStatement;
    public static FunctionId EndConstruct_XmlCData;
    public static FunctionId EndConstruct_XmlComment;
    public static FunctionId EndConstruct_XmlElement;
    public static FunctionId EndConstruct_XmlEmbeddedExpression;
    public static FunctionId EndConstruct_XmlProcessingInstruction;
    public static FunctionId FindReference_Rename;
    public static FunctionId FindReference_ChangeSignature;
    public static FunctionId FindReference;
    public static FunctionId FindReference_DetermineAllSymbolsAsync;
    public static FunctionId FindReference_CreateProjectMapAsync;
    public static FunctionId FindReference_CreateDocumentMapAsync;
    public static FunctionId FindReference_ProcessAsync;
    public static FunctionId FindReference_ProcessProjectAsync;
    public static FunctionId FindReference_ProcessDocumentAsync;
    public static FunctionId LineCommit_CommitRegion;
    public static FunctionId Formatting_TokenStreamConstruction;
    public static FunctionId Formatting_ContextInitialization;
    public static FunctionId Formatting_Format;
    public static FunctionId Formatting_ApplyResultToBuffer;
    public static FunctionId Formatting_CollectTokenOperation;
    public static FunctionId Formatting_BuildContext;
    public static FunctionId Formatting_ApplySpaceAndLine;
    public static FunctionId Formatting_ApplyAnchorOperation;
    public static FunctionId Formatting_ApplyAlignOperation;
    public static FunctionId Formatting_AggregateCreateTextChanges;
    public static FunctionId Formatting_AggregateCreateFormattedRoot;
    public static FunctionId Formatting_CreateTextChanges;
    public static FunctionId Formatting_CreateFormattedRoot;
    public static FunctionId Formatting_Partitions;
    public static FunctionId SmartIndentation_Start;
    public static FunctionId SmartIndentation_OpenCurly;
    public static FunctionId SmartIndentation_CloseCurly;
    public static FunctionId Rename_InlineSession;
    public static FunctionId Rename_InlineSession_Session;
    public static FunctionId Rename_FindLinkedSpans;
    public static FunctionId Rename_GetSymbolRenameInfo;
    public static FunctionId Rename_OnTextBufferChanged;
    public static FunctionId Rename_ApplyReplacementText;
    public static FunctionId Rename_CommitCore;
    public static FunctionId Rename_CommitCoreWithPreview;
    public static FunctionId Rename_GetAsynchronousLocationsSource;
    public static FunctionId Rename_AllRenameLocations;
    public static FunctionId Rename_StartSearchingForSpansInAllOpenDocuments;
    public static FunctionId Rename_StartSearchingForSpansInOpenDocument;
    public static FunctionId Rename_CreateOpenTextBufferManagerForAllOpenDocs;
    public static FunctionId Rename_CreateOpenTextBufferManagerForAllOpenDocument;
    public static FunctionId Rename_ReportSpan;
    public static FunctionId Rename_GetNoChangeConflictResolution;
    public static FunctionId Rename_Tracking_BufferChanged;
    public static FunctionId TPLTask_TaskScheduled;
    public static FunctionId TPLTask_TaskStarted;
    public static FunctionId TPLTask_TaskCompleted;
    public static FunctionId Get_QuickInfo_Async;
    public static FunctionId Completion_ModelComputer_DoInBackground;
    public static FunctionId Completion_ModelComputation_FilterModelInBackground;
    public static FunctionId Completion_ModelComputation_WaitForModel;
    public static FunctionId Completion_SymbolCompletionProvider_GetItemsWorker;
    public static FunctionId Completion_KeywordCompletionProvider_GetItemsWorker;
    public static FunctionId Completion_SnippetCompletionProvider_GetItemsWorker_CSharp;
    public static FunctionId Completion_TypeImportCompletionProvider_GetCompletionItemsAsync;
    public static FunctionId Completion_ExtensionMethodImportCompletionProvider_GetCompletionItemsAsync;
    public static FunctionId SignatureHelp_ModelComputation_ComputeModelInBackground;
    public static FunctionId SignatureHelp_ModelComputation_UpdateModelInBackground;
    public static FunctionId Refactoring_CodeRefactoringService_GetRefactoringsAsync;
    public static FunctionId Refactoring_AddImport;
    public static FunctionId Refactoring_FullyQualify;
    public static FunctionId Refactoring_GenerateFromMembers_AddConstructorParametersFromMembers;
    public static FunctionId Refactoring_GenerateFromMembers_GenerateConstructorFromMembers;
    public static FunctionId Refactoring_GenerateFromMembers_GenerateEqualsAndGetHashCode;
    public static FunctionId Refactoring_GenerateMember_GenerateConstructor;
    public static FunctionId Refactoring_GenerateMember_GenerateDefaultConstructors;
    public static FunctionId Refactoring_GenerateMember_GenerateEnumMember;
    public static FunctionId Refactoring_GenerateMember_GenerateMethod;
    public static FunctionId Refactoring_GenerateMember_GenerateVariable;
    public static FunctionId Refactoring_ImplementAbstractClass;
    public static FunctionId Refactoring_ImplementInterface;
    public static FunctionId Refactoring_IntroduceVariable;
    public static FunctionId Refactoring_GenerateType;
    public static FunctionId Refactoring_RemoveUnnecessaryImports_CSharp;
    public static FunctionId Refactoring_RemoveUnnecessaryImports_VisualBasic;
    public static FunctionId Snippet_OnBeforeInsertion;
    public static FunctionId Snippet_OnAfterInsertion;
    public static FunctionId Misc_NonReentrantLock_BlockingWait;
    public static FunctionId Misc_SaveEventsSink_OnBeforeSave;
    public static FunctionId TaskList_Refresh;
    public static FunctionId TaskList_NavigateTo;
    public static FunctionId WinformDesigner_GenerateXML;
    public static FunctionId NavigateTo_Search;
    public static FunctionId NavigationService_VSDocumentNavigationService_NavigateTo;
    public static FunctionId NavigationBar_ComputeModelAsync;
    public static FunctionId NavigationBar_ItemService_GetMembersInTypes_CSharp;
    public static FunctionId NavigationBar_ItemService_GetTypesInFile_CSharp;
    public static FunctionId NavigationBar_UpdateDropDownsSynchronously_WaitForModel;
    public static FunctionId NavigationBar_UpdateDropDownsSynchronously_WaitForSelectedItemInfo;
    public static FunctionId EventHookup_Determine_If_Event_Hookup;
    public static FunctionId EventHookup_Generate_Handler;
    public static FunctionId EventHookup_Type_Char;
    public static FunctionId Cache_Created;
    public static FunctionId Cache_AddOrAccess;
    public static FunctionId Cache_Remove;
    public static FunctionId Cache_Evict;
    public static FunctionId Cache_EvictAll;
    public static FunctionId Cache_ItemRank;
    public static FunctionId TextStructureNavigator_GetExtentOfWord;
    public static FunctionId TextStructureNavigator_GetSpanOfEnclosing;
    public static FunctionId TextStructureNavigator_GetSpanOfFirstChild;
    public static FunctionId TextStructureNavigator_GetSpanOfNextSibling;
    public static FunctionId TextStructureNavigator_GetSpanOfPreviousSibling;
    public static FunctionId Debugging_LanguageDebugInfoService_GetDataTipSpanAndText;
    public static FunctionId Debugging_VsLanguageDebugInfo_ValidateBreakpointLocation;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetProximityExpressions;
    public static FunctionId Debugging_VsLanguageDebugInfo_ResolveName;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetNameOfLocation;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetDataTipText;
    public static FunctionId Debugging_EncSession;
    public static FunctionId Debugging_EncSession_EditSession;
    public static FunctionId Debugging_EncSession_EditSession_EmitDeltaErrorId;
    public static FunctionId Debugging_EncSession_EditSession_RudeEdit;
    public static FunctionId Simplifier_ReduceAsync;
    public static FunctionId Simplifier_ExpandNode;
    public static FunctionId Simplifier_ExpandToken;
    public static FunctionId ForegroundNotificationService_Processed;
    public static FunctionId ForegroundNotificationService_NotifyOnForeground;
    public static FunctionId BackgroundCompiler_BuildCompilationsAsync;
    public static FunctionId PersistenceService_ReadAsync;
    public static FunctionId PersistenceService_WriteAsync;
    public static FunctionId PersistenceService_ReadAsyncFailed;
    public static FunctionId PersistenceService_WriteAsyncFailed;
    public static FunctionId PersistenceService_Initialization;
    public static FunctionId TemporaryStorageServiceFactory_ReadText;
    public static FunctionId TemporaryStorageServiceFactory_WriteText;
    public static FunctionId TemporaryStorageServiceFactory_ReadStream;
    public static FunctionId TemporaryStorageServiceFactory_WriteStream;
    public static FunctionId PullMembersUpWarning_ChangeTargetToAbstract;
    public static FunctionId PullMembersUpWarning_ChangeOriginToPublic;
    public static FunctionId PullMembersUpWarning_ChangeOriginToNonStatic;
    public static FunctionId PullMembersUpWarning_UserProceedToFinish;
    public static FunctionId PullMembersUpWarning_UserGoBack;
    public static FunctionId SmartTags_RefreshSession;
    public static FunctionId SmartTags_SmartTagInitializeFixes;
    public static FunctionId SmartTags_ApplyQuickFix;
    public static FunctionId EditorTestApp_RefreshTask;
    public static FunctionId EditorTestApp_UpdateDiagnostics;
    public static FunctionId IncrementalAnalyzerProcessor_Analyzers;
    public static FunctionId IncrementalAnalyzerProcessor_Analyzer;
    public static FunctionId IncrementalAnalyzerProcessor_ActiveFileAnalyzers;
    public static FunctionId IncrementalAnalyzerProcessor_ActiveFileAnalyzer;
    public static FunctionId IncrementalAnalyzerProcessor_Shutdown;
    public static FunctionId WorkCoordinatorRegistrationService_Register;
    public static FunctionId WorkCoordinatorRegistrationService_Unregister;
    public static FunctionId WorkCoordinatorRegistrationService_Reanalyze;
    public static FunctionId WorkCoordinator_PersistentStorageAdded;
    public static FunctionId WorkCoordinator_PersistentStorageRemoved;
    public static FunctionId WorkCoordinator_Shutdown;
    public static FunctionId DiagnosticAnalyzerService_Analyzers;
    public static FunctionId DiagnosticAnalyzerDriver_AnalyzerTypeCount;
    public static FunctionId StorageDatabase_Exceptions;
    public static FunctionId WorkCoordinator_ShutdownTimeout;
    public static FunctionId Diagnostics_HyperLink;
    public static FunctionId CodeFixes_FixAllOccurrencesSession;
    public static FunctionId CodeFixes_FixAllOccurrencesContext;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Diagnostics;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Diagnostics;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Fixes;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Fixes;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Merge;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Merge;
    public static FunctionId CodeFixes_FixAllOccurrencesPreviewChanges;
    public static FunctionId CodeFixes_ApplyChanges;
    public static FunctionId SolutionExplorer_AnalyzerItemSource_GetItems;
    public static FunctionId SolutionExplorer_DiagnosticItemSource_GetItems;
    public static FunctionId WorkCoordinator_ActiveFileEnqueue;
    public static FunctionId SymbolFinder_FindDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_AddDeclarationsAsync;
    public static FunctionId SymbolFinder_Assembly_AddDeclarationsAsync;
    public static FunctionId SymbolFinder_Solution_Name_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Name_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Solution_Predicate_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Predicate_FindSourceDeclarationsAsync;
    public static FunctionId Tagger_Diagnostics_RecomputeTags;
    public static FunctionId Tagger_Diagnostics_Updated;
    public static FunctionId SuggestedActions_HasSuggestedActionsAsync;
    public static FunctionId SuggestedActions_GetSuggestedActions;
    public static FunctionId VirtualMemory_MemoryLow;
    public static FunctionId Extension_Exception;
    public static FunctionId WorkCoordinator_WaitForHigherPriorityOperationsAsync;
    public static FunctionId CSharp_Interactive_Window;
    public static FunctionId VisualBasic_Interactive_Window;
    public static FunctionId NonFatalWatson;
    public static FunctionId CommandHandler_FindAllReference;
    public static FunctionId CodefixInfobar_Enable;
    public static FunctionId CodefixInfobar_EnableAndIgnoreFutureErrors;
    public static FunctionId CodefixInfobar_LeaveDisabled;
    public static FunctionId CodefixInfobar_ErrorIgnored;
    public static FunctionId Refactoring_NamingStyle;
    public static FunctionId SymbolTreeInfo_ExceptionInCacheRead;
    public static FunctionId SpellChecker_ExceptionInCacheRead;
    public static FunctionId BKTree_ExceptionInCacheRead;
    public static FunctionId IntellisenseBuild_Failed;
    public static FunctionId FileTextLoader_FileLengthThresholdExceeded;
    public static FunctionId MeasurePerformance_StartAction;
    public static FunctionId MeasurePerformance_StopAction;
    public static FunctionId Serializer_CreateChecksum;
    public static FunctionId Serializer_Serialize;
    public static FunctionId Serializer_Deserialize;
    public static FunctionId CodeAnalysisService_CalculateDiagnosticsAsync;
    public static FunctionId CodeAnalysisService_SerializeDiagnosticResultAsync;
    public static FunctionId CodeAnalysisService_GetReferenceCountAsync;
    public static FunctionId CodeAnalysisService_FindReferenceLocationsAsync;
    public static FunctionId CodeAnalysisService_FindReferenceMethodsAsync;
    public static FunctionId CodeAnalysisService_GetFullyQualifiedName;
    public static FunctionId CodeAnalysisService_GetTodoCommentsAsync;
    public static FunctionId CodeAnalysisService_GetDesignerAttributesAsync;
    public static FunctionId ServiceHubRemoteHostClient_CreateAsync;
    public static FunctionId RemoteHost_Connect;
    public static FunctionId RemoteHost_Disconnect;
    public static FunctionId RemoteHostService_SynchronizePrimaryWorkspaceAsync;
    public static FunctionId AssetStorage_CleanAssets;
    public static FunctionId AssetStorage_TryGetAsset;
    public static FunctionId AssetService_GetAssetAsync;
    public static FunctionId AssetService_SynchronizeAssetsAsync;
    public static FunctionId AssetService_SynchronizeSolutionAssetsAsync;
    public static FunctionId AssetService_SynchronizeProjectAssetsAsync;
    public static FunctionId CodeLens_GetReferenceCountAsync;
    public static FunctionId CodeLens_FindReferenceLocationsAsync;
    public static FunctionId CodeLens_FindReferenceMethodsAsync;
    public static FunctionId CodeLens_GetFullyQualifiedName;
    public static FunctionId SolutionState_ComputeChecksumsAsync;
    public static FunctionId ProjectState_ComputeChecksumsAsync;
    public static FunctionId DocumentState_ComputeChecksumsAsync;
    public static FunctionId SolutionCompilationState_ComputeChecksumsAsync;
    public static FunctionId SolutionChecksumUpdater_SynchronizePrimaryWorkspace;
    public static FunctionId JsonRpcSession_RequestAssetAsync;
    public static FunctionId SolutionService_GetSolutionAsync;
    public static FunctionId SolutionService_UpdatePrimaryWorkspaceAsync;
    public static FunctionId RemoteHostService_GetAssetsAsync;
    public static FunctionId SolutionCreator_AssetDifferences;
    public static FunctionId Extension_InfoBar;
    public static FunctionId FxCopAnalyzersInstall;
    public static FunctionId Intellisense_Completion;
    public static FunctionId MetadataOnlyImage_EmitFailure;
    public static FunctionId LiveTableDataSource_OnDiagnosticsUpdated;
    public static FunctionId Experiment_KeybindingsReset;
    public static FunctionId Diagnostics_GeneratePerformaceReport;
    public static FunctionId CodeAnalysisService_ReportAnalyzerPerformance;
    public static FunctionId PerformanceTrackerService_AddSnapshot;
    public static FunctionId ExternalErrorDiagnosticUpdateSource_AddError;
    public static FunctionId DiagnosticIncrementalAnalyzer_SynchronizeWithBuildAsync;
    public static FunctionId Completion_ExecuteCommand_TypeChar;
    public static FunctionId RemoteHostService_SynchronizeTextAsync;
    public static FunctionId SymbolFinder_Solution_Pattern_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Pattern_FindSourceDeclarationsAsync;
    public static FunctionId CodeCleanupInfobar_BarDisplayed;
    public static FunctionId CodeCleanupInfobar_ConfigureNow;
    public static FunctionId CodeCleanupInfobar_NeverShowCodeCleanupInfoBarAgain;
    public static FunctionId FormatDocument;
    public static FunctionId CodeCleanup_ApplyCodeFixesAsync;
    public static FunctionId CodeCleanup_RemoveUnusedImports;
    public static FunctionId CodeCleanup_SortImports;
    public static FunctionId CodeCleanup_Format;
    public static FunctionId CodeCleanupABTest_AssignedToOnByDefault;
    public static FunctionId CodeCleanupABTest_AssignedToOffByDefault;
    public static FunctionId Workspace_Events;
    public static FunctionId Refactoring_ExtractMethod_UnknownMatrixItem;
    public static FunctionId SyntaxTreeIndex_Precalculate;
    public static FunctionId SyntaxTreeIndex_Precalculate_Create;
    public static FunctionId SymbolTreeInfo_Create;
    public static FunctionId SymbolTreeInfo_TryLoadOrCreate;
    public static FunctionId CommandHandler_GoToImplementation;
    public static FunctionId GraphQuery_ImplementedBy;
    public static FunctionId GraphQuery_Implements;
    public static FunctionId GraphQuery_IsCalledBy;
    public static FunctionId GraphQuery_IsUsedBy;
    public static FunctionId GraphQuery_Overrides;
    public static FunctionId Intellisense_AsyncCompletion_Data;
    public static FunctionId Intellisense_CompletionProviders_Data;
    public static FunctionId RemoteHostService_IsExperimentEnabledAsync;
    public static FunctionId PartialLoad_FullyLoaded;
    public static FunctionId Liveshare_UnknownCodeAction;
    public static FunctionId CommandHandler_GoToBase;
    public static FunctionId DiagnosticAnalyzerService_GetDiagnosticsForSpanAsync;
    public static FunctionId CodeFixes_GetCodeFixesAsync;
    public static FunctionId LanguageServer_ActivateFailed;
    public static FunctionId LanguageServer_OnLoadedFailed;
    public static FunctionId CodeFixes_AddExplicitCast;
    public static FunctionId ToolsOptions_GenerateEditorconfig;
    public static FunctionId Renamer_RenameSymbolAsync;
    public static FunctionId Renamer_FindRenameLocationsAsync;
    public static FunctionId Renamer_ResolveConflictsAsync;
    public static FunctionId ChangeSignature_Data;
    public static FunctionId AbstractEncapsulateFieldService_EncapsulateFieldsAsync;
    public static FunctionId AbstractConvertTupleToStructCodeRefactoringProvider_ConvertToStructAsync;
    public static FunctionId DependentTypeFinder_FindAndCacheDerivedClassesAsync;
    public static FunctionId DependentTypeFinder_FindAndCacheDerivedInterfacesAsync;
    public static FunctionId DependentTypeFinder_FindAndCacheImplementingTypesAsync;
    public static FunctionId RemoteSemanticClassificationCacheService_ExceptionInCacheRead;
    public static FunctionId LSPCompletion_MissingLSPCompletionTriggerKind;
    public static FunctionId LSPCompletion_MissingLSPCompletionInvokeKind;
    public static FunctionId Workspace_Project_CompilationThrownAway;
    public static FunctionId CommandHandler_Paste_ImportsOnPaste;
    public static FunctionId RegisterWorkspace;
    public static FunctionId LSP_RequestCounter;
    public static FunctionId LSP_RequestDuration;
    public static FunctionId LSP_TimeInQueue;
    public static FunctionId Intellicode_UnknownIntent;
    public static FunctionId LSP_CompletionListCacheMiss;
    public static FunctionId InheritanceMargin_TargetsMenuOpen;
    public static FunctionId InheritanceMargin_NavigateToTarget;
    public static FunctionId VS_ErrorReportingService_ShowGlobalErrorInfo;
    public static FunctionId UnusedReferences_GetUnusedReferences;
    public static FunctionId ValueTracking_Command;
    public static FunctionId ValueTracking_TrackValueSource;
    public static FunctionId InheritanceMargin_GetInheritanceMemberItems;
    public static FunctionId LSP_FindDocumentInWorkspace;
    public static FunctionId SuggestedActions_GetSuggestedActionsAsync;
    public static FunctionId NavigateTo_CacheItemsMiss;
    public static FunctionId AssetService_Perf;
    public static FunctionId Inline_Hints_DoubleClick;
    public static FunctionId NavigateToExternalSources;
    public static FunctionId StackTraceToolWindow_ShowOnActivated;
    public static FunctionId CodeModel_FileCodeModel_Create;
    public static FunctionId Refactoring_FixAllOccurrencesSession;
    public static FunctionId Refactoring_FixAllOccurrencesContext;
    public static FunctionId Refactoring_FixAllOccurrencesComputation;
    public static FunctionId Refactoring_FixAllOccurrencesPreviewChanges;
    public static FunctionId LSP_UsedForkedSolution;
    public static FunctionId DocumentOutline_WindowOpen;
    public static FunctionId DocumentOutline_SortByName;
    public static FunctionId DocumentOutline_SortByOrder;
    public static FunctionId DocumentOutline_SortByType;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMatch_ApplicationSucceeded;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMatch_ApplicationFailed;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationSucceeded;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_IncompatibleSolutionChange;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_IncompatibleProjectChange;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_NoChangedDocument;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_NoTextChange;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_DocumentRemoved;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_TextChangeConflict;
    public static FunctionId Completion_SemanticSnippets;
    public static FunctionId SpellCheckFixer_CouldNotFindDocument;
    public static FunctionId SpellCheckFixer_LanguageDoesNotSupportRename;
    public static FunctionId SpellCheckFixer_LanguageCouldNotGetRenameInfo;
    public static FunctionId SpellCheckFixer_RenameSpanNotWithinTokenSpan;
    public static FunctionId SpellCheckFixer_ReplacementTextInvalid;
    public static FunctionId SpellCheckFixer_TryApplyChangesFailure;
    public static FunctionId SourceGenerator_SolutionStatistics;
    public static FunctionId SourceGenerator_OtherWorkspaceSessionStatistics;
    public static FunctionId SQLite_SqlException;
    public static FunctionId SQLite_StorageDisabled;
    public static FunctionId Diagnostics_AnalyzerPerformanceInfo2;
    public static FunctionId SemanticModelReuseLanguageService_TryGetSpeculativeSemanticModelAsync_Equivalent;
    public static FunctionId Rename_TryApplyRename_WorkspaceChanged;
    public static FunctionId Rename_InlineSession_Cancel_NonDocumentChangedWorkspaceChange;
    public static FunctionId LSP_Initialize;
    public static FunctionId CodeFix_Delay;
    public static FunctionId CodeFix_Summary;
    public static FunctionId CodeRefactoring_Delay;
    public static FunctionId CodeRefactoring_Summary;
    public static FunctionId PerformAnalysis_Delay;
    public static FunctionId PerformAnalysis_Summary;
    public static FunctionId RequestDiagnostics_Delay;
    public static FunctionId RequestDiagnostics_Summary;
    public static FunctionId SuggestedAction_Delay;
    public static FunctionId SuggestedAction_Summary;
    public static FunctionId SuggestedAction_Application_Delay;
    public static FunctionId SuggestedAction_Application_Summary;
    public static FunctionId SuggestedAction_Preview_Delay;
    public static FunctionId SuggestedAction_Preview_Summary;
    public static FunctionId LSP_DocumentIdCacheMiss;
    public static FunctionId RemoteWorkspace_SolutionCachingStatistics;
    public static FunctionId SemanticSearch_QueryExecution;
    public static FunctionId Copilot_Suggestion_Dismissed;
    public static FunctionId Copilot_On_The_Fly_Docs_Showed_Link;
    public static FunctionId Copilot_On_The_Fly_Docs_Loading_State_Entered;
    public static FunctionId Copilot_On_The_Fly_Docs_Results_Displayed;
    public static FunctionId Copilot_On_The_Fly_Docs_Error_Displayed;
    public static FunctionId Copilot_On_The_Fly_Docs_Results_Canceled;
    public static FunctionId Copilot_On_The_Fly_Docs_Get_Counts;
    public static FunctionId Copilot_Rename;
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Internal.Log.ILogger {
    public abstract virtual bool IsEnabled(FunctionId functionId);
    public abstract virtual void Log(FunctionId functionId, LogMessage logMessage);
    public abstract virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public abstract virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Internal.Log.Logger : object {
    [NullableAttribute("2")]
private static ILogger s_currentLogger;
    private static int s_lastUniqueBlockId;
    private static ObjectPool`1<RoslynLogBlock> s_pool;
    private static Logger();
    [NullableContextAttribute("2")]
public static ILogger SetLogger(ILogger logger);
    [NullableContextAttribute("2")]
public static ILogger GetLogger();
    [NullableContextAttribute("2")]
private static bool TryGetActiveLogger(FunctionId functionId, ILogger& activeLogger);
    [NullableContextAttribute("2")]
public static void Log(FunctionId functionId, string message, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`1<string> messageGetter, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`2<TArg, string> messageGetter, TArg arg, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3, LogLevel logLevel);
    public static void Log(FunctionId functionId, LogMessage logMessage);
    private static int GetNextUniqueBlockId();
    public static IDisposable LogBlock(FunctionId functionId, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, string message, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`1<string> messageGetter, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`2<TArg, string> messageGetter, TArg arg, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, LogMessage logMessage, CancellationToken token);
    private static IDisposable CreateLogBlock(FunctionId functionId, LogMessage message, int blockId, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Internal.Log.LogLevel : Enum {
    public int value__;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Information;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Critical;
    public static LogLevel None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Internal.Log.LogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [NullableAttribute("2")]
private string _message;
    public LogLevel LogLevel { get; protected set; }
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
protected void set_LogLevel(LogLevel value);
    public static LogMessage Create(string message, LogLevel logLevel);
    public static LogMessage Create(Func`1<string> messageGetter, LogLevel logLevel);
    public static LogMessage Create(Func`2<TArg, string> messageGetter, TArg arg, LogLevel logLevel);
    public static LogMessage Create(Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1, LogLevel logLevel);
    public static LogMessage Create(Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, LogLevel logLevel);
    public static LogMessage Create(Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3, LogLevel logLevel);
    protected abstract virtual string CreateMessage();
    protected abstract virtual void FreeCore();
    public string GetMessage();
    public void Free();
}
internal static class Microsoft.CodeAnalysis.Internal.Strings : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractBlockFacts : object {
    [NullableContextAttribute("2")]
public abstract virtual bool IsScopeBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsExecutableBlock(SyntaxNode node);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    public abstract virtual SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    [NullableContextAttribute("2")]
public abstract virtual bool IsStatementContainer(SyntaxNode node);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetStatementContainerStatements(SyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractDocumentationCommentService`10 : object {
    public static string Ellipsis;
    private ISyntaxFacts _syntaxFacts;
    protected AbstractDocumentationCommentService`10(ISyntaxFacts syntaxFacts);
    private static void AddSpaceIfNotAlreadyThere(StringBuilder sb);
    private string GetDocumentationCommentPrefix(TDocumentationCommentTriviaSyntax documentationComment);
    public string GetBannerText(TDocumentationCommentTriviaSyntax documentationComment, int maxBannerLength, CancellationToken cancellationToken);
    private void HandleElement(TXmlElementSyntax summaryElement, StringBuilder sb);
    private void HandleNode(SyntaxNode node, StringBuilder sb);
    protected abstract virtual SyntaxToken GetIdentifier(TXmlNameAttributeSyntax xmlName);
    protected abstract virtual TCrefSyntax GetCref(TXmlCrefAttributeSyntax xmlCref);
    protected abstract virtual SyntaxList`1<TXmlAttributeSyntax> GetAttributes(TXmlEmptyElementSyntax xmlEmpty);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextSyntax xmlText);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextAttributeSyntax xmlTextAttribute);
    protected abstract virtual SyntaxNode GetName(TXmlElementSyntax xmlElement);
    private static void AppendTextTokens(StringBuilder sb, SyntaxTokenList textTokens);
    private static bool HasLeadingWhitespace(string tokenText);
    private static bool HasTrailingWhitespace(string tokenText);
    public sealed virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int maxBannerLength, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <GetBannerText>b__5_0(TXmlElementSyntax e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractFileBannerFacts : object {
    private Matcher`1<SyntaxTrivia> _oneOrMoreBlankLines;
    private Matcher`1<SyntaxTrivia> _bannerMatcher;
    private Matcher`1<SyntaxTrivia> _fileBannerMatcher;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IDocumentationCommentService DocumentationCommentService { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual IDocumentationCommentService get_DocumentationCommentService();
    public sealed virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int bannerLength, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(SyntaxNode node);
    [NullableContextAttribute("0")]
public ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(TSyntaxNode node);
    public sealed virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    public sealed virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public sealed virtual TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public sealed virtual TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxNode root);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxToken firstToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractHeaderFacts : object {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    public abstract virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    public abstract virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    public abstract virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    public abstract virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    public abstract virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    public abstract virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    public abstract virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    public abstract virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
    public bool IsOnHeader(SyntaxNode root, int position, SyntaxNode ownerOfHeader, SyntaxNodeOrToken lastTokenOrNodeOfHeader);
    public bool IsOnHeader(SyntaxNode root, int position, SyntaxNode ownerOfHeader, SyntaxNodeOrToken lastTokenOrNodeOfHeader, ImmutableArray`1<THoleSyntax> holes);
    protected TNode TryGetAncestorForLocation(SyntaxNode root, int position);
    protected int GetStartOfNodeExcludingAttributes(SyntaxNode root, SyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractSelectedMembers`5 : object {
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetMembers(TTypeDeclarationSyntax containingType);
    protected abstract virtual ImmutableArray`1<ValueTuple`2<SyntaxNode, SyntaxToken>> GetDeclaratorsAndIdentifiers(TMemberDeclarationSyntax member);
    public Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedFieldsAndPropertiesAsync(SyntaxTree tree, TextSpan textSpan, bool allowPartialSelection, CancellationToken cancellationToken);
    public Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedMembersAsync(SyntaxTree tree, TextSpan textSpan, bool allowPartialSelection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LanguageService.AbstractSelectedMembers`5/<GetSelectedMembersAsync>d__4")]
private Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedMembersAsync(SyntaxTree tree, TextSpan textSpan, bool allowPartialSelection, Func`2<TMemberDeclarationSyntax, bool> membersToKeep, CancellationToken cancellationToken);
    private ImmutableArray`1<SyntaxNode> GetMembersInSpan(SyntaxNode root, SourceText text, TextSpan textSpan, TMemberDeclarationSyntax firstMember, bool allowPartialSelection, Func`2<TMemberDeclarationSyntax, bool> membersToKeep);
    private static bool IsBeforeOrAfterNodeOnSameLine(SourceText text, SyntaxNode root, SyntaxNode member, int position);
    private static bool IsFieldOrProperty(TMemberDeclarationSyntax member);
    [CompilerGeneratedAttribute]
private void <GetMembersInSpan>g__AddAllMembers|5_0(TMemberDeclarationSyntax member, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
private void <GetMembersInSpan>g__AddSelectedMemberDeclarations|5_1(TMemberDeclarationSyntax member, Func`2<TMemberDeclarationSyntax, bool> membersToKeep, <>c__DisplayClass5_0& );
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.LanguageService.DisplayNameOptions : Enum {
    public int value__;
    public static DisplayNameOptions None;
    public static DisplayNameOptions IncludeMemberKeyword;
    public static DisplayNameOptions IncludeNamespaces;
    public static DisplayNameOptions IncludeParameters;
    public static DisplayNameOptions IncludeType;
    public static DisplayNameOptions IncludeTypeParameters;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.LanguageService.ExternalSourceInfo : ValueType {
    public Nullable`1<int> StartLine;
    public bool Ends;
    public ExternalSourceInfo(Nullable`1<int> startLine, bool ends);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.LanguageService.ForEachSymbols : ValueType {
    public IMethodSymbol GetEnumeratorMethod;
    public IMethodSymbol MoveNextMethod;
    public IPropertySymbol CurrentProperty;
    public IMethodSymbol DisposeMethod;
    public ITypeSymbol ElementType;
    internal ForEachSymbols(IMethodSymbol getEnumeratorMethod, IMethodSymbol moveNextMethod, IPropertySymbol currentProperty, IMethodSymbol disposeMethod, ITypeSymbol elementType);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IAccessibilityFacts {
    public abstract virtual bool CanHaveAccessibility(SyntaxNode declaration, bool ignoreDeclarationModifiers);
    public abstract virtual Accessibility GetAccessibility(SyntaxNode declaration);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IBlockFacts {
    [NullableContextAttribute("2")]
public abstract virtual bool IsScopeBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsExecutableBlock(SyntaxNode node);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    public abstract virtual SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    [NullableContextAttribute("2")]
public abstract virtual bool IsStatementContainer(SyntaxNode node);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetStatementContainerStatements(SyntaxNode node);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.IBlockFactsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode GetStatementContainer(IBlockFacts blockFacts, SyntaxNode node);
}
internal interface Microsoft.CodeAnalysis.LanguageService.IDocumentationCommentService {
    public abstract virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int bannerLength, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IFileBannerFacts {
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxNode root);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxToken firstToken);
    public abstract virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int maxBannerLength, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(SyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.IFileBannerFactsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetTriviaAfterLeadingBlankLines(IFileBannerFacts bannerService, SyntaxNode node);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IHeaderFacts {
    public abstract virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    public abstract virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    public abstract virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    public abstract virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    public abstract virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    public abstract virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    public abstract virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    public abstract virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    public abstract virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.IHeaderFactsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsOnTypeHeader(IHeaderFacts headerFacts, SyntaxNode root, int position, SyntaxNode& typeDeclaration);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.ISemanticFacts {
    public ISyntaxFacts SyntaxFacts { get; }
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool SupportsParameterizedProperties { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    public abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual bool get_SupportsImplicitInterfaceImplementation();
    public abstract virtual bool get_SupportsParameterizedProperties();
    public abstract virtual bool get_ExposesAnonymousFunctionParameterNames();
    public abstract virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public abstract virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public abstract virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public abstract virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public abstract virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    public abstract virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public abstract virtual SymbolInfo GetCollectionInitializerSymbolInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual IMethodSymbol GetGetAwaiterMethod(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual bool IsPartial(INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public abstract virtual IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public abstract virtual IParameterSymbol FindParameterForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, bool allowParams, CancellationToken cancellationToken);
    public abstract virtual ISymbol FindFieldOrPropertyForArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    public abstract virtual ISymbol FindFieldOrPropertyForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public abstract virtual bool IsInsideNameOfExpression(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<IMethodSymbol> GetLocalFunctionSymbols(Compilation compilation, ISymbol symbol, CancellationToken cancellationToken);
    public abstract virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionType, CancellationToken cancellationToken);
    public abstract virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.ISemanticFactsExtensions : object {
    [ExtensionAttribute]
public static bool IsSafeToChangeAssociativity(ISemanticFacts semanticFacts, TBinaryExpressionSyntax innerBinary, TBinaryExpressionSyntax parentBinary, SemanticModel semanticModel);
    private static bool AnySymbolIsUserDefinedOperator(SymbolInfo symbolInfo);
    [NullableContextAttribute("2")]
private static bool IsUserDefinedOperator(ISymbol symbol);
    private static bool IsFloatingPoint(TypeInfo typeInfo);
    [NullableContextAttribute("2")]
private static bool IsFloatingPoint(ITypeSymbol type);
    [ExtensionAttribute]
public static IParameterSymbol FindParameterForArgument(ISemanticFacts semanticFacts, SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol FindParameterForAttributeArgument(ISemanticFacts semanticFacts, SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsSafeToChangeAssociativity>g__IsArithmetic|0_0(IBinaryOperation op);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts {
    public bool IsCaseSensitive { get; }
    public StringComparer StringComparer { get; }
    public SyntaxTrivia ElasticMarker { get; }
    public SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public ISyntaxKinds SyntaxKinds { get; }
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual StringComparer get_StringComparer();
    public abstract virtual SyntaxTrivia get_ElasticMarker();
    public abstract virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    public abstract virtual ISyntaxKinds get_SyntaxKinds();
    public abstract virtual bool SupportsIndexingInitializer(ParseOptions options);
    public abstract virtual bool SupportsLocalFunctionDeclaration(ParseOptions options);
    public abstract virtual bool SupportsNotPattern(ParseOptions options);
    public abstract virtual bool SupportsRecord(ParseOptions options);
    public abstract virtual bool SupportsRecordStruct(ParseOptions options);
    public abstract virtual bool SupportsThrowExpression(ParseOptions options);
    public abstract virtual bool SupportsTargetTypedConditionalExpression(ParseOptions options);
    public abstract virtual bool SupportsIsNotTypeExpression(ParseOptions options);
    public abstract virtual bool SupportsConstantInterpolatedStrings(ParseOptions options);
    public abstract virtual bool SupportsTupleDeconstruction(ParseOptions options);
    public abstract virtual bool SupportsCollectionExpressionNaturalType(ParseOptions options);
    public abstract virtual SyntaxToken ParseToken(string text);
    public abstract virtual SyntaxTriviaList ParseLeadingTrivia(string text);
    public abstract virtual string EscapeIdentifier(string identifier);
    public abstract virtual bool IsVerbatimIdentifier(SyntaxToken token);
    public abstract virtual bool IsOperator(SyntaxToken token);
    public abstract virtual bool IsPredefinedOperator(SyntaxToken token);
    public abstract virtual bool IsPredefinedOperator(SyntaxToken token, PredefinedOperator op);
    public abstract virtual bool IsPredefinedType(SyntaxToken token);
    public abstract virtual bool IsPredefinedType(SyntaxToken token, PredefinedType type);
    [NullableContextAttribute("2")]
public abstract virtual bool IsPredefinedType(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsPredefinedType(SyntaxNode node, PredefinedType type);
    public abstract virtual bool IsReservedKeyword(SyntaxToken token);
    public abstract virtual bool IsContextualKeyword(SyntaxToken token);
    public abstract virtual bool IsPreprocessorKeyword(SyntaxToken token);
    public abstract virtual bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsLiteral(SyntaxToken token);
    public abstract virtual bool IsStringLiteralOrInterpolatedStringLiteral(SyntaxToken token);
    public abstract virtual bool IsNumericLiteral(SyntaxToken token);
    public abstract virtual bool IsVerbatimStringLiteral(SyntaxToken token);
    [NullableContextAttribute("2")]
public abstract virtual bool IsUsingOrExternOrImport(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsGlobalAssemblyAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsGlobalModuleAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDeclaration(SyntaxNode node);
    public abstract virtual bool IsTypeDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsUsingAliasDirective(SyntaxNode node);
    public abstract virtual bool IsRegularComment(SyntaxTrivia trivia);
    public abstract virtual bool IsDocumentationComment(SyntaxTrivia trivia);
    public abstract virtual bool IsElastic(SyntaxTrivia trivia);
    public abstract virtual bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
    public abstract virtual bool IsPreprocessorDirective(SyntaxTrivia trivia);
    public abstract virtual bool IsDocumentationComment(SyntaxNode node);
    public abstract virtual string GetText(int kind);
    [NullableContextAttribute("2")]
public abstract virtual bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool TryGetPredefinedType(SyntaxToken token, PredefinedType& type);
    public abstract virtual bool TryGetPredefinedOperator(SyntaxToken token, PredefinedOperator& op);
    [NullableContextAttribute("2")]
public abstract virtual bool TryGetExternalSourceInfo(SyntaxNode directive, ExternalSourceInfo& info);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDeclarationExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsConversionExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsCastExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsExpressionOfForeach(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfForeachStatement(SyntaxNode statement);
    public abstract virtual void GetPartsOfTupleExpression(SyntaxNode node, SyntaxToken& openParen, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParen);
    [NullableContextAttribute("2")]
public abstract virtual bool IsVerbatimInterpolatedStringExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnyAssignmentStatement(SyntaxNode statement);
    [NullableContextAttribute("2")]
public abstract virtual bool IsSimpleAssignmentStatement(SyntaxNode statement);
    public abstract virtual void GetPartsOfAssignmentStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfAssignmentExpressionOrStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfAnyAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfCompoundAssignment(SyntaxNode node);
    public abstract virtual SyntaxNode GetRightHandSideOfAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsInferredAnonymousObjectMemberDeclarator(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsOperandOfIncrementExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsOperandOfIncrementOrDecrementExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfDot(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetRightSideOfDot(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetLeftSideOfDot(SyntaxNode node, bool allowImplicitTarget);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfExplicitInterfaceSpecifier(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfSimpleMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfAnyMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetStandaloneExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetRootConditionalAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfMemberAccessExpression(SyntaxNode node, bool allowImplicitTarget);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetTargetOfMemberBinding(SyntaxNode node);
    public abstract virtual SyntaxNode GetNameOfMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsPointerMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNamedArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfNamedArgument(SyntaxNode node);
    public abstract virtual SyntaxNode GetParameterList(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsParameterList(SyntaxNode node);
    public abstract virtual bool IsDocumentationCommentExteriorTrivia(SyntaxTrivia trivia);
    public abstract virtual void GetPartsOfElementAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public abstract virtual SyntaxNode GetExpressionOfArgument(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfAttributeArgument(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfInterpolation(SyntaxNode node);
    public abstract virtual SyntaxNode GetNameOfAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsPostfixUnaryExpression(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfSimpleName(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfTypeDeclaration(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfVariableDeclarator(SyntaxNode node);
    public abstract virtual SyntaxNode GetTypeOfVariableDeclarator(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsSimpleArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAttributeArgument(SyntaxNode node);
    public abstract virtual RefKind GetRefKindOfArgument(SyntaxNode node);
    public abstract virtual void GetNameAndArityOfSimpleName(SyntaxNode node, String& name, Int32& arity);
    public abstract virtual bool LooksGeneric(SyntaxNode simpleName);
    [NullableContextAttribute("2")]
public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetTypeArgumentsOfGenericName(SyntaxNode genericName);
    public abstract virtual SyntaxList`1<SyntaxNode> GetContentsOfInterpolatedString(SyntaxNode interpolatedString);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfObjectCreationExpression(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfArgumentList(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfAttributeArgumentList(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsUsingDirectiveName(SyntaxNode node);
    public abstract virtual bool IsAttributeName(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxList`1<SyntaxNode> GetAttributeLists(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAttributeNamedArgumentIdentifier(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMemberInitializerNamedAssignmentIdentifier(SyntaxNode node, SyntaxNode& initializedInstance);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnyInitializerExpression(SyntaxNode node, SyntaxNode& creationExpression);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDirective(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsExecutableStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsGlobalStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetStatementOfGlobalStatement(SyntaxNode node);
    public abstract virtual bool AreStatementsInSameContainer(SyntaxNode firstStatement, SyntaxNode secondStatement);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDeconstructionAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDeconstructionForEachStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMethodBody(SyntaxNode node);
    public abstract virtual bool IsDeclaratorOfLocalDeclarationStatement(SyntaxNode declarator, SyntaxNode localDeclarationStatement);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetVariablesOfLocalDeclarationStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetInitializerOfVariableDeclarator(SyntaxNode node);
    public abstract virtual SyntaxNode GetInitializerOfPropertyDeclaration(SyntaxNode node);
    public abstract virtual bool IsThisConstructorInitializer(SyntaxToken token);
    public abstract virtual bool IsBaseConstructorInitializer(SyntaxToken token);
    public abstract virtual bool IsQueryKeyword(SyntaxToken token);
    [NullableContextAttribute("2")]
public abstract virtual bool IsElementAccessExpression(SyntaxNode node);
    public abstract virtual bool IsIdentifierStartCharacter(char c);
    public abstract virtual bool IsIdentifierPartCharacter(char c);
    public abstract virtual bool IsIdentifierEscapeCharacter(char c);
    public abstract virtual bool IsStartOfUnicodeEscapeSequence(char c);
    public abstract virtual bool IsValidIdentifier(string identifier);
    public abstract virtual bool IsVerbatimIdentifier(string identifier);
    public abstract virtual bool IsTypeCharacter(char c);
    public abstract virtual bool IsBindableToken(SyntaxToken token);
    public abstract virtual bool IsInStaticContext(SyntaxNode node);
    public abstract virtual bool IsUnsafeContext(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsInNamespaceOrTypeContext(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsBaseTypeList(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsInConstantContext(SyntaxNode node);
    public abstract virtual bool IsInConstructor(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMethodLevelMember(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsTopLevelNodeWithMembers(SyntaxNode node);
    public abstract virtual bool AreEquivalent(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("2")]
public abstract virtual bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    [NullableContextAttribute("2")]
public abstract virtual string GetDisplayName(SyntaxNode node, DisplayNameOptions options, string rootNamespace);
    public abstract virtual SyntaxNode GetContainingTypeDeclaration(SyntaxNode root, int position);
    public abstract virtual SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    public abstract virtual SyntaxNode GetContainingMethodDeclaration(SyntaxNode root, int position, bool useFullSpan);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetContainingVariableDeclaratorOfFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode ConvertToSingleLine(SyntaxNode node, bool useElasticTrivia);
    public abstract virtual List`1<SyntaxNode> GetTopLevelAndMethodLevelMembers(SyntaxNode root);
    public abstract virtual List`1<SyntaxNode> GetMethodLevelMembers(SyntaxNode root);
    public abstract virtual SyntaxList`1<SyntaxNode> GetMembersOfTypeDeclaration(SyntaxNode typeDeclaration);
    [NullableContextAttribute("2")]
public abstract virtual bool ContainsInMemberBody(SyntaxNode node, TextSpan span);
    public abstract virtual TextSpan GetInactiveRegionSpanAroundPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
    public abstract virtual TextSpan GetMemberBodySpanForSpeculativeBinding(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode TryGetBindableParent(SyntaxToken token);
    public abstract virtual IEnumerable`1<SyntaxNode> GetConstructors(SyntaxNode root, CancellationToken cancellationToken);
    public abstract virtual string GetNameForArgument(SyntaxNode argument);
    public abstract virtual string GetNameForAttributeArgument(SyntaxNode argument);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfSubpattern(SyntaxNode node);
    public abstract virtual bool IsPropertyPatternClause(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnyPattern(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsBinaryPattern(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsUnaryPattern(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfConstantPattern(SyntaxNode node);
    public abstract virtual SyntaxNode GetTypeOfTypePattern(SyntaxNode node);
    public abstract virtual void GetPartsOfParenthesizedPattern(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& pattern, SyntaxToken& closeParen);
    public abstract virtual void GetPartsOfBinaryPattern(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfDeclarationPattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& designation);
    [NullableContextAttribute("2")]
public abstract virtual void GetPartsOfRecursivePattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& positionalPart, SyntaxNode& propertyPart, SyntaxNode& designation);
    public abstract virtual void GetPartsOfRelationalPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& expression);
    public abstract virtual void GetPartsOfUnaryPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& pattern);
    public abstract virtual bool ContainsInterleavedDirective(TextSpan span, SyntaxToken token, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxTokenList GetModifiers(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
    public abstract virtual Location GetDeconstructionReferenceLocation(SyntaxNode node);
    public abstract virtual Nullable`1<SyntaxToken> GetDeclarationIdentifierIfOverride(SyntaxToken token);
    [NullableContextAttribute("2")]
public abstract virtual bool IsParameterNameXmlElementSyntax(SyntaxNode node);
    public abstract virtual SyntaxList`1<SyntaxNode> GetContentFromDocumentationCommentTriviaSyntax(SyntaxTrivia trivia);
    public abstract virtual bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnonymousFunctionExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsBaseNamespaceDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsBinaryExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLiteralExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMethodDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsSimpleName(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnyName(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnyType(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNamedMemberInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsElementAccessInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsObjectMemberInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsObjectCollectionInitializer(SyntaxNode node);
    public abstract virtual void GetPartsOfAnyIsTypeExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& type);
    public abstract virtual void GetPartsOfArgumentList(SyntaxNode node, SyntaxToken& openParenToken, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParenToken);
    public abstract virtual void GetPartsOfBaseNamespaceDeclaration(SyntaxNode node, SyntaxNode& name, SyntaxList`1& imports, SyntaxList`1& members);
    [NullableContextAttribute("2")]
public abstract virtual void GetPartsOfBaseObjectCreationExpression(SyntaxNode node, SyntaxNode& argumentList, SyntaxNode& initializer);
    public abstract virtual void GetPartsOfBinaryExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfCastExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& expression);
    public abstract virtual void GetPartsOfCompilationUnit(SyntaxNode node, SyntaxList`1& imports, SyntaxList`1& attributeLists, SyntaxList`1& members);
    public abstract virtual void GetPartsOfConditionalAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& whenNotNull);
    public abstract virtual void GetPartsOfConditionalExpression(SyntaxNode node, SyntaxNode& condition, SyntaxNode& whenTrue, SyntaxNode& whenFalse);
    public abstract virtual void GetPartsOfGenericName(SyntaxNode node, SyntaxToken& identifier, SeparatedSyntaxList`1& typeArguments);
    public abstract virtual void GetPartsOfInterpolationExpression(SyntaxNode node, SyntaxToken& stringStartToken, SyntaxList`1& contents, SyntaxToken& stringEndToken);
    public abstract virtual void GetPartsOfInvocationExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public abstract virtual void GetPartsOfIsPatternExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& isToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfMemberAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& name);
    public abstract virtual void GetPartsOfNamedMemberInitializer(SyntaxNode node, SyntaxNode& name, SyntaxNode& expression);
    public abstract virtual void GetPartsOfObjectCreationExpression(SyntaxNode node, SyntaxToken& keyword, SyntaxNode& type, SyntaxNode& argumentList, SyntaxNode& initializer);
    public abstract virtual void GetPartsOfImplicitObjectCreationExpression(SyntaxNode node, SyntaxToken& keyword, SyntaxNode& argumentList, SyntaxNode& initializer);
    public abstract virtual void GetPartsOfParameter(SyntaxNode node, SyntaxToken& identifier, SyntaxNode& default);
    public abstract virtual void GetPartsOfParenthesizedExpression(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& expression, SyntaxToken& closeParen);
    public abstract virtual void GetPartsOfPrefixUnaryExpression(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& operand);
    public abstract virtual void GetPartsOfQualifiedName(SyntaxNode node, SyntaxNode& left, SyntaxToken& dotToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfUsingAliasDirective(SyntaxNode node, SyntaxToken& globalKeyword, SyntaxToken& alias, SyntaxNode& name);
    public abstract virtual SyntaxNode GetArgumentListOfImplicitElementAccess(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfAwaitExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfExpressionStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfRefExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfReturnStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfThrowExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfThrowStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsEqualsValueOfPropertyDeclaration(SyntaxNode node);
    public abstract virtual SyntaxNode GetValueOfEqualsValueClause(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetInitializersOfObjectMemberInitializer(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetExpressionsOfObjectCollectionInitializer(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsExtensions : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ObjectPool`1<Stack`1<ValueTuple`3<SyntaxNodeOrToken, bool, bool>>> s_stackPool;
    private static ISyntaxFactsExtensions();
    [ExtensionAttribute]
public static bool IsMemberInitializerNamedAssignmentIdentifier(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsOnSingleLine(ISyntaxFacts syntaxFacts, SyntaxNode node, bool fullSpan);
    private static bool IsOnSingleLine(ISyntaxFacts syntaxFacts, Stack`1<ValueTuple`3<SyntaxNodeOrToken, bool, bool>> stack);
    private static bool IsOnSingleLine(ISyntaxFacts syntaxFacts, SyntaxToken token, bool leading, bool trailing);
    private static bool IsOnSingleLine(ISyntaxFacts syntaxFacts, SyntaxTriviaList triviaList, bool checkTrivia);
    private static bool IsOnSingleLine(string value);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(ISyntaxFacts syntaxFacts, ImmutableArray`1<SyntaxNode> nodes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(ISyntaxFacts syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(ISyntaxFacts syntaxFacts, TextSpan span, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFacts syntaxFacts, IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFacts syntaxFacts, IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
private static bool SpansPreprocessorDirective(ISyntaxFacts syntaxFacts, SyntaxTriviaList list);
    [ExtensionAttribute]
public static bool IsLegalIdentifier(ISyntaxFacts syntaxFacts, string name);
    [ExtensionAttribute]
public static bool IsReservedOrContextualKeyword(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsWord(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsRegularOrDocumentationComment(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode WalkDownParentheses(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode WalkUpParentheses(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static void GetPartsOfAssignmentStatement(ISyntaxFacts syntaxFacts, SyntaxNode statement, SyntaxNode& left, SyntaxNode& right);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode Unparenthesize(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
private static bool IsWordOrNumber(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFacts service, SyntaxNode node);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFacts service, SyntaxNode[] nodes);
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLineTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static void GetPartsOfBinaryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node, SyntaxNode& left, SyntaxNode& right);
    [ExtensionAttribute]
public static SyntaxNode GetPatternOfParenthesizedPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetOperatorTokenOfBinaryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAnonymousOrLocalFunction(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfElementAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetArgumentListOfElementAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfConditionalAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetOperatorTokenOfMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static void GetPartsOfMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node, SyntaxNode& expression, SyntaxNode& name);
    [ExtensionAttribute]
public static void GetPartsOfConditionalAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node, SyntaxNode& expression, SyntaxNode& whenNotNull);
    [ExtensionAttribute]
public static TextSpan GetSpanWithoutAttributes(ISyntaxFacts syntaxFacts, SyntaxNode root, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetRootStandaloneExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetArgumentListOfInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetArgumentListOfBaseObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetDefaultOfParameter(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfParenthesizedExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetIdentifierOfGenericName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetIdentifierOfIdentifierName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetIdentifierOfParameter(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> GetImportsOfBaseNamespaceDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> GetImportsOfCompilationUnit(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetInitializerOfBaseObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> GetMembersOfBaseNamespaceDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> GetMembersOfCompilationUnit(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetNameOfBaseNamespaceDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetNameOfMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetOperandOfPrefixUnaryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetOperatorTokenOfPrefixUnaryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<SyntaxNode> GetTypeArgumentsOfGenericName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetTypeOfObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsExpressionOfAwaitExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsExpressionOfInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsExpressionOfMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRightOfQualifiedName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeOfObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsEndOfLineTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineDocCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsShebangDirectiveTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineDocCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespaceTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSkippedTokensTrivia(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAwaitKeyword(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsGlobalNamespaceKeyword(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCharacterLiteral(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsStringLiteral(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsIdentifier(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsHashToken(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsInterpolatedStringTextToken(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsGenericName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIdentifierName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsQualifiedName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTupleType(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsCharacterLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsDefaultLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsFalseLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNumericLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNullLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsStringLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTrueLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsArrayCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAwaitExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsBaseExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsConditionalExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsConditionalAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsImplicitArrayCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsImplicitObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIndexExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInterpolatedStringExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInterpolation(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInterpolatedStringText(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIsTypeExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIsNotTypeExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIsPatternExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLogicalAndExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLogicalOrExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLogicalNotExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsParenthesizedExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsQueryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRangeExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRefExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsSimpleMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsThisExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsThrowExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTupleExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsGlobalStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAndPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsConstantPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsDeclarationPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsListPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNotPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsOrPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsParenthesizedPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRecursivePattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRelationalPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypePattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsVarPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsExpressionStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsForEachStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsForStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIfStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLocalDeclarationStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLocalFunctionStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLockStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsReturnStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsThrowStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsUsingStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsWhileStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsYieldReturnStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAttribute(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsClassDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsConstructorDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsEnumDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsGlobalAttribute(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInterfaceDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsParameter(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeConstraint(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsVariableDeclarator(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsFieldDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsPropertyDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsStructDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeArgumentList(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsElseClause(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsEqualsValueClause(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsImplicitElementAccess(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIndexerMemberCref(ISyntaxFacts syntaxFacts, SyntaxNode node);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds {
    public int ConflictMarkerTrivia { get; }
    public int DisabledTextTrivia { get; }
    public int EndOfLineTrivia { get; }
    public int SkippedTokensTrivia { get; }
    public int WhitespaceTrivia { get; }
    public int SingleLineCommentTrivia { get; }
    public Nullable`1<int> MultiLineCommentTrivia { get; }
    public int SingleLineDocCommentTrivia { get; }
    public Nullable`1<int> MultiLineDocCommentTrivia { get; }
    public int IfDirectiveTrivia { get; }
    public int ElifDirectiveTrivia { get; }
    public int ElseDirectiveTrivia { get; }
    public int EndIfDirectiveTrivia { get; }
    public int EndRegionDirectiveTrivia { get; }
    public int RegionDirectiveTrivia { get; }
    public Nullable`1<int> ShebangDirectiveTrivia { get; }
    public int AsyncKeyword { get; }
    public int AwaitKeyword { get; }
    public int DelegateKeyword { get; }
    public int FalseKeyword { get; }
    public int GlobalKeyword { get; }
    public Nullable`1<int> GlobalStatement { get; }
    public int IfKeyword { get; }
    public int NewKeyword { get; }
    public int TrueKeyword { get; }
    public int UsingKeyword { get; }
    public int CharacterLiteralToken { get; }
    public int StringLiteralToken { get; }
    public Nullable`1<int> SingleLineRawStringLiteralToken { get; }
    public Nullable`1<int> MultiLineRawStringLiteralToken { get; }
    public Nullable`1<int> Utf8StringLiteralToken { get; }
    public Nullable`1<int> Utf8SingleLineRawStringLiteralToken { get; }
    public Nullable`1<int> Utf8MultiLineRawStringLiteralToken { get; }
    public int CloseBraceToken { get; }
    public Nullable`1<int> CloseBracketToken { get; }
    public int CloseParenToken { get; }
    public int CommaToken { get; }
    public int ColonToken { get; }
    public int DotToken { get; }
    public int EndOfFileToken { get; }
    public int HashToken { get; }
    public int GreaterThanToken { get; }
    public int IdentifierToken { get; }
    public int InterpolatedStringTextToken { get; }
    public int LessThanSlashToken { get; }
    public int LessThanToken { get; }
    public int OpenBraceToken { get; }
    public Nullable`1<int> OpenBracketToken { get; }
    public int OpenParenToken { get; }
    public int QuestionToken { get; }
    public int XmlTextLiteralToken { get; }
    public int GenericName { get; }
    public int IdentifierName { get; }
    public int QualifiedName { get; }
    public int TupleType { get; }
    public int CharacterLiteralExpression { get; }
    public int DefaultLiteralExpression { get; }
    public int FalseLiteralExpression { get; }
    public int NullLiteralExpression { get; }
    public int NumericLiteralExpression { get; }
    public int StringLiteralExpression { get; }
    public int TrueLiteralExpression { get; }
    public int AddExpression { get; }
    public int AddressOfExpression { get; }
    public int AnonymousObjectCreationExpression { get; }
    public int ArrayCreationExpression { get; }
    public int AwaitExpression { get; }
    public int BaseExpression { get; }
    public int CollectionInitializerExpression { get; }
    public int ConditionalAccessExpression { get; }
    public int ConditionalExpression { get; }
    public Nullable`1<int> ImplicitArrayCreationExpression { get; }
    public Nullable`1<int> ImplicitObjectCreationExpression { get; }
    public Nullable`1<int> IndexExpression { get; }
    public int InterpolatedStringExpression { get; }
    public int InvocationExpression { get; }
    public int IsTypeExpression { get; }
    public Nullable`1<int> IsNotTypeExpression { get; }
    public Nullable`1<int> IsPatternExpression { get; }
    public int LogicalAndExpression { get; }
    public int LogicalOrExpression { get; }
    public int LogicalNotExpression { get; }
    public int ObjectCreationExpression { get; }
    public int ParenthesizedExpression { get; }
    public int QueryExpression { get; }
    public Nullable`1<int> RangeExpression { get; }
    public Nullable`1<int> RefExpression { get; }
    public int ReferenceEqualsExpression { get; }
    public int ReferenceNotEqualsExpression { get; }
    public int SimpleMemberAccessExpression { get; }
    public int TernaryConditionalExpression { get; }
    public int ThisExpression { get; }
    public Nullable`1<int> ThrowExpression { get; }
    public int TupleExpression { get; }
    public Nullable`1<int> AndPattern { get; }
    public Nullable`1<int> ConstantPattern { get; }
    public Nullable`1<int> DeclarationPattern { get; }
    public Nullable`1<int> ListPattern { get; }
    public Nullable`1<int> NotPattern { get; }
    public Nullable`1<int> OrPattern { get; }
    public Nullable`1<int> ParenthesizedPattern { get; }
    public Nullable`1<int> RecursivePattern { get; }
    public Nullable`1<int> RelationalPattern { get; }
    public Nullable`1<int> TypePattern { get; }
    public Nullable`1<int> VarPattern { get; }
    public int ExpressionStatement { get; }
    public int ForEachStatement { get; }
    public int ForStatement { get; }
    public int IfStatement { get; }
    public int LocalDeclarationStatement { get; }
    public Nullable`1<int> LocalFunctionStatement { get; }
    public int LockStatement { get; }
    public int ReturnStatement { get; }
    public int ThrowStatement { get; }
    public int UsingStatement { get; }
    public int WhileStatement { get; }
    public int YieldReturnStatement { get; }
    public int Attribute { get; }
    public int ClassDeclaration { get; }
    public int ConstructorDeclaration { get; }
    public int EnumDeclaration { get; }
    public int InterfaceDeclaration { get; }
    public Nullable`1<int> StructDeclaration { get; }
    public int Parameter { get; }
    public int TypeConstraint { get; }
    public int VariableDeclarator { get; }
    public int FieldDeclaration { get; }
    public int PropertyDeclaration { get; }
    public int IncompleteMember { get; }
    public int TypeArgumentList { get; }
    public int ParameterList { get; }
    public int ElseClause { get; }
    public int EqualsValueClause { get; }
    public Nullable`1<int> ImplicitElementAccess { get; }
    public int Interpolation { get; }
    public int InterpolatedStringText { get; }
    public Nullable`1<int> IndexerMemberCref { get; }
    public abstract virtual TSyntaxKind Convert(int kind);
    public abstract virtual int Convert(TSyntaxKind kind);
    public abstract virtual int get_ConflictMarkerTrivia();
    public abstract virtual int get_DisabledTextTrivia();
    public abstract virtual int get_EndOfLineTrivia();
    public abstract virtual int get_SkippedTokensTrivia();
    public abstract virtual int get_WhitespaceTrivia();
    public abstract virtual int get_SingleLineCommentTrivia();
    public abstract virtual Nullable`1<int> get_MultiLineCommentTrivia();
    public abstract virtual int get_SingleLineDocCommentTrivia();
    public abstract virtual Nullable`1<int> get_MultiLineDocCommentTrivia();
    public abstract virtual int get_IfDirectiveTrivia();
    public abstract virtual int get_ElifDirectiveTrivia();
    public abstract virtual int get_ElseDirectiveTrivia();
    public abstract virtual int get_EndIfDirectiveTrivia();
    public abstract virtual int get_EndRegionDirectiveTrivia();
    public abstract virtual int get_RegionDirectiveTrivia();
    public abstract virtual Nullable`1<int> get_ShebangDirectiveTrivia();
    public abstract virtual int get_AsyncKeyword();
    public abstract virtual int get_AwaitKeyword();
    public abstract virtual int get_DelegateKeyword();
    public abstract virtual int get_FalseKeyword();
    public abstract virtual int get_GlobalKeyword();
    public abstract virtual Nullable`1<int> get_GlobalStatement();
    public abstract virtual int get_IfKeyword();
    public abstract virtual int get_NewKeyword();
    public abstract virtual int get_TrueKeyword();
    public abstract virtual int get_UsingKeyword();
    public abstract virtual int get_CharacterLiteralToken();
    public abstract virtual int get_StringLiteralToken();
    public abstract virtual Nullable`1<int> get_SingleLineRawStringLiteralToken();
    public abstract virtual Nullable`1<int> get_MultiLineRawStringLiteralToken();
    public abstract virtual Nullable`1<int> get_Utf8StringLiteralToken();
    public abstract virtual Nullable`1<int> get_Utf8SingleLineRawStringLiteralToken();
    public abstract virtual Nullable`1<int> get_Utf8MultiLineRawStringLiteralToken();
    public abstract virtual int get_CloseBraceToken();
    public abstract virtual Nullable`1<int> get_CloseBracketToken();
    public abstract virtual int get_CloseParenToken();
    public abstract virtual int get_CommaToken();
    public abstract virtual int get_ColonToken();
    public abstract virtual int get_DotToken();
    public abstract virtual int get_EndOfFileToken();
    public abstract virtual int get_HashToken();
    public abstract virtual int get_GreaterThanToken();
    public abstract virtual int get_IdentifierToken();
    public abstract virtual int get_InterpolatedStringTextToken();
    public abstract virtual int get_LessThanSlashToken();
    public abstract virtual int get_LessThanToken();
    public abstract virtual int get_OpenBraceToken();
    public abstract virtual Nullable`1<int> get_OpenBracketToken();
    public abstract virtual int get_OpenParenToken();
    public abstract virtual int get_QuestionToken();
    public abstract virtual int get_XmlTextLiteralToken();
    public abstract virtual int get_GenericName();
    public abstract virtual int get_IdentifierName();
    public abstract virtual int get_QualifiedName();
    public abstract virtual int get_TupleType();
    public abstract virtual int get_CharacterLiteralExpression();
    public abstract virtual int get_DefaultLiteralExpression();
    public abstract virtual int get_FalseLiteralExpression();
    public abstract virtual int get_NullLiteralExpression();
    public abstract virtual int get_NumericLiteralExpression();
    public abstract virtual int get_StringLiteralExpression();
    public abstract virtual int get_TrueLiteralExpression();
    public abstract virtual int get_AddExpression();
    public abstract virtual int get_AddressOfExpression();
    public abstract virtual int get_AnonymousObjectCreationExpression();
    public abstract virtual int get_ArrayCreationExpression();
    public abstract virtual int get_AwaitExpression();
    public abstract virtual int get_BaseExpression();
    public abstract virtual int get_CollectionInitializerExpression();
    public abstract virtual int get_ConditionalAccessExpression();
    public abstract virtual int get_ConditionalExpression();
    public abstract virtual Nullable`1<int> get_ImplicitArrayCreationExpression();
    public abstract virtual Nullable`1<int> get_ImplicitObjectCreationExpression();
    public abstract virtual Nullable`1<int> get_IndexExpression();
    public abstract virtual int get_InterpolatedStringExpression();
    public abstract virtual int get_InvocationExpression();
    public abstract virtual int get_IsTypeExpression();
    public abstract virtual Nullable`1<int> get_IsNotTypeExpression();
    public abstract virtual Nullable`1<int> get_IsPatternExpression();
    public abstract virtual int get_LogicalAndExpression();
    public abstract virtual int get_LogicalOrExpression();
    public abstract virtual int get_LogicalNotExpression();
    public abstract virtual int get_ObjectCreationExpression();
    public abstract virtual int get_ParenthesizedExpression();
    public abstract virtual int get_QueryExpression();
    public abstract virtual Nullable`1<int> get_RangeExpression();
    public abstract virtual Nullable`1<int> get_RefExpression();
    public abstract virtual int get_ReferenceEqualsExpression();
    public abstract virtual int get_ReferenceNotEqualsExpression();
    public abstract virtual int get_SimpleMemberAccessExpression();
    public abstract virtual int get_TernaryConditionalExpression();
    public abstract virtual int get_ThisExpression();
    public abstract virtual Nullable`1<int> get_ThrowExpression();
    public abstract virtual int get_TupleExpression();
    public abstract virtual Nullable`1<int> get_AndPattern();
    public abstract virtual Nullable`1<int> get_ConstantPattern();
    public abstract virtual Nullable`1<int> get_DeclarationPattern();
    public abstract virtual Nullable`1<int> get_ListPattern();
    public abstract virtual Nullable`1<int> get_NotPattern();
    public abstract virtual Nullable`1<int> get_OrPattern();
    public abstract virtual Nullable`1<int> get_ParenthesizedPattern();
    public abstract virtual Nullable`1<int> get_RecursivePattern();
    public abstract virtual Nullable`1<int> get_RelationalPattern();
    public abstract virtual Nullable`1<int> get_TypePattern();
    public abstract virtual Nullable`1<int> get_VarPattern();
    public abstract virtual int get_ExpressionStatement();
    public abstract virtual int get_ForEachStatement();
    public abstract virtual int get_ForStatement();
    public abstract virtual int get_IfStatement();
    public abstract virtual int get_LocalDeclarationStatement();
    public abstract virtual Nullable`1<int> get_LocalFunctionStatement();
    public abstract virtual int get_LockStatement();
    public abstract virtual int get_ReturnStatement();
    public abstract virtual int get_ThrowStatement();
    public abstract virtual int get_UsingStatement();
    public abstract virtual int get_WhileStatement();
    public abstract virtual int get_YieldReturnStatement();
    public abstract virtual int get_Attribute();
    public abstract virtual int get_ClassDeclaration();
    public abstract virtual int get_ConstructorDeclaration();
    public abstract virtual int get_EnumDeclaration();
    public abstract virtual int get_InterfaceDeclaration();
    public abstract virtual Nullable`1<int> get_StructDeclaration();
    public abstract virtual int get_Parameter();
    public abstract virtual int get_TypeConstraint();
    public abstract virtual int get_VariableDeclarator();
    public abstract virtual int get_FieldDeclaration();
    public abstract virtual int get_PropertyDeclaration();
    public abstract virtual int get_IncompleteMember();
    public abstract virtual int get_TypeArgumentList();
    public abstract virtual int get_ParameterList();
    public abstract virtual int get_ElseClause();
    public abstract virtual int get_EqualsValueClause();
    public abstract virtual Nullable`1<int> get_ImplicitElementAccess();
    public abstract virtual int get_Interpolation();
    public abstract virtual int get_InterpolatedStringText();
    public abstract virtual Nullable`1<int> get_IndexerMemberCref();
}
internal enum Microsoft.CodeAnalysis.LanguageService.PredefinedOperator : Enum {
    public int value__;
    public static PredefinedOperator None;
    public static PredefinedOperator Addition;
    public static PredefinedOperator BitwiseAnd;
    public static PredefinedOperator BitwiseOr;
    public static PredefinedOperator Complement;
    public static PredefinedOperator Concatenate;
    public static PredefinedOperator Decrement;
    public static PredefinedOperator Division;
    public static PredefinedOperator Equality;
    public static PredefinedOperator ExclusiveOr;
    public static PredefinedOperator Exponent;
    public static PredefinedOperator GreaterThan;
    public static PredefinedOperator GreaterThanOrEqual;
    public static PredefinedOperator Increment;
    public static PredefinedOperator Inequality;
    public static PredefinedOperator IntegerDivision;
    public static PredefinedOperator LeftShift;
    public static PredefinedOperator LessThan;
    public static PredefinedOperator LessThanOrEqual;
    public static PredefinedOperator Like;
    public static PredefinedOperator Modulus;
    public static PredefinedOperator Multiplication;
    public static PredefinedOperator RightShift;
    public static PredefinedOperator Subtraction;
    public static PredefinedOperator UnsignedRightShift;
}
internal enum Microsoft.CodeAnalysis.LanguageService.PredefinedType : Enum {
    public int value__;
    public static PredefinedType None;
    public static PredefinedType Boolean;
    public static PredefinedType Byte;
    public static PredefinedType Char;
    public static PredefinedType DateTime;
    public static PredefinedType Decimal;
    public static PredefinedType Double;
    public static PredefinedType Int16;
    public static PredefinedType Int32;
    public static PredefinedType Int64;
    public static PredefinedType Object;
    public static PredefinedType SByte;
    public static PredefinedType Single;
    public static PredefinedType String;
    public static PredefinedType UInt16;
    public static PredefinedType UInt32;
    public static PredefinedType UInt64;
    public static PredefinedType Void;
    public static PredefinedType IntPtr;
    public static PredefinedType UIntPtr;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ISyntaxKinds SyntaxKinds { get; }
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    protected abstract virtual ISyntaxKinds get_SyntaxKinds();
    protected abstract virtual bool IsWrittenTo(SemanticModel semanticModel, TThisExpression expression, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    protected virtual void InitializeWorker(AnalysisContext context);
    private static Location GetDiagnosticLocation(IFieldSymbol field);
    private static bool IsFieldWrite(IFieldReferenceOperation fieldReference, ISymbol owningSymbol);
    private static CodeStyleOption2`1<bool> GetCodeStyleOption(IFieldSymbol field, AnalyzerOptions options, Location& diagnosticLocation);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(CompilationStartAnalysisContext context);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <InitializeWorker>g__IsCandidateField|7_6(IFieldSymbol symbol, INamedTypeSymbol threadStaticAttribute, INamedTypeSymbol dataContractAttribute, INamedTypeSymbol dataMemberAttribute);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <InitializeWorker>g__IsDataContractSerializable|7_7(IFieldSymbol symbol, INamedTypeSymbol dataContractAttribute, INamedTypeSymbol dataMemberAttribute);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.NamingStyles.NamingStyle : ValueType {
    [CompilerGeneratedAttribute]
private Guid <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WordSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private Capitalization <CapitalizationScheme>k__BackingField;
    private static Func`3<string, TextSpan, bool> s_firstCharIsLowerCase;
    private static Func`3<string, TextSpan, bool> s_firstCharIsUpperCase;
    private static Func`3<string, TextSpan, bool> s_wordIsAllUpperCase;
    private static Func`3<string, TextSpan, bool> s_wordIsAllLowerCase;
    [DataMemberAttribute]
public Guid ID { get; public set; }
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public string Prefix { get; public set; }
    [DataMemberAttribute]
public string Suffix { get; public set; }
    [DataMemberAttribute]
public string WordSeparator { get; public set; }
    [DataMemberAttribute]
public Capitalization CapitalizationScheme { get; public set; }
    public NamingStyle(Guid id, string name, string prefix, string suffix, string wordSeparator, Capitalization capitalizationScheme);
    private static NamingStyle();
    [CompilerGeneratedAttribute]
public Guid get_ID();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ID(Guid value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Suffix(string value);
    [CompilerGeneratedAttribute]
public string get_WordSeparator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WordSeparator(string value);
    [CompilerGeneratedAttribute]
public Capitalization get_CapitalizationScheme();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CapitalizationScheme(Capitalization value);
    public string CreateName(ImmutableArray`1<string> words);
    private IEnumerable`1<string> ApplyCapitalization(IEnumerable`1<string> words);
    private string CapitalizeFirstLetter(string word);
    private string DecapitalizeFirstLetter(string word);
    public bool IsNameCompliant(string name, String& failureReason);
    private WordSpanEnumerable GetWordSpans(string name, TextSpan nameSpan);
    private static string Substring(string name, TextSpan wordSpan);
    private bool CheckAllWords(string name, TextSpan nameSpan, Func`3<string, TextSpan, bool> wordCheck, string resourceId, String& reason);
    private bool CheckPascalCase(string name, TextSpan nameSpan, String& reason);
    private bool CheckAllUpper(string name, TextSpan nameSpan, String& reason);
    private bool CheckAllLower(string name, TextSpan nameSpan, String& reason);
    private bool CheckFirstAndRestWords(string name, TextSpan nameSpan, Func`3<string, TextSpan, bool> firstWordCheck, Func`3<string, TextSpan, bool> restWordCheck, string firstResourceId, string restResourceId, String& reason);
    private bool CheckCamelCase(string name, TextSpan nameSpan, String& reason);
    private bool CheckFirstUpper(string name, TextSpan nameSpan, String& reason);
    private static bool DoesCharacterHaveCasing(char c);
    private string CreateCompliantNameDirectly(string name);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.NamingStyles.NamingStyle/<MakeCompliant>d__45")]
public IEnumerable`1<string> MakeCompliant(string name);
    private string CreateCompliantNameReusingPartialPrefixesAndSuffixes(string name);
    public static string StripCommonPrefixes(string name, String& prefix);
    private string FinishFixingName(string name);
    private string EnsureSuffix(string name);
    private string EnsurePrefix(string name);
    internal XElement CreateXElement();
    internal static NamingStyle FromXElement(XElement namingStyleElement);
    public void WriteTo(ObjectWriter writer);
    public static NamingStyle ReadFrom(ObjectReader reader);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NamingStyle left, NamingStyle right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NamingStyle left, NamingStyle right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NamingStyle other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.NewLines.ConsecutiveStatementPlacement.AbstractConsecutiveStatementPlacementDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxFacts _syntaxFacts;
    protected AbstractConsecutiveStatementPlacementDiagnosticAnalyzer`1(ISyntaxFacts syntaxFacts);
    protected abstract virtual bool IsBlockLikeStatement(SyntaxNode node);
    protected abstract virtual Location GetDiagnosticLocation(SyntaxNode block);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node, CancellationToken cancellationToken);
    private void ProcessBlockLikeStatement(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode block);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__5_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.NewLines.MultipleBlankLines.AbstractMultipleBlankLinesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxFacts _syntaxFacts;
    protected AbstractMultipleBlankLinesDiagnosticAnalyzer(ISyntaxFacts syntaxFacts);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node, CancellationToken cancellationToken);
    private void CheckToken(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxToken token);
    private bool ContainsMultipleBlankLines(SyntaxToken token, SyntaxTrivia& firstBadTrivia);
    private bool IsEndOfLine(SyntaxTriviaList triviaList, int index);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.OperationExtensions : object {
    [ExtensionAttribute]
public static bool IsTargetOfObjectMemberInitializer(IOperation operation);
    [ExtensionAttribute]
public static ValueUsageInfo GetValueUsageInfo(IOperation operation, ISymbol containingSymbol);
    [ExtensionAttribute]
public static RefKind GetRefKind(IReturnOperation operation, ISymbol containingSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IMethodSymbol TryGetContainingAnonymousFunctionOrLocalFunction(IOperation operation);
    [ExtensionAttribute]
public static bool IsInLeftOfDeconstructionAssignment(IOperation operation, IDeconstructionAssignmentOperation& deconstructionAssignment);
    [ExtensionAttribute]
public static bool IsAnyCompoundAssignment(IOperation operation);
    [ExtensionAttribute]
public static bool IsInsideCatchRegion(IOperation operation, ControlFlowGraph cfg);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate, IOperation& foundOperation);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, OperationKind kind);
    [ExtensionAttribute]
public static bool IsNumericLiteral(IOperation operation);
    [ExtensionAttribute]
public static bool IsNullLiteral(IOperation operand);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IOperation WalkDownConversion(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSingleThrowNotImplementedOperation(IOperation firstBlock);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IOperation UnwrapImplicitConversion(IOperation value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static IOperation <IsSingleThrowNotImplementedOperation>g__TryGetSingleExplicitStatement|14_0(ImmutableArray`1<IOperation> operations);
    [CompilerGeneratedAttribute]
internal static bool <IsSingleThrowNotImplementedOperation>g__IsThrowNotImplementedOperation|14_1(INamedTypeSymbol notImplementedExceptionType, IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.AnalyzerConfigOptionsReader : object {
    public AnalyzerConfigOptions Options;
    public AnalyzerConfigOptionsReader(AnalyzerConfigOptions options);
    public sealed virtual bool TryGetOption(OptionKey2 optionKey, T& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Options.EditorConfigFileGenerator : object {
    public static void AppendNamingStylePreferencesToEditorConfig(IEnumerable`1<NamingRule> namingRules, StringBuilder editorconfig, string language);
    public static void AppendNamingStylePreferencesToEditorConfig(NamingStylePreferences namingStylePreferences, string language, StringBuilder editorconfig);
    public static void AppendNamingStylePreferencesToEditorConfig(ImmutableArray`1<SymbolSpecification> symbolSpecifications, ImmutableArray`1<NamingStyle> namingStyles, ImmutableArray`1<SerializableNamingRule> serializableNamingRules, string language, StringBuilder editorconfig);
    [NullableContextAttribute("0")]
private static ImmutableDictionary`2<Guid, string> AssignNamesToNamingStyleElements(ImmutableArray`1<SymbolSpecification> symbolSpecifications, ImmutableArray`1<NamingStyle> namingStyles);
    private static ImmutableDictionary`2<SerializableNamingRule, string> AssignNamesToNamingStyleRules(ImmutableArray`1<SerializableNamingRule> namingRules, ImmutableDictionary`2<Guid, string> serializedNameMap);
    [CompilerGeneratedAttribute]
internal static string <AssignNamesToNamingStyleElements>g__ToSnakeCaseName|3_0(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Options.EditorConfigValueSerializer : object {
    private static EditorConfigValueSerializer`1<bool> s_bool;
    private static EditorConfigValueSerializer`1<int> s_int32;
    private static EditorConfigValueSerializer`1<string> s_string;
    private static EditorConfigValueSerializer`1<Nullable`1<bool>> s_nullableBoolean;
    private static EditorConfigValueSerializer();
    private static string EscapeLineBreaks(string str);
    private static string UnescapeLineBreaks(string str);
    [NullableContextAttribute("0")]
private static Optional`1<bool> ParseBoolean(string str);
    private static string SerializeBoolean(bool value);
    [NullableContextAttribute("0")]
private static Optional`1<Nullable`1<bool>> ParseNullableBoolean(string str);
    public static EditorConfigValueSerializer`1<T> Default();
    public static EditorConfigValueSerializer`1<string> String(string emptyStringRepresentation);
    public static EditorConfigValueSerializer`1<CodeStyleOption2`1<T>> CodeStyle(CodeStyleOption2`1<T> defaultValue);
    public static EditorConfigValueSerializer`1<CodeStyleOption2`1<bool>> CodeStyle(CodeStyleOption2`1<bool> defaultValue);
    public static EditorConfigValueSerializer`1<CodeStyleOption2`1<string>> CodeStyle(CodeStyleOption2`1<string> defaultValue);
    [NullableContextAttribute("0")]
public static EditorConfigValueSerializer`1<T> CreateSerializerForEnum();
    [NullableContextAttribute("0")]
public static EditorConfigValueSerializer`1<Nullable`1<T>> CreateSerializerForNullableEnum();
    [NullableContextAttribute("0")]
private static bool TryParseEnum(string str, T& result);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Optional`1<Nullable`1<T>> <CreateSerializerForNullableEnum>g__ParseValueForNullableEnum|15_1(string str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.EditorConfigValueSerializer`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, Optional`1<T>> <parseValue>P;
    [CompilerGeneratedAttribute]
private Func`2<T, string> <serializeValue>P;
    public static EditorConfigValueSerializer`1<T> Unsupported;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, Optional`1<T>> _cachedValues;
    public EditorConfigValueSerializer`1(Func`2<string, Optional`1<T>> parseValue, Func`2<T, string> serializeValue);
    private static EditorConfigValueSerializer`1();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IEditorConfigValueSerializer.TryParse(string value, Object& result);
    internal bool TryParseValue(string value, T& result);
    public string GetEditorConfigStringValue(T value);
    private sealed virtual override string Microsoft.CodeAnalysis.Options.IEditorConfigValueSerializer.Serialize(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Options.Extensions : object {
    [ExtensionAttribute]
public static IOptionsReader GetOptionsReader(AnalyzerConfigOptions configOptions);
    [ExtensionAttribute]
public static T GetOption(IOptionsReader options, Option2`1<T> option);
    [ExtensionAttribute]
public static T GetOption(IOptionsReader options, Option2`1<T> option, T defaultValue);
    [ExtensionAttribute]
public static T GetOption(IOptionsReader options, PerLanguageOption2`1<T> option, string language);
    [ExtensionAttribute]
public static T GetOption(IOptionsReader options, PerLanguageOption2`1<T> option, string language, T defaultValue);
    [ExtensionAttribute]
public static T GetOptionValue(IOptionsReader options, Option2`1<CodeStyleOption2`1<T>> option, T defaultValue);
    [ExtensionAttribute]
public static T GetOptionValue(IOptionsReader options, PerLanguageOption2`1<CodeStyleOption2`1<T>> option, string language, T defaultValue);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Options.IEditorConfigValueSerializer {
    public abstract virtual bool TryParse(string value, Object& result);
    public abstract virtual string Serialize(object value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Options.IOption2 {
    public OptionDefinition Definition { get; }
    [NullableAttribute("2")]
public IPublicOption PublicOption { get; }
    public bool IsPerLanguage { get; }
    public abstract virtual OptionDefinition get_Definition();
    [NullableContextAttribute("2")]
public abstract virtual IPublicOption get_PublicOption();
    public abstract virtual bool get_IsPerLanguage();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Options.IOptionsReader {
    public abstract virtual bool TryGetOption(OptionKey2 optionKey, T& value);
}
internal interface Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption {
}
internal interface Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption`1 {
}
internal interface Microsoft.CodeAnalysis.Options.IPublicOption {
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.Options.ISingleValuedOption {
    public string LanguageName { get; }
    public abstract virtual string get_LanguageName();
}
internal interface Microsoft.CodeAnalysis.Options.ISingleValuedOption`1 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.Option2`1 : object {
    [CompilerGeneratedAttribute]
private OptionDefinition`1<T> <Definition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IPublicOption <PublicOption>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LanguageName>k__BackingField;
    public OptionDefinition`1<T> Definition { get; }
    [NullableAttribute("2")]
public IPublicOption PublicOption { get; }
    [NullableAttribute("2")]
public string LanguageName { get; }
    public T DefaultValue { get; }
    private OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.Definition { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption2.IsPerLanguage { get; }
    internal Option2`1(OptionDefinition`1<T> definition, string languageName, Func`2<IOption2, IPublicOption> publicOptionFactory);
    public Option2`1(string name, T defaultValue, OptionGroup group, string languageName, bool isEditorConfigOption, EditorConfigValueSerializer`1<T> serializer);
    [CompilerGeneratedAttribute]
public OptionDefinition`1<T> get_Definition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IPublicOption get_PublicOption();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_LanguageName();
    [ConditionalAttribute("DEBUG")]
private void VerifyNamingConvention();
    public T get_DefaultValue();
    private sealed virtual override OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.get_Definition();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption2.get_IsPerLanguage();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IOption2 other);
    public static OptionKey2 op_Implicit(Option2`1<T> option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Options.OptionDefinition : object {
    public static string CSharpConfigNamePrefix;
    public static string VisualBasicConfigNamePrefix;
    public static string LanguageAgnosticConfigNamePrefix;
    public static string InternalConfigNamePrefix;
    [CompilerGeneratedAttribute]
private OptionGroup <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEditorConfigOption>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OptionStorageMapping <StorageMapping>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    internal OptionGroup Group { get; }
    public string ConfigName { get; }
    public bool IsEditorConfigOption { get; }
    [NullableAttribute("2")]
public OptionStorageMapping StorageMapping { get; }
    [NullableAttribute("2")]
public object DefaultValue { get; }
    public Type Type { get; }
    public IEditorConfigValueSerializer Serializer { get; }
    protected IEditorConfigValueSerializer SerializerImpl { get; }
    [NullableContextAttribute("2")]
public OptionDefinition(OptionGroup group, string configName, object defaultValue, OptionStorageMapping storageMapping, bool isEditorConfigOption);
    [CompilerGeneratedAttribute]
internal OptionGroup get_Group();
    [CompilerGeneratedAttribute]
public string get_ConfigName();
    [CompilerGeneratedAttribute]
public bool get_IsEditorConfigOption();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public OptionStorageMapping get_StorageMapping();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_DefaultValue();
    public abstract virtual Type get_Type();
    public IEditorConfigValueSerializer get_Serializer();
    protected abstract virtual IEditorConfigValueSerializer get_SerializerImpl();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(OptionDefinition other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool op_Equality(OptionDefinition left, OptionDefinition right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(OptionDefinition left, OptionDefinition right);
    public static bool IsSupportedOptionType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.OptionDefinition`1 : OptionDefinition {
    [CompilerGeneratedAttribute]
private T <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private EditorConfigValueSerializer`1<T> <Serializer>k__BackingField;
    public T DefaultValue { get; }
    public EditorConfigValueSerializer`1<T> Serializer { get; }
    public Type Type { get; }
    protected IEditorConfigValueSerializer SerializerImpl { get; }
    public OptionDefinition`1(T defaultValue, EditorConfigValueSerializer`1<T> serializer, OptionGroup group, string configName, OptionStorageMapping storageMapping, bool isEditorConfigOption);
    [CompilerGeneratedAttribute]
public T get_DefaultValue();
    [CompilerGeneratedAttribute]
public EditorConfigValueSerializer`1<T> get_Serializer();
    public virtual Type get_Type();
    protected virtual IEditorConfigValueSerializer get_SerializerImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.OptionGroup : object {
    public static OptionGroup Default;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OptionGroup <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [NullableAttribute("2")]
public OptionGroup Parent { get; }
    public string Description { get; }
    public string Name { get; }
    public int Priority { get; }
    public OptionGroup(string name, string description, int priority, OptionGroup parent);
    private static OptionGroup();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public OptionGroup get_Parent();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_Priority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Options.OptionKey2 : ValueType {
    [CompilerGeneratedAttribute]
private IOption2 <Option>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public IOption2 Option { get; }
    [NullableAttribute("2")]
public string Language { get; }
    public OptionKey2(IOption2 option, string language);
    public OptionKey2(IPerLanguageValuedOption option, string language);
    public OptionKey2(ISingleValuedOption option);
    [CompilerGeneratedAttribute]
public IOption2 get_Option();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Language();
    public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(OptionKey2 left, OptionKey2 right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(OptionKey2 left, OptionKey2 right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OptionKey2 other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Options.OptionStorageMapping : object {
    [CompilerGeneratedAttribute]
private IOption2 <InternalOption>k__BackingField;
    public IOption2 InternalOption { get; }
    protected OptionStorageMapping(IOption2 internalOption);
    [CompilerGeneratedAttribute]
public IOption2 get_InternalOption();
    [NullableContextAttribute("2")]
public abstract virtual object ToPublicOptionValue(object internalValue);
    [NullableContextAttribute("2")]
public abstract virtual object UpdateInternalOptionValue(object currentInternalValue, object newPublicValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.PerLanguageOption2`1 : object {
    [CompilerGeneratedAttribute]
private OptionDefinition`1<T> <Definition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IPublicOption <PublicOption>k__BackingField;
    public OptionDefinition`1<T> Definition { get; }
    [NullableAttribute("2")]
public IPublicOption PublicOption { get; }
    private OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.Definition { get; }
    public T DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption2.IsPerLanguage { get; }
    internal PerLanguageOption2`1(OptionDefinition`1<T> optionDefinition, Func`2<IOption2, IPublicOption> publicOptionFactory);
    public PerLanguageOption2`1(string name, T defaultValue, OptionGroup group, bool isEditorConfigOption, EditorConfigValueSerializer`1<T> serializer);
    [CompilerGeneratedAttribute]
public OptionDefinition`1<T> get_Definition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IPublicOption get_PublicOption();
    [ConditionalAttribute("DEBUG")]
private void VerifyNamingConvention();
    private sealed virtual override OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.get_Definition();
    public T get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption2.get_IsPerLanguage();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IOption2 other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Options.PublicOptionFactory : object {
    [ExtensionAttribute]
public static Option2`1<T> WithPublicOption(Option2`1<T> option, string feature, string name, Func`2<T, TPublicValue> toPublicValue, Func`2<TPublicValue, T> toInternalValue);
    [ExtensionAttribute]
public static PerLanguageOption2`1<T> WithPublicOption(PerLanguageOption2`1<T> option, string feature, string name, Func`2<T, TPublicValue> toPublicValue, Func`2<TPublicValue, T> toInternalValue);
    [ExtensionAttribute]
public static Option2`1<T> WithPublicOption(Option2`1<T> option, string feature, string name);
    [ExtensionAttribute]
public static Option2`1<CodeStyleOption2`1<T>> WithPublicOption(Option2`1<CodeStyleOption2`1<T>> option, string feature, string name);
    [ExtensionAttribute]
public static PerLanguageOption2`1<T> WithPublicOption(PerLanguageOption2`1<T> option, string feature, string name);
    [ExtensionAttribute]
public static PerLanguageOption2`1<CodeStyleOption2`1<T>> WithPublicOption(PerLanguageOption2`1<CodeStyleOption2`1<T>> option, string feature, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxFacts _syntaxFacts;
    private AbstractOrderModifiersHelpers _helpers;
    protected AbstractOrderModifiersDiagnosticAnalyzer(ISyntaxFacts syntaxFacts, Option2`1<CodeStyleOption2`1<string>> option, AbstractOrderModifiersHelpers helpers);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual CodeStyleOption2`1<string> GetPreferredOrderStyle(SyntaxTreeAnalysisContext context);
    private void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    protected abstract virtual void Recurse(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, NotificationOption2 notificationOption, SyntaxNode root);
    protected void CheckModifiers(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, NotificationOption2 notificationOption, SyntaxNode memberDeclaration);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersHelpers : object {
    private static Char[] s_comma;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Tuple`2<string, Dictionary`2<int, int>> _lastParsed;
    private static AbstractOrderModifiersHelpers();
    protected abstract virtual int GetKeywordKind(string trimmed);
    public static bool IsOrdered(Dictionary`2<int, int> preferredOrder, SyntaxTokenList modifiers);
    public bool TryGetOrComputePreferredOrder(string value, Dictionary`2& preferredOrder);
    protected virtual bool TryParse(string value, Dictionary`2& parsed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObject`1 : ValueType {
    private Action`2<ObjectPool`1<T>, T> _releaser;
    private ObjectPool`1<T> _pool;
    private T _pooledObject;
    public T Object { get; }
    public PooledObject`1(ObjectPool`1<T> pool, Func`2<ObjectPool`1<T>, T> allocator, Action`2<ObjectPool`1<T>, T> releaser);
    [IsReadOnlyAttribute]
public T get_Object();
    public sealed virtual void Dispose();
    public static PooledObject`1<StringBuilder> Create(ObjectPool`1<StringBuilder> pool);
    public static PooledObject`1<Stack`1<TItem>> Create(ObjectPool`1<Stack`1<TItem>> pool);
    public static PooledObject`1<Queue`1<TItem>> Create(ObjectPool`1<Queue`1<TItem>> pool);
    public static PooledObject`1<HashSet`1<TItem>> Create(ObjectPool`1<HashSet`1<TItem>> pool);
    public static PooledObject`1<Dictionary`2<TKey, TValue>> Create(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    public static PooledObject`1<List`1<TItem>> Create(ObjectPool`1<List`1<TItem>> pool);
    public static PooledObject`1<SegmentedList`1<TItem>> Create(ObjectPool`1<SegmentedList`1<TItem>> pool);
    private static StringBuilder Allocator(ObjectPool`1<StringBuilder> pool);
    private static void Releaser(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    private static Stack`1<TItem> Allocator(ObjectPool`1<Stack`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Stack`1<TItem>> pool, Stack`1<TItem> obj);
    private static Queue`1<TItem> Allocator(ObjectPool`1<Queue`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Queue`1<TItem>> pool, Queue`1<TItem> obj);
    private static HashSet`1<TItem> Allocator(ObjectPool`1<HashSet`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1<TItem> obj);
    private static Dictionary`2<TKey, TValue> Allocator(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    private static void Releaser(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> obj);
    private static List`1<TItem> Allocator(ObjectPool`1<List`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<List`1<TItem>> pool, List`1<TItem> obj);
    private static SegmentedList`1<TItem> Allocator(ObjectPool`1<SegmentedList`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<SegmentedList`1<TItem>> pool, SegmentedList`1<TItem> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1 : object {
    public static int PooledArrayLengthLimitExclusive;
    private Builder<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public int Capacity { get; public set; }
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsEmpty { get; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public ImmutableArray`1<T> ToImmutableAndClear();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsEmpty();
    public void SetItem(int index, T value);
    public sealed virtual void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public int FindIndex(Func`3<T, TArg, bool> match, TArg arg);
    public int FindIndex(int startIndex, Func`3<T, TArg, bool> match, TArg arg);
    public int FindIndex(int startIndex, int count, Func`3<T, TArg, bool> match, TArg arg);
    public sealed virtual bool Remove(T element);
    public void RemoveAt(int index);
    public void RemoveRange(int index, int length);
    public void RemoveLast();
    public void RemoveAll(Predicate`1<T> match);
    public void RemoveAll(Func`3<T, TArg, bool> match, TArg arg);
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public sealed virtual void CopyTo(T[] array, int start);
    public T Last();
    [NullableContextAttribute("2")]
internal T LastOrDefault();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutable();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutableAndFree();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public sealed virtual void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items, Func`2<U, T> selector);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ArrayBuilder`1<U> items, int start, int length);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<T> items, int start, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public void SortAndRemoveDuplicates(IComparer`1<T> comparer);
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
    public static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(ArrayBuilder`1& instance);
    public static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(int capacity, ArrayBuilder`1& instance);
    public static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(int capacity, T fillWithValue, ArrayBuilder`1& instance);
}
internal interface Microsoft.CodeAnalysis.PooledObjects.IPooled {
    public abstract virtual void Free();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1 : object {
    [NullableAttribute("2")]
private T _firstItem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Element[] _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Factory<T> _factory;
    public bool TrimOnFree;
    internal ObjectPool`1(Factory<T> factory, bool trimOnFree);
    internal ObjectPool`1(Factory<T> factory, int size, bool trimOnFree);
    internal ObjectPool`1(Func`2<ObjectPool`1<T>, T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PooledObjects.PooledDelegates : object {
    private static Releaser GetPooledDelegate(TUnboundDelegate unboundDelegate, TArg argument, TBoundDelegate& boundDelegate);
    public static Releaser GetPooledAction(Action`1<TArg> unboundAction, TArg argument, Action& boundAction);
    public static Releaser GetPooledAction(Action`2<T1, TArg> unboundAction, TArg argument, Action`1& boundAction);
    public static Releaser GetPooledAction(Action`3<T1, T2, TArg> unboundAction, TArg argument, Action`2& boundAction);
    [NullableContextAttribute("2")]
public static Releaser GetPooledAction(Action`4<T1, T2, T3, TArg> unboundAction, TArg argument, Action`3& boundAction);
    public static Releaser GetPooledFunction(Func`2<TArg, TResult> unboundFunction, TArg argument, Func`1& boundFunction);
    public static Releaser GetPooledCreateValueCallback(Func`3<TKey, TArg, TValue> unboundFunction, TArg argument, CreateValueCallback& boundFunction);
    public static Releaser GetPooledFunction(Func`3<T1, TArg, TResult> unboundFunction, TArg argument, Func`2& boundFunction);
    [NullableContextAttribute("2")]
public static Releaser GetPooledFunction(Func`4<T1, T2, TArg, TResult> unboundFunction, TArg argument, Func`3& boundFunction);
    [NullableContextAttribute("2")]
public static Releaser GetPooledFunction(Func`5<T1, T2, T3, TArg, TResult> unboundFunction, TArg argument, Func`4& boundFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledDictionary`2();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public ImmutableDictionary`2<K, V> ToImmutableDictionary();
    public sealed virtual void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance();
    public static PooledDisposer`1<PooledDictionary`2<K, V>> GetInstance(PooledDictionary`2& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledDisposer`1 : ValueType {
    [CompilerGeneratedAttribute]
private TPoolable <instance>P;
    public PooledDisposer`1(TPoolable instance);
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool, IEqualityComparer`1<T> equalityComparer);
    private static PooledHashSet`1();
    public sealed virtual void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool(IEqualityComparer`1<T> equalityComparer);
    public static PooledHashSet`1<T> GetInstance();
    public static PooledDisposer`1<PooledHashSet`1<T>> GetInstance(PooledHashSet`1& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public sealed virtual void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool(int size);
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
    public static PooledDisposer`1<PooledStringBuilder> GetInstance(StringBuilder& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    protected OperationKind OperationKind { get; }
    protected AbstractPopulateSwitchDiagnosticAnalyzer`2(string diagnosticId, EnforceOnBuild enforceOnBuild);
    private static AbstractPopulateSwitchDiagnosticAnalyzer`2();
    protected abstract virtual OperationKind get_OperationKind();
    protected abstract virtual bool IsSwitchTypeUnknown(TSwitchOperation operation);
    protected abstract virtual IOperation GetValueOfSwitchOperation(TSwitchOperation operation);
    protected abstract virtual bool HasConstantCase(TSwitchOperation operation, object value);
    protected abstract virtual ICollection`1<ISymbol> GetMissingEnumMembers(TSwitchOperation operation);
    protected abstract virtual bool HasDefaultCase(TSwitchOperation operation);
    protected abstract virtual bool HasExhaustiveNullAndTypeCheckCases(TSwitchOperation operation);
    protected abstract virtual Location GetDiagnosticLocation(TSwitchSyntax switchBlock);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
    private ValueTuple`2<bool, bool> AnalyzeSwitch(TSwitchOperation switchOperation, ITypeSymbol type);
    private ValueTuple`2<bool, bool> AnalyzeBooleanSwitch(TSwitchOperation operation, ITypeSymbol type);
    private ValueTuple`2<bool, bool> AnalyzeEnumSwitch(TSwitchOperation operation, ITypeSymbol type);
    [NullableContextAttribute("2")]
protected static bool ConstantValueEquals(Optional`1<object> constantValue, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchExpressionDiagnosticAnalyzer`1 : AbstractPopulateSwitchDiagnosticAnalyzer`2<ISwitchExpressionOperation, TSwitchSyntax> {
    protected OperationKind OperationKind { get; }
    protected sealed virtual OperationKind get_OperationKind();
    protected virtual IOperation GetValueOfSwitchOperation(ISwitchExpressionOperation operation);
    protected virtual bool IsSwitchTypeUnknown(ISwitchExpressionOperation operation);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation operation);
    protected sealed virtual bool HasDefaultCase(ISwitchExpressionOperation operation);
    protected virtual bool HasExhaustiveNullAndTypeCheckCases(ISwitchExpressionOperation operation);
    protected virtual bool HasConstantCase(ISwitchExpressionOperation operation, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchStatementDiagnosticAnalyzer`1 : AbstractPopulateSwitchDiagnosticAnalyzer`2<ISwitchOperation, TSwitchSyntax> {
    protected OperationKind OperationKind { get; }
    protected sealed virtual OperationKind get_OperationKind();
    protected virtual IOperation GetValueOfSwitchOperation(ISwitchOperation operation);
    protected sealed virtual bool IsSwitchTypeUnknown(ISwitchOperation operation);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation operation);
    protected sealed virtual bool HasDefaultCase(ISwitchOperation operation);
    protected virtual bool HasExhaustiveNullAndTypeCheckCases(ISwitchOperation operation);
    protected sealed virtual Location GetDiagnosticLocation(TSwitchSyntax switchBlock);
    protected virtual bool HasConstantCase(ISwitchOperation operation, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PopulateSwitch.PopulateSwitchExpressionHelpers : object {
    public static ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation operation);
    public static bool HasNullSwitchArm(ISwitchExpressionOperation operation);
    private static void RemoveExistingEnumMembers(ISwitchExpressionOperation operation, Dictionary`2<long, ISymbol> enumMembers);
    internal static void HandleBinaryPattern(IBinaryPatternOperation binaryPattern, Dictionary`2<long, ISymbol> enumMembers);
    private static void RemoveIfConstantPatternHasValue(IOperation operation, Dictionary`2<long, ISymbol> enumMembers);
    public static bool HasDefaultCase(ISwitchExpressionOperation operation);
    public static bool IsDefault(ISwitchExpressionArmOperation arm);
    public static bool IsDefault(IPatternOperation pattern);
    public static bool HasExhaustiveNullAndTypeCheckCases(ISwitchExpressionOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PopulateSwitch.PopulateSwitchStatementHelpers : object {
    public static string MissingCases;
    public static string MissingDefaultCase;
    public static bool HasDefaultCase(ISwitchOperation switchStatement);
    private static bool HasDefaultCase(ISwitchCaseOperation switchCase);
    public static ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation switchStatement);
    public static bool HasNullSwitchArm(ISwitchOperation operation);
    private static bool TryRemoveExistingEnumMembers(ISwitchOperation switchStatement, Dictionary`2<long, ISymbol> enumValues);
    public static bool TryGetAllEnumMembers(ITypeSymbol enumType, Dictionary`2<long, ISymbol> enumValues);
    public static bool HasExhaustiveNullAndTypeCheckCases(ISwitchOperation operation);
}
internal abstract class Microsoft.CodeAnalysis.Precedence.AbstractPrecedenceService`2 : object {
    private sealed virtual override int Microsoft.CodeAnalysis.Precedence.IPrecedenceService.GetOperatorPrecedence(SyntaxNode expression);
    private sealed virtual override PrecedenceKind Microsoft.CodeAnalysis.Precedence.IPrecedenceService.GetPrecedenceKind(int operatorPrecedence);
    public abstract virtual TOperatorPrecedence GetOperatorPrecedence(TExpressionSyntax expression);
    public abstract virtual PrecedenceKind GetPrecedenceKind(TOperatorPrecedence operatorPrecedence);
}
internal interface Microsoft.CodeAnalysis.Precedence.IPrecedenceService {
    public abstract virtual PrecedenceKind GetPrecedenceKind(int operatorPrecedence);
    public abstract virtual int GetOperatorPrecedence(SyntaxNode expression);
}
internal enum Microsoft.CodeAnalysis.Precedence.PrecedenceKind : Enum {
    public int value__;
    public static PrecedenceKind Arithmetic;
    public static PrecedenceKind Shift;
    public static PrecedenceKind Relational;
    public static PrecedenceKind Equality;
    public static PrecedenceKind Bitwise;
    public static PrecedenceKind Logical;
    public static PrecedenceKind Coalesce;
    public static PrecedenceKind Other;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Precedence.PrecedenceServiceExtensions : object {
    [ExtensionAttribute]
public static PrecedenceKind GetPrecedenceKind(IPrecedenceService service, SyntaxNode expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Progress.NullProgress`1 : object {
    public static IProgress`1<T> Instance;
    private static NullProgress`1();
    public sealed virtual void Report(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.PublicContract : object {
    internal static IEnumerable`1<T> RequireNonNullItems(IEnumerable`1<T> sequence, string argumentName);
    internal static void RequireUniqueNonNullItems(IEnumerable`1<T> sequence, string argumentName);
    internal static IReadOnlyList`1<T> ToBoxedImmutableArrayWithNonNullItems(IEnumerable`1<T> sequence, string argumentName);
    internal static IReadOnlyList`1<T> ToBoxedImmutableArrayWithDistinctNonNullItems(IEnumerable`1<T> sequence, string argumentName);
    [ExtensionAttribute]
private static int IndexOfNullOrDuplicateItem(IEnumerable`1<T> sequence);
    private static int EnumeratingIndexOfNullOrDuplicateItem(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
private static int IndexOfNullOrDuplicateItem(IReadOnlyList`1<T> list);
    private static string MakeIndexedArgumentName(string argumentName, int index);
    [DoesNotReturnAttribute]
private static void ThrowArgumentItemNullOrDuplicateException(IEnumerable`1<T> sequence, string argumentName);
    [DoesNotReturnAttribute]
private static void ThrowArgumentItemNullException(IEnumerable`1<T> sequence, string argumentName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ISimplification Simplification { get; }
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    protected abstract virtual bool CanMemberAccessBeQualified(ISymbol containingSymbol, SyntaxNode node);
    protected abstract virtual bool IsAlreadyQualifiedMemberAccess(TExpressionSyntax node);
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual Location GetLocation(IOperation operation);
    protected abstract virtual ISimplification get_Simplification();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    private void AnalyzeOperation(OperationAnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context, IOperation operation, IOperation instanceOperation);
    private static bool IsStaticMemberOrIsLocalFunction(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <IsStaticMemberOrIsLocalFunction>g__IsStaticMemberOrIsLocalFunctionHelper|11_0(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.ReadOnlyMemoryOfCharComparer : object {
    public static ReadOnlyMemoryOfCharComparer Instance;
    private static ReadOnlyMemoryOfCharComparer();
    public static bool Equals(ReadOnlySpan`1<char> x, ReadOnlyMemory`1<char> y);
    public sealed virtual bool Equals(ReadOnlyMemory`1<char> x, ReadOnlyMemory`1<char> y);
    public sealed virtual int GetHashCode(ReadOnlyMemory`1<char> obj);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.RelativePathResolver : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <SearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public RelativePathResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_SearchPaths();
    [CompilerGeneratedAttribute]
public string get_BaseDirectory();
    public string ResolvePath(string reference, string baseFilePath);
    [NullableContextAttribute("1")]
protected virtual bool FileExists(string fullPath);
    [NullableContextAttribute("1")]
public RelativePathResolver WithSearchPaths(ImmutableArray`1<string> searchPaths);
    [NullableContextAttribute("1")]
public RelativePathResolver WithBaseDirectory(string baseDirectory);
    public sealed virtual bool Equals(RelativePathResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveRedundantEquality.AbstractRemoveRedundantEqualityDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private ISyntaxFacts <syntaxFacts>P;
    protected AbstractRemoveRedundantEqualityDiagnosticAnalyzer(ISyntaxFacts syntaxFacts);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeIsPatternOperator(OperationAnalysisContext context);
    private void AnalyzeBinaryOperator(OperationAnalysisContext context);
    private void AnalyzeOperator(OperationAnalysisContext context, IOperation leftOperand, IOperation rightOperand, bool isOperatorEquals, SyntaxToken operatorToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static Nullable`1<bool> <AnalyzeOperator>g__TryGetLiteralValue|6_0(IOperation operand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RemoveRedundantEquality.RedundantEqualityConstants : object {
    public static string RedundantSide;
    public static string Left;
    public static string Right;
    public static string Negate;
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryCast.AbstractRemoveUnnecessaryCastDiagnosticAnalyzer`2 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    protected ImmutableArray`1<TLanguageKindEnum> SyntaxKindsOfInterest { get; }
    protected abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SyntaxKindsOfInterest();
    [NullableContextAttribute("1")]
protected abstract virtual TextSpan GetFadeSpan(TCastExpression node);
    [NullableContextAttribute("1")]
protected abstract virtual bool IsUnnecessaryCast(SemanticModel model, TCastExpression node, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
private Diagnostic TryRemoveCastExpression(SemanticModel model, TCastExpression node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    internal static string EnableGenerateDocumentationFileId;
    private static DiagnosticDescriptor s_fixableIdDescriptor;
    private static DiagnosticDescriptor s_enableGenerateDocumentationFileIdDescriptor;
    private DiagnosticDescriptor _classificationIdDescriptor;
    private DiagnosticDescriptor _generatedCodeClassificationIdDescriptor;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IUnnecessaryImportsProvider`1<TSyntaxNode> UnnecessaryImportsProvider { get; }
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    protected AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1(LocalizableString titleAndMessage);
    private static AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1();
    private static ImmutableArray`1<DiagnosticDescriptor> GetDescriptors(LocalizableString titleAndMessage, DiagnosticDescriptor& classificationIdDescriptor, DiagnosticDescriptor& generatedCodeClassificationIdDescriptor);
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual ImmutableArray`1<SyntaxNode> MergeImports(ImmutableArray`1<TSyntaxNode> unnecessaryImports);
    protected abstract virtual bool IsRegularCommentOrDocComment(SyntaxTrivia trivia);
    protected abstract virtual IUnnecessaryImportsProvider`1<TSyntaxNode> get_UnnecessaryImportsProvider();
    protected virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    protected abstract virtual Nullable`1<SyntaxToken> TryGetLastToken(SyntaxNode node);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSemanticModel(SemanticModelAnalysisContext context);
    private void AnalyzeCompilation(CompilationAnalysisContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1/<GetContiguousSpans>d__19")]
private IEnumerable`1<TextSpan> GetContiguousSpans(ImmutableArray`1<SyntaxNode> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1/<CreateClassificationDiagnostics>d__20")]
private static IEnumerable`1<Diagnostic> CreateClassificationDiagnostics(IEnumerable`1<TextSpan> contiguousSpans, SyntaxTree tree, DiagnosticDescriptor descriptor, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<TextSpan> GetFixableDiagnosticSpans(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1/<CreateFixableDiagnostics>d__22")]
private IEnumerable`1<Diagnostic> CreateFixableDiagnostics(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static int <GetContiguousSpans>g__GetEnd|19_0(SyntaxNode node, <>c__DisplayClass19_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractUnnecessaryImportsProvider`1 : object {
    public abstract virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, Nullable`1<TextSpan> span, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<TSyntaxNode>.Equals(TSyntaxNode x, TSyntaxNode y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<TSyntaxNode>.GetHashCode(TSyntaxNode obj);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.RemoveUnnecessaryImports.IUnnecessaryImportsProvider`1 {
    public abstract virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, Nullable`1<TextSpan> span, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.RemoveUnnecessaryImportsConstants : object {
    [NullableAttribute("1")]
public static string DiagnosticFixableId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    [NullableContextAttribute("0")]
protected abstract virtual TLanguageKindEnum GetSyntaxKind();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool CanRemoveParentheses(TParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static Location GetDiagnosticSquiggleLocation(TParenthesizedExpressionSyntax parenthesizedExpression, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.ParenthesesDiagnosticAnalyzersHelper : object {
    internal static ImmutableHashSet`1<IOption2> Options;
    private static ParenthesesDiagnosticAnalyzersHelper();
    internal static CodeStyleOption2`1<ParenthesesPreference> GetLanguageOption(AnalyzerOptionsProvider options, PrecedenceKind precedenceKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    internal static string DocCommentIdKey;
    private static LocalizableResourceString s_localizableTitle;
    private static LocalizableResourceString s_localizableInvalidScopeMessage;
    private static LocalizableResourceString s_localizableInvalidOrMissingTargetMessage;
    private static DiagnosticDescriptor s_invalidScopeDescriptor;
    private static DiagnosticDescriptor s_invalidOrMissingTargetDescriptor;
    private static LocalizableResourceString s_localizableLegacyFormatTitle;
    private static LocalizableResourceString s_localizableLegacyFormatMessage;
    internal static DiagnosticDescriptor LegacyFormatTargetDescriptor;
    private static AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer();
    protected abstract virtual void RegisterAttributeSyntaxAction(CompilationStartAnalysisContext context, CompilationAnalyzer compilationAnalyzer);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__12_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    private static LocalizableResourceString s_localizableRemoveUnnecessarySuppression;
    internal static DiagnosticDescriptor s_removeUnnecessarySuppressionDescriptor;
    private Lazy`1<ImmutableHashSet`1<int>> _lazySupportedCompilerErrorCodes;
    protected string CompilerErrorCodePrefix { get; }
    protected int CompilerErrorCodeDigitCount { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    private static AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer();
    protected abstract virtual string get_CompilerErrorCodePrefix();
    protected abstract virtual int get_CompilerErrorCodeDigitCount();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected abstract virtual ValueTuple`2<Assembly, string> GetCompilerDiagnosticAnalyzerInfo();
    protected abstract virtual bool ContainsPragmaDirective(SyntaxNode root);
    private ImmutableHashSet`1<int> GetSupportedCompilerErrorCodes();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<AnalyzeAsync>d__17")]
public sealed virtual Task AnalyzeAsync(SemanticModel semanticModel, Nullable`1<TextSpan> span, CompilationWithAnalyzers compilationWithAnalyzers, Func`2<DiagnosticAnalyzer, ImmutableArray`1<DiagnosticDescriptor>> getSupportedDiagnostics, Action`1<Diagnostic> reportDiagnostic, CancellationToken cancellationToken);
    private bool ProcessPragmaDirectives(SyntaxNode root, Nullable`1<TextSpan> span, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, PooledHashSet`1<string> compilerDiagnosticIds, ImmutableArray`1<string> userExclusions);
    private bool IsSupportedId(SyntaxNode idNode, String& id, Boolean& isCompilerDiagnosticId);
    private static bool IsSupportedAnalyzerDiagnosticId(string id);
    [NullableContextAttribute("2")]
private static ValueTuple`3<ImmutableArray`1<string>, ImmutableArray`1<string>, bool> ParseUserExclusions(string userExclusions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<GetReportedDiagnosticsForIdsAsync>d__22")]
private static Task`1<ValueTuple`2<ImmutableArray`1<Diagnostic>, ImmutableArray`1<string>>> GetReportedDiagnosticsForIdsAsync(ImmutableHashSet`1<string> idsToAnalyze, SyntaxNode root, SemanticModel semanticModel, CompilationWithAnalyzers compilationWithAnalyzers, Func`2<DiagnosticAnalyzer, ImmutableArray`1<DiagnosticDescriptor>> getSupportedDiagnostics, PooledHashSet`1<string> compilerDiagnosticIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<ProcessReportedDiagnosticsAsync>d__23")]
private static Task ProcessReportedDiagnosticsAsync(ImmutableArray`1<Diagnostic> diagnostics, SyntaxTree tree, CompilationWithAnalyzers compilationWithAnalyzers, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, CancellationToken cancellationToken);
    private static void ReportUnnecessarySuppressions(PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, Action`1<Diagnostic> reportDiagnostic, DiagnosticSeverity severity, Compilation compilation);
    private static bool TryGetTogglingPragmaDirective(SyntaxTrivia pragma, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, SyntaxTrivia& togglePragma);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<ProcessSuppressMessageAttributesAsync>d__26")]
private Task`1<bool> ProcessSuppressMessageAttributesAsync(SyntaxNode root, SemanticModel semanticModel, Nullable`1<TextSpan> span, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, ImmutableArray`1<string> userIdExclusions, ImmutableArray`1<string> userCategoryExclusions, CancellationToken cancellationToken);
    private static bool TryGetSuppressedDiagnosticId(AttributeData attribute, INamedTypeSymbol suppressMessageAttributeType, String& id, String& category);
    [CompilerGeneratedAttribute]
internal static void <GetReportedDiagnosticsForIdsAsync>g__AddAllDiagnostics|22_0(ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> diagnostics, ArrayBuilder`1<Diagnostic> reportedDiagnostics);
    [CompilerGeneratedAttribute]
internal static void <GetReportedDiagnosticsForIdsAsync>g__AddAllCompilationDiagnosticsForTree|22_1(AnalysisResult analysisResult, SyntaxTree tree, ArrayBuilder`1<Diagnostic> reportedDiagnostics);
    [CompilerGeneratedAttribute]
internal static void <ProcessReportedDiagnosticsAsync>g__ProcessPragmaSuppressions|23_0(Diagnostic diagnostic, SyntaxTree tree, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<<ProcessReportedDiagnosticsAsync>g__ProcessAttributeSuppressionsAsync|23_1>d")]
[CompilerGeneratedAttribute]
internal static Task <ProcessReportedDiagnosticsAsync>g__ProcessAttributeSuppressionsAsync|23_1(Diagnostic diagnostic, AttributeData attribute, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <ReportUnnecessarySuppressions>g__AddUnnecessaryPragmaDiagnostics|24_0(ArrayBuilder`1<Diagnostic> diagnosticsBuilder, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, DiagnosticSeverity severity);
    [CompilerGeneratedAttribute]
internal static void <ReportUnnecessarySuppressions>g__AddUnnecessarySuppressMessageAttributeDiagnostics|24_1(ArrayBuilder`1<Diagnostic> diagnosticsBuilder, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, DiagnosticSeverity severity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4 : AbstractCodeQualityDiagnosticAnalyzer {
    private static SymbolDisplayFormat ContainingTypeAndNameOnlyFormat;
    private static DiagnosticDescriptor s_removeUnusedMembersRule;
    internal static DiagnosticDescriptor s_removeUnreadMembersRule;
    private static AbstractRemoveUnusedMembersDiagnosticAnalyzer`4();
    protected abstract virtual IEnumerable`1<TTypeDeclarationSyntax> GetTypeDeclarations(INamedTypeSymbol namedType, CancellationToken cancellationToken);
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetMembers(TTypeDeclarationSyntax typeDeclaration);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected virtual void HandleNamedTypeSymbolStart(SymbolStartAnalysisContext context, Action`2<ISymbol, ValueUsageInfo> onSymbolUsageFound);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(CompilationStartAnalysisContext compilationStartContext);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public static string DiscardVariableName;
    private static string UnusedValuePreferenceKey;
    private static string IsUnusedLocalAssignmentKey;
    private static string IsRemovableAssignmentKey;
    private static DiagnosticDescriptor s_expressionValueIsUnusedRule;
    private static DiagnosticDescriptor s_valueAssignedIsUnusedRule;
    private static DiagnosticDescriptor s_unusedParameterRule;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<ValueTuple`3<UnusedValuePreference, bool, bool>, ImmutableDictionary`2<string, string>> s_propertiesMap;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    protected AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer(Option2`1<CodeStyleOption2`1<UnusedValuePreference>> unusedValueExpressionStatementOption, Option2`1<CodeStyleOption2`1<UnusedValuePreference>> unusedValueAssignmentOption);
    private static AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual Location GetDefinitionLocationToFade(IOperation unusedDefinition);
    protected abstract virtual bool SupportsDiscard(SyntaxTree tree);
    protected abstract virtual bool MethodHasHandlesClause(IMethodSymbol method);
    protected abstract virtual bool IsIfConditionalDirective(SyntaxNode node);
    protected abstract virtual bool ReturnsThrow(SyntaxNode node);
    protected abstract virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueExpressionStatementOption(AnalyzerOptionsProvider provider);
    protected abstract virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueAssignmentOption(AnalyzerOptionsProvider provider);
    protected virtual bool ShouldBailOutFromRemovableAssignmentAnalysis(IOperation unusedSymbolWriteOperation);
    protected abstract virtual bool IsCallStatement(IExpressionStatementOperation expressionStatement);
    protected abstract virtual bool IsExpressionOfExpressionBody(IExpressionStatementOperation expressionStatement);
    private static ImmutableDictionary`2<ValueTuple`3<UnusedValuePreference, bool, bool>, ImmutableDictionary`2<string, string>> CreatePropertiesMap();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private bool TryGetOptions(SyntaxTree syntaxTree, AnalyzerOptions analyzerOptions, CompilationOptions compilationOptions, CancellationToken cancellationToken, Options& options);
    public static bool ShouldReportUnusedParameters(ISymbol symbol, UnusedParametersPreference unusedParametersPreference, ReportDiagnostic unusedParametersSeverity);
    public static bool TryGetUnusedValuePreference(Diagnostic diagnostic, UnusedValuePreference& preference);
    public static bool GetIsUnusedLocalDiagnostic(Diagnostic diagnostic);
    public static bool GetIsRemovableAssignmentDiagnostic(Diagnostic diagnostic);
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntries|21_0(UnusedValuePreference preference, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntries2|21_1(UnusedValuePreference preference, bool isUnusedLocalAssignment, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntryCore|21_2(UnusedValuePreference preference, bool isUnusedLocalAssignment, bool isRemovableAssignment, <>c__DisplayClass21_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__25_0(CompilationStartAnalysisContext compilationContext);
    [CompilerGeneratedAttribute]
private ValueTuple`2<UnusedValuePreference, NotificationOption2> <TryGetOptions>g__GetPreferenceAndSeverity|26_0(CodeStyleOption2`1<UnusedValuePreference> option, <>c__DisplayClass26_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RoslynExperiments : object {
    internal static string NullableDisabledSemanticModel;
    internal static string NullableDisabledSemanticModel_Url;
    internal static string Interceptors;
    internal static string Interceptors_Url;
    internal static string SyntaxTokenParser;
    internal static string SyntaxTokenParser_Url;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SerializableBytes : object {
    private static int ChunkSize;
    internal static PooledStream CreateReadableStream(Byte[] bytes);
    internal static PooledStream CreateReadableStream(Byte[] bytes, int length);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SerializableBytes/<CreateReadableStreamAsync>d__3")]
internal static Task`1<PooledStream> CreateReadableStreamAsync(Stream stream, CancellationToken cancellationToken);
    private static void BlowChunks(Byte[][] chunks);
    internal static ReadWriteStream CreateWritableStream();
}
internal enum Microsoft.CodeAnalysis.Shared.CodeStyle.CollectionExpressionPreference : Enum {
    public int value__;
    public static CollectionExpressionPreference Never;
    public static CollectionExpressionPreference WhenTypesExactlyMatch;
    public static CollectionExpressionPreference WhenTypesLooselyMatch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.CodeStyle.CollectionExpressionPreferenceUtilities : object {
    private static string never;
    private static string when_types_exactly_match;
    private static string when_types_loosely_match;
    public static string GetEditorConfigString(CodeStyleOption2`1<CollectionExpressionPreference> value, CodeStyleOption2`1<CollectionExpressionPreference> defaultValue);
    public static Optional`1<CodeStyleOption2`1<CollectionExpressionPreference>> Parse(string optionString, CodeStyleOption2`1<CollectionExpressionPreference> defaultValue);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector`1 {
    public abstract virtual TextSpan GetSpan(T value);
}
internal interface Microsoft.CodeAnalysis.Shared.Collections.IIntervalTester`2 {
    public abstract virtual bool Test(T value, int start, int length, TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) introspector);
}
internal interface Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree`1 {
    public abstract virtual int FillWithIntervalsThatMatch(int start, int length, TemporaryArray`1& builder, TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) introspector, TIntervalTester& modreq(System.Runtime.InteropServices.InAttribute) intervalTester, bool stopAfterFirst);
    public abstract virtual bool Any(int start, int length, TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) introspector, TIntervalTester& modreq(System.Runtime.InteropServices.InAttribute) intervalTester);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Collections.IIntervalTreeWitness`3 {
    public abstract virtual bool TryGetRoot(TIntervalTree tree, TNode& root);
    public abstract virtual bool TryGetLeftNode(TIntervalTree tree, TNode node, TNode& leftNode);
    public abstract virtual bool TryGetRightNode(TIntervalTree tree, TNode node, TNode& rightNode);
    public abstract virtual T GetValue(TIntervalTree tree, TNode node);
    public abstract virtual TNode GetMaxEndNode(TIntervalTree tree, TNode node);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Collections.ImmutableIntervalTree`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableIntervalTree`1<T> Empty;
    private SegmentedArray`1<Node<T>> _array;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IntervalTreeAlgorithms`2<T, ImmutableIntervalTree`1<T>> Algorithms { get; }
    private ImmutableIntervalTree`1(SegmentedArray`1<Node<T>> array);
    private static ImmutableIntervalTree`1();
    public IntervalTreeAlgorithms`2<T, ImmutableIntervalTree`1<T>> get_Algorithms();
    public static ImmutableIntervalTree`1<T> CreateFromUnsorted(TIntrospector& introspector, SegmentedList`1<T> values);
    public static ImmutableIntervalTree`1<T> CreateFromSorted(TIntrospector& introspector, SegmentedList`1<T> values);
    private static int GetLeftChildIndex(int nodeIndex);
    private static int GetRightChildIndex(int nodeIndex);
    private sealed virtual override bool Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree<T>.Any(int start, int length, TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) introspector, TIntervalTester& modreq(System.Runtime.InteropServices.InAttribute) intervalTester);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree<T>.FillWithIntervalsThatMatch(int start, int length, TemporaryArray`1& builder, TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) introspector, TIntervalTester& modreq(System.Runtime.InteropServices.InAttribute) intervalTester, bool stopAfterFirst);
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public Enumerator<T, ImmutableIntervalTree`1<T>, int, FlatArrayIntervalTreeWitness<T>> GetEnumerator();
    [CompilerGeneratedAttribute]
internal static void <CreateFromSorted>g__BuildCompleteTree|7_0(SegmentedList`1<T> source, int sourceStartInclusive, int sourceEndExclusive, SegmentedArray`1<Node<T>> destination, int destinationIndex);
    [CompilerGeneratedAttribute]
internal static int <CreateFromSorted>g__GetRootSourceIndex|7_1(int subtreeNodeCount);
    [CompilerGeneratedAttribute]
internal static int <CreateFromSorted>g__PerfectTreeNodeCount|7_2(int height);
    [CompilerGeneratedAttribute]
internal static int <CreateFromSorted>g__ComputeMaxEndNodes|7_3(SegmentedArray`1<Node<T>> array, int currentNodeIndex, TIntrospector& introspector);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeAlgorithms`2 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TIntervalTree <tree>P;
    [NullableContextAttribute("1")]
public IntervalTreeAlgorithms`2(TIntervalTree tree);
    public ImmutableArray`1<T> GetIntervalsThatMatch(int start, int length, TIntrospector& introspector, TIntervalTester& intervalTester);
    public ImmutableArray`1<T> GetIntervalsThatOverlapWith(int start, int length, TIntrospector& introspector);
    public ImmutableArray`1<T> GetIntervalsThatIntersectWith(int start, int length, TIntrospector& introspector);
    public ImmutableArray`1<T> GetIntervalsThatContain(int start, int length, TIntrospector& introspector);
    public void FillWithIntervalsThatOverlapWith(int start, int length, TemporaryArray`1& builder, TIntrospector& introspector);
    public void FillWithIntervalsThatIntersectWith(int start, int length, TemporaryArray`1& builder, TIntrospector& introspector);
    public void FillWithIntervalsThatContain(int start, int length, TemporaryArray`1& builder, TIntrospector& introspector);
    public bool HasIntervalThatIntersectsWith(int position, TIntrospector& introspector);
    public bool HasIntervalThatIntersectsWith(int start, int length, TIntrospector& introspector);
    public bool HasIntervalThatOverlapsWith(int start, int length, TIntrospector& introspector);
    public bool HasIntervalThatContains(int start, int length, TIntrospector& introspector);
    public static bool Contains(T value, int start, int length, TIntrospector& introspector);
    private static bool IntersectsWith(T value, int start, int length, TIntrospector& introspector);
    private static bool OverlapsWith(T value, int start, int length, TIntrospector& introspector);
}
internal static class Microsoft.CodeAnalysis.Shared.Collections.IntervalTreeHelpers`4 : object {
    [NullableAttribute("1")]
private static ObjectPool`1<Stack`1<TNode>> s_nodeStackPool;
    private static IntervalTreeHelpers`4();
    public static Enumerator<T, TIntervalTree, TNode, TIntervalTreeWitness> GetEnumerator(TIntervalTree tree);
    public static int FillWithIntervalsThatMatch(TIntervalTree tree, int start, int length, TemporaryArray`1& builder, TIntrospector& introspector, TIntervalTester& intervalTester, bool stopAfterFirst);
    public static bool Any(TIntervalTree tree, int start, int length, TIntrospector& introspector, TIntervalTester& intervalTester);
    [NullableContextAttribute("1")]
private static bool ShouldExamineRight(TIntervalTree tree, int start, int end, TNode currentNode, TIntrospector& introspector, TNode& right);
    [NullableContextAttribute("1")]
private static bool ShouldExamineLeft(TIntervalTree tree, int start, TNode currentNode, TIntrospector& introspector, TNode& left);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.MutableIntervalTree`1 : object {
    [NullableAttribute("1")]
public static MutableIntervalTree`1<T> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Node<T> root;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IntervalTreeAlgorithms`2<T, MutableIntervalTree`1<T>> Algorithms { get; }
    private static MutableIntervalTree`1();
    [NullableContextAttribute("1")]
public static MutableIntervalTree`1<T> Create(TIntrospector& introspector, IEnumerable`1<T> values);
    public IntervalTreeAlgorithms`2<T, MutableIntervalTree`1<T>> get_Algorithms();
    private sealed virtual override bool Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree<T>.Any(int start, int length, TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) introspector, TIntervalTester& modreq(System.Runtime.InteropServices.InAttribute) intervalTester);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalTree<T>.FillWithIntervalsThatMatch(int start, int length, TemporaryArray`1& builder, TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) introspector, TIntervalTester& modreq(System.Runtime.InteropServices.InAttribute) intervalTester, bool stopAfterFirst);
    public bool IsEmpty();
    protected static Node<T> Insert(Node<T> root, Node<T> newNode, TIntrospector& introspector);
    private static Node<T> Insert(Node<T> root, Node<T> newNode, int newNodeStart, TIntrospector& introspector);
    public Enumerator<T, MutableIntervalTree`1<T>, Node<T>, BinaryIntervalTreeWitness<T>> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    protected static int GetEnd(T value, TIntrospector& introspector);
    protected static int MaxEndValue(Node<T> node, TIntrospector& introspector);
    private static int Height(Node<T> node);
    [CompilerGeneratedAttribute]
internal static Node<T> <Insert>g__Balance|9_0(Node<T> node, TIntrospector& introspector);
    [CompilerGeneratedAttribute]
internal static int <Insert>g__BalanceFactor|9_1(Node<T> node);
}
internal static class Microsoft.CodeAnalysis.Shared.Collections.SimpleMutableIntervalTree : object {
    public static SimpleMutableIntervalTree`2<T, TIntrospector> Create(TIntrospector& introspector, T[] values);
    public static SimpleMutableIntervalTree`2<T, TIntrospector> Create(TIntrospector& introspector, IEnumerable`1<T> values);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Shared.Collections.SimpleMutableIntervalTree`2 : MutableIntervalTree`1<T> {
    private TIntrospector _introspector;
    [IsReadOnlyAttribute]
protected TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) Introspector { get; }
    public SimpleMutableIntervalTree`2(TIntrospector& introspector, IEnumerable`1<T> values);
    protected TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) get_Introspector();
    [NullableContextAttribute("1")]
public void AddIntervalInPlace(T value);
    public ImmutableArray`1<T> GetIntervalsThatOverlapWith(int start, int length);
    public ImmutableArray`1<T> GetIntervalsThatIntersectWith(int start, int length);
    public ImmutableArray`1<T> GetIntervalsThatContain(int start, int length);
    public void FillWithIntervalsThatOverlapWith(int start, int length, TemporaryArray`1& builder);
    public void FillWithIntervalsThatIntersectWith(int start, int length, TemporaryArray`1& builder);
    public void FillWithIntervalsThatContain(int start, int length, TemporaryArray`1& builder);
    public bool HasIntervalThatIntersectsWith(int position);
    public bool HasIntervalThatOverlapsWith(int start, int length);
    public bool HasIntervalThatIntersectsWith(int start, int length);
    public bool HasIntervalThatContains(int start, int length);
    [NullableContextAttribute("1")]
protected int MaxEndValue(Node<T> node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1 : ValueType {
    private static int InlineCapacity;
    private T _item0;
    private T _item1;
    private T _item2;
    private T _item3;
    private int _count;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TemporaryArray`1<T> Empty { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private TemporaryArray`1(TemporaryArray`1& array);
    public static TemporaryArray`1<T> GetInstance(int capacity);
    public static TemporaryArray`1<T> get_Empty();
    [IsReadOnlyAttribute]
public int get_Count();
    [IsReadOnlyAttribute]
public T get_Item(int index);
    public void set_Item(int index, T value);
    public sealed virtual void Dispose();
    public void Add(T item);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(TemporaryArray`1& items);
    public void Clear();
    public T RemoveLast();
    [IsReadOnlyAttribute]
public bool Contains(T value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public OneOrMany`1<T> ToOneOrManyAndClear();
    public ImmutableArray`1<T> ToImmutableAndClear();
    [MemberNotNullAttribute("_builder")]
private void MoveInlineToBuilder();
    public void ReverseContents();
    public void Sort(Comparison`1<T> compare);
    private static void ThrowIndexOutOfRangeException();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Collections.TemporaryArrayExtensions : object {
    [ExtensionAttribute]
public static TemporaryArray`1& AsRef(TemporaryArray`1& array);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Any(TemporaryArray`1& array, Func`2<T, bool> predicate);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool All(TemporaryArray`1& array, Func`2<T, bool> predicate);
    private static void ThrowSequenceContainsMoreThanOneElement();
    [ExtensionAttribute]
public static T SingleOrDefault(TemporaryArray`1& array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T SingleOrDefault(TemporaryArray`1& array, Func`3<T, TArg, bool> predicate, TArg arg);
    [ExtensionAttribute]
public static T FirstOrDefault(TemporaryArray`1& array);
    [ExtensionAttribute]
public static T FirstOrDefault(TemporaryArray`1& array, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AddIfNotNull(TemporaryArray`1& array, Nullable`1<T> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddIfNotNull(TemporaryArray`1& array, T value);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Collections.TextSpanIntervalIntrospector : ValueType {
    public sealed virtual TextSpan GetSpan(TextSpan value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Collections.TextSpanMutableIntervalTree : SimpleMutableIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> {
    public TextSpanMutableIntervalTree(IEnumerable`1<TextSpan> values);
    public TextSpanMutableIntervalTree(TextSpan[] values);
    public bool HasIntervalThatIntersectsWith(TextSpan span);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.AccessibilityUtilities : object {
    public static Accessibility Minimum(Accessibility accessibility1, Accessibility accessibility2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ChildSyntaxListExtensions : object {
    [ExtensionAttribute]
public static SyntaxNodeOrToken First(ChildSyntaxList childSyntaxList, Func`2<SyntaxNodeOrToken, bool> predicate);
    [ExtensionAttribute]
public static SyntaxNodeOrToken Last(ChildSyntaxList childSyntaxList, Func`2<SyntaxNodeOrToken, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CompilationExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol GetBestTypeByMetadataName(Compilation compilation, string fullyQualifiedMetadataName);
    [ExtensionAttribute]
public static IMethodSymbol GetTopLevelStatementsMethod(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TryGetCallingConventionSymbol(Compilation compilation, string callingConvention);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions : object {
    private static string DotnetAnalyzerDiagnosticPrefix;
    private static string DotnetDiagnosticPrefix;
    private static string CategoryPrefix;
    private static string SeveritySuffix;
    private static string DotnetAnalyzerDiagnosticSeverityKey;
    [ExtensionAttribute]
public static ImmutableArray`1<string> ImmutableCustomTags(DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
public static ReportDiagnostic GetEffectiveSeverity(DiagnosticDescriptor descriptor, CompilationOptions compilationOptions, ImmutableDictionary`2<string, string> analyzerOptions, ImmutableDictionary`2<string, ReportDiagnostic> treeOptions);
    [ExtensionAttribute]
public static ReportDiagnostic GetEffectiveSeverity(DiagnosticDescriptor descriptor, CompilationOptions compilationOptions, SyntaxTree tree, AnalyzerOptions analyzerOptions);
    [ExtensionAttribute]
public static bool IsDefinedInEditorConfig(DiagnosticDescriptor descriptor, AnalyzerConfigOptions analyzerConfigOptions);
    [ExtensionAttribute]
public static ReportDiagnostic GetEffectiveSeverity(DiagnosticDescriptor descriptor, AnalyzerConfigOptions analyzerConfigOptions, Nullable`1<ValueTuple`2<SyntaxTreeOptionsProvider, SyntaxTree>> providerAndTree);
    private static bool TryGetSeverityFromBulkConfiguration(DiagnosticDescriptor descriptor, ImmutableDictionary`2<string, string> analyzerOptions, ReportDiagnostic& severity);
    [ExtensionAttribute]
public static bool IsCompilationEnd(DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static Uri GetValidHelpLinkUri(DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
public static DiagnosticDescriptor WithMessageFormat(DiagnosticDescriptor descriptor, LocalizableString messageFormat);
}
internal class Microsoft.CodeAnalysis.Shared.Extensions.DirectiveInfo`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<TDirectiveTriviaSyntax, TDirectiveTriviaSyntax> <DirectiveMap>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<TDirectiveTriviaSyntax, ImmutableArray`1<TDirectiveTriviaSyntax>> <ConditionalMap>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<TDirectiveTriviaSyntax, TDirectiveTriviaSyntax> DirectiveMap { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<TDirectiveTriviaSyntax, ImmutableArray`1<TDirectiveTriviaSyntax>> ConditionalMap { get; }
    public DirectiveInfo`1(Dictionary`2<TDirectiveTriviaSyntax, TDirectiveTriviaSyntax> directiveMap, Dictionary`2<TDirectiveTriviaSyntax, ImmutableArray`1<TDirectiveTriviaSyntax>> conditionalMap);
    [CompilerGeneratedAttribute]
public Dictionary`2<TDirectiveTriviaSyntax, TDirectiveTriviaSyntax> get_DirectiveMap();
    [CompilerGeneratedAttribute]
public Dictionary`2<TDirectiveTriviaSyntax, ImmutableArray`1<TDirectiveTriviaSyntax>> get_ConditionalMap();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IAssemblySymbolExtensions : object {
    private static string AttributeSuffix;
    [ExtensionAttribute]
public static bool ContainsNamespaceName(List`1<IAssemblySymbol> assemblies, string namespaceName);
    [ExtensionAttribute]
public static bool ContainsTypeName(List`1<IAssemblySymbol> assemblies, string typeName, bool tryWithAttributeSuffix);
    [ExtensionAttribute]
public static bool IsSameAssemblyOrHasFriendAccessTo(IAssemblySymbol assembly, IAssemblySymbol toAssembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICollectionExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(IEnumerable`1<T> values, Func`3<T, TState, bool> predicate, TState state);
    [ExtensionAttribute]
public static void RemoveRange(ICollection`1<T> collection, IEnumerable`1<T> items);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AddIfNotNull(ICollection`1<T> collection, Nullable`1<T> value);
    [ExtensionAttribute]
public static void AddIfNotNull(ICollection`1<T> collection, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICompilationExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<Compilation> GetReferencedCompilations(Compilation compilation);
    [ExtensionAttribute]
public static ImmutableArray`1<IAssemblySymbol> GetReferencedAssemblySymbols(Compilation compilation, bool excludePreviousSubmissions);
    [ExtensionAttribute]
public static INamedTypeSymbol AttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ExceptionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DebuggerDisplayAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol StructLayoutAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DesignerCategoryAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DesignerGeneratedAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol HideModuleNameAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ThreadStaticAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EventArgsType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol NotImplementedExceptionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EqualityComparerOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ActionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ExpressionOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EditorBrowsableAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EditorBrowsableStateType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TaskType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TaskOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ValueTaskType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ValueTaskOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IEnumerableType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IEnumerableOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IEnumeratorOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IListOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IReadOnlyListOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IAsyncEnumerableOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IAsyncEnumeratorOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ImmutableArrayOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SerializableAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol CoClassType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ComAliasNameAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SuppressMessageAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TupleElementNamesAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol NativeIntegerAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DynamicAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol LazyOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ISerializableType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SerializationInfoType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol StreamingContextType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol OnDeserializingAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol OnDeserializedAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol OnSerializingAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol OnSerializedAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ComRegisterFunctionAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ComUnregisterFunctionAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ConditionalAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ObsoleteAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SystemCompositionImportingConstructorAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SystemComponentModelCompositionImportingConstructorAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SystemIDisposableType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol NotNullAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol MaybeNullAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol MaybeNullWhenAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol AllowNullAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DisallowNullAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DataMemberAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DataContractAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol AsyncMethodBuilderAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol CancellationTokenType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ValueTupleType(Compilation compilation, int arity);
    [ExtensionAttribute]
public static INamedTypeSymbol ListOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ReadOnlySpanOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SpanOfTType(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<IMethodSymbol> GetAllMethodSymbolsOfPartialParts(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasEventHandlerSignature(IMethodSymbol method, INamedTypeSymbol eventArgsType);
    [ExtensionAttribute]
public static bool TryGetPredefinedComparisonOperator(IMethodSymbol symbol, PredefinedOperator& op);
    [ExtensionAttribute]
public static PredefinedOperator GetPredefinedOperator(IMethodSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEntryPoint(IMethodSymbol methodSymbol, INamedTypeSymbol taskType, INamedTypeSymbol genericTaskType);
    [ExtensionAttribute]
public static bool IsAsyncReturningVoidTask(IMethodSymbol method, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions/<GetBaseTypesAndThis>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypesAndThis(INamedTypeSymbol namedType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<ITypeParameterSymbol> GetAllTypeParameters(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetAllTypeArguments(INamedTypeSymbol symbol);
    private static Stack`1<INamedTypeSymbol> GetContainmentStack(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsContainedWithin(INamedTypeSymbol symbol, INamedTypeSymbol outer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol FindImplementationForAbstractMember(INamedTypeSymbol type, ISymbol symbol);
    private static bool ImplementationExists(INamedTypeSymbol classOrStructType, ISymbol member);
    [ExtensionAttribute]
private static bool IsImplemented(INamedTypeSymbol classOrStructType, ISymbol member, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, CancellationToken cancellationToken);
    private static bool IsInterfacePropertyImplemented(INamedTypeSymbol classOrStructType, IPropertySymbol propertySymbol);
    private static bool IsAbstractPropertyImplemented(INamedTypeSymbol classOrStructType, IPropertySymbol propertySymbol);
    [ExtensionAttribute]
private static bool IsExplicitlyImplemented(INamedTypeSymbol classOrStructType, ISymbol member, Func`3<INamedTypeSymbol, ISymbol, bool> isValid, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, bool includeMembersRequiringExplicitImplementation, CancellationToken cancellationToken);
    private static bool IsImplementable(ISymbol m);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembersInThis(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembersInThis(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedExplicitMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetExplicitlyImplementableMembers(INamedTypeSymbol type, ISymbol within);
    private static bool IsPropertyWithInaccessibleImplementableAccessor(ISymbol member, ISymbol within);
    private static bool IsInaccessibleImplementableAccessor(IMethodSymbol accessor, ISymbol within);
    [ExtensionAttribute]
private static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`5<INamedTypeSymbol, ISymbol, Func`3<INamedTypeSymbol, ISymbol, bool>, CancellationToken, bool> isImplemented, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, bool allowReimplementation, CancellationToken cancellationToken);
    private static ImmutableArray`1<INamedTypeSymbol> GetTypesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, bool allowReimplementation, CancellationToken cancellationToken);
    private static ImmutableArray`1<INamedTypeSymbol> GetAbstractClassesToImplement(IEnumerable`1<INamedTypeSymbol> abstractClasses);
    private static ImmutableArray`1<INamedTypeSymbol> GetInterfacesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, bool allowReimplementation, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static ImmutableArray`1<ISymbol> GetUnimplementedMembers(INamedTypeSymbol classOrStructType, INamedTypeSymbol interfaceType, Func`5<INamedTypeSymbol, ISymbol, Func`3<INamedTypeSymbol, ISymbol, bool>, CancellationToken, bool> isImplemented, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions/<GetAttributeNamedParameters>d__24")]
[ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetAttributeNamedParameters(INamedTypeSymbol attributeSymbol, Compilation compilation, ISymbol within);
    private static ISymbol IsAttributeNamedParameter(ISymbol symbol, ISymbol within);
    private static ImmutableArray`1<ISymbol> GetMembers(INamedTypeSymbol type, ISymbol within);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetOverridableMembers(INamedTypeSymbol containingType, CancellationToken cancellationToken);
    private static void AddOverridableMembers(Dictionary`2<ISymbol, int> result, INamedTypeSymbol containingType, INamedTypeSymbol type, Int32& index, CancellationToken cancellationToken);
    private static bool IsOverridable(ISymbol member, INamedTypeSymbol containingType);
    [NullableContextAttribute("2")]
private static bool IsEqualsObjectOverride(ISymbol member);
    private static bool IsEqualsObject(ISymbol member);
    [ExtensionAttribute]
public static INamedTypeSymbol TryConstruct(INamedTypeSymbol type, ITypeSymbol[] typeArguments);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsCollectionBuilderAttribute(INamedTypeSymbol type);
    [CompilerGeneratedAttribute]
internal static bool <IsInterfacePropertyImplemented>g__IsAccessorImplemented|8_0(IMethodSymbol accessor, INamedTypeSymbol classOrStructType);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ISymbol> <GetAllUnimplementedMembers>g__GetImplicitlyImplementableMembers|11_0(INamedTypeSymbol type, ISymbol within);
    [CompilerGeneratedAttribute]
internal static bool <GetAllUnimplementedMembers>g__IsPropertyWithNonPublicImplementableAccessor|11_1(ISymbol member);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetAllUnimplementedMembers>g__IsNonPublicImplementableAccessor|11_2(IMethodSymbol accessor);
    [CompilerGeneratedAttribute]
internal static bool <GetAllUnimplementedMembers>g__IsImplicitlyImplementable|11_3(ISymbol member, ISymbol within);
    [CompilerGeneratedAttribute]
internal static void <GetUnimplementedMembers>g__AddIfNotImplemented|23_0(ISymbol member, <>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static void <GetOverridableMembers>g__RemoveOverriddenMembers|27_0(Dictionary`2<ISymbol, int> result, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <GetOverridableMembers>g__RemoveNonOverriddableMembers|27_1(Dictionary`2<ISymbol, int> result, INamedTypeSymbol containingType, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions : object {
    private static ConditionalWeakTable`2<INamespaceOrTypeSymbol, List`1<string>> s_namespaceOrTypeToNameMap;
    private static SymbolDisplayFormat s_shortNameFormat;
    private static INamespaceOrTypeSymbolExtensions();
    [ExtensionAttribute]
public static string GetShortName(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetIndexers(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetNameParts(INamespaceOrTypeSymbol symbol);
    public static int CompareNameParts(IReadOnlyList`1<string> names1, IReadOnlyList`1<string> names2, bool placeSystemNamespaceFirst);
    private static void GetNameParts(INamespaceOrTypeSymbol namespaceOrTypeSymbol, List`1<string> result);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions/<GetAllTypes>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllTypes(INamespaceOrTypeSymbol namespaceOrTypeSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsRefOrOut(IParameterSymbol symbol);
    [ExtensionAttribute]
public static IPropertySymbol GetAssociatedSynthesizedRecordProperty(IParameterSymbol parameter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPrimaryConstructor(IParameterSymbol parameter, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IPropertySymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IFieldSymbol GetBackingFieldIfAny(IPropertySymbol property);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToNameDisplayString(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToSignatureDisplayString(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasPublicResultantVisibility(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol GetOverriddenMember(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<ISymbol> ExplicitInterfaceImplementations(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<ISymbol> ExplicitOrImplicitInterfaceImplementations(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<ISymbol> ImplicitInterfaceImplementations(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOverridable(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementableMember(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static INamedTypeSymbol GetContainingTypeOrThis(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsModuleType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsInterfaceType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsArrayType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsTupleType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousFunction(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind[] kinds);
    [ExtensionAttribute]
public static bool IsReducedExtension(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsEnumMember(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsExtensionMethod(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsLocalFunction(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousOrLocalFunction(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsModuleMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsStaticConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConversion(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOrdinaryMethod(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOrdinaryMethodOrLocalFunction(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDelegateType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNormalAnonymousType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousDelegateType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousTypeProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsTupleField(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsWriteableFieldOrProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsRequired(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int GetArity(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol GetOriginalUnreducedDefinition(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsFunctionValue(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsThisParameter(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol ConvertThisParameterToType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsParams(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeParameterSymbol> GetAllTypeParameters(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> GetTypeArguments(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> GetAllTypeArguments(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAttribute(ISymbol symbol);
    [ExtensionAttribute]
public static bool RequiresUnsafeModifier(ISymbol member);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ITypeSymbol ConvertToType(ISymbol symbol, Compilation compilation, bool extensionUsedAsInstance);
    [ExtensionAttribute]
public static bool IsStaticType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNamespace(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsOrContainsAccessibleAttribute(ISymbol symbol, ISymbol withinType, IAssemblySymbol withinAssembly, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetValidAnonymousTypeProperties(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Accessibility ComputeResultantAccessibility(ISymbol symbol, ITypeSymbol finalDestination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsInaccessibleLocal(ISymbol symbol, int position);
    [ExtensionAttribute]
public static bool IsAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsEventAccessor(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsFromSource(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNonImplicitAndFromSource(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetSymbolType(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAwaitableNonDynamic(ISymbol symbol, SemanticModel semanticModel, int position);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsValidGetAwaiter(IMethodSymbol symbol);
    [NullableContextAttribute("1")]
private static bool VerifyGetAwaiter(IMethodSymbol getAwaiter);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsValidGetEnumerator(IMethodSymbol symbol);
    [NullableContextAttribute("1")]
private static bool VerifyGetEnumerator(IMethodSymbol getEnumerator);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsValidGetAsyncEnumerator(IMethodSymbol symbol);
    [NullableContextAttribute("1")]
private static bool VerifyGetAsyncEnumerator(IMethodSymbol getAsyncEnumerator);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind, TSymbol& result);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsSymbolWithSpecialDiscardName(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsObsolete(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, ISymbol within, ITypeSymbol throughType);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, IAssemblySymbol within, ITypeSymbol throughType);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughType);
    [NullableContextAttribute("1")]
private static bool IsSymbolAccessible(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughType, Boolean& failedThroughTypeCheck);
    [NullableContextAttribute("1")]
private static bool IsSymbolAccessibleCore(ISymbol symbol, ISymbol within, ITypeSymbol throughType, Boolean& failedThroughTypeCheck);
    [NullableContextAttribute("1")]
private static bool IsNamedTypeAccessible(INamedTypeSymbol type, ISymbol within);
    [NullableContextAttribute("1")]
private static bool IsNonNestedTypeAccessible(IAssemblySymbol assembly, Accessibility declaredAccessibility, ISymbol within);
    [NullableContextAttribute("1")]
private static bool IsMemberAccessible(INamedTypeSymbol containingType, Accessibility declaredAccessibility, ISymbol within, ITypeSymbol throughType, Boolean& failedThroughTypeCheck);
    [NullableContextAttribute("1")]
private static bool IsProtectedSymbolAccessible(INamedTypeSymbol withinType, IAssemblySymbol withinAssembly, ITypeSymbol throughType, INamedTypeSymbol originalContainingType, Boolean& failedThroughTypeCheck);
    [NullableContextAttribute("1")]
private static bool IsPrivateSymbolAccessible(ISymbol within, INamedTypeSymbol originalContainingType);
    [NullableContextAttribute("1")]
private static bool IsNestedWithinOriginalContainingType(INamedTypeSymbol withinType, INamedTypeSymbol originalContainingType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <ConvertToType>g__WithArity|58_1(string typeName, int arity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions : object {
    public static string DefaultParameterName;
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsIntegralType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSignedIntegralType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool CanAddNullCheck(ITypeSymbol type);
    [ExtensionAttribute]
public static IList`1<INamedTypeSymbol> GetAllInterfacesIncludingThis(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAbstractClass(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSystemVoid(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullable(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNonNullableValueType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullable(ITypeSymbol symbol, ITypeSymbol& underlyingType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsModuleType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInterfaceType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDelegateType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsFunctionPointerType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsStructType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousType(INamedTypeSymbol symbol);
    [ExtensionAttribute]
private static HashSet`1<INamedTypeSymbol> GetOriginalInterfacesAndTheirBaseInterfaces(ITypeSymbol type, HashSet`1<INamedTypeSymbol> symbols);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__17")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetBaseTypes>d__18")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetContainingTypesAndThis>d__19")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetContainingTypesAndThis(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetContainingTypes>d__20")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetContainingTypes(ITypeSymbol type);
    [ExtensionAttribute]
public static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces);
    [ExtensionAttribute]
public static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool InheritsFromOrImplementsOrEqualsIgnoringConstruction(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool InheritsFromIgnoringConstruction(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool ImplementsIgnoringConstruction(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsFormattableStringOrIFormattable(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsUnexpressibleTypeParameterConstraint(ITypeSymbol typeSymbol, bool allowDelegateAndEnumConstraints);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNumericType(ITypeSymbol type);
    [ExtensionAttribute]
public static Accessibility DetermineMinimalAccessibility(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContainsAnonymousType(ITypeSymbol symbol);
    private static bool ContainsAnonymousType(INamedTypeSymbol type);
    [ExtensionAttribute]
public static string CreateParameterName(ITypeSymbol type, bool capitalize);
    private static string GetParameterName(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSpecialType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool CanSupportCollectionInitializer(ITypeSymbol typeSymbol, ISymbol within);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static INamedTypeSymbol GetDelegateType(ITypeSymbol typeSymbol, Compilation compilation);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAccessibleMembersInBaseTypes(ITypeSymbol containingType, ISymbol within);
    [ExtensionAttribute]
public static ImmutableArray`1<T> GetAccessibleMembersInThisAndBaseTypes(ITypeSymbol containingType, ISymbol within);
    [ExtensionAttribute]
public static ImmutableArray`1<T> GetAccessibleMembersInThisAndBaseTypes(ITypeSymbol containingType, string memberName, ISymbol within);
    [ExtensionAttribute]
public static Nullable`1<bool> AreMoreSpecificThan(IList`1<ITypeSymbol> t1, IList`1<ITypeSymbol> t2);
    [ExtensionAttribute]
public static IEnumerable`1<T> SelectAccessibleMembers(IEnumerable`1<ITypeSymbol> types, ISymbol within);
    [ExtensionAttribute]
private static IEnumerable`1<T> SelectAccessibleMembers(IEnumerable`1<ITypeSymbol> types, string memberName, ISymbol within);
    [ExtensionAttribute]
private static Nullable`1<bool> IsMoreSpecificThan(ITypeSymbol t1, ITypeSymbol t2);
    [ExtensionAttribute]
public static bool IsOrDerivesFromExceptionType(ITypeSymbol type, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEnumType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEnumType(ITypeSymbol type, INamedTypeSymbol& enumType);
    [ExtensionAttribute]
public static Nullable`1<bool> IsMutableValueType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDisposable(ITypeSymbol type, ITypeSymbol iDisposableType);
    [ExtensionAttribute]
public static ITypeSymbol WithNullableAnnotationFrom(ITypeSymbol type, ITypeSymbol symbolForNullableAnnotation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol RemoveNullableIfPresent(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSpanOrReadOnlySpan(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSpan(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReadOnlySpan(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInlineArray(ITypeSymbol type);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.LinkedListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddRangeAtHead(LinkedList`1<T> list, IEnumerable`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ListExtensions : object {
    [ExtensionAttribute]
public static void RemoveOrTransformAll(List`1<T> list, Func`3<T, TArg, T> transform, TArg arg);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void RemoveOrTransformAll(List`1<T> list, Func`3<T, TArg, Nullable`1<T>> transform, TArg arg);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void RemoveOrTransformAll(ArrayBuilder`1<T> list, Func`3<T, TArg, Nullable`1<T>> transform, TArg arg);
    [ExtensionAttribute]
public static bool TryRemoveFirst(IList`1<T> list, Func`3<T, TArg, bool> selector, TArg arg, T& removedItem);
    [ExtensionAttribute]
public static int IndexOf(IList`1<T> list, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static int IndexOf(IList`1<T> list, Func`3<T, TArg, bool> predicate, TArg arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.LocationExtensions : object {
    [ExtensionAttribute]
public static SyntaxTree GetSourceTreeOrThrow(Location location);
    [ExtensionAttribute]
public static SyntaxToken FindToken(Location location, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, bool getInnermostNodeForTie, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, bool findInsideTrivia, bool getInnermostNodeForTie, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsVisibleSourceLocation(Location loc);
    [ExtensionAttribute]
public static bool IntersectsWith(Location loc1, Location loc2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.MethodKindExtensions : object {
    [ExtensionAttribute]
public static bool IsPropertyAccessor(MethodKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static string GetTypeDisplayName(object obj);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TDerivedType39, TResult> matchFunc39, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TDerivedType39, TResult> matchFunc39, Func`2<TDerivedType40, TResult> matchFunc40, Func`2<TBaseType, TResult> defaultFunc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ObjectReaderExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> ReadArray(ObjectReader reader, Func`2<ObjectReader, T> read);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ReadArray(ObjectReader reader, Func`3<ObjectReader, TArg, T> read, TArg arg);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ObjectWriterExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void WriteArray(ObjectWriter writer, ImmutableArray`1<T> values, Action`2<ObjectWriter, T> write);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.PredefinedTypeExtensions : object {
    [ExtensionAttribute]
public static SpecialType ToSpecialType(PredefinedType predefinedType);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SemanticEquivalence : object {
    public static bool AreEquivalent(SemanticModel semanticModel, SyntaxNode node1, SyntaxNode node2);
    public static bool AreEquivalent(SemanticModel semanticModel1, SemanticModel semanticModel2, SyntaxNode node1, SyntaxNode node2, Func`2<SyntaxNode, bool> predicate);
    private static bool AreSemanticallyEquivalentWorker(SemanticModel semanticModel1, SemanticModel semanticModel2, SyntaxNode node1, SyntaxNode node2, Func`2<SyntaxNode, bool> predicate);
    private static bool IsInstanceMemberReference(IOperation operation);
    private static bool AreEquals(SemanticModel semanticModel1, SemanticModel semanticModel2, SymbolInfo info1, SymbolInfo info2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions : object {
    private static string DefaultBuiltInParameterName;
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeRequiredDataFlow(SemanticModel semanticModel, SyntaxNode statementOrExpression);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeRequiredDataFlow(SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeRequiredControlFlow(SemanticModel semanticModel, SyntaxNode statement);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeRequiredControlFlow(SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    [ExtensionAttribute]
public static ISymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IOperation GetRequiredOperation(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetRequiredEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TSymbol GetEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetEnclosingNamedTypeOrAssembly(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetEnclosingNamedType(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamespaceSymbol GetEnclosingNamespace(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetExistingSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken, Func`2<SyntaxNode, bool> descendInto);
    [ExtensionAttribute]
public static SemanticModel GetOriginalSemanticModel(SemanticModel semanticModel);
    [ExtensionAttribute]
public static HashSet`1<ISymbol> GetAllDeclaredSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken, Func`2<SyntaxNode, bool> filter);
    private static void GetAllDeclaredSymbols(SemanticModel semanticModel, SyntaxNode node, HashSet`1<ISymbol> symbols, CancellationToken cancellationToken, Func`2<SyntaxNode, bool> descendInto);
    [ExtensionAttribute]
public static string GenerateNameFromType(SemanticModel semanticModel, ITypeSymbol type, ISyntaxFacts syntaxFacts, bool capitalize);
    [ExtensionAttribute]
private static bool ShouldPluralize(SemanticModel semanticModel, ITypeSymbol type);
    private static bool TryGeneratePluralizedNameFromTypeArgument(ISyntaxFacts syntaxFacts, ImmutableArray`1<ITypeSymbol> typeArguments, bool capitalize, String& parameterName);
    public static string Pluralize(string word);
    [ExtensionAttribute]
public static ITypeSymbol GetType(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <GetAllDeclaredSymbols>g__ShouldDescendInto|16_0(SyntaxNode node, Func`2<SyntaxNode, bool> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions : object {
    [ExtensionAttribute]
public static string GetLeadingWhitespaceOfLineAtPosition(SourceText text, int position);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SourceText text, TextSpan span, Func`3<int, CancellationToken, bool> isPositionHidden, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryOverlapsHiddenPosition(SourceText text, TextSpan span, Func`3<int, CancellationToken, bool> isPositionHidden, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool AreOnSameLine(SourceText text, SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool AreOnSameLine(SourceText text, int pos1, int pos2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static PredefinedType ToPredefinedType(SpecialType specialType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StackExtensions : object {
    [ExtensionAttribute]
public static bool TryPop(Stack`1<T> stack, T& result);
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, HashSet`1<T> values);
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, ImmutableArray`1<T> values);
    [ExtensionAttribute]
internal static void PushReverse(Stack`1<T> stack, IList`1<U> range);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(string line);
    [ExtensionAttribute]
public static Nullable`1<int> GetLastNonWhitespaceOffset(string line);
    [ExtensionAttribute]
public static string GetLeadingWhitespace(string lineText);
    [ExtensionAttribute]
public static string GetTrailingWhitespace(string lineText);
    [ExtensionAttribute]
public static int GetTextColumn(string text, int tabSize, int initialColumn);
    [ExtensionAttribute]
public static int ConvertTabToSpace(string textSnippet, int tabSize, int initialColumn, int endPosition);
    [ExtensionAttribute]
public static int IndexOf(string text, Func`2<char, bool> predicate);
    [ExtensionAttribute]
public static string GetFirstLineText(string text);
    [ExtensionAttribute]
public static string GetLastLineText(string text);
    [ExtensionAttribute]
public static bool ContainsLineBreak(string text);
    [ExtensionAttribute]
public static int GetNumberOfLineBreaks(string text);
    [ExtensionAttribute]
public static bool ContainsTab(string text);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SymbolDisplayPart> ToSymbolDisplayParts(string text);
    [ExtensionAttribute]
public static int GetColumnOfFirstNonWhitespaceCharacterOrEndOfLine(string line, int tabSize);
    [ExtensionAttribute]
public static int GetColumnFromLineOffset(string line, int endPosition, int tabSize);
    [ExtensionAttribute]
public static int GetLineOffsetFromColumn(string line, int column, int tabSize);
    [ExtensionAttribute]
public static void AppendToAliasNameSet(string alias, Builder<string> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats : object {
    public static SymbolDisplayFormat NameFormat;
    public static SymbolDisplayFormat SignatureFormat;
    private static SymbolDisplayFormats();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayPartExtensions : object {
    [ExtensionAttribute]
public static string GetFullText(IEnumerable`1<SymbolDisplayPart> parts);
    [ExtensionAttribute]
public static void AddLineBreak(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddMethodName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddPunctuation(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddSpace(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddText(IList`1<SymbolDisplayPart> parts, string text);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolInfoExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetAllSymbols(SymbolInfo info);
    [ExtensionAttribute]
private static ImmutableArray`1<ISymbol> GetAllSymbolsWorker(SymbolInfo info);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetAnySymbol(SymbolInfo info);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SymbolInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions : object {
    private static Func`3<SyntaxTriviaList, int, SyntaxToken> s_findSkippedTokenForward;
    private static Func`3<SyntaxTriviaList, int, SyntaxToken> s_findSkippedTokenBackward;
    private static SyntaxNodeExtensions();
    [ExtensionAttribute]
public static SyntaxNode GetRequiredParent(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNodeOrToken> DepthFirstTraversal(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> DepthFirstTraversalNodes(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestors>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestors(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestors>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetAncestors(SyntaxNode node);
    [ExtensionAttribute]
public static TNode GetAncestor(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TNode GetAncestorOrThis(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestorsOrThis>d__7`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetAncestorsOrThis(SyntaxNode node);
    [ExtensionAttribute]
public static bool HasAncestor(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<Traverse>d__9`1")]
[ExtensionAttribute]
public static IEnumerable`1<TSyntaxNode> Traverse(SyntaxNode node, TextSpan searchSpan, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static bool CheckParent(SyntaxNode node, Func`2<T, bool> valueChecker);
    [ExtensionAttribute]
public static bool IsChildNode(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static bool IsFoundUnder(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static SyntaxNode GetCommonRoot(SyntaxNode node1, SyntaxNode node2);
    [ExtensionAttribute]
public static int Width(SyntaxNode node);
    [ExtensionAttribute]
public static int FullWidth(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static SyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static TSyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static TextSpan GetContainedSpan(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode node, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode declaration, SyntaxNode startNode, SyntaxNode endNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAnnotatedNodes(SyntaxNode node, SyntaxAnnotation syntaxAnnotation);
    [ExtensionAttribute]
public static Task`1<TRootNode> ReplaceNodesAsync(TRootNode root, IEnumerable`1<SyntaxNode> nodes, Func`4<SyntaxNode, SyntaxNode, CancellationToken, Task`1<SyntaxNode>> computeReplacementAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TRootNode> ReplaceTokensAsync(TRootNode root, IEnumerable`1<SyntaxToken> tokens, Func`4<SyntaxToken, SyntaxToken, CancellationToken, Task`1<SyntaxToken>> computeReplacementAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TRoot> ReplaceTriviaAsync(TRoot root, IEnumerable`1<SyntaxTrivia> trivia, Func`4<SyntaxTrivia, SyntaxTrivia, CancellationToken, Task`1<SyntaxTrivia>> computeReplacementAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<ReplaceSyntaxAsync>d__27`1")]
[ExtensionAttribute]
public static Task`1<TRoot> ReplaceSyntaxAsync(TRoot root, IEnumerable`1<SyntaxNode> nodes, Func`4<SyntaxNode, SyntaxNode, CancellationToken, Task`1<SyntaxNode>> computeReplacementNodeAsync, IEnumerable`1<SyntaxToken> tokens, Func`4<SyntaxToken, SyntaxToken, CancellationToken, Task`1<SyntaxToken>> computeReplacementTokenAsync, IEnumerable`1<SyntaxTrivia> trivia, Func`4<SyntaxTrivia, SyntaxTrivia, CancellationToken, Task`1<SyntaxTrivia>> computeReplacementTriviaAsync, CancellationToken cancellationToken);
    private static SyntaxToken FindSkippedTokenForward(SyntaxTriviaList triviaList, int position);
    private static SyntaxToken FindSkippedTokenBackward(SyntaxTriviaList triviaList, int position);
    private static SyntaxToken GetInitialToken(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnRightOfPosition(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static T With(T node, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia);
    [ExtensionAttribute]
public static SyntaxToken WithoutLeadingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrailingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxNode FindNode(SyntaxNode root, Nullable`1<TextSpan> span, bool findInTrivia, bool getInnermostNodeForTie);
    [ExtensionAttribute]
public static SyntaxNode GetParent(SyntaxNode node, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static TNode FirstAncestorOrSelfUntil(SyntaxNode node, Func`2<SyntaxNode, bool> predicate);
    public static DirectiveInfo`1<TDirectiveTriviaSyntax> GetDirectiveInfoForRoot(SyntaxNode root, ISyntaxKinds syntaxKinds, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueAncestorsAndSelfEnumerable ValueAncestorsAndSelf(SyntaxNode syntaxNode, bool ascendOutOfTrivia);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FindInnermostCommonNode>g__FindCommonAncestor|17_0(SyntaxNode node, HashSet`1<SyntaxNode> commonAncestorsSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeOrTokenExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool AsNode(SyntaxNodeOrToken nodeOrToken, SyntaxNode& node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeOrTokenExtensions/<DepthFirstTraversal>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNodeOrToken> DepthFirstTraversal(SyntaxNodeOrToken node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeOrTokenExtensions/<DepthFirstTraversalNodes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> DepthFirstTraversalNodes(SyntaxNodeOrToken node);
    public static SyntaxTrivia[] GetTrivia(SyntaxNodeOrToken[] nodesOrTokens);
    [ExtensionAttribute]
public static SyntaxNodeOrToken WithAppendedTrailingTrivia(SyntaxNodeOrToken nodeOrToken, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static SyntaxNodeOrToken WithAppendedTrailingTrivia(SyntaxNodeOrToken nodeOrToken, IEnumerable`1<SyntaxTrivia> trivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode GetAncestor(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static T GetAncestor(SyntaxToken token, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T GetRequiredAncestor(SyntaxToken token, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAncestors(SyntaxToken token);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestors(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode GetCommonRoot(SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool CheckParent(SyntaxToken token, Func`2<T, bool> valueChecker);
    [ExtensionAttribute]
public static int Width(SyntaxToken token);
    [ExtensionAttribute]
public static int FullWidth(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken FindTokenFromEnd(SyntaxNode root, int position, bool includeZeroWidth, bool findInsideTrivia);
    [ExtensionAttribute]
public static SyntaxToken GetNextTokenOrEndOfFile(SyntaxToken token, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken With(SyntaxToken token, SyntaxTriviaList leading, SyntaxTriviaList trailing);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxToken WithAppendedTrailingTrivia(SyntaxToken token, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static SyntaxToken WithAppendedTrailingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxTrivia[] GetTrivia(IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
public static SyntaxNode GetRequiredParent(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxTree tree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsScript(SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingWordAsync(SyntaxTree syntaxTree, int position, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingTokenAsync(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool findInsideTrivia);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions/<GetTouchingTokenAsync>d__4")]
[ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingTokenAsync(SyntaxTree syntaxTree, int position, Predicate`1<SyntaxToken> predicate, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static bool IsEntirelyHidden(SyntaxTree tree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsBeforeFirstToken(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOrEndToken(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static SyntaxTrivia FindTriviaAndAdjustForEndOfFile(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnRightOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static bool IsGeneratedCode(SyntaxTree syntaxTree, AnalyzerOptions analyzerOptions, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(SyntaxTree syntaxTree, Nullable`1<TextSpan> span, bool findInTrivia, bool getInnermostNodeForTie, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTriviaExtensions : object {
    [ExtensionAttribute]
public static int Width(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static int FullWidth(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsElastic(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxTrivia AsElastic(SyntaxTrivia trivia);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTriviaListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> FirstOrNull(SyntaxTriviaList triviaList, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
public static SyntaxTrivia LastOrDefault(SyntaxTriviaList triviaList);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetLastNonWhitespacePosition(TextLine line);
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespacePosition(TextLine line);
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(TextLine line);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetLeadingWhitespace(TextLine line);
    [ExtensionAttribute]
public static bool IsEmptyOrWhitespace(TextLine line);
    [ExtensionAttribute]
public static int GetColumnOfFirstNonWhitespaceCharacterOrEndOfLine(TextLine line, int tabSize);
    [ExtensionAttribute]
public static int GetColumnFromLineOffset(TextLine line, int lineOffset, int tabSize);
    [ExtensionAttribute]
public static int GetLineOffsetFromColumn(TextLine line, int column, int tabSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TextSpan> ToNormalizedSpans(IEnumerable`1<TextSpan> spans);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<TextSpan> ToNormalizedSpans(ImmutableArray`1<TextSpan> spans);
    [ExtensionAttribute]
public static TextSpan Collapse(IEnumerable`1<TextSpan> spans);
    [ExtensionAttribute]
public static bool IsAround(TextSpan span, SyntaxNodeOrToken node);
    [ExtensionAttribute]
public static bool IsAround(TextSpan span, SyntaxNodeOrToken startNode, SyntaxNodeOrToken endNode);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions/<Subtract>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<TextSpan> Subtract(TextSpan span, TextSpan except);
    [ExtensionAttribute]
public static IEnumerable`1<TextSpan> Subtract(IEnumerable`1<TextSpan> spans, TextSpan except);
}
internal static class Microsoft.CodeAnalysis.Shared.Helpers.RemoveUnnecessaryImports.RemoveUnnecessaryImportsHelpers : object {
    [NullableContextAttribute("1")]
public static SyntaxToken StripNewLines(ISyntaxFacts syntaxFacts, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection : ReadOnlyCollection`1<TextSpan> {
    public NormalizedTextSpanCollection(TextSpan span);
    public NormalizedTextSpanCollection(IEnumerable`1<TextSpan> spans);
    private NormalizedTextSpanCollection(OrderedSpanList normalizedSpans);
    public static NormalizedTextSpanCollection Union(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Overlap(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Intersection(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Difference(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    [NullableContextAttribute("2")]
public static bool op_Equality(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public bool OverlapsWith(NormalizedTextSpanCollection set);
    public bool OverlapsWith(TextSpan span);
    public bool IntersectsWith(NormalizedTextSpanCollection set);
    public bool IntersectsWith(TextSpan span);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    private static IList`1<TextSpan> ListFromSpan(TextSpan span);
    private static void UpdateSpanUnion(TextSpan span, IList`1<TextSpan> spans, Int32& start, Int32& end);
    private static IList`1<TextSpan> NormalizeSpans(IEnumerable`1<TextSpan> spans);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IExpeditableDelaySource {
    public abstract virtual Task`1<bool> Delay(TimeSpan delay, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions : object {
    [ExtensionAttribute]
public static NoThrowTaskAwaitable NoThrowAwaitableInternal(Task task, bool captureContext);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.TestHooks.ValueTaskExtensions : object {
    [ExtensionAttribute]
public static NoThrowValueTaskAwaitable NoThrowAwaitableInternal(ValueTask task, bool captureContext);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static NoThrowValueTaskAwaitable`1<TResult> NoThrowAwaitableInternal(ValueTask`1<TResult> task, bool captureContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8 : object {
    private TExpressionSyntax _expression;
    private TExpressionSyntax _newExpressionForReplace;
    private SemanticModel _semanticModel;
    private CancellationToken _cancellationToken;
    private bool _skipVerificationForReplacedNode;
    private bool _failOnOverloadResolutionFailuresInOriginalCode;
    private bool _isNewSemanticModelSpeculativeModel;
    [NullableAttribute("2")]
private SyntaxNode _lazySemanticRootOfOriginalExpression;
    [NullableAttribute("2")]
private TExpressionSyntax _lazyReplacedExpression;
    [NullableAttribute("2")]
private SyntaxNode _lazySemanticRootOfReplacedExpression;
    [NullableAttribute("2")]
private SemanticModel _lazySpeculativeSemanticModel;
    private static SymbolEquivalenceComparer s_includeNullabilityComparer;
    protected ISyntaxFacts SyntaxFactsService { get; }
    public TExpressionSyntax OriginalExpression { get; }
    private SyntaxNode Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalExpression { get; }
    public SyntaxNode SemanticRootOfOriginalExpression { get; }
    public SemanticModel OriginalSemanticModel { get; }
    public TExpressionSyntax ReplacedExpression { get; }
    private SyntaxNode Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.ReplacedExpression { get; }
    public SyntaxNode SemanticRootOfReplacedExpression { get; }
    public SemanticModel SpeculativeSemanticModel { get; }
    public CancellationToken CancellationToken { get; }
    public AbstractSpeculationAnalyzer`8(TExpressionSyntax expression, TExpressionSyntax newExpression, SemanticModel semanticModel, CancellationToken cancellationToken, bool skipVerificationForReplacedNode, bool failOnOverloadResolutionFailuresInOriginalCode);
    private static AbstractSpeculationAnalyzer`8();
    protected abstract virtual ISyntaxFacts get_SyntaxFactsService();
    [NullableContextAttribute("2")]
protected abstract virtual bool CanAccessInstanceMemberThrough(TExpressionSyntax expression);
    public TExpressionSyntax get_OriginalExpression();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.get_OriginalExpression();
    public SyntaxNode get_SemanticRootOfOriginalExpression();
    public sealed virtual SemanticModel get_OriginalSemanticModel();
    public TExpressionSyntax get_ReplacedExpression();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.get_ReplacedExpression();
    public SyntaxNode get_SemanticRootOfReplacedExpression();
    public sealed virtual SemanticModel get_SpeculativeSemanticModel();
    public CancellationToken get_CancellationToken();
    protected abstract virtual SyntaxNode GetSemanticRootForSpeculation(TExpressionSyntax expression);
    protected virtual SyntaxNode GetSemanticRootOfReplacedExpression(SyntaxNode semanticRootOfOriginalExpression, TExpressionSyntax annotatedReplacedExpression);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void EnsureReplacedExpressionAndSemanticRoot();
    [ConditionalAttribute("DEBUG")]
protected abstract virtual void ValidateSpeculativeSemanticModel(SemanticModel speculativeSemanticModel, SyntaxNode nodeToSpeculate);
    [MemberNotNullAttribute("_lazySpeculativeSemanticModel")]
private void EnsureSpeculativeSemanticModel();
    protected abstract virtual SemanticModel CreateSpeculativeSemanticModel(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    protected virtual bool ReplacementIntroducesDisallowedNullType(TExpressionSyntax originalExpression, TExpressionSyntax newExpression, TypeInfo originalTypeInfo, TypeInfo newTypeInfo);
    protected bool TypesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool ConvertedTypesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool ImplicitConversionsAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    private bool ImplicitConversionsAreCompatible(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType);
    protected abstract virtual bool ConversionsAreCompatible(SemanticModel model1, TExpressionSyntax expression1, SemanticModel model2, TExpressionSyntax expression2);
    protected abstract virtual bool ConversionsAreCompatible(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType);
    protected bool SymbolsAreCompatible(SyntaxNode originalNode, SyntaxNode newNode, bool requireNonNullSymbols);
    public static bool SymbolInfosAreCompatible(SymbolInfo originalSymbolInfo, SymbolInfo newSymbolInfo, bool performEquivalenceCheck, bool requireNonNullSymbols);
    protected bool SymbolInfosAreCompatible(SymbolInfo originalSymbolInfo, SymbolInfo newSymbolInfo, bool requireNonNullSymbols);
    [NullableContextAttribute("2")]
protected bool SymbolsAreCompatible(ISymbol symbol, ISymbol newSymbol, bool requireNonNullSymbols);
    [NullableContextAttribute("2")]
private static bool SymbolsAreCompatibleCore(ISymbol symbol, ISymbol newSymbol, bool performEquivalenceCheck, bool requireNonNullSymbols);
    private static bool CompareAcrossSemanticModels(ISymbol symbol, ISymbol newSymbol);
    private static bool EnumTypesAreCompatible(INamedTypeSymbol type1, INamedTypeSymbol type2);
    public bool ReplacementChangesSemantics();
    [NullableContextAttribute("2")]
protected abstract virtual bool IsParenthesizedExpression(SyntaxNode node);
    protected bool ReplacementChangesSemantics(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode originalRoot, bool skipVerificationForCurrentNode);
    public bool SymbolsForOriginalAndReplacedNodesAreCompatible();
    protected abstract virtual bool ReplacementChangesSemanticsForNodeLanguageSpecific(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    private bool ReplacementChangesSemanticsForNode(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    [NullableContextAttribute("2")]
private bool MemberAccessesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    [NullableContextAttribute("2")]
private static bool IsStaticAccess(ISymbol symbol);
    [NullableContextAttribute("2")]
private bool InvocationsAreCompatible(TInvocationExpressionSyntax originalInvocation, TInvocationExpressionSyntax newInvocation);
    private bool ReplacementBreaksSystemObjectMethodResolution(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    [NullableContextAttribute("2")]
private static bool IsSymbolSystemObjectInstanceMethod(ISymbol symbol);
    private bool ReplacementBreaksAttribute(TAttributeSyntax attribute, TAttributeSyntax newAttribute);
    protected abstract virtual TExpressionSyntax GetForEachStatementExpression(TForEachStatementSyntax forEachStatement);
    protected abstract virtual bool IsForEachTypeInferred(TForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    private bool ReplacementBreaksForEachStatement(TForEachStatementSyntax forEachStatement, TForEachStatementSyntax newForEachStatement);
    protected abstract virtual bool ForEachConversionsAreCompatible(SemanticModel originalModel, TForEachStatementSyntax originalForEach, SemanticModel newModel, TForEachStatementSyntax newForEach);
    protected abstract virtual void GetForEachSymbols(SemanticModel model, TForEachStatementSyntax forEach, IMethodSymbol& getEnumeratorMethod, ITypeSymbol& elementType);
    private bool ReplacementBreaksForEachGetEnumerator(IMethodSymbol getEnumerator, IMethodSymbol newGetEnumerator, TExpressionSyntax newForEachStatementExpression);
    protected abstract virtual TExpressionSyntax GetThrowStatementExpression(TThrowStatementSyntax throwStatement);
    private bool ReplacementBreaksThrowStatement(TThrowStatementSyntax originalThrowStatement, TThrowStatementSyntax newThrowStatement);
    protected abstract virtual bool IsInNamespaceOrTypeContext(TExpressionSyntax node);
    private bool ReplacementBreaksTypeResolution(TTypeSyntax type, TTypeSyntax newType, bool useSpeculativeModel);
    [NullableContextAttribute("2")]
protected abstract virtual bool ExpressionMightReferenceMember(SyntaxNode node);
    private static bool IsDelegateInvoke(ISymbol symbol);
    private static bool IsAnonymousDelegateInvoke(ISymbol symbol);
    private bool ReplacementBreaksExpression(TExpressionSyntax expression, TExpressionSyntax newExpression);
    protected bool ReplacementBreaksCompoundAssignment(TExpressionSyntax originalLeft, TExpressionSyntax originalRight, TExpressionSyntax newLeft, TExpressionSyntax newRight);
    protected abstract virtual bool IsReferenceConversion(Compilation model, ITypeSymbol sourceType, ITypeSymbol targetType);
    private bool IsCompatibleInterfaceMemberImplementation(ISymbol symbol, ISymbol newSymbol, TExpressionSyntax originalExpression, TExpressionSyntax newExpression, SemanticModel speculativeSemanticModel);
    private bool IsReceiverNonUniquePossibleValueTypeParam(TExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsReceiverUniqueInstance(TExpressionSyntax receiver, SemanticModel semanticModel);
    protected abstract virtual ImmutableArray`1<TArgumentSyntax> GetArguments(TExpressionSyntax expression);
    protected abstract virtual TExpressionSyntax GetReceiver(TExpressionSyntax expression);
    private bool SymbolsHaveCompatibleParameterLists(ISymbol originalSymbol, ISymbol newSymbol, TExpressionSyntax originalInvocation);
    protected abstract virtual bool IsNamedArgument(TArgumentSyntax argument);
    protected abstract virtual string GetNamedArgumentIdentifierValueText(TArgumentSyntax argument);
    private bool AreCompatibleParameterLists(ImmutableArray`1<TArgumentSyntax> specifiedArguments, ImmutableArray`1<IParameterSymbol> signature1Parameters, ImmutableArray`1<IParameterSymbol> signature2Parameters);
    protected void GetConversions(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType, Nullable`1& originalConversion, Nullable`1& newConversion);
    protected abstract virtual TConversion ClassifyConversion(SemanticModel model, TExpressionSyntax expression, ITypeSymbol targetType);
    protected abstract virtual TConversion ClassifyConversion(SemanticModel model, ITypeSymbol originalType, ITypeSymbol targetType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.AliasSymbolCache : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<ValueTuple`2<SyntaxTree, int>, ImmutableDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol>>> s_treeAliasMap;
    private static AliasSymbolCache();
    public static bool TryGetAliasSymbol(SemanticModel semanticModel, int namespaceId, INamespaceOrTypeSymbol targetSymbol, IAliasSymbol& aliasSymbol);
    public static void AddAliasSymbols(SemanticModel semanticModel, int namespaceId, IEnumerable`1<IAliasSymbol> aliasSymbols);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.Base64Utilities : object {
    private static byte EncodingPad;
    private static ReadOnlySpan`1<sbyte> DecodingMap { get; }
    private static ReadOnlySpan`1<sbyte> get_DecodingMap();
    [ExtensionAttribute]
private static bool IsSpace(char c);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
    private static int Decode(Char& encodedChars, SByte& decodingMap);
    public static bool TryFromBase64Chars(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    private static void CopyToTempBufferWithoutWhiteSpace(ReadOnlySpan`1<char> chars, Span`1<char> tempBuffer, Int32& consumed, Int32& charsWritten);
    private static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> utf16, Span`1<byte> bytes, Int32& consumed, Int32& written);
    public static bool TryGetDecodedLength(string encodedString, Int32& decodedLength);
    private static int GetPadding(string attributeData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers : object {
    public static Comparison`1<SuppressOperation> SuppressOperationComparer;
    public static Comparison`1<IndentBlockOperation> IndentBlockOperationComparer;
    private static CommonFormattingHelpers();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers/<ConvertToTokenPairs>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> ConvertToTokenPairs(SyntaxNode root, IReadOnlyList`1<TextSpan> spans);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> ConvertToTokenPair(SyntaxNode root, TextSpan textSpan);
    [ExtensionAttribute]
public static bool IsInvalidTokenRange(SyntaxNode root, SyntaxToken startToken, SyntaxToken endToken);
    [ExtensionAttribute]
public static int GetTokenColumn(SyntaxTree tree, SyntaxToken token, int tabSize);
    [ExtensionAttribute]
public static string GetText(SourceText text, SyntaxToken token1, SyntaxToken token2);
    public static string GetTextBetween(SyntaxToken token1, SyntaxToken token2);
    public static void AppendTextBetween(SyntaxToken token1, SyntaxToken token2, StringBuilder builder);
    private static void AppendTextBetweenTwoAdjacentTokens(SyntaxToken token1, SyntaxToken token2, StringBuilder builder);
    private static void AppendLeadingTriviaText(SyntaxToken token, StringBuilder builder);
    private static void AppendPartialLeadingTriviaText(SyntaxToken token, StringBuilder builder, int token1FullSpanEnd);
    private static void AppendTrailingTriviaText(SyntaxToken token, StringBuilder builder);
    public static TextSpan GetSpanIncludingTrailingAndLeadingTriviaOfAdjacentTokens(SyntaxToken startToken, SyntaxToken endToken);
    private static int GetEndPositionOfSpan(SyntaxToken token);
    public static int GetStartPositionOfSpan(SyntaxToken token);
    [NullableContextAttribute("2")]
private static SyntaxNode GetParentThatContainsGivenSpan(SyntaxNode node, int position, bool forward);
    public static bool HasAnyWhitespaceElasticTrivia(SyntaxToken previousToken, SyntaxToken currentToken);
    public static TextSpan GetFormattingSpan(SyntaxNode root, TextSpan span);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Utilities.DeserializationConstructorCheck : ValueType {
    private INamedTypeSymbol _iSerializableType;
    private INamedTypeSymbol _serializationInfoType;
    private INamedTypeSymbol _streamingContextType;
    [NullableContextAttribute("1")]
public DeserializationConstructorCheck(Compilation compilation);
    [NullableContextAttribute("1")]
public bool IsDeserializationConstructor(IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer : ValueType {
    private Compilation _compilation;
    private IMethodSymbol _objectGetHashCodeMethod;
    [NullableAttribute("2")]
private INamedTypeSymbol _equalityComparerType;
    public INamedTypeSymbol SystemHashCodeType;
    private HashCodeAnalyzer(Compilation compilation, IMethodSymbol objectGetHashCodeMethod, INamedTypeSymbol equalityComparerType, INamedTypeSymbol systemHashCodeType);
    public static bool TryGetAnalyzer(Compilation compilation, HashCodeAnalyzer& analyzer);
    [NullableContextAttribute("2")]
public ValueTuple`3<bool, ImmutableArray`1<ISymbol>, ImmutableArray`1<IOperation>> GetHashedMembers(ISymbol owningSymbol, IOperation operation);
    private Nullable`1<ValueTuple`2<bool, ImmutableArray`1<ISymbol>>> MatchTuplePattern(IMethodSymbol method, ImmutableArray`1<IOperation> statements);
    private Nullable`1<ValueTuple`2<bool, ImmutableArray`1<ISymbol>>> MatchAccumulatorPattern(IMethodSymbol method, ImmutableArray`1<IOperation> statements);
    [NullableContextAttribute("2")]
private bool OverridesSystemObject(IMethodSymbol method);
    private static bool IsLocalReference(IOperation value, ILocalSymbol accumulatorVariable);
    private static bool IsLiteralNumber(IOperation value);
    private static IOperation Unwrap(IOperation value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.IntegerUtilities : object {
    public static int CountOfBitsSet(long v);
    [NullableContextAttribute("1")]
public static bool HasOneBitSet(IComparable value);
    public static bool HasOneBitSet(long v);
    public static int LogBase2(long v);
    public static long Convert(long v, SpecialType type);
    public static ulong ToUnsigned(long v);
    public static ulong ToUInt64(object o);
    public static long ToInt64(object o);
    public static bool IsIntegral(object value);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.InterceptsLocationUtilities : object {
    public static ImmutableArray`1<InterceptsLocationData> GetInterceptsLocationData(ImmutableArray`1<AttributeData> attributes);
    public static bool TryGetInterceptsLocationData(AttributeData attribute, InterceptsLocationData& result);
    private static bool TryGetInterceptsLocationDataVersion1(string attributeData, InterceptsLocationData& result);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer {
    public SyntaxNode OriginalExpression { get; }
    public SyntaxNode ReplacedExpression { get; }
    public SemanticModel OriginalSemanticModel { get; }
    public SemanticModel SpeculativeSemanticModel { get; }
    public abstract virtual SyntaxNode get_OriginalExpression();
    public abstract virtual SyntaxNode get_ReplacedExpression();
    public abstract virtual SemanticModel get_OriginalSemanticModel();
    public abstract virtual SemanticModel get_SpeculativeSemanticModel();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.Matcher : object {
    public static Matcher`1<T> Repeat(Matcher`1<T> matcher);
    public static Matcher`1<T> OneOrMore(Matcher`1<T> matcher);
    public static Matcher`1<T> Choice(Matcher`1[] matchers);
    public static Matcher`1<T> Sequence(Matcher`1[] matchers);
    public static Matcher`1<T> Single(Func`2<T, bool> predicate, string description);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.Matcher`1 : object {
    public abstract virtual bool TryMatch(IList`1<T> sequence, Int32& index);
    internal static Matcher`1<T> Repeat(Matcher`1<T> matcher);
    internal static Matcher`1<T> OneOrMore(Matcher`1<T> matcher);
    internal static Matcher`1<T> Choice(Matcher`1[] matchers);
    internal static Matcher`1<T> Sequence(Matcher`1[] matchers);
    internal static Matcher`1<T> Single(Func`2<T, bool> predicate, string description);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.PathMetadataUtilities : object {
    private static Char[] NamespaceSeparatorArray;
    private static PathMetadataUtilities();
    public static string TryBuildNamespaceFromFolders(IEnumerable`1<string> folders, ISyntaxFacts syntaxFacts, string rootNamespace);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<string> BuildFoldersFromNamespace(string namespace, string rootNamespace);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SignatureComparer : object {
    public static SignatureComparer Instance;
    public static SignatureComparer IgnoreAssembliesInstance;
    private SymbolEquivalenceComparer _symbolEquivalenceComparer;
    private IEqualityComparer`1<IParameterSymbol> ParameterEquivalenceComparer { get; }
    private IEqualityComparer`1<ITypeSymbol> SignatureTypeEquivalenceComparer { get; }
    private SignatureComparer(SymbolEquivalenceComparer symbolEquivalenceComparer);
    private static SignatureComparer();
    private IEqualityComparer`1<IParameterSymbol> get_ParameterEquivalenceComparer();
    private IEqualityComparer`1<ITypeSymbol> get_SignatureTypeEquivalenceComparer();
    public bool HaveSameSignature(ISymbol symbol1, ISymbol symbol2, bool caseSensitive);
    private static bool HaveSameSignature(IEventSymbol event1, IEventSymbol event2, bool caseSensitive);
    public bool HaveSameSignature(IPropertySymbol property1, IPropertySymbol property2, bool caseSensitive);
    private static bool BadPropertyAccessor(IMethodSymbol method1, IMethodSymbol method2);
    public bool HaveSameSignature(IMethodSymbol method1, IMethodSymbol method2, bool caseSensitive, bool compareParameterName, bool isParameterCaseSensitive);
    private static bool IdentifiersMatch(string identifier1, string identifier2, bool caseSensitive);
    public bool HaveSameSignature(IList`1<IParameterSymbol> parameters1, IList`1<IParameterSymbol> parameters2);
    public bool HaveSameSignature(IList`1<IParameterSymbol> parameters1, IList`1<IParameterSymbol> parameters2, bool compareParameterName, bool isCaseSensitive);
    public bool HaveSameSignatureAndConstraintsAndReturnTypeAndAccessors(ISymbol symbol1, ISymbol symbol2, bool caseSensitive);
    private static bool HaveSameAccessors(IPropertySymbol property1, IPropertySymbol property2);
    private bool HaveSameSignatureAndConstraintsAndReturnType(IMethodSymbol method1, IMethodSymbol method2);
    private bool HaveSameConstraints(ITypeParameterSymbol typeParameter1, ITypeParameterSymbol typeParameter2);
    private bool HaveSameReturnType(IEventSymbol ev1, IEventSymbol ev2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker : object {
    [NullableContextAttribute("0")]
public static void AddWordParts(string identifier, TemporaryArray`1& parts);
    [NullableContextAttribute("0")]
public static void AddCharacterParts(string identifier, TemporaryArray`1& parts);
    [NullableContextAttribute("0")]
public static void AddParts(string text, bool word, TemporaryArray`1& parts);
    public static TextSpan GenerateSpan(string identifier, int wordStart, bool word);
    private static TextSpan ScanCharacterRun(string identifier, int length, int wordStart);
    private static TextSpan ScanWordRun(string identifier, int length, int wordStart);
    private static TextSpan ScanLowerCaseRun(string identifier, int length, int wordStart);
    private static TextSpan ScanNumber(string identifier, int length, int wordStart);
    private static int SkipPunctuation(string identifier, int length, int wordStart);
    private static bool IsLower(char c);
    private static bool IsAscii(char v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<EquivalenceVisitor> _equivalenceVisitors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<GetHashCodeVisitor> _getHashCodeVisitors;
    public static SymbolEquivalenceComparer Instance;
    public static SymbolEquivalenceComparer TupleNamesMustMatchInstance;
    public static SymbolEquivalenceComparer IgnoreAssembliesInstance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<IAssemblySymbol> _assemblyComparer;
    private bool _tupleNamesMustMatch;
    private bool _ignoreNullableAnnotations;
    private bool _objectAndDynamicCompareEqually;
    [CompilerGeneratedAttribute]
private ParameterSymbolEqualityComparer <ParameterEquivalenceComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureTypeSymbolEquivalenceComparer <SignatureTypeEquivalenceComparer>k__BackingField;
    public ParameterSymbolEqualityComparer ParameterEquivalenceComparer { get; }
    public SignatureTypeSymbolEquivalenceComparer SignatureTypeEquivalenceComparer { get; }
    public SymbolEquivalenceComparer(IEqualityComparer`1<IAssemblySymbol> assemblyComparer, bool distinguishRefFromOut, bool tupleNamesMustMatch, bool ignoreNullableAnnotations, bool objectAndDynamicCompareEqually);
    private static SymbolEquivalenceComparer();
    [CompilerGeneratedAttribute]
public ParameterSymbolEqualityComparer get_ParameterEquivalenceComparer();
    [CompilerGeneratedAttribute]
public SignatureTypeSymbolEquivalenceComparer get_SignatureTypeEquivalenceComparer();
    public static SymbolEquivalenceComparer Create(bool distinguishRefFromOut, bool tupleNamesMustMatch, bool ignoreNullableAnnotations, bool objectAndDynamicCompareEqually);
    private EquivalenceVisitor GetEquivalenceVisitor(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    private GetHashCodeVisitor GetGetHashCodeVisitor(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    private static int GetVisitorIndex(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    public bool ReturnTypeEquals(IMethodSymbol x, IMethodSymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ISymbol x, ISymbol y);
    [NullableContextAttribute("2")]
public bool Equals(ISymbol x, ISymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    [NullableContextAttribute("2")]
private bool EqualsCore(ISymbol x, ISymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(ISymbol x);
    private static ISymbol UnwrapAlias(ISymbol symbol);
    private static SymbolKind GetKindAndUnwrapAlias(ISymbol& symbol);
    private static bool IsConstructedFromSelf(INamedTypeSymbol symbol);
    private static bool IsConstructedFromSelf(IMethodSymbol symbol);
    private static bool IsObjectType(ISymbol symbol);
    private static bool CheckContainingType(IMethodSymbol x);
    private static OneOrMany`1<INamedTypeSymbol> Unwrap(INamedTypeSymbol namedType);
    private static bool IsPartialMethodDefinitionPart(IMethodSymbol symbol);
    private static bool IsPartialMethodImplementationPart(IMethodSymbol symbol);
    private static bool IsPartialMethodDefinitionPart(IPropertySymbol symbol);
    private static bool IsPartialMethodImplementationPart(IPropertySymbol symbol);
    private static TypeKind GetTypeKind(INamedTypeSymbol x);
    public static bool AreRefKindsEquivalent(RefKind rk1, RefKind rk2, bool distinguishRefFromOut);
    [CompilerGeneratedAttribute]
private void <.ctor>g__AddVisitors|16_0(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually, <>c__DisplayClass16_0& );
}
internal enum Microsoft.CodeAnalysis.Shared.Utilities.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SharedPoolExtensions : object {
    private static int Threshold;
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool, StringBuilder& builder);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Queue`1<TItem>> GetPooledObject(ObjectPool`1<Queue`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<SegmentedList`1<TItem>> GetPooledObject(ObjectPool`1<SegmentedList`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool, Stack`1& stack);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool, List`1& list);
    [ExtensionAttribute]
public static PooledObject`1<SegmentedList`1<TItem>> GetPooledObject(ObjectPool`1<SegmentedList`1<TItem>> pool, SegmentedList`1& list);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1& set);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2& dictionary);
    [ExtensionAttribute]
public static PooledObject`1<T> GetPooledObject(ObjectPool`1<T> pool);
    [ExtensionAttribute]
public static StringBuilder AllocateAndClear(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static Stack`1<T> AllocateAndClear(ObjectPool`1<Stack`1<T>> pool);
    [ExtensionAttribute]
public static Queue`1<T> AllocateAndClear(ObjectPool`1<Queue`1<T>> pool);
    [ExtensionAttribute]
public static HashSet`1<T> AllocateAndClear(ObjectPool`1<HashSet`1<T>> pool);
    [ExtensionAttribute]
public static SegmentedHashSet`1<T> AllocateAndClear(ObjectPool`1<SegmentedHashSet`1<T>> pool);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AllocateAndClear(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static List`1<T> AllocateAndClear(ObjectPool`1<List`1<T>> pool);
    [ExtensionAttribute]
public static SegmentedList`1<T> AllocateAndClear(ObjectPool`1<SegmentedList`1<T>> pool);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<HashSet`1<T>> pool, HashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<SegmentedHashSet`1<T>> pool, SegmentedHashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<ConcurrentSet`1<T>> pool, ConcurrentSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stack`1<T>> pool, Stack`1<T> stack);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<ConcurrentStack`1<T>> pool, ConcurrentStack`1<T> stack);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Queue`1<T>> pool, Queue`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<ConcurrentDictionary`2<TKey, TValue>> pool, ConcurrentDictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<List`1<T>> pool, List`1<T> list, bool trim);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<SegmentedList`1<T>> pool, SegmentedList`1<T> list, bool trim);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SharedPools : object {
    public static ObjectPool`1<HashSet`1<string>> StringIgnoreCaseHashSet;
    public static ObjectPool`1<HashSet`1<string>> StringHashSet;
    public static ObjectPool`1<Byte[]> ByteArray;
    public static int ByteBufferSize;
    private static int ByteBufferCount;
    private static SharedPools();
    public static ObjectPool`1<T> BigDefault();
    public static ObjectPool`1<T> Default();
    public static ObjectPool`1<Dictionary`2<string, T>> StringIgnoreCaseDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Simplification.AbstractSimplification : object {
    public SimplifierOptions DefaultOptions { get; }
    public abstract virtual SimplifierOptions get_DefaultOptions();
    public abstract virtual SimplifierOptions GetSimplifierOptions(IOptionsReader options, SimplifierOptions fallbackOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Simplification.AliasAnnotation : object {
    public static string Kind;
    public static string GetAliasName(SyntaxAnnotation annotation);
    public static SyntaxAnnotation Create(string aliasName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.DoNotAddImportsAnnotation : object {
    public static SyntaxAnnotation Annotation;
    public static string Kind;
    private static DoNotAddImportsAnnotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.DoNotAllowVarAnnotation : object {
    public static SyntaxAnnotation Annotation;
    public static string Kind;
    private static DoNotAllowVarAnnotation();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Simplification.ISimplification {
    public SimplifierOptions DefaultOptions { get; }
    public abstract virtual SimplifierOptions get_DefaultOptions();
    public abstract virtual SimplifierOptions GetSimplifierOptions(IOptionsReader options, SimplifierOptions fallbackOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.SimplifierOptions : object {
    public static CodeStyleOption2`1<bool> DefaultQualifyAccess;
    internal static SimplifierOptions CommonDefaults;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <QualifyFieldAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <QualifyPropertyAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <QualifyMethodAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <QualifyEventAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPredefinedTypeKeywordInMemberAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferPredefinedTypeKeywordInDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> QualifyFieldAccess { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> QualifyPropertyAccess { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> QualifyMethodAccess { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> QualifyEventAccess { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPredefinedTypeKeywordInMemberAccess { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferPredefinedTypeKeywordInDeclaration { get; public set; }
    private protected SimplifierOptions(IOptionsReader options, SimplifierOptions fallbackOptions, string language);
    [CompilerGeneratedAttribute]
protected SimplifierOptions(SimplifierOptions original);
    private static SimplifierOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_QualifyFieldAccess();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifyFieldAccess(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_QualifyPropertyAccess();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifyPropertyAccess(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_QualifyMethodAccess();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifyMethodAccess(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_QualifyEventAccess();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifyEventAccess(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPredefinedTypeKeywordInMemberAccess();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPredefinedTypeKeywordInMemberAccess(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferPredefinedTypeKeywordInDeclaration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferPredefinedTypeKeywordInDeclaration(CodeStyleOption2`1<bool> value);
    [NullableContextAttribute("2")]
public bool TryGetQualifyMemberAccessOption(SymbolKind symbolKind, CodeStyleOption2`1& option);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SimplifierOptions left, SimplifierOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SimplifierOptions left, SimplifierOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SimplifierOptions other);
    [CompilerGeneratedAttribute]
public virtual SimplifierOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.Simplification.SimplifierOptionsProvider {
}
internal static class Microsoft.CodeAnalysis.Simplification.SimplifierOptionsProviders : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.SpecialTypeAnnotation : object {
    public static string Kind;
    private static ConcurrentDictionary`2<SpecialType, string> s_fromSpecialTypes;
    private static ConcurrentDictionary`2<string, SpecialType> s_toSpecialTypes;
    private static SpecialTypeAnnotation();
    public static SyntaxAnnotation Create(SpecialType specialType);
    public static SpecialType GetSpecialType(SyntaxAnnotation annotation);
    private static string CreateFromSpecialTypes(SpecialType arg);
    private static SpecialType CreateToSpecialTypes(string arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.SymbolAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(ISymbol symbol);
    public static ISymbol GetSymbol(SyntaxAnnotation annotation, Compilation compilation);
    public static ImmutableArray`1<ISymbol> GetSymbols(SyntaxAnnotation annotation, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyBooleanExpression.AbstractSimplifyConditionalDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_takeCondition;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_negateCondition;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_takeConditionOrWhenFalse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_negateConditionAndWhenFalse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_negateConditionOrWhenTrue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_takeConditionAndWhenTrue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_takeConditionAndWhenFalse;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractSimplifyConditionalDiagnosticAnalyzer`3();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual CommonConversion GetConversion(SemanticModel semanticModel, TExpressionSyntax node, CancellationToken cancellationToken);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeConditionalExpression(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <AnalyzeConditionalExpression>g__ReportDiagnostic|13_0(ImmutableDictionary`2<string, string> properties, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsSimpleBooleanType|13_1(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsTrue|13_2(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsFalse|13_3(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsBoolValue|13_4(TExpressionSyntax node, bool value, <>c__DisplayClass13_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyBooleanExpressionConstants : object {
    public static string Negate;
    public static string Or;
    public static string And;
    public static string WhenTrue;
    public static string WhenFalse;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationDiagnosticAnalyzer`2 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    protected abstract virtual IVirtualCharService GetVirtualCharService();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInterpolation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationHelpers : object {
    protected bool PermitNonLiteralAlignmentComponents { get; }
    protected abstract virtual bool get_PermitNonLiteralAlignmentComponents();
    protected abstract virtual SyntaxNode GetPreservedInterpolationExpressionSyntax(IOperation operation);
    public void UnwrapInterpolation(IVirtualCharService virtualCharService, ISyntaxFacts syntaxFacts, IInterpolationOperation interpolation, TExpressionSyntax& unwrapped, TExpressionSyntax& alignment, Boolean& negate, String& formatString, ImmutableArray`1& unnecessaryLocations);
    [NullableContextAttribute("2")]
private static IOperation Unwrap(IOperation expression, bool towardsParent);
    private void UnwrapFormatString(IVirtualCharService virtualCharService, ISyntaxFacts syntaxFacts, IOperation expression, IOperation& unwrapped, String& formatString, List`1<TextSpan> unnecessarySpans);
    private static bool IsObjectToStringOverride(IMethodSymbol method);
    private static bool UsesInvariantCultureReferenceInsideFormattableStringInvariant(IInvocationOperation invocation, int formatProviderArgumentIndex);
    private static bool IsInvariantCultureReference(IOperation operation);
    private static bool IsInsideFormattableStringInvariant(IOperation operation);
    private static bool IsType(INamedTypeSymbol type, SemanticModel semanticModel);
    [NullableContextAttribute("2")]
private static INamedTypeSymbol FindType(SemanticModel semanticModel);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationHelpers/<AncestorsAndSelf>d__12")]
private static IEnumerable`1<IOperation> AncestorsAndSelf(IOperation operation);
    private static TextSpan GetSpanWithinLiteralQuotes(IVirtualCharService virtualCharService, SyntaxToken formatToken);
    private void UnwrapAlignmentPadding(IOperation expression, IOperation& unwrapped, TExpressionSyntax& alignment, Boolean& negate, List`1<TextSpan> unnecessarySpans);
    private static bool HasNonImplicitInstance(IInvocationOperation invocation, IOperation& instance);
    private static bool IsSpaceChar(IArgumentOperation argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyLinqExpression.AbstractSimplifyLinqExpressionDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static IImmutableSet`1<string> s_nonEnumerableReturningLinqMethodNames;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractSimplifyLinqExpressionDiagnosticAnalyzer`2();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual IInvocationOperation TryGetNextInvocationInChain(IInvocationOperation invocation);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    public void AnalyzeInvocationOperation(OperationAnalysisContext context, INamedTypeSymbol enumerableType, IMethodSymbol whereMethod, ImmutableArray`1<IMethodSymbol> linqMethods);
    [CompilerGeneratedAttribute]
internal static bool <OnCompilationStart>g__TryGetEnumerableTypeSymbol|7_1(Compilation compilation, INamedTypeSymbol& enumerableType);
    [CompilerGeneratedAttribute]
internal static bool <OnCompilationStart>g__TryGetLinqWhereExtensionMethod|7_2(INamedTypeSymbol enumerableType, IMethodSymbol& whereMethod);
    [CompilerGeneratedAttribute]
internal static bool <OnCompilationStart>g__TryGetLinqMethodsThatDoNotReturnEnumerables|7_3(INamedTypeSymbol enumerableType, ImmutableArray`1& linqMethods);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeInvocationOperation>g__IsWhereLinqMethod|8_1(IInvocationOperation invocation, <>c__DisplayClass8_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeInvocationOperation>g__IsInvocationNonEnumerableReturningLinqMethod|8_2(IInvocationOperation invocation, <>c__DisplayClass8_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <AnalyzeInvocationOperation>g__TryGetSymbolOfMemberAccess|8_3(IInvocationOperation invocation, <>c__DisplayClass8_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <AnalyzeInvocationOperation>g__TryGetMethodName|8_4(IInvocationOperation invocation, <>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`2 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_localizableMessage;
    private static LocalizableString s_localizableTitleSimplifyNames;
    private static DiagnosticDescriptor s_descriptorSimplifyNames;
    private static LocalizableString s_localizableTitleSimplifyMemberAccess;
    private static DiagnosticDescriptor s_descriptorSimplifyMemberAccess;
    private static DiagnosticDescriptor s_descriptorPreferBuiltinOrFrameworkType;
    private static SimplifyTypeNamesDiagnosticAnalyzerBase`2();
    internal abstract virtual bool IsCandidate(SyntaxNode node);
    internal abstract virtual bool CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, TSimplifierOptions options, TextSpan& issueSpan, String& diagnosticId, Boolean& inDeclaration, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    [NullableContextAttribute("0")]
protected static ImmutableArray`1<NotificationOption2> GetAllNotifications(SimplifierOptions options);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeCompilation(CompilationStartAnalysisContext context);
    protected abstract virtual bool IsIgnoredCodeBlock(SyntaxNode codeBlock);
    protected abstract virtual ImmutableArray`1<Diagnostic> AnalyzeCodeBlock(CodeBlockAnalysisContext context, SyntaxNode root);
    protected abstract virtual ImmutableArray`1<Diagnostic> AnalyzeSemanticModel(SemanticModelAnalysisContext context, SyntaxNode root, TextSpanMutableIntervalTree codeBlockIntervalTree);
    public bool TrySimplify(SemanticModel model, SyntaxNode node, Diagnostic& diagnostic, TSimplifierOptions options, AnalyzerOptions analyzerOptions, CancellationToken cancellationToken);
    internal static Diagnostic CreateDiagnostic(SemanticModel model, TSimplifierOptions options, AnalyzerOptions analyzerOptions, TextSpan issueSpan, string diagnosticId, bool inDeclaration);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SourceCodeKindExtensions : object {
    [ExtensionAttribute]
internal static SourceCodeKind MapSpecifiedToEffectiveKind(SourceCodeKind kind);
    [ExtensionAttribute]
internal static bool IsValid(SourceCodeKind value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsClrInteger(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsBlittable(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsValueType(SpecialType specialType);
    [ExtensionAttribute]
public static int SizeInBytes(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsPrimitiveRecursiveStruct(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsValidEnumUnderlyingType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsNumericType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsUnsignedIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsSignedIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static int VBForToShiftBits(SpecialType specialType);
    public static SpecialType FromRuntimeTypeOfLiteralValue(object value);
    [ExtensionAttribute]
public static bool CanOptimizeBehavior(SpecialType specialType);
    [ExtensionAttribute]
internal static ulong ConvertUnderlyingValueToUInt64(SpecialType enumUnderlyingType, object value);
}
internal static class Microsoft.CodeAnalysis.StackGuard : object {
    public static int MaxUncheckedRecursionDepth;
    [DebuggerStepThroughAttribute]
public static void EnsureSufficientExecutionStack(int recursionDepth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SymbolKey : ValueType {
    internal static int FormatVersion;
    [DataMemberAttribute]
private string _symbolKeyData;
    public SymbolKey(string data);
    [NullableContextAttribute("2")]
public static SymbolKey Create(ISymbol symbol, CancellationToken cancellationToken);
    public static IEqualityComparer`1<SymbolKey> GetComparer(bool ignoreCase, bool ignoreAssemblyKeys);
    public static bool CanCreate(ISymbol symbol, CancellationToken cancellationToken);
    public static SymbolKeyResolution ResolveString(string symbolKey, Compilation compilation, bool ignoreAssemblyKey, CancellationToken cancellationToken);
    public static SymbolKeyResolution ResolveString(string symbolKey, Compilation compilation, String& failureReason, CancellationToken cancellationToken);
    public static SymbolKeyResolution ResolveString(string symbolKey, Compilation compilation, bool ignoreAssemblyKey, String& failureReason, CancellationToken cancellationToken);
    public static string CreateString(ISymbol symbol, CancellationToken cancellationToken);
    internal static string CreateStringWorker(int version, ISymbol symbol, CancellationToken cancellationToken);
    [IsReadOnlyAttribute]
public SymbolKeyResolution Resolve(Compilation compilation, bool ignoreAssemblyKey, CancellationToken cancellationToken);
    [IsReadOnlyAttribute]
public virtual string ToString();
    private static SymbolKeyResolution CreateResolution(PooledArrayBuilder`1<TSymbol> symbols, string reasonIfFailed, String& failureReason);
    private static T SafeGet(ImmutableArray`1<T> values, int index);
    [NullableContextAttribute("2")]
private static bool Equals(Compilation compilation, string name1, string name2);
    [NullableContextAttribute("2")]
private static bool Equals(bool isCaseSensitive, string name1, string name2);
    [NullableContextAttribute("0")]
private static bool ParameterRefKindsMatch(ImmutableArray`1<IParameterSymbol> parameters, PooledArrayBuilder`1<RefKind> refKinds);
    [NullableContextAttribute("0")]
private static PooledArrayBuilder`1<TSymbol> GetMembersOfNamedType(SymbolKeyResolution containingTypeResolution, string metadataName);
    public static bool IsBodyLevelSymbol(ISymbol symbol);
    private static int GetDataStartPosition(string key);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(SymbolKey other);
    [IsReadOnlyAttribute]
private bool Equals(SymbolKey other, bool ignoreCase);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKeyExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SymbolKey GetSymbolKey(ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SymbolKeyResolution : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISymbol> _candidateSymbols;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private CandidateReason <CandidateReason>k__BackingField;
    internal int SymbolCount { get; }
    public ISymbol Symbol { get; }
    public CandidateReason CandidateReason { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    internal SymbolKeyResolution(ISymbol symbol);
    internal SymbolKeyResolution(ImmutableArray`1<ISymbol> candidateSymbols, CandidateReason candidateReason);
    internal int get_SymbolCount();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public CandidateReason get_CandidateReason();
    public ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public Enumerator`1<ISymbol> GetEnumerator();
    [NullableContextAttribute("0")]
internal Enumerable`1<TSymbol> OfType();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKeyResolutionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ISymbol GetAnySymbol(SymbolKeyResolution resolution);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SymbolUsageInfo : ValueType {
    public static SymbolUsageInfo None;
    [CompilerGeneratedAttribute]
private Nullable`1<ValueUsageInfo> <ValueUsageInfoOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeOrNamespaceUsageInfo> <TypeOrNamespaceUsageInfoOpt>k__BackingField;
    [DataMemberAttribute]
public Nullable`1<ValueUsageInfo> ValueUsageInfoOpt { get; }
    [DataMemberAttribute]
public Nullable`1<TypeOrNamespaceUsageInfo> TypeOrNamespaceUsageInfoOpt { get; }
    public SymbolUsageInfo(Nullable`1<ValueUsageInfo> valueUsageInfoOpt, Nullable`1<TypeOrNamespaceUsageInfo> typeOrNamespaceUsageInfoOpt);
    private static SymbolUsageInfo();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueUsageInfo> get_ValueUsageInfoOpt();
    [CompilerGeneratedAttribute]
public Nullable`1<TypeOrNamespaceUsageInfo> get_TypeOrNamespaceUsageInfoOpt();
    public static SymbolUsageInfo Create(ValueUsageInfo valueUsageInfo);
    public static SymbolUsageInfo Create(TypeOrNamespaceUsageInfo typeOrNamespaceUsageInfo);
    public bool IsReadFrom();
    public bool IsWrittenTo();
    public bool IsNameOnly();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolUsageInfo other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
internal static void VerifySource(SyntaxTree tree, IEnumerable`1<TextChangeRange> changes);
    private static int FindFirstDifference(string s1, string s2);
    [ExtensionAttribute]
public static bool IsHiddenPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Text.EncodedStringText : object {
    private static int LargeObjectHeapLimitInChars;
    private static Encoding s_utf8Encoding;
    private static Lazy`1<Encoding> s_fallbackEncoding;
    private static EncodedStringText();
    internal static Encoding CreateFallbackEncoding();
    internal static SourceText Create(Stream stream, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm, bool canBeEmbedded);
    internal static SourceText Create(Stream stream, Lazy`1<Encoding> getEncoding, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm, bool canBeEmbedded);
    private static SourceText Decode(Stream data, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected, bool canBeEmbedded);
    [NullableContextAttribute("0")]
internal static bool TryGetBytesFromStream(Stream data, ArraySegment`1& bytes);
    [NullableContextAttribute("0")]
private static bool TryGetBytesFromFileStream(FileStream stream, ArraySegment`1& bytes);
}
internal enum Microsoft.CodeAnalysis.TextEncodingKind : Enum {
    public byte value__;
    public static TextEncodingKind None;
    public static TextEncodingKind EncodingUtf8;
    public static TextEncodingKind EncodingUtf8_BOM;
    public static TextEncodingKind EncodingUtf32_BE;
    public static TextEncodingKind EncodingUtf32_BE_BOM;
    public static TextEncodingKind EncodingUtf32_LE;
    public static TextEncodingKind EncodingUtf32_LE_BOM;
    public static TextEncodingKind EncodingUnicode_BE;
    public static TextEncodingKind EncodingUnicode_BE_BOM;
    public static TextEncodingKind EncodingUnicode_LE;
    public static TextEncodingKind EncodingUnicode_LE_BOM;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo : Enum {
    public int value__;
    public static TypeOrNamespaceUsageInfo None;
    public static TypeOrNamespaceUsageInfo Qualified;
    public static TypeOrNamespaceUsageInfo TypeArgument;
    public static TypeOrNamespaceUsageInfo TypeConstraint;
    public static TypeOrNamespaceUsageInfo Base;
    public static TypeOrNamespaceUsageInfo ObjectCreation;
    public static TypeOrNamespaceUsageInfo Import;
    public static TypeOrNamespaceUsageInfo NamespaceDeclaration;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ObjectPool`1<ConcurrentStack`1<AnalysisResult<TSyntaxKind, TPropertyDeclaration, TConstructorDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression, TIdentifierName>>> s_analysisResultPool;
    private static ObjectPool`1<ConcurrentSet`1<IFieldSymbol>> s_fieldSetPool;
    private static ObjectPool`1<ConcurrentSet`1<SyntaxNode>> s_nodeSetPool;
    private static ObjectPool`1<ConcurrentDictionary`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>>> s_fieldWriteLocationPool;
    private static Func`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>> s_createFieldWriteNodeSet;
    private ObjectPool`1<HashSet`1<string>> _fieldNamesPool;
    protected ISemanticFacts SemanticFacts { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    [NullableAttribute("0")]
protected TSyntaxKind PropertyDeclarationKind { get; }
    private static AbstractUseAutoPropertyAnalyzer`7();
    protected static void AddFieldWrite(ConcurrentDictionary`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>> fieldWrites, IFieldSymbol field, SyntaxNode node);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected ISyntaxFacts get_SyntaxFacts();
    [NullableContextAttribute("0")]
protected abstract virtual TSyntaxKind get_PropertyDeclarationKind();
    protected abstract virtual bool SupportsReadOnlyProperties(Compilation compilation);
    protected abstract virtual bool SupportsPropertyInitializer(Compilation compilation);
    protected abstract virtual bool CanExplicitInterfaceImplementationsBeFixed();
    protected abstract virtual TExpression GetFieldInitializer(TVariableDeclarator variable, CancellationToken cancellationToken);
    protected abstract virtual TExpression GetGetterExpression(IMethodSymbol getMethod, CancellationToken cancellationToken);
    protected abstract virtual TExpression GetSetterExpression(IMethodSymbol setMethod, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetFieldNode(TFieldDeclaration fieldDeclaration, TVariableDeclarator variableDeclarator);
    protected abstract virtual void RegisterIneligibleFieldsAction(HashSet`1<string> fieldNames, ConcurrentSet`1<IFieldSymbol> ineligibleFields, SemanticModel semanticModel, SyntaxNode codeBlock, CancellationToken cancellationToken);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void RegisterNonConstructorFieldWrites(HashSet`1<string> fieldNames, ConcurrentDictionary`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>> fieldWrites, SemanticModel semanticModel, SyntaxNode codeBlock, CancellationToken cancellationToken);
    private void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context, INamedTypeSymbol containingType, ConcurrentStack`1<AnalysisResult<TSyntaxKind, TPropertyDeclaration, TConstructorDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression, TIdentifierName>> analysisResults);
    protected virtual bool CanConvert(IPropertySymbol property);
    private IFieldSymbol GetSetterField(SemanticModel semanticModel, IMethodSymbol setMethod, CancellationToken cancellationToken);
    private IFieldSymbol GetGetterField(SemanticModel semanticModel, IMethodSymbol getMethod, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static IFieldSymbol CheckFieldAccessExpression(SemanticModel semanticModel, TExpression expression, CancellationToken cancellationToken);
    private void Process(ConcurrentStack`1<AnalysisResult<TSyntaxKind, TPropertyDeclaration, TConstructorDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression, TIdentifierName>> analysisResults, ConcurrentSet`1<IFieldSymbol> ineligibleFields, ConcurrentDictionary`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>> nonConstructorFieldWrites, SymbolAnalysisContext context);
    private void Process(AnalysisResult<TSyntaxKind, TPropertyDeclaration, TConstructorDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression, TIdentifierName> result, SymbolAnalysisContext context);
    [CompilerGeneratedAttribute]
private HashSet`1<string> <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__23_0(SymbolStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private bool <InitializeWorker>g__ShouldAnalyze|23_4(SymbolStartAnalysisContext context, INamedTypeSymbol namedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer`6 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual bool IsTargetTyped(SemanticModel semanticModel, TConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer`4 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual bool IsTargetTyped(SemanticModel semanticModel, TConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractObjectCreationExpressionAnalyzer`7 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax> State;
    protected TObjectCreationExpressionSyntax _objectCreationExpression;
    protected bool _analyzeForCollectionExpression;
    private static ObjectPool`1<TAnalyzer> s_pool;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected SemanticModel SemanticModel { get; }
    private static AbstractObjectCreationExpressionAnalyzer`7();
    protected ISyntaxFacts get_SyntaxFacts();
    protected SemanticModel get_SemanticModel();
    protected abstract virtual bool ShouldAnalyze(CancellationToken cancellationToken);
    protected abstract virtual bool TryAddMatches(ArrayBuilder`1<TMatch> matches, CancellationToken cancellationToken);
    protected abstract virtual bool IsInitializerOfLocalDeclarationStatement(TLocalDeclarationStatementSyntax localDeclarationStatement, TObjectCreationExpressionSyntax rootExpression, TVariableDeclaratorSyntax& variableDeclarator);
    public static TAnalyzer Allocate();
    public sealed virtual void Dispose();
    public void Initialize(UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax> state, TObjectCreationExpressionSyntax objectCreationExpression, bool analyzeForCollectionExpression);
    protected void Clear();
    protected ImmutableArray`1<TMatch> AnalyzeWorker(CancellationToken cancellationToken);
    protected Nullable`1<UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax>> TryInitializeState(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax rootExpression, bool analyzeForCollectionExpression, CancellationToken cancellationToken);
    private Nullable`1<UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax>> TryInitializeVariableDeclarationCase(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax rootExpression, TStatementSyntax containingStatement, CancellationToken cancellationToken);
    private static Nullable`1<UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax>> TryInitializeAssignmentCase(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax rootExpression, TStatementSyntax containingStatement, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerAnalyzer`9 : AbstractObjectCreationExpressionAnalyzer`7<TExpressionSyntax, TStatementSyntax, TObjectCreationExpressionSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, Match`1<TStatementSyntax>, TAnalyzer> {
    protected IUpdateExpressionSyntaxHelper`2<TExpressionSyntax, TStatementSyntax> SyntaxHelper { get; }
    protected abstract virtual bool IsComplexElementInitializer(SyntaxNode expression);
    protected abstract virtual bool HasExistingInvalidInitializerForCollection();
    protected abstract virtual bool ValidateMatchesForCollectionExpression(ArrayBuilder`1<Match`1<TStatementSyntax>> matches, CancellationToken cancellationToken);
    protected abstract virtual IUpdateExpressionSyntaxHelper`2<TExpressionSyntax, TStatementSyntax> get_SyntaxHelper();
    public ImmutableArray`1<Match`1<TStatementSyntax>> Analyze(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax objectCreationExpression, bool analyzeForCollectionExpression, CancellationToken cancellationToken);
    protected sealed virtual bool TryAddMatches(ArrayBuilder`1<Match`1<TStatementSyntax>> matches, CancellationToken cancellationToken);
    private Nullable`1<Match`1<TStatementSyntax>> TryAnalyzeStatement(TStatementSyntax statement, Boolean& seenInvocation, Boolean& seenIndexAssignment, CancellationToken cancellationToken);
    private Nullable`1<Match`1<TStatementSyntax>> TryAnalyzeStatementForCollectionInitializer(TStatementSyntax statement, Boolean& seenInvocation, Boolean& seenIndexAssignment, CancellationToken cancellationToken);
    protected sealed virtual bool ShouldAnalyze(CancellationToken cancellationToken);
    private bool TryAnalyzeIndexAssignment(TExpressionStatementSyntax statement, CancellationToken cancellationToken, TExpressionSyntax& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerDiagnosticAnalyzer`10 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_descriptor;
    private static DiagnosticDescriptor s_unnecessaryCodeDescriptor;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractUseCollectionInitializerDiagnosticAnalyzer`10();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual bool AreCollectionInitializersSupported(Compilation compilation);
    protected abstract virtual bool AreCollectionExpressionsSupported(Compilation compilation);
    protected abstract virtual bool CanUseCollectionExpression(SemanticModel semanticModel, TObjectCreationExpressionSyntax objectCreationExpression, INamedTypeSymbol expressionType, bool allowSemanticsChange, CancellationToken cancellationToken, Boolean& changesSemantics);
    protected abstract virtual TAnalyzer GetAnalyzer();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol ienumerableType, INamedTypeSymbol expressionType);
    private void FadeOutCode(SyntaxNodeAnalysisContext context, ImmutableArray`1<Match`1<TStatementSyntax>> matches, ImmutableArray`1<Location> locations, ImmutableDictionary`2<string, string> properties);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`3<ImmutableArray`1<Match`1<TStatementSyntax>>, bool, bool>> <AnalyzeNode>g__GetCollectionInitializerMatches|12_1(<>c__DisplayClass12_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`3<ImmutableArray`1<Match`1<TStatementSyntax>>, bool, bool>> <AnalyzeNode>g__GetCollectionExpressionMatches|12_2(<>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.UseCollectionInitializer.IUpdateExpressionSyntaxHelper`2 {
    public abstract virtual void GetPartsOfForeachStatement(TStatementSyntax statement, SyntaxToken& awaitKeyword, SyntaxToken& identifier, TExpressionSyntax& expression, IEnumerable`1& statements);
    public abstract virtual void GetPartsOfIfStatement(TStatementSyntax statement, TExpressionSyntax& condition, IEnumerable`1& whenTrueStatements, IEnumerable`1& whenFalseStatements);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.UseCollectionInitializer.Match`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TStatementSyntax <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSpread>k__BackingField;
    [NullableAttribute("1")]
public TStatementSyntax Statement { get; public set; }
    public bool UseSpread { get; public set; }
    [NullableContextAttribute("1")]
public Match`1(TStatementSyntax Statement, bool UseSpread);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TStatementSyntax get_Statement();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Statement(TStatementSyntax value);
    [CompilerGeneratedAttribute]
public bool get_UseSpread();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseSpread(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Match`1<TStatementSyntax> left, Match`1<TStatementSyntax> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Match`1<TStatementSyntax> left, Match`1<TStatementSyntax> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Match`1<TStatementSyntax> other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(TStatementSyntax& Statement, Boolean& UseSpread);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2 : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, bool>> s_multiAddNames;
    public SemanticModel SemanticModel;
    public ISyntaxFacts SyntaxFacts;
    public TExpressionSyntax StartExpression;
    [NullableAttribute("2")]
public TStatementSyntax ContainingStatement;
    public SyntaxNodeOrToken ValuePattern;
    [NullableAttribute("2")]
public ISymbol InitializedSymbol;
    public UpdateExpressionState`2(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TExpressionSyntax startExpression, SyntaxNodeOrToken valuePattern, ISymbol initializedSymbol);
    private static UpdateExpressionState`2();
    public IEnumerable`1<TStatementSyntax> GetSubsequentStatements();
    public bool ValuePatternMatches(TExpressionSyntax expression);
    public bool NodeContainsValuePatternOrReferencesInitializedSymbol(SyntaxNode expression, CancellationToken cancellationToken);
    public bool TryAnalyzeInvocationForCollectionExpression(TExpressionSyntax invocationExpression, bool allowLinq, CancellationToken cancellationToken, TExpressionSyntax& instance, Boolean& useSpread);
    [NullableContextAttribute("2")]
public bool TryAnalyzeAddInvocation(TExpressionSyntax invocationExpression, string requiredArgumentName, bool forCollectionExpression, CancellationToken cancellationToken, TExpressionSyntax& instance);
    private bool TryAnalyzeMultiAddInvocation(TExpressionSyntax invocationExpression, string methodName, string requiredArgumentName, CancellationToken cancellationToken, TExpressionSyntax& instance, Boolean& useSpread);
    private bool TryAnalyzeInvocation(TExpressionSyntax invocationExpression, string methodName, string requiredArgumentName, CancellationToken cancellationToken, TExpressionSyntax& instance, SeparatedSyntaxList`1& arguments);
    public Nullable`1<Match`1<TStatementSyntax>> TryAnalyzeStatementForCollectionExpression(IUpdateExpressionSyntaxHelper`2<TExpressionSyntax, TStatementSyntax> syntaxHelper, TStatementSyntax statement, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Nullable`1<Match`1<TStatementSyntax>> <TryAnalyzeStatementForCollectionExpression>g__TryAnalyzeExpressionStatement|15_0(TStatementSyntax expressionStatement, <>c__DisplayClass15_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Nullable`1<Match`1<TStatementSyntax>> <TryAnalyzeStatementForCollectionExpression>g__TryAnalyzeForeachStatement|15_1(TStatementSyntax foreachStatement, <>c__DisplayClass15_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Nullable`1<Match`1<TStatementSyntax>> <TryAnalyzeStatementForCollectionExpression>g__TryAnalyzeIfStatement|15_2(TStatementSyntax ifStatement, <>c__DisplayClass15_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseCollectionInitializer.UseCollectionInitializerHelpers : object {
    public static string UseCollectionExpressionName;
    public static string ChangesSemanticsName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableDictionary`2<string, string> UseCollectionExpressionProperties;
    private static UseCollectionInitializerHelpers();
    public static ImmutableArray`1<Location> GetLocationsToFade(ISyntaxFacts syntaxFacts, Match`1<TStatementSyntax> matchInfo);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.UseCollectionInitializer.UseCollectionInitializerHelpers/<GetSubsequentStatements>d__4`1")]
public static IEnumerable`1<TStatementSyntax> GetSubsequentStatements(ISyntaxFacts syntaxFacts, TStatementSyntax initialStatement);
    public static bool ChangesSemantics(Diagnostic diagnostic);
}
internal abstract class Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("1")]
private ISyntaxFacts _syntaxFacts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _binaryToAssignmentMap;
    [NullableAttribute("1")]
private DiagnosticDescriptor _incrementDescriptor;
    [NullableAttribute("1")]
private DiagnosticDescriptor _decrementDescriptor;
    protected AbstractUseCompoundAssignmentDiagnosticAnalyzer`3(ISyntaxFacts syntaxFacts, ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds);
    protected abstract virtual TSyntaxKind GetAnalysisKind();
    protected abstract virtual bool IsSupported(TSyntaxKind assignmentKind, ParseOptions options);
    protected abstract virtual int TryGetIncrementOrDecrement(TSyntaxKind opKind, object constantValue);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeAssignment(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseCompoundAssignment.UseCompoundAssignmentUtilities : object {
    internal static string Increment;
    internal static string Decrement;
    [NullableContextAttribute("0")]
public static void GenerateMaps(ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds, ImmutableDictionary`2& binaryToAssignmentMap, ImmutableDictionary`2& assignmentToTokenMap);
    public static bool IsSideEffectFree(ISyntaxFacts syntaxFacts, SyntaxNode expr, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsSideEffectFreeRecurse(ISyntaxFacts syntaxFacts, SyntaxNode expr, SemanticModel semanticModel, bool isTopLevel, CancellationToken cancellationToken);
    private static bool IsSideEffectFreeSymbol(SyntaxNode expr, SemanticModel semanticModel, bool isTopLevel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractUseConditionalExpressionDiagnosticAnalyzer`1(string descriptorId, EnforceOnBuild enforceOnBuild, LocalizableResourceString message, PerLanguageOption2`1<CodeStyleOption2`1<bool>> option);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual ValueTuple`2<bool, bool> TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
    protected abstract virtual CodeStyleOption2`1<bool> GetStylePreference(OperationAnalysisContext context);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1 : AbstractUseConditionalExpressionDiagnosticAnalyzer`1<TIfStatementSyntax> {
    protected AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1(LocalizableResourceString message);
    protected sealed virtual CodeStyleOption2`1<bool> GetStylePreference(OperationAnalysisContext context);
    protected virtual ValueTuple`2<bool, bool> TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1 : AbstractUseConditionalExpressionDiagnosticAnalyzer`1<TIfStatementSyntax> {
    protected AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1(LocalizableResourceString message);
    protected sealed virtual CodeStyleOption2`1<bool> GetStylePreference(OperationAnalysisContext context);
    protected sealed virtual ValueTuple`2<bool, bool> TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
    protected virtual bool IsStatementSupported(IOperation statement);
}
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionForAssignmentHelpers : object {
    [NullableContextAttribute("1")]
public static bool TryMatchPattern(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, Boolean& isRef, IOperation& trueStatement, IOperation& falseStatement, ISimpleAssignmentOperation& trueAssignment, ISimpleAssignmentOperation& falseAssignment);
    [NullableContextAttribute("2")]
private static bool TryGetAssignmentOrThrow(IOperation statement, ISimpleAssignmentOperation& assignment, IThrowOperation& throwOperation);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryMatchPattern>g__AreEqualOrHaveImplicitConversion|0_0(ITypeSymbol firstType, ITypeSymbol secondType, Compilation compilation);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryMatchPattern>g__ReferencesDeclaredVariableInAssignment|0_1(IOperation condition, IOperation trueTarget, IOperation falseTarget);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <TryMatchPattern>g__ContainsLocalReference|0_2(HashSet`1<ILocalSymbol> declaredPatternSymbols, IOperation target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionForReturnHelpers : object {
    public static bool TryMatchPattern(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, ISymbol containingSymbol, Boolean& isRef, IOperation& trueStatement, IOperation& falseStatement, IReturnOperation& trueReturn, IReturnOperation& falseReturn);
    private static bool IsReturnExprOrThrow(IOperation statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionHelpers : object {
    public static string CanSimplifyName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableDictionary`2<string, string> CanSimplifyProperties;
    private static UseConditionalExpressionHelpers();
    public static bool CanConvert(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, IOperation whenTrue, IOperation whenFalse);
    [NullableContextAttribute("2")]
public static IOperation UnwrapSingleStatementBlock(IOperation statement);
    public static bool HasRegularComments(ISyntaxFacts syntaxFacts, SyntaxNode syntax);
    public static bool HasRegularCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTriviaList triviaList);
    [NullableContextAttribute("2")]
public static bool HasInconvertibleThrowStatement(ISyntaxFacts syntaxFacts, bool isRef, IThrowOperation trueThrow, IThrowOperation falseThrow);
    public static bool IsBooleanLiteral(IOperation trueValue, bool val);
    public static bool CanSimplify(IOperation trueValue, IOperation falseValue, bool isRef, Boolean& negate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.UseExplicitTupleName.UseExplicitTupleNameDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string ElementName;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
    private static IFieldSymbol GetNamedField(INamedTypeSymbol containingType, IFieldSymbol unnamedField, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.UseInferredMemberName.AbstractUseInferredMemberNameDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    protected abstract virtual void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseIsNullCheck.AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1(LocalizableString title);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool IsLanguageVersionSupported(Compilation compilation);
    protected abstract virtual bool IsUnconstrainedGenericSupported(Compilation compilation);
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context, IMethodSymbol referenceEqualsMethod, bool unconstraintedGenericSupported);
    private static ITypeParameterSymbol GetGenericParameterSymbol(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, SyntaxNode node1, SyntaxNode node2, CancellationToken cancellationToken);
    private static bool MatchesPattern(ISyntaxFacts syntaxFacts, SyntaxNode node1, SyntaxNode node2);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseIsNullCheck.UseIsNullConstants : object {
    public static string Kind;
    public static string ReferenceEqualsKey;
    public static string CastAndEqualityKey;
    public static string Negated;
    public static string UnconstrainedGeneric;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationDiagnosticAnalyzer`11 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_whenPartIsNullableProperties;
    [NullableAttribute("0")]
protected TSyntaxKind IfStatementSyntaxKind { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractUseNullPropagationDiagnosticAnalyzer`11();
    [NullableContextAttribute("2")]
protected abstract virtual bool TryGetPartsOfIfStatement(TIfStatementSyntax ifStatement, TExpressionSyntax& condition, TStatementSyntax& trueStatement);
    [NullableContextAttribute("2")]
private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context, IMethodSymbol referenceEqualsMethod);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual bool ShouldAnalyze(Compilation compilation);
    [NullableContextAttribute("0")]
protected abstract virtual TSyntaxKind get_IfStatementSyntaxKind();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual bool TryAnalyzePatternCondition(ISyntaxFacts syntaxFacts, TExpressionSyntax conditionNode, TExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeTernaryConditionalExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType, IMethodSymbol referenceEqualsMethod);
    private bool TryAnalyzeCondition(SyntaxNodeAnalysisContext context, ISyntaxFacts syntaxFacts, IMethodSymbol referenceEqualsMethod, TExpressionSyntax condition, TExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    private static bool TryAnalyzeBinaryExpressionCondition(ISyntaxFacts syntaxFacts, TBinaryExpressionSyntax condition, TExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    private static bool TryAnalyzeInvocationCondition(SyntaxNodeAnalysisContext context, ISyntaxFacts syntaxFacts, IMethodSymbol referenceEqualsMethod, TInvocationExpressionSyntax invocation, TExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    private static TExpressionSyntax GetConditionPartToCheck(ISyntaxFacts syntaxFacts, TExpressionSyntax conditionLeft, TExpressionSyntax conditionRight);
    internal static TExpressionSyntax GetWhenPartMatch(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, TExpressionSyntax expressionToMatch, TExpressionSyntax whenPart, CancellationToken cancellationToken);
    private static TExpressionSyntax RemoveObjectCastIfAny(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, TExpressionSyntax node, CancellationToken cancellationToken);
    private static TExpressionSyntax Unwrap(ISyntaxFacts syntaxFacts, TExpressionSyntax node);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__13_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.UseNullPropagation.UseNullPropagationConstants : object {
    [NullableAttribute("1")]
public static string WhenPartIsNullable;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseNamedMemberInitializerAnalyzer`8 : AbstractObjectCreationExpressionAnalyzer`7<TExpressionSyntax, TStatementSyntax, TObjectCreationExpressionSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>, TAnalyzer> {
    public ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> Analyze(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax objectCreationExpression, CancellationToken cancellationToken);
    protected sealed virtual bool ShouldAnalyze(CancellationToken cancellationToken);
    protected sealed virtual bool TryAddMatches(ArrayBuilder`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsExplicitlyImplemented(ITypeSymbol classOrStructType, ISymbol member, ISymbol& typeMember);
    private bool ImplicitMemberAccessWouldBeAffected(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerDiagnosticAnalyzer`9 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_descriptor;
    private static DiagnosticDescriptor s_unnecessaryCodeDescriptor;
    protected bool FadeOutOperatorToken { get; }
    private static AbstractUseObjectInitializerDiagnosticAnalyzer`9();
    protected abstract virtual bool get_FadeOutOperatorToken();
    protected abstract virtual TAnalyzer GetAnalyzer();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool AreObjectInitializersSupported(Compilation compilation);
    protected abstract virtual bool IsValidContainingStatement(TStatementSyntax node);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private void FadeOutCode(SyntaxNodeAnalysisContext context, ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches, ImmutableArray`1<Location> locations);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.UseObjectInitializer.Match`4 : ValueType {
    public TAssignmentStatementSyntax Statement;
    public TMemberAccessExpressionSyntax MemberAccessExpression;
    public TExpressionSyntax Initializer;
    public string MemberName;
    public Match`4(TAssignmentStatementSyntax statement, TMemberAccessExpressionSyntax memberAccessExpression, TExpressionSyntax initializer, string memberName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperationBlock(HashCodeAnalyzer analyzer, OperationBlockAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseThrowExpression.AbstractUseThrowExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ISemanticFacts SemanticFacts { get; }
    protected AbstractUseThrowExpressionDiagnosticAnalyzer(Option2`1<CodeStyleOption2`1<bool>> preferThrowExpressionOption);
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected abstract virtual CodeStyleOption2`1<bool> PreferThrowExpressionStyle(OperationAnalysisContext context);
    protected abstract virtual bool IsSupported(Compilation compilation);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeOperation(OperationAnalysisContext context, INamedTypeSymbol expressionType);
    private static bool ValueIsAccessed(SemanticModel semanticModel, IConditionalOperation ifOperation, IBlockOperation containingBlock, ISymbol localOrParameter, IExpressionStatementOperation expressionStatement, IAssignmentOperation assignmentExpression);
    private static bool TryFindAssignmentExpression(IBlockOperation containingBlock, IConditionalOperation ifOperation, ISymbol localOrParameter, IExpressionStatementOperation& expressionStatement, IAssignmentOperation& assignmentExpression);
    private static bool TryDecomposeIfCondition(IConditionalOperation ifStatement, ISymbol& localOrParameter);
    private static bool TryGetLocalOrParameterSymbol(IOperation operation, ISymbol& localOrParameter);
    private static bool IsNull(IOperation operation);
    private static IConditionalOperation GetContainingIfOperation(SemanticModel semanticModel, IThrowOperation throwOperation, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__6_0(CompilationStartAnalysisContext startContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Utilities.IReadOnlyListExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToReadOnlyList(IList`1<T> list);
    [ExtensionAttribute]
public static T Last(IReadOnlyList`1<T> list);
    [ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> list, T value, int startIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1 : DiagnosticAnalyzer {
    private static string DiagnosticID;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static Regex s_removeEscapedBracketsRegex;
    private static Regex s_extractPlaceholdersRegex;
    private static string NameOfArgsParameter;
    private static string NameOfFormatStringParameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AbstractValidateFormatStringDiagnosticAnalyzer`1();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual SyntaxNode GetArgumentExpression(SyntaxNode syntaxNode);
    protected abstract virtual SyntaxNode TryGetMatchingNamedArgument(SeparatedSyntaxList`1<SyntaxNode> arguments, string searchArgumentName);
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol formatProviderType);
    private static bool IsValidFormatMethod(ISyntaxFacts syntaxFacts, SyntaxNode expression);
    private bool ArgsIsArrayOfReferenceTypes(SemanticModel semanticModel, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    private ITypeSymbol TryGetArgsArgumentType(SemanticModel semanticModel, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    protected SyntaxNode TryGetArgument(string searchArgumentName, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters);
    private static IParameterSymbol GetParameterWithMatchingName(ImmutableArray`1<IParameterSymbol> parameters, string searchArgumentName);
    protected SyntaxNode TryGetFormatStringLiteralExpressionSyntax(SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    [NullableContextAttribute("2")]
protected static IMethodSymbol TryGetValidFormatMethodSymbol(SymbolInfo symbolInfo);
    private static bool FormatCallWorksAtRuntime(string formatString, int numberOfPlaceholderArguments);
    protected static void ValidateAndReportDiagnostic(SyntaxNodeAnalysisContext context, int numberOfPlaceholderArguments, string formatString, int formatStringPosition);
    private static string RemoveEscapedBrackets(string formatString);
    private static bool PlaceholderIndexIsValid(string textInsideBrackets, int numberOfPlaceholderArguments);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_0(CompilationStartAnalysisContext startContext);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.ValueUsageInfo : Enum {
    public int value__;
    public static ValueUsageInfo None;
    public static ValueUsageInfo Read;
    public static ValueUsageInfo Write;
    public static ValueUsageInfo Reference;
    public static ValueUsageInfo Name;
    public static ValueUsageInfo ReadWrite;
    public static ValueUsageInfo ReadableReference;
    public static ValueUsageInfo WritableReference;
    public static ValueUsageInfo ReadableWritableReference;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ValueUsageInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsReadFrom(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsWrittenTo(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsNameOnly(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsReference(ValueUsageInfo valueUsageInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeStyle.VisualBasicCodeStyleOptions : object {
    private static Builder<IOption2> s_allOptionsBuilder;
    public static Option2`1<CodeStyleOption2`1<string>> PreferredModifierOrder;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferIsNotExpression;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSimplifiedObjectCreation;
    public static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueExpressionStatement;
    public static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueAssignment;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<IOption2> EditorConfigOptions { get; }
    private static VisualBasicCodeStyleOptions();
    private static Option2`1<CodeStyleOption2`1<T>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<T> defaultValue, Func`2<CodeStyleOption2`1<T>, EditorConfigValueSerializer`1<CodeStyleOption2`1<T>>> serializerFactory);
    public static ImmutableArray`1<IOption2> get_EditorConfigOptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeStyle.VisualBasicIdeCodeStyleOptions : IdeCodeStyleOptions {
    private static CodeStyleOption2`1<UnusedValuePreference> s_unusedLocalVariableWithSilentEnforcement;
    private static CodeStyleOption2`1<UnusedValuePreference> s_unusedLocalVariableWithSuggestionEnforcement;
    private static CodeStyleOption2`1<string> s_defaultModifierOrder;
    public static VisualBasicIdeCodeStyleOptions Default;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<string> <PreferredModifierOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferIsNotExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSimplifiedObjectCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<UnusedValuePreference> <UnusedValueExpressionStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<UnusedValuePreference> <UnusedValueAssignment>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeStyleOption2`1<string> PreferredModifierOrder { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferIsNotExpression { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSimplifiedObjectCreation { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<UnusedValuePreference> UnusedValueExpressionStatement { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<UnusedValuePreference> UnusedValueAssignment { get; public set; }
    internal VisualBasicIdeCodeStyleOptions(IOptionsReader options, VisualBasicIdeCodeStyleOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private VisualBasicIdeCodeStyleOptions(VisualBasicIdeCodeStyleOptions original);
    private static VisualBasicIdeCodeStyleOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<string> get_PreferredModifierOrder();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferredModifierOrder(CodeStyleOption2`1<string> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferIsNotExpression();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferIsNotExpression(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSimplifiedObjectCreation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSimplifiedObjectCreation(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueExpressionStatement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnusedValueExpressionStatement(CodeStyleOption2`1<UnusedValuePreference> value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueAssignment();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnusedValueAssignment(CodeStyleOption2`1<UnusedValuePreference> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(VisualBasicIdeCodeStyleOptions left, VisualBasicIdeCodeStyleOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(VisualBasicIdeCodeStyleOptions left, VisualBasicIdeCodeStyleOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(IdeCodeStyleOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(VisualBasicIdeCodeStyleOptions other);
    [CompilerGeneratedAttribute]
public virtual IdeCodeStyleOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicSyntaxFormattingOptions : SyntaxFormattingOptions {
    public static VisualBasicSyntaxFormattingOptions Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    internal VisualBasicSyntaxFormattingOptions(IOptionsReader options, VisualBasicSyntaxFormattingOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private VisualBasicSyntaxFormattingOptions(VisualBasicSyntaxFormattingOptions original);
    private static VisualBasicSyntaxFormattingOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(VisualBasicSyntaxFormattingOptions left, VisualBasicSyntaxFormattingOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(VisualBasicSyntaxFormattingOptions left, VisualBasicSyntaxFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SyntaxFormattingOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(VisualBasicSyntaxFormattingOptions other);
    [CompilerGeneratedAttribute]
public virtual SyntaxFormattingOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicSimplifierOptions : SimplifierOptions {
    public static VisualBasicSimplifierOptions Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public VisualBasicSimplifierOptions(IOptionsReader options, VisualBasicSimplifierOptions fallbackOptions);
    [CompilerGeneratedAttribute]
private VisualBasicSimplifierOptions(VisualBasicSimplifierOptions original);
    private static VisualBasicSimplifierOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(VisualBasicSimplifierOptions left, VisualBasicSimplifierOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(VisualBasicSimplifierOptions left, VisualBasicSimplifierOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SimplifierOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(VisualBasicSimplifierOptions other);
    [CompilerGeneratedAttribute]
public virtual SimplifierOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.AnnotationTable`1 : object {
    [CompilerGeneratedAttribute]
private string <annotationKind>P;
    private int _globalId;
    private Dictionary`2<TAnnotation, SyntaxAnnotation> _realAnnotationMap;
    private Dictionary`2<string, TAnnotation> _annotationMap;
    public AnnotationTable`1(string annotationKind);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetOrCreateRealAnnotations>d__5")]
private IEnumerable`1<SyntaxAnnotation> GetOrCreateRealAnnotations(TAnnotation[] annotations);
    private SyntaxAnnotation GetOrCreateRealAnnotation(TAnnotation annotation);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetRealAnnotations>d__7")]
private IEnumerable`1<SyntaxAnnotation> GetRealAnnotations(TAnnotation[] annotations);
    private SyntaxAnnotation GetRealAnnotation(TAnnotation annotation);
    public TSyntaxNode WithAdditionalAnnotations(TSyntaxNode node, TAnnotation[] annotations);
    public SyntaxToken WithAdditionalAnnotations(SyntaxToken token, TAnnotation[] annotations);
    public SyntaxTrivia WithAdditionalAnnotations(SyntaxTrivia trivia, TAnnotation[] annotations);
    public SyntaxNodeOrToken WithAdditionalAnnotations(SyntaxNodeOrToken nodeOrToken, TAnnotation[] annotations);
    public TSyntaxNode WithoutAnnotations(TSyntaxNode node, TAnnotation[] annotations);
    public SyntaxToken WithoutAnnotations(SyntaxToken token, TAnnotation[] annotations);
    public SyntaxTrivia WithoutAnnotations(SyntaxTrivia trivia, TAnnotation[] annotations);
    public SyntaxNodeOrToken WithoutAnnotations(SyntaxNodeOrToken nodeOrToken, TAnnotation[] annotations);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetAnnotations>d__17")]
private IEnumerable`1<TAnnotation> GetAnnotations(IEnumerable`1<SyntaxAnnotation> realAnnotations);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxNode node);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxToken token);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxTrivia trivia);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxNodeOrToken nodeOrToken);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxNode node);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxToken token);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxTrivia trivia);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotations(SyntaxNode node);
    public bool HasAnnotations(SyntaxToken token);
    public bool HasAnnotations(SyntaxTrivia trivia);
    public bool HasAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotations(SyntaxNode node);
    [NullableContextAttribute("0")]
public bool HasAnnotations(SyntaxToken token);
    [NullableContextAttribute("0")]
public bool HasAnnotations(SyntaxTrivia trivia);
    [NullableContextAttribute("0")]
public bool HasAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotation(SyntaxNode node, TAnnotation annotation);
    public bool HasAnnotation(SyntaxToken token, TAnnotation annotation);
    public bool HasAnnotation(SyntaxTrivia trivia, TAnnotation annotation);
    public bool HasAnnotation(SyntaxNodeOrToken nodeOrToken, TAnnotation annotation);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxNode node);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedNodes>b__43_0(SyntaxNodeOrToken nt);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedTokens>b__44_0(SyntaxNodeOrToken nt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ArrayExtensions : object {
    [ExtensionAttribute]
internal static T[] Copy(T[] array, int start, int length);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T item);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T[] items);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T[] items);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position, int length);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, int length, T[] items);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array, int start, int count);
    [ExtensionAttribute]
internal static int BinarySearch(Int32[] array, int value);
    [ExtensionAttribute]
public static bool SequenceEqual(T[] first, T[] second, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
internal static int BinarySearchUpperBound(Int32[] array, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.ArrayPool`1 : object {
    private static int MaxPooledArraySize;
    private static SimplePool`1<T[]> s_pool;
    private static ArrayPool`1();
    public static T[] GetArray(int size);
    public static void ReleaseArray(T[] array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.AsyncLazy : object {
    public static AsyncLazy`1<T> Create(Func`3<TArg, CancellationToken, Task`1<T>> asynchronousComputeFunction, Func`3<TArg, CancellationToken, T> synchronousComputeFunction, TArg arg);
    public static AsyncLazy`1<T> Create(Func`3<TArg, CancellationToken, Task`1<T>> asynchronousComputeFunction, TArg arg);
    public static AsyncLazy`1<T> Create(Func`3<TArg, CancellationToken, T> synchronousComputeFunction, TArg arg);
    public static AsyncLazy`1<T> Create(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction);
    public static AsyncLazy`1<T> Create(Func`2<CancellationToken, T> synchronousComputeFunction);
    public static AsyncLazy`1<T> Create(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction, Func`2<CancellationToken, T> synchronousComputeFunction);
    public static AsyncLazy`1<T> Create(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslyn.Utilities.AsyncLazy`1 : object {
    public abstract virtual bool TryGetValue(T& result);
    public abstract virtual T GetValue(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    public static AsyncLazy`1<T> Create(Func`3<TData, CancellationToken, Task`1<T>> asynchronousComputeFunction, Func`3<TData, CancellationToken, T> synchronousComputeFunction, TData data);
    public static AsyncLazy`1<T> Create(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.BidirectionalMap`2 : object {
    public static IBidirectionalMap`2<TKey, TValue> Empty;
    private ImmutableDictionary`2<TKey, TValue> _forwardMap;
    private ImmutableDictionary`2<TValue, TKey> _backwardMap;
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public TValue Item { get; }
    public TKey Item { get; }
    public BidirectionalMap`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private BidirectionalMap`2(ImmutableDictionary`2<TKey, TValue> forwardMap, ImmutableDictionary`2<TValue, TKey> backwardMap);
    private static BidirectionalMap`2();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TValue value, TKey& key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool ContainsValue(TValue value);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> RemoveKey(TKey key);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> RemoveValue(TValue value);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> Add(TKey key, TValue value);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual bool get_IsEmpty();
    public int get_Count();
    public sealed virtual TValue GetValueOrDefault(TKey key);
    public sealed virtual TKey GetKeyOrDefault(TValue value);
    public TValue get_Item(TKey key);
    public TKey get_Item(TValue value);
}
internal static class Roslyn.Utilities.BitArithmeticUtilities : object {
    public static int CountBits(int v);
    public static int CountBits(UInt32 v);
    public static int CountBits(long v);
    public static int CountBits(ulong v);
    internal static UInt32 Align(UInt32 position, UInt32 alignment);
    internal static int Align(int position, int alignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.BKTree : ValueType {
    public static BKTree Empty;
    private Char[] _concatenatedLowerCaseWords;
    [NullableAttribute("0")]
private ImmutableArray`1<Node> _nodes;
    [NullableAttribute("0")]
private ImmutableArray`1<Edge> _edges;
    [NullableContextAttribute("0")]
private BKTree(Char[] concatenatedLowerCaseWords, ImmutableArray`1<Node> nodes, ImmutableArray`1<Edge> edges);
    private static BKTree();
    public static BKTree Create(IEnumerable`1<string> values);
    public void Find(TemporaryArray`1& result, string value, Nullable`1<int> threshold);
    private void Lookup(Node currentNode, Char[] queryCharacters, int queryLength, int threshold, TemporaryArray`1& result, int recursionCount);
    internal void WriteTo(ObjectWriter writer);
    internal static Nullable`1<BKTree> ReadFrom(ObjectReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.CancellableLazy : object {
    public static CancellableLazy`1<T> Create(T value);
    public static CancellableLazy`1<T> Create(Func`2<CancellationToken, T> valueFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.CancellableLazy`1 : object {
    [NullableAttribute("2")]
private NonReentrantLock _gate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<CancellationToken, T> _valueFactory;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public CancellableLazy`1(Func`2<CancellationToken, T> valueFactory);
    public CancellableLazy`1(T value);
    public bool get_HasValue();
    public bool TryGetValue(T& value);
    public T GetValue(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.ComparerWithState : object {
    public static int CompareTo(T first, T second, S state, ImmutableArray`1<Func`3<T, S, IComparable>> comparableMethods);
    public static int CompareTo(T first, T second, ImmutableArray`1<Func`2<T, IComparable>> comparableMethods);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.CompilerOptionParseUtilities : object {
    public static IList`1<string> ParseFeatureFromMSBuild(string features);
    public static void ParseFeatures(IDictionary`2<string, string> builder, List`1<string> values);
    private static void ParseFeatureCore(IDictionary`2<string, string> builder, string feature);
}
internal static class Roslyn.Utilities.CompilerPathUtilities : object {
    [NullableContextAttribute("1")]
internal static void RequireAbsolutePath(string path, string argumentName);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ConcatImmutableArray`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<T> <first>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<T> <second>P;
    public int Length { get; }
    public ConcatImmutableArray`1(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    public int get_Length();
    [NullableContextAttribute("1")]
public bool Any(Func`2<T, bool> predicate);
    public Enumerator<T> GetEnumerator();
    public ImmutableArray`1<T> ToImmutableArray();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ConcurrentDictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(ConcurrentDictionary`2<K, V> dict, K key, V value);
    [ExtensionAttribute]
public static TValue GetOrAdd(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    [ExtensionAttribute]
public static TValue AddOrUpdate(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, Func`3<TKey, TArg, TValue> addValueFactory, Func`4<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Roslyn.Utilities.ConcurrentSet`1 : object {
    private static int DefaultConcurrencyLevel;
    private static int DefaultCapacity;
    private ConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    public ConcurrentSet`1(IEqualityComparer`1<T> equalityComparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Contains(T value);
    public bool Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public sealed virtual bool Remove(T value);
    public sealed virtual void Clear();
    [NullableContextAttribute("0")]
public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.ConcurrentSet`1/<GetEnumeratorImpl>d__18")]
private IEnumerator`1<T> GetEnumeratorImpl();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ConfiguredYieldAwaitable : ValueType {
    private YieldAwaitable _awaitable;
    private bool _continueOnCapturedContext;
    public ConfiguredYieldAwaitable(YieldAwaitable awaitable, bool continueOnCapturedContext);
    public ConfiguredYieldAwaiter GetAwaiter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ConsList`1 : object {
    public static ConsList`1<T> Empty;
    [NullableAttribute("2")]
private T _head;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConsList`1<T> _tail;
    [DebuggerBrowsableAttribute("0")]
public T Head { get; }
    [DebuggerBrowsableAttribute("0")]
public ConsList`1<T> Tail { get; }
    public ConsList`1(T head, ConsList`1<T> tail);
    private static ConsList`1();
    public T get_Head();
    public ConsList`1<T> get_Tail();
    public bool Any();
    public ConsList`1<T> Push(T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Contract : object {
    [NullableContextAttribute("2")]
public static void ThrowIfNull(T value, int lineNumber, string filePath);
    [NullableContextAttribute("0")]
public static void ThrowIfNull(Nullable`1<T> value, int lineNumber, string filePath);
    public static void ThrowIfNull(T value, string message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfNull(T value, ThrowIfNullInterpolatedStringHandler`1<T> message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfFalse(bool condition, int lineNumber, string filePath);
    public static void ThrowIfFalse(bool condition, string message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfFalse(bool condition, ThrowIfFalseInterpolatedStringHandler message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfTrue(bool condition, int lineNumber, string filePath);
    public static void ThrowIfTrue(bool condition, string message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfTrue(bool condition, ThrowIfTrueInterpolatedStringHandler message, int lineNumber, string filePath);
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
public static void Fail(string message, int lineNumber, string filePath);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.DecimalUtilities : object {
    [ExtensionAttribute]
public static int GetScale(decimal value);
    [ExtensionAttribute]
public static void GetBits(decimal value, Boolean& isNegative, Byte& scale, UInt32& low, UInt32& mid, UInt32& high);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.DocumentationCommentXmlNames : object {
    public static string CElementName;
    public static string CodeElementName;
    public static string CompletionListElementName;
    public static string DescriptionElementName;
    public static string ExampleElementName;
    public static string ExceptionElementName;
    public static string IncludeElementName;
    public static string InheritdocElementName;
    public static string ItemElementName;
    public static string ListElementName;
    public static string ListHeaderElementName;
    public static string ParaElementName;
    public static string ParameterElementName;
    public static string ParameterReferenceElementName;
    public static string PermissionElementName;
    public static string PlaceholderElementName;
    public static string PreliminaryElementName;
    public static string RemarksElementName;
    public static string ReturnsElementName;
    public static string SeeElementName;
    public static string SeeAlsoElementName;
    public static string SummaryElementName;
    public static string TermElementName;
    public static string ThreadSafetyElementName;
    public static string TypeParameterElementName;
    public static string TypeParameterReferenceElementName;
    public static string ValueElementName;
    public static string CrefAttributeName;
    public static string HrefAttributeName;
    public static string FileAttributeName;
    public static string InstanceAttributeName;
    public static string LangwordAttributeName;
    public static string NameAttributeName;
    public static string PathAttributeName;
    public static string StaticAttributeName;
    public static string TypeAttributeName;
    public static bool ElementEquals(string name1, string name2, bool fromVb);
    public static bool AttributeEquals(string name1, string name2);
    public static bool Equals(object left, object right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.EditDistance : ValueType {
    private static int Infinity;
    public static int BeyondThreshold;
    private string _source;
    private Char[] _sourceLowerCaseCharacters;
    private static int MaxMatrixPoolDimension;
    private static ThreadLocal`1<Int32[0...,0...]> t_matrixPool;
    private static int LastSeenIndexLength;
    private static ThreadLocal`1<Int32[]> t_lastSeenIndexPool;
    public EditDistance(string text);
    private static EditDistance();
    private static Char[] ConvertToLowercaseArray(string text);
    public sealed virtual void Dispose();
    public static int GetEditDistance(string source, string target, int threshold);
    public static int GetEditDistance(Char[] source, Char[] target, int threshold);
    public int GetEditDistance(string target, int threshold);
    private static Int32[0...,0...] GetMatrix(int width, int height);
    private static Int32[0...,0...] InitializeMatrix(Int32[0...,0...] matrix);
    [NullableContextAttribute("0")]
public static int GetEditDistance(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, int threshold);
    [NullableContextAttribute("0")]
private static int GetEditDistanceWorker(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, int threshold);
    private static string ToString(Int32[0...,0...] matrix, int width, int height);
    private static int GetValue(Dictionary`2<char, int> da, char c);
    private static int Min(int v1, int v2, int v3, int v4);
    private static void SetValue(Int32[0...,0...] matrix, int i, int j, int val);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.EnumerableExtensions : object {
    private static Func`2<object, bool> s_notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static int Count(IEnumerable`1<T> source, Func`3<T, TArg, bool> predicate, TArg arg);
    [ExtensionAttribute]
public static IEnumerable`1<T> Do(IEnumerable`1<T> source, Action`1<T> action);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArrayOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToBoxedImmutableArray(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<ConcatWorker>d__6`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> ConcatWorker(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> ToCollection(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static T FirstOrDefault(IEnumerable`1<T> source, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> FirstOrNull(IEnumerable`1<T> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> FirstOrNull(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> FirstOrNull(IEnumerable`1<T> source, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> LastOrNull(IEnumerable`1<T> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> SingleOrNull(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool IsSingle(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(IReadOnlyCollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(string source);
    [ExtensionAttribute]
public static bool IsEmpty(T[] source);
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> source);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IReadOnlyCollection`1<TSource> source, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(IEnumerable`1<TItem> source, Func`3<TItem, TArg, IEnumerable`1<TResult>> selector, TArg arg);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(IReadOnlyCollection`1<TItem> source, Func`2<TItem, IEnumerable`1<TResult>> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(IReadOnlyCollection`1<TItem> source, Func`3<TItem, TArg, IEnumerable`1<TResult>> selector, TArg arg);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectAsArrayAsync>d__35`2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(IEnumerable`1<TItem> source, Func`2<TItem, ValueTask`1<TResult>> selector);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectAsArrayAsync>d__36`2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(IEnumerable`1<TItem> source, Func`3<TItem, CancellationToken, ValueTask`1<TResult>> selector, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectAsArrayAsync>d__37`3")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(IEnumerable`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<TResult>> selector, TArg arg, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectManyAsArrayAsync>d__38`3")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectManyAsArrayAsync(IEnumerable`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<IEnumerable`1<TResult>>> selector, TArg arg, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectManyInParallelAsync>d__39`2")]
[ExtensionAttribute]
public static ValueTask`1<IEnumerable`1<TResult>> SelectManyInParallelAsync(IEnumerable`1<TItem> sequence, Func`3<TItem, CancellationToken, Task`1<IEnumerable`1<TResult>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<bool> source);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> sequence, T value);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> sequence, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
private static int EnumeratingIndexOf(IEnumerable`1<T> sequence, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> sequence);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderByDescending(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderByDescending(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> sequence, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Contains(IEnumerable`1<string> sequence, string s);
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items, IEqualityComparer`1<K> keyComparer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static IList`1<IList`1<T>> Transpose(IEnumerable`1<IEnumerable`1<T>> data);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<TransposeInternal>d__61`1")]
[ExtensionAttribute]
private static IEnumerable`1<IList`1<T>> TransposeInternal(IEnumerable`1<IEnumerable`1<T>> data);
    [ExtensionAttribute]
internal static Dictionary`2<K, ImmutableArray`1<T>> ToMultiDictionary(IEnumerable`1<T> data, Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static TSource AsSingleton(IEnumerable`1<TSource> source);
}
internal static class Roslyn.Utilities.EnumUtilities : object {
    internal static T[] GetValues();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.EventMap : object {
    private NonReentrantLock _guard;
    private Dictionary`2<string, object> _eventNameToRegistries;
    public void AddEventHandler(string eventName, TEventHandler eventHandler);
    public void RemoveEventHandler(string eventName, TEventHandler eventHandler);
    public EventHandlerSet`1<TEventHandler> GetEventHandlers(string eventName);
    private ImmutableArray`1<Registry`1<TEventHandler>> GetRegistries(string eventName);
    private ImmutableArray`1<Registry`1<TEventHandler>> GetRegistries_NoLock(string eventName);
    private void SetRegistries_NoLock(string eventName, ImmutableArray`1<Registry`1<TEventHandler>> registries);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.ExceptionUtilities : object {
    internal static Exception UnexpectedValue(object o);
    internal static Exception Unreachable(string path, int line);
    internal static bool IsCurrentOperationBeingCancelled(Exception exception, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.FileNameUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    [NullableContextAttribute("0")]
private static int IndexOfExtension(ReadOnlySpan`1<char> path);
    internal static string GetExtension(string path);
    [NullableContextAttribute("0")]
internal static ReadOnlyMemory`1<char> GetExtension(ReadOnlyMemory`1<char> path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path, bool includeExtension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.FileUtilities : object {
    private static Char[] s_invalidPathChars;
    private static FileUtilities();
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory, IEnumerable`1<string> searchPaths, Func`2<string, bool> fileExists);
    [NullableContextAttribute("2")]
internal static string ResolveRelativePath(string path, string baseDirectory);
    [NullableContextAttribute("2")]
internal static string ResolveRelativePath(string path, string basePath, string baseDirectory);
    [NullableContextAttribute("2")]
private static string ResolveRelativePath(PathKind kind, string path, string basePath, string baseDirectory);
    [NullableContextAttribute("2")]
private static string GetBaseDirectory(string basePath, string baseDirectory);
    internal static string GetNormalizedPathOrOriginalPath(string path, string basePath);
    [NullableContextAttribute("2")]
internal static string NormalizeRelativePath(string path, string basePath, string baseDirectory);
    internal static string NormalizeAbsolutePath(string path);
    internal static string NormalizeDirectoryPath(string path);
    internal static string TryNormalizeAbsolutePath(string path);
    internal static Stream OpenRead(string fullPath);
    internal static Stream OpenAsyncRead(string fullPath);
    public static T RethrowExceptionsAsIOException(Func`1<T> operation);
    public static T RethrowExceptionsAsIOException(Func`2<TArg, T> operation, TArg arg);
    public static Task`1<T> RethrowExceptionsAsIOExceptionAsync(Func`1<Task`1<T>> operation);
    [AsyncStateMachineAttribute("Roslyn.Utilities.FileUtilities/<RethrowExceptionsAsIOExceptionAsync>d__16`2")]
public static Task`1<T> RethrowExceptionsAsIOExceptionAsync(Func`2<TArg, Task`1<T>> operation, TArg arg);
    internal static Stream CreateFileStreamChecked(Func`2<string, Stream> factory, string path, string paramName);
    internal static DateTime GetFileTimeStamp(string fullPath);
    internal static long GetFileLength(string fullPath);
    internal static void GetFileLengthAndTimeStamp(string fullPath, Int64& fileLength, DateTime& timeStamp);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Functions`1 : object {
    public static Func`2<T, T> Identity;
    public static Func`2<T, bool> True;
    private static Functions`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.GeneratedCodeUtilities : object {
    private static String[] s_autoGeneratedStrings;
    private static GeneratedCodeUtilities();
    internal static bool IsGeneratedSymbolWithGeneratedCodeAttribute(ISymbol symbol, INamedTypeSymbol generatedCodeAttribute);
    internal static bool IsGeneratedCode(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    internal static bool IsGeneratedCode(string filePath, SyntaxNode root, Func`2<SyntaxTrivia, bool> isComment);
    [NullableContextAttribute("2")]
private static bool IsGeneratedCodeFile(string filePath);
    private static bool BeginsWithAutoGeneratedComment(SyntaxNode root, Func`2<SyntaxTrivia, bool> isComment);
    private static bool BeginsWithAutoGeneratedComment(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    internal static GeneratedKind GetIsGeneratedCodeFromOptions(ImmutableDictionary`2<string, string> options);
    internal static Nullable`1<bool> GetIsGeneratedCodeFromOptions(AnalyzerConfigOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    [NullableContextAttribute("2")]
internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(ImmutableDictionary`2<TKey, TValue> values, int maxItemsToHash);
    [NullableContextAttribute("2")]
internal static int CombineValues(T[] values, int maxItemsToHash);
    [NullableContextAttribute("2")]
internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ReadOnlySpan`1<byte> data, Boolean& isAscii);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ReadOnlySpan`1<char> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetCaseInsensitiveFNVHashCode(string text);
    [NullableContextAttribute("0")]
internal static int GetCaseInsensitiveFNVHashCode(ReadOnlySpan`1<char> data);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
    [NullableContextAttribute("0")]
internal static int CombineFNVHash(int hashCode, ReadOnlySpan`1<char> data);
}
[NullableContextAttribute("1")]
internal interface Roslyn.Utilities.IBidirectionalMap`2 {
    public bool IsEmpty { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual bool TryGetKey(TValue value, TKey& key);
    public abstract virtual TValue GetValueOrDefault(TKey key);
    public abstract virtual TKey GetKeyOrDefault(TValue value);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool ContainsValue(TValue value);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> RemoveKey(TKey key);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> RemoveValue(TValue value);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> Add(TKey key, TValue value);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[NullableContextAttribute("1")]
internal interface Roslyn.Utilities.ICacheEntry`2 {
    public TKey Key { get; }
    public TValue Value { get; }
    public abstract virtual TKey get_Key();
    public abstract virtual TValue get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ICollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, ArrayBuilder`1<T> values);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, HashSet`1<T> values);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<TKey> collection, KeyCollection<TKey, TValue> keyCollection);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, ImmutableArray`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static V GetOrAdd(IDictionary`2<K, V> dictionary, K key, Func`2<K, V> function);
    [ExtensionAttribute]
public static V GetOrAdd(IDictionary`2<K, V> dictionary, K key, Func`3<K, TArg, V> function, TArg arg);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, ArrayBuilder`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiAddRange(IDictionary`2<TKey, ArrayBuilder`1<TValue>> dictionary, TKey key, IEnumerable`1<TValue> values);
    [ExtensionAttribute]
public static bool MultiAdd(IDictionary`2<TKey, ImmutableHashSet`1<TValue>> dictionary, TKey key, TValue value, IEqualityComparer`1<TValue> comparer);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, TKey key, TValue value, ImmutableArray`1<TValue> defaultArray);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, ImmutableHashSet`1<TValue>> MultiRemove(ImmutableDictionary`2<TKey, ImmutableHashSet`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
private static void MultiRemoveSet(IDictionary`2<TKey, TSet> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, ImmutableHashSet`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, ImmutableSortedSet`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, TKey key, TValue value);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IGroupingExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(IGrouping`2<TKey, TElement> grouping, TKey& key, IEnumerable`1& values);
}
internal class Roslyn.Utilities.ImmutableArrayComparer`1 : object {
    [NullableAttribute("1")]
public static ImmutableArrayComparer`1<T> Instance;
    private static ImmutableArrayComparer`1();
    public sealed virtual bool Equals(ImmutableArray`1<T> x, ImmutableArray`1<T> y);
    public sealed virtual int GetHashCode(ImmutableArray`1<T> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(HashSet`1<T> set);
    [ExtensionAttribute]
public static bool Contains(ImmutableArray`1<T> items, T item, IEqualityComparer`1<T> equalityComparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArrayOrEmpty(T[] items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> TakeAsArray(ImmutableArray`1<T> array, int count);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableAndClear(Builder<T> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ConcatImmutableArray`1<T> ConcatFast(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableDictionaryExtensions : object {
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> AddAll(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, IEnumerable`1<K> keys, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> Add(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, K key, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> RemoveAll(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, IEnumerable`1<K> keys, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> Remove(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, K key, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionaryOrEmpty(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableListExtensions : object {
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(IEnumerable`1<T> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.InterlockedOperations : object {
    private static T GetOrStore(T& target, T value);
    private static int GetOrStore(Int32& target, int value, int uninitializedValue);
    public static T Initialize(T& target, Func`1<T> valueFactory);
    public static T Initialize(T& target, Func`2<TArg, T> valueFactory, TArg arg);
    public static int Initialize(Int32& target, int uninitializedValue, Func`2<TArg, int> valueFactory, TArg arg);
    [NullableContextAttribute("2")]
public static T Initialize(StrongBox`1& target, Func`1<T> valueFactory);
    [NullableContextAttribute("2")]
public static T Initialize(StrongBox`1& target, Func`2<TArg, T> valueFactory, TArg arg);
    public static T Initialize(T& target, T value);
    public static T Initialize(T& target, T initializedValue, T uninitializedValue);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Initialize(ImmutableArray`1& target, ImmutableArray`1<T> initializedValue);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Initialize(ImmutableArray`1& target, Func`1<ImmutableArray`1<T>> createArray);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Initialize(ImmutableArray`1& target, Func`2<TArg, ImmutableArray`1<T>> createArray, TArg arg);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<T> Initialize_Slow(ImmutableArray`1& target, Func`2<TArg, ImmutableArray`1<T>> createArray, TArg arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.IReadOnlyDictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetEnumerableMetadata(IReadOnlyDictionary`2<string, object> metadata, string name);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<TKey, TValue> AsNullable(IReadOnlyDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
internal interface Roslyn.Utilities.IReferenceCountedDisposable`1 {
    public T Target { get; }
    public abstract virtual T get_Target();
    public abstract virtual IReferenceCountedDisposable`1<T> TryAddReference();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ISetExtensions : object {
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, ImmutableArray`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, ImmutableArray`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.KeyValuePairUtil : object {
    public static KeyValuePair`2<K, V> Create(K key, V value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> keyValuePair, TKey& key, TValue& value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static KeyValuePair`2<TKey, TValue> ToKeyValuePair(ValueTuple`2<TKey, TValue> tuple);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.MultiDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<K, ValueSet<K, V>> _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<V> _valueComparer;
    [NullableAttribute("0")]
private ValueSet<K, V> _emptySet;
    public int Count { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<K, ValueSet<K, V>> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<K, ValueSet<K, V>> Values { get; }
    [NullableAttribute("0")]
public ValueSet<K, V> Item { get; }
    public MultiDictionary`2(IEqualityComparer`1<K> comparer);
    public MultiDictionary`2(int capacity, IEqualityComparer`1<K> comparer, IEqualityComparer`1<V> valueComparer);
    public int get_Count();
    public bool get_IsEmpty();
    public KeyCollection<K, ValueSet<K, V>> get_Keys();
    public ValueCollection<K, ValueSet<K, V>> get_Values();
    [NullableContextAttribute("0")]
public ValueSet<K, V> get_Item(K k);
    public void EnsureCapacity(int capacity);
    public bool Add(K k, V v);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<K, ValueSet<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,Roslyn.Utilities.MultiDictionary<K,V>.ValueSet>>.GetEnumerator();
    public bool ContainsKey(K k);
    internal void Clear();
    public void Remove(K key);
}
[AttributeUsageAttribute("16392")]
internal class Roslyn.Utilities.NonCopyableAttribute : Attribute {
}
[AttributeUsageAttribute("16392")]
internal class Roslyn.Utilities.NonDefaultableAttribute : Attribute {
}
internal class Roslyn.Utilities.NonReentrantLock : object {
    [NullableAttribute("1")]
private object _syncLock;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _owningThreadId;
    [NullableAttribute("1")]
public static Func`1<NonReentrantLock> Factory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    private bool IsLocked { get; }
    private bool IsOwnedByMe { get; }
    public NonReentrantLock(bool useThisInstanceForSynchronization);
    private static NonReentrantLock();
    public void Wait(CancellationToken cancellationToken);
    public void Release();
    public bool LockHeldByMe();
    public void AssertHasLock();
    private bool get_IsLocked();
    private bool get_IsOwnedByMe();
    private void TakeOwnership();
    private void ReleaseOwnership();
    [NullableContextAttribute("2")]
private static void CancellationTokenCanceledEventHandler(object obj);
    public SemaphoreDisposer DisposableWait(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ObjectReader : object {
    internal static byte VersionByte1;
    internal static byte VersionByte2;
    private BinaryReader _reader;
    private ReaderReferenceMap _stringReferenceMap;
    private ObjectReader(Stream stream, bool leaveOpen);
    [NullableContextAttribute("2")]
public static ObjectReader TryGetReader(Stream stream, bool leaveOpen);
    public static ObjectReader GetReader(Stream stream, bool leaveOpen);
    public static ObjectReader GetReader(Stream stream, bool leaveOpen, bool checkValidationBytes);
    public void CheckValidationBytes();
    public sealed virtual void Dispose();
    public bool ReadBoolean();
    public byte ReadByte();
    public char ReadChar();
    public decimal ReadDecimal();
    public double ReadDouble();
    public float ReadSingle();
    public int ReadInt32();
    public long ReadInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public ushort ReadUInt16();
    [NullableContextAttribute("2")]
public string ReadString();
    public string ReadRequiredString();
    public Guid ReadGuid();
    [NullableContextAttribute("2")]
public object ReadScalarValue();
    [NullableContextAttribute("2")]
public Encoding ReadEncoding();
    public Byte[] ReadByteArray();
    public Char[] ReadCharArray();
    public ValueTuple`2<Char[], int> ReadCharArray(Func`2<int, Char[]> getArray);
    public ValueTuple`2<T[], int> ReadRawArray(Func`4<BinaryReader, T[], int, int> read, Func`2<int, T[]> getArray);
    internal UInt32 ReadCompressedUInt();
    [NullableContextAttribute("2")]
private string ReadStringValue();
    private string ReadStringValue(TypeCode kind);
    private string ReadStringLiteral(TypeCode kind);
    private int ReadArrayLength();
    [CompilerGeneratedAttribute]
internal static TextEncodingKind <ReadEncoding>g__ToEncodingKind|27_0(TypeCode code);
}
internal class Roslyn.Utilities.ObjectWriter : object {
    public static byte ByteMarkerMask;
    public static byte Byte1Marker;
    public static byte Byte2Marker;
    public static byte Byte4Marker;
    [NullableAttribute("1")]
private BinaryWriter _writer;
    private WriterReferenceMap _stringReferenceMap;
    [NullableContextAttribute("1")]
public ObjectWriter(Stream stream, bool leaveOpen);
    [NullableContextAttribute("1")]
public ObjectWriter(Stream stream, bool leaveOpen, bool writeValidationBytes);
    public void WriteValidationBytes();
    public sealed virtual void Dispose();
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteChar(char ch);
    public void WriteDecimal(decimal value);
    public void WriteDouble(double value);
    public void WriteSingle(float value);
    public void WriteInt32(int value);
    public void WriteInt64(long value);
    public void WriteSByte(sbyte value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteUInt16(ushort value);
    [NullableContextAttribute("2")]
public void WriteString(string value);
    public void WriteGuid(Guid guid);
    [NullableContextAttribute("2")]
public void WriteScalarValue(object value);
    [NullableContextAttribute("1")]
public void WriteByteArray(Byte[] array);
    [NullableContextAttribute("1")]
public void WriteCharArray(Char[] array);
    public void WriteSpan(ReadOnlySpan`1<byte> span);
    public void WriteSpan(ReadOnlySpan`1<char> span);
    private void WriteArrayLength(int length);
    [NullableContextAttribute("1")]
private void WriteSpanPieces(ReadOnlySpan`1<T> span, Action`3<BinaryWriter, T[], int> write);
    private void WriteEncodedInt32(int v);
    private void WriteEncodedUInt32(UInt32 v);
    internal void WriteCompressedUInt(UInt32 value);
    [NullableContextAttribute("2")]
private void WriteStringValue(string value);
    [NullableContextAttribute("2")]
public void WriteEncoding(Encoding encoding);
    [CompilerGeneratedAttribute]
internal static TypeCode <WriteEncoding>g__ToTypeCode|38_0(TextEncodingKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.OneOrMany : object {
    public static OneOrMany`1<T> Create(T one);
    public static OneOrMany`1<T> Create(T one, T two);
    [NullableContextAttribute("2")]
public static OneOrMany`1<T> OneOrNone(T one);
    [NullableContextAttribute("2")]
public static OneOrMany`1<T> Create(ImmutableArray`1<T> many);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<T> array, OneOrMany`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> array, OneOrMany`1<T> other, IEqualityComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
[DebuggerTypeProxyAttribute("Roslyn.Utilities.OneOrMany`1/DebuggerProxy")]
internal class Roslyn.Utilities.OneOrMany`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OneOrMany`1<T> Empty;
    [NullableAttribute("2")]
private T _one;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<T> _many;
    [MemberNotNullWhenAttribute("True", "_one")]
private bool HasOneItem { get; }
    public bool IsDefault { get; }
    public T Item { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public OneOrMany`1(T one);
    public OneOrMany`1(ImmutableArray`1<T> many);
    private static OneOrMany`1();
    [MemberNotNullWhenAttribute("True", "_one")]
private bool get_HasOneItem();
    public bool get_IsDefault();
    public T get_Item(int index);
    public int get_Count();
    public bool get_IsEmpty();
    public OneOrMany`1<T> Add(T item);
    public bool Contains(T item);
    public OneOrMany`1<T> RemoveAll(T item);
    public OneOrMany`1<TResult> Select(Func`2<T, TResult> selector);
    public OneOrMany`1<TResult> Select(Func`3<T, TArg, TResult> selector, TArg arg);
    public T First();
    [NullableContextAttribute("2")]
public T FirstOrDefault();
    public T FirstOrDefault(Func`2<T, bool> predicate);
    public T FirstOrDefault(Func`3<T, TArg, bool> predicate, TArg arg);
    public static OneOrMany`1<T> CastUp(OneOrMany`1<TDerived> from);
    public bool All(Func`2<T, bool> predicate);
    public bool All(Func`3<T, TArg, bool> predicate, TArg arg);
    public bool Any();
    public bool Any(Func`2<T, bool> predicate);
    public bool Any(Func`3<T, TArg, bool> predicate, TArg arg);
    public ImmutableArray`1<T> ToImmutable();
    public T[] ToArray();
    public bool SequenceEqual(OneOrMany`1<T> other, IEqualityComparer`1<T> comparer);
    public bool SequenceEqual(ImmutableArray`1<T> other, IEqualityComparer`1<T> comparer);
    public bool SequenceEqual(IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private string GetDebuggerDisplay();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.OptionalExtensions : object {
    [ExtensionAttribute]
internal static T GetValueOrDefault(Optional`1<T> optional);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.OrderedMultiDictionary`2 : object {
    private Dictionary`2<K, SetWithInsertionOrder`1<V>> _dictionary;
    private List`1<K> _keys;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public SetWithInsertionOrder`1<V> Item { get; }
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public SetWithInsertionOrder`1<V> get_Item(K k);
    public void Add(K k, V v);
    public void AddRange(K k, IEnumerable`1<V> values);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.OrderedMultiDictionary`2/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<KeyValuePair`2<K, SetWithInsertionOrder`1<V>>> GetEnumerator();
}
internal enum Roslyn.Utilities.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.PathUtilities : object {
    internal static char AltDirectorySeparatorChar;
    internal static string ParentRelativeDirectory;
    internal static string ThisDirectory;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static Char[] s_pathChars;
    public static IEqualityComparer`1<string> Comparer;
    internal static char DirectorySeparatorChar { get; }
    internal static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    internal static char get_DirectorySeparatorChar();
    internal static bool get_IsUnixLikePlatform();
    public static bool IsDirectorySeparator(char c);
    public static bool IsAnyDirectorySeparator(char c);
    public static string TrimTrailingSeparators(string s);
    public static string EnsureTrailingSeparator(string s);
    public static string GetExtension(string path);
    [NullableContextAttribute("0")]
public static ReadOnlyMemory`1<char> GetExtension(ReadOnlyMemory`1<char> path);
    public static string ChangeExtension(string path, string extension);
    public static string RemoveExtension(string path);
    [NullableContextAttribute("2")]
public static string GetFileName(string path, bool includeExtension);
    [NullableContextAttribute("2")]
public static string GetDirectoryName(string path);
    [NullableContextAttribute("2")]
internal static string GetDirectoryName(string path, bool isUnixLike);
    internal static bool IsSameDirectoryOrChildOf(string child, string parent, StringComparison comparison);
    [NullableContextAttribute("2")]
public static string GetPathRoot(string path);
    [NullableContextAttribute("2")]
private static string GetPathRoot(string path, bool isUnixLike);
    private static string GetWindowsRoot(string path);
    private static int ConsumeDirectorySeparators(string path, int length, int i);
    private static string GetUnixRoot(string path);
    [NullableContextAttribute("2")]
public static PathKind GetPathKind(string path);
    [NullableContextAttribute("2")]
public static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    public static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    [NullableContextAttribute("2")]
public static string CombinePossiblyRelativeAndRelativePaths(string root, string relativePath);
    public static string CombinePathsUnchecked(string root, string relativePath);
    [NullableContextAttribute("2")]
public static string CombinePaths(string root, string path);
    private static string RemoveTrailingDirectorySeparator(string path);
    public static bool IsFilePath(string assemblyDisplayNameOrPath);
    public static bool ContainsPathComponent(string path, string component, bool ignoreCase);
    public static string GetRelativePath(string directory, string fullPath);
    public static bool IsChildPath(string parentPath, string childPath);
    private static string GetRelativeChildPath(string parentPath, string childPath);
    private static String[] GetPathParts(string path);
    public static bool PathsEqual(string path1, string path2);
    private static bool PathsEqual(string path1, string path2, int length);
    private static bool PathCharEqual(char x, char y);
    [NullableContextAttribute("2")]
private static int PathHashCode(string path);
    public static string NormalizePathPrefix(string filePath, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    public static string NormalizeDriveLetter(string filePath);
    [NullableContextAttribute("2")]
public static bool IsValidFilePath(string fullPath);
    public static string NormalizeWithForwardSlash(string p);
    [NullableContextAttribute("0")]
public static string CollapseWithForwardSlash(ReadOnlySpan`1<char> path);
    public static string ExpandAbsolutePathWithRelativeParts(string p);
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowImplicitBoxing { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitBoxing();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitBoxing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
internal static class Roslyn.Utilities.PlatformInformation : object {
    public static bool IsWindows { get; }
    public static bool IsUnix { get; }
    public static bool IsRunningOnMono { get; }
    public static bool IsUsingMonoRuntime { get; }
    public static bool get_IsWindows();
    public static bool get_IsUnix();
    public static bool get_IsRunningOnMono();
    public static bool get_IsUsingMonoRuntime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.PooledBuilderExtensions : object {
    [ExtensionAttribute]
public static Dictionary`2<K, V> ToDictionaryAndFree(PooledDictionary`2<K, V> builders);
    [ExtensionAttribute]
public static Dictionary`2<K, ImmutableArray`1<V>> ToMultiDictionaryAndFree(PooledDictionary`2<K, ArrayBuilder`1<V>> builders);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableArray`1<V>> ToImmutableMultiDictionaryAndFree(PooledDictionary`2<K, ArrayBuilder`1<V>> builders);
    [ExtensionAttribute]
public static void FreeValues(IReadOnlyDictionary`2<K, ArrayBuilder`1<V>> builders);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToFlattenedImmutableArrayAndFree(ArrayBuilder`1<ArrayBuilder`1<T>> builders);
    [ExtensionAttribute]
public static bool HasDuplicates(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static bool HasDuplicates(ArrayBuilder`1<T> builder, Func`2<T, U> selector);
}
internal static class Roslyn.Utilities.Predicates`1 : object {
    [NullableAttribute("1")]
public static Predicate`1<T> True;
    private static Predicates`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
internal static ReadLockExiter DisposableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static UpgradeableReadLockExiter DisposableUpgradeableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static WriteLockExiter DisposableWrite(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanWrite(ReaderWriterLockSlim lock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ReferenceCountedDisposable`1 : object {
    [NullableAttribute("2")]
private T _instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BoxedReferenceCount<T> _boxedReferenceCount;
    public T Target { get; }
    public ReferenceCountedDisposable`1(T instance);
    private ReferenceCountedDisposable`1(T instance, BoxedReferenceCount<T> referenceCount);
    public sealed virtual T get_Target();
    public ReferenceCountedDisposable`1<T> TryAddReference();
    private sealed virtual override IReferenceCountedDisposable`1<T> Roslyn.Utilities.IReferenceCountedDisposable<T>.TryAddReference();
    [NullableContextAttribute("2")]
private static ReferenceCountedDisposable`1<T> TryAddReferenceImpl(T target, BoxedReferenceCount<T> referenceCount);
    public sealed virtual void Dispose();
    public ValueTask DisposeAsync();
    [NullableContextAttribute("2")]
private T DisposeImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ReferenceCountedDisposableCache`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TKey, WeakReference<Entry<TKey, TValue>>> _cache;
    private object _gate;
    public IReferenceCountedDisposable`1<ICacheEntry`2<TKey, TValue>> GetOrCreate(TKey key, Func`3<TKey, TArg, TValue> valueCreator, TArg arg);
    public void Evict(TKey key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ReferenceEqualityComparer : object {
    [NullableAttribute("1")]
public static ReferenceEqualityComparer Instance;
    private static ReferenceEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object a);
    public static int GetHashCode(object a);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReflectionUtilities : object {
    private static Type Missing;
    private static ReflectionUtilities();
    public static Type TryGetType(string assemblyQualifiedName);
    [NullableContextAttribute("2")]
public static Type TryGetType(Type& lazyType, string assemblyQualifiedName);
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static Type GetTypeFromEither(Type& lazyType, string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static object InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static T Invoke(MethodInfo methodInfo, object obj, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
    [ConditionalAttribute("DEBUG")]
public static void AssertNotNull(T value);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
internal static void AssertOrFailFast(bool condition, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynString : object {
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SemaphoreSlimExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SemaphoreDisposer DisposableWait(SemaphoreSlim semaphore, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SemaphoreSlimExtensions/<DisposableWaitAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<SemaphoreDisposer> DisposableWaitAsync(SemaphoreSlim semaphore, CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.SemaphoreSlimFactory : object {
    [NullableAttribute("1")]
public static Func`1<SemaphoreSlim> Instance;
    private static SemaphoreSlimFactory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.SetWithInsertionOrder`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<T> _set;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<T> _elements;
    public int Count { get; }
    public T Item { get; }
    private IReadOnlySet`1<T> Set { get; }
    public bool Add(T value);
    public bool Insert(int index, T value);
    public bool Remove(T value);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableArray`1<T> AsImmutable();
    public sealed virtual T get_Item(int i);
    private IReadOnlySet`1<T> get_Set();
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.SharedStopwatch : ValueType {
    private static Stopwatch s_stopwatch;
    private TimeSpan _started;
    public TimeSpan Elapsed { get; }
    private SharedStopwatch(TimeSpan started);
    private static SharedStopwatch();
    public TimeSpan get_Elapsed();
    public static SharedStopwatch StartNew();
    private static SharedStopwatch StartNewCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.SimplePool`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<T> <allocate>P;
    private object _gate;
    private Stack`1<T> _values;
    public SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NonCopyableAttribute]
internal class Roslyn.Utilities.SingleInitNullable`1 : ValueType {
    private int _initialized;
    private T _value;
    public T Initialize(Func`2<TArg, T> valueFactory, TArg arg);
    private Nullable`1<T> ReadIfInitialized();
    private T GetOrStore(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.SoftCrashException : OperationCanceledException {
    public SoftCrashException(string message);
    public SoftCrashException(CancellationToken token);
    public SoftCrashException(string message, Exception innerException);
    public SoftCrashException(string message, CancellationToken token);
    public SoftCrashException(string message, Exception innerException, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.SpecializedCollections : object {
    public static IEnumerator`1<T> EmptyEnumerator();
    public static IEnumerable`1<T> EmptyEnumerable();
    public static ICollection`1<T> EmptyCollection();
    public static IList`1<T> EmptyList();
    public static IReadOnlyList`1<T> EmptyBoxedImmutableArray();
    public static IReadOnlyList`1<T> EmptyReadOnlyList();
    public static ISet`1<T> EmptySet();
    public static IReadOnlySet`1<T> EmptyReadOnlySet();
    public static IDictionary`2<TKey, TValue> EmptyDictionary();
    public static IReadOnlyDictionary`2<TKey, TValue> EmptyReadOnlyDictionary();
    public static IEnumerable`1<T> SingletonEnumerable(T value);
    public static ICollection`1<T> SingletonCollection(T value);
    public static IEnumerator`1<T> SingletonEnumerator(T value);
    public static IReadOnlyList`1<T> SingletonReadOnlyList(T value);
    public static IList`1<T> SingletonList(T value);
    public static IEnumerable`1<T> ReadOnlyEnumerable(IEnumerable`1<T> values);
    public static ICollection`1<T> ReadOnlyCollection(ICollection`1<T> collection);
    public static ISet`1<T> ReadOnlySet(ISet`1<T> set);
    public static IReadOnlySet`1<T> StronglyTypedReadOnlySet(ISet`1<T> set);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.SpecializedTasks : object {
    public static Task`1<bool> True;
    public static Task`1<bool> False;
    [ObsoleteAttribute("Use Task.CompletedTask instead which is available in the framework.")]
public static Task EmptyTask;
    private static SpecializedTasks();
    [ExtensionAttribute]
public static Task`1<T> AsNullable(Task`1<T> task);
    [NullableContextAttribute("2")]
public static Task`1<T> Default();
    public static Task`1<T> Null();
    public static Task`1<IReadOnlyList`1<T>> EmptyReadOnlyList();
    public static Task`1<IList`1<T>> EmptyList();
    [NullableContextAttribute("2")]
public static Task`1<ImmutableArray`1<T>> EmptyImmutableArray();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    [NullableContextAttribute("2")]
public static ValueTask`1<T[]> WhenAll(IEnumerable`1<ValueTask`1<T>> tasks);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SpecializedTasks/<WhenAll>d__11`1")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> WhenAll(IReadOnlyCollection`1<Task`1<TResult>> tasks);
    [NullableContextAttribute("2")]
public static ValueTask`1<TResult> TransformWithoutIntermediateCancellationExceptionAsync(Func`3<TArg, CancellationToken, ValueTask`1<TIntermediate>> func, Func`3<TIntermediate, TArg, TResult> transform, TArg arg, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<TResult> <TransformWithoutIntermediateCancellationExceptionAsync>g__UnwrapAndTransformAsync|12_0(ValueTask`1<TIntermediate> intermediateResult, Func`3<TIntermediate, TArg, TResult> transform, TArg arg, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.StreamExtensions : object {
    [ExtensionAttribute]
public static int TryReadAll(Stream stream, Byte[] buffer, int offset, int count);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringEscapeEncoder : object {
    [ExtensionAttribute]
public static string Escape(string text, char escapePrefix, Char[] prohibitedCharacters);
    [ExtensionAttribute]
public static string Unescape(string text, char escapePrefix);
    private static int ParseHex(string text, int start, int length);
    private static bool IsHexDigit(char ch);
    private static int GetHexValue(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_lazyNumerals;
    private static Func`2<char, char> s_toLower;
    private static Func`2<char, char> s_toUpper;
    private static string AttributeSuffix;
    private static StringExtensions();
    internal static string GetNumeral(int number);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static bool LooksLikeInterfaceName(string name);
    [ExtensionAttribute]
public static bool LooksLikeTypeParameterName(string name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string ToPascalCase(string shortName, bool trimLeadingTypePrefix);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string ToCamelCase(string shortName, bool trimLeadingTypePrefix);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static string ConvertCase(string shortName, bool trimLeadingTypePrefix, Func`2<char, char> convert);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsValidClrTypeName(string name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsValidClrNamespaceName(string name);
    [ExtensionAttribute]
internal static string GetWithSingleAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, String& result);
    [ExtensionAttribute]
internal static string GetWithoutAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, bool isCaseSensitive, String& result);
    [ExtensionAttribute]
internal static bool HasAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool IsValidUnicodeString(string str);
    [ExtensionAttribute]
internal static string Unquote(string arg);
    [ExtensionAttribute]
internal static string Unquote(string arg, Boolean& quoted);
    [ExtensionAttribute]
internal static char First(string arg);
    [ExtensionAttribute]
internal static char Last(string arg);
    [ExtensionAttribute]
internal static bool All(string arg, Predicate`1<char> predicate);
    [ExtensionAttribute]
public static int GetCaseInsensitivePrefixLength(string string1, string string2);
    [ExtensionAttribute]
public static int GetCaseSensitivePrefixLength(string string1, string string2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.StringTable : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    private Entry[] _localTable;
    [NullableAttribute("0")]
private static SegmentedArray`1<Entry> s_sharedTable;
    private int _localRandom;
    private static int s_sharedRandom;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<StringTable> _pool;
    private static ObjectPool`1<StringTable> s_staticPool;
    private StringTable(ObjectPool`1<StringTable> pool);
    private static StringTable();
    private static ObjectPool`1<StringTable> CreatePool();
    public static StringTable GetInstance();
    public void Free();
    internal string Add(Char[] chars, int start, int len);
    internal string Add(string chars, int start, int len);
    internal string Add(char chars);
    internal string Add(StringBuilder chars);
    internal string Add(string chars);
    private static string FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    private static string FindSharedEntry(string chars, int start, int len, int hashCode);
    [NullableContextAttribute("0")]
private static string FindSharedEntryASCII(int hashCode, ReadOnlySpan`1<byte> asciiChars);
    [NullableContextAttribute("2")]
private static string FindSharedEntry(char chars, int hashCode);
    private static string FindSharedEntry(StringBuilder chars, int hashCode);
    private static string FindSharedEntry(string chars, int hashCode);
    private string AddItem(Char[] chars, int start, int len, int hashCode);
    private string AddItem(string chars, int start, int len, int hashCode);
    private string AddItem(char chars, int hashCode);
    private string AddItem(StringBuilder chars, int hashCode);
    private void AddCore(string chars, int hashCode);
    private void AddSharedEntry(int hashCode, string text);
    internal static string AddShared(StringBuilder chars);
    private static string AddSharedSlow(int hashCode, StringBuilder builder);
    [NullableContextAttribute("0")]
internal static string AddSharedUtf8(ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("0")]
private static string AddSharedSlow(int hashCode, ReadOnlySpan`1<byte> utf8Bytes, bool isAscii);
    private static void AddSharedSlow(int hashCode, string text);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int LocalNextRandom();
    private static int SharedNextRandom();
    internal static bool TextEquals(string array, string text, int start, int length);
    internal static bool TextEquals(string array, StringBuilder text);
    [NullableContextAttribute("0")]
internal static bool TextEqualsASCII(string text, ReadOnlySpan`1<byte> ascii);
    [NullableContextAttribute("0")]
internal static bool TextEquals(string array, ReadOnlySpan`1<char> text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.SyntaxPath : object {
    private List`1<PathSegment> _segments;
    private int _kind;
    private bool _trackKinds;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public SyntaxPath(SyntaxNodeOrToken nodeOrToken, bool trackKinds);
    [CompilerGeneratedAttribute]
private SyntaxPath(SyntaxPath original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    private void AddSegment(SyntaxNodeOrToken nodeOrToken);
    [NullableContextAttribute("2")]
public bool TryResolve(SyntaxNode root, SyntaxNodeOrToken& nodeOrToken);
    private SyntaxNodeOrToken FindChild(SyntaxNodeOrToken current, PathSegment segment);
    public bool TryResolve(SyntaxTree syntaxTree, CancellationToken cancellationToken, TNode& node);
    [NullableContextAttribute("2")]
public bool TryResolve(SyntaxNode root, TNode& node);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SyntaxPath other);
    public virtual int GetHashCode();
    private int GetSegmentHashCode();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SyntaxPath left, SyntaxPath right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SyntaxPath left, SyntaxPath right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public SyntaxPath <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.TaskExtensions : object {
    [ExtensionAttribute]
public static T WaitAndGetResult(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T WaitAndGetResult_CanCallOnBackground(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task`1<TInput> task, Action`1<Task`1<TInput>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task task, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWithFromAsync(Task`1<TInput> task, Func`2<Task`1<TInput>, Task`1<TResult>> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWithFromAsync(Task task, Func`2<Task, Task`1<TResult>> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task`1<TInput> task, Func`2<Task`1<TInput>, Task> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task ContinueWithAfterDelayFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TimeSpan delay, IExpeditableDelaySource delaySource, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    internal static void ReportNonFatalError(Task task, object continuationFunction);
    private static void ReportNonFatalErrorWorker(Task task, object continuationFunction);
    [ExtensionAttribute]
public static Task ReportNonFatalErrorAsync(Task task);
    [ExtensionAttribute]
public static Task ReportNonFatalErrorUnlessCancelledAsync(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void VerifyCompleted(Task task);
    [ExtensionAttribute]
public static TResult VerifyCompleted(Task`1<TResult> task);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static TResult <SafeContinueWith>g__outerFunction|5_0(Task t, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.TaskFactoryExtensions : object {
    [ExtensionAttribute]
public static Task SafeStartNew(TaskFactory factory, Action action, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNew(TaskFactory factory, Func`1<TResult> func, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeStartNewFromAsync(TaskFactory factory, Func`1<Task> actionAsync, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNewFromAsync(TaskFactory factory, Func`1<Task`1<TResult>> funcAsync, CancellationToken cancellationToken, TaskScheduler scheduler);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TextChangeRangeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Nullable`1<TextChangeRange> Accumulate(Nullable`1<TextChangeRange> accumulatedTextChangeSoFar, IEnumerable`1<TextChangeRange> changesInNextVersion);
    [ExtensionAttribute]
public static TextChangeRange ToTextChangeRange(TextChange textChange);
    public static ImmutableArray`1<TextChangeRange> Merge(ImmutableArray`1<TextChangeRange> oldChanges, ImmutableArray`1<TextChangeRange> newChanges);
    [ExtensionAttribute]
private static int NewEnd(TextChangeRange range);
    [CompilerGeneratedAttribute]
internal static bool <Merge>g__tryGetNextOldChange|2_0(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <Merge>g__tryGetNextNewChange|2_1(<>c__DisplayClass2_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <Merge>g__addAndAdjustOldDelta|2_2(ArrayBuilder`1<TextChangeRange> builder, Int32& oldDelta, TextChangeRange oldChange);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <Merge>g__adjustAndAddNewChange|2_3(ArrayBuilder`1<TextChangeRange> builder, int oldDelta, UnadjustedNewChange newChange);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <Merge>g__add|2_4(ArrayBuilder`1<TextChangeRange> builder, TextChangeRange change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.TopologicalSorter : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore, Func`2<T, IEnumerable`1<T>> itemsAfter);
    private static void Visit(T item, Func`2<T, IEnumerable`1<T>> itemsBefore, List`1<T> result, HashSet`1<T> visited);
    private static Func`2<T, IEnumerable`1<T>> CreateCombinedItemsBefore(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore, Func`2<T, IEnumerable`1<T>> itemsAfter);
}
internal static class Roslyn.Utilities.UnicodeCharacterUtilities : object {
    public static bool IsIdentifierStartCharacter(char ch);
    public static bool IsIdentifierPartCharacter(char ch);
    [NullableContextAttribute("2")]
public static bool IsValidIdentifier(string name);
    private static bool IsLetterChar(UnicodeCategory cat);
    private static bool IsCombiningChar(UnicodeCategory cat);
    private static bool IsDecimalDigitChar(UnicodeCategory cat);
    private static bool IsConnectingChar(UnicodeCategory cat);
    internal static bool IsFormattingChar(char ch);
    private static bool IsFormattingChar(UnicodeCategory cat);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ValueTaskExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T VerifyCompleted(ValueTask`1<T> task, string message);
}
internal static class Roslyn.Utilities.ValueTaskFactory : object {
    public static ValueTask CompletedTask { get; }
    [NullableContextAttribute("1")]
public static ValueTask`1<T> FromResult(T result);
    public static ValueTask get_CompletedTask();
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.VoidResult : ValueType {
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VoidResult other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.WeakEvent`1 : object {
    private ConditionalWeakTable`2<object, EventHandler`1<TEventArgs>> _keepAliveTable;
    private ImmutableList`1<WeakReference`1<EventHandler`1<TEventArgs>>> _weakHandlers;
    public void AddHandler(object target, EventHandler`1<TEventArgs> handler);
    public void RemoveHandler(object target, EventHandler`1<TEventArgs> handler);
    public void RaiseEvent(object sender, TEventArgs e);
}
internal static class Roslyn.Utilities.WeakEventHandler`1 : object {
    [NullableContextAttribute("1")]
public static EventHandler`1<TArgs> Create(TTarget target, Action`3<TTarget, object, TArgs> invoker);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.WeakReferenceExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T GetTarget(WeakReference`1<T> reference);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNull(WeakReference`1<T> reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.WordSimilarityChecker : ValueType {
    private CacheResult _lastAreSimilarResult;
    private string _source;
    private EditDistance _editDistance;
    private int _threshold;
    private bool _substringsAreSimilar;
    public bool IsDefault { get; }
    public WordSimilarityChecker(string text, bool substringsAreSimilar);
    [IsReadOnlyAttribute]
public bool get_IsDefault();
    [IsReadOnlyAttribute]
public sealed virtual void Dispose();
    public static bool AreSimilar(string originalText, string candidateText);
    public static bool AreSimilar(string originalText, string candidateText, bool substringsAreSimilar);
    public static bool AreSimilar(string originalText, string candidateText, Double& similarityWeight);
    public static bool AreSimilar(string originalText, string candidateText, bool substringsAreSimilar, Double& similarityWeight);
    internal static int GetThreshold(string value);
    public bool AreSimilar(string candidateText);
    public bool AreSimilar(string candidateText, Double& similarityWeight);
    private bool AreSimilarWorker(string candidateText, Double& similarityWeight);
    private static double Penalty(string candidateText, string originalText);
    [IsReadOnlyAttribute]
public bool LastCacheResultIs(bool areSimilar, string candidateText);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.YieldAwaitableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredYieldAwaitable ConfigureAwait(YieldAwaitable awaitable, bool continueOnCapturedContext);
}
[NullableContextAttribute("1")]
internal interface System.Collections.Generic.IReadOnlySet`1 {
    public abstract virtual bool Contains(T item);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
internal class System.Diagnostics.CodeAnalysis.ExperimentalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string DiagnosticId { get; }
    [NullableAttribute("2")]
public string UrlFormat { get; public set; }
    public ExperimentalAttribute(string diagnosticId);
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_UrlFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[IsReadOnlyAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal abstract class System.IO.Hashing.NonCryptographicHashAlgorithm : object {
    [CompilerGeneratedAttribute]
private int <HashLengthInBytes>k__BackingField;
    public int HashLengthInBytes { get; }
    protected NonCryptographicHashAlgorithm(int hashLengthInBytes);
    [CompilerGeneratedAttribute]
public int get_HashLengthInBytes();
    public abstract virtual void Append(ReadOnlySpan`1<byte> source);
    public abstract virtual void Reset();
    protected abstract virtual void GetCurrentHashCore(Span`1<byte> destination);
    public void Append(Byte[] source);
    public void Append(Stream stream);
    public Task AppendAsync(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Hashing.NonCryptographicHashAlgorithm/<AppendAsyncCore>d__10")]
private Task AppendAsyncCore(Stream stream, CancellationToken cancellationToken);
    public Byte[] GetCurrentHash();
    public bool TryGetCurrentHash(Span`1<byte> destination, Int32& bytesWritten);
    public int GetCurrentHash(Span`1<byte> destination);
    public Byte[] GetHashAndReset();
    public bool TryGetHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public int GetHashAndReset(Span`1<byte> destination);
    protected virtual void GetHashAndResetCore(Span`1<byte> destination);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetCurrentHash() to retrieve the computed hash code.", "True")]
public virtual int GetHashCode();
    [DoesNotReturnAttribute]
private protected static void ThrowDestinationTooShort();
}
internal class System.IO.Hashing.XxHash128 : NonCryptographicHashAlgorithm {
    private static int HashLengthInBytes;
    private State _state;
    public XxHash128(long seed);
    public static Byte[] Hash(Byte[] source);
    public static Byte[] Hash(Byte[] source, long seed);
    public static Byte[] Hash(ReadOnlySpan`1<byte> source, long seed);
    public static int Hash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, long seed);
    public static bool TryHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten, long seed);
    private static Hash128 HashToHash128(ReadOnlySpan`1<byte> source, long seed);
    public virtual void Reset();
    public virtual void Append(ReadOnlySpan`1<byte> source);
    protected virtual void GetCurrentHashCore(Span`1<byte> destination);
    private Hash128 GetCurrentHashAsHash128();
    private static void WriteBigEndian128(Hash128& hash, Span`1<byte> destination);
    private static Hash128 HashLength0To16(Byte* source, UInt32 length, ulong seed);
    private static Hash128 HashLength1To3(Byte* source, UInt32 length, ulong seed);
    private static Hash128 HashLength4To8(Byte* source, UInt32 length, ulong seed);
    private static Hash128 HashLength9To16(Byte* source, UInt32 length, ulong seed);
    private static Hash128 HashLength17To128(Byte* source, UInt32 length, ulong seed);
    private static Hash128 HashLength129To240(Byte* source, UInt32 length, ulong seed);
    private static Hash128 HashLengthOver240(Byte* source, UInt32 length, ulong seed);
    private static Hash128 AvalancheHash(ulong accLow, ulong accHigh, UInt32 length, ulong seed);
    private static void Mix32Bytes(UInt64& accLow, UInt64& accHigh, Byte* input1, Byte* input2, ulong secret1, ulong secret2, ulong secret3, ulong secret4, ulong seed);
}
internal class System.IO.Hashing.XxHash64 : object {
    internal static ulong Avalanche(ulong hash);
}
internal static class System.IO.Hashing.XxHashShared : object {
    public static int StripeLengthBytes;
    public static int SecretLengthBytes;
    public static int SecretSizeMin;
    public static int SecretLastAccStartBytes;
    public static int SecretConsumeRateBytes;
    public static int SecretMergeAccsStartBytes;
    public static int NumStripesPerBlock;
    public static int AccumulatorCount;
    public static int MidSizeMaxBytes;
    public static int InternalBufferStripes;
    public static int InternalBufferLengthBytes;
    public static ulong DefaultSecretUInt64_0;
    public static ulong DefaultSecretUInt64_1;
    public static ulong DefaultSecretUInt64_2;
    public static ulong DefaultSecretUInt64_3;
    public static ulong DefaultSecretUInt64_4;
    public static ulong DefaultSecretUInt64_5;
    public static ulong DefaultSecretUInt64_6;
    public static ulong DefaultSecretUInt64_7;
    public static ulong DefaultSecretUInt64_8;
    public static ulong DefaultSecretUInt64_9;
    public static ulong DefaultSecretUInt64_10;
    public static ulong DefaultSecretUInt64_11;
    public static ulong DefaultSecretUInt64_12;
    public static ulong DefaultSecretUInt64_13;
    public static ulong DefaultSecretUInt64_14;
    public static ulong DefaultSecretUInt64_15;
    public static ulong DefaultSecret3UInt64_0;
    public static ulong DefaultSecret3UInt64_1;
    public static ulong DefaultSecret3UInt64_2;
    public static ulong DefaultSecret3UInt64_3;
    public static ulong DefaultSecret3UInt64_4;
    public static ulong DefaultSecret3UInt64_5;
    public static ulong DefaultSecret3UInt64_6;
    public static ulong DefaultSecret3UInt64_7;
    public static ulong DefaultSecret3UInt64_8;
    public static ulong DefaultSecret3UInt64_9;
    public static ulong DefaultSecret3UInt64_10;
    public static ulong DefaultSecret3UInt64_11;
    public static ulong DefaultSecret3UInt64_12;
    public static ulong DefaultSecret3UInt64_13;
    public static ulong Prime64_1;
    public static ulong Prime64_2;
    public static ulong Prime64_3;
    public static ulong Prime64_4;
    public static ulong Prime64_5;
    public static UInt32 Prime32_1;
    public static UInt32 Prime32_2;
    public static UInt32 Prime32_3;
    public static UInt32 Prime32_4;
    public static UInt32 Prime32_5;
    public static ReadOnlySpan`1<byte> DefaultSecret { get; }
    public static ReadOnlySpan`1<byte> get_DefaultSecret();
    public static void Initialize(State& state, ulong seed);
    public static void Reset(State& state);
    public static void HashInternalLoop(UInt64* accumulators, Byte* source, UInt32 length, Byte* secret);
    public static void ConsumeStripes(UInt64* accumulators, UInt64& stripesSoFar, ulong stripesPerBlock, Byte* source, ulong stripes, Byte* secret);
    public static void Append(State& state, ReadOnlySpan`1<byte> source);
    public static void CopyAccumulators(State& state, UInt64* accumulators);
    public static void DigestLong(State& state, UInt64* accumulators, Byte* secret);
    public static void InitializeAccumulators(UInt64* accumulators);
    public static ulong MergeAccumulators(UInt64* accumulators, Byte* secret, ulong start);
    public static ulong Mix16Bytes(Byte* source, ulong secretLow, ulong secretHigh, ulong seed);
    public static ulong Multiply32To64(UInt32 v1, UInt32 v2);
    public static ulong Avalanche(ulong hash);
    public static ulong Multiply64To128(ulong left, ulong right, UInt64& lower);
    public static ulong Multiply64To128ThenFold(ulong left, ulong right);
    public static void DeriveSecretFromSeed(Byte* destinationSecret, ulong seed);
    private static void Accumulate(UInt64* accumulators, Byte* source, Byte* secret, int stripesToProcess, bool scramble, int blockCount);
    public static void Accumulate512(UInt64* accumulators, Byte* source, Byte* secret);
    private static void Accumulate512Inlined(UInt64* accumulators, Byte* source, Byte* secret);
    private static void ScrambleAccumulators(UInt64* accumulators, Byte* secret);
    public static ulong XorShift(ulong value, int shift);
    public static UInt32 ReadUInt32LE(Byte* data);
    public static ulong ReadUInt64LE(Byte* data);
    private static void WriteUInt64LE(Byte* data, ulong value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Linq.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static T AggregateOrDefault(IEnumerable`1<T> source, Func`3<T, T, T> func);
    [ExtensionAttribute]
public static IEnumerable`1<TSource[]> Chunk(IEnumerable`1<TSource> source, int size);
    [IteratorStateMachineAttribute("System.Linq.EnumerableExtensions/<ArrayChunkIterator>d__3`1")]
private static IEnumerable`1<TSource[]> ArrayChunkIterator(TSource[] source, int size);
    [IteratorStateMachineAttribute("System.Linq.EnumerableExtensions/<EnumerableChunkIterator>d__4`1")]
private static IEnumerable`1<TSource[]> EnumerableChunkIterator(IEnumerable`1<TSource> source, int size);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Linq.ImmutableSegmentedListExtensions : object {
    [ExtensionAttribute]
public static bool All(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Any(ImmutableSegmentedList`1<T> immutableList);
    [ExtensionAttribute]
public static bool Any(Builder<T> builder);
    [ExtensionAttribute]
public static bool Any(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Last(ImmutableSegmentedList`1<T> immutableList);
    [ExtensionAttribute]
public static T Last(Builder<T> builder);
    [ExtensionAttribute]
public static T Last(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(ImmutableSegmentedList`1<T> immutableList, Func`2<T, TResult> selector);
}
[ExtensionAttribute]
internal static class System.Linq.RoslynEnumerable : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SegmentedList`1<TSource> ToSegmentedList(IEnumerable`1<TSource> source);
}
internal static class System.Numerics.RuntimeBitOperations : object {
    public static UInt32 RotateLeft(UInt32 value, int offset);
    public static ulong RotateLeft(ulong value, int offset);
}
[IsReadOnlyAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <ToString>g__getFromEndSpecifier|10_0(Index index);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <ToString>g__toString|10_1(Index index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class System.Runtime.CompilerServices.RestrictedInternalsVisibleToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AllowedNamespaces>k__BackingField;
    public string AssemblyName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AllowedNamespaces { get; }
    public RestrictedInternalsVisibleToAttribute(string assemblyName, String[] allowedNamespaces);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_AllowedNamespaces();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Rune : ValueType {
    private static char HighSurrogateStart;
    private static char LowSurrogateStart;
    private static int HighSurrogateRange;
    private static byte IsWhiteSpaceFlag;
    private static byte IsLetterOrDigitFlag;
    private static byte UnicodeCategoryMask;
    private UInt32 _value;
    private static ReadOnlySpan`1<byte> AsciiCharInfo { get; }
    private string DebuggerDisplay { get; }
    public bool IsAscii { get; }
    public bool IsBmp { get; }
    public int Plane { get; }
    public static Rune ReplacementChar { get; }
    public int Utf16SequenceLength { get; }
    public int Utf8SequenceLength { get; }
    public int Value { get; }
    public Rune(char ch);
    public Rune(char highSurrogate, char lowSurrogate);
    public Rune(int value);
    public Rune(UInt32 value);
    private Rune(UInt32 scalarValue, bool unused);
    private static ReadOnlySpan`1<byte> get_AsciiCharInfo();
    public static bool op_LessThan(Rune left, Rune right);
    public static bool op_LessThanOrEqual(Rune left, Rune right);
    public static bool op_GreaterThan(Rune left, Rune right);
    public static bool op_GreaterThanOrEqual(Rune left, Rune right);
    public static Rune op_Explicit(char ch);
    public static Rune op_Explicit(UInt32 value);
    public static Rune op_Explicit(int value);
    private string get_DebuggerDisplay();
    public bool get_IsAscii();
    public bool get_IsBmp();
    public int get_Plane();
    public static Rune get_ReplacementChar();
    public int get_Utf16SequenceLength();
    public int get_Utf8SequenceLength();
    public int get_Value();
    private static Rune ChangeCaseCultureAware(Rune rune, CultureInfo culture, bool toUpper);
    public sealed virtual int CompareTo(Rune other);
    public static OperationStatus DecodeFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> source, Rune& result, Int32& bytesConsumed);
    public static OperationStatus DecodeLastFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeLastFromUtf8(ReadOnlySpan`1<byte> source, Rune& value, Int32& bytesConsumed);
    public int EncodeToUtf16(Span`1<char> destination);
    public int EncodeToUtf8(Span`1<byte> destination);
    public static Rune GetRuneAt(string input, int index);
    public static bool IsValid(int value);
    public static bool IsValid(UInt32 value);
    internal static int ReadFirstRuneFromUtf16Buffer(ReadOnlySpan`1<char> input);
    private static int ReadRuneFromString(string input, int index);
    public virtual string ToString();
    public static bool TryCreate(char ch, Rune& result);
    public static bool TryCreate(char highSurrogate, char lowSurrogate, Rune& result);
    public static bool TryCreate(int value, Rune& result);
    public static bool TryCreate(UInt32 value, Rune& result);
    public bool TryEncodeToUtf16(Span`1<char> destination, Int32& charsWritten);
    public bool TryEncodeToUtf8(Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryGetRuneAt(string input, int index, Rune& value);
    internal static Rune UnsafeCreate(UInt32 scalarValue);
    public static double GetNumericValue(Rune value);
    public static UnicodeCategory GetUnicodeCategory(Rune value);
    private static UnicodeCategory GetUnicodeCategoryNonAscii(Rune value);
    private static bool IsCategoryLetter(UnicodeCategory category);
    private static bool IsCategoryLetterOrDecimalDigit(UnicodeCategory category);
    private static bool IsCategoryNumber(UnicodeCategory category);
    private static bool IsCategoryPunctuation(UnicodeCategory category);
    private static bool IsCategorySeparator(UnicodeCategory category);
    private static bool IsCategorySymbol(UnicodeCategory category);
    public static bool IsControl(Rune value);
    public static bool IsDigit(Rune value);
    public static bool IsLetter(Rune value);
    public static bool IsLetterOrDigit(Rune value);
    public static bool IsLower(Rune value);
    public static bool IsNumber(Rune value);
    public static bool IsPunctuation(Rune value);
    public static bool IsSeparator(Rune value);
    public static bool IsSymbol(Rune value);
    public static bool IsUpper(Rune value);
    public static bool IsWhiteSpace(Rune value);
    public static Rune ToLower(Rune value, CultureInfo culture);
    public static Rune ToLowerInvariant(Rune value);
    public static Rune ToUpper(Rune value, CultureInfo culture);
    public static Rune ToUpperInvariant(Rune value);
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Rune left, Rune right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Rune left, Rune right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Rune other);
}
internal static class System.Text.Unicode.Utf16Utility : object {
    internal static bool AllCharsInUInt32AreAscii(UInt32 value);
    internal static bool AllCharsInUInt64AreAscii(ulong value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToLowercase(UInt32 value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToUppercase(UInt32 value);
    internal static bool UInt32ContainsAnyLowercaseAsciiChar(UInt32 value);
    internal static bool UInt32ContainsAnyUppercaseAsciiChar(UInt32 value);
    internal static bool UInt32OrdinalIgnoreCaseAscii(UInt32 valueA, UInt32 valueB);
    internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB);
}
internal static class System.Text.UnicodeDebug : object {
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsHighSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsLowSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidScalar(UInt32 scalarValue);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidSupplementaryPlaneScalar(UInt32 scalarValue);
    private static string ToHexString(UInt32 codePoint);
}
internal static class System.Text.UnicodeUtility : object {
    public static UInt32 ReplacementChar;
    public static int GetPlane(UInt32 codePoint);
    public static UInt32 GetScalarFromUtf16SurrogatePair(UInt32 highSurrogateCodePoint, UInt32 lowSurrogateCodePoint);
    public static int GetUtf16SequenceLength(UInt32 value);
    public static void GetUtf16SurrogatesFromSupplementaryPlaneScalar(UInt32 value, Char& highSurrogateCodePoint, Char& lowSurrogateCodePoint);
    public static int GetUtf8SequenceLength(UInt32 value);
    public static bool IsAsciiCodePoint(UInt32 value);
    public static bool IsBmpCodePoint(UInt32 value);
    public static bool IsHighSurrogateCodePoint(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsLowSurrogateCodePoint(UInt32 value);
    public static bool IsSurrogateCodePoint(UInt32 value);
    public static bool IsValidCodePoint(UInt32 codePoint);
    public static bool IsValidUnicodeScalar(UInt32 value);
}
