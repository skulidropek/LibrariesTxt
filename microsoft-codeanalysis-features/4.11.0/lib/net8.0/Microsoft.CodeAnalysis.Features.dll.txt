internal static class Microsoft.Cci.CompilationOptionNames : object {
    public static string CompilationOptionsVersion;
    public static string CompilerVersion;
    public static string FallbackEncoding;
    public static string DefaultEncoding;
    public static string PortabilityPolicy;
    public static string RuntimeVersion;
    public static string Platform;
    public static string Optimization;
    public static string Checked;
    public static string Language;
    public static string LanguageVersion;
    public static string Unsafe;
    public static string Nullable;
    public static string Define;
    public static string SourceFileCount;
    public static string EmbedRuntime;
    public static string GlobalNamespaces;
    public static string RootNamespace;
    public static string OptionStrict;
    public static string OptionInfer;
    public static string OptionExplicit;
    public static string OptionCompareText;
    public static string OutputKind;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AbstractProjectExtensionProvider`3 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConditionalWeakTable`2<IReadOnlyList`1<AnalyzerReference>, StrongBox`1<ImmutableArray`1<TExtension>>> s_referencesToExtensionsMap;
    private static ConditionalWeakTable`2<AnalyzerReference, TProvider> s_referenceToProviderMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConditionalWeakTable`2<TExtension, ExtensionInfo<TProvider, TExtension, TExportAttribute>> s_extensionInfoMap;
    [CompilerGeneratedAttribute]
private AnalyzerReference <Reference>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ImmutableArray`1<TExtension>> _extensionsPerLanguage;
    private AnalyzerReference Reference { get; private set; }
    private static AbstractProjectExtensionProvider`3();
    [CompilerGeneratedAttribute]
private AnalyzerReference get_Reference();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Reference(AnalyzerReference value);
    protected abstract virtual ImmutableArray`1<string> GetLanguages(TExportAttribute exportAttribute);
    protected abstract virtual bool TryGetExtensionsFromReference(AnalyzerReference reference, ImmutableArray`1& extensions);
    public static bool TryGetCachedExtensions(IReadOnlyList`1<AnalyzerReference> analyzerReferences, ImmutableArray`1& extensions);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TExtension> GetExtensions(Project project);
    public static ImmutableArray`1<TExtension> GetExtensions(string language, IReadOnlyList`1<AnalyzerReference> analyzerReferences);
    public static ImmutableArray`1<TExtension> GetExtensions(TextDocument document, Func`2<TExportAttribute, ExtensionInfo<TProvider, TExtension, TExportAttribute>> getExtensionInfoForFiltering);
    public static ImmutableArray`1<TExtension> FilterExtensions(TextDocument document, ImmutableArray`1<TExtension> extensions, Func`2<TExportAttribute, ExtensionInfo<TProvider, TExtension, TExportAttribute>> getExtensionInfoForFiltering);
    private ImmutableArray`1<TExtension> GetExtensions(string language);
    private ImmutableArray`1<TExtension> CreateExtensions(string language);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<TExtension> <GetExtensions>g__GetExtensionsSlow|13_0(string language, IReadOnlyList`1<AnalyzerReference> analyzerReferences);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<TExtension> <GetExtensions>g__ComputeExtensions|13_1(string language, IReadOnlyList`1<AnalyzerReference> analyzerReferences);
}
internal abstract class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiers`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, SyntaxNode member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifierAdded);
    [NullableContextAttribute("1")]
public abstract virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, TMemberDeclarationSyntax member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifierAdded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual SyntaxNode MapToDeclarator(SyntaxNode declaration);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersCodeFixProvider/<FixAllAsync>d__4")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected static ImmutableDictionary`2<string, string> ModifiersAddedProperties;
    private static AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    protected abstract virtual void ProcessCompilationUnit(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, TCompilationUnitSyntax compilationUnitSyntax);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AddAccessibilityModifiersConstants : object {
    [NullableAttribute("1")]
public static string ModifiersAdded;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddAccessibilityModifiers.AddAccessibilityModifiersHelpers : object {
    public static void UpdateDeclaration(SyntaxEditor editor, ISymbol symbol, SyntaxNode declaration);
    private static Accessibility GetPreferredAccessibility(ISymbol symbol);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.AddAccessibilityModifiers.IAddAccessibilityModifiers {
    public abstract virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, SyntaxNode member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifiersAdded);
}
internal interface Microsoft.CodeAnalysis.AddAccessibilityModifiers.IAddAccessibilityModifiersService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    protected abstract virtual bool HasName(TAnonymousObjectMemberDeclaratorSyntax declarator);
    protected abstract virtual TExpressionSyntax GetExpression(TAnonymousObjectMemberDeclaratorSyntax declarator);
    protected abstract virtual TAnonymousObjectMemberDeclaratorSyntax WithName(TAnonymousObjectMemberDeclaratorSyntax declarator, SyntaxToken name);
    protected abstract virtual IEnumerable`1<string> GetAnonymousObjectMemberNames(TAnonymousObjectInitializer initializer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<GetMemberDeclaratorAsync>d__5")]
private Task`1<TAnonymousObjectMemberDeclaratorSyntax> GetMemberDeclaratorAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddAnonymousTypeMemberName.AbstractAddAnonymousTypeMemberNameCodeFixProvider`3/<FixOneAsync>d__7")]
private Task FixOneAsync(Document document, SemanticModel semanticModel, Diagnostic diagnostic, SyntaxEditor editor, SyntaxAnnotation annotation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[IntentProviderAttribute("AddConstructorParameter", "C#")]
internal class Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider : AbstractGenerateFromMembersCodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider/<AddConstructorParametersFromMembersAsync>d__5")]
private static Task`1<Nullable`1<AddConstructorParameterResult>> AddConstructorParametersFromMembersAsync(Document document, TextSpan textSpan, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ImmutableArray`1<CodeAction> GetGroupedActions(AddConstructorParameterResult result);
    private static AddConstructorParameterResult CreateCodeActions(Document document, CodeGenerationContextInfo info, State state);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddConstructorParametersFromMembers.AddConstructorParametersFromMembersCodeRefactoringProvider/<ComputeIntentAsync>d__8")]
public sealed virtual Task`1<ImmutableArray`1<IntentProcessorResult>> ComputeIntentAsync(Document priorDocument, TextSpan priorSelection, Document currentDocument, IntentDataProvider intentDataProvider, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <CreateCodeActions>g__CanHaveRequiredParameters|7_0(ImmutableArray`1<IParameterSymbol> parameters);
    [CompilerGeneratedAttribute]
internal static AddConstructorParametersCodeAction <CreateCodeActions>g__GetOptionalContructorParametersCodeAction|7_1(Document document, CodeGenerationContextInfo info, ConstructorCandidate constructorCandidate, INamedTypeSymbol containingType, bool useSubMenuName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2 : CodeRefactoringProvider {
    private static string DebuggerDisplayPrefix;
    private static string DebuggerDisplayMethodName;
    private static string DebuggerDisplaySuffix;
    protected bool CanNameofAccessNonPublicMembersFromAttributeArgument { get; }
    protected abstract virtual bool get_CanNameofAccessNonPublicMembersFromAttributeArgument();
    protected abstract virtual bool SupportsConstantInterpolatedStrings(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2/<ComputeRefactoringsAsync>d__6")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2/<GetRelevantTypeFromHeaderAsync>d__7")]
private static Task`1<Nullable`1<ValueTuple`2<TTypeDeclarationSyntax, CodeActionPriority>>> GetRelevantTypeFromHeaderAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2/<GetRelevantTypeFromMethodAsync>d__8")]
private static Task`1<Nullable`1<ValueTuple`2<TTypeDeclarationSyntax, CodeActionPriority>>> GetRelevantTypeFromMethodAsync(CodeRefactoringContext context);
    private static bool IsToStringMethod(IMethodSymbol methodSymbol);
    private static bool IsDebuggerDisplayMethod(IMethodSymbol methodSymbol);
    private static bool IsClassOrStruct(ITypeSymbol typeSymbol);
    private static bool HasDebuggerDisplayAttribute(ITypeSymbol typeSymbol, Compilation compilation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddDebuggerDisplay.AbstractAddDebuggerDisplayCodeRefactoringProvider`2/<ApplyAsync>d__13")]
private Task`1<Document> ApplyAsync(Document document, TTypeDeclarationSyntax type, INamedTypeSymbol debuggerAttributeTypeSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerCodeRefactoringProvider : SyntaxEditorBasedCodeRefactoringProvider {
    private static string BannerFileNamePlaceholder;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<FixAllScope> <SupportedFixAllScopes>k__BackingField;
    [NullableAttribute("0")]
protected ImmutableArray`1<FixAllScope> SupportedFixAllScopes { get; }
    protected abstract virtual bool IsCommentStartCharacter(char ch);
    protected abstract virtual SyntaxTrivia CreateTrivia(SyntaxTrivia trivia, string text);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
protected sealed virtual ImmutableArray`1<FixAllScope> get_SupportedFixAllScopes();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerCodeRefactoringProvider/<ComputeRefactoringsAsync>d__6")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool HasExistingBanner(Document document, SyntaxNode root);
    private static string GetEquivalenceKey(Document document, ImmutableArray`1<SyntaxTrivia> banner);
    private static ImmutableArray`1<SyntaxTrivia> GetBannerFromEquivalenceKey(string equivalenceKey, Document document);
    private Task`1<Document> AddBannerAsync(Document document, SyntaxNode root, Document siblingDocument, ImmutableArray`1<SyntaxTrivia> banner);
    [NullableContextAttribute("0")]
private ImmutableArray`1<SyntaxTrivia> UpdateEmbeddedFileNames(Document sourceDocument, Document destinationDocument, ImmutableArray`1<SyntaxTrivia> banner);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerCodeRefactoringProvider/<TryGetBannerAsync>d__12")]
private Task`1<ImmutableArray`1<SyntaxTrivia>> TryGetBannerAsync(Document document, SyntaxNode root, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerCodeRefactoringProvider/<FixAllAsync>d__13")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<TextSpan> fixAllSpans, SyntaxEditor editor, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerNewDocumentFormattingProvider : object {
    protected SyntaxGenerator SyntaxGenerator { get; }
    protected SyntaxGeneratorInternal SyntaxGeneratorInternal { get; }
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected abstract virtual SyntaxGenerator get_SyntaxGenerator();
    protected abstract virtual SyntaxGeneratorInternal get_SyntaxGeneratorInternal();
    protected abstract virtual AbstractFileHeaderHelper get_FileHeaderHelper();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddFileBanner.AbstractAddFileBannerNewDocumentFormattingProvider/<FormatNewDocumentAsync>d__6")]
public sealed virtual Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddImport.AbstractAddImportCodeFixProvider : CodeFixProvider {
    private static int MaxResults;
    private IPackageInstallerService _packageInstallerService;
    private ISymbolSearchService _symbolSearchService;
    protected AbstractAddImportCodeFixProvider(IPackageInstallerService packageInstallerService, ISymbolSearchService symbolSearchService);
    protected virtual CodeActionRequestPriority ComputeRequestPriority();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1 : object {
    private static ConditionalWeakTable`2<PortableExecutableReference, StrongBox`1<bool>> s_isInPackagesDirectory;
    private static AbstractAddImportFeatureService`1();
    protected abstract virtual bool CanAddImport(SyntaxNode node, bool allowInHiddenRegions, CancellationToken cancellationToken);
    protected abstract virtual bool CanAddImportForMethod(string diagnosticId, ISyntaxFacts syntaxFacts, SyntaxNode node, TSimpleNameSyntax& nameNode);
    protected abstract virtual bool CanAddImportForNamespace(string diagnosticId, SyntaxNode node, TSimpleNameSyntax& nameNode);
    protected abstract virtual bool CanAddImportForDeconstruct(string diagnosticId, SyntaxNode node);
    protected abstract virtual bool CanAddImportForGetAwaiter(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected abstract virtual bool CanAddImportForGetEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected abstract virtual bool CanAddImportForGetAsyncEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected abstract virtual bool CanAddImportForQuery(string diagnosticId, SyntaxNode node);
    protected abstract virtual bool CanAddImportForType(string diagnosticId, SyntaxNode node, TSimpleNameSyntax& nameNode);
    protected abstract virtual ISet`1<INamespaceSymbol> GetImportNamespacesInScope(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual ITypeSymbol GetDeconstructInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual ITypeSymbol GetQueryClauseInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool IsViableExtensionMethod(IMethodSymbol method, SyntaxNode expression, SemanticModel semanticModel, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, INamespaceOrTypeSymbol symbol, Document document, AddImportPlacementOptions options, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, IReadOnlyList`1<string> nameSpaceParts, Document document, AddImportPlacementOptions options, CancellationToken cancellationToken);
    protected abstract virtual bool IsAddMethodContext(SyntaxNode node, SemanticModel semanticModel);
    protected abstract virtual string GetDescription(IReadOnlyList`1<string> nameParts);
    protected abstract virtual ValueTuple`2<string, bool> GetDescription(Document document, AddImportPlacementOptions options, INamespaceOrTypeSymbol symbol, SemanticModel semanticModel, SyntaxNode root, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<GetFixesAsync>d__19")]
public sealed virtual Task`1<ImmutableArray`1<AddImportFixData>> GetFixesAsync(Document document, TextSpan span, string diagnosticId, int maxResults, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<GetFixesInCurrentProcessAsync>d__20")]
private Task`1<ImmutableArray`1<AddImportFixData>> GetFixesInCurrentProcessAsync(Document document, TextSpan span, string diagnosticId, int maxResults, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsAsync>d__21")]
private Task`1<ImmutableArray`1<Reference<TSimpleNameSyntax>>> FindResultsAsync(Document document, SemanticModel semanticModel, string diagnosticId, SyntaxNode node, int maxResults, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    private static bool IsHostOrRemoteWorkspace(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsAsync>d__23")]
private Task`1<ImmutableArray`1<Reference<TSimpleNameSyntax>>> FindResultsAsync(ConcurrentDictionary`2<Project, AsyncLazy`1<IAssemblySymbol>> projectToAssembly, ConcurrentDictionary`2<PortableExecutableReference, Compilation> referenceToCompilation, Project project, int maxResults, SymbolReferenceFinder<TSimpleNameSyntax> finder, bool exact, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsInAllSymbolsInStartingProjectAsync>d__24")]
private static Task FindResultsInAllSymbolsInStartingProjectAsync(ConcurrentQueue`1<Reference<TSimpleNameSyntax>> allSymbolReferences, SymbolReferenceFinder<TSimpleNameSyntax> finder, bool exact, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsInUnreferencedProjectSourceSymbolsAsync>d__25")]
private static Task FindResultsInUnreferencedProjectSourceSymbolsAsync(ConcurrentDictionary`2<Project, AsyncLazy`1<IAssemblySymbol>> projectToAssembly, Project project, ConcurrentQueue`1<Reference<TSimpleNameSyntax>> allSymbolReferences, int maxResults, SymbolReferenceFinder<TSimpleNameSyntax> finder, bool exact, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<FindResultsInUnreferencedMetadataSymbolsAsync>d__26")]
private Task FindResultsInUnreferencedMetadataSymbolsAsync(ConcurrentDictionary`2<PortableExecutableReference, Compilation> referenceToCompilation, Project project, ConcurrentQueue`1<Reference<TSimpleNameSyntax>> allSymbolReferences, int maxResults, SymbolReferenceFinder<TSimpleNameSyntax> finder, bool exact, CancellationToken cancellationToken);
    private static ImmutableArray`1<ValueTuple`2<Project, PortableExecutableReference>> GetUnreferencedMetadataReferences(Project project, HashSet`1<PortableExecutableReference> seenReferences);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<ProcessReferencesAsync>d__28")]
private static Task ProcessReferencesAsync(ConcurrentQueue`1<Reference<TSimpleNameSyntax>> allSymbolReferences, int maxResults, IAsyncEnumerable`1<ImmutableArray`1<SymbolReference<TSimpleNameSyntax>>> reader, CancellationTokenSource linkedTokenSource);
    private static bool IsInPackagesDirectory(PortableExecutableReference reference);
    private static Compilation CreateCompilation(Project project, PortableExecutableReference reference);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.PortableExecutableReference>.Equals(PortableExecutableReference x, PortableExecutableReference y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.PortableExecutableReference>.GetHashCode(PortableExecutableReference obj);
    private static HashSet`1<Project> GetViableUnreferencedProjects(Project project);
    private static void AddRange(ConcurrentQueue`1<Reference<TSimpleNameSyntax>> allSymbolReferences, ImmutableArray`1<SymbolReference<TSimpleNameSyntax>> proposedReferences);
    protected static bool IsViableExtensionMethod(IMethodSymbol method, ITypeSymbol receiver);
    private static bool NotGlobalNamespace(SymbolReference<TSimpleNameSyntax> reference);
    private static bool NotNull(SymbolReference<TSimpleNameSyntax> reference);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<GetFixesForDiagnosticsAsync>d__38")]
public sealed virtual Task`1<ImmutableArray`1<ValueTuple`2<Diagnostic, ImmutableArray`1<AddImportFixData>>>> GetFixesForDiagnosticsAsync(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, int maxResultsPerDiagnostic, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<GetUniqueFixesAsync>d__39")]
public sealed virtual Task`1<ImmutableArray`1<AddImportFixData>> GetUniqueFixesAsync(Document document, TextSpan span, ImmutableArray`1<string> diagnosticIds, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AbstractAddImportFeatureService`1/<GetUniqueFixesAsyncInCurrentProcessAsync>d__40")]
private Task`1<ImmutableArray`1<AddImportFixData>> GetUniqueFixesAsyncInCurrentProcessAsync(Document document, TextSpan span, ImmutableArray`1<string> diagnosticIds, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<CodeAction> GetCodeActionsForFixes(Document document, ImmutableArray`1<AddImportFixData> fixes, IPackageInstallerService installerService, int maxResults);
    private static CodeAction TryCreateCodeAction(Document document, AddImportFixData fixData, IPackageInstallerService installerService);
    private static ITypeSymbol GetAwaitInfo(SemanticModel semanticModel, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    private static ITypeSymbol GetCollectionExpressionType(SemanticModel semanticModel, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected static bool AncestorOrSelfIsAwaitExpression(ISyntaxFacts syntaxFactsService, SyntaxNode node);
    private static SyntaxNode FirstAwaitExpressionAncestor(ISyntaxFacts syntaxFactsService, SyntaxNode node);
    private static SyntaxNode FirstForeachCollectionExpressionAncestor(ISyntaxFacts syntaxFactsService, SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <IsInPackagesDirectory>g__ComputeIsInPackagesDirectory|29_1(PortableExecutableReference reference);
    [CompilerGeneratedAttribute]
internal static bool <IsInPackagesDirectory>g__ContainsPathComponent|29_2(PortableExecutableReference reference, string pathComponent);
}
internal abstract class Microsoft.CodeAnalysis.AddImport.AddImportCodeAction : CodeAction {
    protected AddImportFixData FixData;
    private CodeActionPriority _priority;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Tags>k__BackingField;
    protected Document OriginalDocument;
    private ImmutableArray`1<TextChange> _textChanges;
    public string Title { get; }
    public ImmutableArray`1<string> Tags { get; }
    public string EquivalenceKey { get; }
    protected AddImportCodeAction(Document originalDocument, AddImportFixData fixData, ImmutableArray`1<string> additionalTags);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_Tags();
    public sealed virtual string get_EquivalenceKey();
    protected sealed virtual CodeActionPriority ComputePriority();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AddImportCodeAction/<GetUpdatedDocumentAsync>d__14")]
protected Task`1<Document> GetUpdatedDocumentAsync(CancellationToken cancellationToken);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.AddImport.AddImportFixData : object {
    [CompilerGeneratedAttribute]
private AddImportFixKind <Kind>k__BackingField;
    [DataMemberAttribute]
public ImmutableArray`1<TextChange> TextChanges;
    [DataMemberAttribute]
public string Title;
    [DataMemberAttribute]
public ImmutableArray`1<string> Tags;
    [DataMemberAttribute]
public CodeActionPriority Priority;
    [DataMemberAttribute]
public ProjectId ProjectReferenceToAdd;
    [DataMemberAttribute]
public ProjectId PortableExecutableReferenceProjectId;
    [DataMemberAttribute]
public string PortableExecutableReferenceFilePathToAdd;
    [DataMemberAttribute]
public string AssemblyReferenceAssemblyName;
    [DataMemberAttribute]
public string AssemblyReferenceFullyQualifiedTypeName;
    [DataMemberAttribute]
public string PackageSource;
    [DataMemberAttribute]
public string PackageName;
    [DataMemberAttribute]
public string PackageVersionOpt;
    [DataMemberAttribute]
public AddImportFixKind Kind { get; }
    public AddImportFixData(AddImportFixKind kind, ImmutableArray`1<TextChange> textChanges, string title, ImmutableArray`1<string> tags, CodeActionPriority priority, ProjectId projectReferenceToAdd, ProjectId portableExecutableReferenceProjectId, string portableExecutableReferenceFilePathToAdd, string assemblyReferenceAssemblyName, string assemblyReferenceFullyQualifiedTypeName, string packageSource, string packageName, string packageVersionOpt);
    [CompilerGeneratedAttribute]
public AddImportFixKind get_Kind();
    public static AddImportFixData CreateForProjectSymbol(ImmutableArray`1<TextChange> textChanges, string title, ImmutableArray`1<string> tags, CodeActionPriority priority, ProjectId projectReferenceToAdd);
    public static AddImportFixData CreateForMetadataSymbol(ImmutableArray`1<TextChange> textChanges, string title, ImmutableArray`1<string> tags, CodeActionPriority priority, ProjectId portableExecutableReferenceProjectId, string portableExecutableReferenceFilePathToAdd);
    public static AddImportFixData CreateForReferenceAssemblySymbol(ImmutableArray`1<TextChange> textChanges, string title, string assemblyReferenceAssemblyName, string assemblyReferenceFullyQualifiedTypeName);
    public static AddImportFixData CreateForPackageSymbol(ImmutableArray`1<TextChange> textChanges, string packageSource, string packageName, string packageVersionOpt);
}
internal enum Microsoft.CodeAnalysis.AddImport.AddImportFixKind : Enum {
    public int value__;
    public static AddImportFixKind ProjectSymbol;
    public static AddImportFixKind MetadataSymbol;
    public static AddImportFixKind PackageSymbol;
    public static AddImportFixKind ReferenceAssemblySymbol;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.AddImport.AddImportOptions : ValueType {
    [CompilerGeneratedAttribute]
private SymbolSearchOptions <SearchOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCleanupOptions <CleanupOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideAdvancedMembers>k__BackingField;
    [DataMemberAttribute]
public SymbolSearchOptions SearchOptions { get; public set; }
    [DataMemberAttribute]
public CodeCleanupOptions CleanupOptions { get; public set; }
    [DataMemberAttribute]
public bool HideAdvancedMembers { get; public set; }
    public AddImportOptions(SymbolSearchOptions SearchOptions, CodeCleanupOptions CleanupOptions, bool HideAdvancedMembers);
    [CompilerGeneratedAttribute]
public SymbolSearchOptions get_SearchOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SearchOptions(SymbolSearchOptions value);
    [CompilerGeneratedAttribute]
public CodeCleanupOptions get_CleanupOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CleanupOptions(CodeCleanupOptions value);
    [CompilerGeneratedAttribute]
public bool get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HideAdvancedMembers(bool value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AddImportOptions left, AddImportOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AddImportOptions left, AddImportOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AddImportOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(SymbolSearchOptions& SearchOptions, CodeCleanupOptions& CleanupOptions, Boolean& HideAdvancedMembers);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService {
    public abstract virtual Task`1<ImmutableArray`1<AddImportFixData>> GetFixesAsync(Document document, TextSpan span, string diagnosticId, int maxResults, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<Diagnostic, ImmutableArray`1<AddImportFixData>>>> GetFixesForDiagnosticsAsync(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, int maxResultsPerDiagnostic, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<CodeAction> GetCodeActionsForFixes(Document document, ImmutableArray`1<AddImportFixData> fixes, IPackageInstallerService installerService, int maxResults);
    public abstract virtual Task`1<ImmutableArray`1<AddImportFixData>> GetUniqueFixesAsync(Document document, TextSpan span, ImmutableArray`1<string> diagnosticIds, ISymbolSearchService symbolSearchService, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AddImport.InstallPackageAndAddImportCodeAction : AddImportCodeAction {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    private InstallPackageDirectlyCodeActionOperation _installOperation;
    public string Title { get; }
    public InstallPackageAndAddImportCodeAction(Document originalDocument, AddImportFixData fixData, string title, InstallPackageDirectlyCodeActionOperation installOperation);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.InstallPackageAndAddImportCodeAction/<ComputePreviewOperationsAsync>d__5")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.InstallPackageAndAddImportCodeAction/<GetUpdatedSolutionAsync>d__6")]
private Task`1<Solution> GetUpdatedSolutionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.InstallPackageAndAddImportCodeAction/<ComputeOperationsAsync>d__7")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.AddImport.IRemoteMissingImportDiscoveryService {
    public abstract virtual ValueTask`1<ImmutableArray`1<AddImportFixData>> GetFixesAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, DocumentId documentId, TextSpan span, string diagnosticId, int maxResults, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<AddImportFixData>> GetUniqueFixesAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, DocumentId id, TextSpan span, ImmutableArray`1<string> diagnosticIds, AddImportOptions options, ImmutableArray`1<PackageSource> packageSources, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddImport.PackageSourceHelper : object {
    private static string NugetOrg;
    public static string NugetOrgSourceName;
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.PackageSourceHelper/<GetPackageSources>d__2")]
public static IEnumerable`1<ValueTuple`2<string, string>> GetPackageSources(ImmutableArray`1<PackageSource> packageSources);
    private static bool IsNugetOrg(string sourceUrl);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.AddImport.IRemoteMissingImportDiscoveryService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.AddImport.RemoteMissingImportDiscoveryServiceCallbackDispatcher : RemoteServiceCallbackDispatcher {
    private ISymbolSearchService GetService(RemoteServiceCallbackId callbackId);
    public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(RemoteServiceCallbackId callbackId, string source, string name, int arity, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(RemoteServiceCallbackId callbackId, string source, string name, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(RemoteServiceCallbackId callbackId, string name, int arity, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual ImmutableArray`1<AbstractFormattingRule> GetFormatRules(SourceText text);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<AddMissingImportsAsync>d__3")]
public sealed virtual Task`1<Document> AddMissingImportsAsync(Document document, TextSpan textSpan, AddMissingImportsOptions options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<AddMissingImportsAsync>d__4")]
public sealed virtual Task`1<Document> AddMissingImportsAsync(Document document, AddMissingImportsAnalysisResult analysisResult, SyntaxFormattingOptions formattingOptions, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<AnalyzeAsync>d__5")]
public sealed virtual Task`1<AddMissingImportsAnalysisResult> AnalyzeAsync(Document document, TextSpan textSpan, AddMissingImportsOptions options, CancellationToken cancellationToken);
    private static bool DoesNotAddReference(AddImportFixData fixData, ProjectId currentProjectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<ApplyFixesAsync>d__7")]
private Task`1<Document> ApplyFixesAsync(Document document, ImmutableArray`1<AddImportFixData> fixes, SyntaxFormattingOptions formattingOptions, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<CleanUpNewLinesAsync>d__8")]
private Task`1<Document> CleanUpNewLinesAsync(Document document, IEnumerable`1<TextSpan> insertSpans, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<CleanUpNewLinesAsync>d__9")]
private Task`1<Document> CleanUpNewLinesAsync(Document document, TextSpan insertSpan, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsFeatureService/<GetChangesForCodeActionAsync>d__10")]
private static Task`1<ValueTuple`2<ProjectChanges, IEnumerable`1<TextChange>>> GetChangesForCodeActionAsync(Document document, CodeAction codeAction, IDocumentTextDifferencingService textDiffingService, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsRefactoringProvider : CodeRefactoringProvider {
    protected string CodeActionTitle { get; }
    protected abstract virtual string get_CodeActionTitle();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingImports.AbstractAddMissingImportsRefactoringProvider/<AddMissingImportsAsync>d__3")]
private static Task`1<Solution> AddMissingImportsAsync(Document document, IAddMissingImportsFeatureService addMissingImportsService, AddMissingImportsAnalysisResult analysis, SyntaxFormattingOptions formattingOptions, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AddMissingImports.AddMissingImportsAnalysisResult : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AddImportFixData> <AddImportFixData>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<AddImportFixData> AddImportFixData { get; }
    public bool CanAddMissingImports { get; }
    public AddMissingImportsAnalysisResult(ImmutableArray`1<AddImportFixData> addImportFixData);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AddImportFixData> get_AddImportFixData();
    public bool get_CanAddMissingImports();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.AddMissingImports.AddMissingImportsOptions : ValueType {
    [CompilerGeneratedAttribute]
private CodeCleanupOptions <CleanupOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideAdvancedMembers>k__BackingField;
    [DataMemberAttribute]
public CodeCleanupOptions CleanupOptions { get; public set; }
    [DataMemberAttribute]
public bool HideAdvancedMembers { get; public set; }
    public AddMissingImportsOptions(CodeCleanupOptions CleanupOptions, bool HideAdvancedMembers);
    [CompilerGeneratedAttribute]
public CodeCleanupOptions get_CleanupOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CleanupOptions(CodeCleanupOptions value);
    [CompilerGeneratedAttribute]
public bool get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HideAdvancedMembers(bool value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AddMissingImportsOptions left, AddMissingImportsOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AddMissingImportsOptions left, AddMissingImportsOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AddMissingImportsOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(CodeCleanupOptions& CleanupOptions, Boolean& HideAdvancedMembers);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService {
    public abstract virtual Task`1<Document> AddMissingImportsAsync(Document document, TextSpan textSpan, AddMissingImportsOptions options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    public abstract virtual Task`1<AddMissingImportsAnalysisResult> AnalyzeAsync(Document document, TextSpan textSpan, AddMissingImportsOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMissingImportsAsync(Document document, AddMissingImportsAnalysisResult analysisResult, SyntaxFormattingOptions formattingOptions, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider : AbstractAddPackageCodeFixProvider {
    protected bool IncludePrerelease { get; }
    [NullableContextAttribute("2")]
protected AbstractAddMissingReferenceCodeFixProvider(IPackageInstallerService packageInstallerService, ISymbolSearchService symbolSearchService);
    protected virtual bool get_IncludePrerelease();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider/<GetAddReferencesCodeActionsAsync>d__5")]
private static Task`1<ImmutableArray`1<CodeAction>> GetAddReferencesCodeActionsAsync(CodeFixContext context, ISet`1<AssemblyIdentity> uniqueIdentities);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingReference.AbstractAddMissingReferenceCodeFixProvider/<GetUniqueIdentitiesAsync>d__6")]
private static Task`1<ISet`1<AssemblyIdentity>> GetUniqueIdentitiesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.AddMissingReference.AddMissingReferenceCodeAction : CodeAction {
    private Project _project;
    [NullableAttribute("2")]
private ProjectReference _projectReferenceToAdd;
    private AssemblyIdentity _missingAssemblyIdentity;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    public AddMissingReferenceCodeAction(Project project, string title, ProjectReference projectReferenceToAdd, AssemblyIdentity missingAssemblyIdentity);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    public virtual ImmutableArray`1<string> get_Tags();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddMissingReference.AddMissingReferenceCodeAction/<CreateAsync>d__9")]
public static Task`1<CodeAction> CreateAsync(Project project, AssemblyIdentity missingAssemblyIdentity, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<CodeActionOperation>> ComputeOperationsAsync(IProgress`1<CodeAnalysisProgress> progress, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private ISyntaxFacts _syntaxFacts;
    private string _title;
    protected AbstractAddObsoleteAttributeCodeFixProvider(ISyntaxFacts syntaxFacts, string title);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<GetObsoleteAttributeAsync>d__4")]
private static Task`1<INamedTypeSymbol> GetObsoleteAttributeAsync(Document document, CancellationToken cancellationToken);
    private SyntaxNode GetContainer(SyntaxNode root, SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddObsoleteAttribute.AbstractAddObsoleteAttributeCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.AddPackage.AbstractAddPackageCodeFixProvider : CodeFixProvider {
    private IPackageInstallerService _packageInstallerService;
    private ISymbolSearchService _symbolSearchService;
    protected bool IncludePrerelease { get; }
    protected AbstractAddPackageCodeFixProvider(IPackageInstallerService packageInstallerService, ISymbolSearchService symbolSearchService);
    protected abstract virtual bool get_IncludePrerelease();
    public abstract virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddPackage.AbstractAddPackageCodeFixProvider/<GetAddPackagesCodeActionsAsync>d__6")]
protected Task`1<ImmutableArray`1<CodeAction>> GetAddPackagesCodeActionsAsync(CodeFixContext context, ISet`1<string> assemblyNames);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddPackage.AbstractAddPackageCodeFixProvider/<FindMatchingPackagesAsync>d__7")]
private static Task`1<ImmutableArray`1<PackageWithAssemblyResult>> FindMatchingPackagesAsync(string sourceName, ISymbolSearchService searchService, ISet`1<string> assemblyNames, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.AddPackage.AbstractAddSpecificPackageCodeFixProvider : AbstractAddPackageCodeFixProvider {
    protected bool IncludePrerelease { get; }
    protected AbstractAddSpecificPackageCodeFixProvider(IPackageInstallerService packageInstallerService, ISymbolSearchService symbolSearchService);
    protected virtual bool get_IncludePrerelease();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddPackage.AbstractAddSpecificPackageCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual string GetAssemblyName(string id);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.AddPackage.InstallPackageData : ValueType {
    public string PackageSource;
    [NullableAttribute("1")]
public string PackageName;
    public string PackageVersionOpt;
    [NullableAttribute("0")]
public ImmutableArray`1<TextChange> TextChanges;
    public InstallPackageData(string packageSource, string packageName, string packageVersionOpt, ImmutableArray`1<TextChange> textChanges);
}
internal class Microsoft.CodeAnalysis.AddPackage.InstallPackageDirectlyCodeAction : CodeAction {
    private CodeActionOperation _installPackageOperation;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public InstallPackageDirectlyCodeAction(IPackageInstallerService installerService, Document document, string source, string packageName, string versionOpt, bool includePrerelease, bool isLocal);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    protected virtual Task`1<ImmutableArray`1<CodeActionOperation>> ComputeOperationsAsync(IProgress`1<CodeAnalysisProgress> progress, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.AddPackage.InstallPackageDirectlyCodeActionOperation : CodeActionOperation {
    private Document _document;
    private IPackageInstallerService _installerService;
    [NullableAttribute("2")]
private string _source;
    private string _packageName;
    [NullableAttribute("2")]
private string _versionOpt;
    private bool _includePrerelease;
    private bool _isLocal;
    private List`1<string> _projectsWithMatchingVersion;
    public string Title { get; }
    internal bool ApplyDuringTests { get; }
    public InstallPackageDirectlyCodeActionOperation(IPackageInstallerService installerService, Document document, string source, string packageName, string versionOpt, bool includePrerelease, bool isLocal);
    public virtual string get_Title();
    internal virtual bool get_ApplyDuringTests();
    internal virtual Task`1<bool> TryApplyAsync(Workspace workspace, Solution originalSolution, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AddPackage.InstallPackageParentCodeAction : CodeActionWithNestedActions {
    public ImmutableArray`1<string> Tags { get; }
    public InstallPackageParentCodeAction(IPackageInstallerService installerService, string source, string packageName, bool includePrerelease, Document document);
    public virtual ImmutableArray`1<string> get_Tags();
    private static ImmutableArray`1<CodeAction> CreateNestedActions(IPackageInstallerService installerService, string source, string packageName, bool includePrerelease, Document document);
    private static CodeAction CreateCodeAction(IPackageInstallerService installerService, string source, string packageName, Document document, string versionOpt, bool includePrerelease, bool isLocal);
}
internal class Microsoft.CodeAnalysis.AddPackage.InstallWithPackageManagerCodeAction : CodeAction {
    private IPackageInstallerService _installerService;
    private string _packageName;
    public string Title { get; }
    public InstallWithPackageManagerCodeAction(IPackageInstallerService installerService, string packageName);
    public virtual string get_Title();
    protected virtual Task`1<ImmutableArray`1<CodeActionOperation>> ComputeOperationsAsync(IProgress`1<CodeAnalysisProgress> progress, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.AddPackage.ParentInstallPackageCodeAction : CodeActionWithNestedActions {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    public ParentInstallPackageCodeAction(Document document, InstallPackageData fixData, IPackageInstallerService installerService);
    public virtual ImmutableArray`1<string> get_Tags();
    [NullableContextAttribute("2")]
public static CodeAction TryCreateCodeAction(Document document, InstallPackageData fixData, IPackageInstallerService installerService);
    private static ImmutableArray`1<CodeAction> CreateNestedActions(Document document, InstallPackageData fixData, IPackageInstallerService installerService);
    private static CodeAction CreateCodeAction(Document document, InstallPackageData installData, IPackageInstallerService installerService, string version, bool isLocal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6 : CodeFixProvider {
    private static SymbolDisplayFormat SimpleFormat;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> TooManyArgumentsDiagnosticIds { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> CannotConvertDiagnosticIds { get; }
    private static AbstractAddParameterCodeFixProvider`6();
    protected abstract virtual ImmutableArray`1<string> get_TooManyArgumentsDiagnosticIds();
    protected abstract virtual ImmutableArray`1<string> get_CannotConvertDiagnosticIds();
    protected abstract virtual ITypeSymbol GetArgumentType(SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    protected virtual RegisterFixData`1<TArgumentSyntax> TryGetLanguageSpecificFixInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private TArgumentSyntax TryGetRelevantArgument(SyntaxNode initialNode, SyntaxNode node, Diagnostic diagnostic);
    private static RegisterFixData`1<TArgumentSyntax> TryGetInvocationExpressionFixInfo(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    private static RegisterFixData`1<TArgumentSyntax> TryGetObjectCreationFixInfo(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    private static ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> GetArgumentInsertPositionForMethodCandidates(TArgumentSyntax argumentOpt, SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<IMethodSymbol> methodCandidates);
    private static int NonParamsParameterCount(IMethodSymbol method);
    private void RegisterFixForMethodOverloads(CodeFixContext context, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> methodsAndArgumentsToAdd);
    [NullableContextAttribute("0")]
private ImmutableArray`1<CodeFixData> PrepareCreationOfCodeActions(Document document, SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<ArgumentInsertPositionData`1<TArgumentSyntax>> methodsAndArgumentsToAdd);
    private static string GetCodeFixTitle(string resourceString, IMethodSymbol methodToUpdate, bool includeParameters);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<FixAsync>d__16")]
private Task`1<Solution> FixAsync(Document invocationDocument, IMethodSymbol method, TArgumentSyntax argument, SeparatedSyntaxList`1<TArgumentSyntax> argumentList, bool fixAllReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<GetArgumentTypeAndRefKindAsync>d__17")]
private Task`1<ValueTuple`2<ITypeSymbol, RefKind>> GetArgumentTypeAndRefKindAsync(Document invocationDocument, TArgumentSyntax argument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AbstractAddParameterCodeFixProvider`6/<GetNameSuggestionForArgumentAsync>d__18")]
private static Task`1<ValueTuple`2<string, bool>> GetNameSuggestionForArgumentAsync(Document invocationDocument, TArgumentSyntax argument, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    private static TArgumentSyntax DetermineFirstArgumentToAdd(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, StringComparer comparer, IMethodSymbol method, SeparatedSyntaxList`1<TArgumentSyntax> arguments);
    private static bool TypeInfoMatchesWithParamsExpansion(Compilation compilation, TypeInfo argumentTypeInfo, IParameterSymbol parameter, bool isNullLiteral, bool isDefaultLiteral);
    private static bool TypeInfoMatchesType(Compilation compilation, TypeInfo argumentTypeInfo, ITypeSymbol parameterType, bool isNullLiteral, bool isDefaultLiteral);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<CodeAction> <RegisterFixForMethodOverloads>g__NestByOverload|13_0(<>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<CodeAction> <RegisterFixForMethodOverloads>g__NestByCascading|13_1(<>c__DisplayClass13_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddParameter.AddParameterService : object {
    public static bool HasCascadingDeclarations(IMethodSymbol method);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AddParameterService/<AddParameterAsync>d__1")]
public static Task`1<Solution> AddParameterAsync(Document invocationDocument, IMethodSymbol method, ITypeSymbol newParameterType, RefKind refKind, string parameterName, Nullable`1<int> newParameterIndex, bool fixAllReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddParameter.AddParameterService/<FindMethodDeclarationReferencesAsync>d__2")]
private static Task`1<ImmutableArray`1<IMethodSymbol>> FindMethodDeclarationReferencesAsync(Document invocationDocument, IMethodSymbol method, CancellationToken cancellationToken);
    private static IParameterSymbol CreateParameterSymbol(IMethodSymbol method, ITypeSymbol parameterType, RefKind refKind, bool isOptional, string argumentNameSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.AddParameter.ArgumentInsertPositionData`1 : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <MethodToUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private TArgumentSyntax <ArgumentToInsert>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentInsertionIndex>k__BackingField;
    public IMethodSymbol MethodToUpdate { get; }
    public TArgumentSyntax ArgumentToInsert { get; }
    public int ArgumentInsertionIndex { get; }
    public ArgumentInsertPositionData`1(IMethodSymbol methodToUpdate, TArgumentSyntax argumentToInsert, int argumentInsertionIndex);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MethodToUpdate();
    [CompilerGeneratedAttribute]
public TArgumentSyntax get_ArgumentToInsert();
    [CompilerGeneratedAttribute]
public int get_ArgumentInsertionIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.AddParameter.CodeFixData : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<Solution>> <CreateChangedSolutionNonCascading>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<Solution>> <CreateChangedSolutionCascading>k__BackingField;
    public IMethodSymbol Method { get; }
    public Func`2<CancellationToken, Task`1<Solution>> CreateChangedSolutionNonCascading { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<CancellationToken, Task`1<Solution>> CreateChangedSolutionCascading { get; }
    public CodeFixData(IMethodSymbol method, Func`2<CancellationToken, Task`1<Solution>> createChangedSolutionNonCascading, Func`2<CancellationToken, Task`1<Solution>> createChangedSolutionCascading);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_Method();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task`1<Solution>> get_CreateChangedSolutionNonCascading();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task`1<Solution>> get_CreateChangedSolutionCascading();
}
internal class Microsoft.CodeAnalysis.AddParameter.RegisterFixData`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SeparatedSyntaxList`1<TArgumentSyntax> <Arguments>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <MethodCandidates>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructorInitializer>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SeparatedSyntaxList`1<TArgumentSyntax> Arguments { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IMethodSymbol> MethodCandidates { get; }
    public bool IsConstructorInitializer { get; }
    public RegisterFixData`1(SeparatedSyntaxList`1<TArgumentSyntax> arguments, ImmutableArray`1<IMethodSymbol> methodCandidates, bool isConstructorInitializer);
    [CompilerGeneratedAttribute]
public SeparatedSyntaxList`1<TArgumentSyntax> get_Arguments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_MethodCandidates();
    [CompilerGeneratedAttribute]
public bool get_IsConstructorInitializer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddRequiredParentheses.AbstractAddRequiredParenthesesDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<ValueTuple`2<bool, string>, ImmutableDictionary`2<string, string>> s_cachedProperties;
    private IPrecedenceService _precedenceService;
    private static AbstractAddRequiredParenthesesDiagnosticAnalyzer`3();
    protected AbstractAddRequiredParenthesesDiagnosticAnalyzer`3(IPrecedenceService precedenceService);
    protected static string GetEquivalenceKey(PrecedenceKind precedenceKind);
    protected static ImmutableArray`1<string> GetAllEquivalenceKeys();
    private static ImmutableDictionary`2<string, string> GetProperties(bool includeInFixAll, string equivalenceKey);
    protected abstract virtual int GetPrecedence(TBinaryLikeExpressionSyntax binaryLike);
    protected abstract virtual TExpressionSyntax TryGetAppropriateParent(TBinaryLikeExpressionSyntax binaryLike);
    protected abstract virtual bool IsBinaryLike(TExpressionSyntax node);
    protected abstract virtual ValueTuple`3<TExpressionSyntax, SyntaxToken, TExpressionSyntax> GetPartsOfBinaryLike(TBinaryLikeExpressionSyntax binaryLike);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TLanguageKindEnum> GetSyntaxNodeKinds();
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private void AddDiagnostics(SyntaxNodeAnalysisContext context, TBinaryLikeExpressionSyntax binaryLikeOpt, int precedence, NotificationOption2 notificationOption, ImmutableArray`1<Location> additionalLocations, string equivalenceKey, bool includeInFixAll);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.AddRequiredParentheses.AddRequiredParenthesesCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddRequiredParentheses.AddRequiredParenthesesConstants : object {
    public static string EquivalenceKey;
    public static string IncludeInFixAll;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AliasAmbiguousType.AbstractAliasAmbiguousTypeCodeFixProvider : CodeFixProvider {
    protected abstract virtual string GetTextPreviewOfChange(string aliasName, ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AliasAmbiguousType.AbstractAliasAmbiguousTypeCodeFixProvider/<RegisterCodeFixesAsync>d__2")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static IEnumerable`1<ITypeSymbol> Sort(IEnumerable`1<ITypeSymbol> types, bool sortSystemFirst);
    private static bool SymbolCandidatesContainsSupportedSymbols(SymbolInfo symbolInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Analyzers.MatchFolderAndNamespace.AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableResourceString s_localizableTitle;
    private static LocalizableResourceString s_localizableInsideMessage;
    private static SymbolDisplayFormat s_namespaceDisplayFormat;
    private static AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TSyntaxKind> GetSyntaxKindsToAnalyze();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    private void AnalyzeNamespaceNode(SyntaxNodeAnalysisContext context);
    private bool IsFixSupported(SemanticModel semanticModel, TNamespaceSyntax namespaceDeclaration, CancellationToken cancellationToken);
    private bool IsFileAndNamespaceMismatch(TNamespaceSyntax namespaceDeclaration, string rootNamespace, string projectDir, string currentNamespace, String& targetNamespace);
    protected bool ContainsPartialTypeWithMultipleDeclarations(TNamespaceSyntax namespaceDeclaration, SemanticModel semanticModel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Analyzers.MatchFolderAndNamespace.MatchFolderAndNamespaceConstants : object {
    public static string RootNamespaceOption;
    public static string ProjectDirOption;
    public static string TargetNamespace;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Analyzers.UseCoalesceExpression.AbstractUseCoalesceExpressionForIfNullStatementCheckDiagnosticAnalyzer`5 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("0")]
protected TSyntaxKind IfStatementKind { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    [NullableContextAttribute("0")]
protected abstract virtual TSyntaxKind get_IfStatementKind();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual bool IsSingle(TVariableDeclarator declarator);
    protected abstract virtual bool IsNullCheck(TExpressionSyntax condition, TExpressionSyntax& checkedExpression);
    protected abstract virtual bool HasElseBlock(TIfStatementSyntax ifStatement);
    protected abstract virtual SyntaxNode GetDeclarationNode(TVariableDeclarator declarator);
    protected abstract virtual TExpressionSyntax GetConditionOfIfStatement(TIfStatementSyntax ifStatement);
    protected abstract virtual bool TryGetEmbeddedStatement(TIfStatementSyntax ifStatement, TStatementSyntax& whenTrueStatement);
    protected abstract virtual TStatementSyntax TryGetPreviousStatement(TIfStatementSyntax ifStatement);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeSyntax>g__AnalyzeLocalDeclarationForm|14_0(TStatementSyntax localDeclarationStatement, TExpressionSyntax& expressionToCoalesce, <>c__DisplayClass14_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeSyntax>g__IsLegalWhenTrueStatementForAssignment|14_2(SyntaxNode& whenPartToAnalyze, <>c__DisplayClass14_0& , <>c__DisplayClass14_1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeSyntax>g__AnalyzeAssignmentForm|14_1(TStatementSyntax assignmentStatement, TExpressionSyntax& expressionToCoalesce, <>c__DisplayClass14_0& );
}
internal static class Microsoft.CodeAnalysis.AnalyzersResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Remove_Unnecessary_Cast { get; }
    internal static string Remove_unused_member { get; }
    internal static string Private_member_0_is_unused { get; }
    internal static string Remove_unused_private_members { get; }
    internal static string Remove_unread_private_members { get; }
    internal static string Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read { get; }
    internal static string Private_method_0_can_be_removed_as_it_is_never_invoked { get; }
    internal static string Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked { get; }
    internal static string A_source_file_is_missing_a_required_header { get; }
    internal static string The_file_header_is_missing_or_not_located_at_the_top_of_the_file { get; }
    internal static string A_source_file_contains_a_header_that_does_not_match_the_required_text { get; }
    internal static string The_file_header_does_not_match_the_required_text { get; }
    internal static string Use_throw_expression { get; }
    internal static string Add_this_or_Me_qualification { get; }
    internal static string Member_access_should_be_qualified { get; }
    internal static string Null_check_can_be_simplified { get; }
    internal static string Simplify_collection_initialization { get; }
    internal static string Collection_initialization_can_be_simplified { get; }
    internal static string Simplify_object_initialization { get; }
    internal static string Object_initialization_can_be_simplified { get; }
    internal static string Add_readonly_modifier { get; }
    internal static string Make_field_readonly { get; }
    internal static string Naming_rule_violation_0 { get; }
    internal static string Naming_Styles { get; }
    internal static string Add_missing_cases { get; }
    internal static string Populate_switch { get; }
    internal static string Modifiers_are_not_ordered { get; }
    internal static string Order_modifiers { get; }
    internal static string Expression_value_is_never_used { get; }
    internal static string Unnecessary_assignment_of_a_value_to_0 { get; }
    internal static string Unnecessary_assignment_of_a_value { get; }
    internal static string Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc { get; }
    internal static string Remove_unused_parameter { get; }
    internal static string Remove_unused_parameter_0 { get; }
    internal static string Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names { get; }
    internal static string Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API { get; }
    internal static string Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used { get; }
    internal static string Parameter_0_can_be_removed_its_initial_value_is_never_used { get; }
    internal static string Add_accessibility_modifiers { get; }
    internal static string Accessibility_modifiers_required { get; }
    internal static string Convert_to_conditional_expression { get; }
    internal static string Use_coalesce_expression { get; }
    internal static string Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime { get; }
    internal static string Parentheses_can_be_removed { get; }
    internal static string Remove_unnecessary_parentheses { get; }
    internal static string Add_parentheses_for_clarity { get; }
    internal static string Parentheses_should_be_added_for_clarity { get; }
    internal static string Prefer_explicitly_provided_tuple_element_name { get; }
    internal static string Use_explicitly_provided_tuple_name { get; }
    internal static string Use_System_HashCode { get; }
    internal static string GetHashCode_implementation_can_be_simplified { get; }
    internal static string Use_compound_assignment { get; }
    internal static string Use_null_propagation { get; }
    internal static string Use_inferred_member_name { get; }
    internal static string Member_name_can_be_simplified { get; }
    internal static string Interpolation_can_be_simplified { get; }
    internal static string Simplify_interpolation { get; }
    internal static string Use_auto_property { get; }
    internal static string Format_string_contains_invalid_placeholder { get; }
    internal static string Invalid_format_string { get; }
    internal static string Simplify_conditional_expression { get; }
    internal static string Conditional_expression_can_be_simplified { get; }
    internal static string Invalid_global_SuppressMessageAttribute { get; }
    internal static string Invalid_scope_for_SuppressMessageAttribute { get; }
    internal static string Invalid_or_missing_target_for_SuppressMessageAttribute { get; }
    internal static string Avoid_legacy_format_target_in_SuppressMessageAttribute { get; }
    internal static string Avoid_legacy_format_target_0_in_SuppressMessageAttribute { get; }
    internal static string Remove_unnecessary_suppression { get; }
    internal static string Remove_redundant_equality { get; }
    internal static string Use_decrement_operator { get; }
    internal static string Use_increment_operator { get; }
    internal static string Avoid_multiple_blank_lines { get; }
    internal static string Blank_line_required_between_block_and_subsequent_statement { get; }
    internal static string Change_namespace_to_match_folder_structure { get; }
    internal static string Namespace_0_does_not_match_folder_structure_expected_1 { get; }
    internal static string Namespace_does_not_match_folder_structure { get; }
    internal static string Simplify_LINQ_expression { get; }
    internal static string Set_MSBuild_Property_GenerateDocumentationFile_to_true { get; }
    internal static string Set_MSBuild_Property_GenerateDocumentationFile_to_true_in_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build { get; }
    internal static string Add_the_following_PropertyGroup_to_your_MSBuild_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build { get; }
    internal static string Fix_formatting { get; }
    internal static string _0_statement_implicitly_converts_1_to_2_Add_an_explicit_cast_to_make_intent_clearer_as_it_may_fail_at_runtime { get; }
    internal static string Add_explicit_cast { get; }
    internal static string Name_can_be_simplified { get; }
    internal static string Simplify_Names { get; }
    internal static string Simplify_Member_Access { get; }
    internal static string Remove_accessibility_modifiers { get; }
    internal static string Simplify_check { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Remove_Unnecessary_Cast();
    internal static string get_Remove_unused_member();
    internal static string get_Private_member_0_is_unused();
    internal static string get_Remove_unused_private_members();
    internal static string get_Remove_unread_private_members();
    internal static string get_Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read();
    internal static string get_Private_method_0_can_be_removed_as_it_is_never_invoked();
    internal static string get_Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked();
    internal static string get_A_source_file_is_missing_a_required_header();
    internal static string get_The_file_header_is_missing_or_not_located_at_the_top_of_the_file();
    internal static string get_A_source_file_contains_a_header_that_does_not_match_the_required_text();
    internal static string get_The_file_header_does_not_match_the_required_text();
    internal static string get_Use_throw_expression();
    internal static string get_Add_this_or_Me_qualification();
    internal static string get_Member_access_should_be_qualified();
    internal static string get_Null_check_can_be_simplified();
    internal static string get_Simplify_collection_initialization();
    internal static string get_Collection_initialization_can_be_simplified();
    internal static string get_Simplify_object_initialization();
    internal static string get_Object_initialization_can_be_simplified();
    internal static string get_Add_readonly_modifier();
    internal static string get_Make_field_readonly();
    internal static string get_Naming_rule_violation_0();
    internal static string get_Naming_Styles();
    internal static string get_Add_missing_cases();
    internal static string get_Populate_switch();
    internal static string get_Modifiers_are_not_ordered();
    internal static string get_Order_modifiers();
    internal static string get_Expression_value_is_never_used();
    internal static string get_Unnecessary_assignment_of_a_value_to_0();
    internal static string get_Unnecessary_assignment_of_a_value();
    internal static string get_Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc();
    internal static string get_Remove_unused_parameter();
    internal static string get_Remove_unused_parameter_0();
    internal static string get_Avoid_unused_parameters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names();
    internal static string get_Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API();
    internal static string get_Parameter_0_can_be_removed_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used();
    internal static string get_Parameter_0_can_be_removed_its_initial_value_is_never_used();
    internal static string get_Add_accessibility_modifiers();
    internal static string get_Accessibility_modifiers_required();
    internal static string get_Convert_to_conditional_expression();
    internal static string get_Use_coalesce_expression();
    internal static string get_Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime();
    internal static string get_Parentheses_can_be_removed();
    internal static string get_Remove_unnecessary_parentheses();
    internal static string get_Add_parentheses_for_clarity();
    internal static string get_Parentheses_should_be_added_for_clarity();
    internal static string get_Prefer_explicitly_provided_tuple_element_name();
    internal static string get_Use_explicitly_provided_tuple_name();
    internal static string get_Use_System_HashCode();
    internal static string get_GetHashCode_implementation_can_be_simplified();
    internal static string get_Use_compound_assignment();
    internal static string get_Use_null_propagation();
    internal static string get_Use_inferred_member_name();
    internal static string get_Member_name_can_be_simplified();
    internal static string get_Interpolation_can_be_simplified();
    internal static string get_Simplify_interpolation();
    internal static string get_Use_auto_property();
    internal static string get_Format_string_contains_invalid_placeholder();
    internal static string get_Invalid_format_string();
    internal static string get_Simplify_conditional_expression();
    internal static string get_Conditional_expression_can_be_simplified();
    internal static string get_Invalid_global_SuppressMessageAttribute();
    internal static string get_Invalid_scope_for_SuppressMessageAttribute();
    internal static string get_Invalid_or_missing_target_for_SuppressMessageAttribute();
    internal static string get_Avoid_legacy_format_target_in_SuppressMessageAttribute();
    internal static string get_Avoid_legacy_format_target_0_in_SuppressMessageAttribute();
    internal static string get_Remove_unnecessary_suppression();
    internal static string get_Remove_redundant_equality();
    internal static string get_Use_decrement_operator();
    internal static string get_Use_increment_operator();
    internal static string get_Avoid_multiple_blank_lines();
    internal static string get_Blank_line_required_between_block_and_subsequent_statement();
    internal static string get_Change_namespace_to_match_folder_structure();
    internal static string get_Namespace_0_does_not_match_folder_structure_expected_1();
    internal static string get_Namespace_does_not_match_folder_structure();
    internal static string get_Simplify_LINQ_expression();
    internal static string get_Set_MSBuild_Property_GenerateDocumentationFile_to_true();
    internal static string get_Set_MSBuild_Property_GenerateDocumentationFile_to_true_in_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build();
    internal static string get_Add_the_following_PropertyGroup_to_your_MSBuild_project_file_to_enable_IDE0005_Remove_unnecessary_usings_imports_on_build();
    internal static string get_Fix_formatting();
    internal static string get__0_statement_implicitly_converts_1_to_2_Add_an_explicit_cast_to_make_intent_clearer_as_it_may_fail_at_runtime();
    internal static string get_Add_explicit_cast();
    internal static string get_Name_can_be_simplified();
    internal static string get_Simplify_Names();
    internal static string get_Simplify_Member_Access();
    internal static string get_Remove_accessibility_modifiers();
    internal static string get_Simplify_check();
}
internal abstract class Microsoft.CodeAnalysis.BraceCompletion.AbstractBraceCompletionService : object {
    [NullableAttribute("1")]
protected ISyntaxFacts SyntaxFacts { get; }
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected bool NeedsSemantics { get; }
    [NullableContextAttribute("1")]
protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual char get_OpeningBrace();
    protected abstract virtual char get_ClosingBrace();
    protected virtual bool get_NeedsSemantics();
    protected abstract virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected abstract virtual bool IsValidClosingBraceToken(SyntaxToken token);
    public abstract virtual bool AllowOverType(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<bool> HasBraceCompletionAsync(BraceCompletionContext context, Document document, CancellationToken cancellationToken);
    public sealed virtual BraceCompletionResult GetBraceCompletion(BraceCompletionContext context);
    public virtual Nullable`1<BraceCompletionResult> GetTextChangesAfterCompletion(BraceCompletionContext braceCompletionContext, IndentationOptions options, CancellationToken cancellationToken);
    public virtual Nullable`1<BraceCompletionResult> GetTextChangeAfterReturn(BraceCompletionContext braceCompletionContext, IndentationOptions options, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    public sealed virtual Nullable`1<BraceCompletionContext> GetCompletedBraceContext(ParsedDocument document, int caretLocation);
    [NullableContextAttribute("1")]
protected virtual Task`1<bool> IsValidOpenBraceTokenAtPositionAsync(Document document, SyntaxToken token, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    protected bool AllowOverTypeInUserCodeWithValidClosingToken(BraceCompletionContext context, CancellationToken cancellationToken);
    protected bool AllowOverTypeWithValidClosingToken(BraceCompletionContext context);
    [NullableContextAttribute("1")]
protected static bool ParentIsSkippedTokensTriviaOrNull(ISyntaxFacts syntaxFacts, SyntaxToken token);
    private bool CheckClosingTokenKind(ParsedDocument document, int closingPosition);
    [NullableContextAttribute("1")]
protected static bool CouldEscapePreviousOpenBrace(char openingBrace, int position, SourceText text);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionContext : ValueType {
    [CompilerGeneratedAttribute]
private ParsedDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OpeningPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClosingPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CaretLocation>k__BackingField;
    public ParsedDocument Document { get; }
    public int OpeningPoint { get; }
    public int ClosingPoint { get; }
    public int CaretLocation { get; }
    public BraceCompletionContext(ParsedDocument document, int openingPoint, int closingPoint, int caretLocation);
    [CompilerGeneratedAttribute]
public ParsedDocument get_Document();
    [CompilerGeneratedAttribute]
public int get_OpeningPoint();
    [CompilerGeneratedAttribute]
public int get_ClosingPoint();
    [CompilerGeneratedAttribute]
public int get_CaretLocation();
    public bool HasCompletionForOpeningBrace(char openingBrace);
    public SyntaxToken GetOpeningToken();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.BraceCompletion.BraceCompletionResult : ValueType {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TextChange> <TextChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePosition <CaretLocation>k__BackingField;
    public ImmutableArray`1<TextChange> TextChanges { get; }
    public LinePosition CaretLocation { get; }
    public BraceCompletionResult(ImmutableArray`1<TextChange> textChanges, LinePosition caretLocation);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TextChange> get_TextChanges();
    [CompilerGeneratedAttribute]
public LinePosition get_CaretLocation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.BraceCompletion.ExportBraceCompletionServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public ExportBraceCompletionServiceAttribute(string language);
    [CompilerGeneratedAttribute]
public string get_Language();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService {
    public abstract virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> HasBraceCompletionAsync(BraceCompletionContext context, Document document, CancellationToken cancellationToken);
    public abstract virtual BraceCompletionResult GetBraceCompletion(BraceCompletionContext braceCompletionContext);
    public abstract virtual Nullable`1<BraceCompletionResult> GetTextChangesAfterCompletion(BraceCompletionContext braceCompletionContext, IndentationOptions options, CancellationToken cancellationToken);
    public abstract virtual Nullable`1<BraceCompletionResult> GetTextChangeAfterReturn(BraceCompletionContext braceCompletionContext, IndentationOptions options, CancellationToken cancellationToken);
    public abstract virtual Nullable`1<BraceCompletionContext> GetCompletedBraceContext(ParsedDocument document, int caretLocation);
    public abstract virtual bool AllowOverType(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.BraceMatching.AbstractBraceMatcher : object {
    private BraceCharacterAndKind _openBrace;
    private BraceCharacterAndKind _closeBrace;
    protected AbstractBraceMatcher(BraceCharacterAndKind openBrace, BraceCharacterAndKind closeBrace);
    private bool TryFindMatchingToken(SyntaxToken token, SyntaxToken& match);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceMatching.AbstractBraceMatcher/<FindBracesAsync>d__4")]
public sealed virtual Task`1<Nullable`1<BraceMatchingResult>> FindBracesAsync(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
    protected virtual bool AllowedForToken(SyntaxToken token);
    private bool IsBrace(char c);
    [CompilerGeneratedAttribute]
private bool <TryFindMatchingToken>b__3_2(<>f__AnonymousType0`2<SyntaxNodeOrToken, SyntaxToken> <>h__TransparentIdentifier0);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.BraceMatching.AbstractDirectiveTriviaBraceMatcher`7 : object {
    protected abstract virtual ImmutableArray`1<TDirectiveTriviaSyntax> GetMatchingConditionalDirectives(TDirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    protected abstract virtual TDirectiveTriviaSyntax GetMatchingDirective(TDirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    internal abstract virtual TextSpan GetSpanForTagging(TDirectiveTriviaSyntax directive);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceMatching.AbstractDirectiveTriviaBraceMatcher`7/<FindBracesAsync>d__3")]
public sealed virtual Task`1<Nullable`1<BraceMatchingResult>> FindBracesAsync(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.BraceMatching.AbstractEmbeddedLanguageBraceMatcher : AbstractEmbeddedLanguageFeatureService`1<IEmbeddedLanguageBraceMatcher> {
    protected AbstractEmbeddedLanguageBraceMatcher(string languageName, EmbeddedLanguageInfo info, ISyntaxKinds syntaxKinds, IEnumerable`1<Lazy`2<IEmbeddedLanguageBraceMatcher, EmbeddedLanguageMetadata>> allServices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceMatching.AbstractEmbeddedLanguageBraceMatcher/<FindBracesAsync>d__1")]
public sealed virtual Task`1<Nullable`1<BraceMatchingResult>> FindBracesAsync(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.BraceMatching.BraceCharacterAndKind : ValueType {
    [CompilerGeneratedAttribute]
private char <Character>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Kind>k__BackingField;
    public char Character { get; }
    public int Kind { get; }
    public BraceCharacterAndKind(char character, int kind);
    [CompilerGeneratedAttribute]
public char get_Character();
    [CompilerGeneratedAttribute]
public int get_Kind();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.BraceMatching.BraceMatchingOptions : ValueType {
    [CompilerGeneratedAttribute]
private HighlightingOptions <HighlightingOptions>k__BackingField;
    public static BraceMatchingOptions Default;
    [DataMemberAttribute]
public HighlightingOptions HighlightingOptions { get; public set; }
    public BraceMatchingOptions(HighlightingOptions HighlightingOptions);
    private static BraceMatchingOptions();
    [CompilerGeneratedAttribute]
public HighlightingOptions get_HighlightingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HighlightingOptions(HighlightingOptions value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BraceMatchingOptions left, BraceMatchingOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BraceMatchingOptions left, BraceMatchingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BraceMatchingOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(HighlightingOptions& HighlightingOptions);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.BraceMatching.BraceMatchingResult : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <LeftSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <RightSpan>k__BackingField;
    [DataMemberAttribute]
public TextSpan LeftSpan { get; public set; }
    [DataMemberAttribute]
public TextSpan RightSpan { get; public set; }
    public BraceMatchingResult(TextSpan LeftSpan, TextSpan RightSpan);
    [CompilerGeneratedAttribute]
public TextSpan get_LeftSpan();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LeftSpan(TextSpan value);
    [CompilerGeneratedAttribute]
public TextSpan get_RightSpan();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RightSpan(TextSpan value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BraceMatchingResult left, BraceMatchingResult right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BraceMatchingResult left, BraceMatchingResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BraceMatchingResult other);
    [CompilerGeneratedAttribute]
public void Deconstruct(TextSpan& LeftSpan, TextSpan& RightSpan);
}
[ExportAttribute("Microsoft.CodeAnalysis.BraceMatching.IBraceMatchingService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.BraceMatching.BraceMatchingService : object {
    private ImmutableArray`1<Lazy`2<IBraceMatcher, LanguageMetadata>> _braceMatchers;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public BraceMatchingService(IEnumerable`1<Lazy`2<IBraceMatcher, LanguageMetadata>> braceMatchers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceMatching.BraceMatchingService/<GetMatchingBracesAsync>d__2")]
public sealed virtual Task`1<Nullable`1<BraceMatchingResult>> GetMatchingBracesAsync(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.BraceMatching.ExportBraceMatcherAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public ExportBraceMatcherAttribute(string language);
    [CompilerGeneratedAttribute]
public string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.BraceMatching.ExportEmbeddedLanguageBraceMatcherAttribute : ExportEmbeddedLanguageFeatureServiceAttribute {
    public ExportEmbeddedLanguageBraceMatcherAttribute(string name, String[] languages, bool supportsUnannotatedAPIs, String[] identifiers);
    public ExportEmbeddedLanguageBraceMatcherAttribute(string name, String[] languages, String[] identifiers);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.BraceMatching.IBraceMatcher {
    public abstract virtual Task`1<Nullable`1<BraceMatchingResult>> FindBracesAsync(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.BraceMatching.IBraceMatchingService {
    public abstract virtual Task`1<Nullable`1<BraceMatchingResult>> GetMatchingBracesAsync(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.BraceMatching.IBraceMatchingServiceExtensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BraceMatching.IBraceMatchingServiceExtensions/<FindMatchingSpanAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Nullable`1<TextSpan>> FindMatchingSpanAsync(IBraceMatchingService service, Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.BraceMatching.IEmbeddedLanguageBraceMatcher {
    [NullableContextAttribute("1")]
public abstract virtual Nullable`1<BraceMatchingResult> FindBraces(Project project, SemanticModel semanticModel, SyntaxToken token, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.BracePairs.AbstractBracePairsService : object {
    [NullableAttribute("1")]
private Dictionary`2<int, int> _bracePairKinds;
    [NullableContextAttribute("1")]
protected AbstractBracePairsService(ISyntaxKinds syntaxKinds);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.BracePairs.AbstractBracePairsService/<AddBracePairsAsync>d__2")]
public sealed virtual Task AddBracePairsAsync(Document document, TextSpan span, ArrayBuilder`1<BracePairData> bracePairs, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <.ctor>g__Add|1_0(Nullable`1<int> open, Nullable`1<int> close);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.BracePairs.BracePairData : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <End>k__BackingField;
    public TextSpan Start { get; public set; }
    public TextSpan End { get; public set; }
    public BracePairData(TextSpan Start, TextSpan End);
    [CompilerGeneratedAttribute]
public TextSpan get_Start();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Start(TextSpan value);
    [CompilerGeneratedAttribute]
public TextSpan get_End();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_End(TextSpan value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BracePairData left, BracePairData right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BracePairData left, BracePairData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BracePairData other);
    [CompilerGeneratedAttribute]
public void Deconstruct(TextSpan& Start, TextSpan& End);
}
internal interface Microsoft.CodeAnalysis.BracePairs.IBracePairsService {
    [NullableContextAttribute("1")]
public abstract virtual Task AddBracePairsAsync(Document document, TextSpan textSpan, ArrayBuilder`1<BracePairData> bracePairs, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService : object {
    public abstract virtual Task`1<bool> CanChangeNamespaceAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    public abstract virtual Task`1<Solution> ChangeNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Solution> TryChangeTopLevelNamespacesAsync(Document document, string targetNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public abstract virtual bool TryGetReplacementReferenceSyntax(SyntaxNode reference, ImmutableArray`1<string> newNamespaceParts, ISyntaxFactsService syntaxFacts, SyntaxNode& old, SyntaxNode& new);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3 : AbstractChangeNamespaceService {
    private static Char[] s_dotSeparator;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <ContainerAnnotation>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <WarningAnnotation>k__BackingField;
    protected static SyntaxAnnotation ContainerAnnotation { get; }
    protected static SyntaxAnnotation WarningAnnotation { get; }
    private static AbstractChangeNamespaceService`3();
    [CompilerGeneratedAttribute]
protected static SyntaxAnnotation get_ContainerAnnotation();
    [CompilerGeneratedAttribute]
protected static SyntaxAnnotation get_WarningAnnotation();
    protected abstract virtual TCompilationUnitSyntax ChangeNamespaceDeclaration(TCompilationUnitSyntax root, ImmutableArray`1<string> declaredNamespaceParts, ImmutableArray`1<string> targetNamespaceParts);
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetMemberDeclarationsInContainer(SyntaxNode compilationUnitOrNamespaceDecl);
    protected abstract virtual Task`1<SyntaxNode> TryGetApplicableContainerFromSpanAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected abstract virtual string GetDeclaredNamespace(SyntaxNode container);
    protected abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>>> GetValidContainersFromAllLinkedDocumentsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    private static bool IsValidContainer(SyntaxNode container);
    protected static bool IsGlobalNamespace(ImmutableArray`1<string> parts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<CanChangeNamespaceAsync>d__14")]
public virtual Task`1<bool> CanChangeNamespaceAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<TryChangeTopLevelNamespacesAsync>d__15")]
public virtual Task`1<Solution> TryChangeTopLevelNamespacesAsync(Document document, string targetNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<ChangeNamespaceAsync>d__16")]
public virtual Task`1<Solution> ChangeNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<TryGetApplicableContainersFromAllDocumentsAsync>d__17")]
protected Task`1<ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>>> TryGetApplicableContainersFromAllDocumentsAsync(Solution solution, ImmutableArray`1<DocumentId> ids, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<AnnotateContainersAsync>d__18")]
protected static Task`1<Solution> AnnotateContainersAsync(Solution solution, ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>> containers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<ContainsPartialTypeWithMultipleDeclarationsAsync>d__19")]
protected Task`1<bool> ContainsPartialTypeWithMultipleDeclarationsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    protected static bool IsSupportedLinkedDocument(Document document, ImmutableArray`1& allDocumentIds);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<GetDeclaredSymbolsInContainerAsync>d__21")]
private Task`1<ImmutableArray`1<ISymbol>> GetDeclaredSymbolsInContainerAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    private static ImmutableArray`1<string> GetNamespaceParts(string namespace);
    private static ImmutableArray`1<string> GetAllNamespaceImportsForDeclaringDocument(string oldNamespace, string newNamespace);
    private static ImmutableArray`1<SyntaxNode> CreateImports(Document document, ImmutableArray`1<string> names, bool withFormatterAnnotation);
    private static SyntaxNode CreateImport(SyntaxGenerator syntaxGenerator, string name, bool withFormatterAnnotation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<ChangeNamespaceInSingleDocumentAsync>d__26")]
private Task`1<ValueTuple`2<Solution, ImmutableArray`1<DocumentId>>> ChangeNamespaceInSingleDocumentAsync(Solution solution, DocumentId id, string oldNamespace, string newNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FindReferenceLocationsForSymbolAsync>d__28")]
private static Task`1<ImmutableArray`1<LocationForAffectedSymbol<TNamespaceDeclarationSyntax, TCompilationUnitSyntax, TMemberDeclarationSyntax>>> FindReferenceLocationsForSymbolAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FindReferencesAsync>d__29")]
private static Task`1<ImmutableArray`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FixDeclarationDocumentAsync>d__30")]
private Task`1<Document> FixDeclarationDocumentAsync(Document document, IReadOnlyList`1<LocationForAffectedSymbol<TNamespaceDeclarationSyntax, TCompilationUnitSyntax, TMemberDeclarationSyntax>> refLocations, string oldNamespace, string newNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FixReferencingDocumentAsync>d__31")]
private static Task`1<Document> FixReferencingDocumentAsync(Document document, IEnumerable`1<LocationForAffectedSymbol<TNamespaceDeclarationSyntax, TCompilationUnitSyntax, TMemberDeclarationSyntax>> refLocations, string newNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<FixReferencesAsync>d__32")]
private static Task`1<ValueTuple`2<Document, ImmutableArray`1<SyntaxNode>>> FixReferencesAsync(Document document, IChangeNamespaceService changeNamespaceService, IAddImportsService addImportService, IEnumerable`1<LocationForAffectedSymbol<TNamespaceDeclarationSyntax, TCompilationUnitSyntax, TMemberDeclarationSyntax>> refLocations, ImmutableArray`1<string> newNamespaceParts, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<RemoveUnnecessaryImportsAsync>d__33")]
private static Task`1<Solution> RemoveUnnecessaryImportsAsync(Solution solution, ImmutableArray`1<DocumentId> ids, ImmutableArray`1<string> names, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<AddImportsInContainersAsync>d__34")]
private static Task`1<Document> AddImportsInContainersAsync(Document document, IAddImportsService addImportService, ImmutableArray`1<SyntaxNode> containers, ImmutableArray`1<string> names, AddImportPlacementOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<MergeDiffAsync>d__35")]
private static Task`1<Solution> MergeDiffAsync(Solution oldSolution, Solution newSolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<<TryChangeTopLevelNamespacesAsync>g__GetTopLevelNamespacesAsync|15_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<ImmutableArray`1<SyntaxNode>> <TryChangeTopLevelNamespacesAsync>g__GetTopLevelNamespacesAsync|15_0(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeNamespace.AbstractChangeNamespaceService`3/<<RemoveUnnecessaryImportsAsync>g__RemoveUnnecessaryImportsWorkerAsync|33_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<Document> <RemoveUnnecessaryImportsAsync>g__RemoveUnnecessaryImportsWorkerAsync|33_0(Document doc, IEnumerable`1<SyntaxNode> importsToRemove, CodeCleanupOptionsProvider fallbackOptions, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService : object {
    protected SyntaxAnnotation changeSignatureFormattingAnnotation;
    protected SyntaxGenerator Generator { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    public abstract virtual Task`1<ValueTuple`2<ISymbol, int>> GetInvocationSymbolAsync(Document document, int position, bool restrictToDeclarations, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode FindNodeToUpdate(Document document, SyntaxNode node);
    public abstract virtual Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsFromDelegateInvokeAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<SyntaxNode> ChangeSignatureAsync(Document document, ISymbol declarationSymbol, SyntaxNode potentiallyUpdatedNode, SyntaxNode originalNode, SignatureChange signaturePermutation, LineFormattingOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected abstract virtual T TransferLeadingWhitespaceTrivia(T newArgument, SyntaxNode oldArgument);
    protected abstract virtual SyntaxToken CommaTokenWithElasticSpace();
    protected abstract virtual TArgumentSyntax CreateExplicitParamsArrayFromIndividualArguments(SeparatedSyntaxList`1<TArgumentSyntax> newArguments, int startingIndex, IParameterSymbol parameterSymbol);
    protected abstract virtual TArgumentSyntax AddNameToArgument(TArgumentSyntax argument, string name);
    protected abstract virtual bool SupportsOptionalAndParamsArrayParametersSimultaneously();
    protected abstract virtual bool TryGetRecordPrimaryConstructor(INamedTypeSymbol typeSymbol, IMethodSymbol& primaryConstructor);
    protected abstract virtual ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol declarationSymbol);
    protected abstract virtual SyntaxGenerator get_Generator();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<GetChangeSignatureCodeActionAsync>d__17")]
public Task`1<ImmutableArray`1<ChangeSignatureCodeAction>> GetChangeSignatureCodeActionAsync(Document document, TextSpan span, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<GetChangeSignatureContextAsync>d__18")]
internal Task`1<ChangeSignatureAnalyzedContext> GetChangeSignatureContextAsync(Document document, int position, bool restrictToDeclarations, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<ChangeSignatureWithContextAsync>d__19")]
internal Task`1<ChangeSignatureResult> ChangeSignatureWithContextAsync(ChangeSignatureAnalyzedContext context, ChangeSignatureOptionsResult options, CancellationToken cancellationToken);
    internal static ChangeSignatureOptionsResult GetChangeSignatureOptions(ChangeSignatureAnalyzedContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<FindChangeSignatureReferencesAsync>d__21")]
private static Task`1<ImmutableArray`1<ReferencedSymbol>> FindChangeSignatureReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<CreateUpdatedSolutionAsync>d__22")]
private Task`1<ValueTuple`2<Solution, string>> CreateUpdatedSolutionAsync(ChangeSignatureAnalysisSucceededContext context, ChangeSignatureOptionsResult options, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static void AddUpdatableNodeToDictionaries(Dictionary`2<DocumentId, List`1<SyntaxNode>> nodesToUpdate, DocumentId documentId, SyntaxNode nodeToUpdate, Dictionary`2<SyntaxNode, ISymbol> definitionToUse, ISymbol symbolWithSemanticParameters);
    [NullableContextAttribute("0")]
private static bool TryGetNodeWithEditableSignatureOrAttributes(Location location, Solution solution, SyntaxNode& nodeToUpdate, DocumentId& documentId);
    [NullableContextAttribute("0")]
protected ImmutableArray`1<IUnifiedArgumentSyntax> PermuteArguments(ISymbol declarationSymbol, ImmutableArray`1<IUnifiedArgumentSyntax> arguments, SignatureChange updatedSignature, bool isReducedExtensionMethod);
    [NullableContextAttribute("0")]
private SignatureChange UpdateSignatureChangeToIncludeExtraParametersFromTheDeclarationSymbol(ISymbol declarationSymbol, SignatureChange updatedSignature);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<IParameterSymbol> GetParametersToPermute(ImmutableArray`1<IUnifiedArgumentSyntax> arguments, ImmutableArray`1<IParameterSymbol> originalParameters, bool isReducedExtensionMethod);
    [NullableContextAttribute("0")]
protected static int GetParameterIndex(SeparatedSyntaxList`1<TNode> parameters, int position);
    [NullableContextAttribute("0")]
protected ValueTuple`2<ImmutableArray`1<T>, ImmutableArray`1<SyntaxToken>> UpdateDeclarationBase(SeparatedSyntaxList`1<T> list, SignatureChange updatedSignature, Func`2<AddedParameter, T> createNewParameterMethod);
    [NullableContextAttribute("0")]
protected ImmutableArray`1<SyntaxToken> GetSeparators(SeparatedSyntaxList`1<T> arguments, int numSeparatorsToSkip);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<AddNewArgumentsToListAsync>d__31`1")]
protected virtual Task`1<SeparatedSyntaxList`1<TArgumentSyntax>> AddNewArgumentsToListAsync(ISymbol declarationSymbol, SeparatedSyntaxList`1<TArgumentSyntax> newArguments, SignatureChange signaturePermutation, bool isReducedExtensionMethod, bool isParamsArrayExpanded, bool generateAttributeArguments, Document document, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<GenerateInferredCallsiteExpressionAsync>d__32")]
private Task`1<SyntaxNode> GenerateInferredCallsiteExpressionAsync(Document document, int position, AddedParameter addedParameter, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
protected ImmutableArray`1<SyntaxTrivia> GetPermutedDocCommentTrivia(SyntaxNode node, ImmutableArray`1<SyntaxNode> permutedParamNodes, LanguageServices services, LineFormattingOptions options);
    [NullableContextAttribute("0")]
protected static bool IsParamsArrayExpandedHelper(ISymbol symbol, int argumentCount, bool lastArgumentIsNamed, SemanticModel semanticModel, SyntaxNode lastArgumentExpression, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
protected static int GetParameterIndexFromInvocationArgument(SyntaxNode argument, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService/<<ChangeSignatureWithContextAsync>g__GetChangeSignatureResultAsync|19_0>d")]
[CompilerGeneratedAttribute]
private Task`1<ChangeSignatureResult> <ChangeSignatureWithContextAsync>g__GetChangeSignatureResultAsync|19_0(ChangeSignatureAnalysisSucceededContext context, ChangeSignatureOptionsResult options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.AddedParameter : Parameter {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TypeBinds>k__BackingField;
    [CompilerGeneratedAttribute]
private CallSiteKind <CallSiteKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallSiteValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    public string Name { get; }
    public bool HasDefaultValue { get; }
    public ITypeSymbol Type { get; }
    public string TypeName { get; }
    public bool TypeBinds { get; }
    public CallSiteKind CallSiteKind { get; }
    public string CallSiteValue { get; }
    public bool IsRequired { get; }
    public string DefaultValue { get; }
    public AddedParameter(ITypeSymbol type, string typeName, string name, CallSiteKind callSiteKind, string callSiteValue, bool isRequired, string defaultValue, bool typeBinds);
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public virtual bool get_HasDefaultValue();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public bool get_TypeBinds();
    [CompilerGeneratedAttribute]
public CallSiteKind get_CallSiteKind();
    [CompilerGeneratedAttribute]
public string get_CallSiteValue();
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
    public virtual string ToString();
}
internal enum Microsoft.CodeAnalysis.ChangeSignature.CallSiteKind : Enum {
    public int value__;
    public static CallSiteKind Value;
    public static CallSiteKind ValueWithName;
    public static CallSiteKind Todo;
    public static CallSiteKind Omitted;
    public static CallSiteKind Inferred;
}
internal class Microsoft.CodeAnalysis.ChangeSignature.CannotChangeSignatureAnalyzedContext : ChangeSignatureAnalyzedContext {
    public ChangeSignatureFailureKind CannotChangeSignatureReason;
    public CannotChangeSignatureAnalyzedContext(ChangeSignatureFailureKind reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureAnalysisSucceededContext : ChangeSignatureAnalyzedContext {
    public Document Document;
    public ISymbol Symbol;
    public ParameterConfiguration ParameterConfiguration;
    public int PositionForTypeBinding;
    public CodeCleanupOptionsProvider FallbackOptions;
    public Solution Solution { get; }
    public ChangeSignatureAnalysisSucceededContext(Document document, int positionForTypeBinding, ISymbol symbol, ParameterConfiguration parameterConfiguration, CodeCleanupOptionsProvider fallbackOptions);
    public Solution get_Solution();
}
internal abstract class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureAnalyzedContext : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeAction : CodeActionWithOptions {
    private AbstractChangeSignatureService _changeSignatureService;
    private ChangeSignatureAnalysisSucceededContext _context;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    public string Title { get; }
    public ChangeSignatureCodeAction(AbstractChangeSignatureService changeSignatureService, ChangeSignatureAnalysisSucceededContext context);
    public virtual ImmutableArray`1<string> get_Tags();
    public virtual string get_Title();
    [NullableContextAttribute("2")]
public virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeAction/<ComputeOperationsAsync>d__8")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeActionOperation : CodeActionOperation {
    [CompilerGeneratedAttribute]
private Solution <ChangedSolution>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ConfirmationMessage>k__BackingField;
    public Solution ChangedSolution { get; }
    [NullableAttribute("2")]
public string ConfirmationMessage { get; }
    internal bool ApplyDuringTests { get; }
    public ChangeSignatureCodeActionOperation(Solution changedSolution, string confirmationMessage);
    [CompilerGeneratedAttribute]
public Solution get_ChangedSolution();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ConfirmationMessage();
    internal virtual bool get_ApplyDuringTests();
    internal sealed virtual Task`1<bool> TryApplyAsync(Workspace workspace, Solution originalSolution, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    private bool ApplyWorker(Workspace workspace, Solution originalSolution, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal enum Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureFailureKind : Enum {
    public int value__;
    public static ChangeSignatureFailureKind None;
    public static ChangeSignatureFailureKind DefinedInMetadata;
    public static ChangeSignatureFailureKind IncorrectKind;
}
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureLogger : object {
    private static string Maximum;
    private static string Minimum;
    private static string Mean;
    private static CountLogAggregator`1<ActionInfo> s_countLogAggregator;
    private static StatisticLogAggregator`1<ActionInfo> s_statisticLogAggregator;
    private static HistogramLogAggregator`1<ActionInfo> s_histogramLogAggregator;
    private static ChangeSignatureLogger();
    internal static void LogChangeSignatureDialogLaunched();
    internal static void LogChangeSignatureDialogCommitted();
    internal static void LogAddParameterDialogLaunched();
    internal static void LogAddParameterDialogCommitted();
    internal static void LogTransformationInformation(int numOriginalParameters, int numParametersAdded, int numParametersRemoved, bool anyParametersReordered);
    private static void LogTransformationCombination(bool parametersAdded, bool parametersRemoved, bool parametersReordered);
    internal static void LogCommitInformation(int numDeclarationsUpdated, int numCallSitesUpdated, TimeSpan elapsedTime);
    internal static void LogAddedParameterTypeBinds();
    internal static void LogAddedParameterRequired();
    internal static void LogAddedParameter_ValueExplicit();
    internal static void LogAddedParameter_ValueExplicitNamed();
    internal static void LogAddedParameter_ValueTODO();
    internal static void LogAddedParameter_ValueOmitted();
    internal static void ReportTelemetry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureOptionsResult : object {
    public bool PreviewChanges;
    public SignatureChange UpdatedSignature;
    public ChangeSignatureOptionsResult(SignatureChange updatedSignature, bool previewChanges);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ChangeSignatureResult : object {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <UpdatedSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Glyph> <Glyph>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreviewChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ChangeSignatureFailureKind> <ChangeSignatureFailureKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfirmationMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [MemberNotNullWhenAttribute("True", "UpdatedSolution")]
public bool Succeeded { get; }
    public Solution UpdatedSolution { get; }
    public Nullable`1<Glyph> Glyph { get; }
    public bool PreviewChanges { get; }
    public Nullable`1<ChangeSignatureFailureKind> ChangeSignatureFailureKind { get; }
    public string ConfirmationMessage { get; }
    public string Name { get; }
    public ChangeSignatureResult(bool succeeded, Solution updatedSolution, string name, Nullable`1<Glyph> glyph, bool previewChanges, Nullable`1<ChangeSignatureFailureKind> changeSignatureFailureKind, string confirmationMessage);
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("True", "UpdatedSolution")]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public Solution get_UpdatedSolution();
    [CompilerGeneratedAttribute]
public Nullable`1<Glyph> get_Glyph();
    [CompilerGeneratedAttribute]
public bool get_PreviewChanges();
    [CompilerGeneratedAttribute]
public Nullable`1<ChangeSignatureFailureKind> get_ChangeSignatureFailureKind();
    [CompilerGeneratedAttribute]
public string get_ConfirmationMessage();
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.ChangeSignature.DelegateInvokeMethodReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    public static DelegateInvokeMethodReferenceFinder Instance;
    private static DelegateInvokeMethodReferenceFinder();
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ChangeSignature.DelegateInvokeMethodReferenceFinder/<DetermineCascadedSymbolsAsync>d__3")]
protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IMethodSymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual Task DetermineDocumentsToSearchAsync(IMethodSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, Action`2<Document, TData> processResult, TData processResultData, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual void FindReferencesInDocument(IMethodSymbol methodSymbol, FindReferencesDocumentState state, Action`2<FinderLocation, TData> processResult, TData processResultData, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static FinderLocation <FindReferencesInDocument>g__CreateFinderLocation|5_1(SyntaxNode node, FindReferencesDocumentState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ExistingParameter : Parameter {
    [CompilerGeneratedAttribute]
private IParameterSymbol <Symbol>k__BackingField;
    public IParameterSymbol Symbol { get; }
    public bool HasDefaultValue { get; }
    public string Name { get; }
    public ExistingParameter(IParameterSymbol param);
    [CompilerGeneratedAttribute]
public IParameterSymbol get_Symbol();
    public virtual bool get_HasDefaultValue();
    public virtual string get_Name();
}
internal interface Microsoft.CodeAnalysis.ChangeSignature.IChangeSignatureOptionsService {
    [NullableContextAttribute("1")]
public abstract virtual ChangeSignatureOptionsResult GetChangeSignatureOptions(Document document, int positionForTypeBinding, ISymbol symbol, ParameterConfiguration parameters);
}
internal interface Microsoft.CodeAnalysis.ChangeSignature.IUnifiedArgumentSyntax {
    public bool IsDefault { get; }
    public bool IsNamed { get; }
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool get_IsNamed();
    public abstract virtual string GetName();
    public abstract virtual IUnifiedArgumentSyntax WithName(string name);
    public abstract virtual IUnifiedArgumentSyntax WithAdditionalAnnotations(SyntaxAnnotation annotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ChangeSignature.Parameter : object {
    public bool HasDefaultValue { get; }
    public string Name { get; }
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual string get_Name();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.ParameterConfiguration : object {
    public ExistingParameter ThisParameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Parameter> ParametersWithoutDefaultValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Parameter> RemainingEditableParameters;
    public ExistingParameter ParamsParameter;
    public int SelectedIndex;
    public ParameterConfiguration(ExistingParameter thisParameter, ImmutableArray`1<Parameter> parametersWithoutDefaultValues, ImmutableArray`1<Parameter> remainingEditableParameters, ExistingParameter paramsParameter, int selectedIndex);
    [NullableContextAttribute("1")]
public static ParameterConfiguration Create(ImmutableArray`1<Parameter> parameters, bool isExtensionMethod, int selectedIndex);
    [NullableContextAttribute("1")]
internal ParameterConfiguration WithoutAddedParameters();
    public ImmutableArray`1<Parameter> ToListOfParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ChangeSignature.SignatureChange : object {
    public ParameterConfiguration OriginalConfiguration;
    public ParameterConfiguration UpdatedConfiguration;
    private Dictionary`2<int, Nullable`1<int>> _originalIndexToUpdatedIndexMap;
    public SignatureChange(ParameterConfiguration originalConfiguration, ParameterConfiguration updatedConfiguration);
    public Nullable`1<int> GetUpdatedIndex(int parameterIndex);
    internal SignatureChange WithoutAddedParameters();
    internal void LogTelemetry();
    private static bool AnyParametersReordered(ImmutableArray`1<Parameter> originalListOfParameters, ImmutableArray`1<Parameter> updatedListOfParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Classification.AbstractEmbeddedLanguageClassificationService : AbstractEmbeddedLanguageFeatureService`1<IEmbeddedLanguageClassifier> {
    private IEmbeddedLanguageClassifier _fallbackClassifier;
    protected AbstractEmbeddedLanguageClassificationService(string languageName, EmbeddedLanguageInfo info, ISyntaxKinds syntaxKinds, IEmbeddedLanguageClassifier fallbackClassifier, IEnumerable`1<Lazy`2<IEmbeddedLanguageClassifier, EmbeddedLanguageMetadata>> allClassifiers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractEmbeddedLanguageClassificationService/<AddEmbeddedLanguageClassificationsAsync>d__2")]
public sealed virtual Task AddEmbeddedLanguageClassificationsAsync(Document document, ImmutableArray`1<TextSpan> textSpans, ClassificationOptions options, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public sealed virtual void AddEmbeddedLanguageClassifications(SolutionServices services, Project project, SemanticModel semanticModel, ImmutableArray`1<TextSpan> textSpans, ClassificationOptions options, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Classification.AbstractFallbackEmbeddedLanguageClassifier : object {
    private EmbeddedLanguageInfo _info;
    private ImmutableArray`1<int> _supportedKinds;
    protected AbstractFallbackEmbeddedLanguageClassifier(EmbeddedLanguageInfo info);
    public sealed virtual void RegisterClassifications(EmbeddedLanguageClassificationContext context);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpan : ValueType {
    public static string Key;
    public ImmutableArray`1<ClassifiedSpan> ClassifiedSpans;
    public TextSpan HighlightSpan;
    public ClassifiedSpansAndHighlightSpan(ImmutableArray`1<ClassifiedSpan> classifiedSpans, TextSpan highlightSpan);
}
internal static class Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<ClassifyAsync>d__0")]
public static Task`1<ClassifiedSpansAndHighlightSpan> ClassifyAsync(DocumentSpan documentSpan, Nullable`1<ClassifiedSpansAndHighlightSpan> classifiedSpans, ClassificationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<ClassifyAsync>d__1")]
private static Task`1<ClassifiedSpansAndHighlightSpan> ClassifyAsync(Document document, TextSpan sourceSpan, ClassificationOptions options, CancellationToken cancellationToken);
    private static TextSpan GetLineSpanForReference(SourceText sourceText, TextSpan referenceSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<GetTaggedTextForDocumentRegionAsync>d__3")]
private static Task`1<ClassifiedSpansAndHighlightSpan> GetTaggedTextForDocumentRegionAsync(Document document, TextSpan narrowSpan, TextSpan widenedSpan, ClassificationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifiedSpansAndHighlightSpanFactory/<GetClassifiedSpansAsync>d__4")]
private static Task`1<ImmutableArray`1<ClassifiedSpan>> GetClassifiedSpansAsync(Document document, TextSpan narrowSpan, TextSpan widenedSpan, ClassificationOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Classification.EmbeddedLanguageClassificationContext : ValueType {
    internal SolutionServices SolutionServices;
    private SegmentedList`1<ClassifiedSpan> _result;
    private TextSpan _spanToClassify;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <SyntaxToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    internal ClassificationOptions Options;
    internal IVirtualCharService VirtualCharService;
    public Project Project { get; }
    public SyntaxToken SyntaxToken { get; }
    public SemanticModel SemanticModel { get; }
    public CancellationToken CancellationToken { get; }
    internal EmbeddedLanguageClassificationContext(SolutionServices solutionServices, Project project, SemanticModel semanticModel, SyntaxToken syntaxToken, TextSpan spanToClassify, ClassificationOptions options, IVirtualCharService virtualCharService, SegmentedList`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public SyntaxToken get_SyntaxToken();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    public void AddClassification(string classificationType, TextSpan span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Classification.ExportEmbeddedLanguageClassifierAttribute : ExportEmbeddedLanguageFeatureServiceAttribute {
    public ExportEmbeddedLanguageClassifierAttribute(string name, String[] languages, bool supportsUnannotatedAPIs, String[] identifiers);
    public ExportEmbeddedLanguageClassifierAttribute(string name, String[] languages, String[] identifiers);
}
internal interface Microsoft.CodeAnalysis.Classification.IEmbeddedLanguageClassifier {
    public abstract virtual void RegisterClassifications(EmbeddedLanguageClassificationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeActions.DefaultCodeActionRequestPriorityProvider : object {
    private object _gate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<DiagnosticAnalyzer> _lowPriorityAnalyzers;
    [CompilerGeneratedAttribute]
private Nullable`1<CodeActionRequestPriority> <Priority>k__BackingField;
    public Nullable`1<CodeActionRequestPriority> Priority { get; }
    public DefaultCodeActionRequestPriorityProvider(Nullable`1<CodeActionRequestPriority> priority);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<CodeActionRequestPriority> get_Priority();
    public sealed virtual void AddDeprioritizedAnalyzerWithLowPriority(DiagnosticAnalyzer analyzer);
    public sealed virtual bool IsDeprioritizedAnalyzerWithLowPriority(DiagnosticAnalyzer analyzer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.CodeActions.DocumentNavigationOperation : CodeActionOperation {
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal DocumentId DocumentId { get; }
    internal int Position { get; }
    public DocumentNavigationOperation(DocumentId documentId, int position);
    [CompilerGeneratedAttribute]
internal DocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
internal int get_Position();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProvider {
    public Nullable`1<CodeActionRequestPriority> Priority { get; }
    public abstract virtual Nullable`1<CodeActionRequestPriority> get_Priority();
    public abstract virtual void AddDeprioritizedAnalyzerWithLowPriority(DiagnosticAnalyzer analyzer);
    public abstract virtual bool IsDeprioritizedAnalyzerWithLowPriority(DiagnosticAnalyzer analyzer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeActions.ICodeActionRequestPriorityProviderExtensions : object {
    [ExtensionAttribute]
public static bool MatchesPriority(ICodeActionRequestPriorityProvider provider, DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool MatchesPriority(ICodeActionRequestPriorityProvider provider, CodeFixProvider codeFixProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeActions.StartInlineRenameSessionOperation : CodeActionOperation {
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public DocumentId DocumentId { get; }
    public int Position { get; }
    public StartInlineRenameSessionOperation(DocumentId documentId, int position);
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
public int get_Position();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeActions.WorkspaceServices.IAddMetadataReferenceCodeActionOperationFactoryWorkspaceService {
    public abstract virtual CodeActionOperation CreateAddMetadataReferenceOperation(ProjectId projectId, AssemblyIdentity assemblyIdentity);
}
internal interface Microsoft.CodeAnalysis.CodeActions.WorkspaceServices.ISymbolRenamedCodeActionOperationFactoryWorkspaceService {
    public abstract virtual CodeActionOperation CreateSymbolRenamedOperation(ISymbol symbol, string newName, Solution startingSolution, Solution updatedSolution);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.AbstractConfigurationActionWithNestedActions : CodeActionWithNestedActions {
    internal CodeActionPriority AdditionalPriority { get; }
    internal bool IsBulkConfigurationAction { get; }
    [NullableContextAttribute("1")]
protected AbstractConfigurationActionWithNestedActions(ImmutableArray`1<CodeAction> nestedActions, string title);
    internal virtual CodeActionPriority get_AdditionalPriority();
    internal virtual bool get_IsBulkConfigurationAction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.AbstractFixAllCodeFixCodeAction : AbstractFixAllCodeAction {
    private static HashSet`1<string> s_predefinedCodeFixProviderNames;
    protected AbstractFixAllCodeFixCodeAction(IFixAllState fixAllState, bool showPreviewChangesDialog);
    private static AbstractFixAllCodeFixCodeAction();
    protected sealed virtual IFixAllContext CreateFixAllContext(IFixAllState fixAllState, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    protected sealed virtual bool IsInternalProvider(IFixAllState fixAllState);
    private static HashSet`1<string> GetPredefinedCodeFixProviderNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    private static int MaximumConversionOptions;
    protected abstract virtual TExpressionSyntax Cast(TExpressionSyntax expression, ITypeSymbol type);
    protected abstract virtual void GetPartsOfCastOrConversionExpression(TExpressionSyntax expression, SyntaxNode& type, SyntaxNode& castedExpression);
    protected abstract virtual bool TryGetTargetTypeInfo(Document document, SemanticModel semanticModel, SyntaxNode root, string diagnosticId, TExpressionSyntax spanNode, CancellationToken cancellationToken, ImmutableArray`1& potentialConversionTypes);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private SyntaxNode ApplyFix(Document document, SemanticModel semanticModel, SyntaxNode currentRoot, TExpressionSyntax targetNode, ITypeSymbol conversionType, CancellationToken cancellationToken);
    private static string GetSubItemName(SemanticModel semanticModel, int position, ITypeSymbol conversionType);
    protected static ImmutableArray`1<ValueTuple`2<TExpressionSyntax, ITypeSymbol>> FilterValidPotentialConversionTypes(Document document, SemanticModel semanticModel, ArrayBuilder`1<ValueTuple`2<TExpressionSyntax, ITypeSymbol>> mutablePotentialConversionTypes);
    protected static bool FindCorrespondingParameterByName(string argumentName, ImmutableArray`1<IParameterSymbol> parameters, Int32& parameterIndex);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.AbstractAddExplicitCastCodeFixProvider`1/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.AddExplicitCast.InheritanceDistanceComparer`1 : object {
    private SemanticModel _semanticModel;
    public InheritanceDistanceComparer`1(SemanticModel semanticModel);
    public sealed virtual int Compare(ValueTuple`2<TExpressionSyntax, ITypeSymbol> x, ValueTuple`2<TExpressionSyntax, ITypeSymbol> y);
    private static int GetInheritanceDistanceRecursive(ITypeSymbol baseType, ITypeSymbol derivedType);
    private int GetInheritanceDistance(ITypeSymbol baseType, ITypeSymbol castType);
}
internal class Microsoft.CodeAnalysis.CodeFixes.CodeFixCollection : object {
    [CompilerGeneratedAttribute]
private object <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CodeFix> <Fixes>k__BackingField;
    [CompilerGeneratedAttribute]
private FixAllState <FixAllState>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<FixAllScope> <SupportedScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private Diagnostic <FirstDiagnostic>k__BackingField;
    public object Provider { get; }
    public TextSpan TextSpan { get; }
    public ImmutableArray`1<CodeFix> Fixes { get; }
    public FixAllState FixAllState { get; }
    public ImmutableArray`1<FixAllScope> SupportedScopes { get; }
    public Diagnostic FirstDiagnostic { get; }
    public CodeFixCollection(object provider, TextSpan span, ImmutableArray`1<CodeFix> fixes, FixAllState fixAllState, ImmutableArray`1<FixAllScope> supportedScopes, Diagnostic firstDiagnostic);
    [CompilerGeneratedAttribute]
public object get_Provider();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CodeFix> get_Fixes();
    [CompilerGeneratedAttribute]
public FixAllState get_FixAllState();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<FixAllScope> get_SupportedScopes();
    [CompilerGeneratedAttribute]
public Diagnostic get_FirstDiagnostic();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater : object {
    private static string DiagnosticOptionPrefix;
    private static string SeveritySuffix;
    private static string BulkConfigureAllAnalyzerDiagnosticsOptionKey;
    private static string BulkConfigureAnalyzerDiagnosticsByCategoryOptionPrefix;
    private static string AllAnalyzerDiagnosticsCategory;
    private static Regex s_headerPattern;
    private static Regex s_optionEntryPattern;
    [NullableAttribute("2")]
private string _optionNameOpt;
    [NullableAttribute("2")]
private string _newOptionValueOpt;
    private string _newSeverity;
    private ConfigurationKind _configurationKind;
    [NullableAttribute("2")]
private Diagnostic _diagnostic;
    [NullableAttribute("2")]
private string _categoryToBulkConfigure;
    private bool _isPerLanguage;
    private Project _project;
    private bool _addNewEntryIfNoExistingEntryFound;
    private string _language;
    [NullableContextAttribute("2")]
private ConfigurationUpdater(string optionNameOpt, string newOptionValueOpt, string newSeverity, ConfigurationKind configurationKind, Diagnostic diagnosticToConfigure, string categoryToBulkConfigure, bool isPerLanguage, Project project, bool addNewEntryIfNoExistingEntryFound);
    private static ConfigurationUpdater();
    public static Task`1<Solution> ConfigureSeverityAsync(ReportDiagnostic severity, Diagnostic diagnostic, Project project, CancellationToken cancellationToken);
    public static Task`1<Solution> ConfigureSeverityAsync(string editorConfigSeverity, Diagnostic diagnostic, Project project, CancellationToken cancellationToken);
    public static Task`1<Solution> BulkConfigureSeverityAsync(string editorConfigSeverity, string category, Project project, CancellationToken cancellationToken);
    public static Task`1<Solution> BulkConfigureSeverityAsync(string editorConfigSeverity, Project project, CancellationToken cancellationToken);
    private static Task`1<Solution> BulkConfigureSeverityCoreAsync(string editorConfigSeverity, string category, Project project, CancellationToken cancellationToken);
    public static Task`1<Solution> ConfigureCodeStyleOptionAsync(string optionName, string optionValue, Diagnostic diagnostic, bool isPerLanguage, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater/<ConfigureCodeStyleOptionsAsync>d__25")]
private static Task`1<Solution> ConfigureCodeStyleOptionsAsync(IEnumerable`1<ValueTuple`3<string, string, bool>> codeStyleOptionValues, string editorConfigSeverity, Diagnostic diagnostic, Project project, ConfigurationKind configurationKind, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigurationUpdater/<ConfigureAsync>d__26")]
private Task`1<Solution> ConfigureAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private AnalyzerConfigDocument FindOrGenerateEditorConfig();
    private static AnalyzerConfigDocument GetOrCreateAnalyzerConfigDocument(Project project, string analyzerConfigPath);
    private static ImmutableArray`1<ValueTuple`3<string, string, bool>> GetCodeStyleOptionValuesForDiagnostic(Diagnostic diagnostic, Project project);
    internal static bool TryGetEditorConfigStringParts(string editorConfigString, ValueTuple`2& parts);
    internal static ImmutableArray`1<IOption2> GetCodeStyleOptionsForDiagnostic(Diagnostic diagnostic, Project project);
    private SourceText GetNewAnalyzerConfigDocumentText(SourceText originalText, AnalyzerConfigDocument editorConfigDocument);
    private ValueTuple`3<SourceText, Nullable`1<TextLine>, Nullable`1<TextLine>> CheckIfRuleExistsAndReplaceInFile(SourceText result, AnalyzerConfigDocument editorConfigDocument);
    private SourceText AddMissingRule(SourceText result, Nullable`1<TextLine> lastValidHeaderSpanEnd, Nullable`1<TextLine> lastValidSpecificHeaderSpanEnd);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportConfigurationFixProviderAttribute("ConfigureCodeStyleOption", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigureCodeStyle.ConfigureCodeStyleOptionCodeFixProvider : object {
    [NullableAttribute("0")]
private static ImmutableArray`1<bool> s_boolValues;
    private static ConfigureCodeStyleOptionCodeFixProvider();
    public sealed virtual bool IsFixableDiagnostic(Diagnostic diagnostic);
    [NullableContextAttribute("2")]
public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(TextDocument document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ImmutableArray`1<CodeFix> GetConfigurations(Project project, IEnumerable`1<Diagnostic> diagnostics);
}
[ExportConfigurationFixProviderAttribute("ConfigureSeverity", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.Configuration.ConfigureSeverity.ConfigureSeverityLevelCodeFixProvider : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, string>> s_editorConfigSeverityStrings;
    private static ConfigureSeverityLevelCodeFixProvider();
    [NullableContextAttribute("1")]
public sealed virtual bool IsFixableDiagnostic(Diagnostic diagnostic);
    [NullableContextAttribute("2")]
public sealed virtual FixAllProvider GetFixAllProvider();
    [NullableContextAttribute("1")]
public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(TextDocument document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static ImmutableArray`1<CodeFix> GetConfigurations(Project project, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeFixes.DiagnosticExtensions : object {
    [ExtensionAttribute]
public static bool IsMoreSevereThanOrEqualTo(DiagnosticSeverity left, DiagnosticSeverity right);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.CodeFixes.ExportConfigurationFixProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public string Name { get; }
    public String[] Languages { get; }
    public ExportConfigurationFixProviderAttribute(string name, String[] languages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
internal class Microsoft.CodeAnalysis.CodeFixes.FixMultipleCodeAction : AbstractFixAllCodeFixCodeAction {
    private string _title;
    private string _computingFixWaitDialogMessage;
    public string Title { get; }
    internal string Message { get; }
    public FixMultipleCodeAction(IFixAllState fixAllState, string title, string computingFixWaitDialogMessage);
    public virtual string get_Title();
    internal virtual string get_Message();
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider : CodeFixProvider {
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyCodeFixProvider/<RegisterCodeFixesAsync>d__1")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyService`1 : object {
    private static int MaxResults;
    private static int NamespaceWithNoErrorsWeight;
    private static int TypeWeight;
    private static int NamespaceWithErrorsWeight;
    protected abstract virtual bool CanFullyQualify(SyntaxNode node, TSimpleNameSyntax& simpleName);
    protected abstract virtual Task`1<SyntaxNode> ReplaceNodeAsync(TSimpleNameSyntax simpleName, string containerName, bool resultingSymbolIsType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyService`1/<GetFixDataAsync>d__6")]
public sealed virtual Task`1<Nullable`1<FullyQualifyFixData>> GetFixDataAsync(Document document, TextSpan span, bool hideAdvancedMembers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyService`1/<GetFixDataInCurrentProcessAsync>d__7")]
private Task`1<Nullable`1<FullyQualifyFixData>> GetFixDataInCurrentProcessAsync(Document document, TextSpan span, bool hideAdvancedMembers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyService`1/<AddFixesAsync>d__8")]
private Task AddFixesAsync(Document document, SemanticModel semanticModel, TSimpleNameSyntax simpleName, string name, ImmutableArray`1<SymbolResult<TSimpleNameSyntax>> proposedContainers, ArrayBuilder`1<FullyQualifyIndividualFixData> fixes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyService`1/<ProcessNodeAsync>d__9")]
private Task`1<IEnumerable`1<TextChange>> ProcessNodeAsync(Document document, TSimpleNameSyntax simpleName, string containerName, INamespaceOrTypeSymbol originalSymbol, CancellationToken cancellationToken);
    private static bool IsValidNamedTypeSearchResult(SemanticModel semanticModel, int arity, bool inAttributeContext, bool looksGeneric, INamedTypeSymbol searchResult);
    private static bool HasValidContainer(ISymbol symbol);
    private bool BindsWithoutErrors(INamespaceSymbol ns, string rightName, bool isAttributeName);
    private static bool HasAccessibleTypes(INamespaceSymbol namespace, SemanticModel model, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.AbstractFullyQualifyService`1/<GetContainers>d__14")]
private static IEnumerable`1<SymbolResult<TSimpleNameSyntax>> GetContainers(ImmutableArray`1<SymbolResult<TSimpleNameSyntax>> symbols, Compilation compilation);
    private static IEnumerable`1<SymbolResult<TSimpleNameSyntax>> FilterAndSort(IEnumerable`1<SymbolResult<TSimpleNameSyntax>> symbols);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.FullyQualify.FullyQualifyFixData : ValueType {
    [NullableAttribute("1")]
[DataMemberAttribute]
public string Name;
    [DataMemberAttribute]
public ImmutableArray`1<FullyQualifyIndividualFixData> IndividualFixData;
    public FullyQualifyFixData(string name, ImmutableArray`1<FullyQualifyIndividualFixData> individualFixData);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.FullyQualify.FullyQualifyIndividualFixData : ValueType {
    [NullableAttribute("1")]
[DataMemberAttribute]
public string Title;
    [DataMemberAttribute]
public ImmutableArray`1<TextChange> TextChanges;
    public FullyQualifyIndividualFixData(string title, ImmutableArray`1<TextChange> textChanges);
}
internal interface Microsoft.CodeAnalysis.CodeFixes.FullyQualify.IFullyQualifyService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Nullable`1<FullyQualifyFixData>> GetFixDataAsync(Document document, TextSpan span, bool hideAdvancedMembers, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeFixes.FullyQualify.IRemoteFullyQualifyService {
    public abstract virtual ValueTask`1<Nullable`1<FullyQualifyFixData>> GetFixDataAsync(Checksum solutionChecksum, DocumentId documentId, TextSpan span, bool hideAdvancedMembers, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.GenerateMember.AbstractGenerateMemberCodeFixProvider : CodeFixProvider {
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.GenerateMember.AbstractGenerateMemberCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.GenerateMember.AbstractGenerateMemberCodeFixProvider/<GetTargetNodes>d__5")]
private IEnumerable`1<SyntaxNode> GetTargetNodes(ISyntaxFactsService syntaxFacts, SyntaxNode root, TextSpan span, Diagnostic diagnostic);
}
internal interface Microsoft.CodeAnalysis.CodeFixes.ICodeFixProviderFactory {
    public abstract virtual ImmutableArray`1<CodeFixProvider> GetFixers();
}
internal interface Microsoft.CodeAnalysis.CodeFixes.IFixMultipleOccurrencesService {
    public abstract virtual Solution GetFix(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> diagnosticsToFix, Workspace workspace, CodeFixProvider fixProvider, FixAllProvider fixAllProvider, CodeActionOptionsProvider optionsProvider, string equivalenceKey, string waitDialogTitle, string waitDialogMessage, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    public abstract virtual Solution GetFix(ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> diagnosticsToFix, Workspace workspace, CodeFixProvider fixProvider, FixAllProvider fixAllProvider, CodeActionOptionsProvider optionsProvider, string equivalenceKey, string waitDialogTitle, string waitDialogMessage, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Iterator.AbstractIteratorCodeFixProvider : CodeFixProvider {
    public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Iterator.AbstractIteratorCodeFixProvider/<RegisterCodeFixesAsync>d__2")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.MatchFolderAndNamespace.AbstractChangeNamespaceToMatchFolderCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.MatchFolderAndNamespace.AbstractChangeNamespaceToMatchFolderCodeFixProvider/<FixAllInDocumentAsync>d__3")]
private static Task`1<Solution> FixAllInDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.NamingStyles.NamingStyleCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Solution> FixAsync(Document document, ISymbol symbol, string fixedName, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixes.PredefinedCodeFixProviderNames : object {
    public static string AddAccessibilityModifiers;
    public static string AddAnonymousTypeMemberName;
    public static string AddAsync;
    public static string AddBraces;
    public static string AddDocCommentNodes;
    public static string AddExplicitCast;
    public static string AddImport;
    public static string AddInheritdoc;
    public static string AddMissingReference;
    public static string AddNew;
    public static string AddObsoleteAttribute;
    public static string AddOverloads;
    public static string AddPackage;
    public static string AddParameter;
    public static string AddParenthesesAroundConditionalExpressionInInterpolatedString;
    public static string AddRequiredParentheses;
    public static string AliasAmbiguousType;
    public static string ApplyNamingStyle;
    public static string ArrowExpressionClausePlacement;
    public static string AssignOutParametersAboveReturn;
    public static string AssignOutParametersAtStart;
    public static string ChangeNamespaceToMatchFolder;
    public static string ChangeReturnType;
    public static string ChangeToYield;
    public static string ConditionalExpressionPlacement;
    public static string ConflictMarkerResolution;
    public static string ConsecutiveBracePlacement;
    public static string ConsecutiveStatementPlacement;
    public static string ConstructorInitializerPlacement;
    public static string ConvertNamespace;
    public static string ConvertSwitchStatementToExpression;
    public static string ConvertToAsync;
    public static string ConvertToIterator;
    public static string ConvertToProgramMain;
    public static string ConvertToRecord;
    public static string ConvertToTopLevelStatements;
    public static string ConvertTypeOfToNameOf;
    public static string CopilotSuggestions;
    public static string CorrectNextControlVariable;
    public static string DeclareAsNullable;
    public static string DisambiguateSameVariable;
    public static string EmbeddedStatementPlacement;
    public static string FileHeader;
    public static string FixFormatting;
    public static string FixIncorrectConstraint;
    public static string FixIncorrectExitContinue;
    public static string FixIncorrectFunctionReturnType;
    public static string FixReturnType;
    public static string ForEachCast;
    public static string FullyQualify;
    public static string GenerateConstructor;
    public static string GenerateConversion;
    public static string GenerateDeconstructMethod;
    public static string GenerateDefaultConstructors;
    public static string GenerateEndConstruct;
    public static string GenerateEnumMember;
    public static string GenerateEvent;
    public static string GenerateMethod;
    public static string GenerateType;
    public static string GenerateVariable;
    public static string ImplementAbstractClass;
    public static string ImplementInterface;
    public static string InlineDeclaration;
    public static string InvokeDelegateWithConditionalAccess;
    public static string JsonDetection;
    public static string MakeFieldReadonly;
    public static string MakeLocalFunctionStatic;
    public static string MakeAnonymousFunctionStatic;
    public static string MakeMemberRequired;
    public static string MakeMemberStatic;
    public static string MakeMethodSynchronous;
    public static string MakeRefStruct;
    public static string MakeStatementAsynchronous;
    public static string MakeStructFieldsWritable;
    public static string MakeStructMemberReadOnly;
    public static string MakeStructReadOnly;
    public static string MakeTypeAbstract;
    public static string MakeTypePartial;
    public static string MoveMisplacedUsingDirectives;
    public static string MoveToTopOfFile;
    public static string OrderModifiers;
    public static string PassInCapturedVariables;
    public static string PopulateSwitch;
    public static string PopulateSwitchExpression;
    public static string PreferFrameworkType;
    public static string QualifyMemberAccess;
    public static string RemoveAsyncModifier;
    public static string RemoveBlankLines;
    public static string RemoveConfusingSuppression;
    public static string RemoveDocCommentNode;
    public static string RemoveIn;
    public static string RemoveNew;
    public static string RemoveRedundantEquality;
    public static string RemoveSharedFromModuleMembers;
    public static string RemoveUnnecessaryAttributeSuppressions;
    public static string RemoveUnnecessaryByVal;
    public static string RemoveUnnecessaryCast;
    public static string RemoveUnnecessaryDiscardDesignation;
    public static string RemoveUnnecessaryImports;
    public static string RemoveUnnecessaryLambdaExpression;
    public static string RemoveUnnecessaryNullableDirective;
    public static string RemoveUnnecessaryParentheses;
    public static string RemoveUnnecessaryPragmaSuppressions;
    public static string RemoveUnreachableCode;
    public static string RemoveUnusedLocalFunction;
    public static string RemoveUnusedMembers;
    public static string RemoveUnusedValues;
    public static string RemoveUnusedVariable;
    public static string ReplaceDefaultLiteral;
    public static string SimplifyConditionalExpression;
    public static string SimplifyInterpolation;
    public static string SimplifyLinqExpression;
    public static string SimplifyNames;
    public static string SimplifyObjectCreation;
    public static string SimplifyPropertyPattern;
    public static string SimplifyThisOrMe;
    public static string SpellCheck;
    public static string TransposeRecordKeyword;
    public static string UnsealClass;
    public static string UpdateLegacySuppressions;
    public static string UpdateProjectToAllowUnsafe;
    public static string UpgradeProject;
    public static string UseAutoProperty;
    public static string UseCoalesceExpressionForIfNullStatementCheck;
    public static string UseCoalesceExpressionForNullableTernaryConditionalCheck;
    public static string UseCoalesceExpressionForTernaryConditionalCheck;
    public static string UseCollectionExpressionForArray;
    public static string UseCollectionExpressionForBuilder;
    public static string UseCollectionExpressionForCreate;
    public static string UseCollectionExpressionForEmpty;
    public static string UseCollectionExpressionForFluent;
    public static string UseCollectionExpressionForStackAlloc;
    public static string UseCollectionInitializer;
    public static string UseCompoundAssignment;
    public static string UseCompoundCoalesceAssignment;
    public static string UseConditionalExpressionForAssignment;
    public static string UseConditionalExpressionForReturn;
    public static string UseDeconstruction;
    public static string UseDefaultLiteral;
    public static string UseExplicitTupleName;
    public static string UseExplicitType;
    public static string UseExplicitTypeForConst;
    public static string UseExpressionBody;
    public static string UseExpressionBodyForLambda;
    public static string UseImplicitObjectCreation;
    public static string UseImplicitType;
    public static string UseIndexOperator;
    public static string UseInferredMemberName;
    public static string UseInterpolatedVerbatimString;
    public static string UseIsNotExpression;
    public static string UseIsNullCheck;
    public static string UseIsNullCheckForCastAndEqualityOperator;
    public static string UseIsNullCheckForReferenceEquals;
    public static string UseLocalFunction;
    public static string UseNameofInAttribute;
    public static string UseNotPattern;
    public static string UseNullCheckOverTypeCheck;
    public static string UseNullPropagation;
    public static string UseObjectInitializer;
    public static string UsePatternCombinators;
    public static string UsePatternMatchingAsAndMemberAccess;
    public static string UsePatternMatchingAsAndNullCheck;
    public static string UsePatternMatchingIsAndCastCheck;
    public static string UsePatternMatchingIsAndCastCheckWithoutName;
    public static string UsePrimaryConstructor;
    public static string UseRangeOperator;
    public static string UseSimpleUsingStatement;
    public static string UseSystemHashCode;
    public static string UseThrowExpression;
    public static string UseTupleSwap;
    public static string UseUtf8StringLiteral;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixes.PredefinedConfigurationFixProviderNames : object {
    public static string ConfigureCodeStyleOption;
    public static string ConfigureSeverity;
    public static string Suppression;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider : FixAllProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> s_getValue;
    private static AbstractSuppressionBatchFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetFixAsync>d__0")]
public virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetFixAsync>d__1")]
private Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap, FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetDiagnosticsAndCodeActionsAsync>d__2")]
private Task`1<ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>>> GetDiagnosticsAndCodeActionsAsync(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap, FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<AddDocumentFixesAsync>d__3")]
protected virtual Task AddDocumentFixesAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, Action`1<ValueTuple`2<Diagnostic, CodeAction>> onItemFound, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetFixAsync>d__4")]
private Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> projectsAndDiagnosticsToFixMap, FixAllContext fixAllContext);
    private static Action`2<CodeAction, ImmutableArray`1<Diagnostic>> GetRegisterCodeFixAction(FixAllState fixAllState, Action`1<ValueTuple`2<Diagnostic, CodeAction>> onItemFound);
    protected virtual Task AddProjectFixesAsync(Project project, ImmutableArray`1<Diagnostic> diagnostics, ConcurrentBag`1<ValueTuple`2<Diagnostic, CodeAction>> fixes, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<TryGetMergedFixAsync>d__7")]
public virtual Task`1<CodeAction> TryGetMergedFixAsync(ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> batchOfFixes, FixAllState fixAllState, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<TryMergeFixesAsync>d__8")]
private static Task`1<Solution> TryMergeFixesAsync(Solution oldSolution, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetDocumentIdToChangedDocumentsAsync>d__9")]
private static Task`1<IReadOnlyDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>>> GetDocumentIdToChangedDocumentsAsync(Solution oldSolution, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetDocumentIdToFinalTextAsync>d__10")]
private static Task`1<ImmutableArray`1<ValueTuple`2<DocumentId, SourceText>>> GetDocumentIdToFinalTextAsync(Solution oldSolution, IReadOnlyDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> documentIdToChangedDocuments, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetFinalDocumentTextAsync>d__11")]
private static Task GetFinalDocumentTextAsync(Solution oldSolution, Dictionary`2<CodeAction, int> codeActionToDiagnosticLocation, ConcurrentDictionary`2<DocumentId, SourceText> documentIdToFinalText, IEnumerable`1<ValueTuple`2<CodeAction, Document>> changedDocuments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionBatchFixAllProvider/<GetChangedDocumentsAsync>d__13")]
private static Task GetChangedDocumentsAsync(Solution oldSolution, ConcurrentDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> documentIdToChangedDocuments, CodeAction codeAction, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider : object {
    public static string SuppressMessageAttributeName;
    private static string s_globalSuppressionsFileName;
    private static string s_suppressionsFileCommentTemplate;
    protected string DefaultFileExtension { get; }
    protected string SingleLineCommentStart { get; }
    protected string GlobalSuppressionsFileHeaderComment { get; }
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual bool IsFixableDiagnostic(Diagnostic diagnostic);
    protected abstract virtual SyntaxTriviaList CreatePragmaDisableDirectiveTrivia(Diagnostic diagnostic, Func`3<SyntaxNode, CancellationToken, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine, CancellationToken cancellationToken);
    protected abstract virtual SyntaxTriviaList CreatePragmaRestoreDirectiveTrivia(Diagnostic diagnostic, Func`3<SyntaxNode, CancellationToken, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode AddGlobalSuppressMessageAttribute(SyntaxNode newRoot, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic, SolutionServices services, SyntaxFormattingOptions options, IAddImportsService addImportsService, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode AddLocalSuppressMessageAttribute(SyntaxNode targetNode, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic);
    protected abstract virtual string get_DefaultFileExtension();
    protected abstract virtual string get_SingleLineCommentStart();
    protected abstract virtual bool IsAttributeListWithAssemblyAttributes(SyntaxNode node);
    protected abstract virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected abstract virtual bool IsEndOfFileToken(SyntaxToken token);
    protected abstract virtual bool IsSingleAttributeInAttributeList(SyntaxNode attribute);
    protected abstract virtual bool IsAnyPragmaDirectiveForId(SyntaxTrivia trivia, string id, Boolean& enableDirective, Boolean& hasMultipleIds);
    protected abstract virtual SyntaxTrivia TogglePragmaDirective(SyntaxTrivia trivia);
    protected string get_GlobalSuppressionsFileHeaderComment();
    protected static string GetOrMapDiagnosticId(Diagnostic diagnostic, Boolean& includeTitle);
    protected abstract virtual SyntaxNode GetContainingStatement(SyntaxToken token);
    protected abstract virtual bool TokenHasTrailingLineContinuationChar(SyntaxToken token);
    protected SyntaxToken GetAdjustedTokenForPragmaDisable(SyntaxToken token, SyntaxNode root, TextLineCollection lines);
    private SyntaxToken GetAdjustedTokenForPragmaRestore(SyntaxToken token, SyntaxNode root, TextLineCollection lines, int indexOfLine);
    public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(TextDocument textDocument, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetPragmaSuppressionsAsync>d__30")]
internal Task`1<ImmutableArray`1<PragmaWarningCodeAction>> GetPragmaSuppressionsAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetSuppressionsAsync>d__31")]
private Task`1<ImmutableArray`1<CodeFix>> GetSuppressionsAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, bool skipSuppressMessage, bool skipUnsuppress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetFixesAsync>d__32")]
public sealed virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetSuppressionsAsync>d__33")]
private Task`1<ImmutableArray`1<CodeFix>> GetSuppressionsAsync(Document documentOpt, Project project, IEnumerable`1<Diagnostic> diagnostics, SuppressionTargetInfo suppressionTargetInfo, CodeActionOptionsProvider fallbackOptions, bool skipSuppressMessage, bool skipUnsuppress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.AbstractSuppressionCodeFixProvider/<GetSuppressionTargetInfoAsync>d__35")]
private Task`1<SuppressionTargetInfo> GetSuppressionTargetInfoAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    internal SyntaxNode GetNodeWithTokens(SyntaxToken startToken, SyntaxToken endToken, SyntaxNode root);
    protected static string GetScopeString(SymbolKind targetSymbolKind);
    protected static string GetTargetString(ISymbol targetSymbol);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.Suppression.NestedSuppressionCodeAction : CodeAction {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    protected string DiagnosticIdForEquivalenceKey { get; }
    public string EquivalenceKey { get; }
    protected NestedSuppressionCodeAction(string title);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    protected abstract virtual string get_DiagnosticIdForEquivalenceKey();
    public virtual string get_EquivalenceKey();
    protected sealed virtual CodeActionPriority ComputePriority();
    public static bool IsEquivalenceKeyForGlobalSuppression(string equivalenceKey);
    public static bool IsEquivalenceKeyForPragmaWarning(string equivalenceKey);
    public static bool IsEquivalenceKeyForRemoveSuppression(string equivalenceKey);
    public static bool IsEquivalenceKeyForLocalSuppression(string equivalenceKey);
}
internal static class Microsoft.CodeAnalysis.CodeFixes.Suppression.SuppressionHelpers : object {
    private static string SynthesizedExternalSourceDiagnosticTag;
    public static ImmutableArray`1<string> SynthesizedExternalSourceDiagnosticCustomTags;
    private static SuppressionHelpers();
    public static bool CanBeSuppressed(Diagnostic diagnostic);
    public static bool CanBeSuppressedWithAttribute(Diagnostic diagnostic);
    public static bool CanBeUnsuppressed(Diagnostic diagnostic);
    private static bool CanBeSuppressedOrUnsuppressed(Diagnostic diagnostic, bool checkCanBeSuppressed);
    public static bool IsNotConfigurableDiagnostic(DiagnosticData diagnostic);
    public static bool IsNotConfigurableDiagnostic(Diagnostic diagnostic);
    public static bool IsCompilerDiagnostic(DiagnosticData diagnostic);
    public static bool IsCompilerDiagnostic(Diagnostic diagnostic);
    public static bool IsSynthesizedExternalSourceDiagnostic(DiagnosticData diagnostic);
    public static bool IsSynthesizedExternalSourceDiagnostic(Diagnostic diagnostic);
    public static bool HasCustomTag(ImmutableArray`1<string> customTags, string tagToFind);
}
internal class Microsoft.CodeAnalysis.CodeFixes.Suppression.TopLevelSuppressionCodeAction : AbstractConfigurationActionWithNestedActions {
    public TopLevelSuppressionCodeAction(Diagnostic diagnostic, ImmutableArray`1<NestedSuppressionCodeAction> nestedActions);
}
internal class Microsoft.CodeAnalysis.CodeFixes.Suppression.WrapperCodeFixProvider : CodeFixProvider {
    private ImmutableArray`1<string> _originalDiagnosticIds;
    private IConfigurationFixProvider _suppressionFixProvider;
    public IConfigurationFixProvider SuppressionFixProvider { get; }
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public WrapperCodeFixProvider(IConfigurationFixProvider suppressionFixProvider, IEnumerable`1<string> diagnosticIds);
    public IConfigurationFixProvider get_SuppressionFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.Suppression.WrapperCodeFixProvider/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static void RegisterSuppressionFixes(CodeFixContext context, ImmutableArray`1<CodeFix> suppressionFixes);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllCodeAction : CodeAction {
    private bool _showPreviewChangesDialog;
    [CompilerGeneratedAttribute]
private IFixAllState <FixAllState>k__BackingField;
    public IFixAllState FixAllState { get; }
    public string Title { get; }
    internal string Message { get; }
    protected AbstractFixAllCodeAction(IFixAllState fixAllState, bool showPreviewChangesDialog);
    [CompilerGeneratedAttribute]
public IFixAllState get_FixAllState();
    protected abstract virtual bool IsInternalProvider(IFixAllState fixAllState);
    protected abstract virtual IFixAllContext CreateFixAllContext(IFixAllState fixAllState, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    public virtual string get_Title();
    internal virtual string get_Message();
    protected sealed virtual Task`1<ImmutableArray`1<CodeActionOperation>> ComputeOperationsAsync(IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    protected sealed virtual Task`1<Solution> GetChangedSolutionAsync(IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllGetFixesService : object {
    protected abstract virtual Solution GetChangedSolution(Workspace workspace, Solution currentSolution, Solution newSolution, string fixAllPreviewChangesTitle, string fixAllTopLevelHeader, Glyph glyph);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllGetFixesService/<GetFixAllChangedSolutionAsync>d__1")]
public sealed virtual Task`1<Solution> GetFixAllChangedSolutionAsync(IFixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllGetFixesService/<GetFixAllOperationsAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetFixAllOperationsAsync(IFixAllContext fixAllContext, bool showPreviewChangesDialog);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllGetFixesService/<GetFixAllOperationsAsync>d__3")]
protected Task`1<ImmutableArray`1<CodeActionOperation>> GetFixAllOperationsAsync(CodeAction codeAction, bool showPreviewChangesDialog, IProgress`1<CodeAnalysisProgress> progressTracker, IFixAllState fixAllState, CancellationToken cancellationToken);
    public sealed virtual Solution PreviewChanges(Workspace workspace, Solution currentSolution, Solution newSolution, FixAllKind fixAllKind, string previewChangesTitle, string topLevelHeader, string language, Nullable`1<int> correlationId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllGetFixesService/<GetFixAllCodeActionAsync>d__5")]
private static Task`1<CodeAction> GetFixAllCodeActionAsync(IFixAllContext fixAllContext);
    protected static ImmutableArray`1<CodeActionOperation> GetNewFixAllOperations(ImmutableArray`1<CodeActionOperation> operations, Solution newSolution, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllGetFixesService {
    public abstract virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetFixAllOperationsAsync(IFixAllContext fixAllContext, bool showPreviewChangesDialog);
    public abstract virtual Task`1<Solution> GetFixAllChangedSolutionAsync(IFixAllContext fixAllContext);
    public abstract virtual Solution PreviewChanges(Workspace workspace, Solution currentSolution, Solution newSolution, FixAllKind fixAllKind, string previewChangesTitle, string topLevelHeader, string language, Nullable`1<int> correlationId, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CodeFixesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Add_file_header { get; }
    internal static string Fix_name_violation_colon_0 { get; }
    internal static string Add_both { get; }
    internal static string Add_default_case { get; }
    internal static string Use_discarded_local { get; }
    internal static string Use_discard_underscore { get; }
    internal static string Remove_redundant_assignment { get; }
    internal static string Update_suppression_format { get; }
    internal static string Suppress_or_configure_issues { get; }
    internal static string Fix_all_occurrences_in { get; }
    internal static string Remove_extra_blank_lines { get; }
    internal static string Add_blank_line_after_block { get; }
    internal static string Make_class_abstract { get; }
    internal static string Make_member_static { get; }
    internal static string Add_explicit_cast { get; }
    internal static string Alias_ambiguous_type_0 { get; }
    internal static string Convert_type_to_0 { get; }
    internal static string Make_type_partial { get; }
    internal static string Add_member_name { get; }
    internal static string Add_parameter_to_0 { get; }
    internal static string Add_parameter_to_0_and_overrides_implementations { get; }
    internal static string Add_to_0 { get; }
    internal static string Related_method_signatures_found_in_metadata_will_not_be_updated { get; }
    internal static string Remove_async_modifier { get; }
    internal static string Take_0 { get; }
    internal static string Take_both { get; }
    internal static string Take_bottom { get; }
    internal static string Take_top { get; }
    internal static string Add_missing_param_nodes { get; }
    internal static string Remove_tag { get; }
    internal static string Make_method_synchronous { get; }
    internal static string _0_may_change_semantics { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Add_file_header();
    internal static string get_Fix_name_violation_colon_0();
    internal static string get_Add_both();
    internal static string get_Add_default_case();
    internal static string get_Use_discarded_local();
    internal static string get_Use_discard_underscore();
    internal static string get_Remove_redundant_assignment();
    internal static string get_Update_suppression_format();
    internal static string get_Suppress_or_configure_issues();
    internal static string get_Fix_all_occurrences_in();
    internal static string get_Remove_extra_blank_lines();
    internal static string get_Add_blank_line_after_block();
    internal static string get_Make_class_abstract();
    internal static string get_Make_member_static();
    internal static string get_Add_explicit_cast();
    internal static string get_Alias_ambiguous_type_0();
    internal static string get_Convert_type_to_0();
    internal static string get_Make_type_partial();
    internal static string get_Add_member_name();
    internal static string get_Add_parameter_to_0();
    internal static string get_Add_parameter_to_0_and_overrides_implementations();
    internal static string get_Add_to_0();
    internal static string get_Related_method_signatures_found_in_metadata_will_not_be_updated();
    internal static string get_Remove_async_modifier();
    internal static string get_Take_0();
    internal static string get_Take_both();
    internal static string get_Take_bottom();
    internal static string get_Take_top();
    internal static string get_Add_missing_param_nodes();
    internal static string get_Remove_tag();
    internal static string get_Make_method_synchronous();
    internal static string get__0_may_change_semantics();
}
internal class Microsoft.CodeAnalysis.CodeLens.CodeLensFindReferencesProgress : object {
    private CancellationTokenSource _aggregateCancellationTokenSource;
    private SyntaxNode _queriedNode;
    private ISymbol _queriedSymbol;
    private ConcurrentSet`1<Location> _locations;
    [CompilerGeneratedAttribute]
private int <SearchCap>k__BackingField;
    public int SearchCap { get; }
    public CancellationToken CancellationToken { get; }
    public bool SearchCapReached { get; }
    public int ReferencesCount { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public CodeLensFindReferencesProgress(ISymbol queriedDefinition, SyntaxNode queriedNode, int searchCap, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public int get_SearchCap();
    public CancellationToken get_CancellationToken();
    public bool get_SearchCapReached();
    public int get_ReferencesCount();
    public ImmutableArray`1<Location> get_Locations();
    public sealed virtual void OnStarted();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnFindInDocumentStarted(Document document);
    public sealed virtual void OnFindInDocumentCompleted(Document document);
    private static bool FilterDefinition(ISymbol definition);
    private IEnumerable`1<Location> GetPartialLocations(ISymbol symbol, CancellationToken cancellationToken);
    public sealed virtual void OnDefinitionFound(ISymbol symbol);
    private bool FilterReference(ISymbol definition, ReferenceLocation reference);
    public sealed virtual void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    public sealed virtual void ReportProgress(int current, int maximum);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeLens.CodeLensMember : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    public SyntaxNode Node { get; public set; }
    public TextSpan Span { get; public set; }
    public CodeLensMember(SyntaxNode Node, TextSpan Span);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(SyntaxNode value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public void set_Span(TextSpan value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CodeLensMember left, CodeLensMember right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CodeLensMember left, CodeLensMember right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeLensMember other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(SyntaxNode& Node, TextSpan& Span);
}
internal class Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService : object {
    private static SymbolDisplayFormat MethodDisplayFormat;
    private static FindReferencesSearchOptions s_nonParallelSearch;
    private static CodeLensReferencesService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<FindAsync>d__2`1")]
private static Task`1<Nullable`1<T>> FindAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, Func`2<CodeLensFindReferencesProgress, Task`1<T>> onResults, Func`2<CodeLensFindReferencesProgress, Task`1<T>> onCapped, int searchCap, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<GetProjectCodeLensVersionAsync>d__3")]
public sealed virtual ValueTask`1<VersionStamp> GetProjectCodeLensVersionAsync(Solution solution, ProjectId projectId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<GetReferenceCountAsync>d__4")]
public sealed virtual Task`1<Nullable`1<ReferenceCount>> GetReferenceCountAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, int maxSearchResults, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<GetDescriptorOfEnclosingSymbolAsync>d__5")]
private static Task`1<ReferenceLocationDescriptor> GetDescriptorOfEnclosingSymbolAsync(Solution solution, Location location, CancellationToken cancellationToken);
    private static SyntaxNode GetEnclosingCodeElementNode(Document document, SyntaxToken token, ICodeLensDisplayInfoService langServices, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<FindReferenceLocationsAsync>d__7")]
public sealed virtual Task`1<Nullable`1<ImmutableArray`1<ReferenceLocationDescriptor>>> FindReferenceLocationsAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    private static ISymbol GetEnclosingMethod(SemanticModel semanticModel, Location location, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<TryGetMethodDescriptorAsync>d__9")]
private static Task`1<ReferenceMethodDescriptor> TryGetMethodDescriptorAsync(Location commonLocation, Solution solution, CancellationToken cancellationToken);
    public sealed virtual Task`1<Nullable`1<ImmutableArray`1<ReferenceMethodDescriptor>>> FindReferenceMethodsAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesService/<GetFullyQualifiedNameAsync>d__11")]
public sealed virtual Task`1<string> GetFullyQualifiedNameAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeLens.CodeLensReferencesServiceFactory : object {
    public static ICodeLensReferencesService Instance;
    private static CodeLensReferencesServiceFactory();
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal interface Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService {
    public abstract virtual SyntaxNode GetDisplayNode(SyntaxNode node);
    public abstract virtual string GetDisplayName(SemanticModel semanticModel, SyntaxNode node);
}
internal interface Microsoft.CodeAnalysis.CodeLens.ICodeLensMemberFinder {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<CodeLensMember>> GetCodeLensMembersAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeLens.ICodeLensReferencesService {
    public abstract virtual ValueTask`1<VersionStamp> GetProjectCodeLensVersionAsync(Solution solution, ProjectId projectId, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ReferenceCount>> GetReferenceCountAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, int maxSearchResults, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ImmutableArray`1<ReferenceLocationDescriptor>>> FindReferenceLocationsAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ImmutableArray`1<ReferenceMethodDescriptor>>> FindReferenceMethodsAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetFullyQualifiedNameAsync(Solution solution, DocumentId documentId, SyntaxNode syntaxNode, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeLens.IRemoteCodeLensReferencesService {
    public abstract virtual ValueTask`1<Nullable`1<ReferenceCount>> GetReferenceCountAsync(Checksum solutionChecksum, DocumentId documentId, TextSpan textSpan, int maxResultCount, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Nullable`1<ImmutableArray`1<ReferenceLocationDescriptor>>> FindReferenceLocationsAsync(Checksum solutionChecksum, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Nullable`1<ImmutableArray`1<ReferenceMethodDescriptor>>> FindReferenceMethodsAsync(Checksum solutionChecksum, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<string> GetFullyQualifiedNameAsync(Checksum solutionChecksum, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeLens.LocationComparer : object {
    [CompilerGeneratedAttribute]
private static LocationComparer <Instance>k__BackingField;
    public static LocationComparer Instance { get; }
    private static LocationComparer();
    [CompilerGeneratedAttribute]
public static LocationComparer get_Instance();
    public sealed virtual bool Equals(Location x, Location y);
    public sealed virtual int GetHashCode(Location obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeLens.ReferenceCount : ValueType {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCapped>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [DataMemberAttribute]
public int Count { get; public set; }
    [DataMemberAttribute]
public bool IsCapped { get; public set; }
    [DataMemberAttribute]
public string Version { get; public set; }
    public ReferenceCount(int Count, bool IsCapped, string Version);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Count(int value);
    [CompilerGeneratedAttribute]
public bool get_IsCapped();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsCapped(bool value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Version(string value);
    public string GetDescription();
    public string GetToolTip(string codeElementKind);
    private string GetCappedReferenceCountString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ReferenceCount left, ReferenceCount right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ReferenceCount left, ReferenceCount right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReferenceCount other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Count, Boolean& IsCapped, String& Version);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeLens.ReferenceLocationDescriptor : object {
    [CompilerGeneratedAttribute]
private string <LongDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Glyph> <Glyph>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpanStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SpanLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ProjectGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <DocumentGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReferenceLineText>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeReferenceText1>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BeforeReferenceText2>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterReferenceText1>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AfterReferenceText2>k__BackingField;
    [DataMemberAttribute]
public string LongDescription { get; }
    [DataMemberAttribute]
public string Language { get; }
    [DataMemberAttribute]
public Nullable`1<Glyph> Glyph { get; }
    [DataMemberAttribute]
public int SpanStart { get; }
    [DataMemberAttribute]
public int SpanLength { get; }
    [DataMemberAttribute]
public int LineNumber { get; }
    [DataMemberAttribute]
public int ColumnNumber { get; }
    [DataMemberAttribute]
public Guid ProjectGuid { get; }
    [DataMemberAttribute]
public Guid DocumentGuid { get; }
    [DataMemberAttribute]
public string FilePath { get; }
    [DataMemberAttribute]
public string ReferenceLineText { get; }
    [DataMemberAttribute]
public int ReferenceStart { get; }
    [DataMemberAttribute]
public int ReferenceLength { get; }
    [DataMemberAttribute]
public string BeforeReferenceText1 { get; }
    [DataMemberAttribute]
public string BeforeReferenceText2 { get; }
    [DataMemberAttribute]
public string AfterReferenceText1 { get; }
    [DataMemberAttribute]
public string AfterReferenceText2 { get; }
    public ReferenceLocationDescriptor(string longDescription, string language, Nullable`1<Glyph> glyph, int spanStart, int spanLength, int lineNumber, int columnNumber, Guid projectGuid, Guid documentGuid, string filePath, string referenceLineText, int referenceStart, int referenceLength, string beforeReferenceText1, string beforeReferenceText2, string afterReferenceText1, string afterReferenceText2);
    [CompilerGeneratedAttribute]
public string get_LongDescription();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public Nullable`1<Glyph> get_Glyph();
    [CompilerGeneratedAttribute]
public int get_SpanStart();
    [CompilerGeneratedAttribute]
public int get_SpanLength();
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public Guid get_ProjectGuid();
    [CompilerGeneratedAttribute]
public Guid get_DocumentGuid();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_ReferenceLineText();
    [CompilerGeneratedAttribute]
public int get_ReferenceStart();
    [CompilerGeneratedAttribute]
public int get_ReferenceLength();
    [CompilerGeneratedAttribute]
public string get_BeforeReferenceText1();
    [CompilerGeneratedAttribute]
public string get_BeforeReferenceText2();
    [CompilerGeneratedAttribute]
public string get_AfterReferenceText1();
    [CompilerGeneratedAttribute]
public string get_AfterReferenceText2();
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeLens.ReferenceMethodDescriptor : object {
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [DataMemberAttribute]
public string FullName { get; private set; }
    [DataMemberAttribute]
public string FilePath { get; private set; }
    [DataMemberAttribute]
public string OutputFilePath { get; private set; }
    public ReferenceMethodDescriptor(string fullName, string filePath, string outputFilePath);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
private void set_FullName(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
private void set_OutputFilePath(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeQuality.AbstractCodeQualityDiagnosticAnalyzer : DiagnosticAnalyzer {
    private GeneratedCodeAnalysisFlags _generatedCodeAnalysisFlags;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public bool IsHighPriority { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected AbstractCodeQualityDiagnosticAnalyzer(ImmutableArray`1<DiagnosticDescriptor> descriptors, GeneratedCodeAnalysisFlags generatedCodeAnalysisFlags);
    public sealed virtual bool get_IsHighPriority();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    protected abstract virtual void InitializeWorker(AnalysisContext context);
    public abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("2")]
public sealed virtual bool OpenFileOnly(SimplifierOptions options);
    protected static DiagnosticDescriptor CreateDescriptor(string id, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString messageFormat, bool hasAnyCodeStyleOption, bool isUnnecessary, bool isEnabledByDefault, bool isConfigurable, LocalizableString description);
}
internal static class Microsoft.CodeAnalysis.CodeRefactoringHelpers : object {
    [NullableContextAttribute("2")]
public static bool IsNodeUnderselected(SyntaxNode node, TextSpan selection);
    public static TextSpan GetTrimmedTextSpan(ParsedDocument document, TextSpan span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3 : object {
    protected IHeaderFacts HeaderFacts { get; }
    protected abstract virtual IHeaderFacts get_HeaderFacts();
    public abstract virtual bool IsBetweenTypeMembers(SourceText sourceText, SyntaxNode root, int position, SyntaxNode& typeDeclaration);
    private static void AddNode(bool allowEmptyNodes, TemporaryArray`1& result, TSyntaxNode node);
    [NullableContextAttribute("0")]
public sealed virtual void AddRelevantNodes(ParsedDocument document, TextSpan selectionRaw, bool allowEmptyNodes, int maxCount, TemporaryArray`1& result, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static bool IsWantedTypeExpressionLike();
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, SyntaxToken> GetTokensToLeftAndRight(ParsedDocument document, SyntaxNode root, int location);
    private void AddNodesForTokenToLeft(ISyntaxFactsService syntaxFacts, bool allowEmptyNodes, int maxCount, TemporaryArray`1& result, SyntaxToken tokenToLeft, CancellationToken cancellationToken);
    private void AddNodesForTokenToRight(ISyntaxFactsService syntaxFacts, SyntaxNode root, bool allowEmptyNodes, int maxCount, TemporaryArray`1& result, SyntaxToken tokenToRightOrIn, CancellationToken cancellationToken);
    private void AddRelevantNodesForSelection(ISyntaxFactsService syntaxFacts, SyntaxNode root, TextSpan selectionTrimmed, bool allowEmptyNodes, int maxCount, TemporaryArray`1& result, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3/<ExtractNodesSimple>d__10")]
protected virtual IEnumerable`1<SyntaxNode> ExtractNodesSimple(SyntaxNode node, ISyntaxFactsService syntaxFacts);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AbstractRefactoringHelpersService`3/<ExtractNodesInHeader>d__11")]
protected virtual IEnumerable`1<SyntaxNode> ExtractNodesInHeader(SyntaxNode root, int location, IHeaderFactsService headerFacts);
    [NullableContextAttribute("0")]
private static void AddNodesDeepIn(ParsedDocument document, int position, bool allowEmptyNodes, int maxCount, TemporaryArray`1& result, CancellationToken cancellationToken);
    private static void AddNonHiddenCorrectTypeNodes(IEnumerable`1<SyntaxNode> nodes, bool allowEmptyNodes, int maxCount, TemporaryArray`1& result, CancellationToken cancellationToken);
    public sealed virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    public sealed virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    public sealed virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    public sealed virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    public sealed virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    public sealed virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    public sealed virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    public sealed virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    public sealed virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
    [CompilerGeneratedAttribute]
internal static bool <IsWantedTypeExpressionLike>g__IsAEqualOrSubclassOfB|5_0(Type a, Type b);
    [CompilerGeneratedAttribute]
internal static bool <GetTokensToLeftAndRight>g__IsAcceptableLineDistanceAway|6_0(SourceText sourceText, SyntaxToken tokenOnLocation, int location);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.AddAwait.AbstractAddAwaitCodeRefactoringProvider`1 : CodeRefactoringProvider {
    protected abstract virtual string GetTitle();
    protected abstract virtual string GetTitleWithConfigureAwait();
    protected abstract virtual bool IsInAsyncContext(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.AddAwait.AbstractAddAwaitCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__3")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool IsValidAwaitableExpression(SemanticModel model, ISyntaxFactsService syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    private static Task`1<Document> AddAwaitAsync(Document document, TExpressionSyntax expression, bool withConfigureAwait, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoring : object {
    [CompilerGeneratedAttribute]
private CodeRefactoringProvider <Provider>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`2<CodeAction, Nullable`1<TextSpan>>> <CodeActions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FixAllProviderInfo <FixAllProviderInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeActionOptionsProvider <CodeActionOptionsProvider>k__BackingField;
    public CodeRefactoringProvider Provider { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<CodeAction, Nullable`1<TextSpan>>> CodeActions { get; }
    [NullableAttribute("2")]
public FixAllProviderInfo FixAllProviderInfo { get; }
    public CodeActionOptionsProvider CodeActionOptionsProvider { get; }
    public CodeRefactoring(CodeRefactoringProvider provider, ImmutableArray`1<ValueTuple`2<CodeAction, Nullable`1<TextSpan>>> actions, FixAllProviderInfo fixAllProviderInfo, CodeActionOptionsProvider codeActionOptionsProvider);
    [CompilerGeneratedAttribute]
public CodeRefactoringProvider get_Provider();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<CodeAction, Nullable`1<TextSpan>>> get_CodeActions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FixAllProviderInfo get_FixAllProviderInfo();
    [CompilerGeneratedAttribute]
public CodeActionOptionsProvider get_CodeActionOptionsProvider();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContextExtensions : object {
    [ExtensionAttribute]
public static void RegisterRefactorings(CodeRefactoringContext context, ImmutableArray`1<TCodeAction> actions, Nullable`1<TextSpan> applicableToSpan);
    [ExtensionAttribute]
public static Task`1<TSyntaxNode> TryGetRelevantNodeAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContextExtensions/<TryGetRelevantNodeAsync>d__2`1")]
[ExtensionAttribute]
public static Task`1<TSyntaxNode> TryGetRelevantNodeAsync(CodeRefactoringContext context, bool allowEmptyNode);
    [ExtensionAttribute]
public static Task`1<ImmutableArray`1<TSyntaxNode>> GetRelevantNodesAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContextExtensions/<GetRelevantNodesAsync>d__4`1")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<TSyntaxNode>> GetRelevantNodesAsync(CodeRefactoringContext context, bool allowEmptyNodes);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContextExtensions/<TryGetRelevantNodeAsync>d__5`1")]
[ExtensionAttribute]
public static Task`1<TSyntaxNode> TryGetRelevantNodeAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TSyntaxNode TryGetRelevantNode(ParsedDocument document, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TSyntaxNode TryGetRelevantNode(ParsedDocument document, TextSpan span, bool allowEmptyNode, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<TSyntaxNode>> GetRelevantNodesAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContextExtensions/<GetRelevantNodesAsync>d__9`1")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<TSyntaxNode>> GetRelevantNodesAsync(Document document, TextSpan span, bool allowEmptyNodes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TSyntaxNode> GetRelevantNodes(ParsedDocument document, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TSyntaxNode> GetRelevantNodes(ParsedDocument document, TextSpan span, bool allowEmptyNodes, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static void AddRelevantNodes(ParsedDocument document, TextSpan span, bool allowEmptyNodes, int maxCount, TemporaryArray`1& result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableDictionary`2<string, Lazy`1<ImmutableArray`1<CodeRefactoringProvider>>>> _lazyLanguageToProvidersMap;
    private Lazy`1<ImmutableDictionary`2<CodeRefactoringProvider, CodeChangeProviderMetadata>> _lazyRefactoringToMetadataMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<CodeRefactoringProvider, FixAllProviderInfo> _fixAllProviderMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, Lazy`1<ImmutableArray`1<CodeRefactoringProvider>>> LanguageToProvidersMap { get; }
    private ImmutableDictionary`2<CodeRefactoringProvider, CodeChangeProviderMetadata> RefactoringToMetadataMap { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CodeRefactoringService(IEnumerable`1<Lazy`2<CodeRefactoringProvider, CodeChangeProviderMetadata>> providers);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService/<DistributeLanguages>d__4")]
private static IEnumerable`1<Lazy`2<CodeRefactoringProvider, OrderableLanguageMetadata>> DistributeLanguages(IEnumerable`1<Lazy`2<CodeRefactoringProvider, CodeChangeProviderMetadata>> providers);
    private ImmutableDictionary`2<string, Lazy`1<ImmutableArray`1<CodeRefactoringProvider>>> get_LanguageToProvidersMap();
    private ImmutableDictionary`2<CodeRefactoringProvider, CodeChangeProviderMetadata> get_RefactoringToMetadataMap();
    private ConcatImmutableArray`1<CodeRefactoringProvider> GetProviders(TextDocument document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService/<HasRefactoringsAsync>d__10")]
public sealed virtual Task`1<bool> HasRefactoringsAsync(TextDocument document, TextSpan state, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringService/<GetRefactoringsAsync>d__11")]
public sealed virtual Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(TextDocument document, TextSpan state, Nullable`1<CodeActionRequestPriority> priority, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    private Task`1<CodeRefactoring> GetRefactoringFromProviderAsync(TextDocument textDocument, TextSpan state, CodeRefactoringProvider provider, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<CodeRefactoringProvider> <GetProviders>g__GetProjectRefactorings|9_0(TextDocument document);
    [CompilerGeneratedAttribute]
internal static ExtensionInfo<ProjectCodeRefactoringProvider, CodeRefactoringProvider, ExportCodeRefactoringProviderAttribute> <GetProviders>g__GetExtensionInfo|9_1(ExportCodeRefactoringProviderAttribute attribute);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<GetCodeActionsAsync>d__2")]
private static Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, TextSpan textSpan, ExtractMethodGenerationOptions extractOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<ExtractMethodAsync>d__3")]
private static Task`1<CodeAction> ExtractMethodAsync(Document document, TextSpan textSpan, ExtractMethodGenerationOptions extractOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<ExtractLocalFunctionAsync>d__4")]
private static Task`1<CodeAction> ExtractLocalFunctionAsync(Document document, TextSpan textSpan, ExtractMethodGenerationOptions extractOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ExtractMethod.ExtractMethodCodeRefactoringProvider/<AddRenameAnnotationAsync>d__5")]
private static Task`1<Document> AddRenameAnnotationAsync(Document document, Nullable`1<SyntaxToken> invocationNameToken, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeRefactorings.FixAllCodeRefactoringCodeAction : AbstractFixAllCodeAction {
    public FixAllCodeRefactoringCodeAction(IFixAllState fixAllState);
    protected virtual IFixAllContext CreateFixAllContext(IFixAllState fixAllState, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    protected virtual bool IsInternalProvider(IFixAllState fixAllState);
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringHelpersService {
    public bool ActiveInlineRenameSession { get; }
    public abstract virtual bool get_ActiveInlineRenameSession();
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringProviderFactory {
    public abstract virtual ImmutableArray`1<CodeRefactoringProvider> GetRefactorings();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringService {
    public abstract virtual Task`1<bool> HasRefactoringsAsync(TextDocument document, TextSpan textSpan, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(TextDocument document, TextSpan textSpan, Nullable`1<CodeActionRequestPriority> priority, CodeActionOptionsProvider options, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringServiceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<CodeRefactoring>> GetRefactoringsAsync(ICodeRefactoringService service, TextDocument document, TextSpan state, CodeActionOptionsProvider options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService {
    [NullableContextAttribute("1")]
public abstract virtual bool IsBetweenTypeMembers(SourceText sourceText, SyntaxNode root, int position, SyntaxNode& typeDeclaration);
    public abstract virtual void AddRelevantNodes(ParsedDocument document, TextSpan selection, bool allowEmptyNodes, int maxCount, TemporaryArray`1& result, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService : object {
    public static SyntaxAnnotation NamespaceScopeMovedAnnotation;
    private static AbstractMoveTypeService();
    public abstract virtual Task`1<Solution> GetModifiedSolutionAsync(Document document, TextSpan textSpan, MoveTypeOperationKind operationKind, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringAsync(Document document, TextSpan textSpan, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5 : AbstractMoveTypeService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5/<GetRefactoringAsync>d__0")]
public virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringAsync(Document document, TextSpan textSpan, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5/<GetModifiedSolutionAsync>d__1")]
public virtual Task`1<Solution> GetModifiedSolutionAsync(Document document, TextSpan textSpan, MoveTypeOperationKind operationKind, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual Task`1<TTypeDeclarationSyntax> GetRelevantNodeAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.AbstractMoveTypeService`5/<CreateStateAsync>d__3")]
private Task`1<State<TService, TTypeDeclarationSyntax, TNamespaceDeclarationSyntax, TMemberDeclarationSyntax, TCompilationUnitSyntax>> CreateStateAsync(Document document, TextSpan textSpan, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeAction> CreateActions(State<TService, TTypeDeclarationSyntax, TNamespaceDeclarationSyntax, TMemberDeclarationSyntax, TCompilationUnitSyntax> state, CancellationToken cancellationToken);
    private static bool ClassNextToGlobalStatements(SyntaxNode root, ISyntaxFactsService syntaxFacts);
    private CodeAction GetCodeAction(State<TService, TTypeDeclarationSyntax, TNamespaceDeclarationSyntax, TMemberDeclarationSyntax, TCompilationUnitSyntax> state, string fileName, MoveTypeOperationKind operationKind);
    private static bool IsNestedType(TTypeDeclarationSyntax typeNode);
    private static bool MultipleTopLevelTypeDeclarationInSourceDocument(SyntaxNode root);
    private static IEnumerable`1<TTypeDeclarationSyntax> TopLevelTypeDeclarations(SyntaxNode root);
    private static bool AnyTopLevelTypeMatchesDocumentName(State<TService, TTypeDeclarationSyntax, TNamespaceDeclarationSyntax, TMemberDeclarationSyntax, TCompilationUnitSyntax> state, CancellationToken cancellationToken);
    protected static bool TypeMatchesDocumentName(TTypeDeclarationSyntax typeNode, string typeName, string documentNameWithoutExtension, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<string> GetSuggestedFileNames(TTypeDeclarationSyntax typeNode, bool isNestedType, string typeName, string documentNameWithExtension, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static IEnumerable`1<string> GetTypeNamePartsForNestedTypeNode(TTypeDeclarationSyntax typeNode, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.MoveType.IMoveTypeService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringAsync(Document document, TextSpan textSpan, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Solution> GetModifiedSolutionAsync(Document document, TextSpan textSpan, MoveTypeOperationKind operationKind, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal enum Microsoft.CodeAnalysis.CodeRefactorings.MoveType.MoveTypeOperationKind : Enum {
    public int value__;
    public static MoveTypeOperationKind MoveType;
    public static MoveTypeOperationKind MoveTypeNamespaceScope;
    public static MoveTypeOperationKind RenameType;
    public static MoveTypeOperationKind RenameFile;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeRefactorings.PredefinedCodeRefactoringProviderNames : object {
    public static string AddAwait;
    public static string AddConstructorParametersFromMembers;
    public static string AddDebuggerDisplay;
    public static string AddFileBanner;
    public static string AddMissingImports;
    public static string AddParameterCheck;
    public static string ChangeSignature;
    public static string ConvertAnonymousTypeToClass;
    public static string ConvertAnonymousTypeToTuple;
    public static string ConvertAutoPropertyToFullProperty;
    public static string ConvertBetweenRegularAndVerbatimInterpolatedString;
    public static string ConvertBetweenRegularAndVerbatimString;
    public static string ConvertConcatenationToInterpolatedString;
    public static string ConvertDirectCastToTryCast;
    public static string ConvertForEachToFor;
    public static string ConvertForEachToLinqQuery;
    public static string ConvertForToForEach;
    public static string ConvertIfToSwitch;
    public static string ConvertLinqQueryToForEach;
    public static string ConvertLocalFunctionToMethod;
    public static string ConvertNamespace;
    public static string ConvertNumericLiteral;
    public static string ConvertPlaceholderToInterpolatedString;
    public static string ConvertPrimaryToRegularConstructor;
    public static string ConvertToInterpolatedString;
    public static string ConvertToProgramMain;
    public static string ConvertToRawString;
    public static string ConvertToRecord;
    public static string ConvertToTopLevelStatements;
    public static string ConvertTryCastToDirectCast;
    public static string ConvertTupleToStruct;
    public static string EnableNullable;
    public static string EncapsulateField;
    public static string ExtractClass;
    public static string ExtractInterface;
    public static string ExtractMethod;
    public static string GenerateComparisonOperators;
    public static string GenerateConstructorFromMembers;
    public static string GenerateDefaultConstructors;
    public static string GenerateEqualsAndGetHashCodeFromMembers;
    public static string GenerateOverrides;
    public static string ImplementInterfaceExplicitly;
    public static string ImplementInterfaceImplicitly;
    public static string InitializeMemberFromParameter;
    public static string InitializeMemberFromPrimaryConstructorParameter;
    public static string InlineMethod;
    public static string InlineTemporary;
    public static string IntroduceLocalForExpression;
    public static string IntroduceParameter;
    public static string IntroduceUsingStatement;
    public static string IntroduceVariable;
    public static string InvertConditional;
    public static string InvertIf;
    public static string InvertLogical;
    public static string InvertMultiLineIf;
    public static string MakeLocalFunctionStatic;
    public static string MergeConsecutiveIfStatements;
    public static string MergeNestedIfStatements;
    public static string MoveDeclarationNearReference;
    public static string MoveStaticMembers;
    public static string MoveToNamespace;
    public static string MoveTypeToFile;
    public static string NameTupleElement;
    public static string PullMemberUp;
    public static string RenameTracking;
    public static string ReplaceConditionalWithStatements;
    public static string ReplaceDocCommentTextWithTag;
    public static string ReplaceMethodWithProperty;
    public static string ReplacePropertyWithMethods;
    public static string ReverseForStatement;
    public static string SplitIntoConsecutiveIfStatements;
    public static string SplitIntoNestedIfStatements;
    public static string SyncNamespace;
    public static string UseExplicitType;
    public static string UseExpressionBody;
    public static string UseExpressionBodyForLambda;
    public static string UseImplicitType;
    public static string UseNamedArguments;
    public static string UseRecursivePatterns;
    public static string Wrapping;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.AbstractPullMemberUpRefactoringProvider : CodeRefactoringProvider {
    [NullableAttribute("2")]
private IPullMemberUpOptionsService _service;
    [NullableContextAttribute("2")]
protected AbstractPullMemberUpRefactoringProvider(IPullMemberUpOptionsService service);
    protected abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedNodesAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.AbstractPullMemberUpRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static ImmutableArray`1<INamedTypeSymbol> FindAllValidDestinations(ImmutableArray`1<ISymbol> selectedMembers, INamedTypeSymbol containingType, Solution solution, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.Dialog.IPullMemberUpOptionsService {
    public abstract virtual PullMembersUpOptions GetPullMemberUpOptions(Document document, ImmutableArray`1<ISymbol> selectedNodeSymbols);
}
internal static class Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller : object {
    private static SyntaxAnnotation s_removableImportAnnotation;
    private static SyntaxAnnotation s_destinationNodeAnnotation;
    private static MembersPuller();
    public static CodeAction TryComputeCodeAction(Document document, ImmutableArray`1<ISymbol> selectedMembers, INamedTypeSymbol destination, CleanCodeGenerationOptionsProvider fallbackOptions);
    public static Task`1<Solution> PullMembersUpAsync(Document document, PullMembersUpOptions pullMembersUpOptions, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static IMethodSymbol FilterOutNonPublicAccessor(IMethodSymbol getterOrSetter);
    private static IMethodSymbol MakePublicAccessor(IMethodSymbol getterOrSetter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller/<PullMembersIntoInterfaceAsync>d__6")]
private static Task`1<Solution> PullMembersIntoInterfaceAsync(Document document, PullMembersUpOptions pullMemberUpOptions, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ISymbol GetSymbolsToPullUp(MemberAnalysisResult analysisResult);
    private static void ChangeMemberToPublicAndNonStatic(ICodeGenerationService codeGenerationService, DocumentEditor editor, SyntaxNode memberDeclaration, ISymbol member, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static void ChangeEventToPublicAndNonStatic(ICodeGenerationService codeGenerationService, DocumentEditor editor, IEventSymbol eventSymbol, SyntaxNode eventDeclaration, DeclarationModifiers modifiers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller/<PullMembersIntoClassAsync>d__10")]
private static Task`1<Solution> PullMembersIntoClassAsync(Document document, PullMembersUpOptions result, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SyntaxTriviaList GetLeadingTriviaBeforeFirstMember(SyntaxNode root, ISyntaxFactsService syntaxFacts);
    private static SyntaxNode RemoveLeadingTriviaBeforeFirstMember(SyntaxNode root, ISyntaxFactsService syntaxFacts);
    private static SyntaxNode AddLeadingTriviaBeforeFirstMember(SyntaxNode root, ISyntaxFactsService syntaxFacts, SyntaxTriviaList trivia);
    private static ImmutableArray`1<SyntaxNode> GetImports(SyntaxNode start, ISyntaxFactsService syntaxFacts);
    private static ISymbol MakeAbstractVersion(ISymbol member);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.MembersPuller/<InitializeSymbolToDeclarationsMapAsync>d__16")]
private static Task`1<ImmutableDictionary`2<ISymbol, ImmutableArray`1<SyntaxNode>>> InitializeSymbolToDeclarationsMapAsync(PullMembersUpOptions result, CancellationToken cancellationToken);
    private static bool IsSelectedMemberDeclarationAlreadyInDestination(ISymbol selectedMember, INamedTypeSymbol destination);
    private static bool IsSelectedMemberDeclarationAlreadyInDestinationClass(ISymbol selectedMember, INamedTypeSymbol destination);
    private static bool IsSelectedMemberDeclarationAlreadyInDestinationInterface(ISymbol selectedMember, INamedTypeSymbol destination);
}
internal class Microsoft.CodeAnalysis.CodeRefactorings.PullMemberUp.PullMembersUpOptionsBuilder : object {
    public static PullMembersUpOptions BuildPullMembersUpOptions(INamedTypeSymbol destination, ImmutableArray`1<ValueTuple`2<ISymbol, bool>> members);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeRefactorings.ICodeRefactoringHelpersService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeRefactorings.ServicesLayerCodeActionHelpersService : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3 : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.AbstractSyncNamespaceCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__0")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    protected abstract virtual Task`1<SyntaxNode> TryGetApplicableInvocationNodeAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected abstract virtual string EscapeIdentifier(string identifier);
}
internal class Microsoft.CodeAnalysis.CodeRefactorings.SyncNamespace.SyncNamespaceDocumentsNotInSolutionException : Exception {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<DocumentId> _documentIds;
    public SyncNamespaceDocumentsNotInSolutionException(ImmutableArray`1<DocumentId> documentIds);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInCodeStyleDiagnosticAnalyzer : DiagnosticAnalyzer {
    protected DiagnosticDescriptor Descriptor;
    private Nullable`1<DiagnosticSeverity> _minimumReportedSeverity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public bool IsHighPriority { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, IOption2 option, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, ImmutableHashSet`1<IOption2> options, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, IOption2>> supportedDiagnosticsWithOptions);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, ImmutableHashSet`1<IOption2>>> supportedDiagnosticsWithOptions);
    private AbstractBuiltInCodeStyleDiagnosticAnalyzer(string descriptorId, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool configurable, bool hasAnyCodeStyleOption);
    protected AbstractBuiltInCodeStyleDiagnosticAnalyzer(ImmutableArray`1<DiagnosticDescriptor> supportedDiagnostics);
    private static void AddDiagnosticIdToOptionMapping(string diagnosticId, IOption2 option);
    private static void AddDiagnosticIdToOptionMapping(string diagnosticId, ImmutableHashSet`1<IOption2> options);
    public abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    public virtual bool get_IsHighPriority();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected static DiagnosticDescriptor CreateDescriptorWithId(string id, EnforceOnBuild enforceOnBuild, bool hasAnyCodeStyleOption, LocalizableString title, LocalizableString messageFormat, bool isUnnecessary, bool isConfigurable, LocalizableString description);
    protected virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    public sealed virtual void Initialize(AnalysisContext context);
    protected abstract virtual void InitializeWorker(AnalysisContext context);
    protected static bool IsAnalysisLevelGreaterThanOrEquals(int minAnalysisLevel, AnalyzerOptions analyzerOptions);
    protected bool ShouldSkipAnalysis(SemanticModelAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(SyntaxNodeAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(CodeBlockAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(OperationAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(OperationBlockAnalysisContext context, Nullable`1<NotificationOption2> notification);
    protected bool ShouldSkipAnalysis(SyntaxTree tree, AnalyzerOptions analyzerOptions, CompilationOptions compilationOptions, Nullable`1<NotificationOption2> notification, CancellationToken cancellationToken);
    protected bool ShouldSkipAnalysis(SyntaxTree tree, AnalyzerOptions analyzerOptions, CompilationOptions compilationOptions, ImmutableArray`1<NotificationOption2> notifications, CancellationToken cancellationToken);
    private bool ShouldSkipAnalysis(SyntaxTree tree, AnalyzerOptions analyzerOptions, CompilationOptions compilationOptions, Nullable`1<NotificationOption2> notification, bool performDescriptorsCheck, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableContextAttribute("2")]
protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, IOption2 option, PerLanguageOption2`1<bool> fadingOption, LocalizableString title, LocalizableString messageFormat, bool configurable);
    protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild, ImmutableHashSet`1<IOption2> options, PerLanguageOption2`1<bool> fadingOption, LocalizableString title, LocalizableString messageFormat, bool configurable);
    protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(ImmutableArray`1<DiagnosticDescriptor> descriptors, PerLanguageOption2`1<bool> fadingOption);
    [NullableContextAttribute("2")]
protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, IOption2>> supportedDiagnosticsWithOptions, PerLanguageOption2`1<bool> fadingOption);
    [NullableContextAttribute("2")]
protected AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer(ImmutableArray`1<ValueTuple`2<DiagnosticDescriptor, ImmutableHashSet`1<IOption2>>> supportedDiagnosticsWithOptions, PerLanguageOption2`1<bool> fadingOption);
    private static void AddDiagnosticIdToFadingOptionMapping(string diagnosticId, PerLanguageOption2`1<bool> fadingOption);
    private static void AddDescriptorsToFadingOptionMapping(IEnumerable`1<DiagnosticDescriptor> descriptors, PerLanguageOption2`1<bool> fadingOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ISyntaxFormatting SyntaxFormatting { get; }
    public bool IsHighPriority { get; }
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFormatting get_SyntaxFormatting();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    public virtual bool get_IsHighPriority();
    private void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected ISyntaxFormatting SyntaxFormatting { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual ISyntaxFormatting get_SyntaxFormatting();
    protected virtual CodeActionRequestPriority ComputeRequestPriority();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingCodeFixProvider/<FixOneAsync>d__7")]
private Task`1<Document> FixOneAsync(CodeFixContext context, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.AbstractFormattingCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuild : Enum {
    public int value__;
    public static EnforceOnBuild Never;
    public static EnforceOnBuild WhenExplicitlyEnabled;
    public static EnforceOnBuild Recommended;
    public static EnforceOnBuild HighlyRecommended;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeStyle.EnforceOnBuildExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToCustomTag(EnforceOnBuild enforceOnBuild);
}
internal static class Microsoft.CodeAnalysis.CodeStyle.FormattingAnalyzerHelper : object {
    internal static void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context, ISyntaxFormatting formattingProvider, DiagnosticDescriptor descriptor, SyntaxFormattingOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CommentSelection.AbstractCommentSelectionService : object {
    public string BlockCommentEndString { get; }
    public string BlockCommentStartString { get; }
    public string SingleLineCommentString { get; }
    public bool SupportsBlockComment { get; }
    public abstract virtual string get_BlockCommentEndString();
    public abstract virtual string get_BlockCommentStartString();
    public abstract virtual string get_SingleLineCommentString();
    public abstract virtual bool get_SupportsBlockComment();
    public sealed virtual CommentSelectionInfo GetInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CommentSelection.CommentSelectionInfo : ValueType {
    [CompilerGeneratedAttribute]
private bool <SupportsSingleLineComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsBlockComment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SingleLineCommentString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlockCommentStartString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlockCommentEndString>k__BackingField;
    public bool SupportsSingleLineComment { get; }
    public bool SupportsBlockComment { get; }
    public string SingleLineCommentString { get; }
    public string BlockCommentStartString { get; }
    public string BlockCommentEndString { get; }
    public CommentSelectionInfo(bool supportsSingleLineComment, bool supportsBlockComment, string singleLineCommentString, string blockCommentStartString, string blockCommentEndString);
    [CompilerGeneratedAttribute]
public bool get_SupportsSingleLineComment();
    [CompilerGeneratedAttribute]
public bool get_SupportsBlockComment();
    [CompilerGeneratedAttribute]
public string get_SingleLineCommentString();
    [CompilerGeneratedAttribute]
public string get_BlockCommentStartString();
    [CompilerGeneratedAttribute]
public string get_BlockCommentEndString();
}
internal interface Microsoft.CodeAnalysis.CommentSelection.ICommentSelectionService {
    public abstract virtual CommentSelectionInfo GetInfo();
}
internal static class Microsoft.CodeAnalysis.Common.FeaturesSessionTelemetry : object {
    public static void Report();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.AbstractContextVariableArgumentProvider : ArgumentProvider {
    protected string ThisOrMeKeyword { get; }
    protected abstract virtual string get_ThisOrMeKeyword();
    protected abstract virtual bool IsInstanceContext(SyntaxTree syntaxTree, SyntaxToken targetToken, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.AbstractContextVariableArgumentProvider/<ProvideArgumentAsync>d__3")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
    [CompilerGeneratedAttribute]
internal static void <ProvideArgumentAsync>g__CheckCandidate|3_0(ISymbol candidate, string overridingName, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <ProvideArgumentAsync>g__IsNewConversionSameOrBetter|3_1(CommonConversion conversion, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <ProvideArgumentAsync>g__IsNewNameSameOrBetter|3_2(ISymbol symbol, <>c__DisplayClass3_0& );
}
internal abstract class Microsoft.CodeAnalysis.Completion.AbstractDefaultArgumentProvider : ArgumentProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.ArgumentContext : object {
    [CompilerGeneratedAttribute]
private ArgumentProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterSymbol <Parameter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    internal ArgumentProvider Provider { get; }
    public SemanticModel SemanticModel { get; }
    public int Position { get; }
    public IParameterSymbol Parameter { get; }
    [NullableAttribute("2")]
public string PreviousValue { get; }
    public CancellationToken CancellationToken { get; }
    [NullableAttribute("2")]
public string DefaultValue { get; public set; }
    public ArgumentContext(ArgumentProvider provider, SemanticModel semanticModel, int position, IParameterSymbol parameter, string previousValue, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal ArgumentProvider get_Provider();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public IParameterSymbol get_Parameter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_PreviousValue();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_DefaultValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DefaultValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.ArgumentProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    public abstract virtual Task ProvideArgumentAsync(ArgumentContext context);
}
public enum Microsoft.CodeAnalysis.Completion.CharacterSetModificationKind : Enum {
    public int value__;
    public static CharacterSetModificationKind Add;
    public static CharacterSetModificationKind Remove;
    public static CharacterSetModificationKind Replace;
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Completion.CharacterSetModificationRule : ValueType {
    [CompilerGeneratedAttribute]
private CharacterSetModificationKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<char> <Characters>k__BackingField;
    public CharacterSetModificationKind Kind { get; }
    public ImmutableArray`1<char> Characters { get; }
    private CharacterSetModificationRule(CharacterSetModificationKind kind, ImmutableArray`1<char> characters);
    [CompilerGeneratedAttribute]
public CharacterSetModificationKind get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<char> get_Characters();
    public static CharacterSetModificationRule Create(CharacterSetModificationKind kind, ImmutableArray`1<char> characters);
    [NullableContextAttribute("1")]
public static CharacterSetModificationRule Create(CharacterSetModificationKind kind, Char[] characters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.CommonCompletionItem : object {
    public static string DescriptionProperty;
    private static Char[] s_descriptionSeparators;
    private static CommonCompletionItem();
    [NullableContextAttribute("2")]
public static CompletionItem Create(string displayText, string displayTextSuffix, CompletionItemRules rules, Nullable`1<Glyph> glyph, ImmutableArray`1<SymbolDisplayPart> description, string sortText, string filterText, bool showsWarningIcon, ImmutableArray`1<KeyValuePair`2<string, string>> properties, ImmutableArray`1<string> tags, string inlineDescription, string displayTextPrefix, bool isComplexTextEdit);
    public static bool HasDescription(CompletionItem item);
    public static CompletionDescription GetDescription(CompletionItem item);
    [NullableContextAttribute("0")]
private static string EncodeDescription(ImmutableArray`1<TaggedText> description);
    private static CompletionDescription DecodeDescription(string encoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.CommonCompletionProvider : CompletionProvider {
    private static CompletionItemRules s_suggestionItemRules;
    internal string Language { get; }
    private static CommonCompletionProvider();
    internal abstract virtual string get_Language();
    public sealed virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    internal virtual bool ShouldTriggerCompletion(LanguageServices languageServices, SourceText text, int caretPosition, CompletionTrigger trigger, CompletionOptions options, OptionSet passThroughOptions);
    private bool ShouldTriggerCompletionImpl(SourceText text, int caretPosition, CompletionTrigger trigger, CompletionOptions& options);
    public virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, CompletionOptions options);
    public sealed virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CommonCompletionProvider/<GetDescriptionAsync>d__8")]
internal virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CommonCompletionProvider/<TryAddSnippetInvocationPartAsync>d__9")]
private Task`1<ImmutableArray`1<TaggedText>> TryAddSnippetInvocationPartAsync(Document document, CompletionItem item, ImmutableArray`1<TaggedText> parts, CancellationToken cancellationToken);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CommonCompletionProvider/<GetChangeAsync>d__11")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected static CompletionItem CreateSuggestionModeItem(string displayText, string description);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.CommonCompletionService : CompletionService {
    protected CommonCompletionService(SolutionServices services, IAsynchronousOperationListenerProvider listenerProvider);
    protected virtual CompletionItem GetBetterItem(CompletionItem item, CompletionItem existingItem);
    protected static bool IsKeywordItem(CompletionItem item);
    protected static bool IsSnippetItem(CompletionItem item);
    internal virtual void FilterItems(Document document, IReadOnlyList`1<MatchResult> matchResults, string filterText, IList`1<MatchResult> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.CommonCompletionUtilities : object {
    private static string NonBreakingSpaceString;
    public static TextSpan GetWordSpan(SourceText text, int position, Func`2<char, bool> isWordStartCharacter, Func`2<char, bool> isWordCharacter);
    public static TextSpan GetWordSpan(SourceText text, int position, Func`2<char, bool> isWordStartCharacter, Func`2<char, bool> isWordCharacter, bool alwaysExtendEndSpan);
    public static bool IsStartingNewWord(SourceText text, int characterPosition, Func`2<char, bool> isWordStartCharacter, Func`2<char, bool> isWordCharacter);
    public static Func`2<CancellationToken, Task`1<CompletionDescription>> CreateDescriptionFactory(SolutionServices workspaceServices, SemanticModel semanticModel, int position, ISymbol symbol, SymbolDescriptionOptions options);
    public static Func`2<CancellationToken, Task`1<CompletionDescription>> CreateDescriptionFactory(SolutionServices workspaceServices, SemanticModel semanticModel, int position, SymbolDescriptionOptions options, IReadOnlyList`1<ISymbol> symbols);
    public static Func`2<CancellationToken, Task`1<CompletionDescription>> CreateDescriptionFactory(SolutionServices workspaceServices, SemanticModel semanticModel, int position, IReadOnlyList`1<ISymbol> symbols, SymbolDescriptionOptions options, SupportedPlatformData supportedPlatforms);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CommonCompletionUtilities/<CreateDescriptionAsync>d__7")]
public static Task`1<CompletionDescription> CreateDescriptionAsync(SolutionServices workspaceServices, SemanticModel semanticModel, int position, ISymbol symbol, int overloadCount, SymbolDescriptionOptions options, SupportedPlatformData supportedPlatforms, CancellationToken cancellationToken);
    public static Task`1<CompletionDescription> CreateDescriptionAsync(SolutionServices workspaceServices, SemanticModel semanticModel, int position, IReadOnlyList`1<ISymbol> symbols, SymbolDescriptionOptions options, SupportedPlatformData supportedPlatforms, CancellationToken cancellationToken);
    private static void AddOverloadPart(List`1<TaggedText> textContentBuilder, int overloadCount, bool isGeneric);
    private static void AddDocumentationPart(List`1<TaggedText> textContentBuilder, ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    internal static bool IsTextualTriggerString(SourceText text, int characterPosition, string value);
    public static bool TryRemoveAttributeSuffix(ISymbol symbol, SyntaxContext context, String& name);
    internal static ImmutableHashSet`1<char> GetTriggerCharacters(CompletionProvider provider);
}
public class Microsoft.CodeAnalysis.Completion.CompletionChange : object {
    [CompilerGeneratedAttribute]
private TextChange <TextChange>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TextChange> <TextChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <NewPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludesCommitCharacter>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <Properties>k__BackingField;
    public TextChange TextChange { get; }
    public ImmutableArray`1<TextChange> TextChanges { get; }
    public Nullable`1<int> NewPosition { get; }
    public bool IncludesCommitCharacter { get; }
    [NullableAttribute("1")]
internal ImmutableDictionary`2<string, string> Properties { get; }
    private CompletionChange(TextChange textChange, ImmutableArray`1<TextChange> textChanges, Nullable`1<int> newPosition, bool includesCommitCharacter);
    private CompletionChange(TextChange textChange, ImmutableArray`1<TextChange> textChanges, Nullable`1<int> newPosition, bool includesCommitCharacter, ImmutableDictionary`2<string, string> properties);
    [CompilerGeneratedAttribute]
public TextChange get_TextChange();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TextChange> get_TextChanges();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_NewPosition();
    [CompilerGeneratedAttribute]
public bool get_IncludesCommitCharacter();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal ImmutableDictionary`2<string, string> get_Properties();
    [ObsoleteAttribute("Use Create overload that takes a single TextChange and multiple TextChanges instead", "True")]
public static CompletionChange Create(ImmutableArray`1<TextChange> textChanges, Nullable`1<int> newPosition, bool includesCommitCharacter);
    [NullableContextAttribute("1")]
public static CompletionChange Create(TextChange textChange, Nullable`1<int> newPosition, bool includesCommitCharacter);
    public static CompletionChange Create(TextChange textChange, ImmutableArray`1<TextChange> textChanges, Nullable`1<int> newPosition, bool includesCommitCharacter);
    [NullableContextAttribute("1")]
internal static CompletionChange Create(TextChange textChange, ImmutableArray`1<TextChange> textChanges, ImmutableDictionary`2<string, string> properties, Nullable`1<int> newPosition, bool includesCommitCharacter);
    [NullableContextAttribute("1")]
public CompletionChange WithTextChange(TextChange textChange);
    public CompletionChange WithTextChanges(ImmutableArray`1<TextChange> textChanges);
    [NullableContextAttribute("1")]
public CompletionChange WithNewPosition(Nullable`1<int> newPostion);
    [NullableContextAttribute("1")]
public CompletionChange WithIncludesCommitCharacter(bool includesCommitCharacter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Completion.CompletionContext : object {
    private SegmentedList`1<CompletionItem> _items;
    [NullableAttribute("2")]
private CompletionItem _suggestionModeItem;
    private bool _isExclusive;
    [CompilerGeneratedAttribute]
private CompletionProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SharedSyntaxContextsWithSpeculativeModel <SharedSyntaxContextsWithSpeculativeModel>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <DefaultItemSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <CompletionListSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionTrigger <Trigger>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionOptions <CompletionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionSet <Options>k__BackingField;
    internal CompletionProvider Provider { get; }
    public Document Document { get; }
    public int Position { get; }
    [NullableAttribute("2")]
private SharedSyntaxContextsWithSpeculativeModel SharedSyntaxContextsWithSpeculativeModel { get; }
    [ObsoleteAttribute("Not used anymore. Use CompletionListSpan instead.", "True")]
public TextSpan DefaultItemSpan { get; }
    public TextSpan CompletionListSpan { get; public set; }
    public CompletionTrigger Trigger { get; }
    internal CompletionOptions CompletionOptions { get; }
    public CancellationToken CancellationToken { get; }
    public bool IsExclusive { get; public set; }
    public OptionSet Options { get; }
    internal IReadOnlyList`1<CompletionItem> Items { get; }
    [NullableAttribute("2")]
public CompletionItem SuggestionModeItem { get; public set; }
    public CompletionContext(CompletionProvider provider, Document document, int position, TextSpan defaultSpan, CompletionTrigger trigger, OptionSet options, CancellationToken cancellationToken);
    internal CompletionContext(CompletionProvider provider, Document document, int position, SharedSyntaxContextsWithSpeculativeModel sharedSyntaxContextsWithSpeculativeModel, TextSpan defaultSpan, CompletionTrigger trigger, CompletionOptions& options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal CompletionProvider get_Provider();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public int get_Position();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private SharedSyntaxContextsWithSpeculativeModel get_SharedSyntaxContextsWithSpeculativeModel();
    [CompilerGeneratedAttribute]
public TextSpan get_DefaultItemSpan();
    [CompilerGeneratedAttribute]
public TextSpan get_CompletionListSpan();
    [CompilerGeneratedAttribute]
public void set_CompletionListSpan(TextSpan value);
    [CompilerGeneratedAttribute]
public CompletionTrigger get_Trigger();
    [CompilerGeneratedAttribute]
internal CompletionOptions get_CompletionOptions();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    public bool get_IsExclusive();
    public void set_IsExclusive(bool value);
    [CompilerGeneratedAttribute]
public OptionSet get_Options();
    internal IReadOnlyList`1<CompletionItem> get_Items();
    public void AddItem(CompletionItem item);
    public void AddItems(IEnumerable`1<CompletionItem> items);
    [NullableContextAttribute("2")]
public CompletionItem get_SuggestionModeItem();
    [NullableContextAttribute("2")]
public void set_SuggestionModeItem(CompletionItem value);
    internal Task`1<SyntaxContext> GetSyntaxContextWithExistingSpeculativeModelAsync(Document document, CancellationToken cancellationToken);
    private CompletionItem FixItem(CompletionItem item);
}
public class Microsoft.CodeAnalysis.Completion.CompletionDescription : object {
    [NullableAttribute("2")]
private string _text;
    [NullableAttribute("1")]
public static CompletionDescription Empty;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <TaggedParts>k__BackingField;
    public ImmutableArray`1<TaggedText> TaggedParts { get; }
    [NullableAttribute("1")]
public string Text { get; }
    private CompletionDescription(ImmutableArray`1<TaggedText> taggedParts);
    private static CompletionDescription();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_TaggedParts();
    public static CompletionDescription Create(ImmutableArray`1<TaggedText> taggedParts);
    [NullableContextAttribute("1")]
public static CompletionDescription FromText(string text);
    public CompletionDescription WithTaggedParts(ImmutableArray`1<TaggedText> taggedParts);
    [NullableContextAttribute("1")]
public string get_Text();
}
internal enum Microsoft.CodeAnalysis.Completion.CompletionFilterReason : Enum {
    public int value__;
    public static CompletionFilterReason Insertion;
    public static CompletionFilterReason Deletion;
    public static CompletionFilterReason CaretPositionChanged;
    public static CompletionFilterReason Other;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.CompletionHelper : object {
    [CompilerGeneratedAttribute]
private static CompletionHelper <CaseSensitiveInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompletionHelper <CaseInsensitiveInstance>k__BackingField;
    private bool _isCaseSensitive;
    private static CompletionHelper CaseSensitiveInstance { get; }
    private static CompletionHelper CaseInsensitiveInstance { get; }
    public CompletionHelper(bool isCaseSensitive);
    private static CompletionHelper();
    [CompilerGeneratedAttribute]
private static CompletionHelper get_CaseSensitiveInstance();
    [CompilerGeneratedAttribute]
private static CompletionHelper get_CaseInsensitiveInstance();
    public static CompletionHelper GetHelper(Document document);
    public int CompareMatchResults(MatchResult matchResult1, MatchResult matchResult2, bool filterTextHasNoUpperCase);
    private static int CompareItems(PatternMatch match1, PatternMatch match2, CompletionItem item1, CompletionItem item2, bool isCaseSensitive, bool filterTextHasNoUpperCase);
    private static int CompareSpecialMatchPriorityValues(CompletionItem item1, CompletionItem item2);
    private static int ComparePreselection(CompletionItem item1, CompletionItem item2);
    private static int CompareDeprioritization(CompletionItem item1, CompletionItem item2);
    private static int CompareExpandedItem(CompletionItem item1, PatternMatch match1, CompletionItem item2, PatternMatch match2);
    [CompilerGeneratedAttribute]
internal static bool <CompareMatchResults>g__IsKeywordItem|9_0(CompletionItem item);
    [CompilerGeneratedAttribute]
internal static bool <CompareMatchResults>g__TagsEqual|9_1(CompletionItem item1, CompletionItem item2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DisplayText}")]
public class Microsoft.CodeAnalysis.Completion.CompletionItem : object {
    [NullableAttribute("2")]
private string _filterText;
    [NullableAttribute("2")]
private string _lazyEntireDisplayText;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, string> _lazyPropertiesAsImmutableDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<KeyValuePair`2<string, string>> _properties;
    [CompilerGeneratedAttribute]
private string <DisplayText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayTextPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayTextSuffix>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AdditionalFilterTexts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SortText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InlineDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionItemRules <Rules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplexTextEdit>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <AutomationText>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionItemFlags <Flags>k__BackingField;
    public string DisplayText { get; }
    public string DisplayTextPrefix { get; }
    public string DisplayTextSuffix { get; }
    public string FilterText { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImmutableArray`1<string> AdditionalFilterTexts { get; internal set; }
    internal bool HasDifferentFilterText { get; }
    internal bool HasAdditionalFilterTexts { get; }
    public string SortText { get; }
    public string InlineDescription { get; }
    public TextSpan Span { get; internal set; }
    public ImmutableDictionary`2<string, string> Properties { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    public CompletionItemRules Rules { get; }
    public bool IsComplexTextEdit { get; }
    [NullableAttribute("2")]
internal string ProviderName { get; internal set; }
    [NullableAttribute("2")]
internal string AutomationText { get; internal set; }
    internal CompletionItemFlags Flags { get; internal set; }
    [NullableContextAttribute("2")]
private CompletionItem(string displayText, string filterText, string sortText, TextSpan span, ImmutableArray`1<KeyValuePair`2<string, string>> properties, ImmutableArray`1<string> tags, CompletionItemRules rules, string displayTextPrefix, string displayTextSuffix, string inlineDescription, bool isComplexTextEdit);
    [CompilerGeneratedAttribute]
public string get_DisplayText();
    [CompilerGeneratedAttribute]
public string get_DisplayTextPrefix();
    [CompilerGeneratedAttribute]
public string get_DisplayTextSuffix();
    public string get_FilterText();
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<string> get_AdditionalFilterTexts();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AdditionalFilterTexts(ImmutableArray`1<string> value);
    internal bool get_HasDifferentFilterText();
    internal bool get_HasAdditionalFilterTexts();
    [CompilerGeneratedAttribute]
public string get_SortText();
    [CompilerGeneratedAttribute]
public string get_InlineDescription();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
internal void set_Span(TextSpan value);
    public ImmutableDictionary`2<string, string> get_Properties();
    internal ImmutableArray`1<KeyValuePair`2<string, string>> GetProperties();
    internal bool TryGetProperty(string name, String& value);
    internal string GetProperty(string name);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Tags();
    [CompilerGeneratedAttribute]
public CompletionItemRules get_Rules();
    [CompilerGeneratedAttribute]
public bool get_IsComplexTextEdit();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_ProviderName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ProviderName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_AutomationText();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_AutomationText(string value);
    [CompilerGeneratedAttribute]
internal CompletionItemFlags get_Flags();
    [CompilerGeneratedAttribute]
internal void set_Flags(CompletionItemFlags value);
    [NullableContextAttribute("2")]
public static CompletionItem Create(string displayText, string filterText, string sortText, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules);
    [NullableContextAttribute("2")]
public static CompletionItem Create(string displayText, string filterText, string sortText, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules, string displayTextPrefix, string displayTextSuffix);
    [NullableContextAttribute("2")]
public static CompletionItem Create(string displayText, string filterText, string sortText, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules, string displayTextPrefix, string displayTextSuffix, string inlineDescription);
    [NullableContextAttribute("2")]
public static CompletionItem Create(string displayText, string filterText, string sortText, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules, string displayTextPrefix, string displayTextSuffix, string inlineDescription, bool isComplexTextEdit);
    [NullableContextAttribute("2")]
internal static CompletionItem CreateInternal(string displayText, string filterText, string sortText, ImmutableArray`1<KeyValuePair`2<string, string>> properties, ImmutableArray`1<string> tags, CompletionItemRules rules, string displayTextPrefix, string displayTextSuffix, string inlineDescription, bool isComplexTextEdit);
    [ObsoleteAttribute("Use the Create overload that does not take a span", "True")]
[EditorBrowsableAttribute("1")]
public static CompletionItem Create(string displayText, string filterText, string sortText, TextSpan span, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, CompletionItemRules rules);
    [NullableContextAttribute("0")]
private CompletionItem With(Optional`1<TextSpan> span, Optional`1<string> displayText, Optional`1<string> filterText, Optional`1<string> sortText, Optional`1<ImmutableArray`1<KeyValuePair`2<string, string>>> properties, Optional`1<ImmutableArray`1<string>> tags, Optional`1<CompletionItemRules> rules, Optional`1<string> displayTextPrefix, Optional`1<string> displayTextSuffix, Optional`1<string> inlineDescription, Optional`1<bool> isComplexTextEdit, Optional`1<ImmutableArray`1<string>> additionalFilterTexts);
    [ObsoleteAttribute("Not used anymore.  CompletionList.Span is used to control the span used for filtering.", "True")]
[EditorBrowsableAttribute("1")]
public CompletionItem WithSpan(TextSpan span);
    public CompletionItem WithDisplayText(string text);
    public CompletionItem WithDisplayTextPrefix(string displayTextPrefix);
    public CompletionItem WithDisplayTextSuffix(string displayTextSuffix);
    public CompletionItem WithFilterText(string text);
    public CompletionItem WithSortText(string text);
    public CompletionItem WithProperties(ImmutableDictionary`2<string, string> properties);
    internal CompletionItem WithProperties(ImmutableArray`1<KeyValuePair`2<string, string>> properties);
    public CompletionItem AddProperty(string name, string value);
    public CompletionItem WithTags(ImmutableArray`1<string> tags);
    public CompletionItem AddTag(string tag);
    public CompletionItem WithRules(CompletionItemRules rules);
    public CompletionItem WithIsComplexTextEdit(bool isComplexTextEdit);
    internal CompletionItem WithAdditionalFilterTexts(ImmutableArray`1<string> additionalFilterTexts);
    private sealed virtual override int System.IComparable<Microsoft.CodeAnalysis.Completion.CompletionItem>.CompareTo(CompletionItem other);
    internal string GetEntireDisplayText();
    public virtual string ToString();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Completion.CompletionItemFlags : Enum {
    public int value__;
    public static CompletionItemFlags None;
    public static CompletionItemFlags Cached;
    public static CompletionItemFlags Expanded;
    public static CompletionItemFlags CachedAndExpanded;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Completion.CompletionItemFlagsExtensions : object {
    [ExtensionAttribute]
public static bool IsCached(CompletionItemFlags flags);
    [ExtensionAttribute]
public static bool IsExpanded(CompletionItemFlags flags);
}
public class Microsoft.CodeAnalysis.Completion.CompletionItemRules : object {
    [NullableAttribute("1")]
public static CompletionItemRules Default;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CharacterSetModificationRule> <FilterCharacterRules>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CharacterSetModificationRule> <CommitCharacterRules>k__BackingField;
    [CompilerGeneratedAttribute]
private EnterKeyRule <EnterKeyRule>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatOnCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MatchPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionItemSelectionBehavior <SelectionBehavior>k__BackingField;
    public ImmutableArray`1<CharacterSetModificationRule> FilterCharacterRules { get; }
    public ImmutableArray`1<CharacterSetModificationRule> CommitCharacterRules { get; }
    public EnterKeyRule EnterKeyRule { get; }
    public bool FormatOnCommit { get; }
    public int MatchPriority { get; }
    public CompletionItemSelectionBehavior SelectionBehavior { get; }
    private CompletionItemRules(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules, ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules, EnterKeyRule enterKeyRule, bool formatOnCommit, int matchPriority, CompletionItemSelectionBehavior selectionBehavior);
    private static CompletionItemRules();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CharacterSetModificationRule> get_FilterCharacterRules();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CharacterSetModificationRule> get_CommitCharacterRules();
    [CompilerGeneratedAttribute]
public EnterKeyRule get_EnterKeyRule();
    [CompilerGeneratedAttribute]
public bool get_FormatOnCommit();
    [CompilerGeneratedAttribute]
public int get_MatchPriority();
    [CompilerGeneratedAttribute]
public CompletionItemSelectionBehavior get_SelectionBehavior();
    public static CompletionItemRules Create(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules, ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules, EnterKeyRule enterKeyRule, bool formatOnCommit, Nullable`1<int> matchPriority);
    public static CompletionItemRules Create(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules, ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules, EnterKeyRule enterKeyRule, bool formatOnCommit, Nullable`1<int> matchPriority, CompletionItemSelectionBehavior selectionBehavior);
    internal static CompletionItemRules Create(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules, ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules, EnterKeyRule enterKeyRule, bool formatOnCommit, bool preselect);
    private CompletionItemRules With(Optional`1<ImmutableArray`1<CharacterSetModificationRule>> filterRules, Optional`1<ImmutableArray`1<CharacterSetModificationRule>> commitRules, Optional`1<EnterKeyRule> enterKeyRule, Optional`1<bool> formatOnCommit, Optional`1<int> matchPriority, Optional`1<CompletionItemSelectionBehavior> selectionBehavior);
    public CompletionItemRules WithFilterCharacterRules(ImmutableArray`1<CharacterSetModificationRule> filterCharacterRules);
    [NullableContextAttribute("1")]
internal CompletionItemRules WithFilterCharacterRule(CharacterSetModificationRule rule);
    [NullableContextAttribute("1")]
internal CompletionItemRules WithCommitCharacterRule(CharacterSetModificationRule rule);
    public CompletionItemRules WithCommitCharacterRules(ImmutableArray`1<CharacterSetModificationRule> commitCharacterRules);
    [NullableContextAttribute("1")]
public CompletionItemRules WithEnterKeyRule(EnterKeyRule enterKeyRule);
    [NullableContextAttribute("1")]
public CompletionItemRules WithFormatOnCommit(bool formatOnCommit);
    [NullableContextAttribute("1")]
public CompletionItemRules WithMatchPriority(int matchPriority);
    [NullableContextAttribute("1")]
public CompletionItemRules WithSelectionBehavior(CompletionItemSelectionBehavior selectionBehavior);
}
public enum Microsoft.CodeAnalysis.Completion.CompletionItemSelectionBehavior : Enum {
    public int value__;
    public static CompletionItemSelectionBehavior Default;
    public static CompletionItemSelectionBehavior SoftSelection;
    public static CompletionItemSelectionBehavior HardSelection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Completion.CompletionList : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableArray`1<CompletionItem>> _lazyItems;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CompletionItem> <ItemsList>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <DefaultSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private CompletionRules <Rules>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CompletionItem <SuggestionModeItem>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExclusive>k__BackingField;
    public static CompletionList Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ObsoleteAttribute("This property is obsolete. Use ItemsList instead", "False")]
[EditorBrowsableAttribute("1")]
public ImmutableArray`1<CompletionItem> Items { get; }
    public IReadOnlyList`1<CompletionItem> ItemsList { get; }
    [ObsoleteAttribute("Not used anymore.  CompletionList.Span is used instead.", "True")]
public TextSpan DefaultSpan { get; }
    public TextSpan Span { get; }
    public CompletionRules Rules { get; }
    [NullableAttribute("2")]
public CompletionItem SuggestionModeItem { get; }
    internal bool IsExclusive { get; }
    internal bool IsEmpty { get; }
    [NullableContextAttribute("2")]
private CompletionList(TextSpan defaultSpan, IReadOnlyList`1<CompletionItem> itemsList, CompletionRules rules, CompletionItem suggestionModeItem, bool isExclusive);
    private static CompletionList();
    public ImmutableArray`1<CompletionItem> get_Items();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CompletionItem> get_ItemsList();
    [CompilerGeneratedAttribute]
public TextSpan get_DefaultSpan();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public CompletionRules get_Rules();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CompletionItem get_SuggestionModeItem();
    [CompilerGeneratedAttribute]
internal bool get_IsExclusive();
    [NullableContextAttribute("2")]
public static CompletionList Create(TextSpan defaultSpan, ImmutableArray`1<CompletionItem> items, CompletionRules rules, CompletionItem suggestionModeItem);
    internal static CompletionList Create(TextSpan defaultSpan, IReadOnlyList`1<CompletionItem> itemsList, CompletionRules rules, CompletionItem suggestionModeItem, bool isExclusive);
    [NullableContextAttribute("0")]
private CompletionList With(Optional`1<TextSpan> span, Optional`1<IReadOnlyList`1<CompletionItem>> itemsList, Optional`1<CompletionRules> rules, Optional`1<CompletionItem> suggestionModeItem);
    [ObsoleteAttribute("Not used anymore.  Use WithSpan instead.", "True")]
public CompletionList WithDefaultSpan(TextSpan span);
    public CompletionList WithSpan(TextSpan span);
    public CompletionList WithItems(ImmutableArray`1<CompletionItem> items);
    internal CompletionList WithItemsList(IReadOnlyList`1<CompletionItem> itemsList);
    public CompletionList WithRules(CompletionRules rules);
    public CompletionList WithSuggestionModeItem(CompletionItem suggestionModeItem);
    internal bool get_IsEmpty();
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CompletionItem> <.ctor>b__21_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.CompletionOptions : object {
    [CompilerGeneratedAttribute]
private bool <TriggerOnTyping>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TriggerOnTypingLetters>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <TriggerOnDeletion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TriggerInArgumentLists>k__BackingField;
    [CompilerGeneratedAttribute]
private EnterKeyRule <EnterKeyBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private SnippetsRule <SnippetsBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideAdvancedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowNameSuggestions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShowItemsFromUnimportedNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnnamedSymbolCompletionDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TargetTypedCompletionFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProvideDateAndTimeCompletions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProvideRegexCompletions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PerformSort>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceExpandedCompletionIndexCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateImportCompletionCacheInBackground>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanAddImportStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FilterOutOfScopeLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowXmlDocCommentCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShowNewSnippetExperienceUserOption>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowNewSnippetExperienceFeatureFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpandedCompletionMode <ExpandedCompletionBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingStylePreferences <NamingStyleFallbackOptions>k__BackingField;
    [NullableAttribute("1")]
public static CompletionOptions Default;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public bool TriggerOnTyping { get; public set; }
    public bool TriggerOnTypingLetters { get; public set; }
    public Nullable`1<bool> TriggerOnDeletion { get; public set; }
    public bool TriggerInArgumentLists { get; public set; }
    public EnterKeyRule EnterKeyBehavior { get; public set; }
    public SnippetsRule SnippetsBehavior { get; public set; }
    public bool HideAdvancedMembers { get; public set; }
    public bool ShowNameSuggestions { get; public set; }
    public Nullable`1<bool> ShowItemsFromUnimportedNamespaces { get; public set; }
    public bool UnnamedSymbolCompletionDisabled { get; public set; }
    public bool TargetTypedCompletionFilter { get; public set; }
    public bool ProvideDateAndTimeCompletions { get; public set; }
    public bool ProvideRegexCompletions { get; public set; }
    public bool PerformSort { get; public set; }
    public bool ForceExpandedCompletionIndexCreation { get; public set; }
    public bool UpdateImportCompletionCacheInBackground { get; public set; }
    public bool CanAddImportStatement { get; public set; }
    public bool FilterOutOfScopeLocals { get; public set; }
    public bool ShowXmlDocCommentCompletion { get; public set; }
    public Nullable`1<bool> ShowNewSnippetExperienceUserOption { get; public set; }
    public bool ShowNewSnippetExperienceFeatureFlag { get; public set; }
    public ExpandedCompletionMode ExpandedCompletionBehavior { get; public set; }
    public NamingStylePreferences NamingStyleFallbackOptions { get; public set; }
    public bool ShouldShowItemsFromUnimportedNamespaces { get; }
    [CompilerGeneratedAttribute]
private CompletionOptions(CompletionOptions original);
    private static CompletionOptions();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_TriggerOnTyping();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TriggerOnTyping(bool value);
    [CompilerGeneratedAttribute]
public bool get_TriggerOnTypingLetters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TriggerOnTypingLetters(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_TriggerOnDeletion();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TriggerOnDeletion(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_TriggerInArgumentLists();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TriggerInArgumentLists(bool value);
    [CompilerGeneratedAttribute]
public EnterKeyRule get_EnterKeyBehavior();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EnterKeyBehavior(EnterKeyRule value);
    [CompilerGeneratedAttribute]
public SnippetsRule get_SnippetsBehavior();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SnippetsBehavior(SnippetsRule value);
    [CompilerGeneratedAttribute]
public bool get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HideAdvancedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowNameSuggestions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowNameSuggestions(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ShowItemsFromUnimportedNamespaces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowItemsFromUnimportedNamespaces(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_UnnamedSymbolCompletionDisabled();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnnamedSymbolCompletionDisabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_TargetTypedCompletionFilter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetTypedCompletionFilter(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProvideDateAndTimeCompletions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProvideDateAndTimeCompletions(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProvideRegexCompletions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProvideRegexCompletions(bool value);
    [CompilerGeneratedAttribute]
public bool get_PerformSort();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PerformSort(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceExpandedCompletionIndexCreation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForceExpandedCompletionIndexCreation(bool value);
    [CompilerGeneratedAttribute]
public bool get_UpdateImportCompletionCacheInBackground();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UpdateImportCompletionCacheInBackground(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanAddImportStatement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanAddImportStatement(bool value);
    [CompilerGeneratedAttribute]
public bool get_FilterOutOfScopeLocals();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilterOutOfScopeLocals(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowXmlDocCommentCompletion();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowXmlDocCommentCompletion(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ShowNewSnippetExperienceUserOption();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowNewSnippetExperienceUserOption(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_ShowNewSnippetExperienceFeatureFlag();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowNewSnippetExperienceFeatureFlag(bool value);
    [CompilerGeneratedAttribute]
public ExpandedCompletionMode get_ExpandedCompletionBehavior();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExpandedCompletionBehavior(ExpandedCompletionMode value);
    [CompilerGeneratedAttribute]
public NamingStylePreferences get_NamingStyleFallbackOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamingStyleFallbackOptions(NamingStylePreferences value);
    public RecommendationServiceOptions ToRecommendationServiceOptions();
    public bool get_ShouldShowItemsFromUnimportedNamespaces();
    [NullableContextAttribute("1")]
public bool ShouldShowNewSnippetExperience(Document document);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CompletionOptions left, CompletionOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CompletionOptions left, CompletionOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompletionOptions other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public CompletionOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Completion.CompletionProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal string Name { get; }
    internal bool IsSnippetProvider { get; }
    internal bool IsExpandItemProvider { get; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    public abstract virtual Task ProvideCompletionsAsync(CompletionContext context);
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    internal virtual bool ShouldTriggerCompletion(LanguageServices languageServices, SourceText text, int caretPosition, CompletionTrigger trigger, CompletionOptions options, OptionSet passThroughOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionProvider/<IsSyntacticTriggerCharacterAsync>d__7")]
internal virtual Task`1<bool> IsSyntacticTriggerCharacterAsync(Document document, int caretPosition, CompletionTrigger trigger, CompletionOptions options, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    internal virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    internal virtual bool get_IsSnippetProvider();
    internal virtual bool get_IsExpandItemProvider();
}
public class Microsoft.CodeAnalysis.Completion.CompletionRules : object {
    [CompilerGeneratedAttribute]
private bool <DismissIfEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DismissIfLastCharacterDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<char> <DefaultCommitCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private EnterKeyRule <DefaultEnterKeyRule>k__BackingField;
    [CompilerGeneratedAttribute]
private SnippetsRule <SnippetsRule>k__BackingField;
    private static ImmutableArray`1<char> s_defaultCommitKeys;
    [NullableAttribute("1")]
public static CompletionRules Default;
    public bool DismissIfEmpty { get; }
    public bool DismissIfLastCharacterDeleted { get; }
    public ImmutableArray`1<char> DefaultCommitCharacters { get; }
    public EnterKeyRule DefaultEnterKeyRule { get; }
    public SnippetsRule SnippetsRule { get; }
    private CompletionRules(bool dismissIfEmpty, bool dismissIfLastCharacterDeleted, ImmutableArray`1<char> defaultCommitCharacters, EnterKeyRule defaultEnterKeyRule, SnippetsRule snippetsRule);
    private static CompletionRules();
    [CompilerGeneratedAttribute]
public bool get_DismissIfEmpty();
    [CompilerGeneratedAttribute]
public bool get_DismissIfLastCharacterDeleted();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<char> get_DefaultCommitCharacters();
    [CompilerGeneratedAttribute]
public EnterKeyRule get_DefaultEnterKeyRule();
    [CompilerGeneratedAttribute]
public SnippetsRule get_SnippetsRule();
    public static CompletionRules Create(bool dismissIfEmpty, bool dismissIfLastCharacterDeleted, ImmutableArray`1<char> defaultCommitCharacters, EnterKeyRule defaultEnterKeyRule);
    public static CompletionRules Create(bool dismissIfEmpty, bool dismissIfLastCharacterDeleted, ImmutableArray`1<char> defaultCommitCharacters, EnterKeyRule defaultEnterKeyRule, SnippetsRule snippetsRule);
    private CompletionRules With(Optional`1<bool> dismissIfEmpty, Optional`1<bool> dismissIfLastCharacterDeleted, Optional`1<ImmutableArray`1<char>> defaultCommitCharacters, Optional`1<EnterKeyRule> defaultEnterKeyRule, Optional`1<SnippetsRule> snippetsRule);
    [NullableContextAttribute("1")]
public CompletionRules WithDismissIfEmpty(bool dismissIfEmpty);
    [NullableContextAttribute("1")]
public CompletionRules WithDismissIfLastCharacterDeleted(bool dismissIfLastCharacterDeleted);
    public CompletionRules WithDefaultCommitCharacters(ImmutableArray`1<char> defaultCommitCharacters);
    [NullableContextAttribute("1")]
public CompletionRules WithDefaultEnterKeyRule(EnterKeyRule defaultEnterKeyRule);
    [NullableContextAttribute("1")]
public CompletionRules WithSnippetsRule(SnippetsRule snippetsRule);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Completion.CompletionService : object {
    private SolutionServices _services;
    private ProviderManager _providerManager;
    private bool _suppressPartialSemantics;
    private static ObjectPool`1<List`1<MatchResult>> s_listOfMatchResultPool;
    public string Language { get; }
    internal CompletionService(SolutionServices services, IAsynchronousOperationListenerProvider listenerProvider);
    private static CompletionService();
    [NullableContextAttribute("2")]
public static CompletionService GetService(Document document);
    [ObsoleteAttribute("Built-in providers will be ignored in a future release, please make them MEF exports instead.")]
protected virtual ImmutableArray`1<CompletionProvider> GetBuiltInProviders();
    public abstract virtual string get_Language();
    public CompletionRules GetRules();
    internal abstract virtual CompletionRules GetRules(CompletionOptions options);
    public bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options);
    internal virtual bool SupportsTriggerOnDeletion(CompletionOptions options);
    internal virtual bool ShouldTriggerCompletion(Project project, LanguageServices languageServices, SourceText text, int caretPosition, CompletionTrigger trigger, CompletionOptions options, OptionSet passThroughOptions, ImmutableHashSet`1<string> roles);
    [ObsoleteAttribute("Not used anymore. CompletionService.GetDefaultCompletionListSpan is used instead.", "True")]
public virtual TextSpan GetDefaultItemSpan(SourceText text, int caretPosition);
    public virtual TextSpan GetDefaultCompletionListSpan(SourceText text, int caretPosition);
    public Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionService/<GetDescriptionAsync>d__16")]
internal virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionService/<GetChangeAsync>d__17")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitCharacter, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<CompletionItem> FilterItems(Document document, ImmutableArray`1<CompletionItem> items, string filterText);
    internal virtual void FilterItems(Document document, IReadOnlyList`1<MatchResult> matchResults, string filterText, IList`1<MatchResult> builder);
    internal static void FilterItems(CompletionHelper completionHelper, IReadOnlyList`1<MatchResult> matchResults, string filterText, IList`1<MatchResult> builder);
    internal void LoadImportedProviders();
    internal void TriggerLoadProjectProviders(Project project, CompletionOptions options);
    [NullableContextAttribute("2")]
internal CompletionProvider GetProvider(CompletionItem item, Project project);
    internal TestAccessor GetTestAccessor();
    public Task`1<CompletionList> GetCompletionsAsync(Document document, int caretPosition, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionService/<GetCompletionsAsync>d__29")]
internal virtual Task`1<CompletionList> GetCompletionsAsync(Document document, int caretPosition, CompletionOptions options, OptionSet passThroughOptions, CompletionTrigger trigger, ImmutableHashSet`1<string> roles, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionService/<GetDocumentWithFrozenPartialSemanticsAsync>d__30")]
private Task`1<ValueTuple`2<Document, SemanticModel>> GetDocumentWithFrozenPartialSemanticsAsync(Document document, CancellationToken cancellationToken);
    private static bool ValidatePossibleTriggerCharacterSet(CompletionTriggerKind completionTriggerKind, IEnumerable`1<CompletionProvider> triggeredProviders, Document document, SourceText text, int caretPosition, CompletionOptions& options);
    private static bool HasAnyItems(CompletionContext cc);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionService/<ComputeNonEmptyCompletionContextsAsync>d__33")]
private static Task`1<ImmutableArray`1<CompletionContext>> ComputeNonEmptyCompletionContextsAsync(Document document, int caretPosition, CompletionTrigger trigger, CompletionOptions options, TextSpan completionListSpan, ImmutableArray`1<CompletionProvider> providers, SharedSyntaxContextsWithSpeculativeModel sharedContext, CancellationToken cancellationToken);
    private CompletionList MergeAndPruneCompletionLists(ImmutableArray`1<CompletionContext> completionContexts, CompletionOptions& options, bool isExclusive);
    protected virtual bool ItemsMatch(CompletionItem item, CompletionItem existingItem);
    protected virtual CompletionItem GetBetterItem(CompletionItem item, CompletionItem existingItem);
    private static Dictionary`2<CompletionProvider, int> GetCompletionProviderToIndex(ConcatImmutableArray`1<CompletionProvider> completionProviders);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionService/<GetContextAsync>d__38")]
private static Task`1<CompletionContext> GetContextAsync(CompletionProvider provider, Document document, int position, CompletionTrigger triggerInfo, CompletionOptions options, TextSpan defaultSpan, SharedSyntaxContextsWithSpeculativeModel sharedContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.CompletionService/<<GetCompletionsAsync>g__GetAugmentingProvidersAsync|29_4>d")]
[CompilerGeneratedAttribute]
internal static Task`1<ImmutableArray`1<CompletionProvider>> <GetCompletionsAsync>g__GetAugmentingProvidersAsync|29_4(Document document, ImmutableArray`1<CompletionProvider> triggeredProviders, int caretPosition, CompletionTrigger trigger, CompletionOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use Microsoft.CodeAnalysis.Tags.WellKnownTags instead.")]
[EditorBrowsableAttribute("1")]
public static class Microsoft.CodeAnalysis.Completion.CompletionTags : object {
    public static string Public;
    public static string Protected;
    public static string Private;
    public static string Internal;
    public static string File;
    public static string Project;
    public static string Folder;
    public static string Assembly;
    public static string Class;
    public static string Constant;
    public static string Delegate;
    public static string Enum;
    public static string EnumMember;
    public static string Event;
    public static string ExtensionMethod;
    public static string Field;
    public static string Interface;
    public static string Intrinsic;
    public static string Keyword;
    public static string Label;
    public static string Local;
    public static string Namespace;
    public static string Method;
    public static string Module;
    public static string Operator;
    public static string Parameter;
    public static string Property;
    public static string RangeVariable;
    public static string Reference;
    public static string Structure;
    public static string TypeParameter;
    public static string Snippet;
    public static string Error;
    public static string Warning;
    internal static string StatusInformation;
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Completion.CompletionTrigger : ValueType {
    [CompilerGeneratedAttribute]
private CompletionTriggerKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Character>k__BackingField;
    [ObsoleteAttribute("Use 'Invoke' instead.")]
public static CompletionTrigger Default;
    public static CompletionTrigger Invoke;
    public CompletionTriggerKind Kind { get; }
    public char Character { get; }
    internal CompletionTrigger(CompletionTriggerKind kind, char character);
    private static CompletionTrigger();
    [CompilerGeneratedAttribute]
public CompletionTriggerKind get_Kind();
    [CompilerGeneratedAttribute]
public char get_Character();
    public static CompletionTrigger CreateInsertionTrigger(char insertedCharacter);
    public static CompletionTrigger CreateDeletionTrigger(char deletedCharacter);
}
public enum Microsoft.CodeAnalysis.Completion.CompletionTriggerKind : Enum {
    public int value__;
    [ObsoleteAttribute("Use 'Invoke' instead.")]
public static CompletionTriggerKind Other;
    public static CompletionTriggerKind Invoke;
    public static CompletionTriggerKind Insertion;
    public static CompletionTriggerKind Deletion;
    public static CompletionTriggerKind Snippets;
    public static CompletionTriggerKind InvokeAndCommitIfUnique;
}
public enum Microsoft.CodeAnalysis.Completion.EnterKeyRule : Enum {
    public int value__;
    public static EnterKeyRule Default;
    public static EnterKeyRule Never;
    public static EnterKeyRule Always;
    public static EnterKeyRule AfterFullyTypedWord;
}
internal enum Microsoft.CodeAnalysis.Completion.ExpandedCompletionMode : Enum {
    public int value__;
    public static ExpandedCompletionMode NonExpandedItemsOnly;
    public static ExpandedCompletionMode ExpandedItemsOnly;
    public static ExpandedCompletionMode AllItems;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Completion.ExportArgumentProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Roles>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public String[] Roles { get; public set; }
    public ExportArgumentProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public String[] get_Roles();
    [CompilerGeneratedAttribute]
public void set_Roles(String[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Completion.ExportCompletionProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Roles>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Roles { get; public set; }
    public ExportCompletionProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public String[] get_Roles();
    [CompilerGeneratedAttribute]
public void set_Roles(String[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.FileSystemCompletionHelper : object {
    private static Char[] s_windowsDirectorySeparator;
    private Glyph _folderGlyph;
    private Glyph _fileGlyph;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<string> _searchPaths;
    [NullableAttribute("2")]
private string _baseDirectory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<string> _allowableExtensions;
    private CompletionItemRules _itemRules;
    public FileSystemCompletionHelper(Glyph folderGlyph, Glyph fileGlyph, ImmutableArray`1<string> searchPaths, string baseDirectory, ImmutableArray`1<string> allowableExtensions, CompletionItemRules itemRules);
    private static FileSystemCompletionHelper();
    protected virtual String[] GetLogicalDrives();
    protected virtual bool DirectoryExists(string fullPath);
    protected virtual IEnumerable`1<string> EnumerateDirectories(string fullDirectoryPath);
    protected virtual IEnumerable`1<string> EnumerateFiles(string fullDirectoryPath);
    protected virtual bool IsVisibleFileSystemEntry(string fullPath);
    private CompletionItem CreateNetworkRoot();
    private CompletionItem CreateUnixRoot();
    private CompletionItem CreateFileSystemEntryItem(string fullPath, bool isDirectory);
    private CompletionItem CreateLogicalDriveItem(string drive);
    public Task`1<ImmutableArray`1<CompletionItem>> GetItemsAsync(string directoryPath, CancellationToken cancellationToken);
    private ImmutableArray`1<CompletionItem> GetItems(string directoryPath, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Completion.FileSystemCompletionHelper/<GetItemsInDirectory>d__19")]
private IEnumerable`1<CompletionItem> GetItemsInDirectory(string fullDirectoryPath, CancellationToken cancellationToken);
    internal TestAccessor GetTestAccessor();
}
internal interface Microsoft.CodeAnalysis.Completion.ICompletionProviderFactory {
    public abstract virtual ImmutableArray`1<CompletionProvider> GetCompletionProviders();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Completion.INotifyCommittingItemCompletionProvider {
    public abstract virtual Task NotifyCommittingItemAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.Log.CompletionProvidersLogger : object {
    private static StatisticLogAggregator`1<ActionInfo> s_statisticLogAggregator;
    private static CountLogAggregator`1<ActionInfo> s_countLogAggregator;
    private static HistogramLogAggregator`1<ActionInfo> s_histogramLogAggregator;
    private static CompletionProvidersLogger();
    internal static void LogTypeImportCompletionTicksDataPoint(TimeSpan elapsed);
    internal static void LogTypeImportCompletionItemCountDataPoint(int count);
    internal static void LogTypeImportCompletionReferenceCountDataPoint(int count);
    internal static void LogTypeImportCompletionCacheMiss();
    internal static void LogCommitOfTypeImportCompletionItem();
    internal static void LogExtensionMethodCompletionTicksDataPoint(TimeSpan total, TimeSpan getSymbols, TimeSpan createItems, Nullable`1<TimeSpan> remoteAssetSync);
    internal static void LogExtensionMethodCompletionMethodsProvidedDataPoint(int count);
    internal static void LogCommitOfExtensionMethodImportCompletionItem();
    internal static void LogExtensionMethodCompletionPartialResultCount();
    internal static void LogCommitUsingSemicolonToAddParenthesis();
    internal static void LogCommitUsingDotToAddParenthesis();
    internal static void LogCustomizedCommitToAddParenthesis(Nullable`1<char> commitChar);
    internal static void ReportTelemetry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.LSPCompletionProvider : CommonCompletionProvider {
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public abstract virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
public static class Microsoft.CodeAnalysis.Completion.MatchPriority : object {
    internal static int Deprioritize;
    public static int Default;
    public static int Preselect;
    private static MatchPriority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Completion.MatchResult : ValueType {
    public CompletionItem CompletionItem;
    public Nullable`1<PatternMatch> PatternMatch;
    public bool ShouldBeConsideredMatchingFilterText;
    public int IndexInOriginalSortedOrder;
    public int RecentItemIndex;
    [NullableAttribute("2")]
public string MatchedAdditionalFilterText;
    [CompilerGeneratedAttribute]
private static IComparer`1<MatchResult> <SortingComparer>k__BackingField;
    public string FilterTextUsed { get; }
    public bool MatchedWithAdditionalFilterTexts { get; }
    public static IComparer`1<MatchResult> SortingComparer { get; }
    public MatchResult(CompletionItem completionItem, bool shouldBeConsideredMatchingFilterText, Nullable`1<PatternMatch> patternMatch, int index, string matchedAdditionalFilterText, int recentItemIndex);
    private static MatchResult();
    public string get_FilterTextUsed();
    public bool get_MatchedWithAdditionalFilterTexts();
    [CompilerGeneratedAttribute]
public static IComparer`1<MatchResult> get_SortingComparer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.PatternMatchHelper : object {
    private static CultureInfo EnUSCultureInfo;
    private object _gate;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<CultureInfo, bool>, PatternMatcher> _patternMatcherMap;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; }
    public PatternMatchHelper(string pattern);
    private static PatternMatchHelper();
    [CompilerGeneratedAttribute]
public string get_Pattern();
    public ImmutableArray`1<TextSpan> GetHighlightedSpans(string text, CultureInfo culture);
    public Nullable`1<PatternMatch> GetMatch(string text, bool includeMatchSpans, CultureInfo culture);
    private PatternMatcher GetPatternMatcher(CultureInfo culture, bool includeMatchedSpans);
    public MatchResult GetMatchResult(CompletionItem item, bool includeMatchSpans, CultureInfo culture);
    public bool MatchesPattern(CompletionItem item, CultureInfo culture);
    public bool TryCreateMatchResult(CompletionItem item, CompletionTriggerKind initialTriggerKind, CompletionFilterReason filterReason, int recentItemIndex, bool includeMatchSpans, int currentIndex, MatchResult& matchResult);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <TryCreateMatchResult>g__ShouldBeConsideredMatchingFilterText|13_0(string filterText, int matchPriority, CompletionTriggerKind initialTriggerKind, CompletionFilterReason filterReason, int recentItemIndex, Nullable`1<PatternMatch> patternMatch);
    [CompilerGeneratedAttribute]
internal static bool <TryCreateMatchResult>g__KeepAllItemsInTheList|13_1(CompletionTriggerKind initialTriggerKind, string filterText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractAggregateEmbeddedLanguageCompletionProvider : LSPCompletionProvider {
    public static string EmbeddedProviderName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IEmbeddedLanguage> _languageProviders;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected AbstractAggregateEmbeddedLanguageCompletionProvider(IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> languageServices, string languageName);
    private static ImmutableHashSet`1<char> GetTriggerCharactersForEmbeddedLanguage(IEmbeddedLanguage language);
    private static bool IsEmbeddedLanguageProvider(Lazy`2<ILanguageService, LanguageServiceMetadata> lazyLanguageService, string languageName, string embeddedLanguageServiceType);
    [NullableContextAttribute("2")]
protected ImmutableArray`1<IEmbeddedLanguage> GetLanguageProviders(LanguageServices languageServices);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    internal sealed virtual bool ShouldTriggerCompletion(LanguageServices languageServices, SourceText text, int caretPosition, CompletionTrigger trigger, CompletionOptions options, OptionSet passThroughOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractAggregateEmbeddedLanguageCompletionProvider/<ProvideCompletionsAsync>d__10")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    internal virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    private IEmbeddedLanguage GetLanguage(CompletionItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider : LSPCompletionProvider {
    private static string AwaitCompletionTargetTokenPosition;
    private static string AppendConfigureAwait;
    private static string MakeContainerAsync;
    private static string AddAwaitAtCurrentPosition;
    private string _awaitKeyword;
    private string _awaitfDisplayText;
    private string _awaitfFilterText;
    private string _falseKeyword;
    protected AbstractAwaitCompletionProvider(ISyntaxFacts syntaxFacts);
    protected abstract virtual int GetSpanStart(SyntaxNode declaration);
    [NullableContextAttribute("2")]
protected abstract virtual SyntaxNode GetAsyncSupportingDeclaration(SyntaxToken token);
    protected abstract virtual ITypeSymbol GetTypeSymbolOfExpression(SemanticModel semanticModel, SyntaxNode potentialAwaitableExpression, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetExpressionToPlaceAwaitInFrontOf(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected abstract virtual Nullable`1<SyntaxToken> GetDotTokenLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual bool IsAwaitKeywordContext(SyntaxContext syntaxContext);
    private static bool IsConfigureAwaitable(Compilation compilation, ITypeSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider/<ProvideCompletionsAsync>d__17")]
public sealed virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractAwaitCompletionProvider/<GetChangeAsync>d__18")]
public sealed virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    private DotAwaitContext GetDotAwaitKeywordContext(SyntaxContext syntaxContext, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static CompletionItem <ProvideCompletionsAsync>g__CreateCompletionItem|17_0(ImmutableArray`1<KeyValuePair`2<string, string>> completionProperties, string displayText, string filterText, string tooltip, bool isComplexTextEdit, bool appendConfigureAwait);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<CompletionChange> <>n__0(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractCrefCompletionProvider : LSPCompletionProvider {
    protected static string HideAdvancedMembers;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractCrefCompletionProvider/<GetDescriptionWorkerAsync>d__1")]
internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ValueTuple`3<SyntaxToken, SemanticModel, ImmutableArray`1<ISymbol>>> GetSymbolsAsync(Document document, int position, CompletionOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractDirectivePathCompletionProvider : CompletionProvider {
    protected string DirectiveName { get; }
    protected static bool IsDirectorySeparator(char ch);
    protected abstract virtual bool TryGetStringLiteralToken(SyntaxTree tree, int position, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
    protected abstract virtual string get_DirectiveName();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractDirectivePathCompletionProvider/<ProvideCompletionsAsync>d__4")]
public sealed virtual Task ProvideCompletionsAsync(CompletionContext context);
    public sealed virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    private static string GetPathThroughLastSlash(string quotedPath, int quotedPathStart, int position);
    private static TextSpan GetTextChangeSpan(string quotedPath, int quotedPathStart, int position);
    private static bool EndsWithQuote(string quotedPath);
    private static int AfterLastSlashIndex(string text, int position);
    protected abstract virtual Task ProvideCompletionsAsync(CompletionContext context, string pathThroughLastSlash);
    protected static FileSystemCompletionHelper GetFileSystemCompletionHelper(Document document, Glyph itemGlyph, ImmutableArray`1<string> extensions, CompletionItemRules completionRules);
    [NullableContextAttribute("2")]
private static string GetBaseDirectory(Document document, string baseDirectory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractDocCommentCompletionProvider`1 : LSPCompletionProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_listTagNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_listHeaderTagNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_nestedTagNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_topLevelRepeatableTagNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_topLevelSingleUseTagNames;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, ValueTuple`4<string, string, string, string>> s_tagMap;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`3<string, string, string>> s_attributeMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_listTypeValues;
    private CompletionItemRules defaultRules;
    private static CharacterSetModificationRule WithoutQuoteRule;
    private static CharacterSetModificationRule WithoutSpaceRule;
    [NullableAttribute("0")]
protected static ImmutableArray`1<CharacterSetModificationRule> FilterRules;
    protected AbstractDocCommentCompletionProvider`1(CompletionItemRules defaultRules);
    private static AbstractDocCommentCompletionProvider`1();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractDocCommentCompletionProvider`1/<ProvideCompletionsAsync>d__10")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected abstract virtual Task`1<IEnumerable`1<CompletionItem>> GetItemsWorkerAsync(Document document, int position, CompletionTrigger trigger, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<string> GetExistingTopLevelElementNames(TSyntax syntax);
    protected abstract virtual IEnumerable`1<string> GetExistingTopLevelAttributeValues(TSyntax syntax, string tagName, string attributeName);
    protected abstract virtual ImmutableArray`1<string> GetKeywordNames();
    protected abstract virtual ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    private CompletionItem GetItem(string name);
    protected IEnumerable`1<CompletionItem> GetAttributeItems(string tagName, ISet`1<string> existingAttributes, bool addEqualsAndQuotes);
    protected IEnumerable`1<CompletionItem> GetAlwaysVisibleItems();
    private CompletionItem GetCommentItem();
    private CompletionItem GetCDataItem();
    protected IEnumerable`1<CompletionItem> GetNestedItems(ISymbol symbol, bool includeKeywords);
    private IEnumerable`1<CompletionItem> GetParamRefItems(ISymbol symbol);
    private IEnumerable`1<CompletionItem> GetTypeParamRefItems(ISymbol symbol);
    protected IEnumerable`1<CompletionItem> GetAttributeValueItems(ISymbol symbol, string tagName, string attributeName);
    protected ImmutableArray`1<CompletionItem> GetTopLevelItems(ISymbol symbol, TSyntax syntax);
    protected IEnumerable`1<CompletionItem> GetItemTagItems();
    protected IEnumerable`1<CompletionItem> GetListItems();
    protected IEnumerable`1<CompletionItem> GetListHeaderItems();
    private IEnumerable`1<CompletionItem> GetParameterItems(ImmutableArray`1<TSymbol> symbols, TSyntax syntax, string tagName);
    private static string FormatParameter(string kind, string name);
    private static string FormatParameterRefTag(string kind, string name);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractDocCommentCompletionProvider`1/<GetChangeAsync>d__32")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitChar, CancellationToken cancellationToken);
    private CompletionItem CreateCompletionItem(string displayText);
    private CompletionItem CreateLangwordCompletionItem(string displayText);
    protected CompletionItem CreateCompletionItem(string displayText, string beforeCaretText, string afterCaretText);
    private CompletionItemRules GetCompletionItemRules(string displayText);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private CompletionItem <GetParamRefItems>b__22_1(string p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private CompletionItem <GetTypeParamRefItems>b__23_1(string t);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private CompletionItem <GetAttributeValueItems>b__24_0(IParameterSymbol parameter);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private CompletionItem <GetAttributeValueItems>b__24_1(ITypeParameterSymbol typeParameter);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private CompletionItem <GetAttributeValueItems>b__24_2(ITypeParameterSymbol typeParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractExtensionMethodImportCompletionProvider : AbstractImportCompletionProvider {
    protected string GenericSuffix { get; }
    protected abstract virtual string get_GenericSuffix();
    protected virtual bool ShouldProvideCompletion(CompletionContext completionContext, SyntaxContext syntaxContext);
    protected virtual void LogCommit();
    protected virtual void WarmUpCacheInBackground(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractExtensionMethodImportCompletionProvider/<AddCompletionItemsAsync>d__5")]
protected virtual Task AddCompletionItemsAsync(CompletionContext completionContext, SyntaxContext syntaxContext, HashSet`1<string> namespaceInScope, CancellationToken cancellationToken);
    private static bool TryGetReceiverTypeSymbol(SyntaxContext syntaxContext, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, ITypeSymbol& receiverTypeSymbol);
    private static ITypeSymbol GetSymbolType(ISymbol symbol);
    private CompletionItem Convert(SerializableImportCompletionItem serializableItem, string receiverTypeSymbolKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionCacheServiceFactory`2 : object {
    private ConcurrentDictionary`2<string, TMetadataCacheEntry> _peItemsCache;
    private ConcurrentDictionary`2<ProjectId, TProjectCacheEntry> _projectItemsCache;
    private IAsynchronousOperationListenerProvider _listenerProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<ImmutableSegmentedList`1<Project>, CancellationToken, ValueTask> _processBatchAsync;
    private CancellationToken _disposalToken;
    protected AbstractImportCompletionCacheServiceFactory`2(IAsynchronousOperationListenerProvider listenerProvider, Func`3<ImmutableSegmentedList`1<Project>, CancellationToken, ValueTask> processBatchAsync, CancellationToken disposalToken);
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
    private void OnCacheFlushRequested(object sender, EventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionProvider : LSPCompletionProvider {
    internal bool IsExpandItemProvider { get; }
    protected abstract virtual bool ShouldProvideCompletion(CompletionContext completionContext, SyntaxContext syntaxContext);
    protected abstract virtual void WarmUpCacheInBackground(Document document);
    protected abstract virtual Task AddCompletionItemsAsync(CompletionContext completionContext, SyntaxContext syntaxContext, HashSet`1<string> namespacesInScope, CancellationToken cancellationToken);
    protected abstract virtual bool IsFinalSemicolonOfUsingOrExtern(SyntaxNode directive, SyntaxToken token);
    protected abstract virtual Task`1<bool> ShouldProvideParenthesisCompletionAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    protected abstract virtual void LogCommit();
    public sealed virtual Task NotifyCommittingItemAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    internal virtual bool get_IsExpandItemProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionProvider/<ProvideCompletionsAsync>d__9")]
public virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    private static HashSet`1<string> GetNamespacesInScope(SyntaxContext syntaxContext, CancellationToken cancellationToken);
    private static ImmutableArray`1<string> GetImportedNamespaces(SyntaxContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionProvider/<GetChangeAsync>d__12")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem completionItem, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractImportCompletionProvider/<IsInImportsDirectiveAsync>d__13")]
private Task`1<bool> IsInImportsDirectiveAsync(Document document, int position, CancellationToken cancellationToken);
    protected static bool IsAddingImportsSupported(Document document, CompletionOptions completionOptions);
    private static SyntaxNode CreateImport(Document document, string namespaceName);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider : LSPCompletionProvider {
    private static string ProjectGuidKey;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected abstract virtual IImmutableList`1<SyntaxNode> GetAssemblyScopedAttributeSyntaxNodesOfDocument(SyntaxNode documentRoot);
    protected abstract virtual SyntaxNode GetConstructorArgumentOfInternalsVisibleToAttribute(SyntaxNode internalsVisibleToAttribute);
    public sealed virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, CompletionOptions options);
    protected abstract virtual bool ShouldTriggerAfterQuotes(SourceText text, int insertedCharacterPosition);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<ProvideCompletionsAsync>d__8")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static SyntaxNode GetAttributeSyntaxNodeOfToken(ISyntaxFactsService syntaxFactsService, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<CheckTypeInfoOfAttributeAsync>d__10")]
private static Task`1<bool> CheckTypeInfoOfAttributeAsync(Document document, SyntaxNode attributeNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<AddAssemblyCompletionItemsAsync>d__11")]
private Task AddAssemblyCompletionItemsAsync(CompletionContext context, CancellationToken cancellationToken);
    private static bool IsProjectTypeUnsupported(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetAllInternalsVisibleToAssemblyNamesOfProjectAsync>d__13")]
private Task`1<IImmutableSet`1<string>> GetAllInternalsVisibleToAssemblyNamesOfProjectAsync(CompletionContext completionContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetAssemblyNameFromInternalsVisibleToAttributeAsync>d__14")]
private Task`1<string> GetAssemblyNameFromInternalsVisibleToAttributeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetTextChangeSpanAsync>d__15")]
private static Task`1<TextSpan> GetTextChangeSpanAsync(Document document, TextSpan startSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetChangeAsync>d__16")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractInternalsVisibleToCompletionProvider/<GetPublicKeyOfProjectAsync>d__17")]
private static Task`1<string> GetPublicKeyOfProjectAsync(Project project, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static string GetPublicKeyAsHexString(ImmutableArray`1<byte> publicKey);
    [CompilerGeneratedAttribute]
internal static bool <GetTextChangeSpanAsync>g__IsWordCharacter|15_0(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractKeywordCompletionProvider`1 : LSPCompletionProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Comparer<TContext> s_comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IKeywordRecommender`1<TContext>> _keywordRecommenders;
    protected AbstractKeywordCompletionProvider`1(ImmutableArray`1<IKeywordRecommender`1<TContext>> keywordRecommenders);
    private static AbstractKeywordCompletionProvider`1();
    protected abstract virtual CompletionItem CreateItem(RecommendedKeyword keyword, TContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractKeywordCompletionProvider`1/<ProvideCompletionsAsync>d__4")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractKeywordCompletionProvider`1/<RecommendCompletionItemsAsync>d__5")]
private Task`1<ImmutableArray`1<CompletionItem>> RecommendCompletionItemsAsync(Document document, CompletionContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractKeywordCompletionProvider`1/<RecommendKeywordsAsync>d__6")]
private Task`1<ImmutableArray`1<RecommendedKeyword>> RecommendKeywordsAsync(Document document, int position, TContext context, CancellationToken cancellationToken);
    public sealed virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem item, Nullable`1<char> ch, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractLoadDirectiveCompletionProvider : AbstractDirectivePathCompletionProvider {
    private static CompletionItemRules s_rules;
    private static AbstractLoadDirectiveCompletionProvider();
    private static ImmutableArray`1<char> GetCommitCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractLoadDirectiveCompletionProvider/<ProvideCompletionsAsync>d__2")]
protected virtual Task ProvideCompletionsAsync(CompletionContext context, string pathThroughLastSlash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider : LSPCompletionProvider {
    private SyntaxAnnotation _annotation;
    private SyntaxAnnotation _otherAnnotation;
    [NullableAttribute("0")]
private static ImmutableArray`1<CharacterSetModificationRule> s_commitRules;
    [NullableAttribute("0")]
private static ImmutableArray`1<CharacterSetModificationRule> s_filterRules;
    private static CompletionItemRules s_defaultRules;
    private static AbstractMemberInsertingCompletionProvider();
    protected abstract virtual SyntaxToken GetToken(CompletionItem completionItem, SyntaxTree tree, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ISymbol> GenerateMemberAsync(ISymbol member, INamedTypeSymbol containingType, Document document, CompletionItem item, CancellationToken cancellationToken);
    protected abstract virtual int GetTargetCaretPosition(SyntaxNode caretTarget);
    protected abstract virtual SyntaxNode GetSyntax(SyntaxToken commonSyntaxToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<GetChangeAsync>d__7")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<DetermineNewDocumentAsync>d__8")]
private Task`1<Document> DetermineNewDocumentAsync(Document document, CompletionItem completionItem, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<GenerateMemberAndUsingsAsync>d__9")]
private Task`1<Document> GenerateMemberAndUsingsAsync(Document document, CompletionItem completionItem, TextLine line, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private TextSpan ComputeDestinationSpan(SyntaxNode insertionRoot);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<GenerateInsertionTextAsync>d__11")]
private Task`1<string> GenerateInsertionTextAsync(Document memberContainingDocument, CodeCleanupOptions cleanupOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractMemberInsertingCompletionProvider/<GetTreeWithAddedSyntaxNodeRemovedAsync>d__12")]
private Task`1<SyntaxNode> GetTreeWithAddedSyntaxNodeRemovedAsync(Document document, CodeCleanupOptions cleanupOptions, CancellationToken cancellationToken);
    protected static CompletionItemRules GetRules();
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractObjectCreationCompletionProvider`1 : AbstractSymbolCompletionProvider`1<TSyntaxContext> {
    protected abstract virtual SyntaxNode GetObjectCreationNewExpression(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected abstract virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbols);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbols, TSyntaxContext context, SupportedPlatformData supportedPlatformData);
    protected virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, TSyntaxContext context, int position, CompletionOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractObjectInitializerCompletionProvider : LSPCompletionProvider {
    private static CompletionItemRules s_rules;
    private static AbstractObjectInitializerCompletionProvider();
    protected abstract virtual Tuple`2<ITypeSymbol, Location> GetInitializedType(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    protected abstract virtual HashSet`1<string> GetInitializedMembers(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected abstract virtual string EscapeIdentifier(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractObjectInitializerCompletionProvider/<ProvideCompletionsAsync>d__3")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    protected abstract virtual Task`1<bool> IsExclusiveAsync(Document document, int position, CancellationToken cancellationToken);
    private static bool IsLegalFieldOrProperty(ISymbol symbol);
    protected virtual bool IsInitializable(ISymbol member, INamedTypeSymbol containingType);
    private static bool CanSupportObjectInitializer(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractOverrideCompletionProvider : AbstractMemberInsertingCompletionProvider {
    public abstract virtual SyntaxToken FindStartingToken(SyntaxTree tree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual ImmutableArray`1<ISymbol> FilterOverrides(ImmutableArray`1<ISymbol> members, ITypeSymbol returnType);
    public abstract virtual bool TryDetermineModifiers(SyntaxToken startToken, SourceText text, int startLine, Accessibility& seenAccessibility, DeclarationModifiers& modifiers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractOverrideCompletionProvider/<ProvideCompletionsAsync>d__4")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected virtual Task`1<ISymbol> GenerateMemberAsync(ISymbol newOverriddenMember, INamedTypeSymbol newContainingType, Document newDocument, CompletionItem completionItem, CancellationToken cancellationToken);
    public abstract virtual bool TryDetermineReturnType(SyntaxToken startToken, SemanticModel semanticModel, CancellationToken cancellationToken, ITypeSymbol& returnType, SyntaxToken& nextToken);
    protected static bool IsOnStartLine(int position, SourceText text, int startLine);
    protected static ITypeSymbol GetReturnType(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialMethodCompletionProvider : AbstractMemberInsertingCompletionProvider {
    protected static SymbolDisplayFormat SignatureDisplayFormat;
    private static AbstractPartialMethodCompletionProvider();
    protected abstract virtual bool IncludeAccessibility(IMethodSymbol method, CancellationToken cancellationToken);
    protected abstract virtual bool IsPartialMethodCompletionContext(SyntaxTree tree, int position, CancellationToken cancellationToken, DeclarationModifiers& modifiers, SyntaxToken& token);
    protected abstract virtual string GetDisplayText(IMethodSymbol method, SemanticModel semanticModel, int position);
    protected abstract virtual bool IsPartial(IMethodSymbol method);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialMethodCompletionProvider/<ProvideCompletionsAsync>d__6")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialMethodCompletionProvider/<GenerateMemberAsync>d__7")]
protected virtual Task`1<ISymbol> GenerateMemberAsync(ISymbol member, INamedTypeSymbol containingType, Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialMethodCompletionProvider/<CreatePartialItemsAsync>d__8")]
protected Task`1<IEnumerable`1<CompletionItem>> CreatePartialItemsAsync(Document document, int position, TextSpan span, DeclarationModifiers modifiers, SyntaxToken token, CancellationToken cancellationToken);
    private CompletionItem CreateItem(IMethodSymbol method, int line, TextSpan span, SemanticModel semanticModel, DeclarationModifiers modifiers, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialTypeCompletionProvider`1 : LSPCompletionProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPartialTypeCompletionProvider`1/<ProvideCompletionsAsync>d__1")]
public sealed virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    private CompletionItem CreateCompletionItem(INamedTypeSymbol symbol, TSyntaxContext context);
    protected abstract virtual ImmutableArray`1<KeyValuePair`2<string, string>> GetProperties(INamedTypeSymbol symbol, TSyntaxContext context);
    protected abstract virtual SyntaxNode GetPartialTypeSyntaxNode(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected abstract virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(INamedTypeSymbol symbol, TSyntaxContext context);
    protected virtual IEnumerable`1<INamedTypeSymbol> LookupCandidateSymbols(TSyntaxContext context, INamedTypeSymbol declaredSymbol, CancellationToken cancellationToken);
    private static bool InSameProject(INamedTypeSymbol symbol, Compilation compilation);
    private static bool NotNewDeclaredMember(INamedTypeSymbol symbol, TSyntaxContext context);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractPreprocessorCompletionProvider : LSPCompletionProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractPreprocessorCompletionProvider/<ProvideCompletionsAsync>d__0")]
public sealed virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1 : AbstractSymbolCompletionProvider`1<TSyntaxContext> {
    protected CompletionItemSelectionBehavior PreselectedItemSelectionBehavior { get; }
    protected abstract virtual Task`1<bool> ShouldPreselectInferredTypesAsync(CompletionContext completionContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    protected abstract virtual Task`1<bool> ShouldProvideAvailableSymbolsInCurrentContextAsync(CompletionContext completionContext, TSyntaxContext context, int position, CompletionOptions options, CancellationToken cancellationToken);
    protected abstract virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbols, TSyntaxContext context);
    protected abstract virtual CompletionItemSelectionBehavior get_PreselectedItemSelectionBehavior();
    protected abstract virtual bool IsInstrinsic(ISymbol symbol);
    protected abstract virtual bool IsTriggerOnDot(SyntaxToken token, int characterPosition);
    protected abstract virtual string GetFilterText(ISymbol symbol, string displayText, TSyntaxContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1/<GetSymbolsAsync>d__8")]
protected sealed virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, TSyntaxContext context, int position, CompletionOptions options, CancellationToken cancellationToken);
    private static bool IsValidForTaskLikeTypeOnlyContext(ISymbol symbol, TSyntaxContext context);
    private static bool IsValidForGenericConstraintContext(ISymbol symbol);
    private static ITypeSymbol GetSymbolType(ISymbol symbol);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbols, TSyntaxContext context, SupportedPlatformData supportedPlatformData);
    private static bool ShouldSoftSelectInArgumentList(CompletionContext completionContext, TSyntaxContext context, bool preselect);
    private static bool IsArgumentListTriggerCharacter(char character);
    private static int ComputeSymbolMatchPriority(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1/<GetDescriptionWorkerAsync>d__16")]
internal sealed virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1/<IsSemanticTriggerCharacterAsync>d__17")]
protected sealed virtual Task`1<bool> IsSemanticTriggerCharacterAsync(Document document, int characterPosition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractRecommendationServiceBasedCompletionProvider`1/<IsTriggerOnDotAsync>d__18")]
protected Task`1<Nullable`1<bool>> IsTriggerOnDotAsync(Document document, int characterPosition, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetDescriptionWorkerAsync>g__SymbolMatches|16_1(SymbolAndSelectionInfo<TSyntaxContext> info, string name, Nullable`1<SymbolKind> kind, bool isGeneric);
}
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractReferenceDirectiveCompletionProvider : AbstractDirectivePathCompletionProvider {
    private static CompletionItemRules s_rules;
    private static Char[] s_pathIndicators;
    private static AbstractReferenceDirectiveCompletionProvider();
    private static ImmutableArray`1<char> GetCommitCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractReferenceDirectiveCompletionProvider/<ProvideCompletionsAsync>d__3")]
protected virtual Task ProvideCompletionsAsync(CompletionContext context, string pathThroughLastSlash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractSuggestionModeCompletionProvider : LSPCompletionProvider {
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    protected abstract virtual Task`1<CompletionItem> GetSuggestionModeItemAsync(Document document, int position, TextSpan span, CompletionTrigger triggerInfo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSuggestionModeCompletionProvider/<ProvideCompletionsAsync>d__1")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected static CompletionItem CreateEmptySuggestionModeItem();
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1 : LSPCompletionProvider {
    protected abstract virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, TSyntaxContext context);
    protected abstract virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, TSyntaxContext syntaxContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    protected abstract virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbols, TSyntaxContext context, SupportedPlatformData supportedPlatformData);
    private static bool ShouldIncludeInTargetTypedCompletionList(ISymbol symbol, ImmutableArray`1<ITypeSymbol> inferredTypes, SemanticModel semanticModel, int position, Dictionary`2<ITypeSymbol, bool> typeConvertibilityCache);
    [NullableContextAttribute("0")]
private ImmutableArray`1<CompletionItem> CreateItems(CompletionContext completionContext, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbols, Func`2<SymbolAndSelectionInfo<TSyntaxContext>, TSyntaxContext> contextLookup, Dictionary`2<ISymbol, List`1<ProjectId>> invalidProjectMap, List`1<ProjectId> totalProjects);
    [NullableContextAttribute("0")]
protected static bool TryFindFirstSymbolMatchesTargetTypes(Func`2<SymbolAndSelectionInfo<TSyntaxContext>, TSyntaxContext> contextLookup, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbolList, Dictionary`2<ITypeSymbol, bool> typeConvertibilityCache, Int32& index);
    [NullableContextAttribute("0")]
private static SupportedPlatformData ComputeSupportedPlatformData(CompletionContext completionContext, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbols, Dictionary`2<ISymbol, List`1<ProjectId>> invalidProjectMap, List`1<ProjectId> totalProjects);
    protected static CompletionItem CreateItemDefault(string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>> symbols, TSyntaxContext context, SupportedPlatformData supportedPlatformData);
    protected static string GetFilterTextDefault(ISymbol symbol, string displayText, TSyntaxContext context);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<ProvideCompletionsAsync>d__11")]
public virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<GetItemsAsync>d__12")]
private Task`1<ImmutableArray`1<CompletionItem>> GetItemsAsync(CompletionContext completionContext, TSyntaxContext syntaxContext, Document document, int position, CompletionOptions options, CancellationToken cancellationToken);
    protected virtual bool IsExclusive();
    protected virtual Task`1<bool> IsSemanticTriggerCharacterAsync(Document document, int characterPosition, CancellationToken cancellationToken);
    private static Dictionary`2<SymbolAndSelectionInfo<TSyntaxContext>, TSyntaxContext> UnionSymbols(ImmutableArray`1<ValueTuple`3<DocumentId, TSyntaxContext, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>>>> linkedContextSymbolLists);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<GetPerContextSymbolsAsync>d__16")]
private Task`1<ImmutableArray`1<ValueTuple`3<DocumentId, TSyntaxContext, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>>>>> GetPerContextSymbolsAsync(CompletionContext completionContext, Document document, CompletionOptions options, IEnumerable`1<DocumentId> relatedDocuments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractSymbolCompletionProvider`1/<TryGetSymbolsForContextAsync>d__17")]
protected Task`1<ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>>> TryGetSymbolsForContextAsync(CompletionContext completionContext, TSyntaxContext syntaxContext, CompletionOptions options, CancellationToken cancellationToken);
    private static Dictionary`2<ISymbol, List`1<ProjectId>> FindSymbolsMissingInLinkedContexts(Dictionary`2<SymbolAndSelectionInfo<TSyntaxContext>, TSyntaxContext> symbolToContext, ImmutableArray`1<ValueTuple`3<DocumentId, TSyntaxContext, ImmutableArray`1<SymbolAndSelectionInfo<TSyntaxContext>>>> linkedContextSymbolLists);
    public sealed virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    private string GetInsertionText(CompletionItem item, Nullable`1<char> ch);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionProvider`1 : AbstractImportCompletionProvider {
    protected virtual bool ShouldProvideCompletion(CompletionContext completionContext, SyntaxContext syntaxContext);
    protected virtual void LogCommit();
    protected virtual void WarmUpCacheInBackground(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionProvider`1/<AddCompletionItemsAsync>d__3")]
protected virtual Task AddCompletionItemsAsync(CompletionContext completionContext, SyntaxContext syntaxContext, HashSet`1<string> namespacesInScope, CancellationToken cancellationToken);
    private static MultiDictionary`2<string, string> GetAliasTypeDictionary(Document document, SyntaxContext syntaxContext, CancellationToken cancellationToken);
    private static void AddItems(ImmutableArray`1<CompletionItem> items, CompletionContext completionContext, HashSet`1<string> namespacesInScope, MultiDictionary`2<string, string> aliasTargetNamespaceToTypeNameMap, TelemetryCounter<AliasDeclarationTypeNode> counter);
    [CompilerGeneratedAttribute]
internal static bool <AddItems>g__ShouldAddItem|5_0(CompletionItem item, HashSet`1<string> namespacesInScope, MultiDictionary`2<string, string> aliasTargetNamespaceToTypeNameMap);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionService : object {
    [CompilerGeneratedAttribute]
private IImportCompletionCacheService`2<TypeImportCompletionCacheEntry, TypeImportCompletionCacheEntry> <CacheService>k__BackingField;
    private IImportCompletionCacheService`2<TypeImportCompletionCacheEntry, TypeImportCompletionCacheEntry> CacheService { get; }
    protected string GenericTypeSuffix { get; }
    protected bool IsCaseSensitive { get; }
    protected string Language { get; }
    internal AbstractTypeImportCompletionService(SolutionServices services);
    [CompilerGeneratedAttribute]
private IImportCompletionCacheService`2<TypeImportCompletionCacheEntry, TypeImportCompletionCacheEntry> get_CacheService();
    protected abstract virtual string get_GenericTypeSuffix();
    protected abstract virtual bool get_IsCaseSensitive();
    protected abstract virtual string get_Language();
    public sealed virtual void QueueCacheWarmUpTask(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionService/<GetAllTopLevelTypesAsync>d__11")]
public sealed virtual Task`1<ValueTuple`2<ImmutableArray`1<ImmutableArray`1<CompletionItem>>, bool>> GetAllTopLevelTypesAsync(SyntaxContext syntaxContext, bool forceCacheCreation, CompletionOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionService/<GetCacheEntriesAsync>d__12")]
private Task`1<ValueTuple`2<ImmutableArray`1<TypeImportCompletionCacheEntry>, bool>> GetCacheEntriesAsync(Project currentProject, Compilation originCompilation, bool forceCacheCreation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionService/<BatchUpdateCacheAsync>d__13")]
public static ValueTask BatchUpdateCacheAsync(ImmutableSegmentedList`1<Project> projects, CancellationToken cancellationToken);
    private static bool HasGlobalAlias(ImmutableArray`1<string> aliases);
    private static string GetPEReferenceCacheKey(PortableExecutableReference peReference);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.AbstractTypeImportCompletionService/<GetUpToDateCacheForProjectAsync>d__16")]
private Task`1<TypeImportCompletionCacheEntry> GetUpToDateCacheForProjectAsync(Project project, CancellationToken cancellationToken);
    private bool TryGetUpToDateCacheForPEReference(Compilation originCompilation, Solution solution, EditorBrowsableInfo editorBrowsableInfo, PortableExecutableReference peReference, CancellationToken cancellationToken, TypeImportCompletionCacheEntry& cacheEntry);
    private TypeImportCompletionCacheEntry CreateCacheWorker(TKey key, IAssemblySymbol assembly, Checksum checksum, IDictionary`2<TKey, TypeImportCompletionCacheEntry> cache, EditorBrowsableInfo editorBrowsableInfo, CancellationToken cancellationToken);
    private static string ConcatNamespace(string containingNamespace, string name);
    private static void GetCompletionItemsForTopLevelTypeDeclarations(INamespaceSymbol rootNamespaceSymbol, Builder builder, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <GetCompletionItemsForTopLevelTypeDeclarations>g__VisitNamespace|20_0(INamespaceSymbol symbol, string containingNamespace, Builder builder, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Completion.Providers.CompletionProviderMetadata : OrderableLanguageMetadata {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Roles>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Roles { get; }
    [NullableContextAttribute("1")]
public CompletionProviderMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public String[] get_Roles();
}
internal static class Microsoft.CodeAnalysis.Completion.Providers.CompletionUtilities : object {
    [NullableContextAttribute("1")]
public static bool IsTypeImplicitlyConvertible(Compilation compilation, ITypeSymbol sourceType, ImmutableArray`1<ITypeSymbol> targetTypes);
    public static ImmutableArray`1<Project> GetDistinctProjectsFromLatestSolutionSnapshot(ImmutableSegmentedList`1<Project> projects);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Completion.Providers.IImportCompletionCacheService`2<Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionCacheEntry,System.Object>", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Completion.Providers.DefaultExtensionMethodImportCompletionCacheServiceFactory : AbstractImportCompletionCacheServiceFactory`2<ExtensionMethodImportCompletionCacheEntry, object> {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DefaultExtensionMethodImportCompletionCacheServiceFactory(IAsynchronousOperationListenerProvider listenerProvider);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Completion.Providers.IImportCompletionCacheService`2<Microsoft.CodeAnalysis.Completion.Providers.TypeImportCompletionCacheEntry,Microsoft.CodeAnalysis.Completion.Providers.TypeImportCompletionCacheEntry>", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Completion.Providers.DefaultTypeImportCompletionCacheServiceFactory : AbstractImportCompletionCacheServiceFactory`2<TypeImportCompletionCacheEntry, TypeImportCompletionCacheEntry> {
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DefaultTypeImportCompletionCacheServiceFactory(IAsynchronousOperationListenerProvider listenerProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.EmbeddedLanguageCompletionProvider : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    public abstract virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public abstract virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger);
    public abstract virtual Task ProvideCompletionsAsync(CompletionContext context);
    public abstract virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public abstract virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionCacheEntry : ValueType {
    [CompilerGeneratedAttribute]
private Checksum <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private MultiDictionary`2<string, DeclaredSymbolInfo> <ReceiverTypeNameToExtensionMethodMap>k__BackingField;
    public Checksum Checksum { get; }
    public string Language { get; }
    public MultiDictionary`2<string, DeclaredSymbolInfo> ReceiverTypeNameToExtensionMethodMap { get; }
    public bool ContainsExtensionMethod { get; }
    private ExtensionMethodImportCompletionCacheEntry(Checksum checksum, string language, MultiDictionary`2<string, DeclaredSymbolInfo> receiverTypeNameToExtensionMethodMap);
    [CompilerGeneratedAttribute]
public Checksum get_Checksum();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public MultiDictionary`2<string, DeclaredSymbolInfo> get_ReceiverTypeNameToExtensionMethodMap();
    public bool get_ContainsExtensionMethod();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper/<WarmUpCacheAsync>d__0")]
public static Task WarmUpCacheAsync(Project project, CancellationToken cancellationToken);
    public static void WarmUpCacheInCurrentProcess(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper/<GetUnimportedExtensionMethodsAsync>d__2")]
public static Task`1<SerializableUnimportedExtensionMethods> GetUnimportedExtensionMethodsAsync(SyntaxContext syntaxContext, ITypeSymbol receiverTypeSymbol, ISet`1<string> namespaceInScope, ImmutableArray`1<ITypeSymbol> targetTypesSymbols, bool forceCacheCreation, bool hideAdvancedMembers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper/<GetUnimportedExtensionMethodsInCurrentProcessAsync>d__3")]
public static Task`1<SerializableUnimportedExtensionMethods> GetUnimportedExtensionMethodsInCurrentProcessAsync(Document document, SemanticModel semanticModel, int position, ITypeSymbol receiverTypeSymbol, ISet`1<string> namespaceInScope, ImmutableArray`1<ITypeSymbol> targetTypes, bool forceCacheCreation, bool hideAdvancedMembers, Nullable`1<TimeSpan> remoteAssetSyncTime, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper/<BatchUpdateCacheAsync>d__4")]
public static ValueTask BatchUpdateCacheAsync(ImmutableSegmentedList`1<Project> projects, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SerializableImportCompletionItem> ConvertSymbolsToCompletionItems(Compilation compilation, ImmutableArray`1<IMethodSymbol> extentsionMethodSymbols, ImmutableArray`1<ITypeSymbol> targetTypeSymbols, CancellationToken cancellationToken);
    private static bool ShouldIncludeInTargetTypedCompletion(Compilation compilation, IMethodSymbol methodSymbol, ImmutableArray`1<ITypeSymbol> targetTypeSymbols, Dictionary`2<ITypeSymbol, bool> typeConvertibilityCache);
    private static string GetFullyQualifiedNamespaceName(INamespaceSymbol symbol, Dictionary`2<INamespaceSymbol, string> stringCache);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ExtensionMethodImportCompletionHelper/<GetUpToDateCacheEntryAsync>d__8")]
private static Task`1<ExtensionMethodImportCompletionCacheEntry> GetUpToDateCacheEntryAsync(Project project, IImportCompletionCacheService`2<ExtensionMethodImportCompletionCacheEntry, object> cacheService, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Completion.Providers.GlobalAssemblyCacheCompletionHelper : object {
    private static Lazy`1<List`1<string>> s_lazyAssemblySimpleNames;
    private CompletionItemRules _itemRules;
    public GlobalAssemblyCacheCompletionHelper(CompletionItemRules itemRules);
    private static GlobalAssemblyCacheCompletionHelper();
    public Task`1<ImmutableArray`1<CompletionItem>> GetItemsAsync(string directoryPath, CancellationToken cancellationToken);
    internal ImmutableArray`1<CompletionItem> GetItems(string directoryPath, CancellationToken cancellationToken);
    private static IEnumerable`1<AssemblyIdentity> GetAssemblyIdentities(string partialName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Completion.Providers.IImportCompletionCacheService`2 {
    public IDictionary`2<string, TPortableExecutable> PEItemsCache { get; }
    public IDictionary`2<ProjectId, TProject> ProjectItemsCache { get; }
    public AsyncBatchingWorkQueue`1<Project> WorkQueue { get; }
    public abstract virtual IDictionary`2<string, TPortableExecutable> get_PEItemsCache();
    public abstract virtual IDictionary`2<ProjectId, TProject> get_ProjectItemsCache();
    public abstract virtual AsyncBatchingWorkQueue`1<Project> get_WorkQueue();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Completion.Providers.IKeywordRecommender`1 {
    public abstract virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, TContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.Providers.ImportCompletionItem : object {
    private static string OtherNamespaceSortTextFormat;
    private static string SystemNamespaceSortTextFormat;
    private static string TypeAritySuffixName;
    private static string AttributeFullName;
    private static string MethodKey;
    private static string ReceiverKey;
    private static string OverloadCountKey;
    private static string AlwaysFullyQualifyKey;
    public static CompletionItem Create(string name, int arity, string containingNamespace, Glyph glyph, string genericTypeSuffix, CompletionItemFlags flags, Nullable`1<ValueTuple`3<string, string, int>> extensionMethodData, bool includedInTargetTypeCompletion);
    public static CompletionItem CreateAttributeItemWithoutSuffix(CompletionItem attributeItem, string attributeNameWithoutSuffix, CompletionItemFlags flags);
    private static string GetSortTextFormatString(string containingNamespace);
    public static CompletionItem CreateItemWithGenericDisplaySuffix(CompletionItem item, string genericTypeSuffix);
    public static string GetContainingNamespace(CompletionItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.ImportCompletionItem/<GetCompletionDescriptionAsync>d__13")]
public static Task`1<CompletionDescription> GetCompletionDescriptionAsync(Document document, CompletionItem item, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    public static string GetTypeName(CompletionItem item);
    private static string GetFullyQualifiedName(string namespaceName, string typeName);
    private static ValueTuple`2<ISymbol, int> GetSymbolAndOverloadCount(CompletionItem item, Compilation compilation);
    public static CompletionItem MarkItemToAlwaysFullyQualify(CompletionItem item);
    public static bool ShouldAlwaysFullyQualify(CompletionItem item);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Completion.Providers.IRemoteExtensionMethodImportCompletionService {
    public abstract virtual ValueTask`1<SerializableUnimportedExtensionMethods> GetUnimportedExtensionMethodsAsync(Checksum solutionChecksum, DocumentId documentId, int position, string receiverTypeSymbolKeyData, ImmutableArray`1<string> namespaceInScope, ImmutableArray`1<string> targetTypesSymbolKeyData, bool forceCacheCreation, bool hideAdvancedMembers, CancellationToken cancellationToken);
    public abstract virtual ValueTask WarmUpCacheAsync(Checksum solutionChecksum, ProjectId projectId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Completion.Providers.ITypeImportCompletionService {
    public abstract virtual Task`1<ValueTuple`2<ImmutableArray`1<ImmutableArray`1<CompletionItem>>, bool>> GetAllTopLevelTypesAsync(SyntaxContext syntaxContext, bool forceCacheCreation, CompletionOptions options, CancellationToken cancellationToken);
    public abstract virtual void QueueCacheWarmUpTask(Project project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.Providers.MemberInsertionCompletionItem : object {
    public static CompletionItem Create(string displayText, string displayTextSuffix, DeclarationModifiers modifiers, int line, ISymbol symbol, SyntaxToken token, int descriptionPosition, CompletionItemRules rules);
    public static Task`1<CompletionDescription> GetDescriptionAsync(CompletionItem item, Document document, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    public static DeclarationModifiers GetModifiers(CompletionItem item);
    public static int GetLine(CompletionItem item);
    public static int GetTokenSpanEnd(CompletionItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.Providers.RecommendedKeyword : object {
    [CompilerGeneratedAttribute]
private Glyph <Glyph>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyword>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<CancellationToken, ImmutableArray`1<SymbolDisplayPart>> <DescriptionFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIntrinsic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldFormatOnCommit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MatchPriority>k__BackingField;
    public Glyph Glyph { get; }
    public string Keyword { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<CancellationToken, ImmutableArray`1<SymbolDisplayPart>> DescriptionFactory { get; }
    public bool IsIntrinsic { get; }
    public bool ShouldFormatOnCommit { get; }
    public int MatchPriority { get; }
    public RecommendedKeyword(string keyword, Glyph glyph, Func`2<CancellationToken, ImmutableArray`1<SymbolDisplayPart>> descriptionFactory, bool isIntrinsic, bool shouldFormatOnCommit, Nullable`1<int> matchPriority);
    public RecommendedKeyword(string keyword, string toolTip, Glyph glyph, bool isIntrinsic, bool shouldFormatOnCommit, Nullable`1<int> matchPriority);
    [CompilerGeneratedAttribute]
public Glyph get_Glyph();
    [CompilerGeneratedAttribute]
public string get_Keyword();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, ImmutableArray`1<SymbolDisplayPart>> get_DescriptionFactory();
    [CompilerGeneratedAttribute]
public bool get_IsIntrinsic();
    [CompilerGeneratedAttribute]
public bool get_ShouldFormatOnCommit();
    [CompilerGeneratedAttribute]
public int get_MatchPriority();
    internal static ImmutableArray`1<SymbolDisplayPart> CreateDisplayParts(string keyword, string toolTip);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Completion.Providers.SerializableImportCompletionItem : ValueType {
    [DataMemberAttribute]
public string SymbolKeyData;
    [DataMemberAttribute]
public string Name;
    [DataMemberAttribute]
public int Arity;
    [DataMemberAttribute]
public Glyph Glyph;
    [DataMemberAttribute]
public string ContainingNamespace;
    [DataMemberAttribute]
public int AdditionalOverloadCount;
    [DataMemberAttribute]
public bool IncludedInTargetTypeCompletion;
    public SerializableImportCompletionItem(string symbolKeyData, string name, int arity, Glyph glyph, string containingNamespace, int additionalOverloadCount, bool includedInTargetTypeCompletion);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Completion.Providers.SerializableUnimportedExtensionMethods : object {
    [DataMemberAttribute]
public ImmutableArray`1<SerializableImportCompletionItem> CompletionItems;
    [DataMemberAttribute]
public bool IsPartialResult;
    [CompilerGeneratedAttribute]
private TimeSpan <GetSymbolsTime>k__BackingField;
    [DataMemberAttribute]
public TimeSpan CreateItemsTime;
    [DataMemberAttribute]
public Nullable`1<TimeSpan> RemoteAssetSyncTime;
    [DataMemberAttribute]
public TimeSpan GetSymbolsTime { get; public set; }
    public SerializableUnimportedExtensionMethods(ImmutableArray`1<SerializableImportCompletionItem> completionItems, bool isPartialResult, TimeSpan getSymbolsTime, TimeSpan createItemsTime, Nullable`1<TimeSpan> remoteAssetSyncTime);
    [CompilerGeneratedAttribute]
public TimeSpan get_GetSymbolsTime();
    [CompilerGeneratedAttribute]
public void set_GetSymbolsTime(TimeSpan value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Completion.Providers.Snippets.AbstractSnippetCompletionProvider : CompletionProvider {
    internal bool IsSnippetProvider { get; }
    internal virtual bool get_IsSnippetProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.Snippets.AbstractSnippetCompletionProvider/<GetChangeAsync>d__2")]
public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.Snippets.AbstractSnippetCompletionProvider/<ProvideCompletionsAsync>d__3")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.Snippets.AbstractSnippetCompletionProvider/<GetDescriptionAsync>d__4")]
internal virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.Snippets.AbstractSnippetCompletionProvider/<GetDocumentWithoutInvokingTextAsync>d__5")]
private static Task`1<ValueTuple`2<Document, int>> GetDocumentWithoutInvokingTextAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.Providers.Snippets.SnippetCompletionItem : object {
    public static string LSPSnippetKey;
    public static string SnippetIdentifierKey;
    private static SnippetCompletionItem();
    public static CompletionItem Create(string displayText, string displayTextSuffix, int position, string snippetIdentifier, Glyph glyph, ImmutableArray`1<SymbolDisplayPart> description, string inlineDescription, ImmutableArray`1<string> additionalFilterTexts);
    public static string GetSnippetIdentifier(CompletionItem item);
    public static int GetInvocationPosition(CompletionItem item);
    public static bool IsSnippet(CompletionItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem : object {
    private static string InsertionTextProperty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`2<IReadOnlyList`1<ISymbol>, ArrayBuilder`1<KeyValuePair`2<string, string>>> s_addSymbolEncoding;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`2<IReadOnlyList`1<ISymbol>, ArrayBuilder`1<KeyValuePair`2<string, string>>> s_addSymbolInfo;
    private static Char[] s_projectSeperators;
    private static Char[] s_symbolSplitters;
    private static SymbolCompletionItem();
    [NullableContextAttribute("2")]
private static CompletionItem CreateWorker(string displayText, string displayTextSuffix, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, Action`2<IReadOnlyList`1<ISymbol>, ArrayBuilder`1<KeyValuePair`2<string, string>>> symbolEncoder, string sortText, string insertionText, string filterText, SupportedPlatformData supportedPlatforms, ImmutableArray`1<KeyValuePair`2<string, string>> properties, ImmutableArray`1<string> tags, string displayTextPrefix, string inlineDescription, Nullable`1<Glyph> glyph, bool isComplexTextEdit);
    private static void AddSymbolEncoding(IReadOnlyList`1<ISymbol> symbols, ArrayBuilder`1<KeyValuePair`2<string, string>> properties);
    private static void AddSymbolInfo(IReadOnlyList`1<ISymbol> symbols, ArrayBuilder`1<KeyValuePair`2<string, string>> properties);
    public static CompletionItem AddShouldProvideParenthesisCompletion(CompletionItem item);
    public static bool GetShouldProvideParenthesisCompletion(CompletionItem item);
    public static string EncodeSymbols(IReadOnlyList`1<ISymbol> symbols);
    public static string EncodeSymbol(ISymbol symbol);
    public static bool HasSymbols(CompletionItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem/<GetSymbolsAsync>d__13")]
public static Task`1<ImmutableArray`1<ISymbol>> GetSymbolsAsync(CompletionItem item, Document document, CancellationToken cancellationToken);
    private static void DecodeSymbols(List`1<string> ids, Compilation compilation, ArrayBuilder`1<ISymbol> symbols);
    private static ISymbol DecodeSymbol(string id, Compilation compilation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem/<GetDescriptionAsync>d__16")]
public static Task`1<CompletionDescription> GetDescriptionAsync(CompletionItem item, Document document, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem/<GetDescriptionForSymbolsAsync>d__17")]
public static Task`1<CompletionDescription> GetDescriptionForSymbolsAsync(CompletionItem item, Document document, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    private static Document FindAppropriateDocumentForDescriptionContext(Document document, SupportedPlatformData supportedPlatforms);
    [NullableContextAttribute("2")]
private static void AddSupportedPlatforms(ArrayBuilder`1<KeyValuePair`2<string, string>> properties, SupportedPlatformData supportedPlatforms);
    public static SupportedPlatformData GetSupportedPlatforms(CompletionItem item, Solution solution);
    public static int GetContextPosition(CompletionItem item);
    public static int GetDescriptionPosition(CompletionItem item);
    public static string GetInsertionText(CompletionItem item);
    public static bool TryGetInsertionText(CompletionItem item, String& insertionText);
    public static CompletionItem CreateWithSymbolId(string displayText, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, string sortText, string insertionText, string filterText, SupportedPlatformData supportedPlatforms, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, bool isComplexTextEdit);
    [NullableContextAttribute("2")]
public static CompletionItem CreateWithSymbolId(string displayText, string displayTextSuffix, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, string sortText, string insertionText, string filterText, string displayTextPrefix, string inlineDescription, Nullable`1<Glyph> glyph, SupportedPlatformData supportedPlatforms, ImmutableArray`1<KeyValuePair`2<string, string>> properties, ImmutableArray`1<string> tags, bool isComplexTextEdit);
    [NullableContextAttribute("2")]
public static CompletionItem CreateWithNameAndKind(string displayText, string displayTextSuffix, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, string sortText, string insertionText, string filterText, string displayTextPrefix, string inlineDescription, Nullable`1<Glyph> glyph, SupportedPlatformData supportedPlatforms, ImmutableArray`1<KeyValuePair`2<string, string>> properties, ImmutableArray`1<string> tags, bool isComplexTextEdit);
    internal static string GetSymbolName(CompletionItem item);
    internal static Nullable`1<SymbolKind> GetKind(CompletionItem item);
    internal static bool GetSymbolIsGeneric(CompletionItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Providers.SymbolCompletionItem/<GetDescriptionAsync>d__31")]
public static Task`1<CompletionDescription> GetDescriptionAsync(CompletionItem item, IReadOnlyList`1<ISymbol> symbols, Document document, SemanticModel semanticModel, SymbolDescriptionOptions options, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Completion.Providers.SymbolMatchPriority : object {
    internal static int Keyword;
    internal static int PreferType;
    internal static int PreferNamedArgument;
    internal static int PreferEventOrMethod;
    internal static int PreferFieldOrProperty;
    internal static int PreferLocalOrParameterOrRangeVariable;
    private static SymbolMatchPriority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Completion.Providers.TypeImportCompletionCacheEntry : ValueType {
    [CompilerGeneratedAttribute]
private SymbolKey <AssemblySymbolKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private Checksum <Checksum>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<TypeImportCompletionItemInfo> <ItemInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PublicItemCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasEnumBaseTypes>k__BackingField;
    public SymbolKey AssemblySymbolKey { get; }
    public string Language { get; }
    public Checksum Checksum { get; }
    [NullableAttribute("0")]
private ImmutableArray`1<TypeImportCompletionItemInfo> ItemInfos { get; }
    private int PublicItemCount { get; }
    private bool HasEnumBaseTypes { get; }
    [NullableContextAttribute("0")]
private TypeImportCompletionCacheEntry(SymbolKey assemblySymbolKey, Checksum checksum, string language, ImmutableArray`1<TypeImportCompletionItemInfo> items, int publicItemCount, bool hasEnumBaseTypes);
    [CompilerGeneratedAttribute]
public SymbolKey get_AssemblySymbolKey();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public Checksum get_Checksum();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<TypeImportCompletionItemInfo> get_ItemInfos();
    [CompilerGeneratedAttribute]
private int get_PublicItemCount();
    [CompilerGeneratedAttribute]
private bool get_HasEnumBaseTypes();
    public ImmutableArray`1<CompletionItem> GetItemsForContext(Compilation originCompilation, string language, string genericTypeSuffix, bool isAttributeContext, bool isEnumBaseListContext, bool isCaseSensitive, bool hideAdvancedMembers);
    [CompilerGeneratedAttribute]
internal static CompletionItem <GetItemsForContext>g__GetAppropriateAttributeItem|19_0(CompletionItem attributeItem, bool isCaseSensitive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.Providers.UnionCompletionItemComparer : object {
    public static UnionCompletionItemComparer Instance;
    private static UnionCompletionItemComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(CompletionItem x, CompletionItem y);
    public sealed virtual int GetHashCode(CompletionItem obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Completion.Providers.XmlDocCommentCompletionItem : object {
    private static string BeforeCaretText;
    private static string AfterCaretText;
    public static CompletionItem Create(string displayText, string beforeCaretText, string afterCaretText, CompletionItemRules rules);
    public static string GetBeforeCaretText(CompletionItem item);
    public static string GetAfterCaretText(CompletionItem item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Completion.SharedSyntaxContextsWithSpeculativeModel : object {
    private Document _document;
    private int _position;
    private ConcurrentDictionary`2<Document, AsyncLazy`1<SyntaxContext>> _cache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableArray`1<DocumentId>> _lazyRelatedDocumentIds;
    public SharedSyntaxContextsWithSpeculativeModel(Document document, int position);
    public Task`1<SyntaxContext> GetSyntaxContextAsync(Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static AsyncLazy`1<SyntaxContext> <GetSyntaxContextAsync>g__GetLazySyntaxContextWithSpeculativeModel|5_0(Document document, SharedSyntaxContextsWithSpeculativeModel self);
}
public enum Microsoft.CodeAnalysis.Completion.SnippetsRule : Enum {
    public int value__;
    public static SnippetsRule Default;
    public static SnippetsRule NeverInclude;
    public static SnippetsRule AlwaysInclude;
    public static SnippetsRule IncludeAfterTypingIdentifierQuestionTab;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Completion.Utilities : object {
    public static string UnicodeStarAndSpace;
    [NullableContextAttribute("0")]
public static TextChange Collapse(SourceText newText, ImmutableArray`1<TextChange> changes);
    [ExtensionAttribute]
public static bool IsPreferredItem(CompletionItem completionItem);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Completion.Utilities/<CreateSyntaxContextWithExistingSpeculativeModelAsync>d__3")]
public static Task`1<SyntaxContext> CreateSyntaxContextWithExistingSpeculativeModelAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider : CodeFixProvider {
    internal static string TakeTopEquivalenceKey;
    internal static string TakeBottomEquivalenceKey;
    internal static string TakeBothEquivalenceKey;
    private static int s_mergeConflictLength;
    private ISyntaxKinds _syntaxKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractResolveConflictMarkerCodeFixProvider(ISyntaxKinds syntaxKinds, string diagnosticId);
    private static AbstractResolveConflictMarkerCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual CodeActionRequestPriority ComputeRequestPriority();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<RegisterCodeFixesAsync>d__10")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private bool ShouldFix(SyntaxNode root, SourceText text, int position, TextLine& startLine, TextLine& firstMiddleLine, TextLine& secondMiddleLine, TextLine& endLine);
    private static bool TryGetConflictLines(SourceText text, int position, TextLine& startLine, TextLine& firstMiddleLine, TextLine& secondMiddleLine, TextLine& endLine);
    private static bool TryFindLineForwards(TextLine startLine, char ch, TextLine& foundLine);
    private static bool TryFindLineBackwards(TextLine startLine, char ch, TextLine& foundLine);
    private static bool IsConflictMarker(TextLine currentLine, char ch);
    private static void RegisterCodeFixes(CodeFixContext context, TextLine startLine, TextLine firstMiddleLine, TextLine secondMiddleLine, TextLine endLine);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<AddEditsAsync>d__17")]
private static Task`1<Document> AddEditsAsync(Document document, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos, Action`6<SourceText, ArrayBuilder`1<TextChange>, int, int, int, int> addEdits, CancellationToken cancellationToken);
    private static void AddTopEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos);
    private static void AddBottomEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos);
    private static void AddBothEdits(SourceText text, ArrayBuilder`1<TextChange> edits, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos);
    private static Task`1<Document> TakeTopAsync(Document document, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos, CancellationToken cancellationToken);
    private static Task`1<Document> TakeBottomAsync(Document document, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos, CancellationToken cancellationToken);
    private static Task`1<Document> TakeBothAsync(Document document, int startPos, int firstMiddlePos, int secondMiddlePos, int endPos, CancellationToken cancellationToken);
    private static int GetEndIncludingLineBreak(SourceText text, int position);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<FixAllAsync>d__25")]
private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, string equivalenceKey, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
    [CompilerGeneratedAttribute]
internal static CodeAction <RegisterCodeFixes>g__CreateCodeAction|16_3(string title, Func`2<CancellationToken, Task`1<Document>> action, string equivalenceKey);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConflictMarkerResolution.AbstractResolveConflictMarkerCodeFixProvider/<<GetFixAllProvider>b__26_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__26_0(FixAllContext context, Document document, ImmutableArray`1<Diagnostic> diagnostics);
}
internal interface Microsoft.CodeAnalysis.Contracts.Client.ISolutionSnapshotProvider {
    public abstract virtual ValueTask`1<SolutionSnapshotId> RegisterSolutionSnapshotAsync(CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.Client.SolutionSnapshotId : ValueType {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [DataMemberAttribute]
public int Id { get; public set; }
    public SolutionSnapshotId(int Id);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SolutionSnapshotId left, SolutionSnapshotId right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SolutionSnapshotId left, SolutionSnapshotId right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SolutionSnapshotId other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Id);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Contracts.EditAndContinue.ActiveStatementFlags : Enum {
    public int value__;
    public static ActiveStatementFlags None;
    public static ActiveStatementFlags LeafFrame;
    public static ActiveStatementFlags PartiallyExecuted;
    public static ActiveStatementFlags NonUserCode;
    public static ActiveStatementFlags MethodUpToDate;
    public static ActiveStatementFlags NonLeafFrame;
    public static ActiveStatementFlags Stale;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Contracts.EditAndContinue.DebugSessionFlags : Enum {
    public int value__;
    public static DebugSessionFlags None;
    public static DebugSessionFlags EditAndContinueDisabled;
}
internal enum Microsoft.CodeAnalysis.Contracts.EditAndContinue.HotReloadResult : Enum {
    public int value__;
    public static HotReloadResult Applied;
    public static HotReloadResult NoChanges;
    public static HotReloadResult RestartRequired;
    public static HotReloadResult ErrorEdits;
    public static HotReloadResult ApplyUpdateFailure;
}
internal interface Microsoft.CodeAnalysis.Contracts.EditAndContinue.IManagedHotReloadLanguageService {
    public abstract virtual ValueTask CommitUpdatesAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask DiscardUpdatesAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask EndSessionAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask EnterBreakStateAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask ExitBreakStateAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ManagedHotReloadUpdates> GetUpdatesAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<bool> HasChangesAsync(string sourceFilePath, CancellationToken cancellationToken);
    public abstract virtual ValueTask OnCapabilitiesChangedAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask StartSessionAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Contracts.EditAndContinue.IManagedHotReloadService {
    public abstract virtual ValueTask`1<ImmutableArray`1<ManagedActiveStatementDebugInfo>> GetActiveStatementsAsync(CancellationToken cancellation);
    public abstract virtual ValueTask`1<ManagedHotReloadAvailability> GetAvailabilityAsync(Guid module, CancellationToken cancellation);
    public abstract virtual ValueTask PrepareModuleForUpdateAsync(Guid module, CancellationToken cancellation);
    public abstract virtual ValueTask`1<ImmutableArray`1<string>> GetCapabilitiesAsync(CancellationToken cancellation);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementDebugInfo : ValueType {
    [CompilerGeneratedAttribute]
private ManagedInstructionId <ActiveInstruction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceSpan <SourceSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private ActiveStatementFlags <Flags>k__BackingField;
    [DataMemberAttribute]
public ManagedInstructionId ActiveInstruction { get; }
    [DataMemberAttribute]
public string DocumentName { get; }
    [DataMemberAttribute]
public SourceSpan SourceSpan { get; }
    [DataMemberAttribute]
public ActiveStatementFlags Flags { get; }
    public bool HasSourceLocation { get; }
    public ManagedActiveStatementDebugInfo(ManagedInstructionId activeInstruction, string documentName, SourceSpan sourceSpan, ActiveStatementFlags flags);
    [CompilerGeneratedAttribute]
public ManagedInstructionId get_ActiveInstruction();
    [CompilerGeneratedAttribute]
public string get_DocumentName();
    [CompilerGeneratedAttribute]
public SourceSpan get_SourceSpan();
    [CompilerGeneratedAttribute]
public ActiveStatementFlags get_Flags();
    public bool get_HasSourceLocation();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedActiveStatementUpdate : ValueType {
    [CompilerGeneratedAttribute]
private ManagedModuleMethodId <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ILOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceSpan <NewSpan>k__BackingField;
    [DataMemberAttribute]
public ManagedModuleMethodId Method { get; }
    [DataMemberAttribute]
public int ILOffset { get; }
    [DataMemberAttribute]
public SourceSpan NewSpan { get; }
    public ManagedActiveStatementUpdate(ManagedModuleMethodId method, int ilOffset, SourceSpan newSpan);
    [CompilerGeneratedAttribute]
public ManagedModuleMethodId get_Method();
    [CompilerGeneratedAttribute]
public int get_ILOffset();
    [CompilerGeneratedAttribute]
public SourceSpan get_NewSpan();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedEditAndContinueEngineCapabilities : Enum {
    public int value__;
    public static ManagedEditAndContinueEngineCapabilities None;
    public static ManagedEditAndContinueEngineCapabilities CanReplaceMethodsWhileStopped;
    public static ManagedEditAndContinueEngineCapabilities SupportsInMethodReplacements;
    public static ManagedEditAndContinueEngineCapabilities SupportsEditAndContinueOnModuleLoad;
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedExceptionRegionUpdate : ValueType {
    [CompilerGeneratedAttribute]
private ManagedModuleMethodId <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceSpan <NewSpan>k__BackingField;
    [DataMemberAttribute]
public ManagedModuleMethodId Method { get; }
    [DataMemberAttribute]
public int Delta { get; }
    [DataMemberAttribute]
public SourceSpan NewSpan { get; }
    public ManagedExceptionRegionUpdate(ManagedModuleMethodId method, int delta, SourceSpan newSpan);
    [CompilerGeneratedAttribute]
public ManagedModuleMethodId get_Method();
    [CompilerGeneratedAttribute]
public int get_Delta();
    [CompilerGeneratedAttribute]
public SourceSpan get_NewSpan();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailability : ValueType {
    [CompilerGeneratedAttribute]
private ManagedHotReloadAvailabilityStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizedMessage>k__BackingField;
    [DataMemberAttribute]
public ManagedHotReloadAvailabilityStatus Status { get; }
    [DataMemberAttribute]
public string LocalizedMessage { get; }
    public ManagedHotReloadAvailability(ManagedHotReloadAvailabilityStatus status, string localizedMessage);
    [CompilerGeneratedAttribute]
public ManagedHotReloadAvailabilityStatus get_Status();
    [CompilerGeneratedAttribute]
public string get_LocalizedMessage();
}
internal enum Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadAvailabilityStatus : Enum {
    public int value__;
    public static ManagedHotReloadAvailabilityStatus Available;
    public static ManagedHotReloadAvailabilityStatus Interop;
    public static ManagedHotReloadAvailabilityStatus SqlClr;
    public static ManagedHotReloadAvailabilityStatus Minidump;
    public static ManagedHotReloadAvailabilityStatus Attach;
    public static ManagedHotReloadAvailabilityStatus ModuleNotLoaded;
    public static ManagedHotReloadAvailabilityStatus ModuleReloaded;
    public static ManagedHotReloadAvailabilityStatus NotBuilt;
    public static ManagedHotReloadAvailabilityStatus UnsupportedEngine;
    public static ManagedHotReloadAvailabilityStatus NotSupportedForClr64Version;
    public static ManagedHotReloadAvailabilityStatus NotAllowedForModule;
    public static ManagedHotReloadAvailabilityStatus Optimized;
    public static ManagedHotReloadAvailabilityStatus DomainNeutralAssembly;
    public static ManagedHotReloadAvailabilityStatus ReflectionAssembly;
    public static ManagedHotReloadAvailabilityStatus IntelliTrace;
    public static ManagedHotReloadAvailabilityStatus NotAllowedForRuntime;
    public static ManagedHotReloadAvailabilityStatus InternalError;
    public static ManagedHotReloadAvailabilityStatus Unavailable;
    public static ManagedHotReloadAvailabilityStatus Disabled;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnostic : ValueType {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedHotReloadDiagnosticSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceSpan <Span>k__BackingField;
    [DataMemberAttribute]
public string Id { get; }
    [DataMemberAttribute]
public string Message { get; }
    [DataMemberAttribute]
public ManagedHotReloadDiagnosticSeverity Severity { get; }
    [DataMemberAttribute]
public string FilePath { get; }
    [DataMemberAttribute]
public SourceSpan Span { get; }
    public ManagedHotReloadDiagnostic(string id, string message, ManagedHotReloadDiagnosticSeverity severity, string filePath, SourceSpan span);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public ManagedHotReloadDiagnosticSeverity get_Severity();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public SourceSpan get_Span();
}
internal enum Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadDiagnosticSeverity : Enum {
    public int value__;
    public static ManagedHotReloadDiagnosticSeverity Warning;
    public static ManagedHotReloadDiagnosticSeverity RestartRequired;
    public static ManagedHotReloadDiagnosticSeverity Error;
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadUpdate : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Module>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <ILDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <MetadataDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <PdbDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <UpdatedTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <RequiredCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<int> <UpdatedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SequencePointUpdates> <SequencePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ManagedActiveStatementUpdate> <ActiveStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ManagedExceptionRegionUpdate> <ExceptionRegions>k__BackingField;
    [DataMemberAttribute]
public Guid Module { get; }
    [NullableAttribute("1")]
[DataMemberAttribute]
public string ModuleName { get; }
    [NullableAttribute("1")]
[DataMemberAttribute]
public ProjectId ProjectId { get; }
    [DataMemberAttribute]
public ImmutableArray`1<byte> ILDelta { get; }
    [DataMemberAttribute]
public ImmutableArray`1<byte> MetadataDelta { get; }
    [DataMemberAttribute]
public ImmutableArray`1<byte> PdbDelta { get; }
    [DataMemberAttribute]
public ImmutableArray`1<int> UpdatedTypes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> RequiredCapabilities { get; }
    [DataMemberAttribute]
public ImmutableArray`1<int> UpdatedMethods { get; }
    [DataMemberAttribute]
public ImmutableArray`1<SequencePointUpdates> SequencePoints { get; }
    [DataMemberAttribute]
public ImmutableArray`1<ManagedActiveStatementUpdate> ActiveStatements { get; }
    [DataMemberAttribute]
public ImmutableArray`1<ManagedExceptionRegionUpdate> ExceptionRegions { get; }
    public ManagedHotReloadUpdate(Guid module, string moduleName, ProjectId projectId, ImmutableArray`1<byte> ilDelta, ImmutableArray`1<byte> metadataDelta, ImmutableArray`1<byte> pdbDelta, ImmutableArray`1<int> updatedTypes, ImmutableArray`1<string> requiredCapabilities, ImmutableArray`1<int> updatedMethods, ImmutableArray`1<SequencePointUpdates> sequencePoints, ImmutableArray`1<ManagedActiveStatementUpdate> activeStatements, ImmutableArray`1<ManagedExceptionRegionUpdate> exceptionRegions);
    [CompilerGeneratedAttribute]
public Guid get_Module();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_ModuleName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_ILDelta();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_MetadataDelta();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_PdbDelta();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_UpdatedTypes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_RequiredCapabilities();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_UpdatedMethods();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SequencePointUpdates> get_SequencePoints();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ManagedActiveStatementUpdate> get_ActiveStatements();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ManagedExceptionRegionUpdate> get_ExceptionRegions();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedHotReloadUpdates : ValueType {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ManagedHotReloadUpdate> <Updates>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ManagedHotReloadDiagnostic> <Diagnostics>k__BackingField;
    [DataMemberAttribute]
public ImmutableArray`1<ManagedHotReloadUpdate> Updates { get; }
    [DataMemberAttribute]
public ImmutableArray`1<ManagedHotReloadDiagnostic> Diagnostics { get; }
    public ManagedHotReloadUpdates(ImmutableArray`1<ManagedHotReloadUpdate> updates, ImmutableArray`1<ManagedHotReloadDiagnostic> diagnostics);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ManagedHotReloadUpdate> get_Updates();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ManagedHotReloadDiagnostic> get_Diagnostics();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedInstructionId : ValueType {
    [CompilerGeneratedAttribute]
private ManagedMethodId <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ILOffset>k__BackingField;
    [DataMemberAttribute]
public ManagedMethodId Method { get; }
    [DataMemberAttribute]
public int ILOffset { get; }
    public ManagedInstructionId(ManagedMethodId method, int ilOffset);
    [CompilerGeneratedAttribute]
public ManagedMethodId get_Method();
    [CompilerGeneratedAttribute]
public int get_ILOffset();
    public sealed virtual bool Equals(ManagedInstructionId other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ManagedInstructionId left, ManagedInstructionId right);
    public static bool op_Inequality(ManagedInstructionId left, ManagedInstructionId right);
    [NullableContextAttribute("1")]
internal string GetDebuggerDisplay();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedMethodId : ValueType {
    [CompilerGeneratedAttribute]
private Guid <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedModuleMethodId <Method>k__BackingField;
    [DataMemberAttribute]
public Guid Module { get; }
    [DataMemberAttribute]
public ManagedModuleMethodId Method { get; }
    public int Token { get; }
    public int Version { get; }
    public ManagedMethodId(Guid module, ManagedModuleMethodId method);
    public ManagedMethodId(Guid module, int token, int version);
    [CompilerGeneratedAttribute]
public Guid get_Module();
    [CompilerGeneratedAttribute]
public ManagedModuleMethodId get_Method();
    public int get_Token();
    public int get_Version();
    public sealed virtual bool Equals(ManagedMethodId other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ManagedMethodId left, ManagedMethodId right);
    public static bool op_Inequality(ManagedMethodId left, ManagedMethodId right);
    [NullableContextAttribute("1")]
internal string GetDebuggerDisplay();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.ManagedModuleMethodId : ValueType {
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [DataMemberAttribute]
public int Token { get; }
    [DataMemberAttribute]
public int Version { get; }
    public ManagedModuleMethodId(int token, int version);
    [CompilerGeneratedAttribute]
public int get_Token();
    [CompilerGeneratedAttribute]
public int get_Version();
    public sealed virtual bool Equals(ManagedModuleMethodId other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ManagedModuleMethodId left, ManagedModuleMethodId right);
    public static bool op_Inequality(ManagedModuleMethodId left, ManagedModuleMethodId right);
    [NullableContextAttribute("1")]
internal string GetDebuggerDisplay();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.SequencePointUpdates : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SourceLineUpdate> <LineUpdates>k__BackingField;
    [NullableAttribute("1")]
[DataMemberAttribute]
public string FileName { get; }
    [DataMemberAttribute]
public ImmutableArray`1<SourceLineUpdate> LineUpdates { get; }
    public SequencePointUpdates(string fileName, ImmutableArray`1<SourceLineUpdate> lineUpdates);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SourceLineUpdate> get_LineUpdates();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceLineUpdate : ValueType {
    [CompilerGeneratedAttribute]
private int <OldLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewLine>k__BackingField;
    [DataMemberAttribute]
public int OldLine { get; }
    [DataMemberAttribute]
public int NewLine { get; }
    public SourceLineUpdate(int oldLine, int newLine);
    [CompilerGeneratedAttribute]
public int get_OldLine();
    [CompilerGeneratedAttribute]
public int get_NewLine();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.Contracts.EditAndContinue.SourceSpan : ValueType {
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [DataMemberAttribute]
public int StartLine { get; }
    [DataMemberAttribute]
public int StartColumn { get; }
    [DataMemberAttribute]
public int EndLine { get; }
    [DataMemberAttribute]
public int EndColumn { get; }
    public SourceSpan(int startLine, int startColumn, int endLine, int endColumn);
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    public sealed virtual bool Equals(SourceSpan other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SourceSpan left, SourceSpan right);
    public static bool op_Inequality(SourceSpan left, SourceSpan right);
    [NullableContextAttribute("1")]
internal string GetDebuggerDisplay();
}
internal abstract class Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeCodeRefactoringProvider`1 : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeCodeRefactoringProvider`1/<TryGetAnonymousObjectAsync>d__0")]
protected static Task`1<ValueTuple`2<TAnonymousObjectCreationExpressionSyntax, INamedTypeSymbol>> TryGetAnonymousObjectAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6 : AbstractConvertAnonymousTypeCodeRefactoringProvider`1<TAnonymousObjectCreationExpressionSyntax> {
    protected abstract virtual TObjectCreationExpressionSyntax CreateObjectCreationExpression(TNameSyntax nameNode, TAnonymousObjectCreationExpressionSyntax currentAnonymousObject);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<ConvertAsync>d__2")]
private Task`1<Document> ConvertAsync(Document document, TextSpan span, CodeActionOptionsProvider fallbackOptions, bool isRecord, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<ReplacePropertyReferencesAsync>d__3")]
private static Task ReplacePropertyReferencesAsync(Document document, SyntaxEditor editor, SyntaxNode containingMember, ImmutableDictionary`2<IPropertySymbol, string> propertyMap, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<ReplaceMatchingAnonymousTypesAsync>d__4")]
private Task ReplaceMatchingAnonymousTypesAsync(Document document, SyntaxEditor editor, INamedTypeSymbol classSymbol, SyntaxNode containingMember, TAnonymousObjectCreationExpressionSyntax creationNode, INamedTypeSymbol anonymousType, CancellationToken cancellationToken);
    private void ReplaceWithObjectCreation(SyntaxEditor editor, INamedTypeSymbol classSymbol, TAnonymousObjectCreationExpressionSyntax startingCreationNode, TAnonymousObjectCreationExpressionSyntax childCreation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6/<GenerateFinalNamedTypeAsync>d__6")]
private static Task`1<INamedTypeSymbol> GenerateFinalNamedTypeAsync(Document document, string typeName, bool isRecord, ImmutableArray`1<IPropertySymbol> properties, CancellationToken cancellationToken);
    private static INamedTypeSymbol CreateNamedType(string className, bool isRecord, ImmutableArray`1<ITypeParameterSymbol> capturedTypeParameters, ImmutableArray`1<ISymbol> members);
    private static ValueTuple`2<ImmutableArray`1<IPropertySymbol>, ImmutableDictionary`2<IPropertySymbol, string>> GenerateProperties(Document document, INamedTypeSymbol anonymousType);
    private static IPropertySymbol GenerateProperty(Document document, IPropertySymbol prop);
    private static string GetLegalName(string name, Document document);
    private static IMethodSymbol CreateAccessorSymbol(IPropertySymbol prop, MethodKind kind);
    private static IMethodSymbol CreateClassConstructor(SemanticModel semanticModel, string className, ImmutableArray`1<IPropertySymbol> properties, SyntaxGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToTupleCodeRefactoringProvider`3 : AbstractConvertAnonymousTypeCodeRefactoringProvider`1<TAnonymousObjectCreationExpressionSyntax> {
    protected abstract virtual int GetInitializerCount(TAnonymousObjectCreationExpressionSyntax anonymousType);
    protected abstract virtual TTupleExpressionSyntax ConvertToTuple(TAnonymousObjectCreationExpressionSyntax anonCreation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToTupleCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToTupleCodeRefactoringProvider`3/<GetAllAnonymousTypesInContainer>d__3")]
private IEnumerable`1<ValueTuple`2<TAnonymousObjectCreationExpressionSyntax, INamedTypeSymbol>> GetAllAnonymousTypesInContainer(Document document, SemanticModel semanticModel, TAnonymousObjectCreationExpressionSyntax anonymousNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAnonymousType.AbstractConvertAnonymousTypeToTupleCodeRefactoringProvider`3/<FixInCurrentMemberAsync>d__4")]
private Task`1<Document> FixInCurrentMemberAsync(Document document, TAnonymousObjectCreationExpressionSyntax creationNode, INamedTypeSymbol anonymousType, bool allAnonymousTypes, CancellationToken cancellationToken);
    private void ReplaceWithTuple(SyntaxEditor editor, TAnonymousObjectCreationExpressionSyntax node);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetAllAnonymousTypesInContainer>b__3_1(TAnonymousObjectCreationExpressionSyntax s);
    [CompilerGeneratedAttribute]
private SyntaxNode <ReplaceWithTuple>b__5_0(SyntaxNode current, SyntaxGenerator _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertAutoPropertyToFullProperty.AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`3 : CodeRefactoringProvider {
    protected abstract virtual Task`1<string> GetFieldNameAsync(Document document, IPropertySymbol propertySymbol, NamingStylePreferencesProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetNewAccessors(TCodeGenerationContextInfo info, SyntaxNode property, string fieldName, SyntaxGenerator generator, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetPropertyWithoutInitializer(SyntaxNode property);
    protected abstract virtual SyntaxNode GetInitializerValue(SyntaxNode property);
    protected abstract virtual SyntaxNode ConvertPropertyToExpressionBodyIfDesired(TCodeGenerationContextInfo info, SyntaxNode fullProperty);
    protected abstract virtual SyntaxNode GetTypeBlock(SyntaxNode syntaxNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAutoPropertyToFullProperty.AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__6")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    internal static bool IsValidAutoProperty(IPropertySymbol propertySymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAutoPropertyToFullProperty.AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`3/<GetPropertyAsync>d__8")]
private static Task`1<SyntaxNode> GetPropertyAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertAutoPropertyToFullProperty.AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`3/<ExpandToFullPropertyAsync>d__9")]
private Task`1<Document> ExpandToFullPropertyAsync(Document document, SyntaxNode property, IPropertySymbol propertySymbol, SyntaxNode root, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertCast.AbstractConvertCastCodeRefactoringProvider`3 : CodeRefactoringProvider {
    protected int FromKind { get; }
    protected abstract virtual string GetTitle();
    protected abstract virtual int get_FromKind();
    protected abstract virtual TToExpression ConvertExpression(TFromExpression from, NullableContext nullableContext, bool isReferenceType);
    protected abstract virtual TTypeNode GetTypeNode(TFromExpression from);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertCast.AbstractConvertCastCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__5")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertCast.AbstractConvertCastCodeRefactoringProvider`3/<ConvertAsync>d__6")]
private Task`1<Document> ConvertAsync(Document document, TFromExpression from, NullableContext nullableContext, bool isReferenceType, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertForEachToFor.AbstractConvertForEachToForCodeRefactoringProvider`2 : CodeRefactoringProvider {
    private static string get_Count;
    private static string get_Item;
    private static string Length;
    private static string Count;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_KnownInterfaceNames;
    [CompilerGeneratedAttribute]
private bool <IsForEachVariableWrittenInside>k__BackingField;
    protected bool IsForEachVariableWrittenInside { get; private set; }
    protected string Title { get; }
    private static AbstractConvertForEachToForCodeRefactoringProvider`2();
    [CompilerGeneratedAttribute]
protected bool get_IsForEachVariableWrittenInside();
    [CompilerGeneratedAttribute]
private void set_IsForEachVariableWrittenInside(bool value);
    protected abstract virtual string get_Title();
    protected abstract virtual bool ValidLocation(ForEachInfo<TStatementSyntax, TForEachStatement> foreachInfo);
    protected abstract virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetForEachBody(TForEachStatement foreachStatement);
    protected abstract virtual void ConvertToForStatement(SemanticModel model, ForEachInfo<TStatementSyntax, TForEachStatement> info, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual bool IsValid(TForEachStatement foreachNode);
    protected abstract virtual bool IsSupported(ILocalSymbol foreachVariable, IForEachLoopOperation forEachOperation, TForEachStatement foreachStatement);
    protected static SyntaxAnnotation CreateWarningAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertForEachToFor.AbstractConvertForEachToForCodeRefactoringProvider`2/<ComputeRefactoringsAsync>d__17")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    protected static SyntaxToken CreateUniqueName(ISemanticFactsService semanticFacts, SemanticModel model, SyntaxNode location, string baseName, CancellationToken cancellationToken);
    protected static SyntaxNode GetCollectionVariableName(SemanticModel model, SyntaxGenerator generator, ForEachInfo<TStatementSyntax, TForEachStatement> foreachInfo, SyntaxNode foreachCollectionExpression, CancellationToken cancellationToken);
    protected static void IntroduceCollectionStatement(ForEachInfo<TStatementSyntax, TForEachStatement> foreachInfo, SyntaxEditor editor, SyntaxNode type, SyntaxNode foreachCollectionExpression, SyntaxNode collectionVariable);
    protected static TStatementSyntax AddItemVariableDeclaration(SyntaxGenerator generator, SyntaxNode type, SyntaxToken foreachVariable, ITypeSymbol castType, SyntaxNode collectionVariable, SyntaxToken indexVariable);
    private ForEachInfo<TStatementSyntax, TForEachStatement> GetForeachInfo(ISemanticFactsService semanticFact, SemanticModel model, TForEachStatement foreachStatement, CancellationToken cancellationToken);
    private static void GetInterfaceInfo(SemanticModel model, ILocalSymbol foreachVariable, IOperation foreachCollection, ITypeSymbol& explicitCastInterface, String& collectionNameSuggestion, String& countName);
    private static bool IsExchangable(ITypeSymbol type1, ITypeSymbol type2, Compilation compilation);
    [NullableContextAttribute("2")]
private static bool IsNullOrErrorType(ITypeSymbol type);
    private static IMethodSymbol GetInterfaceMember(ITypeSymbol interfaceType, string memberName);
    private static bool CheckRequireCollectionStatement(IOperation operation);
    private static IOperation RemoveImplicitConversion(IOperation collection);
    private bool CheckIfForEachVariableIsWrittenInside(SemanticModel semanticModel, ISymbol foreachVariable, TForEachStatement foreachStatement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertForEachToFor.AbstractConvertForEachToForCodeRefactoringProvider`2/<ConvertForeachToForAsync>d__30")]
private Task`1<Document> ConvertForeachToForAsync(Document document, ForEachInfo<TStatementSyntax, TForEachStatement> foreachInfo, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertForToForEach.AbstractConvertForToForEachCodeRefactoringProvider`6 : CodeRefactoringProvider {
    protected abstract virtual string GetTitle();
    protected abstract virtual SyntaxList`1<TStatementSyntax> GetBodyStatements(TForStatementSyntax forStatement);
    protected abstract virtual bool IsValidVariableDeclarator(TVariableDeclaratorSyntax firstVariable);
    [NullableContextAttribute("2")]
protected abstract virtual bool TryGetForStatementComponents(TForStatementSyntax forStatement, SyntaxToken& iterationVariable, TExpressionSyntax& initializer, TMemberAccessExpressionSyntax& memberAccess, TExpressionSyntax& stepValueExpressionOpt, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode ConvertForNode(TForStatementSyntax currentFor, TTypeNode typeNode, SyntaxToken foreachIdentifier, TExpressionSyntax collectionExpression, ITypeSymbol iterationVariableType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertForToForEach.AbstractConvertForToForEachCodeRefactoringProvider`6/<ComputeRefactoringsAsync>d__5")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static IEnumerable`1<TSymbol> TryFindMembersInThisOrBaseTypes(INamedTypeSymbol containingType, ITypeSymbol type, string memberName);
    private static TSymbol TryFindMemberInThisOrBaseTypes(INamedTypeSymbol containingType, ITypeSymbol type, string memberName);
    private static bool TryGetIterationElementType(INamedTypeSymbol containingType, ITypeSymbol collectionType, INamedTypeSymbol ienumerableType, INamedTypeSymbol ienumeratorType, ITypeSymbol& iterationType);
    private static bool TryGetIterationElementTypeFromGetEnumerator(INamedTypeSymbol containingType, IMethodSymbol getEnumeratorMethod, INamedTypeSymbol ienumeratorType, ITypeSymbol& iterationType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertForToForEach.AbstractConvertForToForEachCodeRefactoringProvider`6/<ConvertForToForEachAsync>d__10")]
private Task`1<Document> ConvertForToForEachAsync(Document document, TForStatementSyntax forStatement, SyntaxToken iterationVariable, TExpressionSyntax collectionExpression, INamedTypeSymbol containingType, ITypeSymbol collectionType, ITypeSymbol iterationType, CancellationToken cancellationToken);
    private static ITypeSymbol GetIndexerType(INamedTypeSymbol containingType, ITypeSymbol collectionType, INamedTypeSymbol ienumerableType);
    private static bool IsViableIndexer(IPropertySymbol property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4 : SyntaxEditorBasedCodeRefactoringProvider {
    private static string SwitchStatementEquivalenceKey;
    private static string SwitchExpressionEquivalenceKey;
    [NullableAttribute("0")]
protected ImmutableArray`1<FixAllScope> SupportedFixAllScopes { get; }
    public abstract virtual string GetTitle(bool forSwitchExpression);
    public abstract virtual Analyzer<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> CreateAnalyzer(ISyntaxFacts syntaxFacts, ParseOptions options);
    [NullableContextAttribute("0")]
protected sealed virtual ImmutableArray`1<FixAllScope> get_SupportedFixAllScopes();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4/<ComputeRefactoringsAsync>d__11")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private bool ShouldOfferRefactoring(TIfStatementSyntax ifStatement, SemanticModel semanticModel, ISyntaxFactsService syntaxFactsService, Analyzer& analyzer, ImmutableArray`1& sections, SyntaxNode& target);
    private static bool CanConvertToSwitchExpression(bool supportsOrPattern, ImmutableArray`1<AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax>> sections);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4/<FixAllAsync>d__14")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<TextSpan> fixAllSpans, SyntaxEditor editor, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateSwitchExpressionStatement(SyntaxNode target, ImmutableArray`1<AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax>> sections, Feature<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> feature);
    public abstract virtual SyntaxNode CreateSwitchStatement(TIfStatementSyntax ifStatement, SyntaxNode target, IEnumerable`1<SyntaxNode> sectionList);
    public abstract virtual IEnumerable`1<SyntaxNode> AsSwitchSectionStatements(IOperation operation);
    [NullableContextAttribute("0")]
public abstract virtual SyntaxNode AsSwitchLabelSyntax(AnalyzedSwitchLabel<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> label, Feature<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> feature);
    protected abstract virtual SyntaxTriviaList GetLeadingTriviaToTransfer(SyntaxNode syntaxToRemove);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertIfToSwitch.AbstractConvertIfToSwitchCodeRefactoringProvider`4/<UpdateDocumentAsync>d__20")]
private Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode target, TIfStatementSyntax ifStatement, ImmutableArray`1<AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax>> sections, Feature<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> feature, bool convertToSwitchExpression, CancellationToken cancellationToken);
    private SyntaxNode AsSwitchSectionSyntax(AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> section, SyntaxGenerator generator, Feature<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> feature);
    [CompilerGeneratedAttribute]
internal static OperationKind <CanConvertToSwitchExpression>g__GetSwitchArmKind|13_3(IOperation op);
    [CompilerGeneratedAttribute]
internal static bool <CanConvertToSwitchExpression>g__CanConvertSectionForSwitchExpression|13_4(bool supportsOrPattern, AnalyzedSwitchSection<TIfStatementSyntax, TExpressionSyntax, TIsExpressionSyntax, TPatternSyntax> section);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2 : CodeRefactoringProvider {
    protected string Title { get; }
    protected abstract virtual string get_Title();
    protected abstract virtual bool TryConvert(TQueryExpression queryExpression, SemanticModel semanticModel, ISemanticFactsService semanticFacts, CancellationToken cancellationToken, DocumentUpdateInfo& documentUpdate);
    protected abstract virtual Task`1<TQueryExpression> FindNodeToRefactorAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertLinq.AbstractConvertLinqQueryToForEachProvider`2/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2 : CodeRefactoringProvider {
    protected abstract virtual ForEachInfo`2<TForEachStatement, TStatement> CreateForEachInfo(TForEachStatement forEachStatement, SemanticModel semanticModel, bool convertLocalDeclarations);
    protected abstract virtual bool TryBuildSpecificConverter(ForEachInfo`2<TForEachStatement, TStatement> forEachInfo, SemanticModel semanticModel, TStatement statementCannotBeConverted, CancellationToken cancellationToken, IConverter`2& converter);
    protected abstract virtual IConverter`2<TForEachStatement, TStatement> CreateDefaultConverter(ForEachInfo`2<TForEachStatement, TStatement> forEachInfo);
    protected abstract virtual SyntaxNode AddLinqUsing(IConverter`2<TForEachStatement, TStatement> converter, SemanticModel semanticModel, SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.AbstractConvertForEachToLinqQueryProvider`2/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private Task`1<Document> ApplyConversionAsync(IConverter`2<TForEachStatement, TStatement> converter, Document document, bool convertToQuery, CancellationToken cancellationToken);
    private bool TryBuildConverter(TForEachStatement forEachStatement, SemanticModel semanticModel, bool convertLocalDeclarations, CancellationToken cancellationToken, IConverter`2& converter);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ExtendedSyntaxNode : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxTrivia> <ExtraLeadingComments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxTrivia> <ExtraTrailingComments>k__BackingField;
    [NullableAttribute("1")]
public SyntaxNode Node { get; }
    public ImmutableArray`1<SyntaxTrivia> ExtraLeadingComments { get; }
    public ImmutableArray`1<SyntaxTrivia> ExtraTrailingComments { get; }
    [NullableContextAttribute("1")]
public ExtendedSyntaxNode(SyntaxNode node, IEnumerable`1<SyntaxTrivia> extraLeadingComments, IEnumerable`1<SyntaxTrivia> extraTrailingComments);
    [NullableContextAttribute("1")]
public ExtendedSyntaxNode(SyntaxNode node, IEnumerable`1<SyntaxToken> extraLeadingTokens, IEnumerable`1<SyntaxToken> extraTrailingTokens);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxTrivia> get_ExtraLeadingComments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxTrivia> get_ExtraTrailingComments();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.ForEachInfo`2 : ValueType {
    [CompilerGeneratedAttribute]
private TForEachStatement <ForEachStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ExtendedSyntaxNode> <ConvertingExtendedNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxToken> <Identifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TStatement> <Statements>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxToken> <LeadingTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxToken> <TrailingTokens>k__BackingField;
    public TForEachStatement ForEachStatement { get; }
    public SemanticModel SemanticModel { get; }
    public ImmutableArray`1<ExtendedSyntaxNode> ConvertingExtendedNodes { get; }
    public ImmutableArray`1<SyntaxToken> Identifiers { get; }
    public ImmutableArray`1<TStatement> Statements { get; }
    public ImmutableArray`1<SyntaxToken> LeadingTokens { get; }
    public ImmutableArray`1<SyntaxToken> TrailingTokens { get; }
    public ForEachInfo`2(TForEachStatement forEachStatement, SemanticModel semanticModel, ImmutableArray`1<ExtendedSyntaxNode> convertingExtendedNodes, ImmutableArray`1<SyntaxToken> identifiers, ImmutableArray`1<TStatement> statements, ImmutableArray`1<SyntaxToken> leadingTokens, ImmutableArray`1<SyntaxToken> trailingTokens);
    [CompilerGeneratedAttribute]
public TForEachStatement get_ForEachStatement();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ExtendedSyntaxNode> get_ConvertingExtendedNodes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxToken> get_Identifiers();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TStatement> get_Statements();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxToken> get_LeadingTokens();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxToken> get_TrailingTokens();
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.ConvertLinq.ConvertForEachToLinqQuery.IConverter`2 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ForEachInfo`2<TForEachStatement, TStatement> ForEachInfo { get; }
    public abstract virtual ForEachInfo`2<TForEachStatement, TStatement> get_ForEachInfo();
    [NullableContextAttribute("1")]
public abstract virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertNumericLiteral.AbstractConvertNumericLiteralCodeRefactoringProvider`1 : CodeRefactoringProvider {
    [CompilerGeneratedAttribute]
private string <hexPrefix>P;
    [CompilerGeneratedAttribute]
private string <binaryPrefix>P;
    private Regex _regex;
    protected AbstractConvertNumericLiteralCodeRefactoringProvider`1(string hexPrefix, string binaryPrefix);
    protected virtual CodeActionRequestPriority ComputeRequestPriority();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertNumericLiteral.AbstractConvertNumericLiteralCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__6")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [CompilerGeneratedAttribute]
internal static string <ComputeRefactoringsAsync>g__AddSeparators|6_1(string numericText, int interval);
    [CompilerGeneratedAttribute]
internal static Task`1<Document> <ComputeRefactoringsAsync>g__ReplaceTokenAsync|6_2(Document document, SyntaxNode root, SyntaxToken numericToken, long value, string text, string suffix);
}
internal abstract class Microsoft.CodeAnalysis.ConvertToAsync.AbstractConvertToAsyncCodeFixProvider : CodeFixProvider {
    protected abstract virtual Task`1<string> GetDescriptionAsync(Diagnostic diagnostic, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Tuple`2<SyntaxTree, SyntaxNode>> GetRootInOtherSyntaxTreeAsync(SyntaxNode node, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToAsync.AbstractConvertToAsyncCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToAsync.AbstractConvertToAsyncCodeFixProvider/<GetCodeActionAsync>d__5")]
private Task`1<CodeAction> GetCodeActionAsync(SyntaxNode node, Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1 : CodeRefactoringProvider {
    protected abstract virtual bool SupportsInterpolatedStringHandler(Compilation compilation);
    protected abstract virtual string GetTextWithoutQuotes(string text, bool isVerbatimStringLiteral, bool isCharacterLiteral);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1/<ComputeRefactoringsAsync>d__2")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1/<UpdateDocumentAsync>d__3")]
private Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode top, bool isVerbatimStringLiteral, ImmutableArray`1<SyntaxNode> pieces, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1/<CreateInterpolatedStringAsync>d__4")]
protected Task`1<SyntaxNode> CreateInterpolatedStringAsync(Document document, bool isVerbatimStringLiteral, ImmutableArray`1<SyntaxNode> pieces, CancellationToken cancellationToken);
    private static SyntaxNode ConcatenateTextToTextNode(SyntaxGenerator generator, SyntaxNode interpolatedStringTextNode, string textWithoutQuotes, string value);
    private static void CollectPiecesDown(ISyntaxFactsService syntaxFacts, ArrayBuilder`1<SyntaxNode> pieces, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsStringConcat(ISyntaxFactsService syntaxFacts, SyntaxNode expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <CreateInterpolatedStringAsync>g__TryRemoveToString|4_0(SyntaxNode piece, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`7 : CodeRefactoringProvider {
    protected abstract virtual TExpressionSyntax ParseExpression(string text);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`7/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`7/<CreateInterpolatedStringAsync>d__2")]
private static Task`1<Document> CreateInterpolatedStringAsync(Document document, TInvocationExpressionSyntax invocation, TArgumentSyntax placeholderArgument, IMethodSymbol invocationSymbol, TInterpolatedStringExpressionSyntax interpolatedString, bool shouldReplaceInvocation, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <ComputeRefactoringsAsync>g__IsValidPlaceholderArgument|1_5(string stringLiteralText, int remainingArgCount);
    [CompilerGeneratedAttribute]
internal static bool <ComputeRefactoringsAsync>g__ContainsIndex|1_6(string stringLiteralText, string indexString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ConvertToInterpolatedString.ConvertRegularStringToInterpolatedStringRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertToInterpolatedString.ConvertRegularStringToInterpolatedStringRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static string GetTextWithoutQuotes(string text, bool isVerbatim);
    private static SyntaxNode CreateInterpolatedString(Document document, SyntaxNode literalExpression, bool isVerbatim);
    private static Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode root, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10 : CodeRefactoringProvider {
    protected abstract virtual TArgumentSyntax GetArgumentWithChangedName(TArgumentSyntax argument, string name);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static SyntaxNode GetContainingMember(Document document, SyntaxNode tupleExprOrTypeNode);
    private CodeAction CreateAction(Document document, TextSpan span, Scope scope, CleanCodeGenerationOptionsProvider fallbackOptions, bool isRecord);
    private static string GetTitle(Scope scope);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<TryGetTupleInfoAsync>d__5")]
private static Task`1<ValueTuple`2<SyntaxNode, INamedTypeSymbol>> TryGetTupleInfoAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ConvertToStructAsync>d__6")]
public sealed virtual Task`1<Solution> ConvertToStructAsync(Document document, TextSpan span, Scope scope, CleanCodeGenerationOptionsProvider fallbackOptions, bool isRecord, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<AddRenameTokenAsync>d__7")]
private static Task`1<Solution> AddRenameTokenAsync(Solution solution, ValueTuple`2<DocumentId, TextSpan> renamedToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ConvertToStructInCurrentProcessAsync>d__8")]
private Task`1<Solution> ConvertToStructInCurrentProcessAsync(Document document, TextSpan span, Scope scope, CleanCodeGenerationOptionsProvider fallbackOptions, bool isRecord, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ReplaceExpressionAndTypesInScopeAsync>d__9")]
private Task ReplaceExpressionAndTypesInScopeAsync(Dictionary`2<Document, SyntaxEditor> documentToEditorMap, ImmutableArray`1<DocumentToUpdate> documentsToUpdate, SyntaxNode tupleExprOrTypeNode, INamedTypeSymbol tupleType, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamespaceSymbol containingNamespace, NamingRule parameterNamingRule, bool isRecord, CancellationToken cancellationToken);
    private static TNameSyntax CreateStructNameNode(SyntaxGenerator generator, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, bool addRenameAnnotation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GetDocumentsToUpdateAsync>d__11")]
private static Task`1<ImmutableArray`1<DocumentToUpdate>> GetDocumentsToUpdateAsync(Document document, SyntaxNode tupleExprOrTypeNode, INamedTypeSymbol tupleType, Scope scope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GetDocumentsToUpdateForDependentProjectAsync>d__12")]
private static Task`1<ImmutableArray`1<DocumentToUpdate>> GetDocumentsToUpdateForDependentProjectAsync(Project startingProject, INamedTypeSymbol tupleType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GetDocumentsToUpdateForContainingProjectAsync>d__13")]
private static Task`1<ImmutableArray`1<DocumentToUpdate>> GetDocumentsToUpdateForContainingProjectAsync(Project project, INamedTypeSymbol tupleType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<AddDocumentsToUpdateForProjectAsync>d__14")]
private static Task AddDocumentsToUpdateForProjectAsync(Project project, ArrayBuilder`1<DocumentToUpdate> result, ImmutableArray`1<string> tupleFieldNames, CancellationToken cancellationToken);
    private static bool InfoProbablyContainsTupleFieldNames(SyntaxTreeIndex info, ImmutableArray`1<string> tupleFieldNames);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GetDocumentsToUpdateForContainingTypeAsync>d__16")]
private static Task`1<ImmutableArray`1<DocumentToUpdate>> GetDocumentsToUpdateForContainingTypeAsync(Document startingDocument, SyntaxNode tupleExprOrTypeNode, CancellationToken cancellationToken);
    private static ImmutableArray`1<DocumentToUpdate> GetDocumentsToUpdateForContainingMember(Document document, SyntaxNode tupleExprOrTypeNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GenerateStructIntoContainingNamespaceAsync>d__18")]
private static Task GenerateStructIntoContainingNamespaceAsync(Document document, SyntaxNode tupleExprOrTypeNode, INamedTypeSymbol namedTypeSymbol, Dictionary`2<Document, SyntaxEditor> documentToEditorMap, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ApplyChangesAsync>d__19")]
private static Task`1<Solution> ApplyChangesAsync(Document startingDocument, Dictionary`2<Document, SyntaxEditor> documentToEditorMap, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ReplaceTupleExpressionsAndTypesInDocumentAsync>d__20")]
private Task`1<bool> ReplaceTupleExpressionsAndTypesInDocumentAsync(Document document, NamingRule parameterNamingRule, bool isRecord, SyntaxEditor editor, SyntaxNode startingNode, INamedTypeSymbol tupleType, TNameSyntax fullyQualifiedStructName, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, SyntaxNode containerToUpdate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ReplaceMatchingTupleExpressionsAsync>d__21")]
private Task`1<bool> ReplaceMatchingTupleExpressionsAsync(Document document, NamingRule parameterNamingRule, bool isRecord, SyntaxEditor editor, SyntaxNode startingNode, INamedTypeSymbol tupleType, TNameSyntax qualifiedTypeName, string typeName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, SyntaxNode containingMember, CancellationToken cancellationToken);
    private static bool AreEquivalent(StringComparer comparer, INamedTypeSymbol tupleType, INamedTypeSymbol childType);
    private static bool NamesMatch(StringComparer comparer, ImmutableArray`1<IFieldSymbol> fields1, ImmutableArray`1<IFieldSymbol> fields2);
    private void ReplaceWithObjectCreation(SyntaxEditor editor, string typeName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, TNameSyntax qualifiedTypeName, SyntaxNode startingCreationNode, TTupleExpressionSyntax childCreation, NamingRule parameterNamingRule, bool isRecord);
    private SeparatedSyntaxList`1<TArgumentSyntax> ConvertArguments(SyntaxGenerator generator, NamingRule parameterNamingRule, bool isRecord, SeparatedSyntaxList`1<TArgumentSyntax> arguments);
    private SyntaxNodeOrTokenList ConvertArguments(SyntaxGenerator generator, NamingRule parameterNamingRule, bool isRecord, SyntaxNodeOrTokenList list);
    private SyntaxNodeOrToken ConvertArgumentOrToken(SyntaxGenerator generator, NamingRule parameterNamingRule, bool isRecord, SyntaxNodeOrToken arg);
    private TArgumentSyntax ConvertArgument(SyntaxGenerator generator, NamingRule parameterNamingRule, bool isRecord, TArgumentSyntax argument);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<ReplaceMatchingTupleTypesAsync>d__29")]
private static Task`1<bool> ReplaceMatchingTupleTypesAsync(Document document, SyntaxEditor editor, SyntaxNode startingNode, INamedTypeSymbol tupleType, TNameSyntax qualifiedTypeName, string typeName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, SyntaxNode containingMember, CancellationToken cancellationToken);
    private static void ReplaceWithTypeNode(SyntaxEditor editor, string typeName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, TNameSyntax qualifiedTypeName, SyntaxNode startingNode, TTupleTypeSyntax childTupleType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.AbstractConvertTupleToStructCodeRefactoringProvider`10/<GenerateFinalNamedTypeAsync>d__31")]
private static Task`1<INamedTypeSymbol> GenerateFinalNamedTypeAsync(Document document, Scope scope, bool isRecord, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol tupleType, NamingRule parameterNamingRule, CancellationToken cancellationToken);
    private static IMethodSymbol GenerateDeconstructMethod(SemanticModel model, SyntaxGenerator generator, INamedTypeSymbol tupleType, IMethodSymbol constructor);
    private static void AddConversions(SyntaxGenerator generator, ArrayBuilder`1<ISymbol> members, INamedTypeSymbol tupleType, INamedTypeSymbol structType);
    private static INamedTypeSymbol CreateNamedType(IAssemblySymbol containingAssembly, Scope scope, bool isRecord, string structName, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<ISymbol> members);
    private static IMethodSymbol CreateConstructor(SemanticModel semanticModel, bool isRecord, string className, ImmutableArray`1<IFieldSymbol> fields, SyntaxGenerator generator, NamingRule parameterNamingRule);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CodeAction> <ComputeRefactoringsAsync>g__CreateChildActions|1_3(Document document, TextSpan span, SyntaxNode tupleExprOrTypeNode, ImmutableArray`1<IFieldSymbol> fields, ImmutableArray`1<ITypeParameterSymbol> capturedTypeParameters, CleanCodeGenerationOptionsProvider fallbackOptions, bool isRecord, <>c__DisplayClass1_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ConvertTupleToStruct.DocumentToUpdate : ValueType {
    public Document Document;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SyntaxNode> NodesToUpdate;
    public DocumentToUpdate(Document document, ImmutableArray`1<SyntaxNode> nodesToUpdate);
}
internal interface Microsoft.CodeAnalysis.ConvertTupleToStruct.IConvertTupleToStructCodeRefactoringProvider {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Solution> ConvertToStructAsync(Document document, TextSpan span, Scope scope, CleanCodeGenerationOptionsProvider fallbackOptions, bool isRecord, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ConvertTupleToStruct.IRemoteConvertTupleToStructCodeRefactoringService {
    public abstract virtual ValueTask`1<SerializableConvertTupleToStructResult> ConvertToStructAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, DocumentId documentId, TextSpan span, Scope scope, bool isRecord, CancellationToken cancellationToken);
}
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.IRemoteConvertTupleToStructCodeRefactoringService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ConvertTupleToStruct.RemoteConvertTupleToStructCodeRefactoringServiceCallbackDispatcher : RemoteServiceCallbackDispatcher {
    public sealed virtual ValueTask`1<CleanCodeGenerationOptions> GetOptionsAsync(RemoteServiceCallbackId callbackId, string language, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.ConvertTupleToStruct.Scope : Enum {
    public int value__;
    public static Scope ContainingMember;
    public static Scope ContainingType;
    public static Scope ContainingProject;
    public static Scope DependentProjects;
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ConvertTupleToStruct.SerializableConvertTupleToStructResult : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>> DocumentTextChanges;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ValueTuple`2<DocumentId, TextSpan> RenamedToken;
    public SerializableConvertTupleToStructResult(ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>> documentTextChanges, ValueTuple`2<DocumentId, TextSpan> renamedToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual string GetCodeFixTitle();
    protected abstract virtual SyntaxNode GetSymbolTypeExpression(SemanticModel model, TMemberAccessExpressionSyntax node, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfCodeFixProvider`1/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public void ConvertTypeOfToNameOf(SemanticModel semanticModel, SyntaxEditor editor, TMemberAccessExpressionSyntax nodeToReplace, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ConvertTypeOfToNameOf.AbstractConvertTypeOfToNameOfDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractConvertTypeOfToNameOfDiagnosticAnalyzer(LocalizableString title);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual bool IsValidTypeofAction(OperationAnalysisContext context);
    protected virtual void InitializeWorker(AnalysisContext context);
    protected void AnalyzeAction(OperationAnalysisContext context);
    private static bool IsValidOperation(IOperation operation);
}
internal static class Microsoft.CodeAnalysis.Copilot.CopilotConstants : object {
    public static int CopilotIconLogoId;
    public static int CopilotIconSparkleId;
    public static int CopilotIconSparkleBlueId;
    public static Guid CopilotIconMonikerGuid;
    private static CopilotConstants();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Copilot.Extensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Copilot.Extensions/<GetCachedCopilotDiagnosticsAsync>d__0")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<DiagnosticData>> GetCachedCopilotDiagnosticsAsync(TextDocument document, Nullable`1<TextSpan> span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Copilot.ICopilotCodeAnalysisService {
    public abstract virtual Task`1<bool> IsAvailableAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<string>> GetAvailablePromptTitlesAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeDocumentAsync(Document document, Nullable`1<TextSpan> span, string promptTitle, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> GetCachedDocumentDiagnosticsAsync(Document document, Nullable`1<TextSpan> span, ImmutableArray`1<string> promptTitles, CancellationToken cancellationToken);
    public abstract virtual Task StartRefinementSessionAsync(Document oldDocument, Document newDocument, Diagnostic primaryDiagnostic, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetOnTheFlyDocsAsync(string symbolSignature, ImmutableArray`1<string> declarationCode, string language, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsAnyExclusionAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Copilot.ICopilotOptionsService {
    public abstract virtual Task`1<bool> IsRefineOptionEnabledAsync();
    public abstract virtual Task`1<bool> IsCodeAnalysisOptionEnabledAsync();
    public abstract virtual Task`1<bool> IsOnTheFlyDocsOptionEnabledAsync();
}
internal abstract class Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver : object {
    private static SymbolDisplayFormat s_vsDebugNameFormat;
    protected string Text;
    private string _language;
    private Solution _solution;
    private IEqualityComparer`1<string> _identifierComparer;
    protected AbstractBreakpointResolver(Solution solution, string text, string language, IEqualityComparer`1<string> identifierComparer);
    private static AbstractBreakpointResolver();
    protected abstract virtual void ParseText(IList`1& nameParts, Nullable`1& parameterCount);
    protected abstract virtual IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol type, string name);
    protected abstract virtual bool HasMethodBody(IMethodSymbol method, CancellationToken cancellationToken);
    private BreakpointResolutionResult CreateBreakpoint(ISymbol methodSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver/<DoAsync>d__10")]
public Task`1<IEnumerable`1<BreakpointResolutionResult>> DoAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver/<FindMembersAsync>d__11")]
private Task`1<IEnumerable`1<ISymbol>> FindMembersAsync(IList`1<NameAndArity> nameParts, CancellationToken cancellationToken);
    private static bool MatchesName(INamespaceOrTypeSymbol typeOrNamespace, NameAndArity nameAndArity, IEqualityComparer`1<string> comparer);
    private static bool MatchesNames(INamedTypeSymbol type, NameAndArity[] names, IEqualityComparer`1<string> comparer);
    private IEnumerable`1<ISymbol> FindMembers(IEnumerable`1<INamespaceOrTypeSymbol> containers, NameAndArity[] names);
    private IEnumerable`1<ISymbol> FindMembers(IEnumerable`1<INamedTypeSymbol> types, NameAndArity nameAndArity);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.AbstractBreakpointResolver/<GetAllTypesAsync>d__16")]
private Task`1<IEnumerable`1<INamedTypeSymbol>> GetAllTypesAsync(CancellationToken cancellationToken);
    private static ISymbol GetPartialImplementationPartOrNull(ISymbol symbol);
    private bool IsApplicable(ISymbol methodOrProperty, Nullable`1<int> parameterCount, CancellationToken cancellationToken);
    private static bool IsMismatch(ISymbol methodOrProperty, Nullable`1<int> parameterCount);
    private static IEnumerable`1<INamedTypeSymbol> GetTypeMembersRecursive(INamespaceOrTypeSymbol container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Debugging.BreakpointResolutionResult : object {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LocationNameOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLineBreakpoint>k__BackingField;
    public Document Document { get; }
    public TextSpan TextSpan { get; }
    [NullableAttribute("2")]
public string LocationNameOpt { get; }
    public bool IsLineBreakpoint { get; }
    private BreakpointResolutionResult(Document document, TextSpan textSpan, string locationNameOpt, bool isLineBreakpoint);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_LocationNameOpt();
    [CompilerGeneratedAttribute]
public bool get_IsLineBreakpoint();
    internal static BreakpointResolutionResult CreateSpanResult(Document document, TextSpan textSpan, string locationNameOpt);
    internal static BreakpointResolutionResult CreateLineResult(Document document, string locationNameOpt);
}
internal static class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoConstants : object {
    internal static byte Version;
    internal static int GlobalHeaderSize;
    internal static int RecordHeaderSize;
}
internal class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    private Blob _recordCountFixup;
    private int _recordCount;
    internal static int DynamicAttributeSize;
    internal static int IdentifierSize;
    public BlobBuilder Builder { get; }
    public int RecordCount { get; }
    public CustomDebugInfoEncoder(BlobBuilder builder);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    [IsReadOnlyAttribute]
public int get_RecordCount();
    [IsReadOnlyAttribute]
public Byte[] ToArray();
    public void AddStateMachineTypeName(string typeName);
    public void AddForwardMethodInfo(MethodDefinitionHandle methodHandle);
    public void AddForwardModuleInfo(MethodDefinitionHandle methodHandle);
    public void AddUsingGroups(IReadOnlyCollection`1<int> groupSizes);
    public void AddStateMachineHoistedLocalScopes(ImmutableArray`1<StateMachineHoistedLocalScope> scopes);
    public void AddDynamicLocals(IReadOnlyCollection`1<ValueTuple`4<string, Byte[], int, int>> dynamicLocals);
    public void AddTupleElementNames(IReadOnlyCollection`1<ValueTuple`5<string, int, int, int, ImmutableArray`1<string>>> tupleLocals);
    public void AddRecord(CustomDebugInfoKind kind, T debugInfo, Action`2<T, BlobBuilder> recordSerializer);
}
internal enum Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind : Enum {
    public byte value__;
    public static CustomDebugInfoKind UsingGroups;
    public static CustomDebugInfoKind ForwardMethodInfo;
    public static CustomDebugInfoKind ForwardModuleInfo;
    public static CustomDebugInfoKind StateMachineHoistedLocalScopes;
    public static CustomDebugInfoKind StateMachineTypeName;
    public static CustomDebugInfoKind DynamicLocals;
    public static CustomDebugInfoKind EditAndContinueLocalSlotMap;
    public static CustomDebugInfoKind EditAndContinueLambdaMap;
    public static CustomDebugInfoKind TupleElementNames;
    public static CustomDebugInfoKind EditAndContinueStateMachineStateMap;
}
internal static class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader : object {
    private static void ReadGlobalHeader(Byte[] bytes, Int32& offset, Byte& version, Byte& count);
    private static void ReadRecordHeader(Byte[] bytes, Int32& offset, Byte& version, CustomDebugInfoKind& kind, Int32& size, Int32& alignmentSize);
    public static ImmutableArray`1<byte> TryGetCustomDebugInfoRecord(Byte[] customDebugInfo, CustomDebugInfoKind recordKind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader/<GetCustomDebugInfoRecords>d__3")]
public static IEnumerable`1<CustomDebugInfoRecord> GetCustomDebugInfoRecords(Byte[] customDebugInfo);
    public static ImmutableArray`1<short> DecodeUsingRecord(ImmutableArray`1<byte> bytes);
    public static int DecodeForwardRecord(ImmutableArray`1<byte> bytes);
    public static int DecodeForwardToModuleRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<StateMachineHoistedLocalScope> DecodeStateMachineHoistedLocalScopesRecord(ImmutableArray`1<byte> bytes);
    public static string DecodeForwardIteratorRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<DynamicLocalInfo> DecodeDynamicLocalsRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<TupleElementNamesInfo> DecodeTupleElementNamesRecord(ImmutableArray`1<byte> bytes);
    private static TupleElementNamesInfo DecodeTupleElementNamesInfo(ImmutableArray`1<byte> bytes, Int32& offset);
    public static ImmutableArray`1<ImmutableArray`1<string>> GetCSharpGroupedImportStrings(int methodToken, TArg arg, Func`3<int, TArg, Byte[]> getMethodCustomDebugInfo, Func`3<int, TArg, ImmutableArray`1<string>> getMethodImportStrings, ImmutableArray`1& externAliasStrings);
    public static ImmutableArray`1<string> GetVisualBasicImportStrings(int methodToken, TArg arg, Func`3<int, TArg, ImmutableArray`1<string>> getMethodImportStrings);
    private static int ReadInt32(ImmutableArray`1<byte> bytes, Int32& offset);
    private static short ReadInt16(ImmutableArray`1<byte> bytes, Int32& offset);
    private static byte ReadByte(ImmutableArray`1<byte> bytes, Int32& offset);
    private static bool IsCSharpExternAliasInfo(string import);
    public static bool TryParseCSharpImportString(string import, String& alias, String& externAlias, String& target, ImportTargetKind& kind);
    public static bool TryParseVisualBasicImportString(string import, String& alias, String& target, ImportTargetKind& kind, VBImportScopeKind& scope);
    private static bool TrySplit(string input, int offset, char separator, String& before, String& after);
    private static string FormatMethodToken(int methodToken);
    private static string ReadUtf8String(ImmutableArray`1<byte> bytes, Int32& offset);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoRecord : ValueType {
    public CustomDebugInfoKind Kind;
    public byte Version;
    public ImmutableArray`1<byte> Data;
    public CustomDebugInfoRecord(CustomDebugInfoKind kind, byte version, ImmutableArray`1<byte> data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.DebugDataTipInfo : ValueType {
    public TextSpan Span;
    public string Text;
    public bool IsDefault { get; }
    public DebugDataTipInfo(TextSpan span, string text);
    public bool get_IsDefault();
}
internal abstract class Microsoft.CodeAnalysis.Debugging.DebugInformationReaderProvider : object {
    public abstract virtual void Dispose();
    public abstract virtual EditAndContinueMethodDebugInfoReader CreateEditAndContinueMethodDebugInfoReader();
    public abstract virtual ValueTask CopyContentToAsync(Stream stream, CancellationToken cancellationToken);
    public static DebugInformationReaderProvider CreateFromStream(Stream stream);
    private static DebugInformationReaderProvider CreateNative(Stream stream);
    public static DebugInformationReaderProvider CreateFromMetadataReader(MetadataReaderProvider metadataProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.DebugLocationInfo : ValueType {
    public string Name;
    public int LineOffset;
    public bool IsDefault { get; }
    public DebugLocationInfo(string name, int lineOffset);
    public bool get_IsDefault();
}
internal enum Microsoft.CodeAnalysis.Debugging.DebugMode : Enum {
    public int value__;
    public static DebugMode Design;
    public static DebugMode Break;
    public static DebugMode Run;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.DynamicLocalInfo : ValueType {
    public ImmutableArray`1<bool> Flags;
    public int SlotId;
    public string LocalName;
    public DynamicLocalInfo(ImmutableArray`1<bool> flags, int slotId, string localName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Debugging.IBreakpointResolutionService {
    public abstract virtual Task`1<BreakpointResolutionResult> ResolveBreakpointAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<BreakpointResolutionResult>> ResolveBreakpointsAsync(Solution solution, string name, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Debugging.ILanguageDebugInfoService {
    public abstract virtual Task`1<DebugLocationInfo> GetLocationInfoAsync(Document document, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<DebugDataTipInfo> GetDataTipInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Debugging.ImportTargetKind : Enum {
    public int value__;
    public static ImportTargetKind Namespace;
    public static ImportTargetKind Type;
    public static ImportTargetKind NamespaceOrType;
    public static ImportTargetKind Assembly;
    public static ImportTargetKind XmlNamespace;
    public static ImportTargetKind MethodToken;
    public static ImportTargetKind CurrentNamespace;
    public static ImportTargetKind DefaultNamespace;
    public static ImportTargetKind Defunct;
}
internal interface Microsoft.CodeAnalysis.Debugging.IProximityExpressionsService {
    public abstract virtual Task`1<IList`1<string>> GetProximityExpressionsAsync(Document document, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsValidAsync(Document document, int position, string expressionValue, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds : object {
    public static Guid AsyncMethodSteppingInformationBlob;
    public static Guid StateMachineHoistedLocalScopes;
    public static Guid DynamicLocalVariables;
    public static Guid TupleElementNames;
    public static Guid DefaultNamespace;
    public static Guid EncLocalSlotMap;
    public static Guid EncLambdaAndClosureMap;
    public static Guid EncStateMachineStateMap;
    public static Guid SourceLink;
    public static Guid EmbeddedSource;
    public static Guid CompilationMetadataReferences;
    public static Guid CompilationOptions;
    public static Guid TypeDefinitionDocuments;
    public static Guid PrimaryConstructorInformationBlob;
    private static PortableCustomDebugInfoKinds();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope : ValueType {
    public int StartOffset;
    public int EndOffset;
    public int Length { get; }
    public bool IsDefault { get; }
    public StateMachineHoistedLocalScope(int startOffset, int endOffset);
    public int get_Length();
    public bool get_IsDefault();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Debugging.TupleElementNamesInfo : ValueType {
    internal ImmutableArray`1<string> ElementNames;
    internal int SlotIndex;
    internal string LocalName;
    internal int ScopeStart;
    internal int ScopeEnd;
    internal TupleElementNamesInfo(ImmutableArray`1<string> elementNames, int slotIndex, string localName, int scopeStart, int scopeEnd);
}
internal enum Microsoft.CodeAnalysis.Debugging.VBImportScopeKind : Enum {
    public int value__;
    public static VBImportScopeKind Unspecified;
    public static VBImportScopeKind File;
    public static VBImportScopeKind Project;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.DeclarationComputer : object {
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, IEnumerable`1<SyntaxNode> executableCodeBlocks, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SyntaxNode node, ISymbol declaredSymbol, IEnumerable`1<SyntaxNode> executableCodeBlocks);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, SyntaxNode executableCodeBlock, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken, SyntaxNode[] executableCodeBlocks);
    private static ISymbol GetDeclaredSymbol(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.DeclarationInfo : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNode <DeclaredNode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxNode> <ExecutableCodeBlocks>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISymbol <DeclaredSymbol>k__BackingField;
    public SyntaxNode DeclaredNode { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SyntaxNode> ExecutableCodeBlocks { get; }
    [NullableAttribute("2")]
public ISymbol DeclaredSymbol { get; }
    internal DeclarationInfo(SyntaxNode declaredNode, ImmutableArray`1<SyntaxNode> executableCodeBlocks, ISymbol declaredSymbol);
    [CompilerGeneratedAttribute]
public SyntaxNode get_DeclaredNode();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SyntaxNode> get_ExecutableCodeBlocks();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ISymbol get_DeclaredSymbol();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.DecompiledSource.IDecompilationService {
    public abstract virtual Document PerformDecompilation(Document document, string fullName, Compilation compilation, MetadataReference metadataReference, string assemblyLocation);
    public abstract virtual FileVersionInfo GetDecompilerVersion();
}
internal interface Microsoft.CodeAnalysis.DecompiledSource.IDecompiledSourceService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Document> AddSourceToAsync(Document document, Compilation symbolCompilation, ISymbol symbol, MetadataReference metadataReference, string assemblyLocation, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.DelayTimeSpan : object {
    public static TimeSpan NearImmediate;
    public static TimeSpan Short;
    public static TimeSpan Medium;
    public static TimeSpan Idle;
    public static TimeSpan IdleWithLongDelay;
    public static TimeSpan NonFocus;
    private static DelayTimeSpan();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeData : ValueType {
    [NullableAttribute("2")]
[DataMemberAttribute]
public string Category;
    [DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public string FilePath;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.DesignerAttribute.IDesignerAttributeDiscoveryService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_wellKnownDesignerNamespaces;
    private static ConditionalWeakTable`2<MetadataId, AsyncLazy`1<bool>> s_metadataIdToDesignerAttributeInfo;
    private SemaphoreSlim _gate;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<DocumentId, ValueTuple`2<string, VersionStamp>> _documentToLastReportedInformation;
    private static DesignerAttributeDiscoveryService();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<HasDesignerCategoryTypeAsync>d__5")]
private static ValueTask`1<bool> HasDesignerCategoryTypeAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<ProcessPriorityDocumentAsync>d__6")]
public sealed virtual ValueTask ProcessPriorityDocumentAsync(Solution solution, DocumentId priorityDocumentId, ICallback callback, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<ProcessSolutionAsync>d__7")]
public sealed virtual ValueTask ProcessSolutionAsync(Solution solution, ICallback callback, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<ProcessProjectAsync>d__8")]
private Task ProcessProjectAsync(Project project, ICallback callback, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<ScanForDesignerCategoryUsageAsync>d__9")]
private Task ScanForDesignerCategoryUsageAsync(Project project, Document specificDocument, ICallback callback, AsyncLazy`1<VersionStamp> lazyProjectVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<ComputeChangedDataAsync>d__10")]
private Task`1<ImmutableArray`1<ValueTuple`2<DesignerAttributeData, VersionStamp>>> ComputeChangedDataAsync(Project project, Document specificDocument, AsyncLazy`1<VersionStamp> lazyProjectVersion, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<ComputeDesignerAttributeCategoryAsync>d__11")]
public static Task`1<string> ComputeDesignerAttributeCategoryAsync(bool hasDesignerCategoryType, Project project, DocumentId documentId, string existingCategory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<DiscoverDesignerAttributesAsync>d__12")]
public static Task DiscoverDesignerAttributesAsync(Solution solution, Document activeDocument, RemoteHostClient client, IAsynchronousOperationListener listener, ICallback target, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<<HasDesignerCategoryTypeAsync>g__HasDesignerCategoryTypeAsync|5_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<bool> <HasDesignerCategoryTypeAsync>g__HasDesignerCategoryTypeAsync|5_0(SolutionServices solutionServices, SolutionKey solutionKey, PortableExecutableReference peReference, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<<HasDesignerCategoryTypeAsync>g__ComputeHasDesignerCategoryTypeAsync|5_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<bool> <HasDesignerCategoryTypeAsync>g__ComputeHasDesignerCategoryTypeAsync|5_1(SolutionServices solutionServices, SolutionKey solutionKey, PortableExecutableReference peReference, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.DesignerAttribute.DesignerAttributeDiscoveryService/<<ComputeDesignerAttributeCategoryAsync>g__GetBaseTypesAndThis|11_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ITypeSymbol> <ComputeDesignerAttributeCategoryAsync>g__GetBaseTypesAndThis|11_0(Compilation compilation, INamedTypeSymbol firstType);
    [CompilerGeneratedAttribute]
internal static INamedTypeSymbol <ComputeDesignerAttributeCategoryAsync>g__TryMapToNonErrorType|11_1(Compilation compilation, IErrorTypeSymbol errorType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <ComputeDesignerAttributeCategoryAsync>g__IsDesignerAttribute|11_2(INamedTypeSymbol attributeClass);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static SyntaxNode <ComputeDesignerAttributeCategoryAsync>g__FindFirstNonNestedClass|11_3(SyntaxList`1<SyntaxNode> members, <>c__DisplayClass11_0& );
}
internal interface Microsoft.CodeAnalysis.DesignerAttribute.IDesignerAttributeDiscoveryService {
    [NullableContextAttribute("1")]
public abstract virtual ValueTask ProcessSolutionAsync(Solution solution, ICallback callback, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual ValueTask ProcessPriorityDocumentAsync(Solution solution, DocumentId priorityDocumentId, ICallback callback, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.DesignerAttribute.IRemoteDesignerAttributeDiscoveryService {
    public abstract virtual ValueTask DiscoverDesignerAttributesAsync(RemoteServiceCallbackId callbackId, Checksum solutionChecksum, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual ValueTask DiscoverDesignerAttributesAsync(RemoteServiceCallbackId callbackId, Checksum solutionChecksum, DocumentId priorityDocument, CancellationToken cancellationToken);
}
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.DesignerAttribute.IRemoteDesignerAttributeDiscoveryService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.DesignerAttribute.RemoteDesignerAttributeDiscoveryCallbackDispatcher : RemoteServiceCallbackDispatcher {
    [NullableContextAttribute("1")]
private ICallback GetCallback(RemoteServiceCallbackId callbackId);
    public sealed virtual ValueTask ReportDesignerAttributeDataAsync(RemoteServiceCallbackId callbackId, ImmutableArray`1<DesignerAttributeData> data, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AddImport.UnboundIdentifiersDiagnosticAnalyzerBase`4 : DiagnosticAnalyzer {
    protected DiagnosticDescriptor DiagnosticDescriptor { get; }
    [NullableAttribute("0")]
protected ImmutableArray`1<TLanguageKindEnum> SyntaxKindsOfInterest { get; }
    public bool IsHighPriority { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual DiagnosticDescriptor get_DiagnosticDescriptor();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SyntaxKindsOfInterest();
    protected abstract virtual bool IsNameOf(SyntaxNode node);
    public sealed virtual bool get_IsHighPriority();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("2")]
public sealed virtual bool OpenFileOnly(SimplifierOptions options);
    public virtual void Initialize(AnalysisContext context);
    protected static DiagnosticDescriptor GetDiagnosticDescriptor(string id, LocalizableString messageFormat);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private void ReportUnboundIdentifierNames(SyntaxNodeAnalysisContext context, SyntaxNode member);
    private static bool IsQualifiedOrSimpleName(SyntaxNode n);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.AnalyzerExceptionDescriptionBuilder : object {
    private static string s_separator;
    private static AnalyzerExceptionDescriptionBuilder();
    [ExtensionAttribute]
public static string CreateDiagnosticDescription(Exception exception);
    private static string GetExceptionMessage(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProvider : ValueType {
    private IOptionsReader _options;
    private IdeAnalyzerOptions _fallbackOptions;
    private string _language;
    public CodeStyleOption2`1<bool> QualifyFieldAccess { get; }
    public CodeStyleOption2`1<bool> QualifyPropertyAccess { get; }
    public CodeStyleOption2`1<bool> QualifyMethodAccess { get; }
    public CodeStyleOption2`1<bool> QualifyEventAccess { get; }
    public CodeStyleOption2`1<bool> PreferPredefinedTypeKeywordInMemberAccess { get; }
    public CodeStyleOption2`1<bool> PreferPredefinedTypeKeywordInDeclaration { get; }
    public NamingStylePreferences NamingPreferences { get; }
    public CodeStyleOption2`1<bool> PreferObjectInitializer { get; }
    public CodeStyleOption2`1<CollectionExpressionPreference> PreferCollectionExpression { get; }
    public CodeStyleOption2`1<bool> PreferCollectionInitializer { get; }
    public CodeStyleOption2`1<bool> PreferSimplifiedBooleanExpressions { get; }
    public OperatorPlacementWhenWrappingPreference OperatorPlacementWhenWrapping { get; }
    public CodeStyleOption2`1<bool> PreferCoalesceExpression { get; }
    public CodeStyleOption2`1<bool> PreferNullPropagation { get; }
    public CodeStyleOption2`1<bool> PreferExplicitTupleNames { get; }
    public CodeStyleOption2`1<bool> PreferAutoProperties { get; }
    public CodeStyleOption2`1<bool> PreferInferredTupleNames { get; }
    public CodeStyleOption2`1<bool> PreferInferredAnonymousTypeMemberNames { get; }
    public CodeStyleOption2`1<bool> PreferIsNullCheckOverReferenceEqualityMethod { get; }
    public CodeStyleOption2`1<bool> PreferConditionalExpressionOverAssignment { get; }
    public CodeStyleOption2`1<bool> PreferConditionalExpressionOverReturn { get; }
    public CodeStyleOption2`1<bool> PreferCompoundAssignment { get; }
    public CodeStyleOption2`1<bool> PreferSimplifiedInterpolation { get; }
    public CodeStyleOption2`1<UnusedParametersPreference> UnusedParameters { get; }
    public CodeStyleOption2`1<AccessibilityModifiersRequired> RequireAccessibilityModifiers { get; }
    public CodeStyleOption2`1<bool> PreferReadonly { get; }
    public CodeStyleOption2`1<ParenthesesPreference> ArithmeticBinaryParentheses { get; }
    public CodeStyleOption2`1<ParenthesesPreference> OtherBinaryParentheses { get; }
    public CodeStyleOption2`1<ParenthesesPreference> RelationalBinaryParentheses { get; }
    public CodeStyleOption2`1<ParenthesesPreference> OtherParentheses { get; }
    public CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> ForEachExplicitCastInSource { get; }
    public CodeStyleOption2`1<bool> PreferNamespaceAndFolderMatchStructure { get; }
    public CodeStyleOption2`1<bool> AllowMultipleBlankLines { get; }
    public CodeStyleOption2`1<bool> AllowStatementImmediatelyAfterBlock { get; }
    public string RemoveUnnecessarySuppressionExclusions { get; }
    public string FileHeaderTemplate { get; }
    private IdeCodeStyleOptions FallbackCodeStyleOptions { get; }
    private SimplifierOptions FallbackSimplifierOptions { get; }
    public AnalyzerOptionsProvider(IOptionsReader options, string language, IdeAnalyzerOptions fallbackOptions);
    public AnalyzerOptionsProvider(IOptionsReader options, string language, AnalyzerOptions fallbackOptions);
    public CodeStyleOption2`1<bool> get_QualifyFieldAccess();
    public CodeStyleOption2`1<bool> get_QualifyPropertyAccess();
    public CodeStyleOption2`1<bool> get_QualifyMethodAccess();
    public CodeStyleOption2`1<bool> get_QualifyEventAccess();
    public CodeStyleOption2`1<bool> get_PreferPredefinedTypeKeywordInMemberAccess();
    public CodeStyleOption2`1<bool> get_PreferPredefinedTypeKeywordInDeclaration();
    public SimplifierOptions GetSimplifierOptions(ISimplification simplification);
    public SyntaxFormattingOptions GetSyntaxFormattingOptions(ISyntaxFormatting formatting);
    public NamingStylePreferences get_NamingPreferences();
    public CodeStyleOption2`1<bool> get_PreferObjectInitializer();
    public CodeStyleOption2`1<CollectionExpressionPreference> get_PreferCollectionExpression();
    public CodeStyleOption2`1<bool> get_PreferCollectionInitializer();
    public CodeStyleOption2`1<bool> get_PreferSimplifiedBooleanExpressions();
    public OperatorPlacementWhenWrappingPreference get_OperatorPlacementWhenWrapping();
    public CodeStyleOption2`1<bool> get_PreferCoalesceExpression();
    public CodeStyleOption2`1<bool> get_PreferNullPropagation();
    public CodeStyleOption2`1<bool> get_PreferExplicitTupleNames();
    public CodeStyleOption2`1<bool> get_PreferAutoProperties();
    public CodeStyleOption2`1<bool> get_PreferInferredTupleNames();
    public CodeStyleOption2`1<bool> get_PreferInferredAnonymousTypeMemberNames();
    public CodeStyleOption2`1<bool> get_PreferIsNullCheckOverReferenceEqualityMethod();
    public CodeStyleOption2`1<bool> get_PreferConditionalExpressionOverAssignment();
    public CodeStyleOption2`1<bool> get_PreferConditionalExpressionOverReturn();
    public CodeStyleOption2`1<bool> get_PreferCompoundAssignment();
    public CodeStyleOption2`1<bool> get_PreferSimplifiedInterpolation();
    public CodeStyleOption2`1<UnusedParametersPreference> get_UnusedParameters();
    public CodeStyleOption2`1<AccessibilityModifiersRequired> get_RequireAccessibilityModifiers();
    public CodeStyleOption2`1<bool> get_PreferReadonly();
    public CodeStyleOption2`1<ParenthesesPreference> get_ArithmeticBinaryParentheses();
    public CodeStyleOption2`1<ParenthesesPreference> get_OtherBinaryParentheses();
    public CodeStyleOption2`1<ParenthesesPreference> get_RelationalBinaryParentheses();
    public CodeStyleOption2`1<ParenthesesPreference> get_OtherParentheses();
    public CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> get_ForEachExplicitCastInSource();
    public CodeStyleOption2`1<bool> get_PreferNamespaceAndFolderMatchStructure();
    public CodeStyleOption2`1<bool> get_AllowMultipleBlankLines();
    public CodeStyleOption2`1<bool> get_AllowStatementImmediatelyAfterBlock();
    public string get_RemoveUnnecessarySuppressionExclusions();
    public string get_FileHeaderTemplate();
    private TValue GetOption(Option2`1<TValue> option, TValue defaultValue);
    private TValue GetOption(PerLanguageOption2`1<TValue> option, TValue defaultValue);
    private IdeCodeStyleOptions get_FallbackCodeStyleOptions();
    private SimplifierOptions get_FallbackSimplifierOptions();
    internal IOptionsReader GetAnalyzerConfigOptions();
    internal IdeAnalyzerOptions GetFallbackOptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProviders : object {
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeOptions(AnalyzerOptions options);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(AnalyzerOptions analyzerOptions, SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(SemanticModelAnalysisContext context);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(SyntaxTreeAnalysisContext context);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(OperationAnalysisContext context);
    [ExtensionAttribute]
public static AnalyzerOptionsProvider GetAnalyzerOptions(CodeBlockAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(SemanticModelAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(SyntaxTreeAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(OperationAnalysisContext context);
    [ExtensionAttribute]
public static IdeAnalyzerOptions GetIdeAnalyzerOptions(CodeBlockAnalysisContext context);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptionsProviders/<GetAnalyzerOptionsProviderAsync>d__12")]
[ExtensionAttribute]
public static ValueTask`1<AnalyzerOptionsProvider> GetAnalyzerOptionsProviderAsync(Document document, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerPerformanceInfo : ValueType {
    [DataMemberAttribute]
public string AnalyzerId;
    [DataMemberAttribute]
public bool BuiltIn;
    [DataMemberAttribute]
public TimeSpan TimeSpan;
    public AnalyzerPerformanceInfo(string analyzerId, bool builtIn, TimeSpan timeSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleDiagnosticAnalyzerBase`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_localizableMessageFormat;
    private static LocalizableString s_localizableTitleNamingStyle;
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKind> _symbolKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<Guid, ConcurrentDictionary`2<string, string>> s_createCache;
    [NullableAttribute("0")]
protected ImmutableArray`1<TLanguageKindEnum> SupportedSyntaxKinds { get; }
    private static NamingStyleDiagnosticAnalyzerBase`1();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SupportedSyntaxKinds();
    protected abstract virtual bool ShouldIgnore(ISymbol symbol);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void CompilationStartAction(CompilationStartAnalysisContext context);
    private Diagnostic TryGetDiagnostic(Compilation compilation, ISymbol symbol, SyntaxTree sourceTree, AnalyzerOptions options, ConcurrentDictionary`2<Guid, ConcurrentDictionary`2<string, string>> idToCachedResult);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.CodeAnalysisDiagnosticAnalyzerServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions : object {
    [ExtensionAttribute]
public static bool IsWorkspaceDiagnosticAnalyzer(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool IsBuiltInAnalyzer(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool IsOpenFileOnly(DiagnosticAnalyzer analyzer, SimplifierOptions options);
    [ExtensionAttribute]
public static ReportDiagnostic GetEffectiveSeverity(DiagnosticDescriptor descriptor, CompilationOptions options);
    [ExtensionAttribute]
public static ValueTuple`2<string, VersionStamp> GetAnalyzerIdAndVersion(DiagnosticAnalyzer analyzer);
    private static VersionStamp GetAnalyzerVersion(string path);
    [ExtensionAttribute]
public static string GetAnalyzerAssemblyName(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static void AppendAnalyzerMap(Dictionary`2<string, DiagnosticAnalyzer> analyzerMap, IEnumerable`1<DiagnosticAnalyzer> analyzers);
    [ExtensionAttribute]
public static IEnumerable`1<AnalyzerPerformanceInfo> ToAnalyzerPerformanceInfo(IDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> analysisResult, DiagnosticAnalyzerInfoCache analyzerInfo);
}
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerTelemetry : object {
    private object _guard;
    private ImmutableDictionary`2<Type, Data> _analyzerInfoMap;
    public void UpdateAnalyzerActionsTelemetry(DiagnosticAnalyzer analyzer, AnalyzerTelemetryInfo analyzerTelemetryInfo, bool isTelemetryCollectionAllowed);
    public void ReportAndClear(int correlationId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticArguments : object {
    [DataMemberAttribute]
public bool ReportSuppressedDiagnostics;
    [DataMemberAttribute]
public bool LogPerformanceInfo;
    [DataMemberAttribute]
public bool GetTelemetryInfo;
    [NullableAttribute("2")]
[DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public Nullable`1<TextSpan> DocumentSpan;
    [DataMemberAttribute]
public Nullable`1<AnalysisKind> DocumentAnalysisKind;
    [DataMemberAttribute]
public ProjectId ProjectId;
    [DataMemberAttribute]
public String[] AnalyzerIds;
    [DataMemberAttribute]
public IdeAnalyzerOptions IdeOptions;
    [DataMemberAttribute]
public bool IsExplicit;
    public DiagnosticArguments(bool reportSuppressedDiagnostics, bool logPerformanceInfo, bool getTelemetryInfo, DocumentId documentId, Nullable`1<TextSpan> documentSpan, Nullable`1<AnalysisKind> documentAnalysisKind, ProjectId projectId, String[] analyzerIds, IdeAnalyzerOptions ideOptions, bool isExplicit);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticCustomTags : object {
    private static string s_enforceOnBuildNeverTag;
    private static String[] s_microsoftCustomTags;
    private static String[] s_editAndContinueCustomTags;
    private static String[] s_unnecessaryCustomTags;
    private static String[] s_notConfigurableCustomTags;
    private static String[] s_unnecessaryAndNotConfigurableCustomTags;
    public static String[] Microsoft { get; }
    public static String[] EditAndContinue { get; }
    public static String[] Unnecessary { get; }
    public static String[] NotConfigurable { get; }
    public static String[] UnnecessaryAndNotConfigurable { get; }
    private static DiagnosticCustomTags();
    public static String[] get_Microsoft();
    public static String[] get_EditAndContinue();
    public static String[] get_Unnecessary();
    public static String[] get_NotConfigurable();
    public static String[] get_UnnecessaryAndNotConfigurable();
    [ConditionalAttribute("DEBUG")]
private static void Assert(String[] customTags, String[] tags);
    internal static String[] Create(bool isUnnecessary, bool isConfigurable, bool isCustomConfigurable, EnforceOnBuild enforceOnBuild);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper : object {
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, ImmutableArray`1<Location> additionalLocations, ImmutableArray`1<Location> additionalUnnecessaryLocations, Object[] messageArgs);
    public static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, ImmutableArray`1<Location> additionalLocations, ImmutableArray`1<Location> additionalUnnecessaryLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    private static Diagnostic CreateWithLocationTags(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, IEnumerable`1<Location> additionalLocations, IDictionary`2<string, IEnumerable`1<int>> tagIndices, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic CreateWithMessage(DiagnosticDescriptor descriptor, Location location, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, LocalizableString message);
    public static string GetHelpLinkForDiagnosticId(string id);
    [CompilerGeneratedAttribute]
internal static string <CreateWithLocationTags>g__EncodeIndices|3_1(IEnumerable`1<int> indices, int additionalLocationsLength);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DiagnosticHelper/<<CreateWithMessage>g__GetEffectiveCustomTags|4_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <CreateWithMessage>g__GetEffectiveCustomTags|4_0(DiagnosticDescriptor descriptor, NotificationOption2 notificationOption, AnalyzerOptions analyzerOptions);
}
internal enum Microsoft.CodeAnalysis.Diagnostics.DiagnosticKind : Enum {
    public int value__;
    public static DiagnosticKind All;
    public static DiagnosticKind CompilerSyntax;
    public static DiagnosticKind CompilerSemantic;
    public static DiagnosticKind AnalyzerSyntax;
    public static DiagnosticKind AnalyzerSemantic;
}
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticProviderMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public DiagnosticProviderMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedArgs : object {
    public DiagnosticsUpdatedKind Kind;
    public Solution Solution;
    public ProjectId ProjectId;
    public DocumentId DocumentId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticData> Diagnostics;
    private DiagnosticsUpdatedArgs(Solution solution, ProjectId projectId, DocumentId documentId, ImmutableArray`1<DiagnosticData> diagnostics, DiagnosticsUpdatedKind kind);
    [NullableContextAttribute("1")]
public static DiagnosticsUpdatedArgs DiagnosticsCreated(Solution solution, ProjectId projectId, DocumentId documentId, ImmutableArray`1<DiagnosticData> diagnostics);
    public static DiagnosticsUpdatedArgs DiagnosticsRemoved(Solution solution, ProjectId projectId, DocumentId documentId);
}
internal enum Microsoft.CodeAnalysis.Diagnostics.DiagnosticsUpdatedKind : Enum {
    public int value__;
    public static DiagnosticsUpdatedKind DiagnosticsRemoved;
    public static DiagnosticsUpdatedKind DiagnosticsCreated;
}
internal static class Microsoft.CodeAnalysis.Diagnostics.EnforceOnBuildValues : object {
    public static EnforceOnBuild RemoveUnnecessaryImports;
    public static EnforceOnBuild UseImplicitType;
    public static EnforceOnBuild UseExplicitType;
    public static EnforceOnBuild AddBraces;
    public static EnforceOnBuild OrderModifiers;
    public static EnforceOnBuild AddAccessibilityModifiers;
    public static EnforceOnBuild ValidateFormatString;
    public static EnforceOnBuild MakeFieldReadonly;
    public static EnforceOnBuild RemoveUnusedMembers;
    public static EnforceOnBuild RemoveUnreadMembers;
    public static EnforceOnBuild Formatting;
    public static EnforceOnBuild ValueAssignedIsUnused;
    public static EnforceOnBuild UnusedParameter;
    public static EnforceOnBuild FileHeaderMismatch;
    public static EnforceOnBuild InvalidSuppressMessageAttribute;
    public static EnforceOnBuild LegacyFormatSuppressMessageAttribute;
    public static EnforceOnBuild RemoveConfusingSuppressionForIsExpression;
    public static EnforceOnBuild UseBlockScopedNamespace;
    public static EnforceOnBuild UseFileScopedNamespace;
    public static EnforceOnBuild UseTupleSwap;
    public static EnforceOnBuild UseThrowExpression;
    public static EnforceOnBuild UseObjectInitializer;
    public static EnforceOnBuild InlineDeclaration;
    public static EnforceOnBuild InlineAsType;
    public static EnforceOnBuild InlineIsType;
    public static EnforceOnBuild UseExpressionBodyForConstructors;
    public static EnforceOnBuild UseExpressionBodyForMethods;
    public static EnforceOnBuild UseExpressionBodyForConversionOperators;
    public static EnforceOnBuild UseExpressionBodyForOperators;
    public static EnforceOnBuild UseExpressionBodyForProperties;
    public static EnforceOnBuild UseExpressionBodyForIndexers;
    public static EnforceOnBuild UseExpressionBodyForAccessors;
    public static EnforceOnBuild UseCollectionInitializer;
    public static EnforceOnBuild UseCoalesceExpression;
    public static EnforceOnBuild UseCoalesceExpressionForNullable;
    public static EnforceOnBuild UseNullPropagation;
    public static EnforceOnBuild UseAutoProperty;
    public static EnforceOnBuild UseExplicitTupleName;
    public static EnforceOnBuild UseDefaultLiteral;
    public static EnforceOnBuild InlineIsTypeWithoutName;
    public static EnforceOnBuild UseLocalFunction;
    public static EnforceOnBuild UseDeconstruction;
    public static EnforceOnBuild UseConditionalExpressionForAssignment;
    public static EnforceOnBuild UseConditionalExpressionForReturn;
    public static EnforceOnBuild RemoveUnnecessaryParentheses;
    public static EnforceOnBuild UseExpressionBodyForLambdaExpressions;
    public static EnforceOnBuild UseCompoundAssignment;
    public static EnforceOnBuild UseIndexOperator;
    public static EnforceOnBuild UseRangeOperator;
    public static EnforceOnBuild UseExpressionBodyForLocalFunctions;
    public static EnforceOnBuild MakeLocalFunctionStatic;
    public static EnforceOnBuild UseSimpleUsingStatement;
    public static EnforceOnBuild MoveMisplacedUsingDirectives;
    public static EnforceOnBuild UseSystemHashCode;
    public static EnforceOnBuild SimplifyInterpolation;
    public static EnforceOnBuild UseCoalesceCompoundAssignment;
    public static EnforceOnBuild SimplifyConditionalExpression;
    public static EnforceOnBuild UsePatternCombinators;
    public static EnforceOnBuild RemoveUnnecessaryByVal;
    public static EnforceOnBuild ConvertTypeOfToNameOf;
    public static EnforceOnBuild UseNotPattern;
    public static EnforceOnBuild UseIsNotExpression;
    public static EnforceOnBuild UseImplicitObjectCreation;
    public static EnforceOnBuild RemoveRedundantEquality;
    public static EnforceOnBuild RemoveUnnecessaryDiscardDesignation;
    public static EnforceOnBuild RemoveUnnecessaryLambdaExpression;
    public static EnforceOnBuild InvokeDelegateWithConditionalAccess;
    public static EnforceOnBuild NamingRule;
    public static EnforceOnBuild MatchFolderAndNamespace;
    public static EnforceOnBuild SimplifyObjectCreation;
    public static EnforceOnBuild SimplifyPropertyPattern;
    public static EnforceOnBuild RemoveRedundantNullableDirective;
    public static EnforceOnBuild RemoveUnnecessaryNullableDirective;
    public static EnforceOnBuild MakeStructReadOnly;
    public static EnforceOnBuild MakeStructMemberReadOnly;
    public static EnforceOnBuild UsePatternMatchingAsAndMemberAccess;
    public static EnforceOnBuild UseCoalesceExpressionForIfNullCheck;
    public static EnforceOnBuild UseNameofInAttribute;
    public static EnforceOnBuild UsePrimaryConstructor;
    public static EnforceOnBuild UseCollectionExpressionForArray;
    public static EnforceOnBuild UseCollectionExpressionForEmpty;
    public static EnforceOnBuild UseCollectionExpressionForStackAlloc;
    public static EnforceOnBuild UseCollectionExpressionForCreate;
    public static EnforceOnBuild UseCollectionExpressionForBuilder;
    public static EnforceOnBuild UseCollectionExpressionForFluent;
    public static EnforceOnBuild MakeAnonymousFunctionStatic;
    public static EnforceOnBuild RemoveUnnecessaryCast;
    public static EnforceOnBuild PopulateSwitchStatement;
    public static EnforceOnBuild UseInferredMemberName;
    public static EnforceOnBuild UseIsNullCheck;
    public static EnforceOnBuild AddRequiredParentheses;
    public static EnforceOnBuild ExpressionValueIsUnused;
    public static EnforceOnBuild MakeStructFieldsWritable;
    public static EnforceOnBuild ConvertSwitchStatementToExpression;
    public static EnforceOnBuild PopulateSwitchExpression;
    public static EnforceOnBuild SimplifyLinqExpression;
    public static EnforceOnBuild UseNullCheckOverTypeCheck;
    public static EnforceOnBuild UseTopLevelStatements;
    public static EnforceOnBuild UseProgramMain;
    public static EnforceOnBuild ForEachCast;
    public static EnforceOnBuild UseUtf8StringLiteral;
    public static EnforceOnBuild MultipleBlankLines;
    public static EnforceOnBuild EmbeddedStatementPlacement;
    public static EnforceOnBuild ConsecutiveBracePlacement;
    public static EnforceOnBuild ConsecutiveStatementPlacement;
    public static EnforceOnBuild ConstructorInitializerPlacement;
    public static EnforceOnBuild ConditionalExpressionPlacement;
    public static EnforceOnBuild ArrowExpressionClausePlacement;
    public static EnforceOnBuild Regex;
    public static EnforceOnBuild Json;
    public static EnforceOnBuild SimplifyNames;
    public static EnforceOnBuild SimplifyMemberAccess;
    public static EnforceOnBuild RemoveQualification;
    public static EnforceOnBuild AddQualification;
    public static EnforceOnBuild PreferBuiltInOrFrameworkType;
    public static EnforceOnBuild ConvertAnonymousTypeToTuple;
    public static EnforceOnBuild RemoveUnreachableCode;
    public static EnforceOnBuild RemoveUnnecessarySuppression;
    public static EnforceOnBuild DetectProbableJsonStrings;
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IAnalyzerDriverService {
    public abstract virtual void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Diagnostics.ICodeAnalysisDiagnosticAnalyzerService {
    public abstract virtual void Clear();
    public abstract virtual Task RunAnalysisAsync(Solution solution, ProjectId projectId, Action`1<Project> onAfterProjectAnalyzed, CancellationToken cancellationToken);
    public abstract virtual bool HasProjectBeenAnalyzed(ProjectId projectId);
    public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetLastComputedDocumentDiagnosticsAsync(DocumentId documentId, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetLastComputedProjectDiagnosticsAsync(ProjectId projectId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIds : object {
    public static string SimplifyNamesDiagnosticId;
    public static string SimplifyMemberAccessDiagnosticId;
    public static string RemoveThisOrMeQualificationDiagnosticId;
    public static string RemoveUnnecessaryCastDiagnosticId;
    public static string RemoveUnnecessaryImportsDiagnosticId;
    public static string IntellisenseBuildFailedDiagnosticId;
    public static string UseImplicitTypeDiagnosticId;
    public static string UseExplicitTypeDiagnosticId;
    public static string AddThisOrMeQualificationDiagnosticId;
    public static string PopulateSwitchStatementDiagnosticId;
    public static string AddBracesDiagnosticId;
    public static string UseThrowExpressionDiagnosticId;
    public static string UseObjectInitializerDiagnosticId;
    public static string InlineDeclarationDiagnosticId;
    public static string InlineAsTypeCheckId;
    public static string InlineIsTypeCheckId;
    public static string UseExpressionBodyForConstructorsDiagnosticId;
    public static string UseExpressionBodyForMethodsDiagnosticId;
    public static string UseExpressionBodyForConversionOperatorsDiagnosticId;
    public static string UseExpressionBodyForOperatorsDiagnosticId;
    public static string UseExpressionBodyForPropertiesDiagnosticId;
    public static string UseExpressionBodyForIndexersDiagnosticId;
    public static string UseExpressionBodyForAccessorsDiagnosticId;
    public static string UseCollectionInitializerDiagnosticId;
    public static string UseCoalesceExpressionForTernaryConditionalCheckDiagnosticId;
    public static string UseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticId;
    public static string UseNullPropagationDiagnosticId;
    public static string UseAutoPropertyDiagnosticId;
    public static string UseExplicitTupleNameDiagnosticId;
    public static string UseDefaultLiteralDiagnosticId;
    public static string RemoveUnreachableCodeDiagnosticId;
    public static string OrderModifiersDiagnosticId;
    public static string UseInferredMemberNameDiagnosticId;
    public static string InlineIsTypeWithoutNameCheckDiagnosticsId;
    public static string UseLocalFunctionDiagnosticId;
    public static string AddAccessibilityModifiersDiagnosticId;
    public static string UseIsNullCheckDiagnosticId;
    public static string UseDeconstructionDiagnosticId;
    public static string ValidateFormatStringDiagnosticID;
    public static string MakeFieldReadonlyDiagnosticId;
    public static string UseConditionalExpressionForAssignmentDiagnosticId;
    public static string UseConditionalExpressionForReturnDiagnosticId;
    public static string RemoveUnnecessaryParenthesesDiagnosticId;
    public static string AddRequiredParenthesesDiagnosticId;
    public static string PreferBuiltInOrFrameworkTypeDiagnosticId;
    public static string RemoveUnusedMembersDiagnosticId;
    public static string RemoveUnreadMembersDiagnosticId;
    public static string UseExpressionBodyForLambdaExpressionsDiagnosticId;
    public static string UseCompoundAssignmentDiagnosticId;
    public static string FormattingDiagnosticId;
    public static string UseIndexOperatorDiagnosticId;
    public static string UseRangeOperatorDiagnosticId;
    public static string ExpressionValueIsUnusedDiagnosticId;
    public static string ValueAssignedIsUnusedDiagnosticId;
    public static string UnusedParameterDiagnosticId;
    public static string UseExpressionBodyForLocalFunctionsDiagnosticId;
    public static string MakeLocalFunctionStaticDiagnosticId;
    public static string UseSimpleUsingStatementDiagnosticId;
    public static string MakeStructFieldsWritable;
    public static string MoveMisplacedUsingDirectivesDiagnosticId;
    public static string ConvertSwitchStatementToExpressionDiagnosticId;
    public static string UseSystemHashCode;
    public static string SimplifyInterpolationId;
    public static string PopulateSwitchExpressionDiagnosticId;
    public static string FileHeaderMismatch;
    public static string UseCoalesceCompoundAssignmentDiagnosticId;
    public static string SimplifyConditionalExpressionDiagnosticId;
    public static string InvalidSuppressMessageAttributeDiagnosticId;
    public static string LegacyFormatSuppressMessageAttributeDiagnosticId;
    public static string UsePatternCombinatorsDiagnosticId;
    public static string RemoveUnnecessarySuppressionDiagnosticId;
    public static string RemoveConfusingSuppressionForIsExpressionDiagnosticId;
    public static string RemoveUnnecessaryByValDiagnosticId;
    public static string ConvertTypeOfToNameOfDiagnosticId;
    public static string UseNotPatternDiagnosticId;
    public static string UseIsNotExpressionDiagnosticId;
    public static string UseImplicitObjectCreationDiagnosticId;
    public static string RemoveRedundantEqualityDiagnosticId;
    public static string RemoveUnnecessaryDiscardDesignationDiagnosticId;
    public static string SimplifyLinqExpressionDiagnosticId;
    public static string MatchFolderAndNamespaceDiagnosticId;
    public static string SimplifyObjectCreationDiagnosticId;
    public static string UseNullCheckOverTypeCheckDiagnosticId;
    public static string UseBlockScopedNamespaceDiagnosticId;
    public static string UseFileScopedNamespaceDiagnosticId;
    public static string SimplifyPropertyPatternDiagnosticId;
    public static string UseTupleSwapDiagnosticId;
    public static string RemoveUnnecessaryLambdaExpressionDiagnosticId;
    public static string UseTopLevelStatementsId;
    public static string UseProgramMainId;
    public static string ForEachCastDiagnosticId;
    public static string UseUtf8StringLiteralDiagnosticId;
    public static string RemoveRedundantNullableDirectiveDiagnosticId;
    public static string RemoveUnnecessaryNullableDirectiveDiagnosticId;
    public static string MakeStructReadOnlyDiagnosticId;
    public static string MakeStructMemberReadOnlyDiagnosticId;
    public static string UsePatternMatchingAsAndMemberAccessDiagnosticId;
    public static string UseCoalesceExpressionForIfNullCheckDiagnosticId;
    public static string UseNameofInAttributeDiagnosticId;
    public static string UsePrimaryConstructorDiagnosticId;
    public static string UseCollectionExpressionForArrayDiagnosticId;
    public static string UseCollectionExpressionForEmptyDiagnosticId;
    public static string UseCollectionExpressionForStackAllocDiagnosticId;
    public static string UseCollectionExpressionForCreateDiagnosticId;
    public static string UseCollectionExpressionForBuilderDiagnosticId;
    public static string UseCollectionExpressionForFluentDiagnosticId;
    public static string MakeAnonymousFunctionStaticDiagnosticId;
    public static string AnalyzerChangedId;
    public static string AnalyzerDependencyConflictId;
    public static string MissingAnalyzerReferenceId;
    public static string InvokeDelegateWithConditionalAccessId;
    public static string NamingRuleId;
    public static string UnboundIdentifierId;
    public static string MultipleBlankLinesDiagnosticId;
    public static string EmbeddedStatementPlacementDiagnosticId;
    public static string ConsecutiveBracePlacementDiagnosticId;
    public static string ConsecutiveStatementPlacementDiagnosticId;
    public static string ConstructorInitializerPlacementDiagnosticId;
    public static string ConditionalExpressionPlacementDiagnosticId;
    public static string ArrowExpressionClausePlacementDiagnosticId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.IDEDiagnosticIdToOptionMappingHelper : object {
    private static ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>> s_diagnosticIdToOptionMap;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>>> s_diagnosticIdToLanguageSpecificOptionsMap;
    private static ConcurrentDictionary`2<string, PerLanguageOption2`1<bool>> s_diagnosticIdToFadingOptionMap;
    private static IDEDiagnosticIdToOptionMappingHelper();
    public static bool TryGetMappedOptions(string diagnosticId, string language, ImmutableHashSet`1& options);
    public static bool TryGetMappedFadingOption(string diagnosticId, PerLanguageOption2`1& fadingOption);
    public static bool IsKnownIDEDiagnosticId(string diagnosticId);
    public static void AddOptionMapping(string diagnosticId, ImmutableHashSet`1<IOption2> options);
    private static void AddOptionMapping(ConcurrentDictionary`2<string, ImmutableHashSet`1<IOption2>> map, string diagnosticId, ImmutableHashSet`1<IOption2> options);
    public static void AddFadingOptionMapping(string diagnosticId, PerLanguageOption2`1<bool> fadingOption);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerService {
    public IGlobalOptionService GlobalOptions { get; }
    public DiagnosticAnalyzerInfoCache AnalyzerInfoCache { get; }
    public abstract virtual IGlobalOptionService get_GlobalOptions();
    public abstract virtual DiagnosticAnalyzerInfoCache get_AnalyzerInfoCache();
    public abstract virtual void RequestDiagnosticRefresh();
    [NullableContextAttribute("2")]
public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetCachedDiagnosticsAsync(Workspace workspace, ProjectId projectId, DocumentId documentId, bool includeSuppressedDiagnostics, bool includeLocalDocumentDiagnostics, bool includeNonLocalDocumentDiagnostics, CancellationToken cancellationToken);
    public abstract virtual Task ForceAnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForIdsAsync(Solution solution, ProjectId projectId, DocumentId documentId, ImmutableHashSet`1<string> diagnosticIds, Func`2<DiagnosticAnalyzer, bool> shouldIncludeAnalyzer, Func`3<Project, DocumentId, IReadOnlyList`1<DocumentId>> getDocumentIds, bool includeSuppressedDiagnostics, bool includeLocalDocumentDiagnostics, bool includeNonLocalDocumentDiagnostics, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetProjectDiagnosticsForIdsAsync(Solution solution, ProjectId projectId, ImmutableHashSet`1<string> diagnosticIds, Func`2<DiagnosticAnalyzer, bool> shouldIncludeAnalyzer, bool includeSuppressedDiagnostics, bool includeNonLocalDocumentDiagnostics, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForSpanAsync(TextDocument document, Nullable`1<TextSpan> range, Func`2<string, bool> shouldIncludeDiagnostic, bool includeCompilerDiagnostics, bool includeSuppressedDiagnostics, ICodeActionRequestPriorityProvider priorityProvider, DiagnosticKind diagnosticKind, bool isExplicit, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.IDiagnosticAnalyzerServiceExtensions : object {
    [ExtensionAttribute]
public static Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForSpanAsync(IDiagnosticAnalyzerService service, TextDocument document, Nullable`1<TextSpan> range, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForSpanAsync(IDiagnosticAnalyzerService service, TextDocument document, Nullable`1<TextSpan> range, DiagnosticKind diagnosticKind, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForSpanAsync(IDiagnosticAnalyzerService service, TextDocument document, Nullable`1<TextSpan> range, string diagnosticId, bool includeSuppressedDiagnostics, ICodeActionRequestPriorityProvider priorityProvider, DiagnosticKind diagnosticKind, bool isExplicit, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ImmutableArray`1<DiagnosticData>> GetDiagnosticsForIdsAsync(IDiagnosticAnalyzerService service, Solution solution, ProjectId projectId, DocumentId documentId, ImmutableHashSet`1<string> diagnosticIds, Func`2<DiagnosticAnalyzer, bool> shouldIncludeAnalyzer, bool includeSuppressedDiagnostics, bool includeLocalDocumentDiagnostics, bool includeNonLocalDocumentDiagnostics, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticsRefresher {
    public int GlobalStateVersion { get; }
    public abstract virtual void RequestWorkspaceRefresh();
    public abstract virtual int get_GlobalStateVersion();
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IRemoteDiagnosticAnalyzerService {
    public abstract virtual ValueTask`1<SerializableDiagnosticAnalysisResults> CalculateDiagnosticsAsync(Checksum solutionChecksum, DiagnosticArguments arguments, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetSourceGeneratorDiagnosticsAsync(Checksum solutionChecksum, ProjectId projectId, CancellationToken cancellationToken);
    public abstract virtual ValueTask ReportAnalyzerPerformanceAsync(ImmutableArray`1<AnalyzerPerformanceInfo> snapshot, int unitCount, bool forSpanAnalysis, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.Log.DiagnosticLogger : object {
    private static string From;
    private static string Id;
    private static string HasDescription;
    private static string Uri;
    public static void LogHyperlink(string from, string id, bool description, bool telemetry, string uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.SuppressMessageAttributeState : object {
    internal static string SuppressMessageScope;
    internal static string SuppressMessageTarget;
    private static ImmutableDictionary`2<string, TargetScope> s_targetScopesMap;
    private Compilation _compilation;
    private INamedTypeSymbol _suppressMessageAttributeType;
    [NullableAttribute("0")]
private static string s_suppressionPrefix;
    public SuppressMessageAttributeState(Compilation compilation, INamedTypeSymbol suppressMessageAttributeType);
    private static SuppressMessageAttributeState();
    private static ImmutableDictionary`2<string, TargetScope> CreateTargetScopesMap();
    public bool IsSuppressMessageAttributeWithNamedArguments(SyntaxNode attributeSyntax, SemanticModel model, CancellationToken cancellationToken, ImmutableArray`1& namedAttributeArguments);
    public static bool HasValidScope(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, TargetScope& targetScope);
    [NullableContextAttribute("2")]
public bool HasValidTarget(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, TargetScope targetScope, Boolean& targetHasDocCommentIdFormat, String& targetSymbolString, IOperation& targetValueOperation, ImmutableArray`1& resolvedSymbols);
    [NullableContextAttribute("2")]
private static bool TryGetNamedArgument(ImmutableArray`1<ValueTuple`2<string, IOperation>> namedAttributeArguments, string argumentName, String& argumentValue, IOperation& argumentValueOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.DocumentationComments.AbstractAddDocCommentNodesCodeFixProvider`4 : CodeFixProvider {
    protected string NodeName { get; }
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentationComments.AbstractAddDocCommentNodesCodeFixProvider`4/<RegisterCodeFixesAsync>d__1")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual string get_NodeName();
    protected abstract virtual List`1<TXmlNameAttributeSyntax> GetNameAttributes(TXmlElementSyntax node);
    protected abstract virtual string GetValueFromNameAttribute(TXmlNameAttributeSyntax attribute);
    [NullableContextAttribute("2")]
protected abstract virtual SyntaxNode TryGetDocCommentNode(SyntaxTriviaList parameter);
    protected abstract virtual string GetXmlElementLocalName(TXmlElementSyntax element);
    protected abstract virtual ImmutableArray`1<string> GetParameterNames(TMemberDeclarationSyntax method);
    protected abstract virtual TXmlElementSyntax GetNewNode(string parameterName, bool isFirstNodeInComment);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentationComments.AbstractAddDocCommentNodesCodeFixProvider`4/<AddParamTagAsync>d__10")]
protected Task`1<Document> AddParamTagAsync(Document document, TMemberDeclarationSyntax parentMethod, SyntaxNode docCommentNode, CancellationToken cancellationToken);
    private List`1<TXmlElementSyntax> GetElementNodes(SyntaxNode docComment, string nodeName);
    private bool NodeExists(IEnumerable`1<TXmlElementSyntax> paramNodes, string name);
    protected TXmlElementSyntax GetParamNodeForParamName(IEnumerable`1<TXmlElementSyntax> paramNodeList, string name);
}
internal abstract class Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentFormattingService : object {
    public sealed virtual string Format(string rawXmlText, Compilation compilation);
    public sealed virtual ImmutableArray`1<TaggedText> Format(string rawXmlText, ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format, CancellationToken cancellationToken);
    private static void AppendTextFromNode(FormatterState state, XNode node, Compilation compilation);
    private static Nullable`1<ValueTuple`2<string, string>> GetNavigationTarget(XElement element, SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    private static void AppendTextFromAttribute(FormatterState state, XAttribute attribute, string attributeNameToParse, SymbolDisplayPartKind kind);
    internal static IEnumerable`1<SymbolDisplayPart> CrefToSymbolDisplayParts(string crefValue, int position, SemanticModel semanticModel, SymbolDisplayFormat format, SymbolDisplayPartKind kind);
    internal static IEnumerable`1<SymbolDisplayPart> TypeParameterRefToSymbolDisplayParts(string crefValue, ISymbol typeResolutionSymbol, int position, SemanticModel semanticModel, SymbolDisplayFormat format);
    private static string TrimCrefPrefix(string value);
    private static void AppendTextFromTextNode(FormatterState state, XText element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.DocumentationComments.AbstractDocumentationCommentSnippetService`2 : object {
    public string DocumentationCommentCharacter { get; }
    protected string ExteriorTriviaText { get; }
    protected bool AddIndent { get; }
    protected abstract virtual TMemberNode GetContainingMember(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected abstract virtual bool SupportsDocumentationComments(TMemberNode member);
    protected abstract virtual bool HasDocumentationComment(TMemberNode member);
    protected abstract virtual int GetPrecedingDocumentationCommentCount(TMemberNode member);
    protected abstract virtual List`1<string> GetDocumentationCommentStubLines(TMemberNode member, string existingCommentText);
    protected abstract virtual SyntaxToken GetTokenToRight(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected abstract virtual SyntaxToken GetTokenToLeft(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected abstract virtual bool IsDocCommentNewLine(SyntaxToken token);
    protected abstract virtual bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    protected abstract virtual bool IsSingleExteriorTrivia(TDocumentationComment documentationComment, String& existingCommentText);
    [NullableContextAttribute("2")]
protected abstract virtual bool EndsWithSingleExteriorTrivia(TDocumentationComment documentationComment);
    [NullableContextAttribute("2")]
protected abstract virtual bool IsMultilineDocComment(TDocumentationComment documentationComment);
    protected abstract virtual bool HasSkippedTrailingTrivia(SyntaxToken token);
    public abstract virtual string get_DocumentationCommentCharacter();
    protected abstract virtual string get_ExteriorTriviaText();
    protected abstract virtual bool get_AddIndent();
    public DocumentationCommentSnippet GetDocumentationCommentSnippetOnCharacterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& options, CancellationToken cancellationToken, bool addIndentation);
    private List`1<string> GetDocumentationCommentLines(SyntaxToken token, SourceText text, DocumentationCommentOptions& options, String& indentText, Int32& caretOffset, Int32& spanToReplaceLength);
    private List`1<string> GetDocumentationCommentLinesNoIndentation(SyntaxToken token, SourceText text, DocumentationCommentOptions& options, Int32& caretOffset, Int32& spanToReplaceLength);
    private List`1<string> GetDocumentationStubLines(SyntaxToken token, SourceText text, DocumentationCommentOptions& options, Int32& caretOffset, Int32& spanToReplaceLength, String& existingCommentText);
    public sealed virtual bool IsValidTargetMember(SyntaxTree syntaxTree, SourceText text, int position, CancellationToken cancellationToken);
    private TMemberNode GetTargetMember(SyntaxTree syntaxTree, SourceText text, int position, CancellationToken cancellationToken);
    private TMemberNode GetTargetMember(TDocumentationComment documentationComment);
    private static void AddLineBreaks(IList`1<string> lines, string newLine);
    private static void IndentLines(List`1<string> lines, string indentText);
    public DocumentationCommentSnippet GetDocumentationCommentSnippetOnEnterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& options, CancellationToken cancellationToken);
    private DocumentationCommentSnippet GenerateDocumentationCommentAfterEnter(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& options, CancellationToken cancellationToken);
    public DocumentationCommentSnippet GetDocumentationCommentSnippetOnCommandInvoke(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& options, CancellationToken cancellationToken);
    private DocumentationCommentSnippet GenerateExteriorTriviaAfterEnter(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& options, CancellationToken cancellationToken);
    public DocumentationCommentSnippet GetDocumentationCommentSnippetFromPreviousLine(DocumentationCommentOptions& options, TextLine currentLine, TextLine previousLine);
    private string CreateInsertionTextFromPreviousLine(TextLine previousLine, DocumentationCommentOptions& options);
    private sealed virtual override DocumentationCommentSnippet Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService.GetDocumentationCommentSnippetOnCharacterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CancellationToken cancellationToken, bool addIndentation);
    private sealed virtual override DocumentationCommentSnippet Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService.GetDocumentationCommentSnippetOnCommandInvoke(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CancellationToken cancellationToken);
    private sealed virtual override DocumentationCommentSnippet Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService.GetDocumentationCommentSnippetOnEnterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CancellationToken cancellationToken);
    private sealed virtual override DocumentationCommentSnippet Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService.GetDocumentationCommentSnippetFromPreviousLine(DocumentationCommentOptions& modreq(System.Runtime.InteropServices.InAttribute) options, TextLine currentLine, TextLine previousLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.DocumentationComments.AbstractRemoveDocCommentNodeCodeFixProvider`2 : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string DocCommentSignifierToken { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public abstract virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual string get_DocCommentSignifierToken();
    protected abstract virtual SyntaxTriviaList GetRevisedDocCommentTrivia(string docCommentText);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextSyntax xmlText);
    protected abstract virtual bool IsXmlNewLineToken(SyntaxToken token);
    protected abstract virtual bool IsXmlWhitespaceToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentationComments.AbstractRemoveDocCommentNodeCodeFixProvider`2/<RegisterCodeFixesAsync>d__9")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static TXmlElementSyntax GetParamNode(SyntaxNode root, TextSpan span);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentationComments.AbstractRemoveDocCommentNodeCodeFixProvider`2/<RemoveDuplicateParamTagAsync>d__11")]
private Task`1<Document> RemoveDuplicateParamTagAsync(Document document, TXmlElementSyntax paramNode, CancellationToken cancellationToken);
    private bool ShouldRemovePreviousSibling(List`1<SyntaxNode> paramNodeSiblings, int paramNodeIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentOptions : ValueType {
    public static DocumentationCommentOptions Default;
    [CompilerGeneratedAttribute]
private LineFormattingOptions <LineFormatting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoXmlDocCommentGeneration>k__BackingField;
    [DataMemberAttribute]
public LineFormattingOptions LineFormatting { get; public set; }
    [DataMemberAttribute]
public bool AutoXmlDocCommentGeneration { get; public set; }
    public bool UseTabs { get; }
    public int TabSize { get; }
    public string NewLine { get; }
    private static DocumentationCommentOptions();
    [CompilerGeneratedAttribute]
public LineFormattingOptions get_LineFormatting();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineFormatting(LineFormattingOptions value);
    [CompilerGeneratedAttribute]
public bool get_AutoXmlDocCommentGeneration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AutoXmlDocCommentGeneration(bool value);
    public bool get_UseTabs();
    public int get_TabSize();
    public string get_NewLine();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentationCommentOptions left, DocumentationCommentOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocumentationCommentOptions left, DocumentationCommentOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocumentationCommentOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.DocumentationComments.DocumentationCommentSnippet : object {
    [CompilerGeneratedAttribute]
private TextSpan <SpanToReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SnippetText>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CaretOffset>k__BackingField;
    public TextSpan SpanToReplace { get; }
    public string SnippetText { get; }
    public int CaretOffset { get; }
    internal DocumentationCommentSnippet(TextSpan spanToReplace, string snippetText, int caretOffset);
    [CompilerGeneratedAttribute]
public TextSpan get_SpanToReplace();
    [CompilerGeneratedAttribute]
public string get_SnippetText();
    [CompilerGeneratedAttribute]
public int get_CaretOffset();
}
internal interface Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentFormattingService {
    [NullableContextAttribute("2")]
public abstract virtual string Format(string rawXmlText, Compilation compilation);
    [NullableContextAttribute("1")]
public abstract virtual ImmutableArray`1<TaggedText> Format(string rawXmlText, ISymbol symbol, SemanticModel semanticModel, int position, SymbolDisplayFormat format, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService {
    public string DocumentationCommentCharacter { get; }
    public abstract virtual string get_DocumentationCommentCharacter();
    public abstract virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnCharacterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CancellationToken cancellationToken, bool addIndentation);
    public abstract virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnCommandInvoke(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CancellationToken cancellationToken);
    public abstract virtual DocumentationCommentSnippet GetDocumentationCommentSnippetOnEnterTyped(SyntaxTree syntaxTree, SourceText text, int position, DocumentationCommentOptions& modreq(System.Runtime.InteropServices.InAttribute) options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual DocumentationCommentSnippet GetDocumentationCommentSnippetFromPreviousLine(DocumentationCommentOptions& modreq(System.Runtime.InteropServices.InAttribute) options, TextLine currentLine, TextLine previousLine);
    public abstract virtual bool IsValidTargetMember(SyntaxTree syntaxTree, SourceText text, int caretPosition, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService : AbstractEmbeddedLanguageFeatureService`1<IEmbeddedLanguageDocumentHighlighter> {
    protected AbstractDocumentHighlightsService(string languageName, EmbeddedLanguageInfo info, ISyntaxKinds syntaxKinds, IEnumerable`1<Lazy`2<IEmbeddedLanguageDocumentHighlighter, EmbeddedLanguageMetadata>> allServices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<GetDocumentHighlightsAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<DocumentHighlights>> GetDocumentHighlightsAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, HighlightingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<GetDocumentHighlightsInCurrentProcessAsync>d__2")]
private Task`1<ImmutableArray`1<DocumentHighlights>> GetDocumentHighlightsInCurrentProcessAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, HighlightingOptions options, CancellationToken cancellationToken);
    private ImmutableArray`1<DocumentHighlights> TryGetEmbeddedLanguageHighlights(Document document, SemanticModel semanticModel, int position, HighlightingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<GetTagsForReferencedSymbolAsync>d__4")]
private Task`1<ImmutableArray`1<DocumentHighlights>> GetTagsForReferencedSymbolAsync(ISymbol symbol, Document document, IImmutableSet`1<Document> documentsToSearch, CancellationToken cancellationToken);
    private static bool ShouldConsiderSymbol(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<FilterAndCreateSpansAsync>d__6")]
private Task`1<ImmutableArray`1<DocumentHighlights>> FilterAndCreateSpansAsync(ImmutableArray`1<ReferencedSymbol> references, Document startingDocument, IImmutableSet`1<Document> documentsToSearch, ISymbol symbol, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Location>> GetAdditionalReferencesAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<CreateSpansAsync>d__8")]
private static Task`1<ImmutableArray`1<DocumentHighlights>> CreateSpansAsync(Solution solution, ISymbol symbol, IEnumerable`1<ReferencedSymbol> references, ArrayBuilder`1<Location> additionalReferences, IImmutableSet`1<Document> documentToSearch, CancellationToken cancellationToken);
    private static bool ShouldIncludeDefinition(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<AddLocationSpanAsync>d__10")]
private static Task AddLocationSpanAsync(Location location, Solution solution, HashSet`1<DocumentSpan> spanSet, MultiDictionary`2<Document, HighlightSpan> tagList, HighlightSpanKind kind, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.AbstractDocumentHighlightsService/<GetLocationSpanAsync>d__11")]
private static Task`1<Nullable`1<DocumentSpan>> GetLocationSpanAsync(Solution solution, Location location, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.DocumentHighlighting.DocumentHighlights : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<HighlightSpan> <HighlightSpans>k__BackingField;
    [NullableAttribute("1")]
public Document Document { get; }
    public ImmutableArray`1<HighlightSpan> HighlightSpans { get; }
    public DocumentHighlights(Document document, ImmutableArray`1<HighlightSpan> highlightSpans);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<HighlightSpan> get_HighlightSpans();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.DocumentHighlighting.ExportEmbeddedLanguageDocumentHighlighterAttribute : ExportEmbeddedLanguageFeatureServiceAttribute {
    public ExportEmbeddedLanguageDocumentHighlighterAttribute(string name, String[] languages, bool supportsUnannotatedAPIs, String[] identifiers);
    public ExportEmbeddedLanguageDocumentHighlighterAttribute(string name, String[] languages, String[] identifiers);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.DocumentHighlighting.HighlightingOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <HighlightRelatedRegexComponentsUnderCursor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HighlightRelatedJsonComponentsUnderCursor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FrozenPartialSemantics>k__BackingField;
    public static HighlightingOptions Default;
    [DataMemberAttribute]
public bool HighlightRelatedRegexComponentsUnderCursor { get; public set; }
    [DataMemberAttribute]
public bool HighlightRelatedJsonComponentsUnderCursor { get; public set; }
    [DataMemberAttribute]
public bool FrozenPartialSemantics { get; public set; }
    private static HighlightingOptions();
    [CompilerGeneratedAttribute]
public bool get_HighlightRelatedRegexComponentsUnderCursor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HighlightRelatedRegexComponentsUnderCursor(bool value);
    [CompilerGeneratedAttribute]
public bool get_HighlightRelatedJsonComponentsUnderCursor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HighlightRelatedJsonComponentsUnderCursor(bool value);
    [CompilerGeneratedAttribute]
public bool get_FrozenPartialSemantics();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FrozenPartialSemantics(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(HighlightingOptions left, HighlightingOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(HighlightingOptions left, HighlightingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HighlightingOptions other);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.DocumentHighlighting.HighlightSpan : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private HighlightSpanKind <Kind>k__BackingField;
    [DataMemberAttribute]
public TextSpan TextSpan { get; }
    [DataMemberAttribute]
public HighlightSpanKind Kind { get; }
    public HighlightSpan(TextSpan textSpan, HighlightSpanKind kind);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public HighlightSpanKind get_Kind();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(HighlightSpan left, HighlightSpan right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(HighlightSpan left, HighlightSpan right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(HighlightSpan other);
}
internal enum Microsoft.CodeAnalysis.DocumentHighlighting.HighlightSpanKind : Enum {
    public int value__;
    public static HighlightSpanKind None;
    public static HighlightSpanKind Definition;
    public static HighlightSpanKind Reference;
    public static HighlightSpanKind WrittenReference;
}
internal interface Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<DocumentHighlights>> GetDocumentHighlightsAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, HighlightingOptions options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.DocumentHighlighting.IEmbeddedLanguageDocumentHighlighter {
    [NullableContextAttribute("1")]
public abstract virtual ImmutableArray`1<DocumentHighlights> GetDocumentHighlights(Document document, SemanticModel semanticModel, SyntaxToken token, int position, HighlightingOptions options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.DocumentHighlighting.IRemoteDocumentHighlightsService {
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableDocumentHighlights>> GetDocumentHighlightsAsync(Checksum solutionChecksum, DocumentId documentId, int position, ImmutableArray`1<DocumentId> documentIdsToSearch, HighlightingOptions options, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.DocumentHighlighting.SerializableDocumentHighlights : ValueType {
    [NullableAttribute("1")]
[DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public ImmutableArray`1<HighlightSpan> HighlightSpans;
    public SerializableDocumentHighlights(DocumentId documentId, ImmutableArray`1<HighlightSpan> highlightSpans);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.SerializableDocumentHighlights/<RehydrateAsync>d__3")]
public ValueTask`1<DocumentHighlights> RehydrateAsync(Solution solution);
    public static SerializableDocumentHighlights Dehydrate(DocumentHighlights highlights);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.DocumentIdSpan : ValueType {
    [CompilerGeneratedAttribute]
private DocumentId <documentId>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <sourceSpan>k__BackingField;
    [DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public TextSpan SourceSpan;
    public DocumentId documentId { get; public set; }
    public TextSpan sourceSpan { get; public set; }
    public DocumentIdSpan(DocumentId documentId, TextSpan sourceSpan);
    [CompilerGeneratedAttribute]
public DocumentId get_documentId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_documentId(DocumentId value);
    [CompilerGeneratedAttribute]
public TextSpan get_sourceSpan();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_sourceSpan(TextSpan value);
    public static DocumentIdSpan op_Implicit(DocumentSpan documentSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentIdSpan/<TryRehydrateAsync>d__12")]
public Task`1<Nullable`1<DocumentSpan>> TryRehydrateAsync(Solution solution, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentIdSpan left, DocumentIdSpan right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocumentIdSpan left, DocumentIdSpan right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocumentIdSpan other);
    [CompilerGeneratedAttribute]
public void Deconstruct(DocumentId& documentId, TextSpan& sourceSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.DocumentSpan : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <SourceSpan>k__BackingField;
    public Document Document { get; public set; }
    public TextSpan SourceSpan { get; public set; }
    public DocumentSpan(Document Document, TextSpan SourceSpan);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Document(Document value);
    [CompilerGeneratedAttribute]
public TextSpan get_SourceSpan();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceSpan(TextSpan value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentSpan left, DocumentSpan right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocumentSpan left, DocumentSpan right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocumentSpan other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Document& Document, TextSpan& SourceSpan);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.DocumentSpanExtensions : object {
    private static ValueTuple`2<Workspace, IDocumentNavigationService> GetNavigationParts(DocumentSpan documentSpan);
    [ExtensionAttribute]
public static Task`1<INavigableLocation> GetNavigableLocationAsync(DocumentSpan documentSpan, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentSpanExtensions/<IsHiddenAsync>d__2")]
[ExtensionAttribute]
public static Task`1<bool> IsHiddenAsync(DocumentSpan documentSpan, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer : object {
    internal static int DefaultStatementPart;
    private static string CreateNewOnMetadataUpdateAttributeName;
    private static SymbolDisplayFormat s_unqualifiedMemberDisplayFormat;
    private static SymbolDisplayFormat s_fullyQualifiedMemberDisplayFormat;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<SyntaxNode> _testFaultInjector;
    private static SourceText s_emptySource;
    private static SymbolEquivalenceComparer s_runtimeSymbolEqualityComparer;
    private static SymbolEquivalenceComparer s_exactSymbolEqualityComparer;
    private static TraceLog Log { get; }
    protected string LineDirectiveKeyword { get; }
    protected ushort LineDirectiveSyntaxKind { get; }
    protected SymbolDisplayFormat ErrorDisplayFormat { get; }
    internal Func`2<SyntaxNode, bool> IsLambda { get; }
    internal Func`2<SyntaxNode, bool> IsNotLambda { get; }
    internal SyntaxNode EmptyCompilationUnit { get; }
    protected AbstractEditAndContinueAnalyzer(Action`1<SyntaxNode> testFaultInjector);
    private static AbstractEditAndContinueAnalyzer();
    private static TraceLog get_Log();
    internal abstract virtual bool ExperimentalFeaturesEnabled(SyntaxTree tree);
    internal abstract virtual bool TryFindMemberDeclaration(SyntaxNode root, SyntaxNode node, TextSpan activeSpan, OneOrMany`1& declarations);
    [NullableContextAttribute("2")]
internal abstract virtual MemberBody TryGetDeclarationBody(SyntaxNode node, ISymbol symbol);
    internal abstract virtual bool IsDeclarationWithSharedBody(SyntaxNode declaration, ISymbol member);
    protected abstract virtual LambdaBody FindEnclosingLambdaBody(SyntaxNode encompassingAncestor, SyntaxNode node);
    protected abstract virtual Match`1<SyntaxNode> ComputeTopLevelMatch(SyntaxNode oldCompilationUnit, SyntaxNode newCompilationUnit);
    protected abstract virtual Nullable`1<BidirectionalMap`1<SyntaxNode>> ComputeParameterMap(SyntaxNode oldDeclaration, SyntaxNode newDeclaration);
    protected abstract virtual IEnumerable`1<SequenceEdit> GetSyntaxSequenceEdits(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    protected abstract virtual bool TryGetEnclosingBreakpointSpan(SyntaxToken token, TextSpan& span);
    protected abstract virtual bool TryGetActiveSpan(SyntaxNode node, int statementPart, int minLength, TextSpan& span);
    protected abstract virtual IEnumerable`1<ValueTuple`2<SyntaxNode, int>> EnumerateNearStatements(SyntaxNode statement);
    protected abstract virtual bool StatementLabelEquals(SyntaxNode node1, SyntaxNode node2);
    protected abstract virtual bool AreEquivalentActiveStatements(SyntaxNode oldStatement, SyntaxNode newStatement, int statementPart);
    protected abstract virtual bool AreEquivalentImpl(SyntaxToken oldToken, SyntaxToken newToken);
    private bool AreEquivalent(SyntaxToken oldToken, SyntaxToken newToken);
    protected abstract virtual bool IsNamespaceDeclaration(SyntaxNode node);
    protected abstract virtual bool IsCompilationUnitWithGlobalStatements(SyntaxNode node);
    protected abstract virtual bool IsGlobalStatement(SyntaxNode node);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetTopLevelTypeDeclarations(SyntaxNode compilationUnit);
    [NullableContextAttribute("2")]
protected abstract virtual void AddSymbolEdits(TemporaryArray`1& result, EditKind editKind, SyntaxNode oldNode, ISymbol oldSymbol, SyntaxNode newNode, ISymbol newSymbol, SemanticModel oldModel, SemanticModel newModel, Match`1<SyntaxNode> topMatch, IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, SymbolInfoCache symbolCache, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected abstract virtual OneOrMany`1<ValueTuple`2<ISymbol, ISymbol>> GetEditedSymbols(EditKind editKind, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel oldModel, SemanticModel newModel, CancellationToken cancellationToken);
    private OneOrMany`1<ValueTuple`3<ISymbol, ISymbol, EditKind>> GetSymbolEdits(EditKind editKind, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel oldModel, SemanticModel newModel, Match`1<SyntaxNode> topMatch, IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, SymbolInfoCache symbolCache, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetVariableUseSites(IEnumerable`1<SyntaxNode> roots, ISymbol localOrParameter, SemanticModel model, CancellationToken cancellationToken);
    protected abstract virtual bool AreHandledEventsEqual(IMethodSymbol oldMethod, IMethodSymbol newMethod);
    protected abstract virtual Nullable`1<TextSpan> TryGetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    internal TextSpan GetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    protected virtual TextSpan GetBodyDiagnosticSpan(SyntaxNode node, EditKind editKind);
    internal abstract virtual TextSpan GetLambdaParameterDiagnosticSpan(SyntaxNode lambda, int ordinal);
    internal string GetDisplayKindAndName(ISymbol symbol, string displayKind, bool fullyQualify);
    internal string GetDisplayName(SyntaxNode node, EditKind editKind);
    internal string GetDisplayKind(ISymbol symbol);
    internal virtual string GetDisplayName(IEventSymbol symbol);
    internal virtual string GetDisplayName(IPropertySymbol symbol);
    internal virtual string GetDisplayName(INamedTypeSymbol symbol);
    internal virtual string GetDisplayName(IFieldSymbol symbol);
    internal virtual string GetDisplayName(IMethodSymbol symbol);
    protected virtual string GetBodyDisplayName(SyntaxNode node, EditKind editKind);
    protected abstract virtual string TryGetDisplayName(SyntaxNode node, EditKind editKind);
    protected virtual string GetSuspensionPointDisplayName(SyntaxNode node, EditKind editKind);
    protected abstract virtual string get_LineDirectiveKeyword();
    protected abstract virtual ushort get_LineDirectiveSyntaxKind();
    protected abstract virtual SymbolDisplayFormat get_ErrorDisplayFormat();
    protected abstract virtual List`1<SyntaxNode> GetExceptionHandlingAncestors(SyntaxNode node, SyntaxNode root, bool isNonLeaf);
    protected abstract virtual TextSpan GetExceptionHandlingRegion(SyntaxNode node, Boolean& coversAllChildren);
    internal abstract virtual void ReportTopLevelSyntacticRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, Edit`1<SyntaxNode> edit, Dictionary`2<SyntaxNode, EditKind> editMap);
    internal abstract virtual void ReportEnclosingExceptionHandlingRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IEnumerable`1<Edit`1<SyntaxNode>> exceptionHandlingEdits, SyntaxNode oldStatement, TextSpan newStatementSpan);
    internal abstract virtual bool HasUnsupportedOperation(IEnumerable`1<SyntaxNode> newNodes, SyntaxNode& unsupportedNode, RudeEditKind& rudeEdit);
    private bool ReportUnsupportedOperations(DiagnosticContext& diagnosticContext, DeclarationBody body, CancellationToken cancellationToken);
    internal abstract virtual void ReportOtherRudeEditsAroundActiveStatement(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode oldActiveStatement, DeclarationBody oldBody, SyntaxNode newActiveStatement, DeclarationBody newBody, bool isNonLeaf);
    internal abstract virtual void ReportInsertedMemberSymbolRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, ISymbol newSymbol, SyntaxNode newNode, bool insertingIntoExistingContainingType);
    internal abstract virtual void ReportStateMachineSuspensionPointRudeEdits(DiagnosticContext diagnosticContext, SyntaxNode oldNode, SyntaxNode newNode);
    internal abstract virtual Func`2<SyntaxNode, bool> get_IsLambda();
    internal abstract virtual Func`2<SyntaxNode, bool> get_IsNotLambda();
    internal abstract virtual bool IsInterfaceDeclaration(SyntaxNode node);
    internal abstract virtual bool IsRecordDeclaration(SyntaxNode node);
    internal abstract virtual bool IsNestedFunction(SyntaxNode node);
    internal abstract virtual bool IsLocalFunction(SyntaxNode node);
    internal abstract virtual bool IsGenericLocalFunction(SyntaxNode node);
    internal abstract virtual bool IsClosureScope(SyntaxNode node);
    internal abstract virtual SyntaxNode GetCapturedParameterScope(SyntaxNode declaringMethodOrLambda);
    internal abstract virtual IMethodSymbol GetLambdaExpressionSymbol(SemanticModel model, SyntaxNode lambdaExpression, CancellationToken cancellationToken);
    internal abstract virtual SyntaxNode GetContainingQueryExpression(SyntaxNode node);
    internal abstract virtual bool QueryClauseLambdasTypeEquivalent(SemanticModel oldModel, SyntaxNode oldNode, SemanticModel newModel, SyntaxNode newNode, CancellationToken cancellationToken);
    internal bool ContainsLambda(MemberBody body);
    [NullableContextAttribute("2")]
internal abstract virtual bool TryGetLambdaBodies(SyntaxNode node, LambdaBody& body1, LambdaBody& body2);
    internal abstract virtual bool IsStateMachineMethod(SyntaxNode declaration);
    internal abstract virtual SyntaxNode TryGetContainingTypeDeclaration(SyntaxNode node);
    internal abstract virtual bool IsDeclarationWithInitializer(SyntaxNode declaration);
    internal abstract virtual bool IsPrimaryConstructorDeclaration(SyntaxNode declaration);
    internal abstract virtual bool IsConstructorWithMemberInitializers(ISymbol symbol, CancellationToken cancellationToken);
    internal abstract virtual bool IsPartial(INamedTypeSymbol type);
    internal abstract virtual SyntaxNode get_EmptyCompilationUnit();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer/<AnalyzeDocumentAsync>d__87")]
public sealed virtual Task`1<DocumentAnalysisResults> AnalyzeDocumentAsync(Project oldProject, AsyncLazy`1<ActiveStatementsMap> lazyOldActiveStatementMap, Document newDocument, ImmutableArray`1<ActiveStatementLineSpan> newActiveStatementSpans, AsyncLazy`1<EditAndContinueCapabilities> lazyCapabilities, CancellationToken cancellationToken);
    private void ReportTopLevelSyntacticRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, EditScript`1<SyntaxNode> syntacticEdits, Dictionary`2<SyntaxNode, EditKind> editMap);
    internal Dictionary`2<SyntaxNode, EditKind> BuildEditMap(EditScript`1<SyntaxNode> editScript);
    private void AnalyzeUnchangedActiveMemberBodies(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> topMatch, SourceText newText, ImmutableArray`1<UnmappedActiveStatement> oldActiveStatements, ImmutableArray`1<ActiveStatementLineSpan> newActiveStatementSpans, Builder<ActiveStatement> newActiveStatements, Builder<ImmutableArray`1<SourceFileSpan>> newExceptionRegions, CancellationToken cancellationToken);
    private void AnalyzeChangedMemberBody(SyntaxNode oldDeclaration, SyntaxNode newDeclaration, MemberBody oldMemberBody, MemberBody newMemberBody, SemanticModel oldModel, SemanticModel newModel, ISymbol oldMember, ISymbol newMember, Compilation oldCompilation, SourceText newText, bool isMemberReplaced, Match`1<SyntaxNode> topMatch, ImmutableArray`1<UnmappedActiveStatement> oldActiveStatements, ImmutableArray`1<ActiveStatementLineSpan> newActiveStatementSpans, EditAndContinueCapabilitiesGrantor capabilities, Builder<ActiveStatement> newActiveStatements, Builder<ImmutableArray`1<SourceFileSpan>> newExceptionRegions, ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxMaps& syntaxMaps, CancellationToken cancellationToken);
    private static bool TryGetTrackedStatement(ImmutableArray`1<ActiveStatementLineSpan> activeStatementSpans, ActiveStatementId id, SourceText text, MemberBody body, SyntaxNode& trackedStatement, Int32& trackedStatementPart);
    private ActiveStatement GetActiveStatementWithSpan(UnmappedActiveStatement oldStatement, SyntaxTree newTree, TextSpan newSpan, ArrayBuilder`1<RudeEditDiagnostic> diagnostics, CancellationToken cancellationToken);
    private void CalculateExceptionRegionsAroundActiveStatement(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode oldStatementSyntax, SyntaxNode oldEncompassingAncestor, SyntaxNode newStatementSyntax, SyntaxNode newEncompassingAncestor, TextSpan newStatementSyntaxSpan, int ordinal, bool isNonLeaf, Builder<ImmutableArray`1<SourceFileSpan>> newExceptionRegions, ArrayBuilder`1<RudeEditDiagnostic> diagnostics, CancellationToken cancellationToken);
    private DeclarationBodyMap IncludeLambdaBodyMaps(DeclarationBodyMap memberBodyMap, ArrayBuilder`1<ActiveNode> memberBodyActiveNodes, Dictionary`2& lazyActiveOrMatchedLambdas);
    private static DeclarationBodyMap ComputeLambdaBodyMap(LambdaBody oldLambdaBody, LambdaBody newLambdaBody, IReadOnlyList`1<ActiveNode> memberBodyActiveNodes, Dictionary`2<LambdaBody, LambdaInfo> activeOrMatchedLambdas);
    [NullableContextAttribute("2")]
private static DeclarationBodyMap ComputeDeclarationBodyMap(DeclarationBody oldBody, DeclarationBody newBody, IEnumerable`1<ActiveNode> activeNodes);
    private void ReportStateMachineBodyUpdateRudeEdits(DiagnosticContext& diagnosticContext, DeclarationBodyMap bodyMap, StateMachineInfo oldStateMachineInfo, StateMachineInfo newStateMachineInfo, bool hasActiveStatement, CancellationToken cancellationToken);
    private static List`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> GetMatchingActiveNodes(IEnumerable`1<ActiveNode> activeNodes);
    public sealed virtual ActiveStatementExceptionRegions GetExceptionRegions(SyntaxNode root, TextSpan unmappedActiveStatementSpan, bool isNonLeaf, CancellationToken cancellationToken);
    private ActiveStatementExceptionRegions GetExceptionRegions(List`1<SyntaxNode> exceptionHandlingAncestors, SyntaxTree tree, CancellationToken cancellationToken);
    private TextSpan GetDeletedNodeDiagnosticSpan(LambdaBody deletedLambdaBody, SyntaxNode oldEncompassingAncestor, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, Dictionary`2<LambdaBody, LambdaInfo> lambdaInfos);
    private TextSpan FindClosestActiveSpan(SyntaxNode statement, int statementPart);
    internal TextSpan GetDeletedNodeActiveSpan(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode deletedNode);
    internal TextSpan GetDeletedDeclarationActiveSpan(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode deletedDeclaration);
    internal TextSpan GetDeletedNodeDiagnosticSpan(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode deletedNode);
    [NullableContextAttribute("2")]
private static bool TryGetMatchingAncestor(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode oldNode, SyntaxNode& newAncestor);
    protected static bool HasParentEdit(IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, Edit`1<SyntaxNode> edit);
    protected static bool HasEdit(IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, SyntaxNode node, EditKind editKind);
    [NullableContextAttribute("2")]
protected void AddAroundActiveStatementRudeDiagnostic(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldNode, SyntaxNode newNode, TextSpan newActiveStatementSpan);
    protected void AddRudeUpdateAroundActiveStatement(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode newNode);
    protected void AddRudeInsertAroundActiveStatement(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode newNode);
    protected void AddRudeDeleteAroundActiveStatement(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldNode, TextSpan newActiveStatementSpan);
    protected void ReportUnmatchedStatements(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseMap, Func`2<SyntaxNode, bool> nodeSelector, SyntaxNode oldActiveStatement, SyntaxNode oldEncompassingAncestor, SyntaxNode newActiveStatement, SyntaxNode newEncompassingAncestor, Func`3<TSyntaxNode, TSyntaxNode, bool> areEquivalent, Func`3<TSyntaxNode, TSyntaxNode, bool> areSimilar);
    private void ReportRudeEditsAndInserts(List`1<SyntaxNode> oldNodes, List`1<SyntaxNode> newNodes, ArrayBuilder`1<RudeEditDiagnostic> diagnostics);
    private int MatchNodes(List`1<SyntaxNode> oldNodes, List`1<SyntaxNode> newNodes, ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseMap, Func`3<TSyntaxNode, TSyntaxNode, bool> comparer);
    private static int IndexOfEquivalent(SyntaxNode newNode, List`1<SyntaxNode> oldNodes, int startIndex, Func`3<TSyntaxNode, TSyntaxNode, bool> comparer);
    private static List`1<SyntaxNode> GetAncestors(SyntaxNode root, SyntaxNode node, Func`2<SyntaxNode, bool> nodeSelector);
    private void AnalyzeTrivia(Match`1<SyntaxNode> topMatch, IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, ArrayBuilder`1<ValueTuple`3<SyntaxNode, SyntaxNode, TextSpan>> triviaEdits, ArrayBuilder`1<SequencePointUpdates> lineEdits, CancellationToken cancellationToken);
    protected static bool SymbolsEquivalent(ISymbol oldSymbol, ISymbol newSymbol);
    protected static bool ParameterTypesEquivalent(ImmutableArray`1<IParameterSymbol> oldParameters, ImmutableArray`1<IParameterSymbol> newParameters, bool exact);
    protected static bool CustomModifiersEquivalent(CustomModifier oldModifier, CustomModifier newModifier, bool exact);
    protected static bool CustomModifiersEquivalent(ImmutableArray`1<CustomModifier> oldModifiers, ImmutableArray`1<CustomModifier> newModifiers, bool exact);
    protected static bool ReturnTypesEquivalent(IMethodSymbol oldMethod, IMethodSymbol newMethod, bool exact);
    protected static bool ReturnTypesEquivalent(IPropertySymbol oldProperty, IPropertySymbol newProperty, bool exact);
    protected static bool ReturnTypesEquivalent(IEventSymbol oldEvent, IEventSymbol newEvent, bool exact);
    protected static bool ReturnTypesEquivalent(IFieldSymbol oldField, IFieldSymbol newField, bool exact);
    [NullableContextAttribute("2")]
protected static bool TypesEquivalent(ITypeSymbol oldType, ITypeSymbol newType, bool exact);
    [NullableContextAttribute("0")]
protected static bool TypesEquivalent(ImmutableArray`1<T> oldTypes, ImmutableArray`1<T> newTypes, bool exact);
    protected static bool ParameterTypesEquivalent(IParameterSymbol oldParameter, IParameterSymbol newParameter, bool exact);
    protected static bool TypeParameterConstraintsEquivalent(ITypeParameterSymbol oldParameter, ITypeParameterSymbol newParameter, bool exact);
    protected static bool TypeParametersEquivalent(ImmutableArray`1<ITypeParameterSymbol> oldParameters, ImmutableArray`1<ITypeParameterSymbol> newParameters, bool exact);
    protected static bool BaseTypesEquivalent(INamedTypeSymbol oldType, INamedTypeSymbol newType, bool exact);
    [NullableContextAttribute("2")]
protected static bool MemberOrDelegateSignaturesEquivalent(ISymbol oldMember, ISymbol newMember, bool exact);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer/<AnalyzeSemanticsAsync>d__142")]
private Task`1<ImmutableArray`1<SemanticEditInfo>> AnalyzeSemanticsAsync(EditScript`1<SyntaxNode> editScript, IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, ImmutableArray`1<UnmappedActiveStatement> oldActiveStatements, ImmutableArray`1<ActiveStatementLineSpan> newActiveStatementSpans, IReadOnlyList`1<ValueTuple`3<SyntaxNode, SyntaxNode, TextSpan>> triviaEdits, Project oldProject, Document oldDocument, Document newDocument, SourceText newText, ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Builder<ActiveStatement> newActiveStatements, Builder<ImmutableArray`1<SourceFileSpan>> newExceptionRegions, EditAndContinueCapabilitiesGrantor capabilities, bool inBreakState, CancellationToken cancellationToken);
    protected static bool IsMemberOrDelegateReplaced(ISymbol oldMember, ISymbol newMember);
    protected static bool IsMember(ISymbol symbol);
    protected static bool IsMemberOrDelegate(ISymbol symbol);
    [NullableContextAttribute("2")]
protected static ISymbol GetSemanticallyMatchingNewSymbol(ISymbol oldSymbol, ISymbol newSymbol, SemanticModel newModel, SymbolInfoCache symbolCache, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected static void AddMemberUpdate(TemporaryArray`1& result, ISymbol oldSymbol, ISymbol newSymbol, ISymbol newSemanticallyMatchingSymbol);
    private static void AddSynthesizedMemberEditsForRecordParameterChange(ArrayBuilder`1<SemanticEditInfo> semanticEdits, IParameterSymbol parameterSymbol, INamedTypeSymbol otherContainingType, SymbolKey containingTypeKey, bool isParameterDelete, CancellationToken cancellationToken);
    private void AddDeconstructorEdits(ArrayBuilder`1<SemanticEditInfo> semanticEdits, IMethodSymbol constructor, IMethodSymbol otherConstructor, SymbolKey containingTypeKey, Compilation compilation, Compilation otherCompilation, bool isParameterDelete, CancellationToken cancellationToken);
    private static bool AllowsDeletion(ISymbol symbol);
    private static void AddUpdateEditsForMemberAndAccessors(ArrayBuilder`1<SemanticEditInfo> semanticEdits, ISymbol symbol, CancellationToken cancellationToken);
    private static void AddDeleteEditsForMemberAndAccessors(ArrayBuilder`1<SemanticEditInfo> semanticEdits, ISymbol oldSymbol, SymbolKey deletedSymbolContainer, CancellationToken cancellationToken);
    private static void AddInsertEditsForMemberAndAccessors(ArrayBuilder`1<SemanticEditInfo> semanticEdits, ISymbol newSymbol, CancellationToken cancellationToken);
    private static void AddMemberSignatureOrNameChangeEdits(ArrayBuilder`1<SemanticEditInfo> semanticEdits, ISymbol oldSymbol, ISymbol newSymbol, SymbolKey containingSymbolKey, CancellationToken cancellationToken);
    private ImmutableArray`1<ValueTuple`3<ISymbol, ISymbol, EditKind>> GetNamespaceSymbolEdits(SemanticModel oldModel, SemanticModel newModel, CancellationToken cancellationToken);
    private static bool IsReloadable(INamedTypeSymbol type);
    [NullableContextAttribute("2")]
private void ReportMemberOrLambdaBodyUpdateRudeEdits(DiagnosticContext& diagnosticContext, Compilation oldCompilation, SyntaxNode oldDeclaration, ISymbol oldMember, MemberBody oldMemberBody, DeclarationBody oldBody, SyntaxNode newDeclaration, ISymbol newMember, MemberBody newMemberBody, DeclarationBody newBody, EditAndContinueCapabilitiesGrantor capabilities, StateMachineInfo oldStateMachineInfo, StateMachineInfo newStateMachineInfo, CancellationToken cancellationToken);
    private void ReportUpdatedSymbolDeclarationRudeEdits(DiagnosticContext& diagnosticContext, EditAndContinueCapabilitiesGrantor capabilities, Boolean& hasGeneratedAttributeChange, Boolean& hasGeneratedReturnTypeAttributeChange, CancellationToken cancellationToken);
    private static bool GeneratesParameterAttribute(RefKind kind);
    private static void AnalyzeBaseTypes(INamedTypeSymbol oldType, INamedTypeSymbol newType, RudeEditKind& rudeEdit, Boolean& hasGeneratedAttributeChange);
    private static RudeEditKind GetSignatureChangeRudeEdit(ISymbol oldMember, ISymbol newMember, EditAndContinueCapabilitiesGrantor capabilities);
    private static void AnalyzeTypeParameter(ITypeParameterSymbol oldParameter, ITypeParameterSymbol newParameter, RudeEditKind& rudeEdit, Boolean& hasGeneratedAttributeChange);
    private static bool IsExtensionMethodThisParameter(IParameterSymbol parameter);
    private void AnalyzeSymbolUpdate(DiagnosticContext& diagnosticContext, EditAndContinueCapabilitiesGrantor capabilities, ArrayBuilder`1<SemanticEditInfo> semanticEdits, Boolean& hasAttributeChange, CancellationToken cancellationToken);
    private void AddSemanticEditsOriginatingFromParameterUpdate(ArrayBuilder`1<SemanticEditInfo> semanticEdits, IParameterSymbol oldParameterSymbol, IParameterSymbol newParameterSymbol, Compilation newCompilation, CancellationToken cancellationToken);
    private static void AddDelegateMethodEdit(ArrayBuilder`1<SemanticEditInfo> semanticEdits, INamedTypeSymbol delegateType, string methodName, CancellationToken cancellationToken);
    private void ReportCustomAttributeRudeEdits(DiagnosticContext& diagnosticContext, EditAndContinueCapabilitiesGrantor capabilities, Boolean& hasAttributeChange, Boolean& hasReturnTypeAttributeChange, CancellationToken cancellationToken);
    private bool ReportCustomAttributeRudeEdits(DiagnosticContext& diagnosticContext, Nullable`1<ImmutableArray`1<AttributeData>> oldAttributes, ImmutableArray`1<AttributeData> newAttributes, EditAndContinueCapabilitiesGrantor capabilities, CancellationToken cancellationToken);
    private static bool CanRenameOrChangeSignature(ISymbol oldSymbol, ISymbol newSymbol, EditAndContinueCapabilitiesGrantor capabilities);
    private static bool CanAddNewMemberToExistingType(ISymbol newSymbol, EditAndContinueCapabilitiesGrantor capabilities);
    private static EditAndContinueCapabilities GetRequiredAddMethodCapabilities(ISymbol symbol);
    private static EditAndContinueCapabilities GetRequiredAddFieldCapabilities(ISymbol symbol);
    private static bool CanUpdateMemberBody(ISymbol oldSymbol, EditAndContinueCapabilitiesGrantor capabilities);
    private static void AddSynthesizedRecordMethodUpdatesForPropertyChange(ArrayBuilder`1<SemanticEditInfo> semanticEdits, Compilation compilation, INamedTypeSymbol recordType, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer/<GetRecordUpdatedSynthesizedMethods>d__176")]
private static IEnumerable`1<ISymbol> GetRecordUpdatedSynthesizedMethods(Compilation compilation, INamedTypeSymbol record);
    [NullableContextAttribute("2")]
private DiagnosticContext CreateDiagnosticContext(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, ISymbol oldSymbol, ISymbol newSymbol, SyntaxNode newNode, SemanticModel newModel, Match`1<SyntaxNode> topMatch, TextSpan diagnosticSpan);
    internal void ReportTypeLayoutUpdateRudeEdits(DiagnosticContext& diagnosticContext, ISymbol newSymbol, CancellationToken cancellationToken);
    private bool HasBackingField(IParameterSymbol parameter, CancellationToken cancellationToken);
    private static bool HasBackingField(IEventSymbol event);
    private static bool HasExplicitOrSequentialLayout(INamedTypeSymbol type, SemanticModel model);
    private static Func`2<SyntaxNode, SyntaxNode> CreateSyntaxMapForEquivalentNodes(MemberBody oldBody, MemberBody newBody);
    private static Func`2<SyntaxNode, SyntaxNode> CreateSyntaxMap(DeclarationBodyMap bodyMap);
    private SyntaxMaps CreateAggregateSyntaxMaps(SyntaxTree newTree, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseTopMatches, IReadOnlyDictionary`2<SyntaxNode, SyntaxMaps> changedDeclarations);
    private void AddConstructorEdits(IReadOnlyDictionary`2<INamedTypeSymbol, MemberInitializationUpdates> updatedTypes, Match`1<SyntaxNode> topMatch, SemanticModel oldModel, Compilation oldCompilation, SemanticModel newModel, bool isStatic, ArrayBuilder`1<SemanticEditInfo> semanticEdits, ArrayBuilder`1<RudeEditDiagnostic> diagnostics, CancellationToken cancellationToken);
    private bool AnyMemberInitializerBody(INamedTypeSymbol type, Func`2<MemberBody, bool> predicate, bool isStatic, CancellationToken cancellationToken);
    private static IMethodSymbol TryGetParameterlessConstructor(INamedTypeSymbol type, bool isStatic);
    private static bool IsPartialTypeEdit(ISymbol oldSymbol, ISymbol newSymbol, SyntaxTree oldSyntaxTree, SyntaxTree newSyntaxTree);
    private void ReportLambdaAndClosureRudeEdits(SemanticModel oldModel, ISymbol oldMember, MemberBody oldMemberBody, SyntaxNode oldDeclaration, SemanticModel newModel, ISymbol newMember, MemberBody newMemberBody, SyntaxNode newDeclaration, IReadOnlyDictionary`2<LambdaBody, LambdaInfo> activeOrMatchedLambdas, DeclarationBodyMap bodyMap, EditAndContinueCapabilitiesGrantor capabilities, ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Boolean& syntaxMapRequired, Boolean& hasLambdaBodyUpdate, Func`2& runtimeRudeEdits, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[IteratorStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.AbstractEditAndContinueAnalyzer/<GetLambdaBodies>d__191")]
private IEnumerable`1<ValueTuple`3<SyntaxNode, LambdaBody, LambdaBody>> GetLambdaBodies(MemberBody body);
    private static VariableCaptureKind GetCaptureKind(ISymbol variable, IMethodSymbol liftingPrimaryConstructor);
    [NullableContextAttribute("2")]
private void GetCapturedVariables(MemberBody memberBody, SemanticModel model, IMethodSymbol liftingPrimaryConstructor, bool ignorePrimaryParameterCaptures, Boolean& hasLambdaBodies, ImmutableArray`1& variablesCapturedInLambdas, ImmutableArray`1& primaryParametersCapturedViaThis);
    private void ReportPrimaryParameterCaptureRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IMethodSymbol oldLiftingPrimaryConstructor, ImmutableArray`1<IParameterSymbol> oldPrimaryCaptures, IMethodSymbol newLiftingPrimaryConstructor, ImmutableArray`1<IParameterSymbol> newPrimaryCaptures, ISymbol newMember, CancellationToken cancellationToken);
    private static BitVector GetAccessedCaptures(LambdaBody lambdaBody, SemanticModel model, ImmutableArray`1<VariableCapture> captures, PooledDictionary`2<VariableCaptureKey, int> capturesIndex, IMethodSymbol liftingPrimaryConstructor);
    [NullableContextAttribute("0")]
private static void BuildIndex(Dictionary`2<VariableCaptureKey, int> index, ImmutableArray`1<VariableCapture> array);
    internal static ISymbol GetAssociatedMember(ISymbol symbol);
    protected abstract virtual SyntaxNode GetSymbolDeclarationSyntax(ISymbol symbol, Func`2<ImmutableArray`1<SyntaxReference>, SyntaxReference> selector, CancellationToken cancellationToken);
    protected SyntaxNode GetSymbolDeclarationSyntax(ISymbol symbol, CancellationToken cancellationToken);
    protected SyntaxNode GetSingleSymbolDeclarationSyntax(ISymbol symbol, CancellationToken cancellationToken);
    protected SyntaxNode GetSymbolDeclarationSyntax(ISymbol symbol, SyntaxTree tree, CancellationToken cancellationToken);
    protected abstract virtual ISymbol GetDeclaredSymbol(SemanticModel model, SyntaxNode declaration, CancellationToken cancellationToken);
    protected ISymbol GetRequiredDeclaredSymbol(SemanticModel model, SyntaxNode declaration, CancellationToken cancellationToken);
    private TextSpan GetSymbolLocationSpan(ISymbol symbol, CancellationToken cancellationToken);
    private CapturedParameterKey GetParameterKey(IParameterSymbol parameter, CancellationToken cancellationToken);
    private static bool TryMapParameter(CapturedParameterKey parameterKey, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> parameterMap, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> bodyMap, CapturedParameterKey& mappedParameterKey);
    [NullableContextAttribute("2")]
private void CalculateCapturedVariablesMaps(ImmutableArray`1<VariableCapture> oldCaptures, SyntaxNode oldDeclaration, IMethodSymbol oldPrimaryConstructor, ImmutableArray`1<VariableCapture> newCaptures, SyntaxNode newDeclaration, IMethodSymbol newPrimaryConstructor, DeclarationBodyMap bodyMap, ArrayBuilder`1<int> reverseCapturesMap, ArrayBuilder`1<SyntaxNode> newCapturesToClosureScopes, ArrayBuilder`1<SyntaxNode> oldCapturesToClosureScopes, Dictionary`2<SyntaxNode, RudeEditDiagnostic> closureRudeEdits, CancellationToken cancellationToken);
    private void ReportLambdaSignatureRudeEdits(DiagnosticContext diagnosticContext, SyntaxNode oldLambda, SyntaxNode newLambda, EditAndContinueCapabilitiesGrantor capabilities, Boolean& hasSignatureErrors, CancellationToken cancellationToken);
    private static ITypeSymbol GetType(ISymbol localOrParameter);
    private SyntaxNode GetCapturedVariableScope(ISymbol local, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool AreEquivalentClosureScopes(SyntaxNode oldScope, SyntaxNode newScope, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseMap);
    private static void ReportMissingStateMachineAttribute(DiagnosticContext& diagnosticContext, Compilation oldCompilation, StateMachineInfo kinds, CancellationToken cancellationToken);
    private static SyntaxNode FindPartner(OneOrMany`1<SyntaxNode> rootNodes, OneOrMany`1<SyntaxNode> otherRootNodes, SyntaxNode otherNode);
    internal static SyntaxNode FindPartner(SyntaxNode root, SyntaxNode otherRoot, SyntaxNode otherNode);
    internal static SyntaxNodeOrToken ChildThatContainsPosition(SyntaxNode self, int position, Int32& childIndex);
    internal static void FindLeafNodeAndPartner(SyntaxNode leftRoot, int leftPosition, SyntaxNode rightRoot, SyntaxNode& leftNode, SyntaxNode& rightNode);
    private static SyntaxNode TryGetNode(SyntaxNode root, int position);
    internal static void AddNodes(ArrayBuilder`1<SyntaxNode> nodes, SyntaxList`1<T> list);
    internal static void AddNodes(ArrayBuilder`1<SyntaxNode> nodes, Nullable`1<SeparatedSyntaxList`1<T>> list);
    private static bool IsGlobalMain(ISymbol symbol);
    private static bool InGenericContext(ISymbol symbol);
    private bool InGenericLocalContext(SyntaxNode node, OneOrMany`1<SyntaxNode> roots);
    public IMethodSymbol GetPrimaryConstructor(INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    public bool IsPrimaryConstructor(ISymbol symbol, CancellationToken cancellationToken);
    public bool IsPrimaryConstructorParameterMatchingSymbol(ISymbol symbol, CancellationToken cancellationToken);
    public IMethodSymbol GetEncompassingPrimaryConstructor(SyntaxNode declaration, ISymbol symbol, CancellationToken cancellationToken);
    private static IPropertySymbol GetPropertySynthesizedForRecordPrimaryConstructorParameter(IParameterSymbol parameter);
    private static bool SymbolPresenceAffectsSynthesizedRecordMembers(ISymbol symbol);
    private bool DeleteEditImpliesInsertEdit(ISymbol oldSymbol, ISymbol newSymbol, Compilation oldCompilation, CancellationToken cancellationToken);
    private static bool HasPrintMembersSignature(IMethodSymbol method, Compilation compilation);
    private static bool HasIEquatableEqualsSignature(IMethodSymbol method);
    private static bool HasGetHashCodeSignature(IMethodSymbol method);
    internal TestAccessor GetTestAccessor();
    [CompilerGeneratedAttribute]
internal static void <AnalyzeDocumentAsync>g__LogRudeEdits|87_0(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SourceText text, string filePath);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <BuildEditMap>b__89_0(KeyValuePair`2<SyntaxNode, EditKind> entry);
    [CompilerGeneratedAttribute]
private bool <AnalyzeTrivia>g__IsCurrentSegmentBreakpointSpanMappable|121_1(<>c__DisplayClass121_0& , <>c__DisplayClass121_2& );
    [CompilerGeneratedAttribute]
private void <AnalyzeTrivia>g__AddCurrentSegment|121_2(<>c__DisplayClass121_0& , <>c__DisplayClass121_1& , <>c__DisplayClass121_2& );
    [CompilerGeneratedAttribute]
private void <AnalyzeSemanticsAsync>g__AnalyzeRecordPropertyReplacement|142_3(IPropertySymbol oldProperty, IPropertySymbol newProperty, bool isDeleteEdit, <>c__DisplayClass142_0& , <>c__DisplayClass142_1& , <>c__DisplayClass142_3& );
    [CompilerGeneratedAttribute]
private void <AnalyzeSemanticsAsync>g__ReportDeletedMemberActiveStatementsRudeEdits|142_4(<>c__DisplayClass142_0& , <>c__DisplayClass142_1& , <>c__DisplayClass142_3& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private bool <AnalyzeSemanticsAsync>g__PreprocessSymbolEdit|142_1(ISymbol& oldSymbol, ISymbol& newSymbol, <>c__DisplayClass142_0& , <>c__DisplayClass142_1& );
    [CompilerGeneratedAttribute]
internal static ISymbol <AnalyzeSemanticsAsync>g__Resolve|142_8(ISymbol symbol, SymbolKey symbolKey, Compilation compilation, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <AnalyzeSemanticsAsync>g__DeferConstructorEdit|142_2(INamedTypeSymbol oldType, INamedTypeSymbol newType, SyntaxNode newDeclaration, SyntaxMaps syntaxMaps, bool isStatic, bool isMemberWithDeletedInitializer, <>c__DisplayClass142_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private ValueTuple`2<SyntaxNode, SyntaxNode> <AnalyzeSemanticsAsync>g__GetSymbolDeclarationNodes|142_0(ISymbol oldSymbol, ISymbol newSymbol, SyntaxNode oldNode, SyntaxNode newNode, <>c__DisplayClass142_0& );
    [CompilerGeneratedAttribute]
private void <AddDeconstructorEdits>g__AddEdits|149_0(IMethodSymbol constructor, Compilation otherCompilation, bool isDelete, <>c__DisplayClass149_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <AddUpdateEditsForMemberAndAccessors>g__AddUpdate|151_0(ISymbol symbol, <>c__DisplayClass151_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <AddDeleteEditsForMemberAndAccessors>g__AddDelete|152_0(ISymbol symbol, <>c__DisplayClass152_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <AddMemberSignatureOrNameChangeEdits>g__AddInsert|154_0(ISymbol symbol, <>c__DisplayClass154_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <AddMemberSignatureOrNameChangeEdits>g__AddDelete|154_1(ISymbol symbol, <>c__DisplayClass154_0& );
    [CompilerGeneratedAttribute]
internal static void <ReportCustomAttributeRudeEdits>g__FindChangedAttributes|169_0(Nullable`1<ImmutableArray`1<AttributeData>> oldAttributes, ImmutableArray`1<AttributeData> newAttributes, ArrayBuilder`1<AttributeData> changedAttributes);
    [CompilerGeneratedAttribute]
internal static AttributeData <ReportCustomAttributeRudeEdits>g__FindMatch|169_1(AttributeData attribute, Nullable`1<ImmutableArray`1<AttributeData>> oldAttributes);
    [CompilerGeneratedAttribute]
internal static bool <ReportCustomAttributeRudeEdits>g__IsNonCustomAttribute|169_2(AttributeData attribute);
    [CompilerGeneratedAttribute]
internal static bool <ReportCustomAttributeRudeEdits>g__IsSecurityAttribute|169_3(INamedTypeSymbol namedTypeSymbol);
    [CompilerGeneratedAttribute]
internal static bool <IsPartialTypeEdit>g__IsNotInDocument|189_0(SyntaxReference reference, SyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
internal static bool <IsPartialTypeEdit>g__IsPartialTypeEdit|189_1(ISymbol symbol, SyntaxTree tree);
    [CompilerGeneratedAttribute]
internal static void <GetCapturedVariables>g__AddCaptures|196_3(LambdaBody lambdaBody, <>c__DisplayClass196_0& );
    [CompilerGeneratedAttribute]
internal static bool <ReportPrimaryParameterCaptureRudeEdits>g__IsCapturedPrimaryParameterCapturedInType|197_0(IParameterSymbol capture, INamedTypeSymbol otherType);
    [CompilerGeneratedAttribute]
internal static string <ReportPrimaryParameterCaptureRudeEdits>g__GetLayoutKindDisplay|197_1(IParameterSymbol parameter);
    [CompilerGeneratedAttribute]
internal static void <GetAccessedCaptures>g__MarkVariables|198_0(ImmutableArray`1<ISymbol> variables, <>c__DisplayClass198_0& );
    [CompilerGeneratedAttribute]
private void <CalculateCapturedVariablesMaps>g__AddRuntimeRudeEdit|212_0(ISymbol newSymbol, RudeEditDiagnostic diagnostic, <>c__DisplayClass212_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.AbstractSimpleMemberBody : MemberBody {
    [CompilerGeneratedAttribute]
private SyntaxNode <node>P;
    public SyntaxNode Node { get; }
    public SyntaxTree SyntaxTree { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public TextSpan Envelope { get; }
    public SyntaxNode EncompassingAncestor { get; }
    protected AbstractSimpleMemberBody(SyntaxNode node);
    public SyntaxNode get_Node();
    public sealed virtual SyntaxTree get_SyntaxTree();
    public sealed virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    public sealed virtual TextSpan get_Envelope();
    public sealed virtual SyntaxNode get_EncompassingAncestor();
    [NullableContextAttribute("2")]
public sealed virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatement : object {
    public ActiveStatementId Id;
    public ManagedInstructionId InstructionId;
    public SourceFileSpan FileSpan;
    public ActiveStatementFlags Flags;
    public LinePositionSpan Span { get; }
    public string FilePath { get; }
    public bool IsLeaf { get; }
    public bool IsNonLeaf { get; }
    public bool IsMethodUpToDate { get; }
    public bool IsStale { get; }
    public ActiveStatement(ActiveStatementId id, ActiveStatementFlags flags, SourceFileSpan span, ManagedInstructionId instructionId);
    public ActiveStatement WithSpan(LinePositionSpan span);
    public ActiveStatement WithFileSpan(SourceFileSpan span);
    public ActiveStatement WithFlags(ActiveStatementFlags flags);
    public LinePositionSpan get_Span();
    public string get_FilePath();
    public bool get_IsLeaf();
    public bool get_IsNonLeaf();
    public bool get_IsMethodUpToDate();
    public bool get_IsStale();
    private string GetDebuggerDisplay();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementExceptionRegions : ValueType {
    public ImmutableArray`1<SourceFileSpan> Spans;
    public bool IsActiveStatementCovered;
    public ActiveStatementExceptionRegions(ImmutableArray`1<SourceFileSpan> spans, bool isActiveStatementCovered);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementId : ValueType {
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    [DataMemberAttribute]
public int Ordinal { get; public set; }
    public ActiveStatementId(int Ordinal);
    [CompilerGeneratedAttribute]
public int get_Ordinal();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Ordinal(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ActiveStatementId left, ActiveStatementId right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ActiveStatementId left, ActiveStatementId right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ActiveStatementId other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Ordinal);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementLineSpan : ValueType {
    [CompilerGeneratedAttribute]
private ActiveStatementId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePositionSpan <LineSpan>k__BackingField;
    [DataMemberAttribute]
public ActiveStatementId Id { get; public set; }
    [DataMemberAttribute]
public LinePositionSpan LineSpan { get; public set; }
    public ActiveStatementLineSpan(ActiveStatementId Id, LinePositionSpan LineSpan);
    [CompilerGeneratedAttribute]
public ActiveStatementId get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(ActiveStatementId value);
    [CompilerGeneratedAttribute]
public LinePositionSpan get_LineSpan();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineSpan(LinePositionSpan value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ActiveStatementLineSpan left, ActiveStatementLineSpan right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ActiveStatementLineSpan left, ActiveStatementLineSpan right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ActiveStatementLineSpan other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ActiveStatementId& Id, LinePositionSpan& LineSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap : object {
    public static ActiveStatementsMap Empty;
    public static Comparer`1<ActiveStatement> Comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Comparer`1<ValueTuple`3<ManagedActiveStatementDebugInfo, SourceFileSpan, ActiveStatementId>> s_infoSpanComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, ImmutableArray`1<ActiveStatement>> DocumentPathMap;
    public IReadOnlyDictionary`2<ManagedInstructionId, ActiveStatement> InstructionMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<SyntaxTree, ImmutableArray`1<UnmappedActiveStatement>> _lazyOldDocumentActiveStatements;
    public bool IsEmpty { get; }
    public ActiveStatementsMap(IReadOnlyDictionary`2<string, ImmutableArray`1<ActiveStatement>> documentPathMap, IReadOnlyDictionary`2<ManagedInstructionId, ActiveStatement> instructionMap);
    private static ActiveStatementsMap();
    [NullableContextAttribute("0")]
public static ActiveStatementsMap Create(ImmutableArray`1<ManagedActiveStatementDebugInfo> debugInfos, ImmutableDictionary`2<ManagedMethodId, ImmutableArray`1<NonRemappableRegion>> remapping);
    private static bool TryGetUpToDateSpan(ManagedActiveStatementDebugInfo activeStatementInfo, ImmutableDictionary`2<ManagedMethodId, ImmutableArray`1<NonRemappableRegion>> remapping, LinePositionSpan& newSpan);
    public bool get_IsEmpty();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementsMap/<GetOldActiveStatementsAsync>d__11")]
internal ValueTask`1<ImmutableArray`1<UnmappedActiveStatement>> GetOldActiveStatementsAsync(IEditAndContinueAnalyzer analyzer, Document oldDocument, CancellationToken cancellationToken);
    internal ImmutableArray`1<UnmappedActiveStatement> GetOldActiveStatements(IEditAndContinueAnalyzer analyzer, SyntaxTree oldSyntaxTree, SourceText oldText, SyntaxNode oldRoot, CancellationToken cancellationToken);
    private ImmutableArray`1<UnmappedActiveStatement> CalculateOldActiveStatementsAndExceptionRegions(IEditAndContinueAnalyzer analyzer, SyntaxTree oldTree, SourceText oldText, SyntaxNode oldRoot, CancellationToken cancellationToken);
    private static LinePositionSpan ReverseMapLinePositionSpan(LinePositionSpan unmappedSection, LinePositionSpan mappedSection, LinePositionSpan mappedSpan);
    private static bool TryGetTextSpan(TextLineCollection lines, LinePositionSpan lineSpan, TextSpan& span);
    internal static Range GetSpansStartingInSpan(TPosition spanStart, TPosition spanEnd, ImmutableArray`1<TElement> spans, Func`3<TElement, TPosition, int> startPositionComparer);
    [CompilerGeneratedAttribute]
internal static void <CalculateOldActiveStatementsAndExceptionRegions>g__AddStatement|13_0(LinePositionSpan unmappedLineSpan, ActiveStatement activeStatement, <>c__DisplayClass13_0& );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpan : ValueType {
    [CompilerGeneratedAttribute]
private ActiveStatementId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePositionSpan <LineSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private ActiveStatementFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <UnmappedDocumentId>k__BackingField;
    [DataMemberAttribute]
public ActiveStatementId Id { get; public set; }
    [DataMemberAttribute]
public LinePositionSpan LineSpan { get; public set; }
    [DataMemberAttribute]
public ActiveStatementFlags Flags { get; public set; }
    [DataMemberAttribute]
public DocumentId UnmappedDocumentId { get; public set; }
    public ActiveStatementSpan(ActiveStatementId Id, LinePositionSpan LineSpan, ActiveStatementFlags Flags, DocumentId UnmappedDocumentId);
    [CompilerGeneratedAttribute]
public ActiveStatementId get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(ActiveStatementId value);
    [CompilerGeneratedAttribute]
public LinePositionSpan get_LineSpan();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineSpan(LinePositionSpan value);
    [CompilerGeneratedAttribute]
public ActiveStatementFlags get_Flags();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Flags(ActiveStatementFlags value);
    [CompilerGeneratedAttribute]
public DocumentId get_UnmappedDocumentId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnmappedDocumentId(DocumentId value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ActiveStatementSpan left, ActiveStatementSpan right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ActiveStatementSpan left, ActiveStatementSpan right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ActiveStatementSpan other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ActiveStatementId& Id, LinePositionSpan& LineSpan, ActiveStatementFlags& Flags, DocumentId& UnmappedDocumentId);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProvider : MulticastDelegate {
    public ActiveStatementSpanProvider(object object, IntPtr method);
    public virtual ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> Invoke(DocumentId documentId, string filePath, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(DocumentId documentId, string filePath, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> EndInvoke(IAsyncResult result);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProviderCallback : object {
    [NullableAttribute("1")]
private ActiveStatementSpanProvider _provider;
    [NullableContextAttribute("1")]
public ActiveStatementSpanProviderCallback(ActiveStatementSpanProvider provider);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.ActiveStatementSpanProviderCallback/<GetSpansAsync>d__2")]
public ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> GetSpansAsync(DocumentId documentId, string filePath, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.BidirectionalMap`1 : ValueType {
    public IReadOnlyDictionary`2<T, T> Forward;
    public IReadOnlyDictionary`2<T, T> Reverse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static BidirectionalMap`1<T> Empty;
    public BidirectionalMap`1(IReadOnlyDictionary`2<T, T> forward, IReadOnlyDictionary`2<T, T> reverse);
    private static BidirectionalMap`1();
    public BidirectionalMap`1<T> With(T source, T target);
    public BidirectionalMap`1<T> With(BidirectionalMap`1<T> map);
    public BidirectionalMap`1<T> WithMatch(Match`1<T> match);
    public static BidirectionalMap`1<T> FromMatch(Match`1<T> match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution : object {
    private DebuggingSession _debuggingSession;
    private Solution _solution;
    private Dictionary`2<DocumentId, DocumentState> _documentState;
    private object _guard;
    public CommittedSolution(DebuggingSession debuggingSession, Solution solution, IEnumerable`1<KeyValuePair`2<DocumentId, DocumentState>> initialDocumentStates);
    internal void Test_SetDocumentState(DocumentId documentId, DocumentState state);
    internal ImmutableArray`1<ValueTuple`2<DocumentId, DocumentState>> Test_GetDocumentStates();
    public bool HasNoChanges(Solution solution);
    public Project GetProject(ProjectId id);
    public Project GetRequiredProject(ProjectId id);
    public ImmutableArray`1<DocumentId> GetDocumentIdsWithFilePath(string path);
    public bool ContainsDocument(DocumentId documentId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution/<GetDocumentAndStateAsync>d__13")]
public Task`1<ValueTuple`2<Document, DocumentState>> GetDocumentAndStateAsync(DocumentId documentId, Document currentDocument, CancellationToken cancellationToken, bool reloadOutOfSyncDocument);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution/<TryGetMatchingSourceTextAsync>d__14")]
private ValueTask`1<ValueTuple`2<Optional`1<SourceText>, Nullable`1<bool>>> TryGetMatchingSourceTextAsync(Document document, SourceText sourceText, Document currentDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution/<TryGetMatchingSourceTextAsync>d__15")]
private static ValueTask`1<Optional`1<SourceText>> TryGetMatchingSourceTextAsync(SourceText sourceText, string filePath, Document currentDocument, IPdbMatchingSourceTextProvider sourceTextProvider, ImmutableArray`1<byte> requiredChecksum, SourceHashAlgorithm checksumAlgorithm, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.CommittedSolution/<GetMatchingDocumentsAsync>d__16")]
internal static Task`1<IEnumerable`1<KeyValuePair`2<DocumentId, DocumentState>>> GetMatchingDocumentsAsync(IEnumerable`1<ValueTuple`2<Project, IEnumerable`1<DocumentState>>> documentsByProject, Func`2<Project, CompilationOutputs> compilationOutputsProvider, IPdbMatchingSourceTextProvider sourceTextProvider, CancellationToken cancellationToken);
    private static DebugInformationReaderProvider GetMethodDebugInfoReader(CompilationOutputs compilationOutputs, string projectName);
    public void CommitSolution(Solution solution);
    [NullableContextAttribute("0")]
private static bool IsMatchingSourceText(SourceText sourceText, ImmutableArray`1<byte> requiredChecksum, SourceHashAlgorithm checksumAlgorithm);
    [NullableContextAttribute("0")]
private static Optional`1<SourceText> TryGetPdbMatchingSourceTextFromDisk(string sourceFilePath, Encoding encoding, ImmutableArray`1<byte> requiredChecksum, SourceHashAlgorithm checksumAlgorithm);
    [NullableContextAttribute("0")]
private Nullable`1<bool> TryReadSourceFileChecksumFromPdb(Document document, ImmutableArray`1& requiredChecksum, SourceHashAlgorithm& checksumAlgorithm);
    private static Nullable`1<bool> TryReadSourceFileChecksumFromPdb(EditAndContinueMethodDebugInfoReader debugInfoReader, string sourceFilePath, ImmutableArray`1& checksum, SourceHashAlgorithm& algorithm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession : object {
    private Func`2<Project, CompilationOutputs> _compilationOutputsProvider;
    internal IPdbMatchingSourceTextProvider SourceTextProvider;
    private CancellationTokenSource _cancellationSource;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ProjectId, ValueTuple`2<Guid, Diagnostic>> _projectModuleIds;
    private Dictionary`2<Guid, ProjectId> _moduleIds;
    private object _projectModuleIdsGuard;
    private Dictionary`2<ProjectId, ProjectBaseline> _projectBaselines;
    private List`1<IDisposable> _initialBaselineModuleReaders;
    private object _projectEmitBaselinesGuard;
    private ReaderWriterLockSlim _baselineAccessLock;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private EditSession <EditSession>k__BackingField;
    private HashSet`1<Guid> _modulesPreparedForUpdate;
    private object _modulesPreparedForUpdateGuard;
    internal DebuggingSessionId Id;
    private int _updateOrdinal;
    internal CommittedSolution LastCommittedSolution;
    internal IManagedHotReloadService DebuggerService;
    internal bool ReportDiagnostics;
    private DebuggingSessionTelemetry _telemetry;
    private EditSessionTelemetry _editSessionTelemetry;
    [NullableAttribute("2")]
private PendingUpdate _pendingUpdate;
    private Action`1<Data> _reportTelemetry;
    [NullableAttribute("0")]
private ImmutableArray`1<ManagedHotReloadUpdate> _lastModuleUpdatesLog;
    internal EditSession EditSession { get; private set; }
    internal DebuggingSession(DebuggingSessionId id, Solution solution, IManagedHotReloadService debuggerService, Func`2<Project, CompilationOutputs> compilationOutputsProvider, IPdbMatchingSourceTextProvider sourceTextProvider, IEnumerable`1<KeyValuePair`2<DocumentId, DocumentState>> initialDocumentStates, bool reportDiagnostics);
    [CompilerGeneratedAttribute]
internal EditSession get_EditSession();
    [CompilerGeneratedAttribute]
private void set_EditSession(EditSession value);
    public sealed virtual void Dispose();
    internal void ThrowIfDisposed();
    private void StorePendingUpdate(PendingUpdate update);
    private PendingUpdate RetrievePendingUpdate();
    private void EndEditSession();
    public void EndSession(Data& telemetryData);
    public void BreakStateOrCapabilitiesChanged(Nullable`1<bool> inBreakState);
    internal void RestartEditSession(ImmutableDictionary`2<ManagedMethodId, ImmutableArray`1<NonRemappableRegion>> nonRemappableRegions, Nullable`1<bool> inBreakState);
    private ImmutableArray`1<IDisposable> GetBaselineModuleReaders();
    internal CompilationOutputs GetCompilationOutputs(Project project);
    private bool AddModulePreparedForUpdate(Guid mvid);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession/<GetProjectModuleIdAsync>d__39")]
internal Task`1<ValueTuple`2<Guid, Diagnostic>> GetProjectModuleIdAsync(Project project, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal bool TryGetProjectId(Guid moduleId, ProjectId& projectId);
    internal bool TryGetOrCreateEmitBaseline(Project baselineProject, Compilation baselineCompilation, ImmutableArray`1& diagnostics, ProjectBaseline& baseline, ReaderWriterLockSlim& baselineAccessLock);
    private static bool TryCreateInitialBaseline(Compilation compilation, CompilationOutputs compilationOutputs, ProjectId projectId, ImmutableArray`1& diagnostics, EmitBaseline& baseline, DebugInformationReaderProvider& debugInfoReaderProvider, MetadataReaderProvider& metadataReaderProvider);
    private static ImmutableDictionary`2<K, ImmutableArray`1<V>> GroupToImmutableDictionary(IEnumerable`1<IGrouping`2<K, V>> items);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession/<GetDocumentDiagnosticsAsync>d__44")]
public ValueTask`1<ImmutableArray`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession/<EmitSolutionUpdateAsync>d__45")]
public ValueTask`1<EmitSolutionUpdateResults> EmitSolutionUpdateAsync(Solution solution, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public void CommitSolutionUpdate();
    public void DiscardSolutionUpdate();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession/<GetBaseActiveStatementSpansAsync>d__48")]
public ValueTask`1<ImmutableArray`1<ImmutableArray`1<ActiveStatementSpan>>> GetBaseActiveStatementSpansAsync(Solution solution, ImmutableArray`1<DocumentId> documentIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.DebuggingSession/<GetAdjustedActiveStatementSpansAsync>d__49")]
public ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> GetAdjustedActiveStatementSpansAsync(TextDocument mappedDocument, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    private static void ReportTelemetry(Data data);
    internal TestAccessor GetTestAccessor();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionId : ValueType {
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    [DataMemberAttribute]
public int Ordinal { get; public set; }
    public DebuggingSessionId(int Ordinal);
    [CompilerGeneratedAttribute]
public int get_Ordinal();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Ordinal(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DebuggingSessionId left, DebuggingSessionId right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DebuggingSessionId left, DebuggingSessionId right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebuggingSessionId other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Ordinal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.DebuggingSessionTelemetry : object {
    private object _guard;
    private Guid _solutionSessionId;
    private List`1<Data> _editSessionData;
    private int _emptyEditSessionCount;
    private int _emptyHotReloadEditSessionCount;
    public DebuggingSessionTelemetry(Guid solutionSessionId);
    public Data GetDataAndClear();
    public void LogEditSession(Data editSessionTelemetryData);
    public static void Log(Data data, Action`2<FunctionId, LogMessage> log, Func`1<int> getNextId);
    [CompilerGeneratedAttribute]
internal static PiiValue <Log>g__ProjectIdToPii|9_4(Guid projectId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody : object {
    public SyntaxTree SyntaxTree { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public SyntaxNode EncompassingAncestor { get; }
    public abstract virtual SyntaxTree get_SyntaxTree();
    public abstract virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody/<GetExpressionsAndStatements>d__4")]
public virtual IEnumerable`1<SyntaxNode> GetExpressionsAndStatements();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.DeclarationBody/<GetDescendantNodes>d__5")]
public IEnumerable`1<SyntaxNode> GetDescendantNodes(Func`2<SyntaxNode, bool> descendIntoChildren);
    public abstract virtual SyntaxNode get_EncompassingAncestor();
    public abstract virtual StateMachineInfo GetStateMachineInfo();
    public abstract virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual DeclarationBodyMap ComputeMap(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public abstract virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public abstract virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DeclarationBody other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.DeclarationBodyMap : ValueType {
    public static DeclarationBodyMap Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> <Forward>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> <Reverse>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SyntaxNode, SyntaxNode> <AdditionalReverseMapping>k__BackingField;
    public IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> Forward { get; }
    public IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> Reverse { get; }
    public ImmutableDictionary`2<SyntaxNode, SyntaxNode> AdditionalReverseMapping { get; }
    public DeclarationBodyMap(IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMatch, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseMatch, ImmutableDictionary`2<SyntaxNode, SyntaxNode> additionalReverseMapping);
    private static DeclarationBodyMap();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> get_Forward();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> get_Reverse();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<SyntaxNode, SyntaxNode> get_AdditionalReverseMapping();
    public static DeclarationBodyMap FromMatch(Match`1<SyntaxNode> match);
    public DeclarationBodyMap WithAdditionalMapping(SyntaxNode oldNode, SyntaxNode newNode);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.DocumentActiveStatementChanges : ValueType {
    public ImmutableArray`1<UnmappedActiveStatement> OldStatements;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ActiveStatement> NewStatements;
    public ImmutableArray`1<ImmutableArray`1<SourceFileSpan>> NewExceptionRegions;
    public DocumentActiveStatementChanges(ImmutableArray`1<UnmappedActiveStatement> oldSpans, ImmutableArray`1<ActiveStatement> newStatements, ImmutableArray`1<ImmutableArray`1<SourceFileSpan>> newExceptionRegions);
    public void Deconstruct(ImmutableArray`1& oldStatements, ImmutableArray`1& newStatements, ImmutableArray`1& newExceptionRegions);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.DocumentAnalysisResults : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [NullableAttribute("1")]
public string FilePath;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ActiveStatement> <ActiveStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RudeEditDiagnostic> <RudeEdits>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Diagnostic <SyntaxError>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SemanticEditInfo> <SemanticEdits>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ImmutableArray`1<SourceFileSpan>> <ExceptionRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SequencePointUpdates> <LineEdits>k__BackingField;
    [CompilerGeneratedAttribute]
private EditAndContinueCapabilities <RequiredCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ElapsedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSyntaxErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasBlockingRudeEdits>k__BackingField;
    [NullableAttribute("1")]
public DocumentId DocumentId { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ActiveStatement> ActiveStatements { get; }
    public ImmutableArray`1<RudeEditDiagnostic> RudeEdits { get; }
    [NullableAttribute("2")]
public Diagnostic SyntaxError { get; }
    public ImmutableArray`1<SemanticEditInfo> SemanticEdits { get; }
    public ImmutableArray`1<ImmutableArray`1<SourceFileSpan>> ExceptionRegions { get; }
    public ImmutableArray`1<SequencePointUpdates> LineEdits { get; }
    public EditAndContinueCapabilities RequiredCapabilities { get; }
    public TimeSpan ElapsedTime { get; }
    public bool HasSyntaxErrors { get; }
    public bool HasChanges { get; }
    public bool HasBlockingRudeEdits { get; }
    public bool HasChangesAndErrors { get; }
    public bool HasChangesAndSyntaxErrors { get; }
    public bool HasSignificantValidChanges { get; }
    public DocumentAnalysisResults(DocumentId documentId, string filePath, ImmutableArray`1<ActiveStatement> activeStatementsOpt, ImmutableArray`1<RudeEditDiagnostic> rudeEdits, Diagnostic syntaxError, ImmutableArray`1<SemanticEditInfo> semanticEditsOpt, ImmutableArray`1<ImmutableArray`1<SourceFileSpan>> exceptionRegionsOpt, ImmutableArray`1<SequencePointUpdates> lineEditsOpt, EditAndContinueCapabilities requiredCapabilities, TimeSpan elapsedTime, bool hasChanges, bool hasSyntaxErrors, bool hasBlockingRudeEdits);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ActiveStatement> get_ActiveStatements();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RudeEditDiagnostic> get_RudeEdits();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Diagnostic get_SyntaxError();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SemanticEditInfo> get_SemanticEdits();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ImmutableArray`1<SourceFileSpan>> get_ExceptionRegions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SequencePointUpdates> get_LineEdits();
    [CompilerGeneratedAttribute]
public EditAndContinueCapabilities get_RequiredCapabilities();
    [CompilerGeneratedAttribute]
public TimeSpan get_ElapsedTime();
    [CompilerGeneratedAttribute]
public bool get_HasSyntaxErrors();
    [CompilerGeneratedAttribute]
public bool get_HasChanges();
    [CompilerGeneratedAttribute]
public bool get_HasBlockingRudeEdits();
    public bool get_HasChangesAndErrors();
    public bool get_HasChangesAndSyntaxErrors();
    public bool get_HasSignificantValidChanges();
    [NullableContextAttribute("1")]
public static DocumentAnalysisResults SyntaxErrors(DocumentId documentId, string filePath, ImmutableArray`1<RudeEditDiagnostic> rudeEdits, Diagnostic syntaxError, TimeSpan elapsedTime, bool hasChanges);
    [NullableContextAttribute("1")]
public static DocumentAnalysisResults Unchanged(DocumentId documentId, string filePath, TimeSpan elapsedTime);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilities : Enum {
    public int value__;
    public static EditAndContinueCapabilities None;
    public static EditAndContinueCapabilities Baseline;
    public static EditAndContinueCapabilities AddMethodToExistingType;
    public static EditAndContinueCapabilities AddStaticFieldToExistingType;
    public static EditAndContinueCapabilities AddInstanceFieldToExistingType;
    public static EditAndContinueCapabilities NewTypeDefinition;
    public static EditAndContinueCapabilities ChangeCustomAttributes;
    public static EditAndContinueCapabilities UpdateParameters;
    public static EditAndContinueCapabilities GenericAddMethodToExistingType;
    public static EditAndContinueCapabilities GenericUpdateMethod;
    public static EditAndContinueCapabilities GenericAddFieldToExistingType;
    public static EditAndContinueCapabilities AddExplicitInterfaceImplementation;
}
internal class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilitiesGrantor : object {
    private EditAndContinueCapabilities _availableCapabilities;
    [CompilerGeneratedAttribute]
private EditAndContinueCapabilities <GrantedCapabilities>k__BackingField;
    public EditAndContinueCapabilities GrantedCapabilities { get; private set; }
    public EditAndContinueCapabilitiesGrantor(EditAndContinueCapabilities availableCapabilities);
    [CompilerGeneratedAttribute]
public EditAndContinueCapabilities get_GrantedCapabilities();
    [CompilerGeneratedAttribute]
private void set_GrantedCapabilities(EditAndContinueCapabilities value);
    public bool Grant(EditAndContinueCapabilities capabilities);
    [NullableContextAttribute("1")]
public bool GrantNewTypeDefinition(INamedTypeSymbol type);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueCapabilitiesParser : object {
    public static EditAndContinueCapabilities Parse(ImmutableArray`1<string> capabilities);
    [ExtensionAttribute]
public static ImmutableArray`1<string> ToStringArray(EditAndContinueCapabilities capabilities);
}
internal static class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDiagnosticDescriptors : object {
    private static int GeneralDiagnosticBaseId;
    private static int ModuleDiagnosticBaseId;
    private static int s_diagnosticBaseIndex;
    private static LocalizableResourceString s_rudeEditLocString;
    private static LocalizableResourceString s_encLocString;
    private static LocalizableResourceString s_encDisallowedByProjectLocString;
    private static ImmutableArray`1<DiagnosticDescriptor> s_descriptors;
    private static Dictionary`2<ManagedHotReloadAvailabilityStatus, DiagnosticDescriptor> s_lazyModuleDiagnosticDescriptors;
    private static object s_moduleDiagnosticDescriptorsGuard;
    private static EditAndContinueDiagnosticDescriptors();
    internal static ImmutableArray`1<DiagnosticDescriptor> GetDescriptors();
    internal static DiagnosticDescriptor GetDescriptor(RudeEditKind kind);
    internal static DiagnosticDescriptor GetDescriptor(EditAndContinueErrorCode errorCode);
    internal static DiagnosticDescriptor GetModuleDiagnosticDescriptor(ManagedHotReloadAvailabilityStatus status);
    private static int GetDescriptorIndex(RudeEditKind kind);
    private static int GetDescriptorIndex(EditAndContinueErrorCode errorCode);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__add|9_0(int index, int id, string resourceName, LocalizableResourceString title, DiagnosticSeverity severity, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddRudeEdit|9_1(RudeEditKind kind, string resourceName, DiagnosticSeverity severity, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddGeneralDiagnostic|9_2(EditAndContinueErrorCode code, string resourceName, DiagnosticSeverity severity, <>c__DisplayClass9_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDocumentAnalysesCache : object {
    private object _guard;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DocumentId, ValueTuple`4<AsyncLazy`1<DocumentAnalysisResults>, Project, Document, ImmutableArray`1<ActiveStatementLineSpan>>> _analyses;
    private AsyncLazy`1<ActiveStatementsMap> _baseActiveStatements;
    private AsyncLazy`1<EditAndContinueCapabilities> _capabilities;
    public EditAndContinueDocumentAnalysesCache(AsyncLazy`1<ActiveStatementsMap> baseActiveStatements, AsyncLazy`1<EditAndContinueCapabilities> capabilities);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDocumentAnalysesCache/<GetDocumentAnalysesAsync>d__5")]
public ValueTask`1<ImmutableArray`1<DocumentAnalysisResults>> GetDocumentAnalysesAsync(CommittedSolution oldSolution, IReadOnlyList`1<ValueTuple`2<Document, Document>> documents, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDocumentAnalysesCache/<GetDocumentAnalysisAsync>d__6")]
public ValueTask`1<DocumentAnalysisResults> GetDocumentAnalysisAsync(CommittedSolution oldSolution, Document oldDocument, Document newDocument, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueDocumentAnalysesCache/<GetLatestUnmappedActiveStatementSpansAsync>d__7")]
private Task`1<ImmutableArray`1<ActiveStatementLineSpan>> GetLatestUnmappedActiveStatementSpansAsync(Document oldDocument, Document newDocument, ActiveStatementSpanProvider newActiveStatementSpanProvider, CancellationToken cancellationToken);
    private AsyncLazy`1<DocumentAnalysisResults> GetDocumentAnalysisNoLock(Project baseProject, Document document, ImmutableArray`1<ActiveStatementLineSpan> activeStatementSpans);
}
internal enum Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueErrorCode : Enum {
    public int value__;
    public static EditAndContinueErrorCode ErrorReadingFile;
    public static EditAndContinueErrorCode CannotApplyChangesUnexpectedError;
    public static EditAndContinueErrorCode ChangesDisallowedWhileStoppedAtException;
    public static EditAndContinueErrorCode DocumentIsOutOfSyncWithDebuggee;
    public static EditAndContinueErrorCode UnableToReadSourceFileOrPdb;
    public static EditAndContinueErrorCode AddingTypeRuntimeCapabilityRequired;
}
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueMethodDebugInfoReader : object {
    internal static bool IgnoreCaseWhenComparingDocumentNames;
    public bool IsPortable { get; }
    public abstract virtual bool get_IsPortable();
    public abstract virtual EditAndContinueMethodDebugInformation GetDebugInfo(MethodDefinitionHandle methodHandle);
    public abstract virtual StandaloneSignatureHandle GetLocalSignature(MethodDefinitionHandle methodHandle);
    public abstract virtual bool TryGetDocumentChecksum(string documentPath, ImmutableArray`1& checksum, Guid& algorithmId);
    public static EditAndContinueMethodDebugInfoReader Create(ISymUnmanagedReader5 symReader, int version);
    public static EditAndContinueMethodDebugInfoReader Create(MetadataReader pdbReader);
    internal static bool TryGetDocumentChecksum(ISymUnmanagedReader5 symReader, string documentPath, ImmutableArray`1& checksum, Guid& algorithmId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueService : object {
    internal static TraceLog Log;
    internal static TraceLog AnalysisLog;
    private Func`2<Project, CompilationOutputs> _compilationOutputsProvider;
    private List`1<DebuggingSession> _debuggingSessions;
    private static int s_debuggingSessionId;
    private static EditAndContinueService();
    [NullableContextAttribute("2")]
private static string GetLogDirectory();
    [NullableContextAttribute("2")]
public sealed virtual void SetFileLoggingDirectory(string logDirectory);
    private static CompilationOutputs GetCompilationOutputs(Project project);
    [NullableContextAttribute("2")]
private DebuggingSession TryGetDebuggingSession(DebuggingSessionId sessionId);
    private ImmutableArray`1<DebuggingSession> GetActiveDebuggingSessions();
    private ImmutableArray`1<DebuggingSession> GetDiagnosticReportingDebuggingSessions();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditAndContinueService/<StartDebuggingSessionAsync>d__15")]
public sealed virtual ValueTask`1<DebuggingSessionId> StartDebuggingSessionAsync(Solution solution, IManagedHotReloadService debuggerService, IPdbMatchingSourceTextProvider sourceTextProvider, ImmutableArray`1<DocumentId> captureMatchingDocuments, bool captureAllMatchingDocuments, bool reportDiagnostics, CancellationToken cancellationToken);
    private static IEnumerable`1<ValueTuple`2<Project, IEnumerable`1<DocumentState>>> GetDocumentStatesGroupedByProject(Solution solution, ImmutableArray`1<DocumentId> documentIds);
    public sealed virtual void EndDebuggingSession(DebuggingSessionId sessionId);
    public sealed virtual void BreakStateOrCapabilitiesChanged(DebuggingSessionId sessionId, Nullable`1<bool> inBreakState);
    public sealed virtual ValueTask`1<ImmutableArray`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<EmitSolutionUpdateResults> EmitSolutionUpdateAsync(DebuggingSessionId sessionId, Solution solution, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public sealed virtual void CommitSolutionUpdate(DebuggingSessionId sessionId);
    public sealed virtual void DiscardSolutionUpdate(DebuggingSessionId sessionId);
    [NullableContextAttribute("0")]
public sealed virtual ValueTask`1<ImmutableArray`1<ImmutableArray`1<ActiveStatementSpan>>> GetBaseActiveStatementSpansAsync(DebuggingSessionId sessionId, Solution solution, ImmutableArray`1<DocumentId> documentIds, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> GetAdjustedActiveStatementSpansAsync(DebuggingSessionId sessionId, TextDocument mappedDocument, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.EditSession : object {
    internal DebuggingSession DebuggingSession;
    internal EditSessionTelemetry Telemetry;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImmutableDictionary`2<ManagedMethodId, ImmutableArray`1<NonRemappableRegion>> NonRemappableRegions;
    internal AsyncLazy`1<EditAndContinueCapabilities> Capabilities;
    internal AsyncLazy`1<ActiveStatementsMap> BaseActiveStatements;
    internal EditAndContinueDocumentAnalysesCache Analyses;
    internal bool InBreakState;
    internal EditSession(DebuggingSession debuggingSession, ImmutableDictionary`2<ManagedMethodId, ImmutableArray`1<NonRemappableRegion>> nonRemappableRegions, EditSessionTelemetry telemetry, AsyncLazy`1<ActiveStatementsMap> lazyActiveStatementMap, bool inBreakState);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetUnsupportedChangesDiagnosticAsync>d__8")]
private Task`1<Diagnostic> GetUnsupportedChangesDiagnosticAsync(EmitDifferenceResult emitResult, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetModuleDiagnosticsAsync>d__9")]
public Task`1<Nullable`1<ImmutableArray`1<Diagnostic>>> GetModuleDiagnosticsAsync(Guid mvid, Project oldProject, Project newProject, ImmutableArray`1<DocumentAnalysisResults> documentAnalyses, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<CreateChangedLocationsAsync>d__10")]
private static IAsyncEnumerable`1<Location> CreateChangedLocationsAsync(Project oldProject, Project newProject, ImmutableArray`1<DocumentAnalysisResults> documentAnalyses, CancellationToken cancellationToken);
    private static TextSpan GetFirstLineDifferenceSpan(SourceText oldText, SourceText newText);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetCapabilitiesAsync>d__12")]
private Task`1<EditAndContinueCapabilities> GetCapabilitiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetBaseActiveStatementsAsync>d__13")]
private Task`1<ActiveStatementsMap> GetBaseActiveStatementsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<HasChangesAsync>d__14")]
public static ValueTask`1<bool> HasChangesAsync(Solution oldSolution, Solution newSolution, string sourceFilePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<HasChangesAsync>d__15")]
public static ValueTask`1<bool> HasChangesAsync(Solution oldSolution, Solution newSolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<ContentEqualsAsync>d__16")]
private static ValueTask`1<bool> ContentEqualsAsync(TextDocument oldDocument, TextDocument newDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<HasChangedOrAddedDocumentsAsync>d__17")]
internal static ValueTask`1<bool> HasChangedOrAddedDocumentsAsync(Project oldProject, Project newProject, ArrayBuilder`1<Document> changedOrAddedDocuments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<PopulateChangedAndAddedDocumentsAsync>d__18")]
internal static Task PopulateChangedAndAddedDocumentsAsync(Project oldProject, Project newProject, ArrayBuilder`1<Document> changedOrAddedDocuments, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetChangedDocumentsAsync>d__19")]
internal static IAsyncEnumerable`1<DocumentId> GetChangedDocumentsAsync(Project oldProject, Project newProject, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<AnalyzeDocumentsAsync>d__20")]
private Task`1<ValueTuple`2<ImmutableArray`1<DocumentAnalysisResults>, ImmutableArray`1<Diagnostic>>> AnalyzeDocumentsAsync(ArrayBuilder`1<Document> changedOrAddedDocuments, ActiveStatementSpanProvider newDocumentActiveStatementSpanProvider, CancellationToken cancellationToken);
    private static ProjectAnalysisSummary GetProjectAnalysisSummary(ImmutableArray`1<DocumentAnalysisResults> documentAnalyses);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<GetProjectChangesAsync>d__22")]
internal static ValueTask`1<ProjectChanges> GetProjectChangesAsync(ActiveStatementsMap baseActiveStatements, Compilation oldCompilation, Compilation newCompilation, Project oldProject, Project newProject, ImmutableArray`1<DocumentAnalysisResults> changedDocumentAnalyses, CancellationToken cancellationToken);
    internal static void MergePartialEdits(Compilation oldCompilation, Compilation newCompilation, IReadOnlyList`1<SemanticEditInfo> edits, ImmutableArray`1& mergedEdits, ImmutableHashSet`1& addedSymbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<EmitSolutionUpdateAsync>d__24")]
public ValueTask`1<SolutionUpdate> EmitSolutionUpdateAsync(Solution solution, ActiveStatementSpanProvider solutionActiveStatementSpanProvider, UpdateId updateId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EditSession/<LogDeltaFilesAsync>d__25")]
private ValueTask LogDeltaFilesAsync(FileLogger log, ManagedHotReloadUpdate delta, int baselineGeneration, Project oldProject, Project newProject, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
internal static void GetActiveStatementAndExceptionRegionSpans(Guid moduleId, ActiveStatementsMap oldActiveStatementMap, ImmutableArray`1<int> updatedMethodTokens, ImmutableDictionary`2<ManagedMethodId, ImmutableArray`1<NonRemappableRegion>> previousNonRemappableRegions, ImmutableArray`1<DocumentActiveStatementChanges> activeStatementsInChangedDocuments, ImmutableArray`1& activeStatementsInUpdatedMethods, ImmutableArray`1& nonRemappableRegions, ImmutableArray`1& exceptionRegionUpdates);
    [CompilerGeneratedAttribute]
internal static void <GetActiveStatementAndExceptionRegionSpans>g__AddNonRemappableRegion|26_2(SourceFileSpan oldSpan, SourceFileSpan newSpan, bool isExceptionRegion, <>c__DisplayClass26_0& , <>c__DisplayClass26_1& );
}
internal class Microsoft.CodeAnalysis.EditAndContinue.EditSessionTelemetry : object {
    [NullableAttribute("1")]
private object _guard;
    private static int MaxReportedProjectIds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<ValueTuple`3<ushort, ushort, Guid>> _rudeEdits;
    [NullableAttribute("1")]
private HashSet`1<string> _emitErrorIds;
    [NullableAttribute("1")]
private HashSet`1<Guid> _projectsWithValidDelta;
    private bool _hadCompilationErrors;
    private bool _hadRudeEdits;
    private bool _hadValidChanges;
    private bool _hadValidInsignificantChanges;
    private Nullable`1<bool> _inBreakState;
    private bool _committed;
    private TimeSpan _emitDifferenceTime;
    private TimeSpan _analysisTime;
    private EditAndContinueCapabilities _capabilities;
    public bool IsEmpty { get; }
    public Data GetDataAndClear();
    public bool get_IsEmpty();
    public void SetBreakState(bool value);
    public void LogEmitDifferenceTime(TimeSpan span);
    public void LogAnalysisTime(TimeSpan span);
    public void LogProjectAnalysisSummary(ProjectAnalysisSummary summary, Guid projectTelemetryId, ImmutableArray`1<string> errorsIds);
    public void LogProjectAnalysisSummary(ProjectAnalysisSummary summary, Guid projectTelemetryId, ImmutableArray`1<Diagnostic> emitDiagnostics);
    public void LogRudeEditDiagnostics(ImmutableArray`1<RudeEditDiagnostic> diagnostics, Guid projectTelemetryId);
    public void LogRuntimeCapabilities(EditAndContinueCapabilities capabilities);
    public void LogCommitted();
}
[IsReadOnlyAttribute]
[RequiredMemberAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults : ValueType {
    public static EmitSolutionUpdateResults Empty;
    [CompilerGeneratedAttribute]
private ModuleUpdates <ModuleUpdates>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ProjectDiagnostics> <Diagnostics>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>> <RudeEdits>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Diagnostic <SyntaxError>k__BackingField;
    [RequiredMemberAttribute]
public ModuleUpdates ModuleUpdates { get; public set; }
    [RequiredMemberAttribute]
public ImmutableArray`1<ProjectDiagnostics> Diagnostics { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[RequiredMemberAttribute]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>> RudeEdits { get; public set; }
    [NullableAttribute("2")]
[RequiredMemberAttribute]
public Diagnostic SyntaxError { get; public set; }
    private static EmitSolutionUpdateResults();
    [CompilerGeneratedAttribute]
public ModuleUpdates get_ModuleUpdates();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ModuleUpdates(ModuleUpdates value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ProjectDiagnostics> get_Diagnostics();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Diagnostics(ImmutableArray`1<ProjectDiagnostics> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>> get_RudeEdits();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RudeEdits(ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Diagnostic get_SyntaxError();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SyntaxError(Diagnostic value);
    [NullableContextAttribute("1")]
public Data Dehydrate(Solution solution);
    [NullableContextAttribute("1")]
public DiagnosticData GetSyntaxErrorData(Solution solution);
    [NullableContextAttribute("1")]
private IEnumerable`1<Project> GetProjectsContainingBlockingRudeEdits(Solution solution);
    [NullableContextAttribute("1")]
public void GetProjectsToRebuildAndRestart(Solution solution, Func`2<Project, bool> isRunningProject, ISet`1<Project> projectsToRestart, ISet`1<Project> projectsToRebuild);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults/<GetAllDiagnosticsAsync>d__22")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAllDiagnosticsAsync(Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.EmitSolutionUpdateResults/<GetAllDiagnosticsAsync>d__23")]
internal static ValueTask`1<ImmutableArray`1<ManagedHotReloadDiagnostic>> GetAllDiagnosticsAsync(Solution solution, ImmutableArray`1<DiagnosticData> diagnosticData, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>> rudeEdits, DiagnosticData syntaxError, ModuleUpdateStatus updateStatus, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <GetProjectsToRebuildAndRestart>g__AddImpactedRunningProjects|21_0(ICollection`1<Project> impactedProjects, Project initialProject, <>c__DisplayClass21_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EditAndContinue.Extensions : object {
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<DiagnosticData> ToDiagnosticData(ImmutableArray`1<ProjectDiagnostics> diagnostics, Solution solution);
    [ExtensionAttribute]
internal static LinePositionSpan AddLineDelta(LinePositionSpan span, int lineDelta);
    [ExtensionAttribute]
internal static SourceFileSpan AddLineDelta(SourceFileSpan span, int lineDelta);
    [ExtensionAttribute]
internal static int GetLineDelta(LinePositionSpan oldSpan, LinePositionSpan newSpan);
    [ExtensionAttribute]
internal static bool Contains(LinePositionSpan container, LinePositionSpan span);
    [ExtensionAttribute]
public static LinePositionSpan ToLinePositionSpan(SourceSpan span);
    [ExtensionAttribute]
public static SourceSpan ToSourceSpan(LinePositionSpan span);
    [ExtensionAttribute]
public static bool SupportsEditAndContinue(Project project);
    [ExtensionAttribute]
public static bool SupportsEditAndContinue(TextDocumentState textDocumentState);
    private static bool IsWpfDesignTimeOnlyDocument(string filePath, string language);
    private static bool IsRazorDesignTimeOnlyDocument(string filePath);
    [ExtensionAttribute]
public static ManagedHotReloadDiagnostic ToHotReloadDiagnostic(DiagnosticData data, ModuleUpdateStatus updateStatus);
    [ExtensionAttribute]
public static bool IsSynthesized(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsSynthesizedAutoProperty(IPropertySymbol property);
    [ExtensionAttribute]
public static bool IsSynthesizedAutoProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsSynthesizedParameter(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsSynthesizedParameter(IParameterSymbol parameter);
    [ExtensionAttribute]
public static bool IsAutoProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAutoProperty(IPropertySymbol property);
    [ExtensionAttribute]
public static bool HasSynthesizedDefaultConstructor(INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool IsCopyConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool HasDeconstructorSignature(IMethodSymbol method, IMethodSymbol constructor);
    [ExtensionAttribute]
public static IFieldSymbol GetPrimaryParameterBackingField(IParameterSymbol parameter);
    private static bool ParsePrimaryParameterBackingFieldName(string fieldName, String& parameterName);
    [ExtensionAttribute]
public static IMethodSymbol GetMatchingDeconstructor(IMethodSymbol constructor);
    [ExtensionAttribute]
public static ISymbol PartialAsImplementation(ISymbol symbol);
    [ExtensionAttribute]
public static bool HasExplicitlyImplementedInterfaceMember(INamedTypeSymbol type);
}
internal interface Microsoft.CodeAnalysis.EditAndContinue.IActiveStatementSpanFactory {
    public abstract virtual ValueTask`1<ImmutableArray`1<ImmutableArray`1<ActiveStatementSpan>>> GetBaseActiveStatementSpansAsync(Solution solution, ImmutableArray`1<DocumentId> documentIds, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> GetAdjustedActiveStatementSpansAsync(TextDocument document, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.EditAndContinue.IActiveStatementSpanLocator {
    [NullableContextAttribute("1")]
public abstract virtual ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> GetSpansAsync(Solution solution, DocumentId documentId, string filePath, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueAnalyzer {
    public abstract virtual Task`1<DocumentAnalysisResults> AnalyzeDocumentAsync(Project baseProject, AsyncLazy`1<ActiveStatementsMap> lazyBaseActiveStatements, Document document, ImmutableArray`1<ActiveStatementLineSpan> newActiveStatementSpans, AsyncLazy`1<EditAndContinueCapabilities> lazyCapabilities, CancellationToken cancellationToken);
    public abstract virtual ActiveStatementExceptionRegions GetExceptionRegions(SyntaxNode syntaxRoot, TextSpan unmappedActiveStatementSpan, bool isNonLeaf, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueService {
    public abstract virtual ValueTask`1<ImmutableArray`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<EmitSolutionUpdateResults> EmitSolutionUpdateAsync(DebuggingSessionId sessionId, Solution solution, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    public abstract virtual void CommitSolutionUpdate(DebuggingSessionId sessionId);
    public abstract virtual void DiscardSolutionUpdate(DebuggingSessionId sessionId);
    public abstract virtual ValueTask`1<DebuggingSessionId> StartDebuggingSessionAsync(Solution solution, IManagedHotReloadService debuggerService, IPdbMatchingSourceTextProvider sourceTextProvider, ImmutableArray`1<DocumentId> captureMatchingDocuments, bool captureAllMatchingDocuments, bool reportDiagnostics, CancellationToken cancellationToken);
    public abstract virtual void BreakStateOrCapabilitiesChanged(DebuggingSessionId sessionId, Nullable`1<bool> inBreakState);
    public abstract virtual void EndDebuggingSession(DebuggingSessionId sessionId);
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<ImmutableArray`1<ImmutableArray`1<ActiveStatementSpan>>> GetBaseActiveStatementSpansAsync(DebuggingSessionId sessionId, Solution solution, ImmutableArray`1<DocumentId> documentIds, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> GetAdjustedActiveStatementSpansAsync(DebuggingSessionId sessionId, TextDocument document, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual void SetFileLoggingDirectory(string logDirectory);
}
internal interface Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueSessionTracker {
    public bool IsSessionActive { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticData> ApplyChangesDiagnostics { get; }
    public abstract virtual bool get_IsSessionActive();
    public abstract virtual ImmutableArray`1<DiagnosticData> get_ApplyChangesDiagnostics();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditAndContinue.IEditAndContinueWorkspaceService {
    public IEditAndContinueService Service { get; }
    public IEditAndContinueSessionTracker SessionTracker { get; }
    public abstract virtual IEditAndContinueService get_Service();
    public abstract virtual IEditAndContinueSessionTracker get_SessionTracker();
}
internal interface Microsoft.CodeAnalysis.EditAndContinue.IPdbMatchingSourceTextProvider {
    public abstract virtual ValueTask`1<string> TryGetMatchingSourceTextAsync(string filePath, ImmutableArray`1<byte> requiredChecksum, SourceHashAlgorithm checksumAlgorithm, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.EditAndContinue.IRemoteEditAndContinueService {
    [NullableContextAttribute("1")]
public abstract virtual ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDocumentDiagnosticsAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, DocumentId documentId, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Data> EmitSolutionUpdateAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, DebuggingSessionId sessionId, CancellationToken cancellationToken);
    public abstract virtual ValueTask CommitSolutionUpdateAsync(DebuggingSessionId sessionId, CancellationToken cancellationToken);
    public abstract virtual ValueTask DiscardSolutionUpdateAsync(DebuggingSessionId sessionId, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<DebuggingSessionId> StartDebuggingSessionAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, ImmutableArray`1<DocumentId> captureMatchingDocuments, bool captureAllMatchingDocuments, bool reportDiagnostics, CancellationToken cancellationToken);
    public abstract virtual ValueTask BreakStateOrCapabilitiesChangedAsync(DebuggingSessionId sessionId, Nullable`1<bool> isBreakState, CancellationToken cancellationToken);
    public abstract virtual ValueTask EndDebuggingSessionAsync(DebuggingSessionId sessionId, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<ImmutableArray`1<ActiveStatementSpan>>> GetBaseActiveStatementSpansAsync(Checksum solutionChecksum, DebuggingSessionId sessionId, ImmutableArray`1<DocumentId> documentIds, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> GetAdjustedActiveStatementSpansAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, DebuggingSessionId sessionId, DocumentId documentId, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual ValueTask SetFileLoggingDirectoryAsync(string logDirectory, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditAndContinue.ISolutionSnapshotRegistry {
    public abstract virtual SolutionSnapshotId RegisterSolutionSnapshot(Solution solution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.LambdaBody : DeclarationBody {
    public abstract virtual SyntaxNode GetLambda();
    public abstract virtual bool IsSyntaxEquivalentTo(LambdaBody other);
    public abstract virtual LambdaBody TryGetPartnerLambdaBody(SyntaxNode newLambda);
}
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.MemberBody : DeclarationBody {
    public TextSpan Envelope { get; }
    public abstract virtual TextSpan get_Envelope();
    public bool ContainsActiveStatementSpan(TextSpan span);
    public virtual bool IsExcludedActiveStatementSpanWithinEnvelope(TextSpan span);
    [NullableContextAttribute("2")]
public abstract virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode FindStatementAndPartner(TextSpan span, MemberBody partnerDeclarationBody, SyntaxNode& partnerStatement, Int32& statementPart);
    [NullableContextAttribute("1")]
public SyntaxNode FindStatement(TextSpan span, Int32& statementPart);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.MemberBody/<GetOverlappingActiveStatementIndices>d__7")]
public IEnumerable`1<int> GetOverlappingActiveStatementIndices(ImmutableArray`1<UnmappedActiveStatement> statements);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ModuleUpdates : ValueType {
    [CompilerGeneratedAttribute]
private ModuleUpdateStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ManagedHotReloadUpdate> <Updates>k__BackingField;
    [DataMemberAttribute]
public ModuleUpdateStatus Status { get; public set; }
    [DataMemberAttribute]
public ImmutableArray`1<ManagedHotReloadUpdate> Updates { get; public set; }
    public ModuleUpdates(ModuleUpdateStatus Status, ImmutableArray`1<ManagedHotReloadUpdate> Updates);
    [CompilerGeneratedAttribute]
public ModuleUpdateStatus get_Status();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Status(ModuleUpdateStatus value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ManagedHotReloadUpdate> get_Updates();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Updates(ImmutableArray`1<ManagedHotReloadUpdate> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ModuleUpdates left, ModuleUpdates right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ModuleUpdates left, ModuleUpdates right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleUpdates other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ModuleUpdateStatus& Status, ImmutableArray`1& Updates);
}
internal enum Microsoft.CodeAnalysis.EditAndContinue.ModuleUpdateStatus : Enum {
    public int value__;
    public static ModuleUpdateStatus None;
    public static ModuleUpdateStatus Ready;
    public static ModuleUpdateStatus RestartRequired;
    public static ModuleUpdateStatus Blocked;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.EditAndContinue.NonRemappableRegion : ValueType {
    public SourceFileSpan OldSpan;
    public SourceFileSpan NewSpan;
    public bool IsExceptionRegion;
    public NonRemappableRegion(SourceFileSpan oldSpan, SourceFileSpan newSpan, bool isExceptionRegion);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NonRemappableRegion other);
    public virtual int GetHashCode();
    public static bool op_Equality(NonRemappableRegion left, NonRemappableRegion right);
    public static bool op_Inequality(NonRemappableRegion left, NonRemappableRegion right);
    public NonRemappableRegion WithNewSpan(SourceFileSpan newSpan);
    [NullableContextAttribute("1")]
internal string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.EditAndContinue.NullPdbMatchingSourceTextProvider : object {
    [NullableAttribute("1")]
public static NullPdbMatchingSourceTextProvider Instance;
    private static NullPdbMatchingSourceTextProvider();
    public sealed virtual ValueTask`1<string> TryGetMatchingSourceTextAsync(string filePath, ImmutableArray`1<byte> requiredChecksum, SourceHashAlgorithm checksumAlgorithm, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.EditAndContinue.PendingSolutionUpdate : PendingUpdate {
    [NullableAttribute("1")]
public Solution Solution;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<Guid, ImmutableArray`1<ValueTuple`2<ManagedModuleMethodId, NonRemappableRegion>>>> NonRemappableRegions;
    public PendingSolutionUpdate(Solution solution, ImmutableArray`1<ProjectBaseline> projectBaselines, ImmutableArray`1<ManagedHotReloadUpdate> deltas, ImmutableArray`1<ValueTuple`2<Guid, ImmutableArray`1<ValueTuple`2<ManagedModuleMethodId, NonRemappableRegion>>>> nonRemappableRegions);
}
internal abstract class Microsoft.CodeAnalysis.EditAndContinue.PendingUpdate : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ProjectBaseline> ProjectBaselines;
    public ImmutableArray`1<ManagedHotReloadUpdate> Deltas;
    protected PendingUpdate(ImmutableArray`1<ProjectBaseline> projectBaselines, ImmutableArray`1<ManagedHotReloadUpdate> deltas);
}
internal enum Microsoft.CodeAnalysis.EditAndContinue.ProjectAnalysisSummary : Enum {
    public int value__;
    public static ProjectAnalysisSummary NoChanges;
    public static ProjectAnalysisSummary SyntaxErrors;
    public static ProjectAnalysisSummary RudeEdits;
    public static ProjectAnalysisSummary ValidInsignificantChanges;
    public static ProjectAnalysisSummary ValidChanges;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.ProjectBaseline : object {
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private EmitBaseline <EmitBaseline>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Generation>k__BackingField;
    public ProjectId ProjectId { get; }
    public EmitBaseline EmitBaseline { get; }
    public int Generation { get; }
    public ProjectBaseline(ProjectId projectId, EmitBaseline emitBaseline, int generation);
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [CompilerGeneratedAttribute]
public EmitBaseline get_EmitBaseline();
    [CompilerGeneratedAttribute]
public int get_Generation();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ProjectChanges : ValueType {
    public ImmutableArray`1<SemanticEdit> SemanticEdits;
    public ImmutableArray`1<SequencePointUpdates> LineChanges;
    [NullableAttribute("1")]
public ImmutableHashSet`1<ISymbol> AddedSymbols;
    public ImmutableArray`1<DocumentActiveStatementChanges> ActiveStatementChanges;
    public EditAndContinueCapabilities RequiredCapabilities;
    public ProjectChanges(ImmutableArray`1<SemanticEdit> semanticEdits, ImmutableArray`1<SequencePointUpdates> lineChanges, ImmutableHashSet`1<ISymbol> addedSymbols, ImmutableArray`1<DocumentActiveStatementChanges> activeStatementChanges, EditAndContinueCapabilities requiredCapabilities);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.ProjectDiagnostics : ValueType {
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <Diagnostics>k__BackingField;
    public ProjectId ProjectId { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Diagnostic> Diagnostics { get; public set; }
    public ProjectDiagnostics(ProjectId ProjectId, ImmutableArray`1<Diagnostic> Diagnostics);
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProjectId(ProjectId value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Diagnostic> get_Diagnostics();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Diagnostics(ImmutableArray`1<Diagnostic> value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ProjectDiagnostics left, ProjectDiagnostics right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ProjectDiagnostics left, ProjectDiagnostics right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ProjectDiagnostics other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ProjectId& ProjectId, ImmutableArray`1& Diagnostics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.RemoteDebuggingSessionProxy : object {
    [CompilerGeneratedAttribute]
private SolutionServices <services>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDisposable <connection>P;
    [CompilerGeneratedAttribute]
private DebuggingSessionId <sessionId>P;
    public RemoteDebuggingSessionProxy(SolutionServices services, IDisposable connection, DebuggingSessionId sessionId);
    public sealed virtual void Dispose();
    private IEditAndContinueService GetLocalService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteDebuggingSessionProxy/<BreakStateOrCapabilitiesChangedAsync>d__6")]
public ValueTask BreakStateOrCapabilitiesChangedAsync(Nullable`1<bool> inBreakState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteDebuggingSessionProxy/<EndDebuggingSessionAsync>d__7")]
public ValueTask EndDebuggingSessionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteDebuggingSessionProxy/<EmitSolutionUpdateAsync>d__8")]
public ValueTask`1<ValueTuple`4<ModuleUpdates, ImmutableArray`1<DiagnosticData>, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>>, DiagnosticData>> EmitSolutionUpdateAsync(Solution solution, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    private static ImmutableArray`1<DiagnosticData> GetInternalErrorDiagnosticData(Solution solution, Exception e);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteDebuggingSessionProxy/<CommitSolutionUpdateAsync>d__10")]
public ValueTask CommitSolutionUpdateAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteDebuggingSessionProxy/<DiscardSolutionUpdateAsync>d__11")]
public ValueTask DiscardSolutionUpdateAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteDebuggingSessionProxy/<GetBaseActiveStatementSpansAsync>d__12")]
public sealed virtual ValueTask`1<ImmutableArray`1<ImmutableArray`1<ActiveStatementSpan>>> GetBaseActiveStatementSpansAsync(Solution solution, ImmutableArray`1<DocumentId> documentIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteDebuggingSessionProxy/<GetAdjustedActiveStatementSpansAsync>d__13")]
public sealed virtual ValueTask`1<ImmutableArray`1<ActiveStatementSpan>> GetAdjustedActiveStatementSpansAsync(TextDocument document, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTask`1<Data> <EmitSolutionUpdateAsync>b__8_0(IRemoteEditAndContinueService service, Checksum solutionInfo, RemoteServiceCallbackId callbackId, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private ValueTask <DiscardSolutionUpdateAsync>b__11_0(IRemoteEditAndContinueService service, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueServiceProxy : ValueType {
    [CompilerGeneratedAttribute]
private SolutionServices <services>P;
    public RemoteEditAndContinueServiceProxy(SolutionServices services);
    private IEditAndContinueService GetLocalService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueServiceProxy/<StartDebuggingSessionAsync>d__5")]
public ValueTask`1<RemoteDebuggingSessionProxy> StartDebuggingSessionAsync(Solution solution, IManagedHotReloadService debuggerService, IPdbMatchingSourceTextProvider sourceTextProvider, ImmutableArray`1<DocumentId> captureMatchingDocuments, bool captureAllMatchingDocuments, bool reportDiagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueServiceProxy/<GetDocumentDiagnosticsAsync>d__6")]
public ValueTask`1<ImmutableArray`1<DiagnosticData>> GetDocumentDiagnosticsAsync(Document document, ActiveStatementSpanProvider activeStatementSpanProvider, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EditAndContinue.RemoteEditAndContinueServiceProxy/<SetFileLoggingDirectoryAsync>d__7")]
public ValueTask SetFileLoggingDirectoryAsync(string logDirectory, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.RudeEditDiagnostic : ValueType {
    [DataMemberAttribute]
public RudeEditKind Kind;
    [DataMemberAttribute]
public TextSpan Span;
    [DataMemberAttribute]
public ushort SyntaxKind;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public String[] Arguments;
    internal RudeEditDiagnostic(RudeEditKind kind, TextSpan span, ushort syntaxKind, String[] arguments);
    [NullableContextAttribute("2")]
internal RudeEditDiagnostic(RudeEditKind kind, TextSpan span, SyntaxNode node, String[] arguments);
    [NullableContextAttribute("1")]
internal Diagnostic ToDiagnostic(SyntaxTree tree);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EditAndContinue.RudeEditExtensions : object {
    [ExtensionAttribute]
internal static DiagnosticSeverity GetSeverity(RudeEditKind kind);
    [ExtensionAttribute]
internal static bool IsBlocking(RudeEditKind kind);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasBlockingRudeEdits(IEnumerable`1<RudeEditDiagnostic> diagnostics);
}
internal enum Microsoft.CodeAnalysis.EditAndContinue.RudeEditKind : Enum {
    public ushort value__;
    public static RudeEditKind None;
    public static RudeEditKind ActiveStatementUpdate;
    public static RudeEditKind ActiveStatementLambdaRemoved;
    public static RudeEditKind Update;
    public static RudeEditKind ModifiersUpdate;
    public static RudeEditKind HandlesClauseUpdate;
    public static RudeEditKind ImplementsClauseUpdate;
    public static RudeEditKind VarianceUpdate;
    public static RudeEditKind FieldKindUpdate;
    public static RudeEditKind TypeUpdate;
    public static RudeEditKind InitializerUpdate;
    public static RudeEditKind FixedSizeFieldUpdate;
    public static RudeEditKind EnumUnderlyingTypeUpdate;
    public static RudeEditKind BaseTypeOrInterfaceUpdate;
    public static RudeEditKind TypeKindUpdate;
    public static RudeEditKind AccessorKindUpdate;
    public static RudeEditKind DeclareLibraryUpdate;
    public static RudeEditKind DeclareAliasUpdate;
    public static RudeEditKind Renamed;
    public static RudeEditKind Insert;
    public static RudeEditKind InsertVirtual;
    public static RudeEditKind InsertOverridable;
    public static RudeEditKind InsertExtern;
    public static RudeEditKind InsertOperator;
    public static RudeEditKind InsertDllImport;
    public static RudeEditKind InsertIntoStruct;
    public static RudeEditKind InsertIntoClassWithLayout;
    public static RudeEditKind Move;
    public static RudeEditKind Delete;
    public static RudeEditKind GenericMethodUpdate;
    public static RudeEditKind GenericTypeUpdate;
    public static RudeEditKind StackAllocUpdate;
    public static RudeEditKind ExperimentalFeaturesEnabled;
    public static RudeEditKind AwaitStatementUpdate;
    public static RudeEditKind ChangingAccessibility;
    public static RudeEditKind ChangingCapturedVariableType;
    public static RudeEditKind ChangingCapturedVariableScope;
    public static RudeEditKind ChangingLambdaParameters;
    public static RudeEditKind ChangingLambdaReturnType;
    public static RudeEditKind ChangingQueryLambdaType;
    public static RudeEditKind InsertAroundActiveStatement;
    public static RudeEditKind DeleteAroundActiveStatement;
    public static RudeEditKind DeleteActiveStatement;
    public static RudeEditKind UpdateAroundActiveStatement;
    public static RudeEditKind UpdateExceptionHandlerOfActiveTry;
    public static RudeEditKind UpdateTryOrCatchWithActiveFinally;
    public static RudeEditKind UpdateCatchHandlerAroundActiveStatement;
    public static RudeEditKind UpdateStaticLocal;
    public static RudeEditKind InsertConstructorToTypeWithInitializersWithLambdas;
    public static RudeEditKind RenamingCapturedVariable;
    public static RudeEditKind InsertHandlesClause;
    public static RudeEditKind InsertFile;
    public static RudeEditKind PartiallyExecutedActiveStatementUpdate;
    public static RudeEditKind PartiallyExecutedActiveStatementDelete;
    public static RudeEditKind UpdatingStateMachineMethodAroundActiveStatement;
    public static RudeEditKind UpdatingStateMachineMethodMissingAttribute;
    public static RudeEditKind SwitchBetweenLambdaAndLocalFunction;
    public static RudeEditKind InternalError;
    public static RudeEditKind InsertMethodWithExplicitInterfaceSpecifier;
    public static RudeEditKind InsertIntoInterface;
    public static RudeEditKind InsertLocalFunctionIntoInterfaceMethod;
    public static RudeEditKind ChangingFromAsynchronousToSynchronous;
    public static RudeEditKind ChangingStateMachineShape;
    public static RudeEditKind ComplexQueryExpression;
    public static RudeEditKind MemberBodyInternalError;
    public static RudeEditKind SourceFileTooBig;
    public static RudeEditKind MemberBodyTooBig;
    public static RudeEditKind NotSupportedByRuntime;
    public static RudeEditKind MakeMethodAsyncNotSupportedByRuntime;
    public static RudeEditKind MakeMethodIteratorNotSupportedByRuntime;
    public static RudeEditKind InsertNotSupportedByRuntime;
    public static RudeEditKind ChangingAttributesNotSupportedByRuntime;
    public static RudeEditKind ChangeImplicitMainReturnType;
    public static RudeEditKind ChangingParameterTypes;
    public static RudeEditKind ChangingTypeParameters;
    public static RudeEditKind ChangingConstraints;
    public static RudeEditKind ChangingReloadableTypeNotSupportedByRuntime;
    public static RudeEditKind RenamingNotSupportedByRuntime;
    public static RudeEditKind ChangingNonCustomAttribute;
    public static RudeEditKind ChangingNamespace;
    public static RudeEditKind ChangingSignatureNotSupportedByRuntime;
    public static RudeEditKind DeleteNotSupportedByRuntime;
    public static RudeEditKind UpdatingStateMachineMethodNotSupportedByRuntime;
    public static RudeEditKind UpdatingGenericNotSupportedByRuntime;
    public static RudeEditKind CapturingPrimaryConstructorParameter;
    public static RudeEditKind NotCapturingPrimaryConstructorParameter;
    public static RudeEditKind ChangingAttribute;
    public static RudeEditKind ChangingNameOrSignatureOfActiveMember;
    public static RudeEditKind UpdateMightNotHaveAnyEffect;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.SemanticEditInfo : ValueType {
    [CompilerGeneratedAttribute]
private SemanticEditKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolKey <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SymbolKey> <DeletedSymbolContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxMaps <SyntaxMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SymbolKey> <PartialType>k__BackingField;
    public SemanticEditKind Kind { get; }
    public SymbolKey Symbol { get; }
    public Nullable`1<SymbolKey> DeletedSymbolContainer { get; }
    public SyntaxMaps SyntaxMaps { get; }
    public Nullable`1<SymbolKey> PartialType { get; }
    public SemanticEditInfo(SemanticEditKind kind, SymbolKey symbol, SyntaxMaps syntaxMaps, Nullable`1<SymbolKey> partialType, Nullable`1<SymbolKey> deletedSymbolContainer);
    public static SemanticEditInfo CreateInsert(SymbolKey symbol, Nullable`1<SymbolKey> partialType);
    public static SemanticEditInfo CreateUpdate(SymbolKey symbol, SyntaxMaps syntaxMaps, Nullable`1<SymbolKey> partialType);
    public static SemanticEditInfo CreateReplace(SymbolKey symbol, Nullable`1<SymbolKey> partialType);
    public static SemanticEditInfo CreateDelete(SymbolKey symbol, SymbolKey deletedSymbolContainer, Nullable`1<SymbolKey> partialType);
    [CompilerGeneratedAttribute]
public SemanticEditKind get_Kind();
    [CompilerGeneratedAttribute]
public SymbolKey get_Symbol();
    [CompilerGeneratedAttribute]
public Nullable`1<SymbolKey> get_DeletedSymbolContainer();
    [CompilerGeneratedAttribute]
public SyntaxMaps get_SyntaxMaps();
    [CompilerGeneratedAttribute]
public Nullable`1<SymbolKey> get_PartialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.EditAndContinue.SolutionSnapshotRegistry")]
[ExportAttribute("Microsoft.CodeAnalysis.EditAndContinue.ISolutionSnapshotRegistry")]
internal class Microsoft.CodeAnalysis.EditAndContinue.SolutionSnapshotRegistry : object {
    private static int s_solutionSnapshotId;
    private Dictionary`2<SolutionSnapshotId, Solution> _pendingSolutionSnapshots;
    public sealed virtual SolutionSnapshotId RegisterSolutionSnapshot(Solution solution);
    public Solution GetRegisteredSolutionSnapshot(SolutionSnapshotId id);
    public void Clear();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.SolutionUpdate : ValueType {
    public ModuleUpdates ModuleUpdates;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<Guid, ImmutableArray`1<ValueTuple`2<ManagedModuleMethodId, NonRemappableRegion>>>> NonRemappableRegions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ProjectBaseline> ProjectBaselines;
    public ImmutableArray`1<ProjectDiagnostics> Diagnostics;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>> DocumentsWithRudeEdits;
    [NullableAttribute("2")]
public Diagnostic SyntaxError;
    public SolutionUpdate(ModuleUpdates moduleUpdates, ImmutableArray`1<ValueTuple`2<Guid, ImmutableArray`1<ValueTuple`2<ManagedModuleMethodId, NonRemappableRegion>>>> nonRemappableRegions, ImmutableArray`1<ProjectBaseline> projectBaselines, ImmutableArray`1<ProjectDiagnostics> diagnostics, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>> documentsWithRudeEdits, Diagnostic syntaxError);
    public static SolutionUpdate Blocked(ImmutableArray`1<ProjectDiagnostics> diagnostics, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<RudeEditDiagnostic>>> documentsWithRudeEdits, Diagnostic syntaxError, bool hasEmitErrors);
    [NullableContextAttribute("1")]
internal void Log(TraceLog log, UpdateId updateId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.SourceFileSpan : ValueType {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePositionSpan <Span>k__BackingField;
    [DataMemberAttribute]
public string Path { get; }
    [DataMemberAttribute]
public LinePositionSpan Span { get; }
    public bool IsValid { get; }
    public LinePosition Start { get; }
    public LinePosition End { get; }
    public SourceFileSpan(string path, LinePositionSpan span);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public LinePositionSpan get_Span();
    public SourceFileSpan WithSpan(LinePositionSpan span);
    public SourceFileSpan WithPath(string path);
    public bool get_IsValid();
    public LinePosition get_Start();
    public LinePosition get_End();
    public sealed virtual bool Equals(SourceFileSpan other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static SourceFileSpan op_Implicit(FileLinePositionSpan span);
    public static bool op_Equality(SourceFileSpan left, SourceFileSpan right);
    public static bool op_Inequality(SourceFileSpan left, SourceFileSpan right);
    public bool Contains(SourceFileSpan span);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.StateMachineInfo : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIterator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSuspensionPoints>k__BackingField;
    public static StateMachineInfo None;
    public bool IsAsync { get; public set; }
    public bool IsIterator { get; public set; }
    public bool HasSuspensionPoints { get; public set; }
    public bool IsStateMachine { get; }
    public StateMachineInfo(bool IsAsync, bool IsIterator, bool HasSuspensionPoints);
    private static StateMachineInfo();
    [CompilerGeneratedAttribute]
public bool get_IsAsync();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsAsync(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsIterator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsIterator(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasSuspensionPoints();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasSuspensionPoints(bool value);
    public bool get_IsStateMachine();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StateMachineInfo left, StateMachineInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StateMachineInfo left, StateMachineInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StateMachineInfo other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsAsync, Boolean& IsIterator, Boolean& HasSuspensionPoints);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.SyntaxMaps : ValueType {
    [NullableAttribute("1")]
public SyntaxTree NewTree;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<SyntaxNode, SyntaxNode> MatchingNodes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<SyntaxNode, Nullable`1<RuntimeRudeEdit>> RuntimeRudeEdits;
    [MemberNotNullWhenAttribute("True", "MatchingNodes")]
public bool HasMap { get; }
    [NullableContextAttribute("1")]
public SyntaxMaps(SyntaxTree newTree, Func`2<SyntaxNode, SyntaxNode> matchingNodes, Func`2<SyntaxNode, Nullable`1<RuntimeRudeEdit>> runtimeRudeEdits);
    [MemberNotNullWhenAttribute("True", "MatchingNodes")]
public bool get_HasMap();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SyntaxMaps left, SyntaxMaps right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SyntaxMaps left, SyntaxMaps right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SyntaxMaps other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditAndContinue.TraceLog : object {
    private Entry[] _log;
    private string _id;
    private string _fileName;
    private int _currentLine;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FileLogger <FileLog>k__BackingField;
    [NullableAttribute("2")]
public FileLogger FileLog { get; private set; }
    public TraceLog(int logSize, string id, string fileName);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FileLogger get_FileLog();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_FileLog(FileLogger value);
    [NullableContextAttribute("2")]
public void SetLogDirectory(string logDirectory);
    private void AppendInMemory(Entry entry);
    private void AppendFileLoggingErrorInMemory(string path, Exception e);
    private void Append(Entry entry);
    public void Write(string str);
    public void Write(string format, Arg[] args);
    [ConditionalAttribute("DEBUG")]
public void DebugWrite(string str);
    [ConditionalAttribute("DEBUG")]
public void DebugWrite(string format, Arg[] args);
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.UnmappedActiveStatement : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <UnmappedSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private ActiveStatement <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private ActiveStatementExceptionRegions <ExceptionRegions>k__BackingField;
    public TextSpan UnmappedSpan { get; }
    public ActiveStatement Statement { get; }
    public ActiveStatementExceptionRegions ExceptionRegions { get; }
    public UnmappedActiveStatement(TextSpan unmappedSpan, ActiveStatement statement, ActiveStatementExceptionRegions exceptionRegions);
    [CompilerGeneratedAttribute]
public TextSpan get_UnmappedSpan();
    [CompilerGeneratedAttribute]
public ActiveStatement get_Statement();
    [CompilerGeneratedAttribute]
public ActiveStatementExceptionRegions get_ExceptionRegions();
    public void Deconstruct(TextSpan& unmappedSpan, ActiveStatement& statement, ActiveStatementExceptionRegions& exceptionRegions);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditAndContinue.UpdateId : ValueType {
    [CompilerGeneratedAttribute]
private DebuggingSessionId <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    public DebuggingSessionId SessionId { get; public set; }
    public int Ordinal { get; public set; }
    public UpdateId(DebuggingSessionId SessionId, int Ordinal);
    [CompilerGeneratedAttribute]
public DebuggingSessionId get_SessionId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SessionId(DebuggingSessionId value);
    [CompilerGeneratedAttribute]
public int get_Ordinal();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Ordinal(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UpdateId left, UpdateId right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UpdateId left, UpdateId right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UpdateId other);
    [CompilerGeneratedAttribute]
public void Deconstruct(DebuggingSessionId& SessionId, Int32& Ordinal);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllGetFixesService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.Implementation.Suggestions.FeaturesFixAllGetFixesService : AbstractFixAllGetFixesService {
    [NullableContextAttribute("1")]
protected virtual Solution GetChangedSolution(Workspace workspace, Solution currentSolution, Solution newSolution, string fixAllPreviewChangesTitle, string fixAllTopLevelHeader, Glyph glyph);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguageFeatureService`1 : object {
    protected HashSet`1<int> SyntaxTokenKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Lazy`2<TService, EmbeddedLanguageMetadata>> _legacyServices;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ImmutableArray`1<Lazy`2<TService, EmbeddedLanguageMetadata>>> _identifierToServices;
    protected EmbeddedLanguageInfo Info;
    private EmbeddedLanguageDetector _detector;
    protected AbstractEmbeddedLanguageFeatureService`1(string languageName, EmbeddedLanguageInfo info, ISyntaxKinds syntaxKinds, IEnumerable`1<Lazy`2<TService, EmbeddedLanguageMetadata>> allServices);
    private static EmbeddedLanguageCommentDetector GetCommentDetector(ImmutableArray`1<string> languageIdentifiers);
    protected ImmutableArray`1<Lazy`2<TService, EmbeddedLanguageMetadata>> GetServices(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.AbstractEmbeddedLanguagesProvider : object {
    [CompilerGeneratedAttribute]
private EmbeddedLanguageInfo <EmbeddedLanguageInfo>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IEmbeddedLanguage> <Languages>k__BackingField;
    public EmbeddedLanguageInfo EmbeddedLanguageInfo { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IEmbeddedLanguage> Languages { get; }
    protected AbstractEmbeddedLanguagesProvider(EmbeddedLanguageInfo info);
    [CompilerGeneratedAttribute]
public sealed virtual EmbeddedLanguageInfo get_EmbeddedLanguageInfo();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IEmbeddedLanguage> get_Languages();
    [NullableContextAttribute("1")]
public abstract virtual string EscapeText(string text, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageCommentDetector : ValueType {
    private Regex _regex;
    public EmbeddedLanguageCommentDetector(ImmutableArray`1<string> identifiers);
    public bool TryMatch(string text, String& identifier, IEnumerable`1& options);
}
internal static class Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageCommentOptions`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, TOptions> s_nameToOption;
    private static EmbeddedLanguageCommentOptions`1();
    public static bool TryGetOptions(IEnumerable`1<string> captures, TOptions& options);
    private static TOptions CombineOptions(TOptions options, TOptions specificOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageDetector : ValueType {
    private EmbeddedLanguageInfo Info;
    private HashSet`1<string> LanguageIdentifiers;
    private EmbeddedLanguageCommentDetector _commentDetector;
    public EmbeddedLanguageDetector(EmbeddedLanguageInfo info, ImmutableArray`1<string> languageIdentifiers, EmbeddedLanguageCommentDetector commentDetector);
    public bool IsEmbeddedLanguageToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, String& identifier, IEnumerable`1& options);
    public string TryGetEmbeddedLanguageTokenIdentifier(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    public bool IsEmbeddedLanguageIdentifier(string identifier);
    private bool IsEmbeddedLanguageTokenWorker(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, String& identifier, IEnumerable`1& options);
    private bool HasLanguageComment(SyntaxToken token, ISyntaxFacts syntaxFacts, String& identifier, IEnumerable`1& options);
    private bool HasLanguageComment(SyntaxTriviaList list, ISyntaxFacts syntaxFacts, String& identifier, IEnumerable`1& options);
    private bool HasLanguageComment(SyntaxTrivia trivia, ISyntaxFacts syntaxFacts, String& identifier, IEnumerable`1& options);
    private bool IsEmbeddedLanguageInterpolatedStringTextToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, String& identifier);
    private bool IsEmbeddedLanguageStringLiteralToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, String& identifier, IEnumerable`1& options);
    [NullableContextAttribute("2")]
private SyntaxNode TryFindContainer(SyntaxToken token);
    private bool IsAttributeArgumentWithMatchingStringSyntaxAttribute(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken, String& identifier);
    private bool IsArgumentWithMatchingStringSyntaxAttribute(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken, String& identifier);
    private bool IsFieldOrPropertyWithMatchingStringSyntaxAttribute(SemanticModel semanticModel, SyntaxNode left, CancellationToken cancellationToken, String& identifier);
    [NullableContextAttribute("2")]
private bool IsFieldOrPropertyWithMatchingStringSyntaxAttribute(ISymbol symbol, String& identifier);
    [NullableContextAttribute("2")]
private bool HasMatchingStringSyntaxAttribute(ISymbol symbol, String& identifier);
    private bool IsMatchingStringSyntaxAttribute(AttributeData attribute, String& identifier);
    [NullableContextAttribute("2")]
private static string GetNameOfType(SyntaxNode typeNode, ISyntaxFacts syntaxFacts);
    private string GetNameOfInvokedExpression(SyntaxNode invokedExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageInfo : ValueType {
    public ISyntaxFacts SyntaxFacts;
    public ISemanticFactsService SemanticFacts;
    public IVirtualCharService VirtualCharService;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<int> <AllStringLiteralKinds>k__BackingField;
    public ISyntaxKinds SyntaxKinds { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<int> AllStringLiteralKinds { get; }
    public EmbeddedLanguageInfo(ISyntaxFacts syntaxFacts, ISemanticFactsService semanticFacts, IVirtualCharService virtualCharService);
    public ISyntaxKinds get_SyntaxKinds();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public ImmutableArray`1<int> get_AllStringLiteralKinds();
    public bool IsAnyStringLiteral(int rawKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.EmbeddedLanguageMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Identifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsUnannotatedAPIs>k__BackingField;
    public IEnumerable`1<string> Identifiers { get; }
    public IEnumerable`1<string> Languages { get; }
    internal bool SupportsUnannotatedAPIs { get; }
    public EmbeddedLanguageMetadata(IDictionary`2<string, object> data);
    public EmbeddedLanguageMetadata(string name, IEnumerable`1<string> languages, IEnumerable`1<string> after, IEnumerable`1<string> before, IEnumerable`1<string> identifiers, bool supportsUnannotatedAPIs);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Identifiers();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Languages();
    [CompilerGeneratedAttribute]
internal bool get_SupportsUnannotatedAPIs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.ExportEmbeddedLanguageFeatureServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Identifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsUnannotatedAPIs>k__BackingField;
    public string Name { get; }
    public String[] Languages { get; }
    public String[] Identifiers { get; }
    internal bool SupportsUnannotatedAPIs { get; }
    public ExportEmbeddedLanguageFeatureServiceAttribute(Type contractType, string name, String[] languages, String[] identifiers);
    internal ExportEmbeddedLanguageFeatureServiceAttribute(Type contractType, string name, String[] languages, bool supportsUnannotatedAPIs, String[] identifiers);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_Languages();
    [CompilerGeneratedAttribute]
public String[] get_Identifiers();
    [CompilerGeneratedAttribute]
internal bool get_SupportsUnannotatedAPIs();
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguage {
    public EmbeddedLanguageCompletionProvider CompletionProvider { get; }
    public abstract virtual EmbeddedLanguageCompletionProvider get_CompletionProvider();
}
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguageFeatureService {
}
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguagesProvider {
    public EmbeddedLanguageInfo EmbeddedLanguageInfo { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IEmbeddedLanguage> Languages { get; }
    public abstract virtual EmbeddedLanguageInfo get_EmbeddedLanguageInfo();
    public abstract virtual ImmutableArray`1<IEmbeddedLanguage> get_Languages();
}
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.IRegexNodeVisitor {
    public abstract virtual void Visit(RegexCompilationUnit node);
    public abstract virtual void Visit(RegexSequenceNode node);
    public abstract virtual void Visit(RegexTextNode node);
    public abstract virtual void Visit(RegexCharacterClassNode node);
    public abstract virtual void Visit(RegexNegatedCharacterClassNode node);
    public abstract virtual void Visit(RegexCharacterClassRangeNode node);
    public abstract virtual void Visit(RegexCharacterClassSubtractionNode node);
    public abstract virtual void Visit(RegexPosixPropertyNode node);
    public abstract virtual void Visit(RegexWildcardNode node);
    public abstract virtual void Visit(RegexZeroOrMoreQuantifierNode node);
    public abstract virtual void Visit(RegexOneOrMoreQuantifierNode node);
    public abstract virtual void Visit(RegexZeroOrOneQuantifierNode node);
    public abstract virtual void Visit(RegexLazyQuantifierNode node);
    public abstract virtual void Visit(RegexExactNumericQuantifierNode node);
    public abstract virtual void Visit(RegexOpenNumericRangeQuantifierNode node);
    public abstract virtual void Visit(RegexClosedNumericRangeQuantifierNode node);
    public abstract virtual void Visit(RegexAnchorNode node);
    public abstract virtual void Visit(RegexAlternationNode node);
    public abstract virtual void Visit(RegexSimpleGroupingNode node);
    public abstract virtual void Visit(RegexSimpleOptionsGroupingNode node);
    public abstract virtual void Visit(RegexNestedOptionsGroupingNode node);
    public abstract virtual void Visit(RegexNonCapturingGroupingNode node);
    public abstract virtual void Visit(RegexPositiveLookaheadGroupingNode node);
    public abstract virtual void Visit(RegexNegativeLookaheadGroupingNode node);
    public abstract virtual void Visit(RegexPositiveLookbehindGroupingNode node);
    public abstract virtual void Visit(RegexNegativeLookbehindGroupingNode node);
    public abstract virtual void Visit(RegexAtomicGroupingNode node);
    public abstract virtual void Visit(RegexCaptureGroupingNode node);
    public abstract virtual void Visit(RegexBalancingGroupingNode node);
    public abstract virtual void Visit(RegexConditionalCaptureGroupingNode node);
    public abstract virtual void Visit(RegexConditionalExpressionGroupingNode node);
    public abstract virtual void Visit(RegexSimpleEscapeNode node);
    public abstract virtual void Visit(RegexAnchorEscapeNode node);
    public abstract virtual void Visit(RegexCharacterClassEscapeNode node);
    public abstract virtual void Visit(RegexControlEscapeNode node);
    public abstract virtual void Visit(RegexHexEscapeNode node);
    public abstract virtual void Visit(RegexUnicodeEscapeNode node);
    public abstract virtual void Visit(RegexCaptureEscapeNode node);
    public abstract virtual void Visit(RegexKCaptureEscapeNode node);
    public abstract virtual void Visit(RegexOctalEscapeNode node);
    public abstract virtual void Visit(RegexBackreferenceEscapeNode node);
    public abstract virtual void Visit(RegexCategoryEscapeNode node);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAlternationNode : RegexExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSeparatedSyntaxNodeList`3<RegexKind, RegexNode, RegexSequenceNode> <SequenceList>k__BackingField;
    public EmbeddedSeparatedSyntaxNodeList`3<RegexKind, RegexNode, RegexSequenceNode> SequenceList { get; }
    internal int ChildCount { get; }
    public RegexAlternationNode(EmbeddedSeparatedSyntaxNodeList`3<RegexKind, RegexNode, RegexSequenceNode> sequenceList);
    [CompilerGeneratedAttribute]
public EmbeddedSeparatedSyntaxNodeList`3<RegexKind, RegexNode, RegexSequenceNode> get_SequenceList();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorEscapeNode : RegexTypeEscapeNode {
    internal int ChildCount { get; }
    public RegexAnchorEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <AnchorToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> AnchorToken { get; }
    internal int ChildCount { get; }
    public RegexAnchorNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> anchorToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_AnchorToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAtomicGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <GreaterThanToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> GreaterThanToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexAtomicGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> greaterThanToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_GreaterThanToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBackreferenceEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <NumberToken>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> NumberToken { get; }
    public RegexBackreferenceEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> numberToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_NumberToken();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBalancingGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <FirstCaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <MinusToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <SecondCaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OpenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> FirstCaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> MinusToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> SecondCaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexBalancingGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> firstCaptureToken, EmbeddedSyntaxToken`1<RegexKind> minusToken, EmbeddedSyntaxToken`1<RegexKind> secondCaptureToken, EmbeddedSyntaxToken`1<RegexKind> closeToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_FirstCaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_MinusToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_SecondCaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBaseCharacterClassNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenBracketToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexSequenceNode <Components>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseBracketToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OpenBracketToken { get; }
    public RegexSequenceNode Components { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseBracketToken { get; }
    protected RegexBaseCharacterClassNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openBracketToken, RegexSequenceNode components, EmbeddedSyntaxToken`1<RegexKind> closeBracketToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenBracketToken();
    [CompilerGeneratedAttribute]
public RegexSequenceNode get_Components();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseBracketToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseToken>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OpenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseToken { get; }
    public RegexCaptureEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> captureToken, EmbeddedSyntaxToken`1<RegexKind> closeToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseToken();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OpenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexCaptureGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> captureToken, EmbeddedSyntaxToken`1<RegexKind> closeToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCategoryEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <TypeToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenBraceToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CategoryToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseBraceToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> TypeToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OpenBraceToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CategoryToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseBraceToken { get; }
    internal int ChildCount { get; }
    public RegexCategoryEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> categoryToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_TypeToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenBraceToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CategoryToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseBraceToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassEscapeNode : RegexTypeEscapeNode {
    internal int ChildCount { get; }
    public RegexCharacterClassEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassNode : RegexBaseCharacterClassNode {
    internal int ChildCount { get; }
    public RegexCharacterClassNode(EmbeddedSyntaxToken`1<RegexKind> openBracketToken, RegexSequenceNode components, EmbeddedSyntaxToken`1<RegexKind> closeBracketToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassRangeNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <MinusToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Right>k__BackingField;
    public RegexExpressionNode Left { get; }
    public EmbeddedSyntaxToken`1<RegexKind> MinusToken { get; }
    public RegexExpressionNode Right { get; }
    internal int ChildCount { get; }
    public RegexCharacterClassRangeNode(RegexExpressionNode left, EmbeddedSyntaxToken`1<RegexKind> minusToken, RegexExpressionNode right);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Left();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_MinusToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Right();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassSubtractionNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <MinusToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexBaseCharacterClassNode <CharacterClass>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> MinusToken { get; }
    public RegexBaseCharacterClassNode CharacterClass { get; }
    internal int ChildCount { get; }
    public RegexCharacterClassSubtractionNode(EmbeddedSyntaxToken`1<RegexKind> minusToken, RegexBaseCharacterClassNode characterClass);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_MinusToken();
    [CompilerGeneratedAttribute]
public RegexBaseCharacterClassNode get_CharacterClass();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal static class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharClass : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Dictionary`2<string, ValueTuple`2<string, string>> EscapeCategories;
    private static RegexCharClass();
    public static bool IsEscapeCategory(string value);
    public static bool IsBoundaryWordChar(VirtualChar r);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexClosedNumericRangeQuantifierNode : RegexNumericQuantifierNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CommaToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <SecondNumberToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> CommaToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> SecondNumberToken { get; }
    internal int ChildCount { get; }
    public RegexClosedNumericRangeQuantifierNode(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> firstNumberToken, EmbeddedSyntaxToken`1<RegexKind> commaToken, EmbeddedSyntaxToken`1<RegexKind> secondNumberToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CommaToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_SecondNumberToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCompilationUnit : RegexNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <EndOfFileToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> EndOfFileToken { get; }
    internal int ChildCount { get; }
    public RegexCompilationUnit(RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> endOfFileToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_EndOfFileToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalCaptureGroupingNode : RegexConditionalGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <InnerOpenParenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <InnerCloseParenToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> InnerOpenParenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> InnerCloseParenToken { get; }
    internal int ChildCount { get; }
    public RegexConditionalCaptureGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> innerOpenParenToken, EmbeddedSyntaxToken`1<RegexKind> captureToken, EmbeddedSyntaxToken`1<RegexKind> innerCloseParenToken, RegexExpressionNode result, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_InnerOpenParenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_InnerCloseParenToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalExpressionGroupingNode : RegexConditionalGroupingNode {
    [CompilerGeneratedAttribute]
private RegexGroupingNode <Grouping>k__BackingField;
    internal int ChildCount { get; }
    public RegexGroupingNode Grouping { get; }
    public RegexConditionalExpressionGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, RegexGroupingNode grouping, RegexExpressionNode result, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public RegexGroupingNode get_Grouping();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Result>k__BackingField;
    public RegexExpressionNode Result { get; }
    protected RegexConditionalGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, RegexExpressionNode result, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Result();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexControlEscapeNode : RegexTypeEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ControlToken>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> ControlToken { get; }
    public RegexControlEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> controlToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ControlToken();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexEscapeNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <BackslashToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> BackslashToken { get; }
    protected RegexEscapeNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> backslashToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_BackslashToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExactNumericQuantifierNode : RegexNumericQuantifierNode {
    internal int ChildCount { get; }
    public RegexExactNumericQuantifierNode(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> numberToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExpressionNode : RegexNode {
    protected RegexExpressionNode(RegexKind kind);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexGroupingNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenParenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseParenToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OpenParenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseParenToken { get; }
    protected RegexGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenParenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseParenToken();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHelpers : object {
    public static bool HasOption(RegexOptions options, RegexOptions val);
    public static EmbeddedSyntaxToken`1<RegexKind> CreateToken(RegexKind kind, ImmutableArray`1<EmbeddedSyntaxTrivia`1<RegexKind>> leadingTrivia, VirtualCharSequence virtualChars);
    public static EmbeddedSyntaxToken`1<RegexKind> CreateMissingToken(RegexKind kind);
    public static EmbeddedSyntaxTrivia`1<RegexKind> CreateTrivia(RegexKind kind, VirtualCharSequence virtualChars);
    public static EmbeddedSyntaxTrivia`1<RegexKind> CreateTrivia(RegexKind kind, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public static VirtualChar MapEscapeChar(VirtualChar ch);
    [ExtensionAttribute]
public static bool IsSelfEscape(RegexSimpleEscapeNode node);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHexEscapeNode : RegexTypeEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <HexText>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> HexText { get; }
    public RegexHexEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> hexText);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_HexText();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKCaptureEscapeNode : RegexTypeEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaptureToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseToken>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OpenToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CaptureToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseToken { get; }
    public RegexKCaptureEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> captureToken, EmbeddedSyntaxToken`1<RegexKind> closeToken);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaptureToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseToken();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal enum Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind : Enum {
    public int value__;
    public static RegexKind None;
    public static RegexKind EndOfFile;
    public static RegexKind Sequence;
    public static RegexKind CompilationUnit;
    public static RegexKind Text;
    public static RegexKind StartAnchor;
    public static RegexKind EndAnchor;
    public static RegexKind Alternation;
    public static RegexKind Wildcard;
    public static RegexKind CharacterClass;
    public static RegexKind NegatedCharacterClass;
    public static RegexKind CharacterClassRange;
    public static RegexKind CharacterClassSubtraction;
    public static RegexKind PosixProperty;
    public static RegexKind ZeroOrMoreQuantifier;
    public static RegexKind OneOrMoreQuantifier;
    public static RegexKind ZeroOrOneQuantifier;
    public static RegexKind ExactNumericQuantifier;
    public static RegexKind OpenRangeNumericQuantifier;
    public static RegexKind ClosedRangeNumericQuantifier;
    public static RegexKind LazyQuantifier;
    public static RegexKind SimpleGrouping;
    public static RegexKind SimpleOptionsGrouping;
    public static RegexKind NestedOptionsGrouping;
    public static RegexKind NonCapturingGrouping;
    public static RegexKind PositiveLookaheadGrouping;
    public static RegexKind NegativeLookaheadGrouping;
    public static RegexKind PositiveLookbehindGrouping;
    public static RegexKind NegativeLookbehindGrouping;
    public static RegexKind AtomicGrouping;
    public static RegexKind CaptureGrouping;
    public static RegexKind BalancingGrouping;
    public static RegexKind ConditionalCaptureGrouping;
    public static RegexKind ConditionalExpressionGrouping;
    public static RegexKind SimpleEscape;
    public static RegexKind AnchorEscape;
    public static RegexKind CharacterClassEscape;
    public static RegexKind CategoryEscape;
    public static RegexKind ControlEscape;
    public static RegexKind HexEscape;
    public static RegexKind UnicodeEscape;
    public static RegexKind OctalEscape;
    public static RegexKind CaptureEscape;
    public static RegexKind KCaptureEscape;
    public static RegexKind BackreferenceEscape;
    public static RegexKind DollarToken;
    public static RegexKind OpenBraceToken;
    public static RegexKind CloseBraceToken;
    public static RegexKind OpenBracketToken;
    public static RegexKind CloseBracketToken;
    public static RegexKind OpenParenToken;
    public static RegexKind CloseParenToken;
    public static RegexKind BarToken;
    public static RegexKind DotToken;
    public static RegexKind CaretToken;
    public static RegexKind TextToken;
    public static RegexKind QuestionToken;
    public static RegexKind AsteriskToken;
    public static RegexKind PlusToken;
    public static RegexKind CommaToken;
    public static RegexKind BackslashToken;
    public static RegexKind ColonToken;
    public static RegexKind EqualsToken;
    public static RegexKind ExclamationToken;
    public static RegexKind GreaterThanToken;
    public static RegexKind LessThanToken;
    public static RegexKind MinusToken;
    public static RegexKind SingleQuoteToken;
    public static RegexKind OptionsToken;
    public static RegexKind NumberToken;
    public static RegexKind CaptureNameToken;
    public static RegexKind EscapeCategoryToken;
    public static RegexKind CommentTrivia;
    public static RegexKind WhitespaceTrivia;
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLazyQuantifierNode : RegexExpressionNode {
    [CompilerGeneratedAttribute]
private RegexQuantifierNode <Quantifier>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <QuestionToken>k__BackingField;
    public RegexQuantifierNode Quantifier { get; }
    public EmbeddedSyntaxToken`1<RegexKind> QuestionToken { get; }
    internal int ChildCount { get; }
    public RegexLazyQuantifierNode(RegexQuantifierNode quantifier, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    [CompilerGeneratedAttribute]
public RegexQuantifierNode get_Quantifier();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_QuestionToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLexer : ValueType {
    public VirtualCharSequence Text;
    public int Position;
    public VirtualChar CurrentChar { get; }
    public RegexLexer(VirtualCharSequence text);
    [IsReadOnlyAttribute]
public VirtualChar get_CurrentChar();
    [IsReadOnlyAttribute]
public VirtualCharSequence GetSubPatternToCurrentPos(int start);
    [IsReadOnlyAttribute]
public VirtualCharSequence GetSubPattern(int start, int end);
    public EmbeddedSyntaxToken`1<RegexKind> ScanNextToken(bool allowTrivia, RegexOptions options);
    private static RegexKind GetKind(VirtualChar ch);
    private ImmutableArray`1<EmbeddedSyntaxTrivia`1<RegexKind>> ScanLeadingTrivia(bool allowTrivia, RegexOptions options);
    public Nullable`1<EmbeddedSyntaxTrivia`1<RegexKind>> ScanComment(RegexOptions options);
    [IsReadOnlyAttribute]
public TextSpan GetTextSpan(int startInclusive, int endExclusive);
    [IsReadOnlyAttribute]
public bool IsAt(string val);
    [IsReadOnlyAttribute]
private bool TextAt(int position, string val);
    private Nullable`1<EmbeddedSyntaxTrivia`1<RegexKind>> ScanWhitespace(RegexOptions options);
    private static bool IsBlank(VirtualChar ch);
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanEscapeCategory();
    private static bool IsEscapeCategoryChar(VirtualChar ch);
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanNumber();
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanCaptureName();
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanNumberOrCaptureName();
    public Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> TryScanOptions();
    private static bool IsOptionChar(VirtualChar ch);
    public EmbeddedSyntaxToken`1<RegexKind> ScanHexCharacters(int count);
    public static bool IsHexChar(VirtualChar ch);
    private static bool IsDecimalDigit(VirtualChar ch);
    private static bool IsOctalDigit(VirtualChar ch);
    public EmbeddedSyntaxToken`1<RegexKind> ScanOctalCharacters(RegexOptions options);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLookbehindGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <LessThanToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> LessThanToken { get; }
    protected RegexLookbehindGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> lessThanToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_LessThanToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegatedCharacterClassNode : RegexBaseCharacterClassNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CaretToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> CaretToken { get; }
    internal int ChildCount { get; }
    public RegexNegatedCharacterClassNode(EmbeddedSyntaxToken`1<RegexKind> openBracketToken, EmbeddedSyntaxToken`1<RegexKind> caretToken, RegexSequenceNode components, EmbeddedSyntaxToken`1<RegexKind> closeBracketToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CaretToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegativeLookaheadGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ExclamationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> ExclamationToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexNegativeLookaheadGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> exclamationToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ExclamationToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegativeLookbehindGroupingNode : RegexLookbehindGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ExclamationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> ExclamationToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexNegativeLookbehindGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> lessThanToken, EmbeddedSyntaxToken`1<RegexKind> exclamationToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ExclamationToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNestedOptionsGroupingNode : RegexOptionsGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ColonToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> ColonToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexNestedOptionsGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken, EmbeddedSyntaxToken`1<RegexKind> colonToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ColonToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNode : EmbeddedSyntaxNode`2<RegexKind, RegexNode> {
    protected RegexNode(RegexKind kind);
    public abstract virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNonCapturingGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <ColonToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> ColonToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexNonCapturingGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> colonToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_ColonToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNumericQuantifierNode : RegexQuantifierNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OpenBraceToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <FirstNumberToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CloseBraceToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OpenBraceToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> FirstNumberToken { get; }
    public EmbeddedSyntaxToken`1<RegexKind> CloseBraceToken { get; }
    protected RegexNumericQuantifierNode(RegexKind kind, RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> firstNumberToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OpenBraceToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_FirstNumberToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CloseBraceToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOctalEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OctalText>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> OctalText { get; }
    public RegexOctalEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> octalText);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OctalText();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOneOrMoreQuantifierNode : RegexQuantifierNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <PlusToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> PlusToken { get; }
    internal int ChildCount { get; }
    public RegexOneOrMoreQuantifierNode(RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> plusToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_PlusToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOpenNumericRangeQuantifierNode : RegexNumericQuantifierNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <CommaToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> CommaToken { get; }
    internal int ChildCount { get; }
    public RegexOpenNumericRangeQuantifierNode(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> firstNumberToken, EmbeddedSyntaxToken`1<RegexKind> commaToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_CommaToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOptionsGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <OptionsToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> OptionsToken { get; }
    protected RegexOptionsGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_OptionsToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser : ValueType {
    [NullableAttribute("1")]
private ImmutableDictionary`2<string, TextSpan> _captureNamesToSpan;
    [NullableAttribute("1")]
private ImmutableDictionary`2<int, TextSpan> _captureNumbersToSpan;
    private RegexLexer _lexer;
    private RegexOptions _options;
    private EmbeddedSyntaxToken`1<RegexKind> _currentToken;
    private int _recursionDepth;
    [NullableContextAttribute("1")]
private RegexParser(VirtualCharSequence text, RegexOptions options, ImmutableDictionary`2<string, TextSpan> captureNamesToSpan, ImmutableDictionary`2<int, TextSpan> captureNumbersToSpan);
    private EmbeddedSyntaxToken`1<RegexKind> ConsumeCurrentToken(bool allowTrivia);
    [NullableContextAttribute("2")]
public static RegexTree TryParse(VirtualCharSequence text, RegexOptions options);
    [NullableContextAttribute("1")]
private RegexTree ParseTree();
    [NullableContextAttribute("1")]
private void CollectDiagnostics(RegexNode node, HashSet`1<EmbeddedDiagnostic> seenDiagnostics, ArrayBuilder`1<EmbeddedDiagnostic> diagnostics);
    [NullableContextAttribute("1")]
private void CollectDiagnosticsWorker(RegexNode node, HashSet`1<EmbeddedDiagnostic> seenDiagnostics, ArrayBuilder`1<EmbeddedDiagnostic> diagnostics);
    [NullableContextAttribute("1")]
private static void AddUniqueDiagnostics(HashSet`1<EmbeddedDiagnostic> seenDiagnostics, ImmutableArray`1<EmbeddedDiagnostic> from, ArrayBuilder`1<EmbeddedDiagnostic> to);
    [NullableContextAttribute("1")]
private RegexAlternationNode ParseAlternatingSequences(bool consumeCloseParen, bool isConditional);
    [NullableContextAttribute("1")]
private RegexAlternationNode ParseAlternatingSequencesWorker(bool consumeCloseParen, bool isConditional);
    [NullableContextAttribute("1")]
private RegexSequenceNode ParseSequence(bool consumeCloseParen);
    [NullableContextAttribute("1")]
private static void MergeTextNodes(ArrayBuilder`1<RegexExpressionNode> list, ArrayBuilder`1<RegexExpressionNode> final);
    [IsReadOnlyAttribute]
private bool ShouldConsumeSequenceElement(bool consumeCloseParen);
    [NullableContextAttribute("1")]
private RegexExpressionNode ParsePrimaryExpressionAndQuantifiers(RegexExpressionNode lastExpression);
    [NullableContextAttribute("1")]
private RegexExpressionNode TryParseLazyQuantifier(RegexQuantifierNode quantifier);
    [NullableContextAttribute("1")]
private RegexExpressionNode ParseZeroOrMoreQuantifier(RegexPrimaryExpressionNode current);
    [NullableContextAttribute("1")]
private RegexExpressionNode ParseOneOrMoreQuantifier(RegexPrimaryExpressionNode current);
    [NullableContextAttribute("1")]
private RegexExpressionNode ParseZeroOrOneQuantifier(RegexPrimaryExpressionNode current);
    [NullableContextAttribute("1")]
private RegexExpressionNode TryParseNumericQuantifier(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken);
    private static RegexQuantifierNode CreateQuantifier(RegexPrimaryExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> openBraceToken, EmbeddedSyntaxToken`1<RegexKind> firstNumberToken, Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> commaToken, Nullable`1<EmbeddedSyntaxToken`1<RegexKind>> secondNumberToken, EmbeddedSyntaxToken`1<RegexKind> closeBraceToken);
    private bool TryParseNumericQuantifierParts(EmbeddedSyntaxToken`1& firstNumberToken, Nullable`1& commaToken, Nullable`1& secondNumberToken, EmbeddedSyntaxToken`1& closeBraceToken);
    private void ResetToPositionAndConsumeCurrentToken(int position, bool allowTrivia);
    [NullableContextAttribute("1")]
private RegexPrimaryExpressionNode ParsePrimaryExpression(RegexExpressionNode lastExpression);
    [NullableContextAttribute("1")]
private RegexPrimaryExpressionNode ParsePossibleUnexpectedNumericQuantifier(RegexExpressionNode lastExpression);
    [NullableContextAttribute("1")]
private RegexPrimaryExpressionNode ParseUnexpectedCloseParenToken();
    [NullableContextAttribute("1")]
private RegexPrimaryExpressionNode ParseText();
    [NullableContextAttribute("1")]
private RegexPrimaryExpressionNode ParseEndAnchor();
    [NullableContextAttribute("1")]
private RegexPrimaryExpressionNode ParseStartAnchor();
    [NullableContextAttribute("1")]
private RegexPrimaryExpressionNode ParseWildcard();
    [NullableContextAttribute("1")]
private RegexGroupingNode ParseGrouping();
    private EmbeddedSyntaxToken`1<RegexKind> ParseGroupingCloseParen();
    private RegexSimpleGroupingNode ParseSimpleGroup(EmbeddedSyntaxToken`1<RegexKind> openParenToken);
    [NullableContextAttribute("1")]
private RegexExpressionNode ParseGroupingEmbeddedExpression(RegexOptions embeddedOptions);
    [IsReadOnlyAttribute]
private TextSpan GetTokenSpanIncludingEOF(EmbeddedSyntaxToken`1<RegexKind> token);
    [IsReadOnlyAttribute]
private TextSpan GetTokenStartPositionSpan(EmbeddedSyntaxToken`1<RegexKind> token);
    private RegexGroupingNode ParseGroupQuestion(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexConditionalGroupingNode ParseConditionalGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    [IsReadOnlyAttribute]
private bool HasCapture(int value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
private bool HasCapture(string value);
    private void MoveBackBeforePreviousScan();
    private RegexConditionalGroupingNode ParseConditionalExpressionGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    [NullableContextAttribute("1")]
private RegexExpressionNode ParseConditionalGroupingResult();
    private RegexGroupingNode ParseLookbehindOrNamedCaptureOrBalancingGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexGroupingNode ParseNamedCaptureOrBalancingGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> openToken);
    private EmbeddedSyntaxToken`1<RegexKind> ParseCaptureGroupingCloseToken(EmbeddedSyntaxToken`1& openParenToken, EmbeddedSyntaxToken`1<RegexKind> openToken);
    private RegexBalancingGroupingNode ParseBalancingGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> openToken, EmbeddedSyntaxToken`1<RegexKind> firstCapture);
    [IsReadOnlyAttribute]
private void CheckCapture(EmbeddedSyntaxToken`1& captureToken);
    private RegexNonCapturingGroupingNode ParseNonCapturingGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexPositiveLookaheadGroupingNode ParsePositiveLookaheadGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexNegativeLookaheadGroupingNode ParseNegativeLookaheadGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexAtomicGroupingNode ParseAtomicGrouping(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    private RegexGroupingNode ParseOptionsGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken);
    private RegexNestedOptionsGroupingNode ParseNestedOptionsGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken);
    private static bool IsTextChar(EmbeddedSyntaxToken`1<RegexKind> currentToken, char ch);
    private static RegexOptions GetNewOptionsFromToken(RegexOptions currentOptions, EmbeddedSyntaxToken`1<RegexKind> optionsToken);
    private static RegexOptions OptionFromCode(VirtualChar ch);
    [NullableContextAttribute("1")]
private RegexBaseCharacterClassNode ParseCharacterClass();
    [NullableContextAttribute("1")]
private void ParseCharacterClassComponents(ArrayBuilder`1<RegexExpressionNode> components);
    [NullableContextAttribute("2")]
private static bool IsEscapedMinus(RegexNode node);
    [NullableContextAttribute("1")]
private static bool TryGetRangeComponentValue(RegexExpressionNode component, Int32& ch);
    [NullableContextAttribute("1")]
private static bool TryGetRangeComponentValueWorker(RegexNode component, Int32& ch);
    private static int GetCharValue(EmbeddedSyntaxToken`1<RegexKind> hexText, int withBase);
    private static int HexValue(VirtualChar ch);
    private static bool HasProblem(EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> component);
    [NullableContextAttribute("1")]
private RegexPrimaryExpressionNode ParseSingleCharacterClassComponent(bool isFirst, bool afterRangeMinus);
    private RegexPrimaryExpressionNode ParseCharacterClassSubtractionNode(EmbeddedSyntaxToken`1<RegexKind> minusToken);
    private RegexEscapeNode ParseEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParseBasicBackslash(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleBackreferenceEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleEcmascriptBackreferenceEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleRegularBackreferenceEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleCaptureEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParsePossibleKCaptureEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private void ScanCaptureParts(bool allowTriviaAfterEnd, EmbeddedSyntaxToken`1& openToken, EmbeddedSyntaxToken`1& capture, EmbeddedSyntaxToken`1& closeToken);
    private RegexEscapeNode ParseCharEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParseUnicodeEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParseHexEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexControlEscapeNode ParseControlEscape(EmbeddedSyntaxToken`1<RegexKind> backslashToken, bool allowTriviaAfterEnd);
    private RegexEscapeNode ParseCategoryEscape(EmbeddedSyntaxToken`1<RegexKind> backslash, bool allowTriviaAfterEnd);
    private bool TryGetCategoryEscapeParts(bool allowTriviaAfterEnd, EmbeddedSyntaxToken`1& openBraceToken, EmbeddedSyntaxToken`1& categoryToken, EmbeddedSyntaxToken`1& closeBraceToken, String& message);
    [NullableContextAttribute("1")]
private RegexTextNode ParseUnexpectedQuantifier(RegexExpressionNode lastExpression);
    private static void CheckQuantifierExpression(RegexExpressionNode current, EmbeddedSyntaxToken`1& token);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static int <MergeTextNodes>g__MergeAndAddAdjacentTextNodes|17_0(ArrayBuilder`1<RegexExpressionNode> list, ArrayBuilder`1<RegexExpressionNode> final, int index);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <MergeTextNodes>g__CanMerge|17_1(RegexTextNode lastNode, RegexExpressionNode next);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPositiveLookaheadGroupingNode : RegexQuestionGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <EqualsToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> EqualsToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexPositiveLookaheadGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> equalsToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_EqualsToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPositiveLookbehindGroupingNode : RegexLookbehindGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <EqualsToken>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> EqualsToken { get; }
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexPositiveLookbehindGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> lessThanToken, EmbeddedSyntaxToken`1<RegexKind> equalsToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_EqualsToken();
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPosixPropertyNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <TextToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> TextToken { get; }
    internal int ChildCount { get; }
    public RegexPosixPropertyNode(EmbeddedSyntaxToken`1<RegexKind> textToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_TextToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPrimaryExpressionNode : RegexExpressionNode {
    protected RegexPrimaryExpressionNode(RegexKind kind);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexQuantifierNode : RegexExpressionNode {
    protected RegexQuantifierNode(RegexKind kind);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexQuestionGroupingNode : RegexGroupingNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <QuestionToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> QuestionToken { get; }
    protected RegexQuestionGroupingNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_QuestionToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSequenceNode : RegexExpressionNode {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RegexExpressionNode> <Children>k__BackingField;
    public ImmutableArray`1<RegexExpressionNode> Children { get; }
    internal int ChildCount { get; }
    public RegexSequenceNode(ImmutableArray`1<RegexExpressionNode> children);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RegexExpressionNode> get_Children();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleEscapeNode : RegexTypeEscapeNode {
    internal int ChildCount { get; }
    public RegexSimpleEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleGroupingNode : RegexGroupingNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    public RegexExpressionNode Expression { get; }
    internal int ChildCount { get; }
    public RegexSimpleGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleOptionsGroupingNode : RegexOptionsGroupingNode {
    internal int ChildCount { get; }
    public RegexSimpleOptionsGroupingNode(EmbeddedSyntaxToken`1<RegexKind> openParenToken, EmbeddedSyntaxToken`1<RegexKind> questionToken, EmbeddedSyntaxToken`1<RegexKind> optionsToken, EmbeddedSyntaxToken`1<RegexKind> closeParenToken);
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTextNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <TextToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> TextToken { get; }
    internal int ChildCount { get; }
    public RegexTextNode(EmbeddedSyntaxToken`1<RegexKind> textToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_TextToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTree : EmbeddedSyntaxTree`3<RegexKind, RegexNode, RegexCompilationUnit> {
    public ImmutableDictionary`2<string, TextSpan> CaptureNamesToSpan;
    public ImmutableDictionary`2<int, TextSpan> CaptureNumbersToSpan;
    public RegexTree(VirtualCharSequence text, RegexCompilationUnit root, ImmutableArray`1<EmbeddedDiagnostic> diagnostics, ImmutableDictionary`2<string, TextSpan> captureNamesToSpan, ImmutableDictionary`2<int, TextSpan> captureNumbersToSpan);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTypeEscapeNode : RegexEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <TypeToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> TypeToken { get; }
    protected RegexTypeEscapeNode(RegexKind kind, EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_TypeToken();
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexUnicodeEscapeNode : RegexTypeEscapeNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <HexText>k__BackingField;
    internal int ChildCount { get; }
    public EmbeddedSyntaxToken`1<RegexKind> HexText { get; }
    public RegexUnicodeEscapeNode(EmbeddedSyntaxToken`1<RegexKind> backslashToken, EmbeddedSyntaxToken`1<RegexKind> typeToken, EmbeddedSyntaxToken`1<RegexKind> hexText);
    internal virtual int get_ChildCount();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_HexText();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexWildcardNode : RegexPrimaryExpressionNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <DotToken>k__BackingField;
    public EmbeddedSyntaxToken`1<RegexKind> DotToken { get; }
    internal int ChildCount { get; }
    public RegexWildcardNode(EmbeddedSyntaxToken`1<RegexKind> dotToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_DotToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexZeroOrMoreQuantifierNode : RegexQuantifierNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <AsteriskToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> AsteriskToken { get; }
    internal int ChildCount { get; }
    public RegexZeroOrMoreQuantifierNode(RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> asteriskToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_AsteriskToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexZeroOrOneQuantifierNode : RegexQuantifierNode {
    [CompilerGeneratedAttribute]
private RegexExpressionNode <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<RegexKind> <QuestionToken>k__BackingField;
    public RegexExpressionNode Expression { get; }
    public EmbeddedSyntaxToken`1<RegexKind> QuestionToken { get; }
    internal int ChildCount { get; }
    public RegexZeroOrOneQuantifierNode(RegexExpressionNode expression, EmbeddedSyntaxToken`1<RegexKind> questionToken);
    [CompilerGeneratedAttribute]
public RegexExpressionNode get_Expression();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<RegexKind> get_QuestionToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<RegexKind, RegexNode> ChildAt(int index);
    public virtual void Accept(IRegexNodeVisitor visitor);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.IStackFrameNodeVisitor {
    public abstract virtual void Visit(StackFrameCompilationUnit node);
    public abstract virtual void Visit(StackFrameMethodDeclarationNode node);
    public abstract virtual void Visit(StackFrameQualifiedNameNode node);
    public abstract virtual void Visit(StackFrameTypeArgumentList node);
    public abstract virtual void Visit(StackFrameParameterList node);
    public abstract virtual void Visit(StackFrameGenericNameNode node);
    public abstract virtual void Visit(StackFrameIdentifierNameNode node);
    public abstract virtual void Visit(StackFrameArrayRankSpecifier node);
    public abstract virtual void Visit(StackFrameFileInformationNode node);
    public abstract virtual void Visit(StackFrameArrayTypeNode node);
    public abstract virtual void Visit(StackFrameParameterDeclarationNode node);
    public abstract virtual void Visit(StackFrameGeneratedMethodNameNode stackFrameGeneratedNameNode);
    public abstract virtual void Visit(StackFrameLocalMethodNameNode stackFrameLocalMethodNameNode);
    public abstract virtual void Visit(StackFrameConstructorNode constructorNode);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.Result`1 : ValueType {
    public bool Success;
    public T Value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`1<T> Abort;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Result`1<T> Empty;
    public Result`1(T value);
    private Result`1(bool success, T value);
    private static Result`1();
    public void Deconstruct(Boolean& success, T& value);
    [NullableContextAttribute("1")]
public static Result`1<T> op_Implicit(T value);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameArrayRankSpecifier : StackFrameNode {
    public EmbeddedSyntaxToken`1<StackFrameKind> OpenBracket;
    public EmbeddedSyntaxToken`1<StackFrameKind> CloseBracket;
    public ImmutableArray`1<EmbeddedSyntaxToken`1<StackFrameKind>> CommaTokens;
    internal int ChildCount { get; }
    public StackFrameArrayRankSpecifier(EmbeddedSyntaxToken`1<StackFrameKind> openBracket, EmbeddedSyntaxToken`1<StackFrameKind> closeBracket, ImmutableArray`1<EmbeddedSyntaxToken`1<StackFrameKind>> commaTokens);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameArrayTypeNode : StackFrameTypeNode {
    public StackFrameNameNode TypeIdentifier;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<StackFrameArrayRankSpecifier> ArrayRankSpecifiers;
    internal int ChildCount { get; }
    public StackFrameArrayTypeNode(StackFrameNameNode typeIdentifier, ImmutableArray`1<StackFrameArrayRankSpecifier> arrayRankSpecifiers);
    internal virtual int get_ChildCount();
    public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameCompilationUnit : StackFrameNode {
    [NullableAttribute("1")]
public StackFrameMethodDeclarationNode MethodDeclaration;
    [NullableAttribute("2")]
public StackFrameFileInformationNode FileInformationExpression;
    public EmbeddedSyntaxToken`1<StackFrameKind> EndOfLineToken;
    internal int ChildCount { get; }
    public StackFrameCompilationUnit(StackFrameMethodDeclarationNode methodDeclaration, StackFrameFileInformationNode fileInformationExpression, EmbeddedSyntaxToken`1<StackFrameKind> endOfLineToken);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameConstructorNode : StackFrameSimpleNameNode {
    internal int ChildCount { get; }
    public StackFrameConstructorNode(EmbeddedSyntaxToken`1<StackFrameKind> constructor);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameDeclarationNode : StackFrameNode {
    protected StackFrameDeclarationNode(StackFrameKind kind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> ToImmutableArray(Nullable`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> trivia);
    [ExtensionAttribute]
public static ImmutableArray`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> ToImmutableArray(EmbeddedSyntaxTrivia`1<StackFrameKind> trivia);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameFileInformationNode : StackFrameNode {
    public EmbeddedSyntaxToken`1<StackFrameKind> Path;
    public Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> Colon;
    public Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> Line;
    internal int ChildCount { get; }
    public StackFrameFileInformationNode(EmbeddedSyntaxToken`1<StackFrameKind> path, Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> colon, Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> line);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameGeneratedMethodNameNode : StackFrameGeneratedNameNode {
    public EmbeddedSyntaxToken`1<StackFrameKind> LessThanToken;
    public EmbeddedSyntaxToken`1<StackFrameKind> GreaterThanToken;
    public Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> DollarToken;
    internal int ChildCount { get; }
    public StackFrameGeneratedMethodNameNode(EmbeddedSyntaxToken`1<StackFrameKind> lessThanToken, EmbeddedSyntaxToken`1<StackFrameKind> identifier, EmbeddedSyntaxToken`1<StackFrameKind> greaterThanToken, Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> dollarToken);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameGeneratedNameNode : StackFrameSimpleNameNode {
    protected StackFrameGeneratedNameNode(EmbeddedSyntaxToken`1<StackFrameKind> identifier, StackFrameKind kind);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameGenericNameNode : StackFrameSimpleNameNode {
    public EmbeddedSyntaxToken`1<StackFrameKind> GraveAccentToken;
    public EmbeddedSyntaxToken`1<StackFrameKind> NumberToken;
    internal int ChildCount { get; }
    public StackFrameGenericNameNode(EmbeddedSyntaxToken`1<StackFrameKind> identifier, EmbeddedSyntaxToken`1<StackFrameKind> graveAccentToken, EmbeddedSyntaxToken`1<StackFrameKind> numberToken);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameIdentifierNameNode : StackFrameSimpleNameNode {
    internal int ChildCount { get; }
    public StackFrameIdentifierNameNode(EmbeddedSyntaxToken`1<StackFrameKind> identifier);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal enum Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameKind : Enum {
    public int value__;
    public static StackFrameKind None;
    public static StackFrameKind CompilationUnit;
    public static StackFrameKind MethodDeclaration;
    public static StackFrameKind MemberAccess;
    public static StackFrameKind ArrayTypeExpression;
    public static StackFrameKind GenericTypeIdentifier;
    public static StackFrameKind GeneratedIdentifier;
    public static StackFrameKind LocalMethodIdentifier;
    public static StackFrameKind TypeArgument;
    public static StackFrameKind TypeIdentifier;
    public static StackFrameKind Parameter;
    public static StackFrameKind ParameterList;
    public static StackFrameKind ArrayExpression;
    public static StackFrameKind FileInformation;
    public static StackFrameKind Constructor;
    public static StackFrameKind EndOfFrame;
    public static StackFrameKind AmpersandToken;
    public static StackFrameKind OpenBracketToken;
    public static StackFrameKind CloseBracketToken;
    public static StackFrameKind OpenParenToken;
    public static StackFrameKind CloseParenToken;
    public static StackFrameKind DotToken;
    public static StackFrameKind PlusToken;
    public static StackFrameKind CommaToken;
    public static StackFrameKind ColonToken;
    public static StackFrameKind EqualsToken;
    public static StackFrameKind GreaterThanToken;
    public static StackFrameKind LessThanToken;
    public static StackFrameKind MinusToken;
    public static StackFrameKind SingleQuoteToken;
    public static StackFrameKind GraveAccentToken;
    public static StackFrameKind BackslashToken;
    public static StackFrameKind ForwardSlashToken;
    public static StackFrameKind IdentifierToken;
    public static StackFrameKind PathToken;
    public static StackFrameKind NumberToken;
    public static StackFrameKind DollarToken;
    public static StackFrameKind PipeToken;
    public static StackFrameKind GeneratedNameSeparatorToken;
    public static StackFrameKind GeneratedNameSuffixToken;
    public static StackFrameKind ConstructorToken;
    public static StackFrameKind WhitespaceTrivia;
    public static StackFrameKind AtTrivia;
    public static StackFrameKind InTrivia;
    public static StackFrameKind LineTrivia;
    public static StackFrameKind SkippedTextTrivia;
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLexer : ValueType {
    public VirtualCharSequence Text;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    private static ImmutableArray`1<Language> s_languages;
    public int Position { get; private set; }
    public VirtualChar CurrentChar { get; }
    [NullableContextAttribute("1")]
private StackFrameLexer(string text);
    private StackFrameLexer(VirtualCharSequence text);
    private static StackFrameLexer();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    [NullableContextAttribute("1")]
public static Nullable`1<StackFrameLexer> TryCreate(string text);
    public static Nullable`1<StackFrameLexer> TryCreate(VirtualCharSequence text);
    [IsReadOnlyAttribute]
public VirtualChar get_CurrentChar();
    [IsReadOnlyAttribute]
public VirtualCharSequence GetSubSequenceToCurrentPos(int start);
    [IsReadOnlyAttribute]
public VirtualCharSequence GetSubSequence(int start, int end);
    public Nullable`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> TryScanRemainingTrivia();
    public Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanIdentifier();
    public Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanIdentifier(bool scanAtTrivia, bool scanLeadingWhitespace, bool scanTrailingWhitespace);
    [IsReadOnlyAttribute]
public EmbeddedSyntaxToken`1<StackFrameKind> CurrentCharAsToken();
    public bool ScanCurrentCharAsTokenIfMatch(StackFrameKind kind, EmbeddedSyntaxToken`1& token);
    public bool ScanCurrentCharAsTokenIfMatch(StackFrameKind kind, bool scanTrailingWhitespace, EmbeddedSyntaxToken`1& token);
    public bool ScanCurrentCharAsTokenIfMatch(Func`2<StackFrameKind, bool> isMatch, EmbeddedSyntaxToken`1& token);
    public Nullable`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> TryScanAtTrivia();
    public Nullable`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> TryScanInTrivia();
    public Nullable`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> TryScanLineTrivia();
    public Result`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanPath();
    public Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanRequiredLineNumber();
    public Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanNumbers();
    public Result`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanRequiredGeneratedNameSeparator();
    public Result`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanRequiredGeneratedNameSuffix();
    public static bool IsBlank(VirtualChar ch);
    private static bool IsAsciiAlphaCharacter(VirtualChar ch);
    public static EmbeddedSyntaxToken`1<StackFrameKind> CreateToken(StackFrameKind kind, VirtualCharSequence virtualChars);
    public static EmbeddedSyntaxToken`1<StackFrameKind> CreateToken(StackFrameKind kind, ImmutableArray`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> leadingTrivia, VirtualCharSequence virtualChars);
    public static EmbeddedSyntaxToken`1<StackFrameKind> CreateToken(StackFrameKind kind, ImmutableArray`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> leadingTrivia, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> trailingTrivia);
    private static EmbeddedSyntaxTrivia`1<StackFrameKind> CreateTrivia(StackFrameKind kind, VirtualCharSequence virtualChars);
    private static EmbeddedSyntaxTrivia`1<StackFrameKind> CreateTrivia(StackFrameKind kind, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    private static ImmutableArray`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> CreateTrivia(Nullable`1[] triviaArray);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
private bool IsStringAtPosition(string val);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
private bool IsAtStartOfText(int position, string val);
    private Nullable`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> TryScanStringTrivia(string valueToLookFor, StackFrameKind triviaKind);
    private Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanStringToken(string valueToLookFor, StackFrameKind tokenKind);
    private Nullable`1<EmbeddedSyntaxTrivia`1<StackFrameKind>> TryScanWhiteSpace();
    private Nullable`1<EmbeddedSyntaxToken`1<StackFrameKind>> TryScanConstructor();
    private static StackFrameKind GetKind(VirtualChar ch);
    private static bool IsNumber(VirtualChar ch);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameLocalMethodNameNode : StackFrameGeneratedNameNode {
    [NullableAttribute("1")]
internal StackFrameGeneratedMethodNameNode EncapsulatingMethod;
    internal EmbeddedSyntaxToken`1<StackFrameKind> GeneratedNameSeparator;
    internal EmbeddedSyntaxToken`1<StackFrameKind> PipeToken;
    internal EmbeddedSyntaxToken`1<StackFrameKind> Suffix;
    internal int ChildCount { get; }
    public StackFrameLocalMethodNameNode(StackFrameGeneratedMethodNameNode encapsulatngMethod, EmbeddedSyntaxToken`1<StackFrameKind> generatedNameSeparator, EmbeddedSyntaxToken`1<StackFrameKind> identifier, EmbeddedSyntaxToken`1<StackFrameKind> pipeToken, EmbeddedSyntaxToken`1<StackFrameKind> suffix);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameMethodDeclarationNode : StackFrameDeclarationNode {
    public StackFrameQualifiedNameNode MemberAccessExpression;
    [NullableAttribute("2")]
public StackFrameTypeArgumentList TypeArguments;
    public StackFrameParameterList ArgumentList;
    internal int ChildCount { get; }
    public StackFrameMethodDeclarationNode(StackFrameQualifiedNameNode memberAccessExpression, StackFrameTypeArgumentList typeArguments, StackFrameParameterList argumentList);
    internal virtual int get_ChildCount();
    public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameNameNode : StackFrameTypeNode {
    protected StackFrameNameNode(StackFrameKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameNode : EmbeddedSyntaxNode`2<StackFrameKind, StackFrameNode> {
    protected StackFrameNode(StackFrameKind kind);
    public abstract virtual void Accept(IStackFrameNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParameterDeclarationNode : StackFrameDeclarationNode {
    [NullableAttribute("1")]
public StackFrameTypeNode Type;
    public EmbeddedSyntaxToken`1<StackFrameKind> Identifier;
    internal int ChildCount { get; }
    public StackFrameParameterDeclarationNode(StackFrameTypeNode type, EmbeddedSyntaxToken`1<StackFrameKind> identifier);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParameterList : StackFrameNode {
    public EmbeddedSyntaxToken`1<StackFrameKind> OpenParen;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EmbeddedSeparatedSyntaxNodeList`3<StackFrameKind, StackFrameNode, StackFrameParameterDeclarationNode> Parameters;
    public EmbeddedSyntaxToken`1<StackFrameKind> CloseParen;
    internal int ChildCount { get; }
    public StackFrameParameterList(EmbeddedSyntaxToken`1<StackFrameKind> openToken, EmbeddedSeparatedSyntaxNodeList`3<StackFrameKind, StackFrameNode, StackFrameParameterDeclarationNode> parameters, EmbeddedSyntaxToken`1<StackFrameKind> closeToken);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameParser : ValueType {
    private StackFrameLexer _lexer;
    private StackFrameParser(StackFrameLexer lexer);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
private EmbeddedSyntaxToken`1<StackFrameKind> CurrentCharAsToken();
    public static StackFrameTree TryParse(VirtualCharSequence text);
    [NullableContextAttribute("1")]
public static StackFrameTree TryParse(string text);
    private StackFrameTree TryParseTree();
    private StackFrameMethodDeclarationNode TryParseRequiredMethodDeclaration();
    private StackFrameNameNode TryParseRequiredNameNode(bool scanAtTrivia);
    [NullableContextAttribute("1")]
private Result`1<StackFrameQualifiedNameNode> TryParseQualifiedName(StackFrameNameNode lhs);
    private Result`1<StackFrameGeneratedNameNode> TryScanGeneratedName();
    [NullableContextAttribute("0")]
private Result`1<StackFrameSimpleNameNode> TryScanGenericTypeIdentifier(EmbeddedSyntaxToken`1<StackFrameKind> identifierToken);
    private Result`1<StackFrameTypeArgumentList> TryParseTypeArguments();
    private StackFrameParameterList TryParseRequiredMethodParameters();
    private Result`1<StackFrameParameterDeclarationNode> ParseParameterNode();
    private Result`1<ImmutableArray`1<StackFrameArrayRankSpecifier>> ParseArrayRankSpecifiers();
    private Result`1<StackFrameFileInformationNode> TryParseFileInformation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameQualifiedNameNode : StackFrameNameNode {
    public StackFrameNameNode Left;
    [NullableAttribute("0")]
public EmbeddedSyntaxToken`1<StackFrameKind> DotToken;
    public StackFrameSimpleNameNode Right;
    internal int ChildCount { get; }
    public StackFrameQualifiedNameNode(StackFrameNameNode left, EmbeddedSyntaxToken`1<StackFrameKind> dotToken, StackFrameSimpleNameNode right);
    internal virtual int get_ChildCount();
    public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameSimpleNameNode : StackFrameNameNode {
    public EmbeddedSyntaxToken`1<StackFrameKind> Identifier;
    protected StackFrameSimpleNameNode(EmbeddedSyntaxToken`1<StackFrameKind> identifier, StackFrameKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameTree : EmbeddedSyntaxTree`3<StackFrameKind, StackFrameNode, StackFrameCompilationUnit> {
    public StackFrameTree(VirtualCharSequence text, StackFrameCompilationUnit root);
}
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameTypeArgumentList : StackFrameNode {
    public EmbeddedSyntaxToken`1<StackFrameKind> OpenToken;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EmbeddedSeparatedSyntaxNodeList`3<StackFrameKind, StackFrameNode, StackFrameIdentifierNameNode> TypeArguments;
    public EmbeddedSyntaxToken`1<StackFrameKind> CloseToken;
    internal int ChildCount { get; }
    public StackFrameTypeArgumentList(EmbeddedSyntaxToken`1<StackFrameKind> openToken, EmbeddedSeparatedSyntaxNodeList`3<StackFrameKind, StackFrameNode, StackFrameIdentifierNameNode> typeArguments, EmbeddedSyntaxToken`1<StackFrameKind> closeToken);
    internal virtual int get_ChildCount();
    [NullableContextAttribute("1")]
public virtual void Accept(IStackFrameNodeVisitor visitor);
    internal virtual EmbeddedSyntaxNodeOrToken`2<StackFrameKind, StackFrameNode> ChildAt(int index);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.StackFrame.StackFrameTypeNode : StackFrameNode {
    protected StackFrameTypeNode(StackFrameKind kind);
}
internal class Microsoft.CodeAnalysis.Emit.CompilationOutputFiles : CompilationOutputs {
    internal static CompilationOutputFiles None;
    [CompilerGeneratedAttribute]
private string <PdbFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFilePath>k__BackingField;
    public string AssemblyDisplayPath { get; }
    public string PdbDisplayPath { get; }
    public string PdbFilePath { get; }
    public string AssemblyFilePath { get; }
    public CompilationOutputFiles(string assemblyFilePath, string pdbFilePath);
    private static CompilationOutputFiles();
    public virtual string get_AssemblyDisplayPath();
    public virtual string get_PdbDisplayPath();
    [CompilerGeneratedAttribute]
public string get_PdbFilePath();
    [CompilerGeneratedAttribute]
public string get_AssemblyFilePath();
    protected virtual Stream OpenAssemblyStream();
    protected virtual Stream OpenPdbStream();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Emit.CompilationOutputFilesWithImplicitPdbPath : CompilationOutputs {
    [CompilerGeneratedAttribute]
private string <AssemblyFilePath>k__BackingField;
    public string AssemblyFilePath { get; }
    public string AssemblyDisplayPath { get; }
    [NullableAttribute("1")]
public string PdbDisplayPath { get; }
    public CompilationOutputFilesWithImplicitPdbPath(string assemblyFilePath);
    [CompilerGeneratedAttribute]
public string get_AssemblyFilePath();
    public virtual string get_AssemblyDisplayPath();
    [NullableContextAttribute("1")]
public virtual string get_PdbDisplayPath();
    protected virtual Stream OpenAssemblyStream();
    [NullableContextAttribute("1")]
protected virtual Stream OpenPdbStream();
    public virtual DebugInformationReaderProvider OpenPdb();
    private static Stream TryOpenFileStream(string path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Emit.CompilationOutputs : object {
    public string AssemblyDisplayPath { get; }
    public string PdbDisplayPath { get; }
    public abstract virtual string get_AssemblyDisplayPath();
    public abstract virtual string get_PdbDisplayPath();
    public virtual MetadataReaderProvider OpenAssemblyMetadata(bool prefetch);
    internal virtual Guid ReadAssemblyModuleVersionId();
    public virtual DebugInformationReaderProvider OpenPdb();
    private static Stream ValidateStream(Stream stream, string methodName);
    private Stream OpenPdbStreamChecked();
    private Stream OpenAssemblyStreamChecked();
    protected abstract virtual Stream OpenAssemblyStream();
    protected abstract virtual Stream OpenPdbStream();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Emit.CompilationOutputs/<TryCopyAssemblyToAsync>d__12")]
internal ValueTask`1<bool> TryCopyAssemblyToAsync(Stream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Emit.CompilationOutputs/<TryCopyPdbToAsync>d__13")]
internal ValueTask`1<bool> TryCopyPdbToAsync(Stream stream, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Emit.ICompilationOutputsProviderService {
    [NullableContextAttribute("1")]
public abstract virtual CompilationOutputs GetCompilationOutputs(ProjectId projectId);
}
internal abstract class Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService : object {
    private static CultureInfo EnUSCultureInfo;
    private static SymbolRenameOptions s_symbolRenameOptions;
    private static Char[] s_underscoreCharArray;
    private static AbstractEncapsulateFieldService();
    protected abstract virtual Task`1<SyntaxNode> RewriteFieldNameAndAccessibilityAsync(string originalFieldName, bool makePrivate, Document document, SyntaxAnnotation declarationAnnotation, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ImmutableArray`1<IFieldSymbol>> GetFieldsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetConstructorNodes(INamedTypeSymbol containingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<EncapsulateFieldsInSpanAsync>d__5")]
public Task`1<EncapsulateFieldResult> EncapsulateFieldsInSpanAsync(Document document, TextSpan span, CleanCodeGenerationOptionsProvider fallbackOptions, bool useDefaultBehavior, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<GetEncapsulateFieldCodeActionsAsync>d__6")]
public Task`1<ImmutableArray`1<CodeAction>> GetEncapsulateFieldCodeActionsAsync(Document document, TextSpan span, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeAction> EncapsulateAllFields(Document document, ImmutableArray`1<IFieldSymbol> fields, CleanCodeGenerationOptionsProvider fallbackOptions);
    private ImmutableArray`1<CodeAction> EncapsulateOneField(Document document, IFieldSymbol field, CleanCodeGenerationOptionsProvider fallbackOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<EncapsulateFieldsAsync>d__9")]
public Task`1<Solution> EncapsulateFieldsAsync(Document document, ImmutableArray`1<IFieldSymbol> fields, CleanCodeGenerationOptionsProvider fallbackOptions, bool updateReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<EncapsulateFieldsInCurrentProcessAsync>d__10")]
private Task`1<Solution> EncapsulateFieldsInCurrentProcessAsync(Document document, ImmutableArray`1<IFieldSymbol> fields, CleanCodeGenerationOptionsProvider fallbackOptions, bool updateReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<EncapsulateFieldAsync>d__11")]
private Task`1<Solution> EncapsulateFieldAsync(Document document, IFieldSymbol field, bool updateReferences, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<UpdateReferencesAsync>d__12")]
private Task`1<Solution> UpdateReferencesAsync(bool updateReferences, Solution solution, Document document, IFieldSymbol field, string finalFieldName, string generatedPropertyName, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<RenameAsync>d__13")]
private static Task`1<Solution> RenameAsync(Solution solution, IFieldSymbol field, string finalName, CodeCleanupOptionsProvider fallbackOptions, HashSet`1<ProjectId> linkedProjectIds, Func`3<DocumentId, TextSpan, bool> filter, CancellationToken cancellationToken);
    private static bool IntersectsWithAny(DocumentId documentId, TextSpan span, ISet`1<ValueTuple`2<DocumentId, TextSpan>> constructorLocations);
    private ISet`1<ValueTuple`2<DocumentId, TextSpan>> GetConstructorLocations(Solution solution, INamedTypeSymbol containingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService/<AddPropertyAsync>d__16")]
protected static Task`1<Document> AddPropertyAsync(Document document, Solution destinationSolution, IFieldSymbol field, IPropertySymbol property, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected static IPropertySymbol GenerateProperty(string propertyName, string fieldName, Accessibility accessibility, IFieldSymbol field, INamedTypeSymbol containingSymbol, SyntaxAnnotation annotation, Document document);
    protected abstract virtual ValueTuple`2<string, string> GenerateFieldAndPropertyNames(IFieldSymbol field);
    protected static Accessibility ComputeAccessibility(Accessibility accessibility, ITypeSymbol type);
    protected static IMethodSymbol CreateSet(string originalFieldName, IFieldSymbol field, SyntaxGenerator factory);
    protected static IMethodSymbol CreateGet(string originalFieldName, IFieldSymbol field, SyntaxGenerator factory);
    protected static string GeneratePropertyName(string fieldName);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.EncapsulateField.EncapsulateFieldRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.EncapsulateField.EncapsulateFieldRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal class Microsoft.CodeAnalysis.EncapsulateField.EncapsulateFieldResult : object {
    public string Name;
    public Glyph Glyph;
    private AsyncLazy`1<Solution> _lazySolution;
    public EncapsulateFieldResult(string name, Glyph glyph, Func`2<CancellationToken, Task`1<Solution>> getSolutionAsync);
    public Task`1<Solution> GetSolutionAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.EncapsulateField.IRemoteEncapsulateFieldService {
    public abstract virtual ValueTask`1<ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>>> EncapsulateFieldsAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, DocumentId documentId, ImmutableArray`1<string> fieldSymbolKeys, bool updateReferences, CancellationToken cancellationToken);
}
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.EncapsulateField.IRemoteEncapsulateFieldService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.EncapsulateField.RemoteConvertTupleToStructCodeRefactoringServiceCallbackDispatcher : RemoteServiceCallbackDispatcher {
    public sealed virtual ValueTask`1<CleanCodeGenerationOptions> GetOptionsAsync(RemoteServiceCallbackId callbackId, string language, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaCompletionProviderBase : CommonCompletionProvider {
    public static CompletionItem CreateCommonCompletionItem(string displayText, string displayTextSuffix, CompletionItemRules rules, Nullable`1<PythiaGlyph> glyph, ImmutableArray`1<SymbolDisplayPart> description, string sortText, string filterText, bool showsWarningIcon, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags, string inlineDescription);
    public static CompletionItem CreateSymbolCompletionItem(string displayText, IReadOnlyList`1<ISymbol> symbols, CompletionItemRules rules, int contextPosition, string sortText, string insertionText, string filterText, SupportedPlatformData supportedPlatforms, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<string> tags);
    public static ImmutableArray`1<SymbolDisplayPart> CreateRecommendedKeywordDisplayParts(string keyword, string toolTip);
    public static Task`1<CompletionDescription> GetDescriptionAsync(CompletionItem item, Document document, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    public static CompletionDescription GetDescription(CompletionItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaCompletionProviderBase/<GetDescriptionWorkerAsync>d__5")]
internal sealed virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    protected virtual CompletionDescription UpdateDescription(CompletionDescription completionDescription);
    public static bool TryGetInsertionText(CompletionItem item, String& insertionText);
    public sealed virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, CompletionOptions options);
    protected virtual bool IsInsertionTriggerWorker(SourceText text, int insertedCharacterPosition);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public virtual Task NotifyCommittingItemAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaDocumentationCommentFormatting : object {
    [NullableContextAttribute("1")]
public static IEnumerable`1<TaggedText> GetDocumentationParts(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaGlyph : Enum {
    public int value__;
    public static PythiaGlyph Keyword;
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSymbolMatchPriority : object {
    internal static int Keyword;
    internal static int PreferType;
    internal static int PreferNamedArgument;
    internal static int PreferEventOrMethod;
    internal static int PreferFieldOrProperty;
    internal static int PreferLocalOrParameterOrRangeVariable;
    private static PythiaSymbolMatchPriority();
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSymbolSorting : object {
    [NullableContextAttribute("1")]
public static ImmutableArray`1<TSymbol> Sort(ImmutableArray`1<TSymbol> symbols, ISymbolDisplayService symbolDisplayService, SemanticModel semanticModel, int position);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.Razor.Api.Extensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsRazorDocument(Document document);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.Razor.Api.IRazorDocumentOptions {
    public abstract virtual bool TryGetDocumentOption(OptionKey option, Object& value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.Razor.Api.IRazorDocumentOptionsService {
    public abstract virtual Task`1<IRazorDocumentOptions> GetOptionsForDocumentAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.INewUnitTestingIncrementalAnalyzerImplementation {
    public abstract virtual Task AnalyzeDocumentAsync(Document document, UnitTestingInvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeProjectAsync(Project project, UnitTestingInvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual void RemoveDocument(DocumentId documentId);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.INewUnitTestingIncrementalAnalyzerProviderImplementation {
    public abstract virtual INewUnitTestingIncrementalAnalyzerImplementation CreateIncrementalAnalyzer();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.IUnitTestingStackTraceServiceAccessor {
    public abstract virtual Task`1<ImmutableArray`1<UnitTestingParsedFrameWrapper>> TryParseAsync(string input, Workspace workspace, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<UnitTestingDefinitionItemWrapper>> TryFindMethodDefinitionAsync(Workspace workspace, UnitTestingParsedFrameWrapper parsedFrame, CancellationToken cancellationToken);
    public abstract virtual ValueTuple`2<Document, int> GetDocumentAndLine(Workspace workspace, UnitTestingParsedFrameWrapper parsedFrame);
    public abstract virtual Task`1<bool> TryNavigateToAsync(Workspace workspace, UnitTestingDefinitionItemWrapper definitionItem, bool showInPreviewTab, bool activateTab, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.NewUnitTestingIncrementalAnalyzerProvider : object {
    [NullableAttribute("2")]
private string _workspaceKind;
    private SolutionServices _services;
    private INewUnitTestingIncrementalAnalyzerProviderImplementation _incrementalAnalyzerProvider;
    [NullableAttribute("2")]
private IUnitTestingIncrementalAnalyzer _lazyAnalyzer;
    private NewUnitTestingIncrementalAnalyzerProvider(string workspaceKind, SolutionServices services, INewUnitTestingIncrementalAnalyzerProviderImplementation incrementalAnalyzerProvider);
    public sealed virtual IUnitTestingIncrementalAnalyzer CreateIncrementalAnalyzer();
    public void Reanalyze();
    public static NewUnitTestingIncrementalAnalyzerProvider TryRegister(string workspaceKind, SolutionServices services, string analyzerName, INewUnitTestingIncrementalAnalyzerProviderImplementation provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingDefinitionItemWrapper : ValueType {
    [CompilerGeneratedAttribute]
private DefinitionItem <UnderlyingObject>k__BackingField;
    internal DefinitionItem UnderlyingObject { get; }
    public UnitTestingDefinitionItemWrapper(DefinitionItem definition);
    [CompilerGeneratedAttribute]
internal DefinitionItem get_UnderlyingObject();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingDocumentSpan : ValueType {
    [CompilerGeneratedAttribute]
private DocumentSpan <DocumentSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private FileLinePositionSpan <Span>k__BackingField;
    public DocumentSpan DocumentSpan { get; }
    public FileLinePositionSpan Span { get; }
    internal UnitTestingDocumentSpan(DocumentSpan sourceSpan, FileLinePositionSpan span);
    [CompilerGeneratedAttribute]
public DocumentSpan get_DocumentSpan();
    [CompilerGeneratedAttribute]
public FileLinePositionSpan get_Span();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingDocumentSpan/<NavigateToAsync>d__7")]
public Task NavigateToAsync(UnitTestingNavigationOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingHotReloadService : object {
    private static ActiveStatementSpanProvider s_solutionActiveStatementSpanProvider;
    [NullableAttribute("0")]
private static ImmutableArray`1<Update> EmptyUpdate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<Diagnostic> EmptyDiagnostic;
    private IEditAndContinueService _encService;
    private DebuggingSessionId _sessionId;
    public UnitTestingHotReloadService(HostWorkspaceServices services);
    private static UnitTestingHotReloadService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingHotReloadService/<StartSessionAsync>d__8")]
public Task StartSessionAsync(Solution solution, ImmutableArray`1<string> capabilities, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingHotReloadService/<EmitSolutionUpdateAsync>d__9")]
public Task`1<ValueTuple`2<ImmutableArray`1<Update>, ImmutableArray`1<Diagnostic>>> EmitSolutionUpdateAsync(Solution solution, bool commitUpdates, CancellationToken cancellationToken);
    public void EndSession();
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingInvocationReasons : ValueType {
    public static UnitTestingInvocationReasons Empty;
    [DataMemberAttribute]
private ImmutableHashSet`1<string> _reasons;
    public static UnitTestingInvocationReasons DocumentAdded;
    public static UnitTestingInvocationReasons DocumentRemoved;
    public static UnitTestingInvocationReasons ProjectConfigurationChanged;
    public static UnitTestingInvocationReasons DocumentChanged;
    public static UnitTestingInvocationReasons AdditionalDocumentChanged;
    public static UnitTestingInvocationReasons SemanticChanged;
    public static UnitTestingInvocationReasons Reanalyze;
    public bool IsEmpty { get; }
    public UnitTestingInvocationReasons(ImmutableHashSet`1<string> reasons);
    public UnitTestingInvocationReasons(string reason);
    private static UnitTestingInvocationReasons();
    public bool get_IsEmpty();
    public bool Contains(string reason);
    public UnitTestingInvocationReasons With(UnitTestingInvocationReasons invocationReasons);
    public UnitTestingInvocationReasons With(string reason);
    public Enumerator<string> GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingNavigationOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <PreferProvisionalTab>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ActivateTab>k__BackingField;
    public bool PreferProvisionalTab { get; public set; }
    public bool ActivateTab { get; public set; }
    public UnitTestingNavigationOptions(bool PreferProvisionalTab, bool ActivateTab);
    [CompilerGeneratedAttribute]
public bool get_PreferProvisionalTab();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferProvisionalTab(bool value);
    [CompilerGeneratedAttribute]
public bool get_ActivateTab();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ActivateTab(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UnitTestingNavigationOptions left, UnitTestingNavigationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UnitTestingNavigationOptions left, UnitTestingNavigationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnitTestingNavigationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& PreferProvisionalTab, Boolean& ActivateTab);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingParsedFrameWrapper : ValueType {
    [CompilerGeneratedAttribute]
private ParsedFrame <UnderlyingObject>k__BackingField;
    internal ParsedFrame UnderlyingObject { get; }
    public UnitTestingParsedFrameWrapper(ParsedFrame parsedFrame);
    [CompilerGeneratedAttribute]
internal ParsedFrame get_UnderlyingObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingPredefinedInvocationReasons : object {
    public static string SemanticChanged;
    public static string Reanalyze;
    public static string ProjectConfigurationChanged;
    public static string HighPriority;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchHelpers : object {
    private static Char[] s_splitCharacters;
    private static UnitTestingSearchHelpers();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchHelpers/<GetSourceLocationAsync>d__1")]
public static Task`1<Nullable`1<UnitTestingDocumentSpan>> GetSourceLocationAsync(Project project, UnitTestingSearchQuery query, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchHelpers/<GetSourceLocationsAsync>d__2")]
public static Task`1<ImmutableArray`1<UnitTestingDocumentSpan>> GetSourceLocationsAsync(Project project, UnitTestingSearchQuery query, CancellationToken cancellationToken);
    private static ValueTuple`3<string, string, int> ExtractQueryData(UnitTestingSearchQuery query);
    private static string ConvertFromMetadataTypeName(string fullyQualifiedTypeName);
    private static void GetNameAndArity(string typeName, String& typeNameWithoutArity, Int32& typeArity);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchHelpers/<GetSourceLocationInProcessAsync>d__6")]
private static Task`1<Nullable`1<UnitTestingDocumentSpan>> GetSourceLocationInProcessAsync(Project project, UnitTestingSearchQuery query, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchHelpers/<GetSourceLocationsInProcessAsync>d__7")]
private static Task`1<ImmutableArray`1<UnitTestingDocumentSpan>> GetSourceLocationsInProcessAsync(Project project, UnitTestingSearchQuery query, CancellationToken cancellationToken);
    private static IAsyncEnumerable`1<UnitTestingDocumentSpan> GetSourceLocationsInProcessWorkerAsync(Project project, UnitTestingSearchQuery query, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchHelpers/<GetSourceLocationsInProcessAsync>d__9")]
private static IAsyncEnumerable`1<UnitTestingDocumentSpan> GetSourceLocationsInProcessAsync(Document document, StringComparer comparer, string container, string symbolName, int symbolArity, UnitTestingSearchQuery query, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSearchQuery : object {
    [DataMemberAttribute]
public string FullyQualifiedTypeName;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string MethodName;
    [DataMemberAttribute]
public int MethodArity;
    [DataMemberAttribute]
public int MethodParameterCount;
    [DataMemberAttribute]
public bool Strict;
    private UnitTestingSearchQuery(string fullyQualifiedTypeName, string methodName, int methodArity, int methodParameterCount, bool strict);
    public static UnitTestingSearchQuery ForType(string fullyQualifiedTypeName, bool strict);
    public static UnitTestingSearchQuery ForMethod(string fullyQualifiedTypeName, string methodName, int methodArity, int methodParameterCount, bool strict);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.IRemoteUnitTestingSearchService {
    public abstract virtual ValueTask`1<Nullable`1<UnitTestingSourceLocation>> GetSourceLocationAsync(Checksum solutionChecksum, ProjectId projectId, UnitTestingSearchQuery query, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<UnitTestingSourceLocation>> GetSourceLocationsAsync(Checksum solutionChecksum, ProjectId projectId, UnitTestingSearchQuery query, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.LegacySolutionEvents.ILegacySolutionEventsListener")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.LegacySolutionEvents.UnitTestingLegacySolutionEventsListener : object {
    private static IUnitTestingWorkCoordinator GetCoordinator(Solution solution);
    public sealed virtual bool ShouldReportChanges(SolutionServices services);
    public sealed virtual ValueTask OnWorkspaceChangedAsync(WorkspaceChangeEventArgs args, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.AbstractUnitTestingDocumentDifferenceService : object {
    [NullableContextAttribute("1")]
public sealed virtual UnitTestingDocumentDifferenceResult GetDifference(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.ExportUnitTestingIncrementalAnalyzerProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WorkspaceKinds>k__BackingField;
    public string Name { get; }
    public String[] WorkspaceKinds { get; }
    public ExportUnitTestingIncrementalAnalyzerProviderAttribute(string name, String[] workspaceKinds);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_WorkspaceKinds();
}
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingDocumentDifferenceService {
    [NullableContextAttribute("1")]
public abstract virtual UnitTestingDocumentDifferenceResult GetDifference(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingIncrementalAnalyzer {
    public abstract virtual Task AnalyzeDocumentAsync(Document document, UnitTestingInvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeProjectAsync(Project project, UnitTestingInvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual Task RemoveDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingIncrementalAnalyzerProvider {
    public abstract virtual IUnitTestingIncrementalAnalyzer CreateIncrementalAnalyzer();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerProgressReporter {
    public bool InProgress { get; }
    public abstract virtual bool get_InProgress();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProgressChanged(EventHandler`1<UnitTestingProgressData> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProgressChanged(EventHandler`1<UnitTestingProgressData> value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerRegistrationService {
    public bool HasRegisteredAnalyzerProviders { get; }
    public abstract virtual IUnitTestingWorkCoordinator Register(Solution solution);
    public abstract virtual void AddAnalyzerProvider(IUnitTestingIncrementalAnalyzerProvider provider, UnitTestingIncrementalAnalyzerProviderMetadata metadata);
    public abstract virtual bool get_HasRegisteredAnalyzerProviders();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerService {
    public abstract virtual void Reanalyze(string workspaceKind, SolutionServices services, IUnitTestingIncrementalAnalyzer analyzer, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds);
    public abstract virtual IUnitTestingSolutionCrawlerProgressReporter GetProgressReporter(Workspace workspace);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingWorkCoordinator {
    public abstract virtual void OnWorkspaceChanged(WorkspaceChangeEventArgs args);
}
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingWorkCoordinatorPriorityService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<bool> IsLowPriorityAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingDocumentDifferenceResult : object {
    [CompilerGeneratedAttribute]
private UnitTestingInvocationReasons <ChangeType>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <ChangedMember>k__BackingField;
    public UnitTestingInvocationReasons ChangeType { get; }
    public SyntaxNode ChangedMember { get; }
    public UnitTestingDocumentDifferenceResult(UnitTestingInvocationReasons changeType, SyntaxNode changedMember);
    [CompilerGeneratedAttribute]
public UnitTestingInvocationReasons get_ChangeType();
    [CompilerGeneratedAttribute]
public SyntaxNode get_ChangedMember();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingGlobalOperationAwareIdleProcessor : UnitTestingIdleProcessor {
    [NullableAttribute("2")]
private IGlobalOperationNotificationService _globalOperationNotificationService;
    public UnitTestingGlobalOperationAwareIdleProcessor(IAsynchronousOperationListener listener, IGlobalOperationNotificationService globalOperationNotificationService, TimeSpan backOffTimeSpan, CancellationToken shutdownToken);
    public virtual void Shutdown();
    private void OnGlobalOperationStarted(object sender, EventArgs e);
    private void OnGlobalOperationStopped(object sender, EventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor : object {
    private static TimeSpan s_minimumDelay;
    private object _gate;
    protected IAsynchronousOperationListener Listener;
    protected CancellationToken CancellationToken;
    protected TimeSpan BackOffTimeSpan;
    [NullableAttribute("2")]
private Task _processorTask;
    private SharedStopwatch _timeSinceLastAccess;
    private bool _isPaused_doNotAccessDirectly;
    public Task AsyncProcessorTask { get; }
    protected UnitTestingIdleProcessor(IAsynchronousOperationListener listener, TimeSpan backOffTimeSpan, CancellationToken cancellationToken);
    private static UnitTestingIdleProcessor();
    protected abstract virtual Task WaitAsync(CancellationToken cancellationToken);
    protected abstract virtual Task ExecuteAsync();
    protected abstract virtual void OnPaused();
    protected void Start();
    protected void UpdateLastAccessTime();
    protected bool GetIsPaused();
    protected bool ShouldContinueToBackOff();
    protected void SetIsPaused(bool isPaused);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor/<WaitForIdleAsync>d__17")]
protected Task`1<bool> WaitForIdleAsync(IExpeditableDelaySource expeditableDelaySource);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIdleProcessor/<ProcessAsync>d__18")]
private Task ProcessAsync();
    public virtual Task get_AsyncProcessorTask();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingIncrementalAnalyzerProviderMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <WorkspaceKinds>k__BackingField;
    public string Name { get; }
    public IReadOnlyList`1<string> WorkspaceKinds { get; }
    public UnitTestingIncrementalAnalyzerProviderMetadata(string name, IReadOnlyList`1<string> workspaceKinds);
    public UnitTestingIncrementalAnalyzerProviderMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_WorkspaceKinds();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingProgressData : ValueType {
    [CompilerGeneratedAttribute]
private UnitTestingProgressStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PendingItemCount>k__BackingField;
    public UnitTestingProgressStatus Status { get; }
    public Nullable`1<int> PendingItemCount { get; }
    public UnitTestingProgressData(UnitTestingProgressStatus type, Nullable`1<int> pendingItemCount);
    [CompilerGeneratedAttribute]
public UnitTestingProgressStatus get_Status();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PendingItemCount();
}
internal enum Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingProgressStatus : Enum {
    public int value__;
    public static UnitTestingProgressStatus Started;
    public static UnitTestingProgressStatus Paused;
    public static UnitTestingProgressStatus PendingItemCountUpdated;
    public static UnitTestingProgressStatus Evaluating;
    public static UnitTestingProgressStatus Stopped;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerLogger : object {
    private static string Id;
    private static string Kind;
    private static string Analyzer;
    private static string DocumentCount;
    private static string Languages;
    private static string HighPriority;
    private static string Enabled;
    private static string AnalyzerCount;
    private static string PersistentStorage;
    private static string GlobalOperation;
    private static string HigherPriority;
    private static string LowerPriority;
    private static string TopLevel;
    private static string MemberLevel;
    private static string NewWorkItem;
    private static string UpdateWorkItem;
    private static string ProjectEnqueue;
    private static string ResetStates;
    private static string ProjectNotExist;
    private static string DocumentNotExist;
    private static string ProcessProject;
    private static string OpenDocument;
    private static string CloseDocument;
    private static string SolutionHash;
    private static string ProcessDocument;
    private static string ProcessDocumentCancellation;
    private static string ProcessProjectCancellation;
    private static string ActiveFileEnqueue;
    private static string ActiveFileProcessDocument;
    private static string ActiveFileProcessDocumentCancellation;
    public static void LogRegistration(int correlationId, string workspaceKind);
    public static void LogUnregistration(int correlationId);
    public static void LogReanalyze(int correlationId, IUnitTestingIncrementalAnalyzer analyzer, int documentCount, string languages);
    public static void LogAnalyzers(int correlationId, string workspaceKind, ImmutableArray`1<IUnitTestingIncrementalAnalyzer> reordered, bool onlyHighPriorityAnalyzer);
    private static void LogAnalyzersWorker(FunctionId analyzersId, FunctionId analyzerId, int correlationId, string workspaceKind, ImmutableArray`1<IUnitTestingIncrementalAnalyzer> reordered);
    public static void LogWorkCoordinatorShutdownTimeout(int correlationId);
    public static void LogWorkspaceEvent(CountLogAggregator`1<WorkspaceChangeKind> logAggregator, WorkspaceChangeKind kind);
    public static void LogWorkCoordinatorShutdown(int correlationId, CountLogAggregator`1<WorkspaceChangeKind> logAggregator);
    public static void LogGlobalOperation(CountLogAggregator`1<object> logAggregator);
    public static void LogActiveFileEnqueue(CountLogAggregator`1<object> logAggregator);
    public static void LogWorkItemEnqueue(CountLogAggregator`1<object> logAggregator, ProjectId _);
    public static void LogWorkItemEnqueue(CountLogAggregator`1<object> logAggregator, string language, DocumentId documentId, UnitTestingInvocationReasons reasons, bool lowPriority, SyntaxPath activeMember, bool added);
    public static void LogHigherPriority(CountLogAggregator`1<object> logAggregator, Guid documentId);
    public static void LogResetStates(CountLogAggregator`1<object> logAggregator);
    public static void LogIncrementalAnalyzerProcessorStatistics(int correlationId, Solution solution, CountLogAggregator`1<object> logAggregator);
    private static int GetSolutionHash(Solution solution);
    public static void LogProcessCloseDocument(CountLogAggregator`1<object> logAggregator, Guid documentId);
    public static void LogProcessOpenDocument(CountLogAggregator`1<object> logAggregator, Guid documentId);
    public static void LogProcessActiveFileDocument(CountLogAggregator`1<object> logAggregator, Guid _, bool processed);
    public static void LogProcessDocument(CountLogAggregator`1<object> logAggregator, Guid documentId, bool processed);
    public static void LogProcessDocumentNotExist(CountLogAggregator`1<object> logAggregator);
    public static void LogProcessProject(CountLogAggregator`1<object> logAggregator, Guid projectId, bool processed);
    public static void LogProcessProjectNotExist(CountLogAggregator`1<object> logAggregator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.IUnitTestingSolutionCrawlerRegistrationService", "Host")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService : object {
    private static string Default;
    private object _gate;
    private UnitTestingSolutionCrawlerProgressReporter _progressReporter;
    private IAsynchronousOperationListener _listener;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<string, SolutionServices>, UnitTestingWorkCoordinator> _documentWorkCoordinatorMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ImmutableArray`1<Lazy`2<IUnitTestingIncrementalAnalyzerProvider, UnitTestingIncrementalAnalyzerProviderMetadata>>> _analyzerProviders;
    private Solution _lastReportedSolution;
    public static string EnqueueItem;
    public bool HasRegisteredAnalyzerProviders { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public UnitTestingSolutionCrawlerRegistrationService(IEnumerable`1<Lazy`2<IUnitTestingIncrementalAnalyzerProvider, UnitTestingIncrementalAnalyzerProviderMetadata>> analyzerProviders, IAsynchronousOperationListenerProvider listenerProvider);
    public sealed virtual IUnitTestingWorkCoordinator Register(Solution solution);
    public sealed virtual bool get_HasRegisteredAnalyzerProviders();
    public sealed virtual void AddAnalyzerProvider(IUnitTestingIncrementalAnalyzerProvider provider, UnitTestingIncrementalAnalyzerProviderMetadata metadata);
    public void Reanalyze(string workspaceKind, SolutionServices services, IUnitTestingIncrementalAnalyzer analyzer, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerRegistrationService/<GetAnalyzerProviders>d__15")]
private IEnumerable`1<Lazy`2<IUnitTestingIncrementalAnalyzerProvider, UnitTestingIncrementalAnalyzerProviderMetadata>> GetAnalyzerProviders(string workspaceKind);
    private static bool TryGetProvider(string kind, ImmutableArray`1<Lazy`2<IUnitTestingIncrementalAnalyzerProvider, UnitTestingIncrementalAnalyzerProviderMetadata>> lazyProviders, Lazy`2& lazyProvider);
    [ConditionalAttribute("DEBUG")]
private static void AssertAnalyzerProviders(ImmutableDictionary`2<string, ImmutableArray`1<Lazy`2<IUnitTestingIncrementalAnalyzerProvider, UnitTestingIncrementalAnalyzerProviderMetadata>>> analyzerProviders);
    private static bool IsDefaultProvider(UnitTestingIncrementalAnalyzerProviderMetadata providerMetadata);
    internal TestAccessor GetTestAccessor();
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.SolutionCrawler.UnitTestingSolutionCrawlerTimeSpan : object {
    public static TimeSpan AllFilesWorkerBackOff;
    public static TimeSpan EntireProjectWorkerBackOff;
    public static TimeSpan SemanticChangeBackOff;
    public static TimeSpan ProjectPropagationBackOff;
    public static TimeSpan PreviewBackOff;
    private static UnitTestingSolutionCrawlerTimeSpan();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingSourceLocation : ValueType {
    [DataMemberAttribute]
public DocumentIdSpan DocumentIdSpan;
    [DataMemberAttribute]
public FileLinePositionSpan Span;
    public UnitTestingSourceLocation(DocumentIdSpan documentIdSpan, FileLinePositionSpan span);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingSourceLocation/<TryRehydrateAsync>d__3")]
public Task`1<Nullable`1<UnitTestingDocumentSpan>> TryRehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingStackTraceServiceAccessor : object {
    private IStackTraceExplorerService _stackTraceExplorerService;
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public UnitTestingStackTraceServiceAccessor(IStackTraceExplorerService stackTraceExplorerService);
    public sealed virtual ValueTuple`2<Document, int> GetDocumentAndLine(Workspace workspace, UnitTestingParsedFrameWrapper parsedFrame);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingStackTraceServiceAccessor/<TryFindMethodDefinitionAsync>d__3")]
public sealed virtual Task`1<Nullable`1<UnitTestingDefinitionItemWrapper>> TryFindMethodDefinitionAsync(Workspace workspace, UnitTestingParsedFrameWrapper parsedFrame, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingStackTraceServiceAccessor/<TryParseAsync>d__4")]
public sealed virtual Task`1<ImmutableArray`1<UnitTestingParsedFrameWrapper>> TryParseAsync(string input, Workspace workspace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingStackTraceServiceAccessor/<TryNavigateToAsync>d__5")]
public sealed virtual Task`1<bool> TryNavigateToAsync(Workspace workspace, UnitTestingDefinitionItemWrapper definitionItem, bool showInPreviewTab, bool activateTab, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.IUnitTestingStackTraceServiceAccessor", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingStackTraceServiceAccessorFactory : object {
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptCommentSelectionServiceImplementation {
    public abstract virtual Task`1<VSTypeScriptCommentSelectionInfo> GetInfoAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> FormatAsync(Document document, ImmutableArray`1<TextSpan> changes, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptDiagnosticAnalyzerImplementation {
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeDocumentSyntaxAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeDocumentSemanticsAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptDiagnosticAnalyzerService {
    public abstract virtual void Reanalyze(Workspace workspace, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptFormattingServiceImplementation {
    public abstract virtual Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, VSTypeScriptIndentationOptions options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigableItem {
    public Glyph Glyph { get; }
    public ImmutableArray`1<TaggedText> DisplayTaggedParts { get; }
    public bool DisplayFileLocation { get; }
    public bool IsImplicitlyDeclared { get; }
    [NullableAttribute("1")]
public Document Document { get; }
    public TextSpan SourceSpan { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IVSTypeScriptNavigableItem> ChildItems { get; }
    public abstract virtual Glyph get_Glyph();
    public abstract virtual ImmutableArray`1<TaggedText> get_DisplayTaggedParts();
    public abstract virtual bool get_DisplayFileLocation();
    public abstract virtual bool get_IsImplicitlyDeclared();
    [NullableContextAttribute("1")]
public abstract virtual Document get_Document();
    public abstract virtual TextSpan get_SourceSpan();
    public abstract virtual ImmutableArray`1<IVSTypeScriptNavigableItem> get_ChildItems();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigateToSearchResult {
    public string AdditionalInformation { get; }
    public string Kind { get; }
    public VSTypeScriptNavigateToMatchKind MatchKind { get; }
    public bool IsCaseSensitive { get; }
    public string Name { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<TextSpan> NameMatchSpans { get; }
    public string SecondarySort { get; }
    public string Summary { get; }
    public IVSTypeScriptNavigableItem NavigableItem { get; }
    public abstract virtual string get_AdditionalInformation();
    public abstract virtual string get_Kind();
    public abstract virtual VSTypeScriptNavigateToMatchKind get_MatchKind();
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual string get_Name();
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<TextSpan> get_NameMatchSpans();
    public abstract virtual string get_SecondarySort();
    public abstract virtual string get_Summary();
    public abstract virtual IVSTypeScriptNavigableItem get_NavigableItem();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptNavigateToSearchService {
    public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    public abstract virtual IImmutableSet`1<string> get_KindsProvided();
    public abstract virtual bool get_CanFilter();
    public abstract virtual Task`1<ImmutableArray`1<IVSTypeScriptNavigateToSearchResult>> SearchProjectAsync(Project project, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<IVSTypeScriptNavigateToSearchResult>> SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptTaskListServiceImplementation {
    public abstract virtual Task`1<ImmutableArray`1<VSTypeScriptTaskListItem>> GetTaskListItemsAsync(Document document, ImmutableArray`1<VSTypeScriptTaskListItemDescriptorWrapper> value, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[ObsoleteAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptCommentSelectionInfo : ValueType {
    internal CommentSelectionInfo UnderlyingObject;
    internal VSTypeScriptCommentSelectionInfo(CommentSelectionInfo underlyingObject);
    [NullableContextAttribute("1")]
public VSTypeScriptCommentSelectionInfo(bool supportsSingleLineComment, bool supportsBlockComment, string singleLineCommentString, string blockCommentStartString, string blockCommentEndString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptCompletionProvider : CompletionProvider {
    public sealed virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger, OptionSet options);
    internal sealed virtual bool ShouldTriggerCompletion(LanguageServices languageServices, SourceText text, int caretPosition, CompletionTrigger trigger, CompletionOptions options, OptionSet passThroughOptions);
    protected abstract virtual bool ShouldTriggerCompletionImpl(SourceText text, int caretPosition, CompletionTrigger trigger, bool triggerOnTypingLetters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptCompletionServiceWithProviders : CompletionService {
    internal VSTypeScriptCompletionServiceWithProviders(Workspace workspace);
    internal sealed virtual CompletionRules GetRules(CompletionOptions options);
    internal abstract virtual CompletionRules GetRulesImpl();
    internal sealed virtual void FilterItems(Document document, IReadOnlyList`1<MatchResult> matchResults, string filterText, IList`1<MatchResult> builder);
    internal virtual void FilterItemsImpl(Document document, IReadOnlyList`1<MatchResult> matchResults, string filterText, IList`1<MatchResult> builder);
}
[ObsoleteAttribute]
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDefinitionItemBase : DefinitionItem {
    protected VSTypeScriptDefinitionItemBase(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDiagnosticData : ValueType {
    private DiagnosticData _data;
    public DiagnosticSeverity Severity { get; }
    [NullableAttribute("2")]
public string Message { get; }
    public string Id { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> CustomTags { get; }
    internal VSTypeScriptDiagnosticData(DiagnosticData data);
    public DiagnosticSeverity get_Severity();
    [NullableContextAttribute("2")]
public string get_Message();
    public string get_Id();
    public ImmutableArray`1<string> get_CustomTags();
    [ObsoleteAttribute("Use overload that only takes a SourceText")]
public LinePositionSpan GetLinePositionSpan(SourceText sourceText, bool useMapped);
    public LinePositionSpan GetLinePositionSpan(SourceText sourceText);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDiagnosticsUpdatedArgsWrapper : ValueType {
    [NullableAttribute("1")]
internal DiagnosticsUpdatedArgs UnderlyingObject;
    public Solution Solution { get; }
    public DocumentId DocumentId { get; }
    [NullableContextAttribute("1")]
public VSTypeScriptDiagnosticsUpdatedArgsWrapper(DiagnosticsUpdatedArgs underlyingObject);
    public Solution get_Solution();
    public DocumentId get_DocumentId();
}
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDocumentHighlightsServiceBase : object {
    [NullableContextAttribute("1")]
protected abstract virtual Task`1<ImmutableArray`1<DocumentHighlights>> GetDocumentHighlightsAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override Task`1<ImmutableArray`1<DocumentHighlights>> Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService.GetDocumentHighlightsAsync(Document document, int position, IImmutableSet`1<Document> documentsToSearch, HighlightingOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDocumentNavigationServiceWrapper : ValueType {
    private IDocumentNavigationService _underlyingObject;
    private IWorkspaceThreadingServiceProvider _threadingProvider;
    public VSTypeScriptDocumentNavigationServiceWrapper(IDocumentNavigationService underlyingObject, IWorkspaceThreadingServiceProvider threadingProvider);
    public static VSTypeScriptDocumentNavigationServiceWrapper Create(Workspace workspace);
    [ObsoleteAttribute("Call overload that takes a CancellationToken", "False")]
public bool TryNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, OptionSet options);
    [ObsoleteAttribute("Call overload that doesn't take options", "False")]
public bool TryNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, OptionSet options, CancellationToken cancellationToken);
    public bool TryNavigateToPosition(Workspace workspace, DocumentId documentId, int position, int virtualSpace, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptGlyph : Enum {
    public int value__;
    public static VSTypeScriptGlyph None;
    public static VSTypeScriptGlyph Assembly;
    public static VSTypeScriptGlyph BasicFile;
    public static VSTypeScriptGlyph BasicProject;
    public static VSTypeScriptGlyph ClassPublic;
    public static VSTypeScriptGlyph ClassProtected;
    public static VSTypeScriptGlyph ClassPrivate;
    public static VSTypeScriptGlyph ClassInternal;
    public static VSTypeScriptGlyph CSharpFile;
    public static VSTypeScriptGlyph CSharpProject;
    public static VSTypeScriptGlyph ConstantPublic;
    public static VSTypeScriptGlyph ConstantProtected;
    public static VSTypeScriptGlyph ConstantPrivate;
    public static VSTypeScriptGlyph ConstantInternal;
    public static VSTypeScriptGlyph DelegatePublic;
    public static VSTypeScriptGlyph DelegateProtected;
    public static VSTypeScriptGlyph DelegatePrivate;
    public static VSTypeScriptGlyph DelegateInternal;
    public static VSTypeScriptGlyph EnumPublic;
    public static VSTypeScriptGlyph EnumProtected;
    public static VSTypeScriptGlyph EnumPrivate;
    public static VSTypeScriptGlyph EnumInternal;
    public static VSTypeScriptGlyph EnumMemberPublic;
    public static VSTypeScriptGlyph EnumMemberProtected;
    public static VSTypeScriptGlyph EnumMemberPrivate;
    public static VSTypeScriptGlyph EnumMemberInternal;
    public static VSTypeScriptGlyph Error;
    public static VSTypeScriptGlyph StatusInformation;
    public static VSTypeScriptGlyph EventPublic;
    public static VSTypeScriptGlyph EventProtected;
    public static VSTypeScriptGlyph EventPrivate;
    public static VSTypeScriptGlyph EventInternal;
    public static VSTypeScriptGlyph ExtensionMethodPublic;
    public static VSTypeScriptGlyph ExtensionMethodProtected;
    public static VSTypeScriptGlyph ExtensionMethodPrivate;
    public static VSTypeScriptGlyph ExtensionMethodInternal;
    public static VSTypeScriptGlyph FieldPublic;
    public static VSTypeScriptGlyph FieldProtected;
    public static VSTypeScriptGlyph FieldPrivate;
    public static VSTypeScriptGlyph FieldInternal;
    public static VSTypeScriptGlyph InterfacePublic;
    public static VSTypeScriptGlyph InterfaceProtected;
    public static VSTypeScriptGlyph InterfacePrivate;
    public static VSTypeScriptGlyph InterfaceInternal;
    public static VSTypeScriptGlyph Intrinsic;
    public static VSTypeScriptGlyph Keyword;
    public static VSTypeScriptGlyph Label;
    public static VSTypeScriptGlyph Local;
    public static VSTypeScriptGlyph Namespace;
    public static VSTypeScriptGlyph MethodPublic;
    public static VSTypeScriptGlyph MethodProtected;
    public static VSTypeScriptGlyph MethodPrivate;
    public static VSTypeScriptGlyph MethodInternal;
    public static VSTypeScriptGlyph ModulePublic;
    public static VSTypeScriptGlyph ModuleProtected;
    public static VSTypeScriptGlyph ModulePrivate;
    public static VSTypeScriptGlyph ModuleInternal;
    public static VSTypeScriptGlyph OpenFolder;
    public static VSTypeScriptGlyph Operator;
    public static VSTypeScriptGlyph Parameter;
    public static VSTypeScriptGlyph PropertyPublic;
    public static VSTypeScriptGlyph PropertyProtected;
    public static VSTypeScriptGlyph PropertyPrivate;
    public static VSTypeScriptGlyph PropertyInternal;
    public static VSTypeScriptGlyph RangeVariable;
    public static VSTypeScriptGlyph Reference;
    public static VSTypeScriptGlyph StructurePublic;
    public static VSTypeScriptGlyph StructureProtected;
    public static VSTypeScriptGlyph StructurePrivate;
    public static VSTypeScriptGlyph StructureInternal;
    public static VSTypeScriptGlyph TypeParameter;
    public static VSTypeScriptGlyph Snippet;
    public static VSTypeScriptGlyph CompletionWarning;
    public static VSTypeScriptGlyph AddReference;
    public static VSTypeScriptGlyph NuGet;
    public static VSTypeScriptGlyph TargetTypeMatch;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptIndentationOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <UseSpaces>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TabSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentSize>k__BackingField;
    public bool UseSpaces { get; public set; }
    public int TabSize { get; public set; }
    public int IndentSize { get; public set; }
    public VSTypeScriptIndentationOptions(bool UseSpaces, int TabSize, int IndentSize);
    [CompilerGeneratedAttribute]
public bool get_UseSpaces();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseSpaces(bool value);
    [CompilerGeneratedAttribute]
public int get_TabSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TabSize(int value);
    [CompilerGeneratedAttribute]
public int get_IndentSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentSize(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VSTypeScriptIndentationOptions left, VSTypeScriptIndentationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VSTypeScriptIndentationOptions left, VSTypeScriptIndentationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VSTypeScriptIndentationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& UseSpaces, Int32& TabSize, Int32& IndentSize);
}
internal enum Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptNavigateToMatchKind : Enum {
    public int value__;
    public static VSTypeScriptNavigateToMatchKind Exact;
    public static VSTypeScriptNavigateToMatchKind Prefix;
    public static VSTypeScriptNavigateToMatchKind Substring;
    public static VSTypeScriptNavigateToMatchKind Regular;
    public static VSTypeScriptNavigateToMatchKind None;
    public static VSTypeScriptNavigateToMatchKind CamelCaseExact;
    public static VSTypeScriptNavigateToMatchKind CamelCasePrefix;
    public static VSTypeScriptNavigateToMatchKind CamelCaseNonContiguousPrefix;
    public static VSTypeScriptNavigateToMatchKind CamelCaseSubstring;
    public static VSTypeScriptNavigateToMatchKind CamelCaseNonContiguousSubstring;
    public static VSTypeScriptNavigateToMatchKind Fuzzy;
}
internal abstract class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptSignatureHelpProviderBase : object {
    [NullableContextAttribute("1")]
private sealed virtual override Task`1<SignatureHelpItems> Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider.GetItemsAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    public abstract virtual bool IsTriggerCharacter(char ch);
    public abstract virtual bool IsRetriggerCharacter(char ch);
    [NullableContextAttribute("1")]
protected abstract virtual Task`1<SignatureHelpItems> GetItemsAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptTaskListItem : ValueType {
    [CompilerGeneratedAttribute]
private VSTypeScriptTaskListItemDescriptorWrapper <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public VSTypeScriptTaskListItemDescriptorWrapper Descriptor { get; }
    public string Message { get; }
    public int Position { get; }
    public VSTypeScriptTaskListItem(VSTypeScriptTaskListItemDescriptorWrapper descriptor, string message, int position);
    [CompilerGeneratedAttribute]
public VSTypeScriptTaskListItemDescriptorWrapper get_Descriptor();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public int get_Position();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptTaskListItemDescriptorWrapper : ValueType {
    internal TaskListItemDescriptor Descriptor;
    [NullableAttribute("1")]
public string Text { get; }
    internal VSTypeScriptTaskListItemDescriptorWrapper(TaskListItemDescriptor descriptor);
    [NullableContextAttribute("1")]
public string get_Text();
    public static ImmutableArray`1<VSTypeScriptTaskListItemDescriptorWrapper> Parse(ImmutableArray`1<string> items);
}
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.IVSTypeScriptDiagnosticAnalyzerService")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptAnalyzerService : object {
    [NullableAttribute("1")]
private IDiagnosticAnalyzerService _service;
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VSTypeScriptAnalyzerService(IDiagnosticAnalyzerService service);
    [NullableContextAttribute("2")]
public sealed virtual void Reanalyze(Workspace workspace, IEnumerable`1<ProjectId> projectIds, IEnumerable`1<DocumentId> documentIds, bool highPriority);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CommentSelection.ICommentSelectionService", "TypeScript", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptCommentSelectionService : object {
    public sealed virtual CommentSelectionInfo GetInfo();
}
[SharedAttribute]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptDiagnosticAnalyzerLanguageService", "TypeScript", "Default")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptDiagnosticAnalyzerLanguageService : object {
    [NullableAttribute("2")]
internal IVSTypeScriptDiagnosticAnalyzerImplementation Implementation;
    [NullableContextAttribute("2")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VSTypeScriptDiagnosticAnalyzerLanguageService(IVSTypeScriptDiagnosticAnalyzerImplementation implementation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("TypeScript", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptDocumentDiagnosticAnalyzer : DocumentDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeSyntaxAsync(Document document, CancellationToken cancellationToken);
    public virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeSemanticsAsync(Document document, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Formatting.IFormattingService", "TypeScript", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptFormattingService : object {
    [NullableAttribute("1")]
private IVSTypeScriptFormattingServiceImplementation _impl;
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VSTypeScriptFormattingService(IVSTypeScriptFormattingServiceImplementation impl);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, LineFormattingOptions lineFormattingOptions, SyntaxFormattingOptions syntaxFormattingOptions, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptGlyphHelpers : object {
    public static VSTypeScriptGlyph ConvertFrom(Glyph glyph);
    public static Glyph ConvertTo(VSTypeScriptGlyph glyph);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptNavigableItemWrapper : object {
    private IVSTypeScriptNavigableItem _navigableItem;
    private NavigableDocument _navigableDocument;
    public Glyph Glyph { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<TaggedText> DisplayTaggedParts { get; }
    public bool DisplayFileLocation { get; }
    public bool IsImplicitlyDeclared { get; }
    public NavigableDocument Document { get; }
    public TextSpan SourceSpan { get; }
    public bool IsStale { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<INavigableItem> ChildItems { get; }
    public VSTypeScriptNavigableItemWrapper(IVSTypeScriptNavigableItem navigableItem);
    public sealed virtual Glyph get_Glyph();
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<TaggedText> get_DisplayTaggedParts();
    public sealed virtual bool get_DisplayFileLocation();
    public sealed virtual bool get_IsImplicitlyDeclared();
    public sealed virtual NavigableDocument get_Document();
    public sealed virtual TextSpan get_SourceSpan();
    public sealed virtual bool get_IsStale();
    public sealed virtual ImmutableArray`1<INavigableItem> get_ChildItems();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService", "TypeScript", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptNavigateToSearchService : object {
    [NullableAttribute("2")]
private IVSTypeScriptNavigateToSearchService _searchService;
    public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    [NullableContextAttribute("2")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VSTypeScriptNavigateToSearchService(IVSTypeScriptNavigateToSearchService searchService);
    public sealed virtual IImmutableSet`1<string> get_KindsProvided();
    public sealed virtual bool get_CanFilter();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptNavigateToSearchService/<SearchDocumentAsync>d__6")]
public sealed virtual Task SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptNavigateToSearchService/<SearchProjectsAsync>d__7")]
public sealed virtual Task SearchProjectsAsync(Solution solution, ImmutableArray`1<Project> projects, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, Document activeDocument, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
    private static INavigateToSearchResult Convert(IVSTypeScriptNavigateToSearchResult result);
}
[DiagnosticAnalyzerAttribute("TypeScript", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptProjectDiagnosticAnalyzer : ProjectDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.TaskList.ITaskListService", "TypeScript", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptTaskListService : object {
    [NullableAttribute("2")]
private IVSTypeScriptTaskListServiceImplementation _impl;
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VSTypeScriptTaskListService(IVSTypeScriptTaskListServiceImplementation impl);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptTaskListService/<GetTaskListItemsAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<TaskListItem>> GetTaskListItemsAsync(Document document, ImmutableArray`1<TaskListItemDescriptor> descriptors, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.VSTypeScriptWellKnownDiagnosticCustomTags : object {
    [NullableAttribute("1")]
public static string DoesNotSupportF1Help;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<ValueTask`1<ImmutableArray`1<string>>> <capabilitiesProvider>P;
    private static ActiveStatementSpanProvider s_solutionActiveStatementSpanProvider;
    private IEditAndContinueService _encService;
    private DebuggingSessionId _sessionId;
    public WatchHotReloadService(SolutionServices services, Func`1<ValueTask`1<ImmutableArray`1<string>>> capabilitiesProvider);
    public WatchHotReloadService(HostWorkspaceServices services, ImmutableArray`1<string> capabilities);
    private static WatchHotReloadService();
    private DebuggingSessionId GetDebuggingSession();
    private static ImmutableArray`1<string> AddImplicitDotNetCapabilities(ImmutableArray`1<string> capabilities);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService/<StartSessionAsync>d__11")]
public Task StartSessionAsync(Solution solution, CancellationToken cancellationToken);
    public void CapabilitiesChanged();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService/<EmitSolutionUpdateAsync>d__13")]
public Task`1<ValueTuple`2<ImmutableArray`1<Update>, ImmutableArray`1<Diagnostic>>> EmitSolutionUpdateAsync(Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.Watch.Api.WatchHotReloadService/<GetUpdatesAsync>d__14")]
public Task`1<Updates> GetUpdatesAsync(Solution solution, Func`2<Project, bool> isRunningProject, CancellationToken cancellationToken);
    public void EndSession();
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ExtractClass.AbstractExtractClassRefactoringProvider : CodeRefactoringProvider {
    [NullableAttribute("2")]
private IExtractClassOptionsService _optionsService;
    [NullableContextAttribute("2")]
protected AbstractExtractClassRefactoringProvider(IExtractClassOptionsService service);
    protected abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedNodesAsync(CodeRefactoringContext context);
    protected abstract virtual Task`1<SyntaxNode> GetSelectedClassDeclarationAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.AbstractExtractClassRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.AbstractExtractClassRefactoringProvider/<TryGetMemberActionAsync>d__5")]
private Task`1<ValueTuple`2<ExtractClassWithDialogCodeAction, bool>> TryGetMemberActionAsync(CodeRefactoringContext context, IExtractClassOptionsService optionsService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.AbstractExtractClassRefactoringProvider/<TryGetClassActionAsync>d__6")]
private Task`1<ExtractClassWithDialogCodeAction> TryGetClassActionAsync(CodeRefactoringContext context, IExtractClassOptionsService optionsService);
    private static bool HasBaseType(INamedTypeSymbol containingType);
}
internal class Microsoft.CodeAnalysis.ExtractClass.ExtractClassMemberAnalysisResult : object {
    [CompilerGeneratedAttribute]
private ISymbol <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MakeAbstract>k__BackingField;
    public ISymbol Member { get; }
    public bool MakeAbstract { get; }
    public ExtractClassMemberAnalysisResult(ISymbol member, bool makeAbstract);
    [CompilerGeneratedAttribute]
public ISymbol get_Member();
    [CompilerGeneratedAttribute]
public bool get_MakeAbstract();
}
internal class Microsoft.CodeAnalysis.ExtractClass.ExtractClassOptions : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SameFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ExtractClassMemberAnalysisResult> <MemberAnalysisResults>k__BackingField;
    public string FileName { get; }
    public string TypeName { get; }
    public bool SameFile { get; }
    public ImmutableArray`1<ExtractClassMemberAnalysisResult> MemberAnalysisResults { get; }
    public ExtractClassOptions(string fileName, string typeName, bool sameFile, ImmutableArray`1<ExtractClassMemberAnalysisResult> memberAnalysisResults);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public bool get_SameFile();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ExtractClassMemberAnalysisResult> get_MemberAnalysisResults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction : CodeActionWithOptions {
    private Document _document;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISymbol> _selectedMembers;
    private INamedTypeSymbol _selectedType;
    private SyntaxNode _selectedTypeDeclarationNode;
    private CleanCodeGenerationOptionsProvider _fallbackOptions;
    private IExtractClassOptionsService _service;
    private CodeActionPriority _priority;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    public TextSpan Span { get; }
    public string Title { get; }
    public ExtractClassWithDialogCodeAction(Document document, TextSpan span, IExtractClassOptionsService service, INamedTypeSymbol selectedType, SyntaxNode selectedTypeDeclarationNode, CleanCodeGenerationOptionsProvider fallbackOptions, ImmutableArray`1<ISymbol> selectedMembers);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    public virtual string get_Title();
    protected sealed virtual CodeActionPriority ComputePriority();
    [NullableContextAttribute("2")]
public virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction/<ComputeOperationsAsync>d__15")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction/<PullMembersUpAsync>d__16")]
private Task`1<Solution> PullMembersUpAsync(Solution solution, INamedTypeSymbol newType, AnnotatedSymbolMapping symbolMapping, ImmutableArray`1<ExtractClassMemberAnalysisResult> memberAnalysisResults, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction/<GetNewTypeSymbolAsync>d__17")]
private static Task`1<INamedTypeSymbol> GetNewTypeSymbolAsync(Document document, SyntaxAnnotation typeAnnotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractClass.ExtractClassWithDialogCodeAction/<GetSolutionWithBaseAddedAsync>d__18")]
private static Task`1<Solution> GetSolutionWithBaseAddedAsync(Solution solution, AnnotatedSymbolMapping symbolMapping, INamedTypeSymbol newType, ImmutableArray`1<ExtractClassMemberAnalysisResult> memberAnalysisResults, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ExtractClass.IExtractClassOptionsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ExtractClassOptions> GetExtractClassOptionsAsync(Document document, INamedTypeSymbol originalType, ImmutableArray`1<ISymbol> selectedMembers, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService : object {
    protected abstract virtual Task`1<SyntaxNode> GetTypeDeclarationAsync(Document document, int position, TypeDiscoveryRule typeDiscoveryRule, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Solution> UpdateMembersWithExplicitImplementationsAsync(Solution unformattedSolution, IReadOnlyList`1<DocumentId> documentId, INamedTypeSymbol extractedInterfaceSymbol, INamedTypeSymbol typeToExtractFrom, IEnumerable`1<ISymbol> includedMembers, ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationAnnotationMap, CancellationToken cancellationToken);
    internal abstract virtual string GetContainingNamespaceDisplay(INamedTypeSymbol typeSymbol, CompilationOptions compilationOptions);
    internal abstract virtual bool ShouldIncludeAccessibilityModifier(SyntaxNode typeNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<GetExtractInterfaceCodeActionAsync>d__4")]
public Task`1<ImmutableArray`1<ExtractInterfaceCodeAction>> GetExtractInterfaceCodeActionAsync(Document document, TextSpan span, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceAsync>d__5")]
public Task`1<ExtractInterfaceResult> ExtractInterfaceAsync(Document documentWithTypeToExtractFrom, int position, CleanCodeGenerationOptionsProvider fallbackOptions, Action`2<string, NotificationSeverity> errorHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<AnalyzeTypeAtPositionAsync>d__6")]
public Task`1<ExtractInterfaceTypeAnalysisResult> AnalyzeTypeAtPositionAsync(Document document, int position, TypeDiscoveryRule typeDiscoveryRule, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceFromAnalyzedTypeAsync>d__7")]
public Task`1<ExtractInterfaceResult> ExtractInterfaceFromAnalyzedTypeAsync(ExtractInterfaceTypeAnalysisResult refactoringResult, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceFromAnalyzedTypeAsync>d__8")]
public Task`1<ExtractInterfaceResult> ExtractInterfaceFromAnalyzedTypeAsync(ExtractInterfaceTypeAnalysisResult refactoringResult, ExtractInterfaceOptionsResult extractInterfaceOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceToNewFileAsync>d__9")]
private Task`1<ExtractInterfaceResult> ExtractInterfaceToNewFileAsync(Solution solution, string containingNamespaceDisplay, INamedTypeSymbol extractedInterfaceSymbol, ExtractInterfaceTypeAnalysisResult refactoringResult, ExtractInterfaceOptionsResult extractInterfaceOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<ExtractInterfaceToSameFileAsync>d__10")]
private Task`1<ExtractInterfaceResult> ExtractInterfaceToSameFileAsync(Solution solution, ExtractInterfaceTypeAnalysisResult refactoringResult, INamedTypeSymbol extractedInterfaceSymbol, ExtractInterfaceOptionsResult extractInterfaceOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<GetExtractInterfaceOptionsAsync>d__11")]
internal static Task`1<ExtractInterfaceOptionsResult> GetExtractInterfaceOptionsAsync(Document document, INamedTypeSymbol type, IEnumerable`1<ISymbol> extractableMembers, string containingNamespace, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<GetFormattedSolutionAsync>d__12")]
private static Task`1<Solution> GetFormattedSolutionAsync(Solution unformattedSolution, IEnumerable`1<DocumentId> documentIds, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService/<GetSolutionWithOriginalTypeUpdatedAsync>d__13")]
private Task`1<Solution> GetSolutionWithOriginalTypeUpdatedAsync(Solution solution, ImmutableArray`1<DocumentId> documentIds, SyntaxAnnotation typeNodeAnnotation, INamedTypeSymbol typeToExtractFrom, INamedTypeSymbol extractedInterfaceSymbol, IEnumerable`1<ISymbol> includedMembers, ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationAnnotationMap, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> CreateInterfaceMembers(IEnumerable`1<ISymbol> includedMembers);
    internal virtual bool IsExtractableMember(ISymbol m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceCodeAction : CodeActionWithOptions {
    private ExtractInterfaceTypeAnalysisResult _typeAnalysisResult;
    private AbstractExtractInterfaceService _extractInterfaceService;
    public string Title { get; }
    public ExtractInterfaceCodeAction(AbstractExtractInterfaceService extractInterfaceService, ExtractInterfaceTypeAnalysisResult typeAnalysisResult);
    public virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceCodeAction/<ComputeOperationsAsync>d__4")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    public virtual string get_Title();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceOptionsResult : object {
    public static ExtractInterfaceOptionsResult Cancelled;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ISymbol> <IncludedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InterfaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private CleanCodeGenerationOptionsProvider <FallbackOptions>k__BackingField;
    public bool IsCancelled { get; }
    public ImmutableArray`1<ISymbol> IncludedMembers { get; }
    public string InterfaceName { get; }
    public string FileName { get; }
    public ExtractLocation Location { get; }
    public CleanCodeGenerationOptionsProvider FallbackOptions { get; }
    public ExtractInterfaceOptionsResult(bool isCancelled, ImmutableArray`1<ISymbol> includedMembers, string interfaceName, string fileName, ExtractLocation location, CleanCodeGenerationOptionsProvider fallbackOptions);
    private ExtractInterfaceOptionsResult(bool isCancelled);
    private static ExtractInterfaceOptionsResult();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ISymbol> get_IncludedMembers();
    [CompilerGeneratedAttribute]
public string get_InterfaceName();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public ExtractLocation get_Location();
    [CompilerGeneratedAttribute]
public CleanCodeGenerationOptionsProvider get_FallbackOptions();
}
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceResult : object {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <UpdatedSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <NavigationDocumentId>k__BackingField;
    public bool Succeeded { get; }
    public Solution UpdatedSolution { get; }
    public DocumentId NavigationDocumentId { get; }
    public ExtractInterfaceResult(bool succeeded, Solution updatedSolution, DocumentId navigationDocumentId);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public Solution get_UpdatedSolution();
    [CompilerGeneratedAttribute]
public DocumentId get_NavigationDocumentId();
}
internal class Microsoft.CodeAnalysis.ExtractInterface.ExtractInterfaceTypeAnalysisResult : object {
    public bool CanExtractInterface;
    public Document DocumentToExtractFrom;
    public SyntaxNode TypeNode;
    public INamedTypeSymbol TypeToExtractFrom;
    public IEnumerable`1<ISymbol> ExtractableMembers;
    public CleanCodeGenerationOptionsProvider FallbackOptions;
    public string ErrorMessage;
    public ExtractInterfaceTypeAnalysisResult(Document documentToExtractFrom, SyntaxNode typeNode, INamedTypeSymbol typeToExtractFrom, IEnumerable`1<ISymbol> extractableMembers, CleanCodeGenerationOptionsProvider fallbackOptions);
    public ExtractInterfaceTypeAnalysisResult(string errorMessage);
}
internal interface Microsoft.CodeAnalysis.ExtractInterface.IExtractInterfaceOptionsService {
    public abstract virtual Task`1<ExtractInterfaceOptionsResult> GetExtractInterfaceOptionsAsync(ISyntaxFactsService syntaxFactsService, INotificationService notificationService, List`1<ISymbol> extractableMembers, string defaultInterfaceName, List`1<string> conflictingTypeNames, string defaultNamespace, string generatedNameTypeParameterSuffix, string languageName, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.ExtractInterface.TypeDiscoveryRule : Enum {
    public int value__;
    public static TypeDiscoveryRule TypeDeclaration;
    public static TypeDiscoveryRule TypeNameOnly;
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`5 : object {
    [NullableContextAttribute("1")]
protected abstract virtual TValidator CreateSelectionValidator(SemanticDocument document, TextSpan textSpan, ExtractMethodOptions options, bool localFunction);
    [NullableContextAttribute("1")]
protected abstract virtual TExtractor CreateMethodExtractor(TSelectionResult selectionResult, ExtractMethodGenerationOptions options, bool localFunction);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.AbstractExtractMethodService`5/<ExtractMethodAsync>d__2")]
public sealed virtual Task`1<ExtractMethodResult> ExtractMethodAsync(Document document, TextSpan textSpan, bool localFunction, ExtractMethodGenerationOptions options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.AbstractSyntaxTriviaService : object {
    private static int TriviaLocationsCount;
    private int _endOfLineKind;
    protected AbstractSyntaxTriviaService(int endOfLineKind);
    public sealed virtual ITriviaSavedResult SaveTriviaAroundSelection(SyntaxNode root, TextSpan textSpan);
    private static SyntaxNode ReplaceTokens(SyntaxNode root, IEnumerable`1<SyntaxToken> oldTokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken);
    private ITriviaSavedResult CreateResult(SyntaxNode root, Dictionary`2<TriviaLocation, SyntaxAnnotation> annotations, Dictionary`2<TriviaLocation, IEnumerable`1<SyntaxTrivia>> triviaList);
    private static Dictionary`2<SyntaxToken, SyntaxToken> CreateOldToNewTokensMap(Dictionary`2<TriviaLocation, SyntaxToken> tokens, Dictionary`2<TriviaLocation, SyntaxAnnotation> annotations);
    private static Dictionary`2<TriviaLocation, IEnumerable`1<SyntaxTrivia>> GetTriviaAtEdges(Dictionary`2<TriviaLocation, SyntaxToken> tokens, TextSpan textSpan);
    private static Dictionary`2<TriviaLocation, SyntaxToken> GetTokensAtEdges(SyntaxNode root, TextSpan textSpan);
    private static ValueTuple`2<List`1<SyntaxTrivia>, List`1<SyntaxTrivia>> SplitTrivia(SyntaxToken token1, SyntaxToken token2, Func`2<SyntaxTrivia, bool> conditionToLeftAtCallSite);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.AnnotationResolver : MulticastDelegate {
    public AnnotationResolver(object object, IntPtr method);
    public virtual SyntaxToken Invoke(SyntaxNode root, TriviaLocation location, SyntaxAnnotation annotation);
    public virtual IAsyncResult BeginInvoke(SyntaxNode root, TriviaLocation location, SyntaxAnnotation annotation, AsyncCallback callback, object object);
    public virtual SyntaxToken EndInvoke(IAsyncResult result);
}
internal enum Microsoft.CodeAnalysis.ExtractMethod.DeclarationBehavior : Enum {
    public int value__;
    public static DeclarationBehavior None;
    public static DeclarationBehavior Delete;
    public static DeclarationBehavior MoveIn;
    public static DeclarationBehavior MoveOut;
    public static DeclarationBehavior SplitIn;
    public static DeclarationBehavior SplitOut;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExtractMethod.Extensions : object {
    [ExtensionAttribute]
public static ITypeSymbol GetLambdaOrAnonymousMethodReturnType(SemanticModel binding, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetTokenWithAnnotation(SemanticDocument document, SyntaxAnnotation annotation);
    [ExtensionAttribute]
public static T ResolveType(SemanticModel semanticModel, T symbol);
    [ExtensionAttribute]
public static bool HasDiagnostics(SyntaxNode node);
    [ExtensionAttribute]
public static bool FromScript(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodMatrix : object {
    private static Dictionary`2<Key, VariableStyle> s_matrix;
    private static ExtractMethodMatrix();
    public static bool TryGetVariableStyle(bool bestEffort, bool dataFlowIn, bool dataFlowOut, bool alwaysAssigned, bool variableDeclared, bool readInside, bool writtenInside, bool readOutside, bool writtenOutside, bool unsafeAddressTaken, VariableStyle& variableStyle);
    private static void BuildMatrix();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodResult : object {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Reasons>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLazy`1<ValueTuple`2<Document, Nullable`1<SyntaxToken>>> _lazyData;
    public bool Succeeded { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Reasons { get; }
    internal ExtractMethodResult(bool succeeded, ImmutableArray`1<string> reasons, Func`2<CancellationToken, Task`1<ValueTuple`2<Document, Nullable`1<SyntaxToken>>>> getDocumentAsync);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Reasons();
    public static ExtractMethodResult Fail(OperationStatus status);
    public static ExtractMethodResult Success(OperationStatus status, Func`2<CancellationToken, Task`1<ValueTuple`2<Document, Nullable`1<SyntaxToken>>>> getDocumentAsync);
    public Task`1<ValueTuple`2<Document, Nullable`1<SyntaxToken>>> GetDocumentAsync(CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodService : object {
    [NullableContextAttribute("1")]
public static Task`1<ExtractMethodResult> ExtractMethodAsync(Document document, TextSpan textSpan, bool localFunction, ExtractMethodGenerationOptions options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ExtractMethod.IExtractMethodService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ExtractMethodResult> ExtractMethodAsync(Document document, TextSpan textSpan, bool localFunction, ExtractMethodGenerationOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ExtractMethod.InsertionPoint : object {
    private SyntaxAnnotation _annotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<SyntaxNode> _context;
    [CompilerGeneratedAttribute]
private SemanticDocument <SemanticDocument>k__BackingField;
    public SemanticDocument SemanticDocument { get; }
    public InsertionPoint(SemanticDocument document, SyntaxAnnotation annotation);
    [CompilerGeneratedAttribute]
public SemanticDocument get_SemanticDocument();
    public SyntaxNode GetRoot();
    [NullableContextAttribute("2")]
public SyntaxNode GetContext();
    public InsertionPoint With(SemanticDocument document);
    private Lazy`1<SyntaxNode> CreateLazyContextNode();
    [NullableContextAttribute("2")]
private SyntaxNode ComputeContextNode();
}
internal interface Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService {
    public abstract virtual ITriviaSavedResult SaveTriviaAroundSelection(SyntaxNode root, TextSpan textSpan);
}
internal interface Microsoft.CodeAnalysis.ExtractMethod.ITriviaSavedResult {
    public SyntaxNode Root { get; }
    public abstract virtual SyntaxNode get_Root();
    public abstract virtual SyntaxNode RestoreTrivia(SyntaxNode root, AnnotationResolver annotationResolver, TriviaResolver triviaResolver);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.LeadingTrailingTriviaPair : ValueType {
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxTrivia> <LeadingTrivia>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxTrivia> <TrailingTrivia>k__BackingField;
    public IEnumerable`1<SyntaxTrivia> LeadingTrivia { get; public set; }
    public IEnumerable`1<SyntaxTrivia> TrailingTrivia { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxTrivia> get_LeadingTrivia();
    [CompilerGeneratedAttribute]
public void set_LeadingTrivia(IEnumerable`1<SyntaxTrivia> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxTrivia> get_TrailingTrivia();
    [CompilerGeneratedAttribute]
public void set_TrailingTrivia(IEnumerable`1<SyntaxTrivia> value);
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor`3 : object {
    protected TSelectionResult OriginalSelectionResult;
    protected ExtractMethodGenerationOptions Options;
    protected bool LocalFunction;
    protected MethodExtractor`3(TSelectionResult selectionResult, ExtractMethodGenerationOptions options, bool localFunction);
    protected abstract virtual SyntaxNode ParseTypeName(string name);
    protected abstract virtual AnalyzerResult<TSelectionResult, TStatementSyntax, TExpressionSyntax> Analyze(TSelectionResult selectionResult, bool localFunction, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetInsertionPointNode(AnalyzerResult<TSelectionResult, TStatementSyntax, TExpressionSyntax> analyzerResult, CancellationToken cancellationToken);
    protected abstract virtual Task`1<TriviaResult<TSelectionResult, TStatementSyntax, TExpressionSyntax>> PreserveTriviaAsync(TSelectionResult selectionResult, CancellationToken cancellationToken);
    protected abstract virtual CodeGenerator<TSelectionResult, TStatementSyntax, TExpressionSyntax> CreateCodeGenerator(AnalyzerResult<TSelectionResult, TStatementSyntax, TExpressionSyntax> analyzerResult);
    protected abstract virtual Task`1<GeneratedCode<TSelectionResult, TStatementSyntax, TExpressionSyntax>> GenerateCodeAsync(InsertionPoint insertionPoint, TSelectionResult selectionResult, AnalyzerResult<TSelectionResult, TStatementSyntax, TExpressionSyntax> analyzeResult, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected abstract virtual Nullable`1<SyntaxToken> GetInvocationNameToken(IEnumerable`1<SyntaxToken> tokens);
    protected abstract virtual AbstractFormattingRule GetCustomFormattingRule(Document document);
    protected abstract virtual Task`1<ValueTuple`2<Document, Nullable`1<SyntaxToken>>> InsertNewLineBeforeLocalFunctionIfNecessaryAsync(Document document, Nullable`1<SyntaxToken> invocationNameToken, SyntaxNode methodDefinition, CancellationToken cancellationToken);
    public ExtractMethodResult ExtractMethod(OperationStatus initialStatus, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor`3/<ExpandAsync>d__18")]
private static Task`1<SemanticDocument> ExpandAsync(TSelectionResult selection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor`3/<GetFormattedDocumentAsync>d__19")]
private Task`1<ValueTuple`2<Document, Nullable`1<SyntaxToken>>> GetFormattedDocumentAsync(Document document, Nullable`1<SyntaxToken> invocationNameToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.MethodExtractor`3/<GetAnnotatedDocumentAndInsertionPointAsync>d__20")]
private static Task`1<ValueTuple`2<SemanticDocument, InsertionPoint>> GetAnnotatedDocumentAndInsertionPointAsync(SemanticDocument document, AnalyzerResult<TSelectionResult, TStatementSyntax, TExpressionSyntax> analyzeResult, SyntaxNode insertionPointNode, CancellationToken cancellationToken);
    private ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(Document document);
    private OperationStatus CheckVariableTypes(OperationStatus status, AnalyzerResult<TSelectionResult, TStatementSyntax, TExpressionSyntax> analyzeResult, CancellationToken cancellationToken);
    private OperationStatus TryCheckVariableType(SemanticModel semanticModel, SyntaxNode contextNode, IEnumerable`1<VariableInfo<TSelectionResult, TStatementSyntax, TExpressionSyntax>> variables, OperationStatus status);
    private OperationStatus CheckType(SemanticModel semanticModel, SyntaxNode contextNode, ITypeSymbol type);
    internal static string MakeMethodName(string prefix, string originalName, bool camelCase);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.OperationStatus : object {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Reasons>k__BackingField;
    public static OperationStatus SucceededStatus;
    public static OperationStatus FailedWithUnknownReason;
    public static OperationStatus OverlapsHiddenPosition;
    public static OperationStatus NoValidLocationToInsertMethodCall;
    public static OperationStatus NoActiveStatement;
    public static OperationStatus ErrorOrUnknownType;
    public static OperationStatus UnsafeAddressTaken;
    public static OperationStatus LocalFunctionCallWithoutDeclaration;
    public bool Succeeded { get; }
    public ImmutableArray`1<string> Reasons { get; }
    public bool Failed { get; }
    public OperationStatus(bool succeeded, string reason);
    private OperationStatus(bool succeeded, ImmutableArray`1<string> reasons);
    private static OperationStatus();
    public OperationStatus With(bool succeeded, string reason);
    public OperationStatus With(OperationStatus operationStatus);
    public OperationStatus MakeFail();
    public OperationStatus`1<T> With(T data);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Reasons();
    public bool get_Failed();
    public static OperationStatus`1<T> Create(OperationStatus status, T data);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.OperationStatus`1 : object {
    [CompilerGeneratedAttribute]
private OperationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    public OperationStatus Status { get; }
    public T Data { get; }
    public OperationStatus`1(OperationStatus status, T data);
    [CompilerGeneratedAttribute]
public OperationStatus get_Status();
    [CompilerGeneratedAttribute]
public T get_Data();
    public OperationStatus`1<T> With(OperationStatus status);
    public OperationStatus`1<TNew> With(TNew data);
}
internal enum Microsoft.CodeAnalysis.ExtractMethod.ParameterBehavior : Enum {
    public int value__;
    public static ParameterBehavior None;
    public static ParameterBehavior Input;
    public static ParameterBehavior Out;
    public static ParameterBehavior Ref;
}
internal class Microsoft.CodeAnalysis.ExtractMethod.ParameterStyle : object {
    [CompilerGeneratedAttribute]
private ParameterBehavior <ParameterBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationBehavior <DeclarationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationBehavior <SaferDeclarationBehavior>k__BackingField;
    public static ParameterStyle None;
    public static ParameterStyle InputOnly;
    public static ParameterStyle Delete;
    public static ParameterStyle MoveOut;
    public static ParameterStyle SplitOut;
    public static ParameterStyle MoveIn;
    public static ParameterStyle SplitIn;
    public static ParameterStyle Out;
    public static ParameterStyle Ref;
    public static ParameterStyle OutWithMoveOut;
    public ParameterBehavior ParameterBehavior { get; private set; }
    public DeclarationBehavior DeclarationBehavior { get; private set; }
    public DeclarationBehavior SaferDeclarationBehavior { get; private set; }
    private static ParameterStyle();
    [CompilerGeneratedAttribute]
public ParameterBehavior get_ParameterBehavior();
    [CompilerGeneratedAttribute]
private void set_ParameterBehavior(ParameterBehavior value);
    [CompilerGeneratedAttribute]
public DeclarationBehavior get_DeclarationBehavior();
    [CompilerGeneratedAttribute]
private void set_DeclarationBehavior(DeclarationBehavior value);
    [CompilerGeneratedAttribute]
public DeclarationBehavior get_SaferDeclarationBehavior();
    [CompilerGeneratedAttribute]
private void set_SaferDeclarationBehavior(DeclarationBehavior value);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.PreviousNextTokenPair : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxToken <PreviousToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <NextToken>k__BackingField;
    public SyntaxToken PreviousToken { get; public set; }
    public SyntaxToken NextToken { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SyntaxToken get_PreviousToken();
    [CompilerGeneratedAttribute]
public void set_PreviousToken(SyntaxToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SyntaxToken get_NextToken();
    [CompilerGeneratedAttribute]
public void set_NextToken(SyntaxToken value);
}
internal enum Microsoft.CodeAnalysis.ExtractMethod.ReturnBehavior : Enum {
    public int value__;
    public static ReturnBehavior None;
    public static ReturnBehavior Initialization;
    public static ReturnBehavior Assignment;
}
internal class Microsoft.CodeAnalysis.ExtractMethod.ReturnStyle : object {
    [CompilerGeneratedAttribute]
private ParameterBehavior <ParameterBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnBehavior <ReturnBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationBehavior <DeclarationBehavior>k__BackingField;
    public static ReturnStyle None;
    public static ReturnStyle AssignmentWithInput;
    public static ReturnStyle AssignmentWithNoInput;
    public static ReturnStyle Initialization;
    public ParameterBehavior ParameterBehavior { get; private set; }
    public ReturnBehavior ReturnBehavior { get; private set; }
    public DeclarationBehavior DeclarationBehavior { get; private set; }
    private static ReturnStyle();
    [CompilerGeneratedAttribute]
public ParameterBehavior get_ParameterBehavior();
    [CompilerGeneratedAttribute]
private void set_ParameterBehavior(ParameterBehavior value);
    [CompilerGeneratedAttribute]
public ReturnBehavior get_ReturnBehavior();
    [CompilerGeneratedAttribute]
private void set_ReturnBehavior(ReturnBehavior value);
    [CompilerGeneratedAttribute]
public DeclarationBehavior get_DeclarationBehavior();
    [CompilerGeneratedAttribute]
private void set_DeclarationBehavior(DeclarationBehavior value);
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.SelectionResult`1 : object {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <FinalSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractMethodOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SelectionInExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticDocument <SemanticDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxAnnotation <FirstTokenAnnotation>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxAnnotation <LastTokenAnnotation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SelectionChanged>k__BackingField;
    protected ISyntaxFacts SyntaxFacts { get; }
    public TextSpan OriginalSpan { get; }
    public TextSpan FinalSpan { get; }
    public ExtractMethodOptions Options { get; }
    public bool SelectionInExpression { get; }
    public SemanticDocument SemanticDocument { get; private set; }
    public SyntaxAnnotation FirstTokenAnnotation { get; }
    public SyntaxAnnotation LastTokenAnnotation { get; }
    public bool SelectionChanged { get; }
    protected SelectionResult`1(TextSpan originalSpan, TextSpan finalSpan, ExtractMethodOptions options, bool selectionInExpression, SemanticDocument document, SyntaxAnnotation firstTokenAnnotation, SyntaxAnnotation lastTokenAnnotation, bool selectionChanged);
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual bool UnderAnonymousOrLocalMethod(SyntaxToken token, SyntaxToken firstToken, SyntaxToken lastToken);
    public abstract virtual TStatementSyntax GetFirstStatementUnderContainer();
    public abstract virtual TStatementSyntax GetLastStatementUnderContainer();
    public abstract virtual bool ContainingScopeHasAsyncKeyword();
    public abstract virtual SyntaxNode GetContainingScope();
    public abstract virtual SyntaxNode GetOutermostCallSiteContainerToProcess(CancellationToken cancellationToken);
    public abstract virtual ValueTuple`2<ITypeSymbol, bool> GetReturnType();
    public ITypeSymbol GetContainingScopeType();
    public virtual SyntaxNode GetNodeForDataFlowAnalysis();
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalSpan();
    [CompilerGeneratedAttribute]
public TextSpan get_FinalSpan();
    [CompilerGeneratedAttribute]
public ExtractMethodOptions get_Options();
    [CompilerGeneratedAttribute]
public bool get_SelectionInExpression();
    [CompilerGeneratedAttribute]
public SemanticDocument get_SemanticDocument();
    [CompilerGeneratedAttribute]
private void set_SemanticDocument(SemanticDocument value);
    [CompilerGeneratedAttribute]
public SyntaxAnnotation get_FirstTokenAnnotation();
    [CompilerGeneratedAttribute]
public SyntaxAnnotation get_LastTokenAnnotation();
    [CompilerGeneratedAttribute]
public bool get_SelectionChanged();
    public SelectionResult`1<TStatementSyntax> With(SemanticDocument document);
    public SyntaxToken GetFirstTokenInSelection();
    public SyntaxToken GetLastTokenInSelection();
    public TNode GetContainingScopeOf();
    public bool IsExtractMethodOnSingleStatement();
    public bool IsExtractMethodOnMultipleStatements();
    public TStatementSyntax GetFirstStatement();
    public TStatementSyntax GetLastStatement();
    public bool ShouldPutAsyncModifier();
    public bool ShouldCallConfigureAwaitFalse();
    protected static SyntaxNode AddAnnotations(SyntaxNode root, IEnumerable`1<ValueTuple`2<SyntaxToken, SyntaxAnnotation>> pairs);
    protected static SyntaxNode AddAnnotations(SyntaxNode root, IEnumerable`1<ValueTuple`2<SyntaxNode, SyntaxAnnotation>> pairs);
    [CompilerGeneratedAttribute]
internal static bool <ShouldCallConfigureAwaitFalse>g__IsConfigureAwaitFalse|46_0(SyntaxNode node, <>c__DisplayClass46_0& );
}
internal abstract class Microsoft.CodeAnalysis.ExtractMethod.SelectionValidator`2 : object {
    protected SemanticDocument SemanticDocument;
    protected TextSpan OriginalSpan;
    protected ExtractMethodOptions Options;
    public bool ContainsValidSelection { get; }
    protected SelectionValidator`2(SemanticDocument document, TextSpan textSpan, ExtractMethodOptions options);
    public bool get_ContainsValidSelection();
    public abstract virtual Task`1<ValueTuple`2<TSelectionResult, OperationStatus>> GetValidSelectionAsync(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<SyntaxNode> GetOuterReturnStatements(SyntaxNode commonRoot, IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    public abstract virtual bool IsFinalSpanSemanticallyValidSpan(SyntaxNode node, TextSpan textSpan, IEnumerable`1<SyntaxNode> returnStatements, CancellationToken cancellationToken);
    public abstract virtual bool ContainsNonReturnExitPointsStatements(IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    protected bool IsFinalSpanSemanticallyValidSpan(SemanticModel semanticModel, TextSpan textSpan, ValueTuple`2<SyntaxNode, SyntaxNode> range, CancellationToken cancellationToken);
    protected static Nullable`1<ValueTuple`2<T, T>> GetStatementRangeContainingSpan(ISyntaxFacts syntaxFacts, SyntaxNode root, TextSpan textSpan, CancellationToken cancellationToken);
    protected static Nullable`1<ValueTuple`2<T, T>> GetStatementRangeContainedInSpan(SyntaxNode root, TextSpan textSpan, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <GetStatementRangeContainingSpan>g__CanMergeExistingSpineWithCurrent|11_0(ISyntaxFacts syntaxFacts, T existing, T current);
}
internal enum Microsoft.CodeAnalysis.ExtractMethod.TriviaLocation : Enum {
    public int value__;
    public static TriviaLocation BeforeBeginningOfSpan;
    public static TriviaLocation AfterBeginningOfSpan;
    public static TriviaLocation BeforeEndOfSpan;
    public static TriviaLocation AfterEndOfSpan;
}
internal class Microsoft.CodeAnalysis.ExtractMethod.TriviaResolver : MulticastDelegate {
    public TriviaResolver(object object, IntPtr method);
    public virtual IEnumerable`1<SyntaxTrivia> Invoke(TriviaLocation location, PreviousNextTokenPair tokenPair, Dictionary`2<SyntaxToken, LeadingTrailingTriviaPair> triviaMap);
    public virtual IAsyncResult BeginInvoke(TriviaLocation location, PreviousNextTokenPair tokenPair, Dictionary`2<SyntaxToken, LeadingTrailingTriviaPair> triviaMap, AsyncCallback callback, object object);
    public virtual IEnumerable`1<SyntaxTrivia> EndInvoke(IAsyncResult result);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.UniqueNameGenerator : object {
    private SemanticModel _semanticModel;
    public UniqueNameGenerator(SemanticModel semanticModel);
    public string CreateUniqueMethodName(SyntaxNode contextNode, string baseName);
}
internal class Microsoft.CodeAnalysis.ExtractMethod.VariableStyle : object {
    [CompilerGeneratedAttribute]
private ParameterStyle <ParameterStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private ReturnStyle <ReturnStyle>k__BackingField;
    public static VariableStyle None;
    public static VariableStyle InputOnly;
    public static VariableStyle Delete;
    public static VariableStyle MoveOut;
    public static VariableStyle SplitOut;
    public static VariableStyle MoveIn;
    public static VariableStyle SplitIn;
    public static VariableStyle NotUsed;
    public static VariableStyle Ref;
    public static VariableStyle OnlyAsRefParam;
    public static VariableStyle Out;
    public static VariableStyle OutWithErrorInput;
    public static VariableStyle OutWithMoveOut;
    public ParameterStyle ParameterStyle { get; private set; }
    public ReturnStyle ReturnStyle { get; private set; }
    private static VariableStyle();
    [CompilerGeneratedAttribute]
public ParameterStyle get_ParameterStyle();
    [CompilerGeneratedAttribute]
private void set_ParameterStyle(ParameterStyle value);
    [CompilerGeneratedAttribute]
public ReturnStyle get_ReturnStyle();
    [CompilerGeneratedAttribute]
private void set_ReturnStyle(ReturnStyle value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractLanguageDetector`1 : object {
    protected EmbeddedLanguageInfo Info;
    protected EmbeddedLanguageDetector Detector;
    protected AbstractLanguageDetector`1(EmbeddedLanguageInfo info, ImmutableArray`1<string> languageIdentifiers, EmbeddedLanguageCommentDetector commentDetector);
    protected abstract virtual bool IsArgumentToWellKnownAPI(SyntaxToken token, SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken, TOptions& options);
    protected abstract virtual bool TryGetOptions(SemanticModel semanticModel, ITypeSymbol exprType, SyntaxNode expr, CancellationToken cancellationToken, TOptions& options);
    protected virtual bool IsEmbeddedLanguageInterpolatedStringTextToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
protected virtual TOptions GetStringSyntaxDefaultOptions();
    [NullableContextAttribute("0")]
public bool IsEmbeddedLanguageToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, TOptions& options);
    [NullableContextAttribute("0")]
private bool IsEmbeddedLanguageStringLiteralToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, TOptions& options);
    protected Nullable`1<TOptions> GetOptionsFromSiblingArgument(SyntaxNode argument, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected static string GetNameOfType(SyntaxNode typeNode, ISyntaxFacts syntaxFacts);
    protected string GetNameOfInvokedExpression(SyntaxNode invokedExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.AbstractLanguageDetector`4 : AbstractLanguageDetector`1<TOptions> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<string> LanguageIdentifiers;
    public static EmbeddedLanguageCommentDetector CommentDetector;
    private static ConditionalWeakTable`2<Compilation, TDetector> s_compilationToDetector;
    protected AbstractLanguageDetector`4(EmbeddedLanguageInfo info, ImmutableArray`1<string> languageIdentifiers, EmbeddedLanguageCommentDetector commentDetector);
    private static AbstractLanguageDetector`4();
    public static TDetector GetOrCreate(Compilation compilation, EmbeddedLanguageInfo info);
    [NullableContextAttribute("0")]
protected abstract virtual TTree TryParse(VirtualCharSequence chars, TOptions options);
    public TTree TryParseString(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static TDetector <GetOrCreate>g__Create|4_0(Compilation compilation, EmbeddedLanguageInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeEmbeddedCompletionProvider : EmbeddedLanguageCompletionProvider {
    private static string StartKey;
    private static string LengthKey;
    private static string NewTextKey;
    private static string DescriptionKey;
    private static CompletionItemRules s_rules;
    private DateAndTimeEmbeddedLanguage _language;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public DateAndTimeEmbeddedCompletionProvider(DateAndTimeEmbeddedLanguage language);
    private static DateAndTimeEmbeddedCompletionProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeEmbeddedCompletionProvider/<ProvideCompletionsAsync>d__11")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static void ProvideStandardFormats(EmbeddedCompletionContext context);
    private static void ProvideCustomFormats(EmbeddedCompletionContext context);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateAndTimeOptions : Enum {
    public int value__;
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.DateTimeTree : object {
    [NullableAttribute("1")]
public static DateTimeTree Instance;
    private static DateTimeTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.LanguageServices.DateAndTimeEmbeddedLanguage : object {
    public EmbeddedLanguageInfo Info;
    [CompilerGeneratedAttribute]
private EmbeddedLanguageCompletionProvider <CompletionProvider>k__BackingField;
    public EmbeddedLanguageCompletionProvider CompletionProvider { get; }
    public DateAndTimeEmbeddedLanguage(EmbeddedLanguageInfo info);
    [CompilerGeneratedAttribute]
public sealed virtual EmbeddedLanguageCompletionProvider get_CompletionProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.LanguageServices.DateAndTimeEmbeddedLanguage/<TryGetDateAndTimeTokenAtPositionAsync>d__5")]
public Task`1<Nullable`1<SyntaxToken>> TryGetDateAndTimeTokenAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    private static SyntaxToken GetToken(ISyntaxFactsService syntaxFacts, SyntaxNode root, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.DateAndTime.LanguageServices.DateAndTimeLanguageDetector : AbstractLanguageDetector`4<DateAndTimeOptions, DateTimeTree, DateAndTimeLanguageDetector, DateAndTimeInfo> {
    private static string FormatName;
    [NullableAttribute("2")]
private INamedTypeSymbol _dateTimeType;
    [NullableAttribute("2")]
private INamedTypeSymbol _dateTimeOffsetType;
    [NullableContextAttribute("2")]
public DateAndTimeLanguageDetector(EmbeddedLanguageInfo info, INamedTypeSymbol dateTimeType, INamedTypeSymbol dateTimeOffsetType);
    protected virtual bool TryGetOptions(SemanticModel semanticModel, ITypeSymbol exprType, SyntaxNode expr, CancellationToken cancellationToken, DateAndTimeOptions& options);
    [NullableContextAttribute("2")]
protected virtual DateTimeTree TryParse(VirtualCharSequence chars, DateAndTimeOptions options);
    protected virtual bool IsEmbeddedLanguageInterpolatedStringTextToken(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool IsArgumentToWellKnownAPI(SyntaxToken token, SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken, DateAndTimeOptions& options);
    private static string GetNameOfInvokedExpression(ISyntaxFacts syntaxFacts, SyntaxNode invokedExpression);
    private static bool IsMethodArgument(SyntaxToken token, ISyntaxFacts syntaxFacts);
    private ValueTuple`2<string, Nullable`1<int>> GetArgumentNameOrIndex(SyntaxNode argument);
    [NullableContextAttribute("2")]
private bool TryAnalyzeInvocation(ISymbol symbol, string argName, Nullable`1<int> argIndex);
    [NullableContextAttribute("2")]
private bool IsDateTimeType(ITypeSymbol type);
    private static bool AnalyzeStringLiteral(IMethodSymbol method, string argName, Nullable`1<int> argIndex);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Features.EmbeddedLanguages.ILanguageDetectorInfo`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> LanguageIdentifiers { get; }
    public abstract virtual ImmutableArray`1<string> get_LanguageIdentifiers();
    public abstract virtual TDetector Create(Compilation compilation, EmbeddedLanguageInfo info);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.IJsonNodeVisitor {
    public abstract virtual void Visit(JsonCompilationUnit node);
    public abstract virtual void Visit(JsonArrayNode node);
    public abstract virtual void Visit(JsonObjectNode node);
    public abstract virtual void Visit(JsonPropertyNode node);
    public abstract virtual void Visit(JsonConstructorNode node);
    public abstract virtual void Visit(JsonLiteralNode node);
    public abstract virtual void Visit(JsonNegativeLiteralNode node);
    public abstract virtual void Visit(JsonTextNode node);
    public abstract virtual void Visit(JsonCommaValueNode node);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonArrayNode : JsonValueNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <OpenBracketToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<JsonValueNode> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <CloseBracketToken>k__BackingField;
    public EmbeddedSyntaxToken`1<JsonKind> OpenBracketToken { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<JsonValueNode> Sequence { get; }
    public EmbeddedSyntaxToken`1<JsonKind> CloseBracketToken { get; }
    internal int ChildCount { get; }
    public JsonArrayNode(EmbeddedSyntaxToken`1<JsonKind> openBracketToken, ImmutableArray`1<JsonValueNode> sequence, EmbeddedSyntaxToken`1<JsonKind> closeBracketToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_OpenBracketToken();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<JsonValueNode> get_Sequence();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_CloseBracketToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonCommaValueNode : JsonValueNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <CommaToken>k__BackingField;
    public EmbeddedSyntaxToken`1<JsonKind> CommaToken { get; }
    internal int ChildCount { get; }
    public JsonCommaValueNode(EmbeddedSyntaxToken`1<JsonKind> commaToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_CommaToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonCompilationUnit : JsonNode {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<JsonValueNode> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <EndOfFileToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<JsonValueNode> Sequence { get; }
    public EmbeddedSyntaxToken`1<JsonKind> EndOfFileToken { get; }
    internal int ChildCount { get; }
    public JsonCompilationUnit(ImmutableArray`1<JsonValueNode> sequence, EmbeddedSyntaxToken`1<JsonKind> endOfFileToken);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<JsonValueNode> get_Sequence();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_EndOfFileToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonConstructorNode : JsonValueNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <NewKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <NameToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <OpenParenToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<JsonValueNode> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <CloseParenToken>k__BackingField;
    public EmbeddedSyntaxToken`1<JsonKind> NewKeyword { get; }
    public EmbeddedSyntaxToken`1<JsonKind> NameToken { get; }
    public EmbeddedSyntaxToken`1<JsonKind> OpenParenToken { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<JsonValueNode> Sequence { get; }
    public EmbeddedSyntaxToken`1<JsonKind> CloseParenToken { get; }
    internal int ChildCount { get; }
    public JsonConstructorNode(EmbeddedSyntaxToken`1<JsonKind> newKeyword, EmbeddedSyntaxToken`1<JsonKind> nameToken, EmbeddedSyntaxToken`1<JsonKind> openParenToken, ImmutableArray`1<JsonValueNode> sequence, EmbeddedSyntaxToken`1<JsonKind> closeParenToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_NewKeyword();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_NameToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_OpenParenToken();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<JsonValueNode> get_Sequence();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_CloseParenToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
internal static class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonHelpers : object {
    public static EmbeddedSyntaxToken`1<JsonKind> CreateToken(JsonKind kind, ImmutableArray`1<EmbeddedSyntaxTrivia`1<JsonKind>> leadingTrivia, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedSyntaxTrivia`1<JsonKind>> trailingTrivia);
    public static EmbeddedSyntaxToken`1<JsonKind> CreateToken(JsonKind kind, ImmutableArray`1<EmbeddedSyntaxTrivia`1<JsonKind>> leadingTrivia, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedSyntaxTrivia`1<JsonKind>> trailingTrivia, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public static EmbeddedSyntaxToken`1<JsonKind> CreateMissingToken(JsonKind kind);
    public static EmbeddedSyntaxTrivia`1<JsonKind> CreateTrivia(JsonKind kind, VirtualCharSequence virtualChars);
    public static EmbeddedSyntaxTrivia`1<JsonKind> CreateTrivia(JsonKind kind, VirtualCharSequence virtualChars, EmbeddedDiagnostic diagnostic);
    public static EmbeddedSyntaxTrivia`1<JsonKind> CreateTrivia(JsonKind kind, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
}
internal enum Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonKind : Enum {
    public int value__;
    public static JsonKind None;
    public static JsonKind CompilationUnit;
    public static JsonKind Text;
    public static JsonKind Object;
    public static JsonKind Array;
    public static JsonKind Literal;
    public static JsonKind NegativeLiteral;
    public static JsonKind Property;
    public static JsonKind Constructor;
    public static JsonKind CommaValue;
    public static JsonKind EndOfFile;
    public static JsonKind OpenBraceToken;
    public static JsonKind CloseBraceToken;
    public static JsonKind OpenBracketToken;
    public static JsonKind CloseBracketToken;
    public static JsonKind OpenParenToken;
    public static JsonKind CloseParenToken;
    public static JsonKind StringToken;
    public static JsonKind NumberToken;
    public static JsonKind TextToken;
    public static JsonKind ColonToken;
    public static JsonKind CommaToken;
    public static JsonKind TrueLiteralToken;
    public static JsonKind FalseLiteralToken;
    public static JsonKind NullLiteralToken;
    public static JsonKind UndefinedLiteralToken;
    public static JsonKind NaNLiteralToken;
    public static JsonKind InfinityLiteralToken;
    public static JsonKind NegativeInfinityLiteralToken;
    public static JsonKind MinusToken;
    public static JsonKind NewKeyword;
    public static JsonKind SingleLineCommentTrivia;
    public static JsonKind MultiLineCommentTrivia;
    public static JsonKind WhitespaceTrivia;
    public static JsonKind EndOfLineTrivia;
}
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonLexer : ValueType {
    public VirtualCharSequence Text;
    public int Position;
    public VirtualChar CurrentChar { get; }
    public JsonLexer(VirtualCharSequence text);
    [IsReadOnlyAttribute]
public VirtualChar get_CurrentChar();
    [IsReadOnlyAttribute]
public VirtualCharSequence GetCharsToCurrentPosition(int start);
    [IsReadOnlyAttribute]
public VirtualCharSequence GetSubSequence(int start, int end);
    public EmbeddedSyntaxToken`1<JsonKind> ScanNextToken();
    private ValueTuple`3<VirtualCharSequence, JsonKind, Nullable`1<EmbeddedDiagnostic>> ScanNextTokenWorker();
    private ValueTuple`3<VirtualCharSequence, JsonKind, Nullable`1<EmbeddedDiagnostic>> ScanString();
    private Nullable`1<EmbeddedDiagnostic> AdvanceToEndOfEscape(int stringStart, int escapeStart);
    private Nullable`1<EmbeddedDiagnostic> ScanUnicodeChars(int escapeStart, int unicodeCharStart);
    private static bool IsHexDigit(VirtualChar c);
    private ValueTuple`3<VirtualCharSequence, JsonKind, Nullable`1<EmbeddedDiagnostic>> ScanText();
    private ValueTuple`3<VirtualCharSequence, JsonKind, Nullable`1<EmbeddedDiagnostic>> ScanSingleCharToken(JsonKind kind);
    private ImmutableArray`1<EmbeddedSyntaxTrivia`1<JsonKind>> ScanTrivia(bool leading);
    private Nullable`1<EmbeddedSyntaxTrivia`1<JsonKind>> ScanEndOfLine();
    public Nullable`1<EmbeddedSyntaxTrivia`1<JsonKind>> ScanComment();
    private EmbeddedSyntaxTrivia`1<JsonKind> ScanSingleLineComment();
    private EmbeddedSyntaxTrivia`1<JsonKind> ScanMultiLineComment();
    [IsReadOnlyAttribute]
private TextSpan GetTextSpan(int startInclusive, int endExclusive);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
private bool IsAt(string val);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
private bool TextAt(int position, string val);
    private Nullable`1<EmbeddedSyntaxTrivia`1<JsonKind>> ScanWhitespace();
    [CompilerGeneratedAttribute]
internal static bool <ScanText>g__IsNotPartOfText|13_0(VirtualChar ch);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonLiteralNode : JsonValueNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <LiteralToken>k__BackingField;
    public EmbeddedSyntaxToken`1<JsonKind> LiteralToken { get; }
    internal int ChildCount { get; }
    public JsonLiteralNode(EmbeddedSyntaxToken`1<JsonKind> literalToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_LiteralToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonNegativeLiteralNode : JsonValueNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <MinusToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <LiteralToken>k__BackingField;
    public EmbeddedSyntaxToken`1<JsonKind> MinusToken { get; }
    public EmbeddedSyntaxToken`1<JsonKind> LiteralToken { get; }
    internal int ChildCount { get; }
    public JsonNegativeLiteralNode(EmbeddedSyntaxToken`1<JsonKind> minusToken, EmbeddedSyntaxToken`1<JsonKind> literalToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_MinusToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_LiteralToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonNode : EmbeddedSyntaxNode`2<JsonKind, JsonNode> {
    protected JsonNode(JsonKind kind);
    public abstract virtual void Accept(IJsonNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonObjectNode : JsonValueNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <OpenBraceToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EmbeddedSeparatedSyntaxNodeList`3<JsonKind, JsonNode, JsonValueNode> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <CloseBraceToken>k__BackingField;
    public EmbeddedSyntaxToken`1<JsonKind> OpenBraceToken { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EmbeddedSeparatedSyntaxNodeList`3<JsonKind, JsonNode, JsonValueNode> Sequence { get; }
    public EmbeddedSyntaxToken`1<JsonKind> CloseBraceToken { get; }
    internal int ChildCount { get; }
    public JsonObjectNode(EmbeddedSyntaxToken`1<JsonKind> openBraceToken, EmbeddedSeparatedSyntaxNodeList`3<JsonKind, JsonNode, JsonValueNode> sequence, EmbeddedSyntaxToken`1<JsonKind> closeBraceToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_OpenBraceToken();
    [CompilerGeneratedAttribute]
public EmbeddedSeparatedSyntaxNodeList`3<JsonKind, JsonNode, JsonValueNode> get_Sequence();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_CloseBraceToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonOptions : Enum {
    public int value__;
    public static JsonOptions Loose;
    public static JsonOptions Strict;
    public static JsonOptions Comments;
    public static JsonOptions TrailingCommas;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonParser : ValueType {
    private static string s_closeBracketExpected;
    private static string s_closeBraceExpected;
    private static string s_openParenExpected;
    private static string s_closeParenExpected;
    private static string s_commaExpected;
    private JsonLexer _lexer;
    [NullableAttribute("0")]
private EmbeddedSyntaxToken`1<JsonKind> _currentToken;
    private int _recursionDepth;
    private bool _inObject;
    private bool _inArray;
    private bool _inConstructor;
    private JsonParser(VirtualCharSequence text);
    private static JsonParser();
    [NullableContextAttribute("0")]
private EmbeddedSyntaxToken`1<JsonKind> ConsumeCurrentToken();
    [NullableContextAttribute("2")]
public static JsonTree TryParse(VirtualCharSequence text, JsonOptions options);
    private JsonTree ParseTree(JsonOptions options);
    private static Nullable`1<EmbeddedDiagnostic> Earliest(Nullable`1<EmbeddedDiagnostic> d1, Nullable`1<EmbeddedDiagnostic> d2);
    private static Nullable`1<EmbeddedDiagnostic> CheckTopLevel(VirtualCharSequence text, JsonCompilationUnit compilationUnit);
    [NullableContextAttribute("0")]
private static EmbeddedSyntaxToken`1<JsonKind> GetFirstToken(EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> nodeOrToken);
    private static Nullable`1<EmbeddedDiagnostic> GetFirstDiagnostic(JsonNode node);
    private static Nullable`1<EmbeddedDiagnostic> GetFirstDiagnostic(EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> child);
    [NullableContextAttribute("0")]
private static Nullable`1<EmbeddedDiagnostic> GetFirstDiagnostic(EmbeddedSyntaxToken`1<JsonKind> token);
    [NullableContextAttribute("0")]
private static Nullable`1<EmbeddedDiagnostic> GetFirstDiagnostic(ImmutableArray`1<EmbeddedSyntaxTrivia`1<JsonKind>> list);
    private ImmutableArray`1<JsonValueNode> ParseSequence();
    private ImmutableArray`1<JsonValueNode> ParseSequenceWorker();
    private EmbeddedSeparatedSyntaxNodeList`3<JsonKind, JsonNode, JsonValueNode> ParseCommaSeparatedSequence();
    private EmbeddedSeparatedSyntaxNodeList`3<JsonKind, JsonNode, JsonValueNode> ParseCommaSeparatedSequenceWorker();
    [IsReadOnlyAttribute]
private bool ShouldConsumeSequenceElement();
    private JsonValueNode ParseValue();
    [NullableContextAttribute("0")]
private static void SplitLiteral(EmbeddedSyntaxToken`1<JsonKind> literalToken, EmbeddedSyntaxToken`1& minusToken, EmbeddedSyntaxToken`1& newLiteralToken);
    [NullableContextAttribute("0")]
private JsonPropertyNode ParseProperty(EmbeddedSyntaxToken`1<JsonKind> stringLiteralOrText);
    private JsonValueNode ParseLiteralOrPropertyOrConstructor();
    [NullableContextAttribute("0")]
private JsonValueNode ParseLiteralOrTextOrConstructor(EmbeddedSyntaxToken`1<JsonKind> token);
    [NullableContextAttribute("0")]
private JsonConstructorNode ParseConstructor(EmbeddedSyntaxToken`1<JsonKind> token);
    [NullableContextAttribute("0")]
private static bool TryMatch(EmbeddedSyntaxToken`1<JsonKind> token, string val, JsonKind kind, JsonKind& newKind);
    [NullableContextAttribute("0")]
private static bool Matches(EmbeddedSyntaxToken`1<JsonKind> token, string val);
    private static bool IsDigit(VirtualChar ch);
    private JsonCommaValueNode ParseCommaValue();
    private JsonArrayNode ParseArray();
    private JsonObjectNode ParseObject();
    [NullableContextAttribute("0")]
private EmbeddedSyntaxToken`1<JsonKind> ConsumeToken(JsonKind kind, string error);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
private TextSpan GetTokenStartPositionSpan(EmbeddedSyntaxToken`1<JsonKind> token);
    [CompilerGeneratedAttribute]
internal static Nullable`1<EmbeddedDiagnostic> <CheckTopLevel>g__CheckSyntax|16_1(JsonNode node);
    [CompilerGeneratedAttribute]
internal static Nullable`1<EmbeddedDiagnostic> <CheckTopLevel>g__CheckChildren|16_2(JsonNode node);
    [CompilerGeneratedAttribute]
internal static Nullable`1<EmbeddedDiagnostic> <CheckTopLevel>g__CheckArray|16_3(JsonArrayNode node);
    [CompilerGeneratedAttribute]
internal static Nullable`1<EmbeddedDiagnostic> <CheckTopLevel>g__CheckObject|16_4(JsonObjectNode node);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonPropertyNode : JsonValueNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <NameToken>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <ColonToken>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private JsonValueNode <Value>k__BackingField;
    public EmbeddedSyntaxToken`1<JsonKind> NameToken { get; }
    public EmbeddedSyntaxToken`1<JsonKind> ColonToken { get; }
    [NullableAttribute("1")]
public JsonValueNode Value { get; }
    internal int ChildCount { get; }
    public JsonPropertyNode(EmbeddedSyntaxToken`1<JsonKind> nameToken, EmbeddedSyntaxToken`1<JsonKind> colonToken, JsonValueNode value);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_NameToken();
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_ColonToken();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public JsonValueNode get_Value();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonTextNode : JsonValueNode {
    [CompilerGeneratedAttribute]
private EmbeddedSyntaxToken`1<JsonKind> <TextToken>k__BackingField;
    public EmbeddedSyntaxToken`1<JsonKind> TextToken { get; }
    internal int ChildCount { get; }
    public JsonTextNode(EmbeddedSyntaxToken`1<JsonKind> textToken);
    [CompilerGeneratedAttribute]
public EmbeddedSyntaxToken`1<JsonKind> get_TextToken();
    internal virtual int get_ChildCount();
    internal virtual EmbeddedSyntaxNodeOrToken`2<JsonKind, JsonNode> ChildAt(int index);
    [NullableContextAttribute("1")]
public virtual void Accept(IJsonNodeVisitor visitor);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonTree : EmbeddedSyntaxTree`3<JsonKind, JsonNode, JsonCompilationUnit> {
    public JsonTree(VirtualCharSequence text, JsonCompilationUnit root, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
}
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.JsonValueNode : JsonNode {
    protected JsonValueNode(JsonKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.AbstractJsonDetectionAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string DiagnosticId;
    public static string StrictKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_strictProperties;
    private EmbeddedLanguageInfo _info;
    protected AbstractJsonDetectionAnalyzer(EmbeddedLanguageInfo info);
    private static AbstractJsonDetectionAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    protected virtual void InitializeWorker(AnalysisContext context);
    public void Analyze(SemanticModelAnalysisContext context);
    private void Analyze(SemanticModelAnalysisContext context, JsonLanguageDetector detector, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.AbstractJsonDetectionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private EmbeddedLanguageInfo _info;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractJsonDetectionCodeFixProvider(EmbeddedLanguageInfo info);
    protected abstract virtual void AddComment(SyntaxEditor editor, SyntaxToken stringLiteral, string commentContents);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public void Fix(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.AbstractJsonDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string DiagnosticId;
    private EmbeddedLanguageInfo _info;
    protected AbstractJsonDiagnosticAnalyzer(EmbeddedLanguageInfo info);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    protected virtual void InitializeWorker(AnalysisContext context);
    public void Analyze(SemanticModelAnalysisContext context);
    private void Analyze(SemanticModelAnalysisContext context, JsonLanguageDetector detector, SyntaxNode node, CancellationToken cancellationToken);
}
[ExportEmbeddedLanguageBraceMatcherAttribute("Json", "Mono.Cecil.CustomAttributeArgument[]", "True", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonBraceMatcher : object {
    [NullableContextAttribute("1")]
public sealed virtual Nullable`1<BraceMatchingResult> FindBraces(Project project, SemanticModel semanticModel, SyntaxToken token, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static Nullable`1<BraceMatchingResult> GetMatchingBraces(JsonTree tree, int position);
    [NullableContextAttribute("1")]
private static Nullable`1<BraceMatchingResult> FindBraceHighlights(JsonTree tree, VirtualChar ch);
    [NullableContextAttribute("1")]
private static Nullable`1<BraceMatchingResult> FindBraceMatchingResult(JsonNode node, VirtualChar ch);
    private static Nullable`1<BraceMatchingResult> Create(EmbeddedSyntaxToken`1<JsonKind> open, EmbeddedSyntaxToken`1<JsonKind> close);
    private static bool Matches(EmbeddedSyntaxToken`1<JsonKind> openToken, EmbeddedSyntaxToken`1<JsonKind> closeToken, VirtualChar ch);
}
[ExportEmbeddedLanguageClassifierAttribute("Json", "Mono.Cecil.CustomAttributeArgument[]", "True", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonClassifier : object {
    [NullableAttribute("1")]
private static ObjectPool`1<Visitor> s_visitorPool;
    private static JsonClassifier();
    public sealed virtual void RegisterClassifications(EmbeddedLanguageClassificationContext context);
    [NullableContextAttribute("1")]
private static void AddClassifications(JsonNode node, Visitor visitor, EmbeddedLanguageClassificationContext context);
    private static void AddTokenClassifications(EmbeddedSyntaxToken`1<JsonKind> token, EmbeddedLanguageClassificationContext context);
    private static void AddTriviaClassifications(EmbeddedSyntaxTrivia`1<JsonKind> trivia, EmbeddedLanguageClassificationContext context);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonEmbeddedLanguage : object {
    [NullableAttribute("2")]
public EmbeddedLanguageCompletionProvider CompletionProvider { get; }
    [NullableContextAttribute("2")]
public sealed virtual EmbeddedLanguageCompletionProvider get_CompletionProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.Json.LanguageServices.JsonLanguageDetector : AbstractLanguageDetector`4<JsonOptions, JsonTree, JsonLanguageDetector, JsonInfo> {
    private static string JsonParameterName;
    private static string ParseMethodName;
    private static HashSet`1<string> s_typeNamesOfInterest;
    private ISet`1<INamedTypeSymbol> _typesOfInterest;
    public JsonLanguageDetector(EmbeddedLanguageInfo info, ISet`1<INamedTypeSymbol> typesOfInterest);
    private static JsonLanguageDetector();
    protected virtual JsonOptions GetStringSyntaxDefaultOptions();
    [NullableContextAttribute("2")]
protected virtual JsonTree TryParse(VirtualCharSequence chars, JsonOptions options);
    public JsonTree TryParseString(SyntaxToken token, SemanticModel semanticModel, bool includeProbableStrings, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public bool IsProbablyJson(SyntaxToken token, JsonTree& tree);
    private static bool ContainsProbableJsonObject(JsonNode node);
    protected virtual bool IsArgumentToWellKnownAPI(SyntaxToken token, SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken, JsonOptions& options);
    protected virtual bool TryGetOptions(SemanticModel semanticModel, ITypeSymbol exprType, SyntaxNode expr, CancellationToken cancellationToken, JsonOptions& options);
    private bool IsArgumentToSuitableParameter(SemanticModel semanticModel, SyntaxNode argumentNode, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.AbstractRegexDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string DiagnosticId;
    private EmbeddedLanguageInfo _info;
    protected AbstractRegexDiagnosticAnalyzer(EmbeddedLanguageInfo info);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    public void Analyze(SemanticModelAnalysisContext context);
    private void AnalyzeToken(SemanticModelAnalysisContext context, RegexLanguageDetector detector, SyntaxToken token, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportEmbeddedLanguageBraceMatcherAttribute("Regex", "Mono.Cecil.CustomAttributeArgument[]", "True", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexBraceMatcher : object {
    public sealed virtual Nullable`1<BraceMatchingResult> FindBraces(Project project, SemanticModel semanticModel, SyntaxToken token, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
    private static Nullable`1<BraceMatchingResult> GetMatchingBraces(RegexTree tree, int position);
    [NullableContextAttribute("0")]
private static Nullable`1<BraceMatchingResult> CreateResult(EmbeddedSyntaxToken`1<RegexKind> open, EmbeddedSyntaxToken`1<RegexKind> close);
    private static Nullable`1<BraceMatchingResult> FindCommentBraces(RegexTree tree, VirtualChar ch);
    private static Nullable`1<BraceMatchingResult> FindGroupingBraces(RegexTree tree, VirtualChar ch);
    private static Nullable`1<BraceMatchingResult> FindCharacterClassBraces(RegexTree tree, VirtualChar ch);
    private static RegexGroupingNode FindGroupingNode(RegexNode node, VirtualChar ch);
    private static RegexBaseCharacterClassNode FindCharacterClassNode(RegexNode node, VirtualChar ch);
    private static TNode FindNode(RegexNode node, VirtualChar ch, Func`3<TNode, VirtualChar, bool> predicate);
    [NullableContextAttribute("0")]
private static Nullable`1<EmbeddedSyntaxTrivia`1<RegexKind>> FindTrivia(RegexNode node, VirtualChar ch);
    [NullableContextAttribute("0")]
private static Nullable`1<EmbeddedSyntaxTrivia`1<RegexKind>> TryGetTrivia(ImmutableArray`1<EmbeddedSyntaxTrivia`1<RegexKind>> triviaList, VirtualChar ch);
}
[ExtensionOrderAttribute]
[ExportEmbeddedLanguageClassifierAttribute("Regex", "Mono.Cecil.CustomAttributeArgument[]", "True", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexClassifier : object {
    [NullableAttribute("1")]
private static ObjectPool`1<Visitor> s_visitorPool;
    private static RegexClassifier();
    public sealed virtual void RegisterClassifications(EmbeddedLanguageClassificationContext context);
    [NullableContextAttribute("1")]
private static void AddClassifications(RegexNode node, Visitor visitor, EmbeddedLanguageClassificationContext context);
    private static void AddTriviaClassifications(EmbeddedSyntaxToken`1<RegexKind> token, EmbeddedLanguageClassificationContext context);
    private static void AddTriviaClassifications(EmbeddedSyntaxTrivia`1<RegexKind> trivia, EmbeddedLanguageClassificationContext context);
}
[ExportEmbeddedLanguageDocumentHighlighterAttribute("Regex", "Mono.Cecil.CustomAttributeArgument[]", "True", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexDocumentHighlighter : object {
    [NullableContextAttribute("1")]
public sealed virtual ImmutableArray`1<DocumentHighlights> GetDocumentHighlights(Document document, SemanticModel semanticModel, SyntaxToken token, int position, HighlightingOptions options, CancellationToken cancellationToken);
    private static ImmutableArray`1<HighlightSpan> GetHighlights(RegexTree tree, int positionInDocument);
    private static ImmutableArray`1<HighlightSpan> GetReferences(RegexTree tree, int position);
    private static ImmutableArray`1<HighlightSpan> FindReferenceHighlights(RegexTree tree, VirtualChar ch);
    private static ImmutableArray`1<HighlightSpan> CreateHighlights(RegexEscapeNode node, TextSpan captureSpan);
    private static HighlightSpan CreateHighlightSpan(TextSpan textSpan);
    private static EmbeddedSyntaxToken`1<RegexKind> GetCaptureToken(RegexEscapeNode node);
    [NullableContextAttribute("1")]
private static RegexEscapeNode FindReferenceNode(RegexNode node, VirtualChar virtualChar);
}
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexEmbeddedCompletionProvider : EmbeddedLanguageCompletionProvider {
    private static string StartKey;
    private static string LengthKey;
    private static string NewTextKey;
    private static string NewPositionKey;
    private static string DescriptionKey;
    private static CompletionItemRules s_rules;
    private RegexEmbeddedLanguage _language;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    public RegexEmbeddedCompletionProvider(RegexEmbeddedLanguage language);
    private static RegexEmbeddedCompletionProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool ShouldTriggerCompletion(SourceText text, int caretPosition, CompletionTrigger trigger);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexEmbeddedCompletionProvider/<ProvideCompletionsAsync>d__13")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static void ProvideCompletions(EmbeddedCompletionContext context);
    private static void ProvideCompletionsBasedOffOfPrecedingCharacter(EmbeddedCompletionContext context);
    private static void ProvideTopLevelCompletions(EmbeddedCompletionContext context, bool inCharacterClass);
    private static void ProvideOpenBraceCompletions(EmbeddedCompletionContext context, RegexTree tree, VirtualChar previousVirtualChar);
    private static void ProvideEscapeCategoryCompletions(EmbeddedCompletionContext context);
    private static void ProvideOpenParenCompletions(EmbeddedCompletionContext context, bool inCharacterClass, RegexNode parentOpt);
    private static void ProvideOpenBracketCompletions(EmbeddedCompletionContext context, bool inCharacterClass, RegexNode parentOpt);
    private static void ProvideBackslashCompletions(EmbeddedCompletionContext context, bool inCharacterClass, RegexNode parentOpt);
    private static Nullable`1<ValueTuple`2<RegexNode, EmbeddedSyntaxToken`1<RegexKind>>> FindToken(RegexNode parent, VirtualChar ch);
    private static bool IsInCharacterClass(RegexNode start, VirtualChar ch);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    public virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsInCharacterClass>g__IsInCharacterClassWorker|23_0(RegexNode parent, bool inCharacterClass, <>c__DisplayClass23_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexEmbeddedLanguage : object {
    public EmbeddedLanguageInfo Info;
    private AbstractEmbeddedLanguagesProvider _provider;
    [CompilerGeneratedAttribute]
private EmbeddedLanguageCompletionProvider <CompletionProvider>k__BackingField;
    public EmbeddedLanguageCompletionProvider CompletionProvider { get; }
    public RegexEmbeddedLanguage(AbstractEmbeddedLanguagesProvider provider, EmbeddedLanguageInfo info);
    [CompilerGeneratedAttribute]
public sealed virtual EmbeddedLanguageCompletionProvider get_CompletionProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexEmbeddedLanguage/<TryGetTreeAndTokenAtPositionAsync>d__6")]
internal Task`1<ValueTuple`2<RegexTree, SyntaxToken>> TryGetTreeAndTokenAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    public string EscapeText(string text, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Features.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexLanguageDetector : AbstractLanguageDetector`4<RegexOptions, RegexTree, RegexLanguageDetector, RegexInfo> {
    private static string _patternName;
    [NullableAttribute("2")]
private INamedTypeSymbol _regexType;
    private HashSet`1<string> _methodNamesOfInterest;
    public RegexLanguageDetector(EmbeddedLanguageInfo info, INamedTypeSymbol regexType, HashSet`1<string> methodNamesOfInterest);
    private static HashSet`1<string> GetMethodNamesOfInterest(INamedTypeSymbol regexType, ISyntaxFacts syntaxFacts);
    protected virtual bool IsArgumentToWellKnownAPI(SyntaxToken token, SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken, RegexOptions& options);
    private bool TryAnalyzeInvocation(INamedTypeSymbol regexType, SyntaxNode argumentNode, SemanticModel semanticModel, ISymbol method, CancellationToken cancellationToken, RegexOptions& options);
    [NullableContextAttribute("2")]
protected virtual RegexTree TryParse(VirtualCharSequence chars, RegexOptions options);
    private bool AnalyzeStringLiteral(SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken, RegexOptions& options);
    protected virtual bool TryGetOptions(SemanticModel semanticModel, ITypeSymbol exprType, SyntaxNode expr, CancellationToken cancellationToken, RegexOptions& options);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Features.Intents.IIntentProvider {
    public abstract virtual Task`1<ImmutableArray`1<IntentProcessorResult>> ComputeIntentAsync(Document priorDocument, TextSpan priorSelection, Document currentDocument, IntentDataProvider intentDataProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Features.Intents.IIntentProviderMetadata {
    public string IntentName { get; }
    public string LanguageName { get; }
    public abstract virtual string get_IntentName();
    public abstract virtual string get_LanguageName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.Intents.IntentDataProvider : object {
    private static Lazy`1<JsonSerializerOptions> s_serializerOptions;
    public CleanCodeGenerationOptionsProvider FallbackOptions;
    [NullableAttribute("2")]
private string _serializedIntentData;
    public IntentDataProvider(string serializedIntentData, CleanCodeGenerationOptionsProvider fallbackOptions);
    private static IntentDataProvider();
    public T GetIntentData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Features.Intents.IntentProcessorResult : ValueType {
    public Solution Solution;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DocumentId> ChangedDocuments;
    public string Title;
    public string ActionName;
    public IntentProcessorResult(Solution solution, ImmutableArray`1<DocumentId> changedDocuments, string title, string actionName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Features.Intents.IntentProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <IntentName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageName>k__BackingField;
    public string IntentName { get; }
    public string LanguageName { get; }
    public IntentProviderAttribute(string intentName, string languageName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_IntentName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LanguageName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Features.Intents.WellKnownIntents : object {
    public static string GenerateConstructor;
    public static string AddConstructorParameter;
    public static string Rename;
    public static string DeleteParameter;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQArrayOrPointerType : RQType {
    public RQType ElementType;
    protected RQArrayOrPointerType(RQType elementType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQArrayType : RQArrayOrPointerType {
    public int Rank;
    public RQArrayType(int rank, RQType elementType);
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQConstructedType : RQType {
    public RQUnconstructedType DefiningType;
    public ReadOnlyCollection`1<RQType> TypeArguments;
    public RQConstructedType(RQUnconstructedType definingType, IList`1<RQType> typeArguments);
    public virtual SimpleTreeNode ToSimpleTree();
}
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQConstructor : RQMethodBase {
    [NullableContextAttribute("1")]
public RQConstructor(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQErrorType : RQType {
    public string Name;
    public RQErrorType(string name);
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQEvent : RQMethodPropertyOrEvent {
    protected string RQKeyword { get; }
    public RQEvent(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName);
    protected virtual string get_RQKeyword();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQExplicitInterfaceMemberName : RQMethodPropertyOrEventName {
    public RQType InterfaceType;
    public RQOrdinaryMethodPropertyOrEventName Name;
    public string OrdinaryNameValue { get; }
    public RQExplicitInterfaceMemberName(RQType interfaceType, RQOrdinaryMethodPropertyOrEventName name);
    public virtual string get_OrdinaryNameValue();
    public virtual SimpleGroupNode ToSimpleTree();
}
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQIndexer : RQPropertyBase {
    [NullableContextAttribute("1")]
public RQIndexer(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMember : RQNode {
    public RQUnconstructedType ContainingType;
    public string MemberName { get; }
    protected RQMember(RQUnconstructedType containingType);
    public abstract virtual string get_MemberName();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMemberParameterIndex : RQNode {
    public RQMember ContainingMember;
    public int ParameterIndex;
    protected string RQKeyword { get; }
    public RQMemberParameterIndex(RQMember containingMember, int parameterIndex);
    protected virtual string get_RQKeyword();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMemberParameterIndexFromPartialImplementation : RQMemberParameterIndex {
    public RQMemberParameterIndexFromPartialImplementation(RQMember containingMember, int parameterIndex);
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMemberParameterIndexFromPartialSignature : RQMemberParameterIndex {
    public RQMemberParameterIndexFromPartialSignature(RQMember containingMember, int parameterIndex);
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMemberVariable : RQMember {
    public string Name;
    public string MemberName { get; }
    protected string RQKeyword { get; }
    public RQMemberVariable(RQUnconstructedType containingType, string name);
    public virtual string get_MemberName();
    protected virtual string get_RQKeyword();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethod : RQMethodBase {
    [NullableContextAttribute("1")]
public RQMethod(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodBase : RQMethodOrProperty {
    protected string RQKeyword { get; }
    protected RQMethodBase(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
    protected virtual string get_RQKeyword();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodOrProperty : RQMethodPropertyOrEvent {
    public int TypeParameterCount;
    public ReadOnlyCollection`1<RQParameter> Parameters;
    protected RQMethodOrProperty(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodPropertyOrEvent : RQMember {
    public RQMethodPropertyOrEventName RqMemberName;
    public string MemberName { get; }
    protected RQMethodPropertyOrEvent(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName);
    public virtual string get_MemberName();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQMethodPropertyOrEventName : object {
    public string OrdinaryNameValue { get; }
    public abstract virtual string get_OrdinaryNameValue();
    public abstract virtual SimpleGroupNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQNamespace : RQTypeOrNamespace {
    protected string RQKeyword { get; }
    public RQNamespace(IList`1<string> namespaceNames);
    protected virtual string get_RQKeyword();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQNode : object {
    protected string RQKeyword { get; }
    protected abstract virtual string get_RQKeyword();
    protected abstract virtual void AppendChildren(List`1<SimpleTreeNode> childList);
    public SimpleGroupNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQNormalParameter : RQParameter {
    public RQNormalParameter(RQType type);
    public virtual SimpleTreeNode CreateSimpleTreeForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQNullType : RQType {
    public static RQNullType Singleton;
    private static RQNullType();
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQOrdinaryMethodPropertyOrEventName : RQMethodPropertyOrEventName {
    private string _constructType;
    public string Name;
    public string OrdinaryNameValue { get; }
    internal RQOrdinaryMethodPropertyOrEventName(string constructType, string name);
    public virtual string get_OrdinaryNameValue();
    public static RQOrdinaryMethodPropertyOrEventName CreateConstructorName();
    public static RQOrdinaryMethodPropertyOrEventName CreateDestructorName();
    public static RQOrdinaryMethodPropertyOrEventName CreateOrdinaryIndexerName();
    public static RQOrdinaryMethodPropertyOrEventName CreateOrdinaryMethodName(string name);
    public static RQOrdinaryMethodPropertyOrEventName CreateOrdinaryEventName(string name);
    public static RQOrdinaryMethodPropertyOrEventName CreateOrdinaryPropertyName(string name);
    public virtual SimpleGroupNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQOutParameter : RQParameter {
    public RQOutParameter(RQType type);
    public virtual SimpleTreeNode CreateSimpleTreeForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQParameter : object {
    public RQType Type;
    protected RQParameter(RQType type);
    public SimpleTreeNode ToSimpleTree();
    public abstract virtual SimpleTreeNode CreateSimpleTreeForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQPointerType : RQArrayOrPointerType {
    public RQPointerType(RQType elementType);
    public virtual SimpleTreeNode ToSimpleTree();
}
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQProperty : RQPropertyBase {
    [NullableContextAttribute("1")]
public RQProperty(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQPropertyBase : RQMethodOrProperty {
    protected string RQKeyword { get; }
    protected RQPropertyBase(RQUnconstructedType containingType, RQMethodPropertyOrEventName memberName, int typeParameterCount, IList`1<RQParameter> parameters);
    protected virtual string get_RQKeyword();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQRefParameter : RQParameter {
    public RQRefParameter(RQType type);
    public virtual SimpleTreeNode CreateSimpleTreeForType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQType : object {
    public static RQType ObjectType;
    private static RQType();
    public abstract virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQTypeOrNamespace : RQNode {
    public ReadOnlyCollection`1<string> NamespaceNames;
    protected RQTypeOrNamespace(IList`1<string> namespaceNames);
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQTypeVariableType : RQType {
    public string Name;
    public RQTypeVariableType(string name);
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQUnconstructedType : RQTypeOrNamespace {
    public ReadOnlyCollection`1<RQUnconstructedTypeInfo> TypeInfos;
    protected string RQKeyword { get; }
    public RQUnconstructedType(IList`1<string> namespaceNames, IList`1<RQUnconstructedTypeInfo> typeInfos);
    protected virtual string get_RQKeyword();
    protected virtual void AppendChildren(List`1<SimpleTreeNode> childList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQUnconstructedTypeInfo : ValueType {
    public string TypeName;
    public int TypeVariableCount;
    public RQUnconstructedTypeInfo(string typeName, int typeVariableCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.Nodes.RQVoidType : RQType {
    public static RQVoidType Singleton;
    private static RQVoidType();
    public virtual SimpleTreeNode ToSimpleTree();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Features.RQName.ParenthesesTreeWriter : object {
    public static string ToParenthesesFormat(SimpleTreeNode tree);
    private static void WriteNode(SimpleTreeNode node, StringBuilder sb);
}
internal static class Microsoft.CodeAnalysis.Features.RQName.RQNameInternal : object {
    [NullableContextAttribute("1")]
public static string From(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.RQName.RQNameStrings : object {
    internal static string Namespace;
    internal static string Agg;
    internal static string MembVar;
    internal static string Event;
    internal static string Meth;
    internal static string Prop;
    internal static string Params;
    internal static string Param;
    internal static string ParamMod;
    internal static string AggType;
    internal static string TypeParams;
    internal static string Array;
    internal static string Pointer;
    internal static string Ref;
    internal static string Out;
    internal static string TyVar;
    internal static string Void;
    internal static string Error;
    internal static string Null;
    internal static string Dynamic;
    internal static string NsName;
    internal static string AggName;
    internal static string MembVarName;
    internal static string MethName;
    internal static string PropName;
    internal static string EventName;
    internal static string IntfExplName;
    internal static string TypeVarCnt;
    internal static string MemberParamIndex;
    internal static string NotPartial;
    internal static string PartialSignature;
    internal static string PartialImplementation;
    internal static string SpecialIndexerName;
    internal static string SpecialConstructorName;
    internal static string SpecialDestructorName;
    internal static string SpecialStaticConstructorName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Features.RQName.RQNodeBuilder : object {
    public static RQNode Build(ISymbol symbol);
    private static RQNamespace BuildNamespace(INamespaceSymbol namespace);
    private static IList`1<string> GetNameParts(INamespaceSymbol namespace);
    private static RQUnconstructedType BuildUnconstructedNamedType(INamedTypeSymbol type);
    private static RQMember BuildField(IFieldSymbol symbol);
    private static RQProperty BuildProperty(IPropertySymbol symbol);
    private static IList`1<RQParameter> BuildParameterList(ImmutableArray`1<IParameterSymbol> parameters);
    private static RQEvent BuildEvent(IEventSymbol symbol);
    private static RQMethod BuildMethod(IMethodSymbol symbol);
    private static RQType BuildType(ITypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Features.RQName.SimpleTree.SimpleGroupNode : SimpleTreeNode {
    private IList`1<SimpleTreeNode> _children;
    public IList`1<SimpleTreeNode> Children { get; }
    public SimpleTreeNode Item { get; }
    public int Count { get; }
    public SimpleGroupNode(string text, IList`1<SimpleTreeNode> children);
    public SimpleGroupNode(string text, string singleLeafChildText);
    public SimpleGroupNode(string text, SimpleTreeNode[] children);
    public IList`1<SimpleTreeNode> get_Children();
    public SimpleTreeNode get_Item(int index);
    public int get_Count();
}
internal class Microsoft.CodeAnalysis.Features.RQName.SimpleTree.SimpleLeafNode : SimpleTreeNode {
    [NullableContextAttribute("1")]
public SimpleLeafNode(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.RQName.SimpleTree.SimpleTreeNode : object {
    public string Text;
    protected SimpleTreeNode(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Features.Testing.AbstractTestMethodFinder`1 : object {
    private static SymbolDisplayFormat s_methodSymbolNoParametersDisplayFormat;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<ITestFrameworkMetadata> TestFrameworkMetadata;
    protected AbstractTestMethodFinder`1(IEnumerable`1<ITestFrameworkMetadata> testFrameworks);
    private static AbstractTestMethodFinder`1();
    protected abstract virtual bool IsTestMethod(TMethodDeclaration method);
    protected abstract virtual bool DescendIntoChildren(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.Testing.AbstractTestMethodFinder`1/<GetPotentialTestMethodsAsync>d__5")]
public sealed virtual Task`1<ImmutableArray`1<SyntaxNode>> GetPotentialTestMethodsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public sealed virtual bool IsMatch(SemanticModel semanticModel, SyntaxNode node, string fullyQualifiedTestName, CancellationToken cancellationToken);
    public sealed virtual bool IsTestMethod(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Features.Testing.AbstractTestMethodFinder`1/<GetPotentialTestNodesAsync>d__8")]
private Task`1<ImmutableArray`1<SyntaxNode>> GetPotentialTestNodesAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Features.Testing.ITestFrameworkMetadata {
    public abstract virtual bool MatchesAttributeSyntacticName(string attributeSyntacticName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Features.Testing.ITestMethodFinder {
    public abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetPotentialTestMethodsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public abstract virtual bool IsTestMethod(SyntaxNode node);
    public abstract virtual bool IsMatch(SemanticModel model, SyntaxNode node, string fullyQualifiedTestName, CancellationToken cancellationToken);
}
[ExportAttribute("Microsoft.CodeAnalysis.Features.Testing.ITestFrameworkMetadata")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Features.Testing.MSTestTestFrameworkMetadata : object {
    [NullableContextAttribute("1")]
public sealed virtual bool MatchesAttributeSyntacticName(string attributeSyntacticName);
}
[ExportAttribute("Microsoft.CodeAnalysis.Features.Testing.ITestFrameworkMetadata")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Features.Testing.NUnitTestFrameworkMetadata : object {
    [NullableContextAttribute("1")]
public sealed virtual bool MatchesAttributeSyntacticName(string attributeSyntacticName);
}
[ExportAttribute("Microsoft.CodeAnalysis.Features.Testing.ITestFrameworkMetadata")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Features.Testing.XUnitTestFrameworkMetadata : object {
    [NullableContextAttribute("1")]
public sealed virtual bool MatchesAttributeSyntacticName(string attributeSyntacticName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Features.Workspaces.LanguageInformation : object {
    [CompilerGeneratedAttribute]
private string <LanguageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptExtension>k__BackingField;
    public string LanguageName { get; }
    public string ScriptExtension { get; }
    public LanguageInformation(string languageName, string scriptExtension);
    [CompilerGeneratedAttribute]
public string get_LanguageName();
    [CompilerGeneratedAttribute]
public string get_ScriptExtension();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Features.Workspaces.MiscellaneousFileUtilities : object {
    internal static ProjectInfo CreateMiscellaneousProjectInfoForDocument(Workspace workspace, string filePath, TextLoader textLoader, LanguageInformation languageInformation, SourceHashAlgorithm checksumAlgorithm, SolutionServices services, ImmutableArray`1<MetadataReference> metadataReferences);
    private static CompilationOptions GetCompilationOptionsWithScriptReferenceResolvers(SolutionServices services, CompilationOptions compilationOptions, string filePath);
}
internal static class Microsoft.CodeAnalysis.FeaturesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string _0_directive { get; }
    internal static string Add_project_reference_to_0 { get; }
    internal static string Add_reference_to_0 { get; }
    internal static string Actions_can_not_be_empty { get; }
    internal static string generic_overload { get; }
    internal static string generic_overloads { get; }
    internal static string overload { get; }
    internal static string overloads_ { get; }
    internal static string type { get; }
    internal static string property_accessor { get; }
    internal static string _0_Keyword { get; }
    internal static string Encapsulate_field_colon_0_and_use_property { get; }
    internal static string Encapsulate_field_colon_0_but_still_use_field { get; }
    internal static string Encapsulate_fields_and_use_property { get; }
    internal static string Encapsulate_fields_but_still_use_field { get; }
    internal static string Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct { get; }
    internal static string Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface { get; }
    internal static string Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket { get; }
    internal static string The_selection_contains_no_active_statement { get; }
    internal static string The_selection_contains_a_local_function_call_without_its_declaration { get; }
    internal static string The_selection_contains_an_error_or_unknown_type { get; }
    internal static string Type_parameter_0_is_hidden_by_another_type_parameter_1 { get; }
    internal static string The_address_of_a_variable_is_used_inside_the_selected_code { get; }
    internal static string Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket { get; }
    internal static string generated_code_is_overlapping_with_hidden_portion_of_the_code { get; }
    internal static string Add_optional_parameters_to_0 { get; }
    internal static string Add_parameters_to_0 { get; }
    internal static string Generate_delegating_constructor_0_1 { get; }
    internal static string Generate_constructor_0_1 { get; }
    internal static string Generate_field_assigning_constructor_0_1 { get; }
    internal static string Generate_Equals_and_GetHashCode { get; }
    internal static string Generate_Equals_object { get; }
    internal static string Generate_GetHashCode { get; }
    internal static string Generate_constructor_in_0 { get; }
    internal static string Generate_all { get; }
    internal static string Generate_enum_member_0 { get; }
    internal static string Generate_constant_0 { get; }
    internal static string Generate_read_only_property_0 { get; }
    internal static string Generate_property_0 { get; }
    internal static string Generate_read_only_field_0 { get; }
    internal static string Generate_field_0 { get; }
    internal static string Generate_local_0 { get; }
    internal static string Generate_0_1_in_new_file { get; }
    internal static string Generate_nested_0_1 { get; }
    internal static string Implement_all_members_explicitly { get; }
    internal static string Implement_interface_abstractly { get; }
    internal static string Implement_interface_through_0 { get; }
    internal static string Implement_interface { get; }
    internal static string Introduce_field_for_0 { get; }
    internal static string Introduce_local_for_0 { get; }
    internal static string Introduce_constant_for_0 { get; }
    internal static string Introduce_local_constant_for_0 { get; }
    internal static string Introduce_field_for_all_occurrences_of_0 { get; }
    internal static string Introduce_local_for_all_occurrences_of_0 { get; }
    internal static string Introduce_constant_for_all_occurrences_of_0 { get; }
    internal static string Introduce_local_constant_for_all_occurrences_of_0 { get; }
    internal static string Introduce_query_variable_for_all_occurrences_of_0 { get; }
    internal static string Introduce_query_variable_for_0 { get; }
    internal static string Types_colon { get; }
    internal static string is_ { get; }
    internal static string Represents_an_object_whose_operations_will_be_resolved_at_runtime { get; }
    internal static string constant { get; }
    internal static string field { get; }
    internal static string local_constant { get; }
    internal static string local_variable { get; }
    internal static string label { get; }
    internal static string range_variable { get; }
    internal static string parameter { get; }
    internal static string discard { get; }
    internal static string in_ { get; }
    internal static string Summary_colon { get; }
    internal static string Locals_and_parameters { get; }
    internal static string Type_parameters_colon { get; }
    internal static string Returns_colon { get; }
    internal static string Exceptions_colon { get; }
    internal static string Remarks_colon { get; }
    internal static string generating_source_for_symbols_of_this_type_is_not_supported { get; }
    internal static string Assembly { get; }
    internal static string location_unknown { get; }
    internal static string Extract_interface { get; }
    internal static string Updating_0_requires_restarting_the_application { get; }
    internal static string Changing_0_to_1_requires_restarting_the_application_because_it_changes_the_shape_of_the_state_machine { get; }
    internal static string Updating_a_complex_statement_containing_an_await_expression_requires_restarting_the_application { get; }
    internal static string Changing_visibility_of_0_requires_restarting_the_application { get; }
    internal static string Ceasing_to_capture_primary_constructor_parameter_0_of_1_requires_restarting_the_application { get; }
    internal static string Changing_attribute_0_requires_restarting_the_application { get; }
    internal static string Changing_name_or_signature_of_0_that_contains_an_active_statement_requires_restarting_the_application { get; }
    internal static string Changing_0_might_not_have_any_effect_until_the_application_is_restarted { get; }
    internal static string Capturing_primary_constructor_parameter_0_that_hasn_t_been_captured_before_requires_restarting_the_application { get; }
    internal static string Changing_the_type_of_a_captured_variable_0_previously_of_type_1_requires_restarting_the_application { get; }
    internal static string Changing_the_parameters_of_0_requires_restarting_the_application { get; }
    internal static string Changing_the_return_type_of_0_requires_restarting_the_application { get; }
    internal static string Changing_the_signature_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime { get; }
    internal static string Changing_the_declaration_scope_of_a_captured_variable_0_requires_restarting_the_application { get; }
    internal static string Adding_0_into_a_1_requires_restarting_the_application { get; }
    internal static string Adding_0_into_an_interface_requires_restarting_the_application { get; }
    internal static string Adding_0_into_an_interface_method_requires_restarting_the_application { get; }
    internal static string Adding_0_into_a_class_with_explicit_or_sequential_layout_requires_restarting_the_application { get; }
    internal static string Updating_the_modifiers_of_0_requires_restarting_the_application { get; }
    internal static string Updating_the_Handles_clause_of_0_requires_restarting_the_application { get; }
    internal static string Adding_0_with_the_Handles_clause_requires_restarting_the_application { get; }
    internal static string Updating_the_Implements_clause_of_a_0_requires_restarting_the_application { get; }
    internal static string Updating_the_variance_of_0_requires_restarting_the_application { get; }
    internal static string Updating_the_type_of_0_requires_restarting_the_application { get; }
    internal static string Updating_the_initializer_of_0_requires_restarting_the_application { get; }
    internal static string Updating_the_size_of_a_0_requires_restarting_the_application { get; }
    internal static string Updating_the_underlying_type_of_0_requires_restarting_the_application { get; }
    internal static string Updating_the_base_class_and_or_base_interface_s_of_0_requires_restarting_the_application { get; }
    internal static string Changing_a_field_to_an_event_or_vice_versa_requires_restarting_the_application { get; }
    internal static string Updating_the_kind_of_a_type_requires_restarting_the_application { get; }
    internal static string Updating_the_kind_of_a_property_event_accessor_requires_restarting_the_application { get; }
    internal static string Updating_the_library_name_of_Declare_statement_requires_restarting_the_application { get; }
    internal static string Updating_the_alias_of_Declare_statement_requires_restarting_the_application { get; }
    internal static string Renaming_0_requires_restarting_the_application { get; }
    internal static string Adding_0_requires_restarting_the_application { get; }
    internal static string Adding_an_abstract_0_or_overriding_an_inherited_0_requires_restarting_the_application { get; }
    internal static string Adding_a_MustOverride_0_or_overriding_an_inherited_0_requires_restarting_the_application { get; }
    internal static string Adding_an_extern_0_requires_restarting_the_application { get; }
    internal static string Adding_an_imported_method_requires_restarting_the_application { get; }
    internal static string Adding_a_user_defined_0_requires_restarting_the_application { get; }
    internal static string Adding_0_around_an_active_statement_requires_restarting_the_application { get; }
    internal static string Moving_0_requires_restarting_the_application { get; }
    internal static string Deleting_0_requires_restarting_the_application { get; }
    internal static string Deleting_0_around_an_active_statement_requires_restarting_the_application { get; }
    internal static string Updating_a_0_around_an_active_statement_requires_restarting_the_application { get; }
    internal static string Updating_async_or_iterator_modifier_around_an_active_statement_requires_restarting_the_application { get; }
    internal static string Changing_0_from_asynchronous_to_synchronous_requires_restarting_the_application { get; }
    internal static string Modifying_a_generic_method_requires_restarting_the_application { get; }
    internal static string Modifying_a_method_inside_the_context_of_a_generic_type_requires_restarting_the_application { get; }
    internal static string Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_requires_restarting_the_application { get; }
    internal static string Renaming_a_captured_variable_from_0_to_1_requires_restarting_the_application { get; }
    internal static string Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_requires_restarting_the_application { get; }
    internal static string Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_requires_restarting_the_application { get; }
    internal static string Modifying_a_catch_handler_around_an_active_statement_requires_restarting_the_application { get; }
    internal static string Modifying_0_which_contains_the_stackalloc_operator_requires_restarting_the_application { get; }
    internal static string Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_requires_restarting_the_application { get; }
    internal static string Modifying_source_with_experimental_language_features_enabled_requires_restarting_the_application { get; }
    internal static string Updating_an_active_statement_requires_restarting_the_application { get; }
    internal static string Removing_0_that_contains_an_active_statement_requires_restarting_the_application { get; }
    internal static string Adding_a_new_file_requires_restarting_the_application { get; }
    internal static string Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_requires_restarting_the_application { get; }
    internal static string Unexpected_interface_member_kind_colon_0 { get; }
    internal static string Generate_abstract_property_0 { get; }
    internal static string Generate_abstract_method_0 { get; }
    internal static string Generate_method_0 { get; }
    internal static string The_symbol_does_not_have_an_icon { get; }
    internal static string Extract_local_function { get; }
    internal static string Extract_method { get; }
    internal static string Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket { get; }
    internal static string The_member_is_defined_in_metadata { get; }
    internal static string You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate { get; }
    internal static string This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue { get; }
    internal static string Change_signature { get; }
    internal static string Generate_new_type { get; }
    internal static string User_Diagnostic_Analyzer_Failure { get; }
    internal static string Analyzer_0_threw_an_exception_of_type_1_with_message_2 { get; }
    internal static string Analyzer_0_threw_the_following_exception_colon_1 { get; }
    internal static string Remove_qualification { get; }
    internal static string Unknown_error_occurred { get; }
    internal static string No_valid_location_to_insert_method_call { get; }
    internal static string Available { get; }
    internal static string Not_Available { get; }
    internal static string _0_1 { get; }
    internal static string You_can_use_the_navigation_bar_to_switch_contexts { get; }
    internal static string in_Source { get; }
    internal static string in_Suppression_File { get; }
    internal static string Remove_Suppression_0 { get; }
    internal static string Remove_Suppression { get; }
    internal static string Configure_0_severity { get; }
    internal static string Configure_0_code_style { get; }
    internal static string Configure_severity_for_all_0_analyzers { get; }
    internal static string Configure_severity_for_all_analyzers { get; }
    internal static string Pending { get; }
    internal static string Awaited_task_returns_0 { get; }
    internal static string Awaited_task_returns_no_value { get; }
    internal static string Note_colon_Tab_twice_to_insert_the_0_snippet { get; }
    internal static string Implement_interface_explicitly_with_Dispose_pattern { get; }
    internal static string Implement_interface_with_Dispose_pattern { get; }
    internal static string Suppress_0 { get; }
    internal static string Computing_fix_all_occurrences_code_fix { get; }
    internal static string Fix_all_occurrences { get; }
    internal static string Document { get; }
    internal static string Project { get; }
    internal static string Solution { get; }
    internal static string Containing_Member { get; }
    internal static string Containing_Type { get; }
    internal static string TODO_colon_dispose_managed_state_managed_objects { get; }
    internal static string TODO_colon_set_large_fields_to_null { get; }
    internal static string Modifying_0_which_contains_a_static_variable_requires_restarting_the_application { get; }
    internal static string Compiler2 { get; }
    internal static string EditAndContinue { get; }
    internal static string Live { get; }
    internal static string namespace_ { get; }
    internal static string class_ { get; }
    internal static string interface_ { get; }
    internal static string enum_ { get; }
    internal static string enum_value { get; }
    internal static string delegate_ { get; }
    internal static string const_field { get; }
    internal static string method { get; }
    internal static string operator_ { get; }
    internal static string constructor { get; }
    internal static string static_constructor { get; }
    internal static string auto_property { get; }
    internal static string property_ { get; }
    internal static string event_ { get; }
    internal static string event_accessor { get; }
    internal static string type_constraint { get; }
    internal static string type_parameter { get; }
    internal static string attribute { get; }
    internal static string Replace_0_and_1_with_property { get; }
    internal static string Replace_0_with_property { get; }
    internal static string Method_referenced_implicitly { get; }
    internal static string Generate_type_0 { get; }
    internal static string Generate_0_1 { get; }
    internal static string Change_0_to_1 { get; }
    internal static string Non_invoked_method_cannot_be_replaced_with_property { get; }
    internal static string Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property { get; }
    internal static string Roslyn_HostError { get; }
    internal static string An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2 { get; }
    internal static string The_assembly_0_does_not_contain_any_analyzers { get; }
    internal static string Unable_to_load_Analyzer_assembly_0_colon_1 { get; }
    internal static string from_0 { get; }
    internal static string Find_and_install_latest_version { get; }
    internal static string Use_local_version_0 { get; }
    internal static string Use_locally_installed_0_version_1_This_version_used_in_colon_2 { get; }
    internal static string Find_and_install_latest_version_of_0 { get; }
    internal static string Install_with_package_manager { get; }
    internal static string Install_0_1 { get; }
    internal static string Install_version_0 { get; }
    internal static string Generate_variable_0 { get; }
    internal static string Classes { get; }
    internal static string Constants { get; }
    internal static string Delegates { get; }
    internal static string Enums { get; }
    internal static string Events { get; }
    internal static string Extension_methods { get; }
    internal static string Fields { get; }
    internal static string Interfaces { get; }
    internal static string Methods { get; }
    internal static string Modules { get; }
    internal static string Namespaces { get; }
    internal static string Properties { get; }
    internal static string Structures { get; }
    internal static string Parameters_colon { get; }
    internal static string Variadic_SignatureHelpItem_must_have_at_least_one_parameter { get; }
    internal static string Replace_0_with_method { get; }
    internal static string Replace_0_with_methods { get; }
    internal static string Property_referenced_implicitly { get; }
    internal static string Property_cannot_safely_be_replaced_with_a_method_call { get; }
    internal static string Convert_to_interpolated_string { get; }
    internal static string Move_type_to_0 { get; }
    internal static string Rename_file_to_0 { get; }
    internal static string Rename_type_to_0 { get; }
    internal static string Asynchronously_waits_for_the_task_to_finish { get; }
    internal static string Await_the_preceding_expression { get; }
    internal static string Await_the_preceding_expression_and_add_ConfigureAwait_0 { get; }
    internal static string paren_Unknown_paren { get; }
    internal static string Implement_abstract_class { get; }
    internal static string Use_framework_type { get; }
    internal static string Install_package_0 { get; }
    internal static string project_0 { get; }
    internal static string Fix_typo_0 { get; }
    internal static string Fully_qualify_0 { get; }
    internal static string Remove_reference_to_0 { get; }
    internal static string Keywords { get; }
    internal static string Snippets { get; }
    internal static string Remove_document_0 { get; }
    internal static string Add_document_0 { get; }
    internal static string Add_argument_name_0 { get; }
    internal static string Add_tuple_element_name_0 { get; }
    internal static string Remove_unused_variable { get; }
    internal static string Convert_to_binary { get; }
    internal static string Convert_to_decimal { get; }
    internal static string Convert_to_hex { get; }
    internal static string Separate_thousands { get; }
    internal static string Separate_words { get; }
    internal static string Separate_nibbles { get; }
    internal static string Remove_separators { get; }
    internal static string Generate_constructor { get; }
    internal static string Pick_members_to_be_used_as_constructor_parameters { get; }
    internal static string Pick_members_to_be_used_in_Equals_GetHashCode { get; }
    internal static string Generate_overrides { get; }
    internal static string Pick_members_to_override { get; }
    internal static string Add_null_check { get; }
    internal static string Add_string_IsNullOrEmpty_check { get; }
    internal static string Add_string_IsNullOrWhiteSpace_check { get; }
    internal static string Create_and_assign_field_0 { get; }
    internal static string Create_and_assign_property_0 { get; }
    internal static string Initialize_field_0 { get; }
    internal static string Initialize_property_0 { get; }
    internal static string Add_null_checks { get; }
    internal static string Generate_operators { get; }
    internal static string Implement_0 { get; }
    internal static string Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed { get; }
    internal static string Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file { get; }
    internal static string in_0_project_1 { get; }
    internal static string Move_declaration_near_reference { get; }
    internal static string Convert_to_full_property { get; }
    internal static string Warning_Method_overrides_symbol_from_metadata { get; }
    internal static string Use_0 { get; }
    internal static string Switching_between_lambda_and_local_function_requires_restarting_the_application { get; }
    internal static string Add_argument_name_0_including_trailing_arguments { get; }
    internal static string local_function { get; }
    internal static string indexer_ { get; }
    internal static string Warning_colon_Collection_was_modified_during_iteration { get; }
    internal static string Warning_colon_Iteration_variable_crossed_function_boundary { get; }
    internal static string Convert_to_linq { get; }
    internal static string Convert_to_class { get; }
    internal static string Convert_to_struct { get; }
    internal static string updating_usages_in_containing_member { get; }
    internal static string updating_usages_in_containing_project { get; }
    internal static string updating_usages_in_containing_type { get; }
    internal static string updating_usages_in_dependent_projects { get; }
    internal static string Formatting_document { get; }
    internal static string Convert_to_linq_call_form { get; }
    internal static string Adding_a_method_with_an_explicit_interface_specifier_requires_restarting_the_application { get; }
    internal static string Modifying_source_file_0_requires_restarting_the_application_due_to_internal_error_1 { get; }
    internal static string Modifying_source_file_0_requires_restarting_the_application_because_the_file_is_too_big { get; }
    internal static string Modifying_body_of_0_requires_restarting_the_application_due_to_internal_error_1 { get; }
    internal static string Modifying_body_of_0_requires_restarting_the_application_because_the_body_has_too_many_statements { get; }
    internal static string Change_namespace_to_0 { get; }
    internal static string Move_file_to_0 { get; }
    internal static string Move_file_to_project_root_folder { get; }
    internal static string Move_to_namespace { get; }
    internal static string Change_to_global_namespace { get; }
    internal static string Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning { get; }
    internal static string Invert_conditional { get; }
    internal static string Replace_0_with_1 { get; }
    internal static string Align_wrapped_parameters { get; }
    internal static string Indent_all_parameters { get; }
    internal static string Indent_wrapped_parameters { get; }
    internal static string Unwrap_all_parameters { get; }
    internal static string Unwrap_and_indent_all_parameters { get; }
    internal static string Wrap_every_parameter { get; }
    internal static string Wrap_long_parameter_list { get; }
    internal static string Unwrap_parameter_list { get; }
    internal static string Align_wrapped_arguments { get; }
    internal static string Indent_all_arguments { get; }
    internal static string Indent_wrapped_arguments { get; }
    internal static string Unwrap_all_arguments { get; }
    internal static string Unwrap_and_indent_all_arguments { get; }
    internal static string Wrap_every_argument { get; }
    internal static string Wrap_long_argument_list { get; }
    internal static string Unwrap_argument_list { get; }
    internal static string Introduce_constant { get; }
    internal static string Introduce_field { get; }
    internal static string Introduce_local { get; }
    internal static string Introduce_query_variable { get; }
    internal static string Failed_to_analyze_data_flow_for_0 { get; }
    internal static string Split_into_nested_0_statements { get; }
    internal static string Merge_with_outer_0_statement { get; }
    internal static string Split_into_consecutive_0_statements { get; }
    internal static string Merge_with_previous_0_statement { get; }
    internal static string Unwrap_expression { get; }
    internal static string Wrap_expression { get; }
    internal static string Wrapping { get; }
    internal static string Merge_with_nested_0_statement { get; }
    internal static string Merge_with_next_0_statement { get; }
    internal static string Pull_0_up { get; }
    internal static string Pull_members_up_to_base_type { get; }
    internal static string Unwrap_call_chain { get; }
    internal static string Wrap_call_chain { get; }
    internal static string Wrap_long_call_chain { get; }
    internal static string Pull_0_up_to_1 { get; }
    internal static string Wrap_and_align_expression { get; }
    internal static string Move_contents_to_namespace { get; }
    internal static string Add_optional_parameter_to_constructor { get; }
    internal static string Add_parameter_to_constructor { get; }
    internal static string Target_type_matches { get; }
    internal static string Generate_parameter_0 { get; }
    internal static string Generate_parameter_0_and_overrides_implementations { get; }
    internal static string in_Source_attribute { get; }
    internal static string StreamMustSupportReadAndSeek { get; }
    internal static string MethodMustReturnStreamThatSupportsReadAndSeek { get; }
    internal static string RudeEdit { get; }
    internal static string CannotApplyChangesUnexpectedError { get; }
    internal static string ErrorReadingFile { get; }
    internal static string EditAndContinueDisallowedByProject { get; }
    internal static string DocumentIsOutOfSyncWithDebuggee { get; }
    internal static string UnableToReadSourceFileOrPdb { get; }
    internal static string ChangesDisallowedWhileStoppedAtException { get; }
    internal static string Wrap_and_align_call_chain { get; }
    internal static string Wrap_and_align_long_call_chain { get; }
    internal static string Warning_colon_semantics_may_change_when_converting_statement { get; }
    internal static string Add_null_checks_for_all_parameters { get; }
    internal static string Implement_0_implicitly { get; }
    internal static string Implement_all_interfaces_implicitly { get; }
    internal static string Implement_implicitly { get; }
    internal static string Implement_0_explicitly { get; }
    internal static string ChangeSignature_NewParameterIntroduceTODOVariable { get; }
    internal static string ChangeSignature_NewParameterOmitValue { get; }
    internal static string Value_colon { get; }
    internal static string Implement_through_0 { get; }
    internal static string Implement_all_interfaces_explicitly { get; }
    internal static string Implement_explicitly { get; }
    internal static string Base_classes_contain_inaccessible_unimplemented_members { get; }
    internal static string Add_DebuggerDisplay_attribute { get; }
    internal static string Do_not_change_this_code_Put_cleanup_code_in_0_method { get; }
    internal static string TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer { get; }
    internal static string TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources { get; }
    internal static string AM_PM_abbreviated { get; }
    internal static string AM_PM_abbreviated_description { get; }
    internal static string AM_PM_full { get; }
    internal static string AM_PM_full_description { get; }
    internal static string date_separator { get; }
    internal static string date_separator_description { get; }
    internal static string day_of_the_month_1_2_digits { get; }
    internal static string day_of_the_month_1_2_digits_description { get; }
    internal static string day_of_the_month_2_digits { get; }
    internal static string day_of_the_month_2_digits_description { get; }
    internal static string day_of_the_week_abbreviated { get; }
    internal static string day_of_the_week_abbreviated_description { get; }
    internal static string day_of_the_week_full { get; }
    internal static string day_of_the_week_full_description { get; }
    internal static string full_long_date_time { get; }
    internal static string full_long_date_time_description { get; }
    internal static string full_short_date_time { get; }
    internal static string full_short_date_time_description { get; }
    internal static string general_long_date_time { get; }
    internal static string general_long_date_time_description { get; }
    internal static string general_short_date_time { get; }
    internal static string general_short_date_time_description { get; }
    internal static string long_date { get; }
    internal static string long_date_description { get; }
    internal static string long_time { get; }
    internal static string long_time_description { get; }
    internal static string minute_1_2_digits { get; }
    internal static string minute_1_2_digits_description { get; }
    internal static string minute_2_digits { get; }
    internal static string minute_2_digits_description { get; }
    internal static string month_1_2_digits { get; }
    internal static string month_1_2_digits_description { get; }
    internal static string month_2_digits { get; }
    internal static string month_2_digits_description { get; }
    internal static string month_abbreviated { get; }
    internal static string month_abbreviated_description { get; }
    internal static string month_day { get; }
    internal static string month_day_description { get; }
    internal static string month_full { get; }
    internal static string month_full_description { get; }
    internal static string period_era { get; }
    internal static string period_era_description { get; }
    internal static string rfc1123_date_time { get; }
    internal static string rfc1123_date_time_description { get; }
    internal static string round_trip_date_time { get; }
    internal static string round_trip_date_time_description { get; }
    internal static string second_1_2_digits { get; }
    internal static string second_1_2_digits_description { get; }
    internal static string second_2_digits { get; }
    internal static string second_2_digits_description { get; }
    internal static string short_date { get; }
    internal static string short_date_description { get; }
    internal static string short_time { get; }
    internal static string short_time_description { get; }
    internal static string sortable_date_time { get; }
    internal static string sortable_date_time_description { get; }
    internal static string time_separator { get; }
    internal static string time_separator_description { get; }
    internal static string time_zone { get; }
    internal static string time_zone_description { get; }
    internal static string universal_full_date_time { get; }
    internal static string universal_full_date_time_description { get; }
    internal static string universal_sortable_date_time { get; }
    internal static string universal_sortable_date_time_description { get; }
    internal static string utc_hour_and_minute_offset { get; }
    internal static string utc_hour_and_minute_offset_description { get; }
    internal static string utc_hour_offset_1_2_digits { get; }
    internal static string utc_hour_offset_1_2_digits_description { get; }
    internal static string utc_hour_offset_2_digits { get; }
    internal static string utc_hour_offset_2_digits_description { get; }
    internal static string year_1_2_digits { get; }
    internal static string year_1_2_digits_description { get; }
    internal static string year_2_digits { get; }
    internal static string year_2_digits_description { get; }
    internal static string year_3_4_digits { get; }
    internal static string year_3_4_digits_description { get; }
    internal static string year_4_digits { get; }
    internal static string year_4_digits_description { get; }
    internal static string year_5_digits { get; }
    internal static string year_5_digits_description { get; }
    internal static string year_month { get; }
    internal static string year_month_description { get; }
    internal static string _10000000ths_of_a_second { get; }
    internal static string _10000000ths_of_a_second_description { get; }
    internal static string _10000000ths_of_a_second_non_zero { get; }
    internal static string _10000000ths_of_a_second_non_zero_description { get; }
    internal static string _1000000ths_of_a_second { get; }
    internal static string _1000000ths_of_a_second_description { get; }
    internal static string _1000000ths_of_a_second_non_zero { get; }
    internal static string _1000000ths_of_a_second_non_zero_description { get; }
    internal static string _100000ths_of_a_second { get; }
    internal static string _100000ths_of_a_second_description { get; }
    internal static string _100000ths_of_a_second_non_zero { get; }
    internal static string _100000ths_of_a_second_non_zero_description { get; }
    internal static string _10000ths_of_a_second { get; }
    internal static string _10000ths_of_a_second_description { get; }
    internal static string _10000ths_of_a_second_non_zero { get; }
    internal static string _10000ths_of_a_second_non_zero_description { get; }
    internal static string _1000ths_of_a_second { get; }
    internal static string _1000ths_of_a_second_description { get; }
    internal static string _1000ths_of_a_second_non_zero { get; }
    internal static string _1000ths_of_a_second_non_zero_description { get; }
    internal static string _100ths_of_a_second { get; }
    internal static string _100ths_of_a_second_description { get; }
    internal static string _100ths_of_a_second_non_zero { get; }
    internal static string _100ths_of_a_second_non_zero_description { get; }
    internal static string _10ths_of_a_second { get; }
    internal static string _10ths_of_a_second_description { get; }
    internal static string _10ths_of_a_second_non_zero { get; }
    internal static string _10ths_of_a_second_non_zero_description { get; }
    internal static string _12_hour_clock_1_2_digits { get; }
    internal static string _12_hour_clock_1_2_digits_description { get; }
    internal static string _12_hour_clock_2_digits { get; }
    internal static string _12_hour_clock_2_digits_description { get; }
    internal static string _24_hour_clock_1_2_digits { get; }
    internal static string _24_hour_clock_1_2_digits_description { get; }
    internal static string _24_hour_clock_2_digits { get; }
    internal static string _24_hour_clock_2_digits_description { get; }
    internal static string Implement_remaining_members_explicitly { get; }
    internal static string Generate_for_0 { get; }
    internal static string Generate_comparison_operators { get; }
    internal static string Create_and_assign_remaining_as_fields { get; }
    internal static string Create_and_assign_remaining_as_properties { get; }
    internal static string Example { get; }
    internal static string Examples { get; }
    internal static string Alternation_conditions_cannot_be_comments { get; }
    internal static string Alternation_conditions_do_not_capture_and_cannot_be_named { get; }
    internal static string A_subtraction_must_be_the_last_element_in_a_character_class { get; }
    internal static string Cannot_include_class_0_in_character_range { get; }
    internal static string Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue { get; }
    internal static string Capture_number_cannot_be_zero { get; }
    internal static string Illegal_backslash_at_end_of_pattern { get; }
    internal static string Illegal_x_y_with_x_less_than_y { get; }
    internal static string Incomplete_character_escape { get; }
    internal static string Insufficient_hexadecimal_digits { get; }
    internal static string Invalid_group_name_Group_names_must_begin_with_a_word_character { get; }
    internal static string Malformed { get; }
    internal static string Malformed_character_escape { get; }
    internal static string Malformed_named_back_reference { get; }
    internal static string Missing_control_character { get; }
    internal static string Nested_quantifier_0 { get; }
    internal static string Not_enough_close_parens { get; }
    internal static string Quantifier_x_y_following_nothing { get; }
    internal static string Reference_to_undefined_group { get; }
    internal static string Reference_to_undefined_group_name_0 { get; }
    internal static string Reference_to_undefined_group_number_0 { get; }
    internal static string Too_many_bars_in_conditional_grouping { get; }
    internal static string Too_many_close_parens { get; }
    internal static string Unknown_property { get; }
    internal static string Unknown_property_0 { get; }
    internal static string Unrecognized_control_character { get; }
    internal static string Unrecognized_escape_sequence_0 { get; }
    internal static string Unrecognized_grouping_construct { get; }
    internal static string Unterminated_character_class_set { get; }
    internal static string Unterminated_regex_comment { get; }
    internal static string x_y_range_in_reverse_order { get; }
    internal static string Regex_issue_0 { get; }
    internal static string Regex_number_decimal_digit { get; }
    internal static string Regex_number_letter { get; }
    internal static string Regex_number_other { get; }
    internal static string Regex_other_control { get; }
    internal static string Regex_other_format { get; }
    internal static string Regex_other_not_assigned { get; }
    internal static string Regex_other_private_use { get; }
    internal static string Regex_other_surrogate { get; }
    internal static string Regex_punctuation_close { get; }
    internal static string Regex_punctuation_connector { get; }
    internal static string Regex_punctuation_dash { get; }
    internal static string Regex_punctuation_final_quote { get; }
    internal static string Regex_punctuation_initial_quote { get; }
    internal static string Regex_punctuation_open { get; }
    internal static string Regex_punctuation_other { get; }
    internal static string Regex_separator_line { get; }
    internal static string Regex_separator_paragraph { get; }
    internal static string Regex_separator_space { get; }
    internal static string Regex_symbol_currency { get; }
    internal static string Regex_symbol_math { get; }
    internal static string Regex_symbol_modifier { get; }
    internal static string Regex_symbol_other { get; }
    internal static string Regex_letter_lowercase { get; }
    internal static string Regex_letter_modifier { get; }
    internal static string Regex_letter_other { get; }
    internal static string Regex_letter_titlecase { get; }
    internal static string Regex_mark_enclosing { get; }
    internal static string Regex_mark_nonspacing { get; }
    internal static string Regex_mark_spacing_combining { get; }
    internal static string Regex_contiguous_matches_long { get; }
    internal static string Regex_contiguous_matches_short { get; }
    internal static string Regex_end_of_string_only_long { get; }
    internal static string Regex_end_of_string_only_short { get; }
    internal static string Regex_end_of_string_or_before_ending_newline_long { get; }
    internal static string Regex_end_of_string_or_before_ending_newline_short { get; }
    internal static string Regex_non_word_boundary_long { get; }
    internal static string Regex_non_word_boundary_short { get; }
    internal static string Regex_start_of_string_only_long { get; }
    internal static string Regex_start_of_string_only_short { get; }
    internal static string Regex_word_boundary_long { get; }
    internal static string Regex_word_boundary_short { get; }
    internal static string Regex_start_of_string_or_line_long { get; }
    internal static string Regex_start_of_string_or_line_short { get; }
    internal static string Regex_end_of_string_or_line_long { get; }
    internal static string Regex_end_of_string_or_line_short { get; }
    internal static string Regex_any_character_group_long { get; }
    internal static string Regex_any_character_group_short { get; }
    internal static string Regex_backspace_character_long { get; }
    internal static string Regex_backspace_character_short { get; }
    internal static string Regex_bell_character_long { get; }
    internal static string Regex_bell_character_short { get; }
    internal static string Regex_carriage_return_character_long { get; }
    internal static string Regex_carriage_return_character_short { get; }
    internal static string Regex_control_character_long { get; }
    internal static string Regex_control_character_short { get; }
    internal static string Regex_decimal_digit_character_long { get; }
    internal static string Regex_decimal_digit_character_short { get; }
    internal static string Regex_escape_character_long { get; }
    internal static string Regex_escape_character_short { get; }
    internal static string Regex_form_feed_character_long { get; }
    internal static string Regex_form_feed_character_short { get; }
    internal static string Regex_hexadecimal_escape_long { get; }
    internal static string Regex_hexadecimal_escape_short { get; }
    internal static string Regex_letter_uppercase { get; }
    internal static string Regex_matched_subexpression_long { get; }
    internal static string Regex_matched_subexpression_short { get; }
    internal static string Regex_negative_character_group_long { get; }
    internal static string Regex_negative_character_group_short { get; }
    internal static string Regex_negative_character_range_long { get; }
    internal static string Regex_negative_unicode_category_long { get; }
    internal static string Regex_negative_unicode_category_short { get; }
    internal static string Regex_new_line_character_long { get; }
    internal static string Regex_new_line_character_short { get; }
    internal static string Regex_non_digit_character_long { get; }
    internal static string Regex_non_digit_character_short { get; }
    internal static string Regex_non_white_space_character_long { get; }
    internal static string Regex_non_white_space_character_short { get; }
    internal static string Regex_non_word_character_long { get; }
    internal static string Regex_non_word_character_short { get; }
    internal static string Regex_positive_character_group_long { get; }
    internal static string Regex_positive_character_group_short { get; }
    internal static string Regex_positive_character_range_long { get; }
    internal static string Regex_positive_character_range_short { get; }
    internal static string Regex_subexpression { get; }
    internal static string Regex_tab_character_long { get; }
    internal static string Regex_tab_character_short { get; }
    internal static string Regex_unicode_category_long { get; }
    internal static string Regex_unicode_category_short { get; }
    internal static string Regex_unicode_escape_long { get; }
    internal static string Regex_unicode_escape_short { get; }
    internal static string Regex_vertical_tab_character_long { get; }
    internal static string Regex_vertical_tab_character_short { get; }
    internal static string Regex_white_space_character_long { get; }
    internal static string Regex_white_space_character_short { get; }
    internal static string Regex_word_character_long { get; }
    internal static string Regex_word_character_short { get; }
    internal static string Regex_alternation_long { get; }
    internal static string Regex_alternation_short { get; }
    internal static string Regex_balancing_group_long { get; }
    internal static string Regex_balancing_group_short { get; }
    internal static string Regex_comment { get; }
    internal static string Regex_conditional_expression_match_long { get; }
    internal static string Regex_conditional_expression_match_short { get; }
    internal static string Regex_conditional_group_match_long { get; }
    internal static string Regex_conditional_group_match_short { get; }
    internal static string Regex_end_of_line_comment_long { get; }
    internal static string Regex_end_of_line_comment_short { get; }
    internal static string Regex_expression { get; }
    internal static string Regex_group_options_long { get; }
    internal static string Regex_group_options_short { get; }
    internal static string Regex_inline_comment_long { get; }
    internal static string Regex_inline_comment_short { get; }
    internal static string Regex_name { get; }
    internal static string Regex_name1 { get; }
    internal static string Regex_name2 { get; }
    internal static string Regex_named_backreference_long { get; }
    internal static string Regex_named_backreference_short { get; }
    internal static string Regex_named_matched_subexpression_long { get; }
    internal static string Regex_named_matched_subexpression_short { get; }
    internal static string Regex_name_or_number { get; }
    internal static string Regex_no { get; }
    internal static string Regex_atomic_group_long { get; }
    internal static string Regex_atomic_group_short { get; }
    internal static string Regex_noncapturing_group_long { get; }
    internal static string Regex_noncapturing_group_short { get; }
    internal static string Regex_numbered_backreference_long { get; }
    internal static string Regex_numbered_backreference_short { get; }
    internal static string Regex_yes { get; }
    internal static string Regex_zero_width_negative_lookahead_assertion_long { get; }
    internal static string Regex_zero_width_negative_lookahead_assertion_short { get; }
    internal static string Regex_zero_width_negative_lookbehind_assertion_long { get; }
    internal static string Regex_zero_width_negative_lookbehind_assertion_short { get; }
    internal static string Regex_zero_width_positive_lookahead_assertion_long { get; }
    internal static string Regex_zero_width_positive_lookahead_assertion_short { get; }
    internal static string Regex_zero_width_positive_lookbehind_assertion_long { get; }
    internal static string Regex_zero_width_positive_lookbehind_assertion_short { get; }
    internal static string Regex_all_control_characters_long { get; }
    internal static string Regex_all_control_characters_short { get; }
    internal static string Regex_all_diacritic_marks_long { get; }
    internal static string Regex_all_diacritic_marks_short { get; }
    internal static string Regex_all_letter_characters_long { get; }
    internal static string Regex_all_letter_characters_short { get; }
    internal static string Regex_all_numbers_long { get; }
    internal static string Regex_all_numbers_short { get; }
    internal static string Regex_all_punctuation_characters_long { get; }
    internal static string Regex_all_punctuation_characters_short { get; }
    internal static string Regex_all_separator_characters_long { get; }
    internal static string Regex_all_separator_characters_short { get; }
    internal static string Regex_all_symbols_long { get; }
    internal static string Regex_all_symbols_short { get; }
    internal static string Regex_base_group { get; }
    internal static string Regex_character_class_subtraction_long { get; }
    internal static string Regex_character_class_subtraction_short { get; }
    internal static string Regex_character_group { get; }
    internal static string Regex_excluded_group { get; }
    internal static string Regex_match_at_least_n_times_lazy_long { get; }
    internal static string Regex_match_at_least_n_times_lazy_short { get; }
    internal static string Regex_match_at_least_n_times_long { get; }
    internal static string Regex_match_at_least_n_times_short { get; }
    internal static string Regex_match_between_m_and_n_times_lazy_long { get; }
    internal static string Regex_match_between_m_and_n_times_lazy_short { get; }
    internal static string Regex_match_between_m_and_n_times_long { get; }
    internal static string Regex_match_between_m_and_n_times_short { get; }
    internal static string Regex_match_exactly_n_times_lazy_long { get; }
    internal static string Regex_match_exactly_n_times_lazy_short { get; }
    internal static string Regex_match_exactly_n_times_long { get; }
    internal static string Regex_match_exactly_n_times_short { get; }
    internal static string Regex_match_one_or_more_times_lazy_long { get; }
    internal static string Regex_match_one_or_more_times_lazy_short { get; }
    internal static string Regex_match_one_or_more_times_long { get; }
    internal static string Regex_match_one_or_more_times_short { get; }
    internal static string Regex_match_zero_or_more_times_lazy_long { get; }
    internal static string Regex_match_zero_or_more_times_lazy_short { get; }
    internal static string Regex_match_zero_or_more_times_long { get; }
    internal static string Regex_match_zero_or_more_times_short { get; }
    internal static string Regex_match_zero_or_one_time_lazy_long { get; }
    internal static string Regex_match_zero_or_one_time_lazy_short { get; }
    internal static string Regex_match_zero_or_one_time_long { get; }
    internal static string Regex_match_zero_or_one_time_short { get; }
    internal static string Regex_unicode_general_category_0 { get; }
    internal static string Regex_inline_options_long { get; }
    internal static string Regex_inline_options_short { get; }
    internal static string _0_cannot_be_null_or_empty { get; }
    internal static string _0_cannot_be_null_or_whitespace { get; }
    internal static string _0_is_not_null_here { get; }
    internal static string _0_may_be_null_here { get; }
    internal static string ChangeSignature_NewParameterInferValue { get; }
    internal static string from_metadata { get; }
    internal static string symbol_cannot_be_a_namespace { get; }
    internal static string Document_must_be_contained_in_the_workspace_that_created_this_service { get; }
    internal static string Generate_constructor_in_0_with_fields { get; }
    internal static string Generate_constructor_in_0_with_properties { get; }
    internal static string Property_reference_cannot_be_updated { get; }
    internal static string Inline_0 { get; }
    internal static string Extract_base_class { get; }
    internal static string Inline_and_keep_0 { get; }
    internal static string Operators { get; }
    internal static string The_assembly_0_containing_type_1_references_NET_Framework { get; }
    internal static string The_assembly_0_references_compiler_version_1_newer_than_2 { get; }
    internal static string Apply_file_header_preferences { get; }
    internal static string Apply_object_collection_initialization_preferences { get; }
    internal static string Remove_unnecessary_casts { get; }
    internal static string Remove_unused_variables { get; }
    internal static string Sort_accessibility_modifiers { get; }
    internal static string Error_creating_instance_of_CodeFixProvider { get; }
    internal static string Error_creating_instance_of_CodeFixProvider_0 { get; }
    internal static string Removal_of_document_not_supported { get; }
    internal static string in_0_1_2 { get; }
    internal static string _0_dash_1 { get; }
    internal static string all_anonymous_types_in_container { get; }
    internal static string Convert_to_tuple { get; }
    internal static string just_this_anonymous_type { get; }
    internal static string member_kind_and_name { get; }
    internal static string symbol_kind_and_name_of_member_kind_and_name { get; }
    internal static string code { get; }
    internal static string Convert_to_record { get; }
    internal static string Introduce_parameter_for_0 { get; }
    internal static string Introduce_parameter_for_all_occurrences_of_0 { get; }
    internal static string into_new_overload { get; }
    internal static string into_extracted_method_to_invoke_at_call_sites { get; }
    internal static string and_update_call_sites_directly { get; }
    internal static string Convert_to_record_struct { get; }
    internal static string Applying_source_changes_while_the_application_is_running_is_not_supported_by_the_runtime { get; }
    internal static string Updating_reloadable_type_marked_by_0_attribute_or_its_member_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime { get; }
    internal static string Making_a_method_an_iterator_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime { get; }
    internal static string Making_a_method_asynchronous_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime { get; }
    internal static string Updating_the_attributes_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime { get; }
    internal static string An_update_that_causes_the_return_type_of_implicit_main_to_change_requires_restarting_the_application { get; }
    internal static string Changing_parameter_types_of_0_requires_restarting_the_application { get; }
    internal static string Changing_type_parameters_of_0_requires_restarting_the_application { get; }
    internal static string Changing_constraints_of_0_requires_restarting_the_application { get; }
    internal static string No_common_root_node_for_extraction { get; }
    internal static string No_valid_selection_to_perform_extraction { get; }
    internal static string Selection_does_not_contain_a_valid_token { get; }
    internal static string Selection_not_contained_inside_a_type { get; }
    internal static string Invalid_selection { get; }
    internal static string Renaming_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime { get; }
    internal static string Move_static_members_to_another_type { get; }
    internal static string Changing_pseudo_custom_attribute_0_of_1_requires_restarting_th_application { get; }
    internal static string Changing_the_containing_namespace_of_0_from_1_to_2_requires_restarting_th_application { get; }
    internal static string ChangesRequiredSynthesizedType { get; }
    internal static string Miscellaneous_Files { get; }
    internal static string Silent { get; }
    internal static string console_writeline { get; }
    internal static string embedded { get; }
    internal static string external { get; }
    internal static string Could_not_find_PDB_on_disk_or_embedded { get; }
    internal static string Error_reading_PDB_0 { get; }
    internal static string Found_embedded_PDB_file { get; }
    internal static string Found_PDB_file_at_0 { get; }
    internal static string Found_PDB_on_symbol_server { get; }
    internal static string Found_PDB_on_symbol_server_but_could_not_read_file { get; }
    internal static string Navigating_to_symbol_0_from_1 { get; }
    internal static string No_source_document_info_found_in_PDB { get; }
    internal static string Source_code_language_information_was_not_found_in_PDB { get; }
    internal static string Source_is_a_reference_assembly { get; }
    internal static string _0_found_in_embedded_PDB { get; }
    internal static string _0_found_in_embedded_PDB_but_checksum_failed { get; }
    internal static string _0_found_in_embedded_PDB_but_could_not_write_file_1 { get; }
    internal static string _0_found_in_embedded_PDB_cached_source_file { get; }
    internal static string _0_found_via_SourceLink { get; }
    internal static string _0_found_via_SourceLink_but_couldnt_read_file { get; }
    internal static string _0_found_in_original_location { get; }
    internal static string _0_found_in_original_location_but_checksum_failed { get; }
    internal static string Could_not_find_PDB_on_disk_or_embedded_or_server { get; }
    internal static string Timeout_SourceLink { get; }
    internal static string Timeout_symbol_server { get; }
    internal static string Symbol_found_in_assembly_path_0 { get; }
    internal static string Invalid_number { get; }
    internal static string Unterminated_comment { get; }
    internal static string Unterminated_string { get; }
    internal static string _0_expected { get; }
    internal static string _0_unexpected { get; }
    internal static string Invalid_escape_sequence { get; }
    internal static string Error_parsing_comment { get; }
    internal static string Syntax_error { get; }
    internal static string Invalid_property_name { get; }
    internal static string Missing_property_value { get; }
    internal static string Nested_properties_not_allowed { get; }
    internal static string Name_expected { get; }
    internal static string Invalid_constructor_name { get; }
    internal static string Comments_not_allowed { get; }
    internal static string Constructors_not_allowed { get; }
    internal static string Illegal_string_character { get; }
    internal static string Illegal_whitespace_character { get; }
    internal static string Only_properties_allowed_in_an_object { get; }
    internal static string Properties_not_allowed_in_an_array { get; }
    internal static string Property_name_must_be_a_string { get; }
    internal static string Property_name_must_be_followed_by_a_colon { get; }
    internal static string Strings_must_start_with_double_quote_not_single_quote { get; }
    internal static string Trailing_comma_not_allowed { get; }
    internal static string Value_required { get; }
    internal static string _0_literal_not_allowed { get; }
    internal static string JSON_issue_0 { get; }
    internal static string Probable_JSON_string_detected { get; }
    internal static string Enable_all_JSON_editor_features { get; }
    internal static string Invalid_regex_pattern { get; }
    internal static string Invalid_JSON_pattern { get; }
    internal static string Unwrap_initializer { get; }
    internal static string Wrap_initializer { get; }
    internal static string Wrap_long_initializer { get; }
    internal static string Unwrap_collection { get; }
    internal static string Wrap_collection { get; }
    internal static string Wrap_long_collection { get; }
    internal static string Indent_all_elements { get; }
    internal static string Unwrap_all_elements { get; }
    internal static string Cannot_navigate_to_the_symbol_under_the_caret { get; }
    internal static string _0_bases { get; }
    internal static string _0_implementations { get; }
    internal static string _0_references { get; }
    internal static string The_symbol_has_no_base { get; }
    internal static string The_symbol_has_no_implementations { get; }
    internal static string Apply_auto_property_preferences { get; }
    internal static string Apply_blank_line_preferences_experimental { get; }
    internal static string Apply_coalesce_expression_preferences { get; }
    internal static string Apply_compound_assignment_preferences { get; }
    internal static string Apply_inferred_anonymous_type_member_names_preferences { get; }
    internal static string Apply_language_framework_type_preferences { get; }
    internal static string Apply_namespace_matches_folder_preferences { get; }
    internal static string Apply_null_checking_preferences { get; }
    internal static string Apply_null_propagation_preferences { get; }
    internal static string Apply_object_initializer_preferences { get; }
    internal static string Apply_simplify_boolean_expression_preferences { get; }
    internal static string Apply_string_interpolation_preferences { get; }
    internal static string Apply_tuple_name_preferences { get; }
    internal static string Remove_unused_suppressions { get; }
    internal static string Apply_parentheses_preferences { get; }
    internal static string Apply_statement_after_block_preferences_experimental { get; }
    internal static string Apply_unused_value_preferences { get; }
    internal static string Remove_unused_parameters { get; }
    internal static string Apply_conditional_expression_preferences { get; }
    internal static string Apply_using_directive_placement_preferences { get; }
    internal static string Remove_unnecessary_imports_or_usings { get; }
    internal static string Sort_Imports_or_usings { get; }
    internal static string if_statement { get; }
    internal static string Directives_from_0 { get; }
    internal static string Decompiled { get; }
    internal static string Could_not_find_implementation_of_symbol_0 { get; }
    internal static string Replace_conditional_expression_with_statements { get; }
    internal static string Fixing_0 { get; }
    internal static string Pull_selected_members_up_to_0 { get; }
    internal static string Pull_selected_members_up { get; }
    internal static string Required { get; }
    internal static string foreach_loop { get; }
    internal static string Deleting_0_requires_restarting_the_application_because_is_not_supported_by_the_runtime { get; }
    internal static string Updating_0_within_generic_type_or_method_requires_restarting_the_application_because_is_not_supported_by_the_runtime { get; }
    internal static string Updating_async_or_iterator_requires_restarting_the_application_because_is_not_supported_by_the_runtime { get; }
    internal static string Extract_base_record { get; }
    internal static string Enum_members { get; }
    internal static string struct_ { get; }
    internal static string class_with_explicit_or_sequential_layout { get; }
    internal static string Inline_temporary_variable { get; }
    internal static string while_loop { get; }
    internal static string else_statement { get; }
    internal static string Code_snippet_for_0 { get; }
    internal static string Please_resolve_errors_in_your_code_before_renaming_this_element { get; }
    internal static string Renaming_anonymous_type_members_is_not_yet_supported { get; }
    internal static string You_cannot_rename_elements_from_previous_submissions { get; }
    internal static string You_cannot_rename_elements_that_are_defined_in_metadata { get; }
    internal static string You_cannot_rename_operators { get; }
    internal static string You_cannot_rename_this_element { get; }
    internal static string You_must_rename_an_identifier { get; }
    internal static string get_only_property { get; }
    internal static string This_0_has_1_references { get; }
    internal static string _0_reference_unquoted { get; }
    internal static string CSharp_VisualBasic_References { get; }
    internal static string _0_references_unquoted { get; }
    internal static string Find_All_References_not_invoked_on_applicable_symbol { get; }
    internal static string Deconstruct_locals_for_0 { get; }
    internal static string Run_All_Tests { get; }
    internal static string Run_Test { get; }
    internal static string Debug_All_Tests { get; }
    internal static string Debug_Test { get; }
    internal static string Chosen_version_0 { get; }
    internal static string Could_not_find_by_name_0 { get; }
    internal static string Decompilation_log { get; }
    internal static string Found_0_assemblies_for_1 { get; }
    internal static string Found_exact_match_0 { get; }
    internal static string Found_higher_version_match_0 { get; }
    internal static string Found_single_assembly_0 { get; }
    internal static string Load_from_0 { get; }
    internal static string Module_not_found { get; }
    internal static string Resolve_0 { get; }
    internal static string Resolve_module_0_of_1 { get; }
    internal static string WARN_Version_mismatch_Expected_0_Got_1 { get; }
    internal static string _0_items_in_cache { get; }
    internal static string Convert_number { get; }
    internal static string Fix_All_0 { get; }
    internal static string Built_in_Copilot_analysis { get; }
    internal static string Dismiss { get; }
    internal static string Symbols { get; }
    internal static string SemanticSearch { get; }
    internal static string Query { get; }
    internal static string Semantic_search_only_supported_on_net_core { get; }
    internal static string Semantic_search_query_terminated_with_exception { get; }
    internal static string Semantic_search_query_failed_to_compile { get; }
    internal static string The_query_does_not_specify_0_method_or_top_level_function { get; }
    internal static string Method_0_must_be_static_and_non_generic { get; }
    internal static string Method_0_must_have_a_single_parameter_of_type_1_and_return_2 { get; }
    internal static string Unable_to_load_type_0_1 { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get__0_directive();
    internal static string get_Add_project_reference_to_0();
    internal static string get_Add_reference_to_0();
    internal static string get_Actions_can_not_be_empty();
    internal static string get_generic_overload();
    internal static string get_generic_overloads();
    internal static string get_overload();
    internal static string get_overloads_();
    internal static string get_type();
    internal static string get_property_accessor();
    internal static string get__0_Keyword();
    internal static string get_Encapsulate_field_colon_0_and_use_property();
    internal static string get_Encapsulate_field_colon_0_but_still_use_field();
    internal static string get_Encapsulate_fields_and_use_property();
    internal static string get_Encapsulate_fields_but_still_use_field();
    internal static string get_Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct();
    internal static string get_Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface();
    internal static string get_Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket();
    internal static string get_The_selection_contains_no_active_statement();
    internal static string get_The_selection_contains_a_local_function_call_without_its_declaration();
    internal static string get_The_selection_contains_an_error_or_unknown_type();
    internal static string get_Type_parameter_0_is_hidden_by_another_type_parameter_1();
    internal static string get_The_address_of_a_variable_is_used_inside_the_selected_code();
    internal static string get_Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket();
    internal static string get_generated_code_is_overlapping_with_hidden_portion_of_the_code();
    internal static string get_Add_optional_parameters_to_0();
    internal static string get_Add_parameters_to_0();
    internal static string get_Generate_delegating_constructor_0_1();
    internal static string get_Generate_constructor_0_1();
    internal static string get_Generate_field_assigning_constructor_0_1();
    internal static string get_Generate_Equals_and_GetHashCode();
    internal static string get_Generate_Equals_object();
    internal static string get_Generate_GetHashCode();
    internal static string get_Generate_constructor_in_0();
    internal static string get_Generate_all();
    internal static string get_Generate_enum_member_0();
    internal static string get_Generate_constant_0();
    internal static string get_Generate_read_only_property_0();
    internal static string get_Generate_property_0();
    internal static string get_Generate_read_only_field_0();
    internal static string get_Generate_field_0();
    internal static string get_Generate_local_0();
    internal static string get_Generate_0_1_in_new_file();
    internal static string get_Generate_nested_0_1();
    internal static string get_Implement_all_members_explicitly();
    internal static string get_Implement_interface_abstractly();
    internal static string get_Implement_interface_through_0();
    internal static string get_Implement_interface();
    internal static string get_Introduce_field_for_0();
    internal static string get_Introduce_local_for_0();
    internal static string get_Introduce_constant_for_0();
    internal static string get_Introduce_local_constant_for_0();
    internal static string get_Introduce_field_for_all_occurrences_of_0();
    internal static string get_Introduce_local_for_all_occurrences_of_0();
    internal static string get_Introduce_constant_for_all_occurrences_of_0();
    internal static string get_Introduce_local_constant_for_all_occurrences_of_0();
    internal static string get_Introduce_query_variable_for_all_occurrences_of_0();
    internal static string get_Introduce_query_variable_for_0();
    internal static string get_Types_colon();
    internal static string get_is_();
    internal static string get_Represents_an_object_whose_operations_will_be_resolved_at_runtime();
    internal static string get_constant();
    internal static string get_field();
    internal static string get_local_constant();
    internal static string get_local_variable();
    internal static string get_label();
    internal static string get_range_variable();
    internal static string get_parameter();
    internal static string get_discard();
    internal static string get_in_();
    internal static string get_Summary_colon();
    internal static string get_Locals_and_parameters();
    internal static string get_Type_parameters_colon();
    internal static string get_Returns_colon();
    internal static string get_Exceptions_colon();
    internal static string get_Remarks_colon();
    internal static string get_generating_source_for_symbols_of_this_type_is_not_supported();
    internal static string get_Assembly();
    internal static string get_location_unknown();
    internal static string get_Extract_interface();
    internal static string get_Updating_0_requires_restarting_the_application();
    internal static string get_Changing_0_to_1_requires_restarting_the_application_because_it_changes_the_shape_of_the_state_machine();
    internal static string get_Updating_a_complex_statement_containing_an_await_expression_requires_restarting_the_application();
    internal static string get_Changing_visibility_of_0_requires_restarting_the_application();
    internal static string get_Ceasing_to_capture_primary_constructor_parameter_0_of_1_requires_restarting_the_application();
    internal static string get_Changing_attribute_0_requires_restarting_the_application();
    internal static string get_Changing_name_or_signature_of_0_that_contains_an_active_statement_requires_restarting_the_application();
    internal static string get_Changing_0_might_not_have_any_effect_until_the_application_is_restarted();
    internal static string get_Capturing_primary_constructor_parameter_0_that_hasn_t_been_captured_before_requires_restarting_the_application();
    internal static string get_Changing_the_type_of_a_captured_variable_0_previously_of_type_1_requires_restarting_the_application();
    internal static string get_Changing_the_parameters_of_0_requires_restarting_the_application();
    internal static string get_Changing_the_return_type_of_0_requires_restarting_the_application();
    internal static string get_Changing_the_signature_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime();
    internal static string get_Changing_the_declaration_scope_of_a_captured_variable_0_requires_restarting_the_application();
    internal static string get_Adding_0_into_a_1_requires_restarting_the_application();
    internal static string get_Adding_0_into_an_interface_requires_restarting_the_application();
    internal static string get_Adding_0_into_an_interface_method_requires_restarting_the_application();
    internal static string get_Adding_0_into_a_class_with_explicit_or_sequential_layout_requires_restarting_the_application();
    internal static string get_Updating_the_modifiers_of_0_requires_restarting_the_application();
    internal static string get_Updating_the_Handles_clause_of_0_requires_restarting_the_application();
    internal static string get_Adding_0_with_the_Handles_clause_requires_restarting_the_application();
    internal static string get_Updating_the_Implements_clause_of_a_0_requires_restarting_the_application();
    internal static string get_Updating_the_variance_of_0_requires_restarting_the_application();
    internal static string get_Updating_the_type_of_0_requires_restarting_the_application();
    internal static string get_Updating_the_initializer_of_0_requires_restarting_the_application();
    internal static string get_Updating_the_size_of_a_0_requires_restarting_the_application();
    internal static string get_Updating_the_underlying_type_of_0_requires_restarting_the_application();
    internal static string get_Updating_the_base_class_and_or_base_interface_s_of_0_requires_restarting_the_application();
    internal static string get_Changing_a_field_to_an_event_or_vice_versa_requires_restarting_the_application();
    internal static string get_Updating_the_kind_of_a_type_requires_restarting_the_application();
    internal static string get_Updating_the_kind_of_a_property_event_accessor_requires_restarting_the_application();
    internal static string get_Updating_the_library_name_of_Declare_statement_requires_restarting_the_application();
    internal static string get_Updating_the_alias_of_Declare_statement_requires_restarting_the_application();
    internal static string get_Renaming_0_requires_restarting_the_application();
    internal static string get_Adding_0_requires_restarting_the_application();
    internal static string get_Adding_an_abstract_0_or_overriding_an_inherited_0_requires_restarting_the_application();
    internal static string get_Adding_a_MustOverride_0_or_overriding_an_inherited_0_requires_restarting_the_application();
    internal static string get_Adding_an_extern_0_requires_restarting_the_application();
    internal static string get_Adding_an_imported_method_requires_restarting_the_application();
    internal static string get_Adding_a_user_defined_0_requires_restarting_the_application();
    internal static string get_Adding_0_around_an_active_statement_requires_restarting_the_application();
    internal static string get_Moving_0_requires_restarting_the_application();
    internal static string get_Deleting_0_requires_restarting_the_application();
    internal static string get_Deleting_0_around_an_active_statement_requires_restarting_the_application();
    internal static string get_Updating_a_0_around_an_active_statement_requires_restarting_the_application();
    internal static string get_Updating_async_or_iterator_modifier_around_an_active_statement_requires_restarting_the_application();
    internal static string get_Changing_0_from_asynchronous_to_synchronous_requires_restarting_the_application();
    internal static string get_Modifying_a_generic_method_requires_restarting_the_application();
    internal static string get_Modifying_a_method_inside_the_context_of_a_generic_type_requires_restarting_the_application();
    internal static string get_Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_requires_restarting_the_application();
    internal static string get_Renaming_a_captured_variable_from_0_to_1_requires_restarting_the_application();
    internal static string get_Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_requires_restarting_the_application();
    internal static string get_Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_requires_restarting_the_application();
    internal static string get_Modifying_a_catch_handler_around_an_active_statement_requires_restarting_the_application();
    internal static string get_Modifying_0_which_contains_the_stackalloc_operator_requires_restarting_the_application();
    internal static string get_Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_requires_restarting_the_application();
    internal static string get_Modifying_source_with_experimental_language_features_enabled_requires_restarting_the_application();
    internal static string get_Updating_an_active_statement_requires_restarting_the_application();
    internal static string get_Removing_0_that_contains_an_active_statement_requires_restarting_the_application();
    internal static string get_Adding_a_new_file_requires_restarting_the_application();
    internal static string get_Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_requires_restarting_the_application();
    internal static string get_Unexpected_interface_member_kind_colon_0();
    internal static string get_Generate_abstract_property_0();
    internal static string get_Generate_abstract_method_0();
    internal static string get_Generate_method_0();
    internal static string get_The_symbol_does_not_have_an_icon();
    internal static string get_Extract_local_function();
    internal static string get_Extract_method();
    internal static string get_Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket();
    internal static string get_The_member_is_defined_in_metadata();
    internal static string get_You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate();
    internal static string get_This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue();
    internal static string get_Change_signature();
    internal static string get_Generate_new_type();
    internal static string get_User_Diagnostic_Analyzer_Failure();
    internal static string get_Analyzer_0_threw_an_exception_of_type_1_with_message_2();
    internal static string get_Analyzer_0_threw_the_following_exception_colon_1();
    internal static string get_Remove_qualification();
    internal static string get_Unknown_error_occurred();
    internal static string get_No_valid_location_to_insert_method_call();
    internal static string get_Available();
    internal static string get_Not_Available();
    internal static string get__0_1();
    internal static string get_You_can_use_the_navigation_bar_to_switch_contexts();
    internal static string get_in_Source();
    internal static string get_in_Suppression_File();
    internal static string get_Remove_Suppression_0();
    internal static string get_Remove_Suppression();
    internal static string get_Configure_0_severity();
    internal static string get_Configure_0_code_style();
    internal static string get_Configure_severity_for_all_0_analyzers();
    internal static string get_Configure_severity_for_all_analyzers();
    internal static string get_Pending();
    internal static string get_Awaited_task_returns_0();
    internal static string get_Awaited_task_returns_no_value();
    internal static string get_Note_colon_Tab_twice_to_insert_the_0_snippet();
    internal static string get_Implement_interface_explicitly_with_Dispose_pattern();
    internal static string get_Implement_interface_with_Dispose_pattern();
    internal static string get_Suppress_0();
    internal static string get_Computing_fix_all_occurrences_code_fix();
    internal static string get_Fix_all_occurrences();
    internal static string get_Document();
    internal static string get_Project();
    internal static string get_Solution();
    internal static string get_Containing_Member();
    internal static string get_Containing_Type();
    internal static string get_TODO_colon_dispose_managed_state_managed_objects();
    internal static string get_TODO_colon_set_large_fields_to_null();
    internal static string get_Modifying_0_which_contains_a_static_variable_requires_restarting_the_application();
    internal static string get_Compiler2();
    internal static string get_EditAndContinue();
    internal static string get_Live();
    internal static string get_namespace_();
    internal static string get_class_();
    internal static string get_interface_();
    internal static string get_enum_();
    internal static string get_enum_value();
    internal static string get_delegate_();
    internal static string get_const_field();
    internal static string get_method();
    internal static string get_operator_();
    internal static string get_constructor();
    internal static string get_static_constructor();
    internal static string get_auto_property();
    internal static string get_property_();
    internal static string get_event_();
    internal static string get_event_accessor();
    internal static string get_type_constraint();
    internal static string get_type_parameter();
    internal static string get_attribute();
    internal static string get_Replace_0_and_1_with_property();
    internal static string get_Replace_0_with_property();
    internal static string get_Method_referenced_implicitly();
    internal static string get_Generate_type_0();
    internal static string get_Generate_0_1();
    internal static string get_Change_0_to_1();
    internal static string get_Non_invoked_method_cannot_be_replaced_with_property();
    internal static string get_Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property();
    internal static string get_Roslyn_HostError();
    internal static string get_An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2();
    internal static string get_The_assembly_0_does_not_contain_any_analyzers();
    internal static string get_Unable_to_load_Analyzer_assembly_0_colon_1();
    internal static string get_from_0();
    internal static string get_Find_and_install_latest_version();
    internal static string get_Use_local_version_0();
    internal static string get_Use_locally_installed_0_version_1_This_version_used_in_colon_2();
    internal static string get_Find_and_install_latest_version_of_0();
    internal static string get_Install_with_package_manager();
    internal static string get_Install_0_1();
    internal static string get_Install_version_0();
    internal static string get_Generate_variable_0();
    internal static string get_Classes();
    internal static string get_Constants();
    internal static string get_Delegates();
    internal static string get_Enums();
    internal static string get_Events();
    internal static string get_Extension_methods();
    internal static string get_Fields();
    internal static string get_Interfaces();
    internal static string get_Methods();
    internal static string get_Modules();
    internal static string get_Namespaces();
    internal static string get_Properties();
    internal static string get_Structures();
    internal static string get_Parameters_colon();
    internal static string get_Variadic_SignatureHelpItem_must_have_at_least_one_parameter();
    internal static string get_Replace_0_with_method();
    internal static string get_Replace_0_with_methods();
    internal static string get_Property_referenced_implicitly();
    internal static string get_Property_cannot_safely_be_replaced_with_a_method_call();
    internal static string get_Convert_to_interpolated_string();
    internal static string get_Move_type_to_0();
    internal static string get_Rename_file_to_0();
    internal static string get_Rename_type_to_0();
    internal static string get_Asynchronously_waits_for_the_task_to_finish();
    internal static string get_Await_the_preceding_expression();
    internal static string get_Await_the_preceding_expression_and_add_ConfigureAwait_0();
    internal static string get_paren_Unknown_paren();
    internal static string get_Implement_abstract_class();
    internal static string get_Use_framework_type();
    internal static string get_Install_package_0();
    internal static string get_project_0();
    internal static string get_Fix_typo_0();
    internal static string get_Fully_qualify_0();
    internal static string get_Remove_reference_to_0();
    internal static string get_Keywords();
    internal static string get_Snippets();
    internal static string get_Remove_document_0();
    internal static string get_Add_document_0();
    internal static string get_Add_argument_name_0();
    internal static string get_Add_tuple_element_name_0();
    internal static string get_Remove_unused_variable();
    internal static string get_Convert_to_binary();
    internal static string get_Convert_to_decimal();
    internal static string get_Convert_to_hex();
    internal static string get_Separate_thousands();
    internal static string get_Separate_words();
    internal static string get_Separate_nibbles();
    internal static string get_Remove_separators();
    internal static string get_Generate_constructor();
    internal static string get_Pick_members_to_be_used_as_constructor_parameters();
    internal static string get_Pick_members_to_be_used_in_Equals_GetHashCode();
    internal static string get_Generate_overrides();
    internal static string get_Pick_members_to_override();
    internal static string get_Add_null_check();
    internal static string get_Add_string_IsNullOrEmpty_check();
    internal static string get_Add_string_IsNullOrWhiteSpace_check();
    internal static string get_Create_and_assign_field_0();
    internal static string get_Create_and_assign_property_0();
    internal static string get_Initialize_field_0();
    internal static string get_Initialize_property_0();
    internal static string get_Add_null_checks();
    internal static string get_Generate_operators();
    internal static string get_Implement_0();
    internal static string get_Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed();
    internal static string get_Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file();
    internal static string get_in_0_project_1();
    internal static string get_Move_declaration_near_reference();
    internal static string get_Convert_to_full_property();
    internal static string get_Warning_Method_overrides_symbol_from_metadata();
    internal static string get_Use_0();
    internal static string get_Switching_between_lambda_and_local_function_requires_restarting_the_application();
    internal static string get_Add_argument_name_0_including_trailing_arguments();
    internal static string get_local_function();
    internal static string get_indexer_();
    internal static string get_Warning_colon_Collection_was_modified_during_iteration();
    internal static string get_Warning_colon_Iteration_variable_crossed_function_boundary();
    internal static string get_Convert_to_linq();
    internal static string get_Convert_to_class();
    internal static string get_Convert_to_struct();
    internal static string get_updating_usages_in_containing_member();
    internal static string get_updating_usages_in_containing_project();
    internal static string get_updating_usages_in_containing_type();
    internal static string get_updating_usages_in_dependent_projects();
    internal static string get_Formatting_document();
    internal static string get_Convert_to_linq_call_form();
    internal static string get_Adding_a_method_with_an_explicit_interface_specifier_requires_restarting_the_application();
    internal static string get_Modifying_source_file_0_requires_restarting_the_application_due_to_internal_error_1();
    internal static string get_Modifying_source_file_0_requires_restarting_the_application_because_the_file_is_too_big();
    internal static string get_Modifying_body_of_0_requires_restarting_the_application_due_to_internal_error_1();
    internal static string get_Modifying_body_of_0_requires_restarting_the_application_because_the_body_has_too_many_statements();
    internal static string get_Change_namespace_to_0();
    internal static string get_Move_file_to_0();
    internal static string get_Move_file_to_project_root_folder();
    internal static string get_Move_to_namespace();
    internal static string get_Change_to_global_namespace();
    internal static string get_Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning();
    internal static string get_Invert_conditional();
    internal static string get_Replace_0_with_1();
    internal static string get_Align_wrapped_parameters();
    internal static string get_Indent_all_parameters();
    internal static string get_Indent_wrapped_parameters();
    internal static string get_Unwrap_all_parameters();
    internal static string get_Unwrap_and_indent_all_parameters();
    internal static string get_Wrap_every_parameter();
    internal static string get_Wrap_long_parameter_list();
    internal static string get_Unwrap_parameter_list();
    internal static string get_Align_wrapped_arguments();
    internal static string get_Indent_all_arguments();
    internal static string get_Indent_wrapped_arguments();
    internal static string get_Unwrap_all_arguments();
    internal static string get_Unwrap_and_indent_all_arguments();
    internal static string get_Wrap_every_argument();
    internal static string get_Wrap_long_argument_list();
    internal static string get_Unwrap_argument_list();
    internal static string get_Introduce_constant();
    internal static string get_Introduce_field();
    internal static string get_Introduce_local();
    internal static string get_Introduce_query_variable();
    internal static string get_Failed_to_analyze_data_flow_for_0();
    internal static string get_Split_into_nested_0_statements();
    internal static string get_Merge_with_outer_0_statement();
    internal static string get_Split_into_consecutive_0_statements();
    internal static string get_Merge_with_previous_0_statement();
    internal static string get_Unwrap_expression();
    internal static string get_Wrap_expression();
    internal static string get_Wrapping();
    internal static string get_Merge_with_nested_0_statement();
    internal static string get_Merge_with_next_0_statement();
    internal static string get_Pull_0_up();
    internal static string get_Pull_members_up_to_base_type();
    internal static string get_Unwrap_call_chain();
    internal static string get_Wrap_call_chain();
    internal static string get_Wrap_long_call_chain();
    internal static string get_Pull_0_up_to_1();
    internal static string get_Wrap_and_align_expression();
    internal static string get_Move_contents_to_namespace();
    internal static string get_Add_optional_parameter_to_constructor();
    internal static string get_Add_parameter_to_constructor();
    internal static string get_Target_type_matches();
    internal static string get_Generate_parameter_0();
    internal static string get_Generate_parameter_0_and_overrides_implementations();
    internal static string get_in_Source_attribute();
    internal static string get_StreamMustSupportReadAndSeek();
    internal static string get_MethodMustReturnStreamThatSupportsReadAndSeek();
    internal static string get_RudeEdit();
    internal static string get_CannotApplyChangesUnexpectedError();
    internal static string get_ErrorReadingFile();
    internal static string get_EditAndContinueDisallowedByProject();
    internal static string get_DocumentIsOutOfSyncWithDebuggee();
    internal static string get_UnableToReadSourceFileOrPdb();
    internal static string get_ChangesDisallowedWhileStoppedAtException();
    internal static string get_Wrap_and_align_call_chain();
    internal static string get_Wrap_and_align_long_call_chain();
    internal static string get_Warning_colon_semantics_may_change_when_converting_statement();
    internal static string get_Add_null_checks_for_all_parameters();
    internal static string get_Implement_0_implicitly();
    internal static string get_Implement_all_interfaces_implicitly();
    internal static string get_Implement_implicitly();
    internal static string get_Implement_0_explicitly();
    internal static string get_ChangeSignature_NewParameterIntroduceTODOVariable();
    internal static string get_ChangeSignature_NewParameterOmitValue();
    internal static string get_Value_colon();
    internal static string get_Implement_through_0();
    internal static string get_Implement_all_interfaces_explicitly();
    internal static string get_Implement_explicitly();
    internal static string get_Base_classes_contain_inaccessible_unimplemented_members();
    internal static string get_Add_DebuggerDisplay_attribute();
    internal static string get_Do_not_change_this_code_Put_cleanup_code_in_0_method();
    internal static string get_TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer();
    internal static string get_TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources();
    internal static string get_AM_PM_abbreviated();
    internal static string get_AM_PM_abbreviated_description();
    internal static string get_AM_PM_full();
    internal static string get_AM_PM_full_description();
    internal static string get_date_separator();
    internal static string get_date_separator_description();
    internal static string get_day_of_the_month_1_2_digits();
    internal static string get_day_of_the_month_1_2_digits_description();
    internal static string get_day_of_the_month_2_digits();
    internal static string get_day_of_the_month_2_digits_description();
    internal static string get_day_of_the_week_abbreviated();
    internal static string get_day_of_the_week_abbreviated_description();
    internal static string get_day_of_the_week_full();
    internal static string get_day_of_the_week_full_description();
    internal static string get_full_long_date_time();
    internal static string get_full_long_date_time_description();
    internal static string get_full_short_date_time();
    internal static string get_full_short_date_time_description();
    internal static string get_general_long_date_time();
    internal static string get_general_long_date_time_description();
    internal static string get_general_short_date_time();
    internal static string get_general_short_date_time_description();
    internal static string get_long_date();
    internal static string get_long_date_description();
    internal static string get_long_time();
    internal static string get_long_time_description();
    internal static string get_minute_1_2_digits();
    internal static string get_minute_1_2_digits_description();
    internal static string get_minute_2_digits();
    internal static string get_minute_2_digits_description();
    internal static string get_month_1_2_digits();
    internal static string get_month_1_2_digits_description();
    internal static string get_month_2_digits();
    internal static string get_month_2_digits_description();
    internal static string get_month_abbreviated();
    internal static string get_month_abbreviated_description();
    internal static string get_month_day();
    internal static string get_month_day_description();
    internal static string get_month_full();
    internal static string get_month_full_description();
    internal static string get_period_era();
    internal static string get_period_era_description();
    internal static string get_rfc1123_date_time();
    internal static string get_rfc1123_date_time_description();
    internal static string get_round_trip_date_time();
    internal static string get_round_trip_date_time_description();
    internal static string get_second_1_2_digits();
    internal static string get_second_1_2_digits_description();
    internal static string get_second_2_digits();
    internal static string get_second_2_digits_description();
    internal static string get_short_date();
    internal static string get_short_date_description();
    internal static string get_short_time();
    internal static string get_short_time_description();
    internal static string get_sortable_date_time();
    internal static string get_sortable_date_time_description();
    internal static string get_time_separator();
    internal static string get_time_separator_description();
    internal static string get_time_zone();
    internal static string get_time_zone_description();
    internal static string get_universal_full_date_time();
    internal static string get_universal_full_date_time_description();
    internal static string get_universal_sortable_date_time();
    internal static string get_universal_sortable_date_time_description();
    internal static string get_utc_hour_and_minute_offset();
    internal static string get_utc_hour_and_minute_offset_description();
    internal static string get_utc_hour_offset_1_2_digits();
    internal static string get_utc_hour_offset_1_2_digits_description();
    internal static string get_utc_hour_offset_2_digits();
    internal static string get_utc_hour_offset_2_digits_description();
    internal static string get_year_1_2_digits();
    internal static string get_year_1_2_digits_description();
    internal static string get_year_2_digits();
    internal static string get_year_2_digits_description();
    internal static string get_year_3_4_digits();
    internal static string get_year_3_4_digits_description();
    internal static string get_year_4_digits();
    internal static string get_year_4_digits_description();
    internal static string get_year_5_digits();
    internal static string get_year_5_digits_description();
    internal static string get_year_month();
    internal static string get_year_month_description();
    internal static string get__10000000ths_of_a_second();
    internal static string get__10000000ths_of_a_second_description();
    internal static string get__10000000ths_of_a_second_non_zero();
    internal static string get__10000000ths_of_a_second_non_zero_description();
    internal static string get__1000000ths_of_a_second();
    internal static string get__1000000ths_of_a_second_description();
    internal static string get__1000000ths_of_a_second_non_zero();
    internal static string get__1000000ths_of_a_second_non_zero_description();
    internal static string get__100000ths_of_a_second();
    internal static string get__100000ths_of_a_second_description();
    internal static string get__100000ths_of_a_second_non_zero();
    internal static string get__100000ths_of_a_second_non_zero_description();
    internal static string get__10000ths_of_a_second();
    internal static string get__10000ths_of_a_second_description();
    internal static string get__10000ths_of_a_second_non_zero();
    internal static string get__10000ths_of_a_second_non_zero_description();
    internal static string get__1000ths_of_a_second();
    internal static string get__1000ths_of_a_second_description();
    internal static string get__1000ths_of_a_second_non_zero();
    internal static string get__1000ths_of_a_second_non_zero_description();
    internal static string get__100ths_of_a_second();
    internal static string get__100ths_of_a_second_description();
    internal static string get__100ths_of_a_second_non_zero();
    internal static string get__100ths_of_a_second_non_zero_description();
    internal static string get__10ths_of_a_second();
    internal static string get__10ths_of_a_second_description();
    internal static string get__10ths_of_a_second_non_zero();
    internal static string get__10ths_of_a_second_non_zero_description();
    internal static string get__12_hour_clock_1_2_digits();
    internal static string get__12_hour_clock_1_2_digits_description();
    internal static string get__12_hour_clock_2_digits();
    internal static string get__12_hour_clock_2_digits_description();
    internal static string get__24_hour_clock_1_2_digits();
    internal static string get__24_hour_clock_1_2_digits_description();
    internal static string get__24_hour_clock_2_digits();
    internal static string get__24_hour_clock_2_digits_description();
    internal static string get_Implement_remaining_members_explicitly();
    internal static string get_Generate_for_0();
    internal static string get_Generate_comparison_operators();
    internal static string get_Create_and_assign_remaining_as_fields();
    internal static string get_Create_and_assign_remaining_as_properties();
    internal static string get_Example();
    internal static string get_Examples();
    internal static string get_Alternation_conditions_cannot_be_comments();
    internal static string get_Alternation_conditions_do_not_capture_and_cannot_be_named();
    internal static string get_A_subtraction_must_be_the_last_element_in_a_character_class();
    internal static string get_Cannot_include_class_0_in_character_range();
    internal static string get_Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue();
    internal static string get_Capture_number_cannot_be_zero();
    internal static string get_Illegal_backslash_at_end_of_pattern();
    internal static string get_Illegal_x_y_with_x_less_than_y();
    internal static string get_Incomplete_character_escape();
    internal static string get_Insufficient_hexadecimal_digits();
    internal static string get_Invalid_group_name_Group_names_must_begin_with_a_word_character();
    internal static string get_Malformed();
    internal static string get_Malformed_character_escape();
    internal static string get_Malformed_named_back_reference();
    internal static string get_Missing_control_character();
    internal static string get_Nested_quantifier_0();
    internal static string get_Not_enough_close_parens();
    internal static string get_Quantifier_x_y_following_nothing();
    internal static string get_Reference_to_undefined_group();
    internal static string get_Reference_to_undefined_group_name_0();
    internal static string get_Reference_to_undefined_group_number_0();
    internal static string get_Too_many_bars_in_conditional_grouping();
    internal static string get_Too_many_close_parens();
    internal static string get_Unknown_property();
    internal static string get_Unknown_property_0();
    internal static string get_Unrecognized_control_character();
    internal static string get_Unrecognized_escape_sequence_0();
    internal static string get_Unrecognized_grouping_construct();
    internal static string get_Unterminated_character_class_set();
    internal static string get_Unterminated_regex_comment();
    internal static string get_x_y_range_in_reverse_order();
    internal static string get_Regex_issue_0();
    internal static string get_Regex_number_decimal_digit();
    internal static string get_Regex_number_letter();
    internal static string get_Regex_number_other();
    internal static string get_Regex_other_control();
    internal static string get_Regex_other_format();
    internal static string get_Regex_other_not_assigned();
    internal static string get_Regex_other_private_use();
    internal static string get_Regex_other_surrogate();
    internal static string get_Regex_punctuation_close();
    internal static string get_Regex_punctuation_connector();
    internal static string get_Regex_punctuation_dash();
    internal static string get_Regex_punctuation_final_quote();
    internal static string get_Regex_punctuation_initial_quote();
    internal static string get_Regex_punctuation_open();
    internal static string get_Regex_punctuation_other();
    internal static string get_Regex_separator_line();
    internal static string get_Regex_separator_paragraph();
    internal static string get_Regex_separator_space();
    internal static string get_Regex_symbol_currency();
    internal static string get_Regex_symbol_math();
    internal static string get_Regex_symbol_modifier();
    internal static string get_Regex_symbol_other();
    internal static string get_Regex_letter_lowercase();
    internal static string get_Regex_letter_modifier();
    internal static string get_Regex_letter_other();
    internal static string get_Regex_letter_titlecase();
    internal static string get_Regex_mark_enclosing();
    internal static string get_Regex_mark_nonspacing();
    internal static string get_Regex_mark_spacing_combining();
    internal static string get_Regex_contiguous_matches_long();
    internal static string get_Regex_contiguous_matches_short();
    internal static string get_Regex_end_of_string_only_long();
    internal static string get_Regex_end_of_string_only_short();
    internal static string get_Regex_end_of_string_or_before_ending_newline_long();
    internal static string get_Regex_end_of_string_or_before_ending_newline_short();
    internal static string get_Regex_non_word_boundary_long();
    internal static string get_Regex_non_word_boundary_short();
    internal static string get_Regex_start_of_string_only_long();
    internal static string get_Regex_start_of_string_only_short();
    internal static string get_Regex_word_boundary_long();
    internal static string get_Regex_word_boundary_short();
    internal static string get_Regex_start_of_string_or_line_long();
    internal static string get_Regex_start_of_string_or_line_short();
    internal static string get_Regex_end_of_string_or_line_long();
    internal static string get_Regex_end_of_string_or_line_short();
    internal static string get_Regex_any_character_group_long();
    internal static string get_Regex_any_character_group_short();
    internal static string get_Regex_backspace_character_long();
    internal static string get_Regex_backspace_character_short();
    internal static string get_Regex_bell_character_long();
    internal static string get_Regex_bell_character_short();
    internal static string get_Regex_carriage_return_character_long();
    internal static string get_Regex_carriage_return_character_short();
    internal static string get_Regex_control_character_long();
    internal static string get_Regex_control_character_short();
    internal static string get_Regex_decimal_digit_character_long();
    internal static string get_Regex_decimal_digit_character_short();
    internal static string get_Regex_escape_character_long();
    internal static string get_Regex_escape_character_short();
    internal static string get_Regex_form_feed_character_long();
    internal static string get_Regex_form_feed_character_short();
    internal static string get_Regex_hexadecimal_escape_long();
    internal static string get_Regex_hexadecimal_escape_short();
    internal static string get_Regex_letter_uppercase();
    internal static string get_Regex_matched_subexpression_long();
    internal static string get_Regex_matched_subexpression_short();
    internal static string get_Regex_negative_character_group_long();
    internal static string get_Regex_negative_character_group_short();
    internal static string get_Regex_negative_character_range_long();
    internal static string get_Regex_negative_unicode_category_long();
    internal static string get_Regex_negative_unicode_category_short();
    internal static string get_Regex_new_line_character_long();
    internal static string get_Regex_new_line_character_short();
    internal static string get_Regex_non_digit_character_long();
    internal static string get_Regex_non_digit_character_short();
    internal static string get_Regex_non_white_space_character_long();
    internal static string get_Regex_non_white_space_character_short();
    internal static string get_Regex_non_word_character_long();
    internal static string get_Regex_non_word_character_short();
    internal static string get_Regex_positive_character_group_long();
    internal static string get_Regex_positive_character_group_short();
    internal static string get_Regex_positive_character_range_long();
    internal static string get_Regex_positive_character_range_short();
    internal static string get_Regex_subexpression();
    internal static string get_Regex_tab_character_long();
    internal static string get_Regex_tab_character_short();
    internal static string get_Regex_unicode_category_long();
    internal static string get_Regex_unicode_category_short();
    internal static string get_Regex_unicode_escape_long();
    internal static string get_Regex_unicode_escape_short();
    internal static string get_Regex_vertical_tab_character_long();
    internal static string get_Regex_vertical_tab_character_short();
    internal static string get_Regex_white_space_character_long();
    internal static string get_Regex_white_space_character_short();
    internal static string get_Regex_word_character_long();
    internal static string get_Regex_word_character_short();
    internal static string get_Regex_alternation_long();
    internal static string get_Regex_alternation_short();
    internal static string get_Regex_balancing_group_long();
    internal static string get_Regex_balancing_group_short();
    internal static string get_Regex_comment();
    internal static string get_Regex_conditional_expression_match_long();
    internal static string get_Regex_conditional_expression_match_short();
    internal static string get_Regex_conditional_group_match_long();
    internal static string get_Regex_conditional_group_match_short();
    internal static string get_Regex_end_of_line_comment_long();
    internal static string get_Regex_end_of_line_comment_short();
    internal static string get_Regex_expression();
    internal static string get_Regex_group_options_long();
    internal static string get_Regex_group_options_short();
    internal static string get_Regex_inline_comment_long();
    internal static string get_Regex_inline_comment_short();
    internal static string get_Regex_name();
    internal static string get_Regex_name1();
    internal static string get_Regex_name2();
    internal static string get_Regex_named_backreference_long();
    internal static string get_Regex_named_backreference_short();
    internal static string get_Regex_named_matched_subexpression_long();
    internal static string get_Regex_named_matched_subexpression_short();
    internal static string get_Regex_name_or_number();
    internal static string get_Regex_no();
    internal static string get_Regex_atomic_group_long();
    internal static string get_Regex_atomic_group_short();
    internal static string get_Regex_noncapturing_group_long();
    internal static string get_Regex_noncapturing_group_short();
    internal static string get_Regex_numbered_backreference_long();
    internal static string get_Regex_numbered_backreference_short();
    internal static string get_Regex_yes();
    internal static string get_Regex_zero_width_negative_lookahead_assertion_long();
    internal static string get_Regex_zero_width_negative_lookahead_assertion_short();
    internal static string get_Regex_zero_width_negative_lookbehind_assertion_long();
    internal static string get_Regex_zero_width_negative_lookbehind_assertion_short();
    internal static string get_Regex_zero_width_positive_lookahead_assertion_long();
    internal static string get_Regex_zero_width_positive_lookahead_assertion_short();
    internal static string get_Regex_zero_width_positive_lookbehind_assertion_long();
    internal static string get_Regex_zero_width_positive_lookbehind_assertion_short();
    internal static string get_Regex_all_control_characters_long();
    internal static string get_Regex_all_control_characters_short();
    internal static string get_Regex_all_diacritic_marks_long();
    internal static string get_Regex_all_diacritic_marks_short();
    internal static string get_Regex_all_letter_characters_long();
    internal static string get_Regex_all_letter_characters_short();
    internal static string get_Regex_all_numbers_long();
    internal static string get_Regex_all_numbers_short();
    internal static string get_Regex_all_punctuation_characters_long();
    internal static string get_Regex_all_punctuation_characters_short();
    internal static string get_Regex_all_separator_characters_long();
    internal static string get_Regex_all_separator_characters_short();
    internal static string get_Regex_all_symbols_long();
    internal static string get_Regex_all_symbols_short();
    internal static string get_Regex_base_group();
    internal static string get_Regex_character_class_subtraction_long();
    internal static string get_Regex_character_class_subtraction_short();
    internal static string get_Regex_character_group();
    internal static string get_Regex_excluded_group();
    internal static string get_Regex_match_at_least_n_times_lazy_long();
    internal static string get_Regex_match_at_least_n_times_lazy_short();
    internal static string get_Regex_match_at_least_n_times_long();
    internal static string get_Regex_match_at_least_n_times_short();
    internal static string get_Regex_match_between_m_and_n_times_lazy_long();
    internal static string get_Regex_match_between_m_and_n_times_lazy_short();
    internal static string get_Regex_match_between_m_and_n_times_long();
    internal static string get_Regex_match_between_m_and_n_times_short();
    internal static string get_Regex_match_exactly_n_times_lazy_long();
    internal static string get_Regex_match_exactly_n_times_lazy_short();
    internal static string get_Regex_match_exactly_n_times_long();
    internal static string get_Regex_match_exactly_n_times_short();
    internal static string get_Regex_match_one_or_more_times_lazy_long();
    internal static string get_Regex_match_one_or_more_times_lazy_short();
    internal static string get_Regex_match_one_or_more_times_long();
    internal static string get_Regex_match_one_or_more_times_short();
    internal static string get_Regex_match_zero_or_more_times_lazy_long();
    internal static string get_Regex_match_zero_or_more_times_lazy_short();
    internal static string get_Regex_match_zero_or_more_times_long();
    internal static string get_Regex_match_zero_or_more_times_short();
    internal static string get_Regex_match_zero_or_one_time_lazy_long();
    internal static string get_Regex_match_zero_or_one_time_lazy_short();
    internal static string get_Regex_match_zero_or_one_time_long();
    internal static string get_Regex_match_zero_or_one_time_short();
    internal static string get_Regex_unicode_general_category_0();
    internal static string get_Regex_inline_options_long();
    internal static string get_Regex_inline_options_short();
    internal static string get__0_cannot_be_null_or_empty();
    internal static string get__0_cannot_be_null_or_whitespace();
    internal static string get__0_is_not_null_here();
    internal static string get__0_may_be_null_here();
    internal static string get_ChangeSignature_NewParameterInferValue();
    internal static string get_from_metadata();
    internal static string get_symbol_cannot_be_a_namespace();
    internal static string get_Document_must_be_contained_in_the_workspace_that_created_this_service();
    internal static string get_Generate_constructor_in_0_with_fields();
    internal static string get_Generate_constructor_in_0_with_properties();
    internal static string get_Property_reference_cannot_be_updated();
    internal static string get_Inline_0();
    internal static string get_Extract_base_class();
    internal static string get_Inline_and_keep_0();
    internal static string get_Operators();
    internal static string get_The_assembly_0_containing_type_1_references_NET_Framework();
    internal static string get_The_assembly_0_references_compiler_version_1_newer_than_2();
    internal static string get_Apply_file_header_preferences();
    internal static string get_Apply_object_collection_initialization_preferences();
    internal static string get_Remove_unnecessary_casts();
    internal static string get_Remove_unused_variables();
    internal static string get_Sort_accessibility_modifiers();
    internal static string get_Error_creating_instance_of_CodeFixProvider();
    internal static string get_Error_creating_instance_of_CodeFixProvider_0();
    internal static string get_Removal_of_document_not_supported();
    internal static string get_in_0_1_2();
    internal static string get__0_dash_1();
    internal static string get_all_anonymous_types_in_container();
    internal static string get_Convert_to_tuple();
    internal static string get_just_this_anonymous_type();
    internal static string get_member_kind_and_name();
    internal static string get_symbol_kind_and_name_of_member_kind_and_name();
    internal static string get_code();
    internal static string get_Convert_to_record();
    internal static string get_Introduce_parameter_for_0();
    internal static string get_Introduce_parameter_for_all_occurrences_of_0();
    internal static string get_into_new_overload();
    internal static string get_into_extracted_method_to_invoke_at_call_sites();
    internal static string get_and_update_call_sites_directly();
    internal static string get_Convert_to_record_struct();
    internal static string get_Applying_source_changes_while_the_application_is_running_is_not_supported_by_the_runtime();
    internal static string get_Updating_reloadable_type_marked_by_0_attribute_or_its_member_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime();
    internal static string get_Making_a_method_an_iterator_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime();
    internal static string get_Making_a_method_asynchronous_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime();
    internal static string get_Updating_the_attributes_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime();
    internal static string get_An_update_that_causes_the_return_type_of_implicit_main_to_change_requires_restarting_the_application();
    internal static string get_Changing_parameter_types_of_0_requires_restarting_the_application();
    internal static string get_Changing_type_parameters_of_0_requires_restarting_the_application();
    internal static string get_Changing_constraints_of_0_requires_restarting_the_application();
    internal static string get_No_common_root_node_for_extraction();
    internal static string get_No_valid_selection_to_perform_extraction();
    internal static string get_Selection_does_not_contain_a_valid_token();
    internal static string get_Selection_not_contained_inside_a_type();
    internal static string get_Invalid_selection();
    internal static string get_Renaming_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime();
    internal static string get_Move_static_members_to_another_type();
    internal static string get_Changing_pseudo_custom_attribute_0_of_1_requires_restarting_th_application();
    internal static string get_Changing_the_containing_namespace_of_0_from_1_to_2_requires_restarting_th_application();
    internal static string get_ChangesRequiredSynthesizedType();
    internal static string get_Miscellaneous_Files();
    internal static string get_Silent();
    internal static string get_console_writeline();
    internal static string get_embedded();
    internal static string get_external();
    internal static string get_Could_not_find_PDB_on_disk_or_embedded();
    internal static string get_Error_reading_PDB_0();
    internal static string get_Found_embedded_PDB_file();
    internal static string get_Found_PDB_file_at_0();
    internal static string get_Found_PDB_on_symbol_server();
    internal static string get_Found_PDB_on_symbol_server_but_could_not_read_file();
    internal static string get_Navigating_to_symbol_0_from_1();
    internal static string get_No_source_document_info_found_in_PDB();
    internal static string get_Source_code_language_information_was_not_found_in_PDB();
    internal static string get_Source_is_a_reference_assembly();
    internal static string get__0_found_in_embedded_PDB();
    internal static string get__0_found_in_embedded_PDB_but_checksum_failed();
    internal static string get__0_found_in_embedded_PDB_but_could_not_write_file_1();
    internal static string get__0_found_in_embedded_PDB_cached_source_file();
    internal static string get__0_found_via_SourceLink();
    internal static string get__0_found_via_SourceLink_but_couldnt_read_file();
    internal static string get__0_found_in_original_location();
    internal static string get__0_found_in_original_location_but_checksum_failed();
    internal static string get_Could_not_find_PDB_on_disk_or_embedded_or_server();
    internal static string get_Timeout_SourceLink();
    internal static string get_Timeout_symbol_server();
    internal static string get_Symbol_found_in_assembly_path_0();
    internal static string get_Invalid_number();
    internal static string get_Unterminated_comment();
    internal static string get_Unterminated_string();
    internal static string get__0_expected();
    internal static string get__0_unexpected();
    internal static string get_Invalid_escape_sequence();
    internal static string get_Error_parsing_comment();
    internal static string get_Syntax_error();
    internal static string get_Invalid_property_name();
    internal static string get_Missing_property_value();
    internal static string get_Nested_properties_not_allowed();
    internal static string get_Name_expected();
    internal static string get_Invalid_constructor_name();
    internal static string get_Comments_not_allowed();
    internal static string get_Constructors_not_allowed();
    internal static string get_Illegal_string_character();
    internal static string get_Illegal_whitespace_character();
    internal static string get_Only_properties_allowed_in_an_object();
    internal static string get_Properties_not_allowed_in_an_array();
    internal static string get_Property_name_must_be_a_string();
    internal static string get_Property_name_must_be_followed_by_a_colon();
    internal static string get_Strings_must_start_with_double_quote_not_single_quote();
    internal static string get_Trailing_comma_not_allowed();
    internal static string get_Value_required();
    internal static string get__0_literal_not_allowed();
    internal static string get_JSON_issue_0();
    internal static string get_Probable_JSON_string_detected();
    internal static string get_Enable_all_JSON_editor_features();
    internal static string get_Invalid_regex_pattern();
    internal static string get_Invalid_JSON_pattern();
    internal static string get_Unwrap_initializer();
    internal static string get_Wrap_initializer();
    internal static string get_Wrap_long_initializer();
    internal static string get_Unwrap_collection();
    internal static string get_Wrap_collection();
    internal static string get_Wrap_long_collection();
    internal static string get_Indent_all_elements();
    internal static string get_Unwrap_all_elements();
    internal static string get_Cannot_navigate_to_the_symbol_under_the_caret();
    internal static string get__0_bases();
    internal static string get__0_implementations();
    internal static string get__0_references();
    internal static string get_The_symbol_has_no_base();
    internal static string get_The_symbol_has_no_implementations();
    internal static string get_Apply_auto_property_preferences();
    internal static string get_Apply_blank_line_preferences_experimental();
    internal static string get_Apply_coalesce_expression_preferences();
    internal static string get_Apply_compound_assignment_preferences();
    internal static string get_Apply_inferred_anonymous_type_member_names_preferences();
    internal static string get_Apply_language_framework_type_preferences();
    internal static string get_Apply_namespace_matches_folder_preferences();
    internal static string get_Apply_null_checking_preferences();
    internal static string get_Apply_null_propagation_preferences();
    internal static string get_Apply_object_initializer_preferences();
    internal static string get_Apply_simplify_boolean_expression_preferences();
    internal static string get_Apply_string_interpolation_preferences();
    internal static string get_Apply_tuple_name_preferences();
    internal static string get_Remove_unused_suppressions();
    internal static string get_Apply_parentheses_preferences();
    internal static string get_Apply_statement_after_block_preferences_experimental();
    internal static string get_Apply_unused_value_preferences();
    internal static string get_Remove_unused_parameters();
    internal static string get_Apply_conditional_expression_preferences();
    internal static string get_Apply_using_directive_placement_preferences();
    internal static string get_Remove_unnecessary_imports_or_usings();
    internal static string get_Sort_Imports_or_usings();
    internal static string get_if_statement();
    internal static string get_Directives_from_0();
    internal static string get_Decompiled();
    internal static string get_Could_not_find_implementation_of_symbol_0();
    internal static string get_Replace_conditional_expression_with_statements();
    internal static string get_Fixing_0();
    internal static string get_Pull_selected_members_up_to_0();
    internal static string get_Pull_selected_members_up();
    internal static string get_Required();
    internal static string get_foreach_loop();
    internal static string get_Deleting_0_requires_restarting_the_application_because_is_not_supported_by_the_runtime();
    internal static string get_Updating_0_within_generic_type_or_method_requires_restarting_the_application_because_is_not_supported_by_the_runtime();
    internal static string get_Updating_async_or_iterator_requires_restarting_the_application_because_is_not_supported_by_the_runtime();
    internal static string get_Extract_base_record();
    internal static string get_Enum_members();
    internal static string get_struct_();
    internal static string get_class_with_explicit_or_sequential_layout();
    internal static string get_Inline_temporary_variable();
    internal static string get_while_loop();
    internal static string get_else_statement();
    internal static string get_Code_snippet_for_0();
    internal static string get_Please_resolve_errors_in_your_code_before_renaming_this_element();
    internal static string get_Renaming_anonymous_type_members_is_not_yet_supported();
    internal static string get_You_cannot_rename_elements_from_previous_submissions();
    internal static string get_You_cannot_rename_elements_that_are_defined_in_metadata();
    internal static string get_You_cannot_rename_operators();
    internal static string get_You_cannot_rename_this_element();
    internal static string get_You_must_rename_an_identifier();
    internal static string get_get_only_property();
    internal static string get_This_0_has_1_references();
    internal static string get__0_reference_unquoted();
    internal static string get_CSharp_VisualBasic_References();
    internal static string get__0_references_unquoted();
    internal static string get_Find_All_References_not_invoked_on_applicable_symbol();
    internal static string get_Deconstruct_locals_for_0();
    internal static string get_Run_All_Tests();
    internal static string get_Run_Test();
    internal static string get_Debug_All_Tests();
    internal static string get_Debug_Test();
    internal static string get_Chosen_version_0();
    internal static string get_Could_not_find_by_name_0();
    internal static string get_Decompilation_log();
    internal static string get_Found_0_assemblies_for_1();
    internal static string get_Found_exact_match_0();
    internal static string get_Found_higher_version_match_0();
    internal static string get_Found_single_assembly_0();
    internal static string get_Load_from_0();
    internal static string get_Module_not_found();
    internal static string get_Resolve_0();
    internal static string get_Resolve_module_0_of_1();
    internal static string get_WARN_Version_mismatch_Expected_0_Got_1();
    internal static string get__0_items_in_cache();
    internal static string get_Convert_number();
    internal static string get_Fix_All_0();
    internal static string get_Built_in_Copilot_analysis();
    internal static string get_Dismiss();
    internal static string get_Symbols();
    internal static string get_SemanticSearch();
    internal static string get_Query();
    internal static string get_Semantic_search_only_supported_on_net_core();
    internal static string get_Semantic_search_query_terminated_with_exception();
    internal static string get_Semantic_search_query_failed_to_compile();
    internal static string get_The_query_does_not_specify_0_method_or_top_level_function();
    internal static string get_Method_0_must_be_static_and_non_generic();
    internal static string get_Method_0_must_have_a_single_parameter_of_type_1_and_return_2();
    internal static string get_Unable_to_load_type_0_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual AbstractFileHeaderHelper get_FileHeaderHelper();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<GetTransformedDocumentAsync>d__6")]
private Task`1<Document> GetTransformedDocumentAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<GetTransformedSyntaxRootAsync>d__7")]
private Task`1<SyntaxNode> GetTransformedSyntaxRootAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<GetTransformedSyntaxRootAsync>d__8")]
internal static Task`1<SyntaxNode> GetTransformedSyntaxRootAsync(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, Document document, string fileHeaderTemplate, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceHeader(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, SyntaxNode root, string expectedFileHeader);
    private static SyntaxNode AddHeader(ISyntaxFacts syntaxFacts, AbstractFileHeaderHelper fileHeaderHelper, SyntaxTrivia newLineTrivia, SyntaxNode root, string expectedFileHeader);
    private static SyntaxTriviaList CreateNewHeader(ISyntaxFacts syntaxFacts, string prefixWithLeadingSpaces, string expectedFileHeader, string newLineText);
    private static string GetCopyrightText(string prefixWithLeadingSpaces, string copyrightText, string newLineText);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderCodeFixProvider/<<GetFixAllProvider>b__13_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__13_0(FixAllContext context, Document document, ImmutableArray`1<Diagnostic> diagnostics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_invalidHeaderTitle;
    private static LocalizableString s_invalidHeaderMessage;
    private static DiagnosticDescriptor s_invalidHeaderDescriptor;
    private static LocalizableString s_missingHeaderTitle;
    private static LocalizableString s_missingHeaderMessage;
    private static DiagnosticDescriptor s_missingHeaderDescriptor;
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    private static AbstractFileHeaderDiagnosticAnalyzer();
    private static DiagnosticDescriptor CreateDescriptorForFileHeader(LocalizableString title, LocalizableString message);
    protected abstract virtual AbstractFileHeaderHelper get_FileHeaderHelper();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void HandleSyntaxTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private static bool CompareCopyrightText(string expectedFileHeader, string copyrightText);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__11_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FileHeaders.AbstractFileHeaderHelper : object {
    [CompilerGeneratedAttribute]
private int <SingleLineCommentTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MultiLineCommentTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WhitespaceTriviaKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOfLineTriviaKind>k__BackingField;
    public string CommentPrefix { get; }
    private int SingleLineCommentTriviaKind { get; }
    private Nullable`1<int> MultiLineCommentTriviaKind { get; }
    private int WhitespaceTriviaKind { get; }
    private int EndOfLineTriviaKind { get; }
    protected AbstractFileHeaderHelper(ISyntaxKinds syntaxKinds);
    public abstract virtual string get_CommentPrefix();
    [NullableContextAttribute("0")]
protected abstract virtual ReadOnlyMemory`1<char> GetTextContextOfComment(SyntaxTrivia commentTrivia);
    [CompilerGeneratedAttribute]
private int get_SingleLineCommentTriviaKind();
    [CompilerGeneratedAttribute]
private Nullable`1<int> get_MultiLineCommentTriviaKind();
    [CompilerGeneratedAttribute]
private int get_WhitespaceTriviaKind();
    [CompilerGeneratedAttribute]
private int get_EndOfLineTriviaKind();
    public FileHeader ParseFileHeader(SyntaxNode root);
    private int IndexOfFirstNonWhitespaceTrivia(T triviaList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.FileHeaders.FileHeader : ValueType {
    private int _fileHeaderStart;
    private int _commentPrefixLength;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyrightText>k__BackingField;
    internal bool IsMissing { get; }
    internal string CopyrightText { get; }
    internal FileHeader(string copyrightText, int fileHeaderStart, int fileHeaderEnd, int commentPrefixLength);
    private FileHeader(int fileHeaderStart, bool isMissing);
    [CompilerGeneratedAttribute]
internal bool get_IsMissing();
    [CompilerGeneratedAttribute]
internal string get_CopyrightText();
    internal static FileHeader MissingFileHeader(int fileHeaderStart);
    internal Location GetLocation(SyntaxTree syntaxTree);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindImplementationsAsync>d__3")]
public sealed virtual Task FindImplementationsAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindImplementationsAsync>d__4")]
public static Task FindImplementationsAsync(IFindUsagesContext context, ISymbol symbol, Project project, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindImplementationsInCurrentProcessAsync>d__5")]
private static Task FindImplementationsInCurrentProcessAsync(ISymbol symbol, Project project, IFindUsagesContext context, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindSourceImplementationsAsync>d__6")]
private static Task`1<ImmutableArray`1<ISymbol>> FindSourceImplementationsAsync(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindImplementationsWorkerAsync>d__7")]
private static Task`1<ImmutableArray`1<ISymbol>> FindImplementationsWorkerAsync(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindSourceAndMetadataImplementationsAsync>d__8")]
private static Task`1<ImmutableArray`1<ISymbol>> FindSourceAndMetadataImplementationsAsync(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<Microsoft-CodeAnalysis-FindUsages-IFindUsagesService-FindReferencesAsync>d__9")]
private sealed virtual override Task Microsoft.CodeAnalysis.FindUsages.IFindUsagesService.FindReferencesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    private sealed virtual override Task Microsoft.CodeAnalysis.FindUsages.IFindUsagesLSPService.FindReferencesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindLiteralOrSymbolReferencesAsync>d__11")]
private static Task FindLiteralOrSymbolReferencesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<GetThirdPartyDefinitionsAsync>d__12")]
private static Task`1<ImmutableArray`1<DefinitionItem>> GetThirdPartyDefinitionsAsync(Solution solution, ImmutableArray`1<DefinitionItem> definitions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindSymbolReferencesAsync>d__13")]
private static Task FindSymbolReferencesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindSymbolReferencesAsync>d__14")]
public static Task FindSymbolReferencesAsync(IFindUsagesContext context, ISymbol symbol, Project project, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<FindReferencesAsync>d__15")]
public static Task FindReferencesAsync(IFindUsagesContext context, ISymbol symbol, Project project, FindReferencesSearchOptions searchOptions, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    private static Task FindReferencesInCurrentProcessAsync(IFindUsagesContext context, ISymbol symbol, Project project, FindReferencesSearchOptions searchOptions, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.AbstractFindUsagesService/<TryFindLiteralReferencesAsync>d__17")]
private static Task`1<bool> TryFindLiteralReferencesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <FindSourceImplementationsAsync>g__AddedAllLocations|6_0(ISymbol implementation, HashSet`1<ValueTuple`2<string, TextSpan>> seenLocations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.AssemblyLocation : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public Version Version { get; public set; }
    [NullableAttribute("2")]
[DataMemberAttribute]
public string FilePath { get; public set; }
    public AssemblyLocation(string Name, Version Version, string FilePath);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Version(Version value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FilePath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilePath(string value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AssemblyLocation left, AssemblyLocation right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AssemblyLocation left, AssemblyLocation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AssemblyLocation other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, Version& Version, String& FilePath);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.FindUsages.IExternalDefinitionItemProvider", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.DefaultExternalDefinitionItemProvider : object {
    [NullableContextAttribute("1")]
public sealed virtual Task`1<DefinitionItem> GetThirdPartyDefinitionItemAsync(Solution solution, DefinitionItem definitionItem, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.FindUsages.DefinitionItem : object {
    [NullableAttribute("1")]
internal static string Primary;
    [NullableAttribute("1")]
internal static string RQNameKey1;
    [NullableAttribute("1")]
internal static string RQNameKey2;
    [NullableAttribute("1")]
internal static string MetadataSymbolKey;
    [NullableAttribute("1")]
internal static string MetadataSymbolOriginatingProjectIdGuid;
    [NullableAttribute("1")]
internal static string MetadataSymbolOriginatingProjectIdDebugName;
    [NullableAttribute("1")]
private static string NonNavigable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Tags>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <Properties>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`2<string, string>> <DisplayableProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <NameDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <DisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentSpan> <SourceSpans>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>> <ClassifiedSpans>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<AssemblyLocation> <MetadataLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayIfNoReferences>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    [NullableAttribute("1")]
public ImmutableDictionary`2<string, string> Properties { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<string, string>> DisplayableProperties { get; }
    public ImmutableArray`1<TaggedText> NameDisplayParts { get; }
    public ImmutableArray`1<TaggedText> DisplayParts { get; }
    public ImmutableArray`1<DocumentSpan> SourceSpans { get; }
    public ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>> ClassifiedSpans { get; }
    public ImmutableArray`1<AssemblyLocation> MetadataLocations { get; }
    public bool DisplayIfNoReferences { get; }
    internal bool IsExternal { get; }
    protected DefinitionItem(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>> classifiedSpans, ImmutableArray`1<AssemblyLocation> metadataLocations, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<ValueTuple`2<string, string>> displayableProperties, bool displayIfNoReferences);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Tags();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<string, string>> get_DisplayableProperties();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_NameDisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_DisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentSpan> get_SourceSpans();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>> get_ClassifiedSpans();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AssemblyLocation> get_MetadataLocations();
    [CompilerGeneratedAttribute]
public bool get_DisplayIfNoReferences();
    internal abstract virtual bool get_IsExternal();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Use GetNavigableLocationAsync instead")]
public Task`1<bool> TryNavigateToAsync(Workspace workspace, bool showInPreviewTab, bool activateTab, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.DefinitionItem/<TryNavigateToAsync>d__38")]
[ObsoleteAttribute("Use GetNavigableLocationAsync instead")]
public Task`1<bool> TryNavigateToAsync(Workspace workspace, NavigationOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual Task`1<INavigableLocation> GetNavigableLocationAsync(Workspace workspace, CancellationToken cancellationToken);
    [ObsoleteAttribute("TypeScript: Use external access APIs")]
public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, DocumentSpan sourceSpan, ImmutableArray`1<TaggedText> nameDisplayParts, bool displayIfNoReferences);
    [ObsoleteAttribute("TypeScript: Use external access APIs")]
public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, DocumentSpan sourceSpan, Nullable`1<ClassifiedSpansAndHighlightSpan> classifiedSpans, ImmutableArray`1<TaggedText> nameDisplayParts, bool displayIfNoReferences);
    [ObsoleteAttribute("TypeScript: Use external access APIs")]
public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>> classifiedSpans, ImmutableArray`1<TaggedText> nameDisplayParts, bool displayIfNoReferences);
    [ObsoleteAttribute("TypeScript: Use external access APIs")]
public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>> classifiedSpans, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableDictionary`2<string, string> properties, bool displayIfNoReferences);
    public static DefinitionItem Create(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<DocumentSpan> sourceSpans, ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>> classifiedSpans, ImmutableArray`1<AssemblyLocation> metadataLocations, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<ValueTuple`2<string, string>> displayableProperties, bool displayIfNoReferences);
    [ObsoleteAttribute("TypeScript: Use external access APIs")]
public static DefinitionItem CreateNonNavigableItem(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> originationParts, bool displayIfNoReferences);
    public static DefinitionItem CreateNonNavigableItem(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableArray`1<AssemblyLocation> metadataLocations, ImmutableDictionary`2<string, string> properties, bool displayIfNoReferences);
    [NullableContextAttribute("1")]
public DetachedDefinitionItem Detach();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindUsages.DefinitionItemFactory : object {
    private static SymbolDisplayFormat s_namePartsFormat;
    private static DefinitionItemFactory();
    [ExtensionAttribute]
public static DefinitionItem ToNonClassifiedDefinitionItem(ISymbol definition, Solution solution, bool includeHiddenLocations);
    [ExtensionAttribute]
public static DefinitionItem ToNonClassifiedDefinitionItem(ISymbol definition, Solution solution, FindReferencesSearchOptions options, bool includeHiddenLocations);
    private static DefinitionItem ToNonClassifiedDefinitionItem(ISymbol definition, ImmutableArray`1<Location> locations, Solution solution, FindReferencesSearchOptions options, bool isPrimary, bool includeHiddenLocations);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.DefinitionItemFactory/<ToClassifiedDefinitionItemAsync>d__4")]
[ExtensionAttribute]
public static ValueTask`1<DefinitionItem> ToClassifiedDefinitionItemAsync(ISymbol definition, OptionsProvider`1<ClassificationOptions> classificationOptions, Solution solution, FindReferencesSearchOptions options, bool isPrimary, bool includeHiddenLocations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.DefinitionItemFactory/<ToClassifiedDefinitionItemAsync>d__5")]
[ExtensionAttribute]
public static ValueTask`1<DefinitionItem> ToClassifiedDefinitionItemAsync(SymbolGroup group, OptionsProvider`1<ClassificationOptions> classificationOptions, Solution solution, FindReferencesSearchOptions options, bool isPrimary, bool includeHiddenLocations, CancellationToken cancellationToken);
    private static DefinitionItem ToDefinitionItem(ISymbol definition, ImmutableArray`1<DocumentSpan> sourceLocations, ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>> classifiedSpans, Solution solution, FindReferencesSearchOptions options, bool isPrimary);
    [ExtensionAttribute]
internal static ImmutableDictionary`2<string, string> WithMetadataSymbolProperties(ImmutableDictionary`2<string, string> properties, ISymbol symbol, ProjectId originatingProjectId);
    internal static AssemblyLocation GetMetadataLocation(IAssemblySymbol assembly, Solution solution, ProjectId& originatingProjectId);
    internal static ImmutableArray`1<AssemblyLocation> GetMetadataLocations(ISymbol definition, Solution solution, ProjectId& originatingProjectId);
    private static ImmutableArray`1<DocumentSpan> GetSourceLocations(ISymbol definition, ImmutableArray`1<Location> locations, Solution solution, bool includeHiddenLocations);
    [NullableContextAttribute("0")]
private static ValueTask`1<ImmutableArray`1<Nullable`1<ClassifiedSpansAndHighlightSpan>>> ClassifyDocumentSpansAsync(OptionsProvider`1<ClassificationOptions> optionsProvider, ImmutableArray`1<DocumentSpan> unclassifiedSpans, CancellationToken cancellationToken);
    private static ImmutableDictionary`2<string, string> GetProperties(ISymbol definition, bool isPrimary);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.DefinitionItemFactory/<TryCreateSourceReferenceItemAsync>d__13")]
[ExtensionAttribute]
public static Task`1<SourceReferenceItem> TryCreateSourceReferenceItemAsync(ReferenceLocation referenceLocation, OptionsProvider`1<ClassificationOptions> optionsProvider, DefinitionItem definitionItem, bool includeHiddenLocations, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.DefinitionsAndReferences : ValueType {
    public static DefinitionsAndReferences Empty;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DefinitionItem> <Definitions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SourceReferenceItem> <References>k__BackingField;
    public ImmutableArray`1<DefinitionItem> Definitions { get; }
    public ImmutableArray`1<SourceReferenceItem> References { get; }
    public DefinitionsAndReferences(ImmutableArray`1<DefinitionItem> definitions, ImmutableArray`1<SourceReferenceItem> references);
    private static DefinitionsAndReferences();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DefinitionItem> get_Definitions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SourceReferenceItem> get_References();
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.DetachedDefinitionItem : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> Tags;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> DisplayParts;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> NameDisplayParts;
    [DataMemberAttribute]
public ImmutableArray`1<DocumentIdSpan> SourceSpans;
    [DataMemberAttribute]
public ImmutableArray`1<AssemblyLocation> MetadataLocations;
    [NullableAttribute("1")]
[DataMemberAttribute]
public ImmutableDictionary`2<string, string> Properties;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<string, string>> DisplayableProperties;
    [DataMemberAttribute]
public bool DisplayIfNoReferences;
    private int _hashCode;
    public DetachedDefinitionItem(ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableArray`1<DocumentIdSpan> sourceSpans, ImmutableArray`1<AssemblyLocation> metadataLocations, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<ValueTuple`2<string, string>> displayableProperties, bool displayIfNoReferences);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DetachedDefinitionItem other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.DetachedDefinitionItem/<TryRehydrateAsync>d__13")]
public Task`1<DefaultDefinitionItem> TryRehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.FindUsages.ExternalScope : Enum {
    public int value__;
    public static ExternalScope Default;
    public static ExternalScope Repository;
    public static ExternalScope Organization;
    public static ExternalScope Global;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FindUsages.FindUsagesContext : object {
    [CompilerGeneratedAttribute]
private IStreamingProgressTracker <ProgressTracker>k__BackingField;
    public IStreamingProgressTracker ProgressTracker { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IStreamingProgressTracker get_ProgressTracker();
    public virtual ValueTask ReportNoResultsAsync(string message, CancellationToken cancellationToken);
    public virtual ValueTask ReportMessageAsync(string message, NotificationSeverity severity, CancellationToken cancellationToken);
    public virtual ValueTask SetSearchTitleAsync(string title, CancellationToken cancellationToken);
    public virtual ValueTask OnCompletedAsync(CancellationToken cancellationToken);
    public virtual ValueTask OnDefinitionFoundAsync(DefinitionItem definition, CancellationToken cancellationToken);
    public virtual ValueTask OnReferencesFoundAsync(IAsyncEnumerable`1<SourceReferenceItem> references, CancellationToken cancellationToken);
    protected virtual ValueTask ReportProgressAsync(int current, int maximum, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.FindUsages.FindUsagesHelpers : object {
    private static SymbolDisplayFormat s_definitionFormat;
    private static SymbolDisplayFormat s_parameterDefinitionFormat;
    private static FindUsagesHelpers();
    public static string GetDisplayName(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.FindUsagesHelpers/<GetRelevantSymbolAndProjectAtPositionAsync>d__1")]
public static Task`1<Nullable`1<ValueTuple`2<ISymbol, Project>>> GetRelevantSymbolAndProjectAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    private static SymbolDisplayFormat GetFormat(ISymbol definition);
    public static ImmutableArray`1<TaggedText> GetDisplayParts(ISymbol definition);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.FindUsagesOptions : ValueType {
    [CompilerGeneratedAttribute]
private ClassificationOptions <ClassificationOptions>k__BackingField;
    public static FindUsagesOptions Default;
    [DataMemberAttribute]
public ClassificationOptions ClassificationOptions { get; public set; }
    private static FindUsagesOptions();
    [CompilerGeneratedAttribute]
public ClassificationOptions get_ClassificationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClassificationOptions(ClassificationOptions value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FindUsagesOptions left, FindUsagesOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FindUsagesOptions left, FindUsagesOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FindUsagesOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallback : object {
    private Solution _solution;
    private IFindUsagesContext _context;
    private Dictionary`2<int, DefinitionItem> _idToDefinition;
    private OptionsProvider`1<ClassificationOptions> _classificationOptions;
    public FindUsagesServerCallback(Solution solution, IFindUsagesContext context, OptionsProvider`1<ClassificationOptions> classificationOptions);
    [NullableContextAttribute("0")]
internal ValueTask`1<ClassificationOptions> GetClassificationOptionsAsync(string language, CancellationToken cancellationToken);
    public ValueTask AddItemsAsync(int count, CancellationToken cancellationToken);
    public ValueTask ItemsCompletedAsync(int count, CancellationToken cancellationToken);
    public ValueTask ReportMessageAsync(string message, CancellationToken cancellationToken);
    public ValueTask ReportInformationalMessageAsync(string message, CancellationToken cancellationToken);
    public ValueTask SetSearchTitleAsync(string title, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallback/<OnDefinitionFoundAsync>d__11")]
public ValueTask OnDefinitionFoundAsync(SerializableDefinitionItem definition, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallback/<OnReferencesFoundAsync>d__12")]
public ValueTask OnReferencesFoundAsync(ImmutableArray`1<SerializableSourceReferenceItem> references, CancellationToken cancellationToken);
    private DefinitionItem GetDefinition(int definitionId);
    [NullableContextAttribute("0")]
[AsyncIteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallback/<<OnReferencesFoundAsync>g__ConvertAsync|12_0>d")]
[CompilerGeneratedAttribute]
private IAsyncEnumerable`1<SourceReferenceItem> <OnReferencesFoundAsync>g__ConvertAsync|12_0(ImmutableArray`1<SerializableSourceReferenceItem> references, CancellationToken cancellationToken);
}
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.FindUsages.IRemoteFindUsagesService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.FindUsagesServerCallbackDispatcher : RemoteServiceCallbackDispatcher {
    [NullableContextAttribute("1")]
private FindUsagesServerCallback GetCallback(RemoteServiceCallbackId callbackId);
    public sealed virtual ValueTask`1<ClassificationOptions> GetOptionsAsync(RemoteServiceCallbackId callbackId, string language, CancellationToken cancellationToken);
    public sealed virtual ValueTask AddItemsAsync(RemoteServiceCallbackId callbackId, int count, CancellationToken cancellationToken);
    public sealed virtual ValueTask ItemsCompletedAsync(RemoteServiceCallbackId callbackId, int count, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnDefinitionFoundAsync(RemoteServiceCallbackId callbackId, SerializableDefinitionItem definition, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnReferencesFoundAsync(RemoteServiceCallbackId callbackId, ImmutableArray`1<SerializableSourceReferenceItem> references, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask ReportMessageAsync(RemoteServiceCallbackId callbackId, string message, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask ReportInformationalMessageAsync(RemoteServiceCallbackId callbackId, string message, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask SetSearchTitleAsync(RemoteServiceCallbackId callbackId, string title, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.FindUsages.IExternalDefinitionItemProvider {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<DefinitionItem> GetThirdPartyDefinitionItemAsync(Solution solution, DefinitionItem definitionItem, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindUsages.IFindUsagesContext {
    public IStreamingProgressTracker ProgressTracker { get; }
    public abstract virtual IStreamingProgressTracker get_ProgressTracker();
    public abstract virtual ValueTask ReportNoResultsAsync(string message, CancellationToken cancellationToken);
    public abstract virtual ValueTask ReportMessageAsync(string message, NotificationSeverity severity, CancellationToken cancellationToken);
    public abstract virtual ValueTask SetSearchTitleAsync(string title, CancellationToken cancellationToken);
    public abstract virtual ValueTask OnDefinitionFoundAsync(DefinitionItem definition, CancellationToken cancellationToken);
    public abstract virtual ValueTask OnReferencesFoundAsync(IAsyncEnumerable`1<SourceReferenceItem> references, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindUsages.IFindUsagesLSPService {
    public abstract virtual Task FindReferencesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    public abstract virtual Task FindImplementationsAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindUsages.IFindUsagesService {
    public abstract virtual Task FindReferencesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
    public abstract virtual Task FindImplementationsAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindUsages.IRemoteFindUsagesService {
    public abstract virtual ValueTask FindReferencesAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, SerializableSymbolAndProjectId symbolAndProjectId, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public abstract virtual ValueTask FindImplementationsAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, SerializableSymbolAndProjectId symbolAndProjectId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.SerializableClassifiedSpansAndHighlightSpan : ValueType {
    [DataMemberAttribute]
public SerializableClassifiedSpans ClassifiedSpans;
    [DataMemberAttribute]
public TextSpan HighlightSpan;
    public SerializableClassifiedSpansAndHighlightSpan(SerializableClassifiedSpans classifiedSpans, TextSpan highlightSpan);
    public static SerializableClassifiedSpansAndHighlightSpan Dehydrate(ClassifiedSpansAndHighlightSpan classifiedSpansAndHighlightSpan);
    public ClassifiedSpansAndHighlightSpan Rehydrate();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.SerializableDefinitionItem : ValueType {
    [DataMemberAttribute]
public int Id;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> Tags;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> DisplayParts;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> NameDisplayParts;
    [DataMemberAttribute]
public ImmutableArray`1<SerializableDocumentSpan> SourceSpans;
    [DataMemberAttribute]
public ImmutableArray`1<AssemblyLocation> MetadataLocations;
    [NullableAttribute("1")]
[DataMemberAttribute]
public ImmutableDictionary`2<string, string> Properties;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<string, string>> DisplayableProperties;
    [DataMemberAttribute]
public bool DisplayIfNoReferences;
    public SerializableDefinitionItem(int id, ImmutableArray`1<string> tags, ImmutableArray`1<TaggedText> displayParts, ImmutableArray`1<TaggedText> nameDisplayParts, ImmutableArray`1<SerializableDocumentSpan> sourceSpans, ImmutableArray`1<AssemblyLocation> metadataLocations, ImmutableDictionary`2<string, string> properties, ImmutableArray`1<ValueTuple`2<string, string>> displayableProperties, bool displayIfNoReferences);
    [NullableContextAttribute("1")]
public static SerializableDefinitionItem Dehydrate(int id, DefinitionItem item);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.SerializableDefinitionItem/<RehydrateAsync>d__11")]
public ValueTask`1<DefaultDefinitionItem> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.SerializableDocumentSpan : ValueType {
    [NullableAttribute("1")]
[DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public TextSpan SourceSpan;
    [NullableContextAttribute("1")]
public SerializableDocumentSpan(DocumentId documentId, TextSpan sourceSpan);
    public static SerializableDocumentSpan Dehydrate(DocumentSpan documentSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.SerializableDocumentSpan/<RehydrateAsync>d__4")]
public ValueTask`1<DocumentSpan> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindUsages.SerializableSourceReferenceItem : ValueType {
    [DataMemberAttribute]
public int DefinitionId;
    [DataMemberAttribute]
public SerializableDocumentSpan SourceSpan;
    [DataMemberAttribute]
public SerializableClassifiedSpansAndHighlightSpan ClassifiedSpans;
    [DataMemberAttribute]
public SymbolUsageInfo SymbolUsageInfo;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<string, string>> AdditionalProperties;
    public SerializableSourceReferenceItem(int definitionId, SerializableDocumentSpan sourceSpan, SerializableClassifiedSpansAndHighlightSpan classifiedSpans, SymbolUsageInfo symbolUsageInfo, ImmutableArray`1<ValueTuple`2<string, string>> additionalProperties);
    public static SerializableSourceReferenceItem Dehydrate(int definitionId, SourceReferenceItem item);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindUsages.SerializableSourceReferenceItem/<RehydrateAsync>d__7")]
public Task`1<SourceReferenceItem> RehydrateAsync(Solution solution, DefinitionItem definition, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindUsages.SourceReferenceItem : object {
    [CompilerGeneratedAttribute]
private DefinitionItem <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentSpan <SourceSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ClassifiedSpansAndHighlightSpan> <ClassifiedSpans>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWrittenTo>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolUsageInfo <SymbolUsageInfo>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`2<string, string>> <AdditionalProperties>k__BackingField;
    public DefinitionItem Definition { get; }
    public DocumentSpan SourceSpan { get; }
    public Nullable`1<ClassifiedSpansAndHighlightSpan> ClassifiedSpans { get; }
    public bool IsWrittenTo { get; }
    public SymbolUsageInfo SymbolUsageInfo { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`2<string, string>> AdditionalProperties { get; }
    private SourceReferenceItem(DefinitionItem definition, DocumentSpan sourceSpan, Nullable`1<ClassifiedSpansAndHighlightSpan> classifiedSpans, SymbolUsageInfo symbolUsageInfo, ImmutableArray`1<ValueTuple`2<string, string>> additionalProperties, bool isWrittenTo);
    internal SourceReferenceItem(DefinitionItem definition, DocumentSpan sourceSpan, Nullable`1<ClassifiedSpansAndHighlightSpan> classifiedSpans);
    internal SourceReferenceItem(DefinitionItem definition, DocumentSpan sourceSpan, Nullable`1<ClassifiedSpansAndHighlightSpan> classifiedSpans, SymbolUsageInfo symbolUsageInfo);
    internal SourceReferenceItem(DefinitionItem definition, DocumentSpan sourceSpan, Nullable`1<ClassifiedSpansAndHighlightSpan> classifiedSpans, SymbolUsageInfo symbolUsageInfo, ImmutableArray`1<ValueTuple`2<string, string>> additionalProperties);
    [CompilerGeneratedAttribute]
public DefinitionItem get_Definition();
    [CompilerGeneratedAttribute]
public DocumentSpan get_SourceSpan();
    [CompilerGeneratedAttribute]
public Nullable`1<ClassifiedSpansAndHighlightSpan> get_ClassifiedSpans();
    [CompilerGeneratedAttribute]
public bool get_IsWrittenTo();
    [CompilerGeneratedAttribute]
public SymbolUsageInfo get_SymbolUsageInfo();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`2<string, string>> get_AdditionalProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ForEachCast.AbstractForEachCastCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual ITypeSymbol GetForEachElementType(SemanticModel semanticModel, TForEachStatementSyntax forEachStatement);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ForEachCast.AbstractForEachCastCodeFixProvider`1/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public void AddCast(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, SyntaxEditor editor, TForEachStatementSyntax forEachStatement, CancellationToken cancellationToken);
    private SyntaxNode GetRewrittenCollection(SyntaxGenerator generator, SyntaxNode collection, ITypeSymbol iterationVariableType, CommonConversion conversion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ForEachCast.AbstractForEachCastDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableDictionary`2<string, string> s_isFixableProperties;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractForEachCastDiagnosticAnalyzer`2();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TSyntaxKind> GetSyntaxKinds();
    protected abstract virtual ValueTuple`2<CommonConversion, ITypeSymbol> GetForEachInfo(SemanticModel semanticModel, TForEachStatementSyntax node);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static bool IsStronglyTyped(ITypeSymbol collectionType, ITypeSymbol collectionElementType);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(SyntaxNodeAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.ForEachCast.ForEachCastHelpers : object {
    [NullableAttribute("1")]
public static string IsFixable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractNewDocumentFormattingService : object {
    private IEnumerable`1<Lazy`2<INewDocumentFormattingProvider, LanguageMetadata>> _providers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<INewDocumentFormattingProvider> _providerValues;
    protected string Language { get; }
    protected AbstractNewDocumentFormattingService(IEnumerable`1<Lazy`2<INewDocumentFormattingProvider, LanguageMetadata>> providers);
    protected abstract virtual string get_Language();
    private IEnumerable`1<INewDocumentFormattingProvider> GetProviders();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.AbstractNewDocumentFormattingService/<FormatNewDocumentAsync>d__6")]
public sealed virtual Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetProviders>b__5_0(Lazy`2<INewDocumentFormattingProvider, LanguageMetadata> p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Formatting.ExportNewDocumentFormattingProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public ExportNewDocumentFormattingProviderAttribute(string languageName);
    [CompilerGeneratedAttribute]
public string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.FormatterHelper : object {
    internal static IEnumerable`1<AbstractFormattingRule> GetDefaultFormattingRules(ISyntaxFormatting syntaxFormattingService);
    public static SyntaxNode Format(SyntaxNode node, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, TextSpan spanToFormat, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static IFormattingResult GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, ImmutableArray`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, ISyntaxFormatting syntaxFormattingService, SyntaxFormattingOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Formatting.INewDocumentFormattingProvider {
    public abstract virtual Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Formatting.INewDocumentFormattingService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Formatting.Rules.FormattingRuleUtilities : object {
    public static ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(ParsedDocument document, TextSpan span, IEnumerable`1<AbstractFormattingRule> additionalRules);
}
internal static class Microsoft.CodeAnalysis.FormattingCodeFixHelper : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FormattingCodeFixHelper/<FixOneAsync>d__0")]
internal static Task`1<SyntaxTree> FixOneAsync(SyntaxTree syntaxTree, ISyntaxFormatting formattingProvider, SyntaxFormattingOptions options, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.GenerateComparisonOperators.GenerateComparisonOperatorsCodeRefactoringProvider : CodeRefactoringProvider {
    private static string LeftName;
    private static string RightName;
    [NullableAttribute("0")]
private static ImmutableArray`1<CodeGenerationOperatorKind> s_operatorKinds;
    private static GenerateComparisonOperatorsCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateComparisonOperators.GenerateComparisonOperatorsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static IMethodSymbol TryGetCompareMethodImpl(INamedTypeSymbol containingType, ITypeSymbol comparableType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateComparisonOperators.GenerateComparisonOperatorsCodeRefactoringProvider/<GenerateComparisonOperatorsAsync>d__6")]
private static Task`1<Document> GenerateComparisonOperatorsAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol comparableType, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SyntaxNode GenerateLeftExpression(SyntaxGenerator generator, INamedTypeSymbol comparableType, IMethodSymbol compareMethod);
    private static ImmutableArray`1<IMethodSymbol> GenerateComparisonOperators(SyntaxGenerator generator, Compilation compilation, INamedTypeSymbol containingType, INamedTypeSymbol comparableType, SyntaxNode thisExpression);
    private static SyntaxNode GenerateStatement(SyntaxGenerator generator, CodeGenerationOperatorKind kind, SyntaxNode leftExpression);
    private static bool HasAllComparisonOperators(INamedTypeSymbol containingType, ITypeSymbol comparedType);
    private static bool HasComparisonOperator(INamedTypeSymbol containingType, ITypeSymbol comparedType, CodeGenerationOperatorKind kind);
    private static string GetOperatorName(CodeGenerationOperatorKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider : AbstractGenerateFromMembersCodeRefactoringProvider {
    private static string AddNullChecksId;
    [NullableAttribute("2")]
private IPickMembersService _pickMembersService_forTesting;
    [NullableContextAttribute("2")]
protected AbstractGenerateConstructorFromMembersCodeRefactoringProvider(IPickMembersService pickMembersService_forTesting);
    protected abstract virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected abstract virtual string ToDisplayString(IParameterSymbol parameter, SymbolDisplayFormat format);
    protected abstract virtual ValueTask`1<bool> PrefersThrowExpressionAsync(Document document, SimplifierOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual IFieldSymbol TryMapToWritableInstanceField(IPropertySymbol property, CancellationToken cancellationToken);
    public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<ComputeIntentAsync>d__11")]
public sealed virtual Task`1<ImmutableArray`1<IntentProcessorResult>> ComputeIntentAsync(Document priorDocument, TextSpan priorSelection, Document currentDocument, IntentDataProvider intentDataProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<ComputeRefactoringsAsync>d__12")]
private Task ComputeRefactoringsAsync(Document document, TextSpan textSpan, Action`2<CodeAction, TextSpan> registerSingleAction, Action`1<ImmutableArray`1<CodeAction>> registerMultipleActions, Nullable`1<Accessibility> desiredAccessibility, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<HandleNonSelectionAsync>d__13")]
private Task`1<Nullable`1<ValueTuple`2<CodeAction, TextSpan>>> HandleNonSelectionAsync(Document document, TextSpan textSpan, Nullable`1<Accessibility> desiredAccessibility, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<GenerateConstructorFromMembersAsync>d__14")]
public Task`1<ImmutableArray`1<CodeAction>> GenerateConstructorFromMembersAsync(Document document, TextSpan textSpan, bool addNullChecks, Nullable`1<Accessibility> desiredAccessibility, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeAction> GetCodeActions(Document document, State state, bool addNullChecks, CleanCodeGenerationOptionsProvider fallbackOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<AddNavigationAnnotationAsync>d__16")]
private static Task`1<Document> AddNavigationAnnotationAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<<ComputeIntentAsync>g__GetIntentProcessorResultAsync|11_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<Nullable`1<IntentProcessorResult>> <ComputeIntentAsync>g__GetIntentProcessorResultAsync|11_1(Document priorDocument, CodeAction codeAction, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateConstructorFromMembers.AbstractGenerateConstructorFromMembersCodeRefactoringProvider/<<ComputeIntentAsync>g__GetCodeActionOperationsAsync|11_2>d")]
[CompilerGeneratedAttribute]
internal static Task`1<ImmutableArray`1<CodeActionOperation>> <ComputeIntentAsync>g__GetCodeActionOperationsAsync|11_2(Solution originalSolution, CodeAction action, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.GenerateDefaultConstructors.AbstractGenerateDefaultConstructorCodeFixProvider : CodeFixProvider {
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual Nullable`1<SyntaxToken> TryGetTypeName(SyntaxNode typeDeclaration);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateDefaultConstructors.AbstractGenerateDefaultConstructorCodeFixProvider/<RegisterCodeFixesAsync>d__2")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.GenerateDefaultConstructors.AbstractGenerateDefaultConstructorsService`1 : object {
    protected abstract virtual bool TryInitializeState(SemanticDocument document, TextSpan textSpan, CancellationToken cancellationToken, INamedTypeSymbol& classType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateDefaultConstructors.AbstractGenerateDefaultConstructorsService`1/<GenerateDefaultConstructorsAsync>d__5")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateDefaultConstructorsAsync(Document document, TextSpan textSpan, CodeAndImportGenerationOptionsProvider fallbackOptions, bool forRefactoring, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.GenerateDefaultConstructors.GenerateDefaultConstructorsCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateDefaultConstructors.GenerateDefaultConstructorsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal interface Microsoft.CodeAnalysis.GenerateDefaultConstructors.IGenerateDefaultConstructorsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateDefaultConstructorsAsync(Document document, TextSpan textSpan, CodeAndImportGenerationOptionsProvider fallbackOptions, bool forRefactoring, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService : object {
    private static string GetHashCodeName;
    private static SyntaxAnnotation s_specializedFormattingAnnotation;
    private static AbstractGenerateEqualsAndGetHashCodeService();
    protected abstract virtual bool TryWrapWithUnchecked(ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1& wrappedStatements);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<FormatDocumentAsync>d__3")]
public sealed virtual Task`1<Document> FormatDocumentAsync(Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<GenerateEqualsMethodAsync>d__4")]
public sealed virtual Task`1<IMethodSymbol> GenerateEqualsMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, string localNameOpt, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<GenerateIEquatableEqualsMethodAsync>d__5")]
public sealed virtual Task`1<IMethodSymbol> GenerateIEquatableEqualsMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, INamedTypeSymbol constructedEquatableType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<GenerateEqualsMethodThroughIEquatableEqualsAsync>d__6")]
public sealed virtual Task`1<IMethodSymbol> GenerateEqualsMethodThroughIEquatableEqualsAsync(Document document, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.AbstractGenerateEqualsAndGetHashCodeService/<GenerateGetHashCodeMethodAsync>d__7")]
public sealed virtual Task`1<IMethodSymbol> GenerateGetHashCodeMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
    private IMethodSymbol CreateGetHashCodeMethod(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members);
    private ImmutableArray`1<SyntaxNode> CreateGetHashCodeStatements(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider : AbstractGenerateFromMembersCodeRefactoringProvider {
    public static string GenerateOperatorsId;
    public static string ImplementIEquatableId;
    private static string EqualsName;
    private static string GetHashCodeName;
    [NullableAttribute("2")]
private IPickMembersService _pickMembersService_forTestingPurposes;
    [NullableContextAttribute("2")]
public GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider(IPickMembersService pickMembersService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<ComputeRefactoringsAsync>d__8")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<HandleNonSelectionAsync>d__9")]
private Task HandleNonSelectionAsync(CodeRefactoringContext context, CleanCodeGenerationOptionsProvider fallbackOptions);
    private static bool HasOperators(INamedTypeSymbol containingType);
    private static bool HasOperator(INamedTypeSymbol containingType, string operatorName);
    private static bool CanImplementIEquatable(SemanticModel semanticModel, INamedTypeSymbol containingType, INamedTypeSymbol& constructedType);
    private static void GetExistingMemberInfo(INamedTypeSymbol containingType, Boolean& hasEquals, Boolean& hasGetHashCode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<GenerateEqualsAndGetHashCodeFromMembersAsync>d__14")]
public Task`1<ImmutableArray`1<CodeAction>> GenerateEqualsAndGetHashCodeFromMembersAsync(Document document, TextSpan textSpan, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<CreateActionsAsync>d__15")]
private Task`1<ImmutableArray`1<CodeAction>> CreateActionsAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> selectedMembers, CleanCodeGenerationOptionsProvider fallbackOptions, bool hasEquals, bool hasGetHashCode, bool withDialog, ILegacyGlobalOptionsWorkspaceService globalOptions, CancellationToken cancellationToken);
    private Task`1<CodeAction> CreateCodeActionAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, CleanCodeGenerationOptionsProvider fallbackOptions, ILegacyGlobalOptionsWorkspaceService globalOptions, bool generateEquals, bool generateGetHashCode, bool withDialog, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<CreateCodeActionWithDialogAsync>d__17")]
private Task`1<CodeAction> CreateCodeActionWithDialogAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, CleanCodeGenerationOptionsProvider fallbackOptions, ILegacyGlobalOptionsWorkspaceService globalOptions, bool generateEquals, bool generateGetHashCode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.GenerateEqualsAndGetHashCodeFromMembersCodeRefactoringProvider/<CreateCodeActionWithoutDialogAsync>d__18")]
private static Task`1<CodeAction> CreateCodeActionWithoutDialogAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, CleanCodeGenerationOptionsProvider fallbackOptions, bool generateEquals, bool generateGetHashCode, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService {
    public abstract virtual Task`1<Document> FormatDocumentAsync(Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<IMethodSymbol> GenerateEqualsMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, string localNameOpt, CancellationToken cancellationToken);
    public abstract virtual Task`1<IMethodSymbol> GenerateEqualsMethodThroughIEquatableEqualsAsync(Document document, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public abstract virtual Task`1<IMethodSymbol> GenerateIEquatableEqualsMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, INamedTypeSymbol constructedEquatableType, CancellationToken cancellationToken);
    public abstract virtual Task`1<IMethodSymbol> GenerateGetHashCodeMethodAsync(Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeServiceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task`1<IMethodSymbol> GenerateEqualsMethodAsync(IGenerateEqualsAndGetHashCodeService service, Document document, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.GenerateFromMembers.AbstractGenerateFromMembersCodeRefactoringProvider : CodeRefactoringProvider {
    protected static SymbolDisplayFormat SimpleFormat;
    private static AbstractGenerateFromMembersCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateFromMembers.AbstractGenerateFromMembersCodeRefactoringProvider/<GetSelectedMemberInfoAsync>d__1")]
protected static Task`1<SelectedMemberInfo> GetSelectedMemberInfoAsync(Document document, TextSpan textSpan, bool allowPartialSelection, CancellationToken cancellationToken);
    protected static bool IsReadableInstanceFieldOrProperty(ISymbol symbol);
    protected static bool IsWritableInstanceFieldOrProperty(ISymbol symbol);
    private static bool IsReadableFieldOrProperty(ISymbol symbol);
    private static bool IsWritableFieldOrProperty(ISymbol symbol);
    private static bool IsViableField(IFieldSymbol field);
    private static bool IsViableProperty(IPropertySymbol property);
    [NullableContextAttribute("0")]
protected static ImmutableArray`1<IParameterSymbol> DetermineParameters(ImmutableArray`1<ISymbol> selectedMembers, ImmutableArray`1<NamingRule> rules);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.GenerateMember.AbstractGenerateMemberService`2 : object {
    protected static ISet`1<TypeKind> EnumType;
    protected static ISet`1<TypeKind> ClassInterfaceModuleStructTypes;
    private static AbstractGenerateMemberService`2();
    protected static bool ValidateTypeToGenerateIn(INamedTypeSymbol typeToGenerateIn, bool isStatic, ISet`1<TypeKind> typeKinds);
    protected static bool TryDetermineTypeToGenerateIn(SemanticDocument document, INamedTypeSymbol containingType, TExpressionSyntax simpleNameOrMemberAccessExpression, CancellationToken cancellationToken, INamedTypeSymbol& typeToGenerateIn, Boolean& isStatic, Boolean& isColorColorCase);
    private static void TryDetermineTypeToGenerateInWorker(SemanticDocument semanticDocument, INamedTypeSymbol containingType, TExpressionSyntax expression, CancellationToken cancellationToken, INamedTypeSymbol& typeToGenerateIn, Boolean& isStatic, Boolean& isColorColorCase);
    private static void DetermineTypeToGenerateInWorker(SemanticModel semanticModel, SyntaxNode expression, INamedTypeSymbol& typeToGenerateIn, Boolean& isStatic, Boolean& isColorColorCase, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.AbstractGenerateConstructorService`2 : object {
    protected abstract virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected abstract virtual bool IsSimpleNameGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool IsConstructorInitializerGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool IsImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool TryInitializeImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeSimpleNameGenerationState(SemanticDocument document, SyntaxNode simpleName, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeConstructorInitializerGeneration(SemanticDocument document, SyntaxNode constructorInitializer, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeSimpleAttributeNameGenerationState(SemanticDocument document, SyntaxNode simpleName, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual ITypeSymbol GetArgumentType(SemanticModel semanticModel, Argument<TService, TExpressionSyntax> argument, CancellationToken cancellationToken);
    protected abstract virtual string GenerateNameForExpression(SemanticModel semanticModel, TExpressionSyntax expression, CancellationToken cancellationToken);
    protected abstract virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected abstract virtual IMethodSymbol GetCurrentConstructor(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    protected abstract virtual IMethodSymbol GetDelegatedConstructor(SemanticModel semanticModel, IMethodSymbol constructor, CancellationToken cancellationToken);
    protected bool WillCauseConstructorCycle(State<TService, TExpressionSyntax> state, SemanticDocument document, IMethodSymbol delegatedConstructor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.AbstractGenerateConstructorService`2/<GenerateConstructorAsync>d__14")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateConstructorAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected static bool IsSymbolAccessible(ISymbol symbol, SemanticDocument document);
    protected string GenerateNameForArgument(SemanticModel semanticModel, Argument<TService, TExpressionSyntax> argument, CancellationToken cancellationToken);
    private ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticDocument document, IEnumerable`1<Argument<TService, TExpressionSyntax>> arguments, IList`1<string> reservedNames, NamingRule parameterNamingRule, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.GenerateConstructorHelpers : object {
    public static bool CanDelegateTo(SemanticDocument document, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<TExpressionSyntax> expressions, IMethodSymbol constructor);
    private static bool IsSymbolAccessible(Compilation compilation, ISymbol symbol);
    private static bool IsCompatible(ISemanticFactsService semanticFacts, SemanticModel semanticModel, IMethodSymbol constructor, ImmutableArray`1<TExpressionSyntax> expressions);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.IGenerateConstructorService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateConstructorAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.AbstractGenerateEnumMemberService`3 : AbstractGenerateMemberService`2<TSimpleNameSyntax, TExpressionSyntax> {
    protected abstract virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected abstract virtual bool TryInitializeIdentifierNameState(SemanticDocument document, TSimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, TExpressionSyntax& simpleNameOrMemberAccessExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.AbstractGenerateEnumMemberService`3/<GenerateEnumMemberAsync>d__4")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateEnumMemberAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.IGenerateEnumMemberService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateEnumMemberAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateConversionService`4 : AbstractGenerateParameterizedMemberService`4<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> {
    protected abstract virtual bool IsImplicitConversionGeneration(SyntaxNode node);
    protected abstract virtual bool IsExplicitConversionGeneration(SyntaxNode node);
    protected abstract virtual bool TryInitializeImplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeExplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateConversionService`4/<GenerateConversionAsync>d__4")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateConversionAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateDeconstructMethodService`4 : AbstractGenerateParameterizedMemberService`4<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> {
    [NullableContextAttribute("1")]
public abstract virtual ImmutableArray`1<IParameterSymbol> TryMakeParameters(SemanticModel semanticModel, SyntaxNode target, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateDeconstructMethodService`4/<GenerateDeconstructMethodAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateDeconstructMethodAsync(Document document, SyntaxNode leftSide, INamedTypeSymbol typeToGenerateIn, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateMethodService`4 : AbstractGenerateParameterizedMemberService`4<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> {
    protected abstract virtual bool IsSimpleNameGeneration(SyntaxNode node);
    protected abstract virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected abstract virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeSimpleNameState(SemanticDocument document, TSimpleNameSyntax simpleName, CancellationToken cancellationToken, SyntaxToken& identifierToken, TExpressionSyntax& simpleNameOrMemberAccessExpression, TInvocationExpressionSyntax& invocationExpressionOpt, Boolean& isInConditionalExpression);
    protected abstract virtual ITypeSymbol DetermineReturnTypeForSimpleNameOrMemberAccessExpression(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, TExpressionSyntax expression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateMethodService`4/<GenerateMethodAsync>d__5")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateMethodAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateParameterizedMemberService`4 : AbstractGenerateMemberService`2<TSimpleNameSyntax, TExpressionSyntax> {
    protected abstract virtual AbstractInvocationInfo<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> abstractState);
    protected abstract virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    protected abstract virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual string GetImplicitConversionDisplayText(State<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> state);
    protected virtual string GetExplicitConversionDisplayText(State<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> state);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateParameterizedMemberService`4/<GetActionsAsync>d__9")]
protected ValueTask`1<ImmutableArray`1<CodeAction>> GetActionsAsync(Document document, State<TService, TSimpleNameSyntax, TExpressionSyntax, TInvocationExpressionSyntax> state, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.AbstractGenerateParameterizedMemberService`4/<ReplaceTypeParametersBasedOnTypeConstraintsAsync>d__13")]
private static ValueTask`1<ITypeSymbol> ReplaceTypeParametersBasedOnTypeConstraintsAsync(Project project, ITypeSymbol type, Compilation compilation, ISet`1<string> availableTypeParameterNames, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateConversionService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateConversionAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateDeconstructMemberService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateDeconstructMethodAsync(Document document, SyntaxNode targetVariables, INamedTypeSymbol typeToGenerateIn, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateParameterizedMemberService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateMethodAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.MethodGenerationKind : Enum {
    public int value__;
    public static MethodGenerationKind Member;
    public static MethodGenerationKind ImplicitConversion;
    public static MethodGenerationKind ExplicitConversion;
}
internal abstract class Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.AbstractGenerateVariableService`3 : AbstractGenerateMemberService`2<TSimpleNameSyntax, TExpressionSyntax> {
    protected abstract virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected abstract virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected abstract virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IPropertySymbol& propertySymbol, INamedTypeSymbol& typeToGenerateIn);
    protected abstract virtual bool TryInitializeIdentifierNameState(SemanticDocument document, TSimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, TExpressionSyntax& simpleNameOrMemberAccessExpression, Boolean& isInExecutableBlock, Boolean& isinConditionalAccessExpression);
    protected abstract virtual bool TryConvertToLocalDeclaration(ITypeSymbol type, SyntaxToken identifierToken, SemanticModel semanticModel, CancellationToken cancellationToken, SyntaxNode& newRoot);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.AbstractGenerateVariableService`3/<GenerateVariableAsync>d__7")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateVariableAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.AbstractGenerateVariableService`3/<AddPropertyCodeActionsAsync>d__9")]
private static Task AddPropertyCodeActionsAsync(ArrayBuilder`1<CodeAction> result, SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.AbstractGenerateVariableService`3/<NameIsHighlyUnlikelyToWarrantSymbolAsync>d__10")]
private static Task`1<bool> NameIsHighlyUnlikelyToWarrantSymbolAsync(Document document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state, SymbolKind kind, Accessibility accessibility, NamingStylePreferencesProvider fallbackOptions, CancellationToken cancellationToken);
    private static void GenerateWritableProperty(ArrayBuilder`1<CodeAction> result, SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state, CodeAndImportGenerationOptionsProvider fallbackOptions);
    private static void AddFieldCodeActions(ArrayBuilder`1<CodeAction> result, SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state, CodeAndImportGenerationOptionsProvider fallbackOptions);
    private static void GenerateWriteableField(ArrayBuilder`1<CodeAction> result, SemanticDocument document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state, CodeAndImportGenerationOptionsProvider fallbackOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.AbstractGenerateVariableService`3/<AddLocalCodeActionsAsync>d__14")]
private Task AddLocalCodeActionsAsync(ArrayBuilder`1<CodeAction> result, Document document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.AbstractGenerateVariableService`3/<AddParameterCodeActionsAsync>d__15")]
private static Task AddParameterCodeActionsAsync(ArrayBuilder`1<CodeAction> result, Document document, State<TService, TSimpleNameSyntax, TExpressionSyntax> state, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static RefKind GetRefKindFromContext(State<TService, TSimpleNameSyntax, TExpressionSyntax> state);
}
internal interface Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.IGenerateVariableService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateVariableAsync(Document document, SyntaxNode node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.GenerateOverrides.GenerateOverridesCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableAttribute("2")]
private IPickMembersService _pickMembersService_forTestingPurposes;
    [NullableContextAttribute("2")]
public GenerateOverridesCodeRefactoringProvider(IPickMembersService pickMembersService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateOverrides.GenerateOverridesCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal abstract class Microsoft.CodeAnalysis.GenerateType.AbstractGenerateTypeService`6 : object {
    protected string DefaultFileExtension { get; }
    protected abstract virtual bool TryInitializeState(SemanticDocument document, TSimpleNameSyntax simpleName, CancellationToken cancellationToken, GenerateTypeServiceStateOptions& generateTypeServiceStateOptions);
    protected abstract virtual TExpressionSyntax GetLeftSideOfDot(TSimpleNameSyntax simpleName);
    protected abstract virtual bool TryGetArgumentList(TObjectCreationExpressionSyntax objectCreationExpression, IList`1& argumentList);
    protected abstract virtual string get_DefaultFileExtension();
    protected abstract virtual ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual Accessibility GetAccessibility(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    protected abstract virtual IList`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IList`1<TArgumentSyntax> arguments, CancellationToken cancellationToken);
    protected abstract virtual INamedTypeSymbol DetermineTypeToGenerateIn(SemanticModel semanticModel, TSimpleNameSyntax simpleName, CancellationToken cancellationToken);
    protected abstract virtual ITypeSymbol DetermineArgumentType(SemanticModel semanticModel, TArgumentSyntax argument, CancellationToken cancellationToken);
    protected abstract virtual bool IsInCatchDeclaration(TExpressionSyntax expression);
    protected abstract virtual bool IsArrayElementType(TExpressionSyntax expression);
    protected abstract virtual bool IsInVariableTypeContext(TExpressionSyntax expression);
    protected abstract virtual bool IsInValueTypeConstraintContext(SemanticModel semanticModel, TExpressionSyntax expression, CancellationToken cancellationToken);
    protected abstract virtual bool IsInInterfaceList(TExpressionSyntax expression);
    internal abstract virtual bool TryGetBaseList(TExpressionSyntax expression, TypeKindOptions& returnValue);
    internal abstract virtual bool IsPublicOnlyAccessibility(TExpressionSyntax expression, Project project);
    internal abstract virtual bool IsGenericName(TSimpleNameSyntax simpleName);
    internal abstract virtual bool IsSimpleName(TExpressionSyntax expression);
    internal abstract virtual Task`1<Solution> TryAddUsingsOrImportToDocumentAsync(Solution updatedSolution, SyntaxNode modifiedRoot, Document document, TSimpleNameSyntax simpleName, string includeUsingsOrImports, AddImportPlacementOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual bool TryGetNameParts(TExpressionSyntax expression, IList`1& nameParts);
    public abstract virtual string GetRootNamespace(CompilationOptions options);
    public abstract virtual Task`1<ValueTuple`3<INamespaceSymbol, INamespaceOrTypeSymbol, Location>> GetOrGenerateEnclosingNamespaceSymbolAsync(INamedTypeSymbol namedTypeSymbol, String[] containers, Document selectedDocument, SyntaxNode selectedDocumentRoot, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateType.AbstractGenerateTypeService`6/<GenerateTypeAsync>d__26")]
public sealed virtual Task`1<ImmutableArray`1<CodeAction>> GenerateTypeAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private ImmutableArray`1<CodeAction> GetActions(SemanticDocument document, SyntaxNode node, State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static bool CanGenerateIntoContainingNamespace(SemanticDocument semanticDocument, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsGeneratingIntoContainingNamespace(SemanticDocument document, SyntaxNode node, State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, CancellationToken cancellationToken);
    protected static string GetTypeName(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state);
    protected static ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, IEnumerable`1<SyntaxNode> typeArguments, CancellationToken cancellationToken);
    protected static Accessibility DetermineDefaultAccessibility(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    protected IList`1<ITypeParameterSymbol> GetAvailableTypeParameters(State<TService, TSimpleNameSyntax, TObjectCreationExpressionSyntax, TExpressionSyntax, TTypeDeclarationSyntax, TArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GenerateType.AbstractGenerateTypeService`6/<IsWithinTheImportingNamespaceAsync>d__34")]
protected static Task`1<bool> IsWithinTheImportingNamespaceAsync(Document document, int triggeringPosition, string includeUsingsOrImports, CancellationToken cancellationToken);
    protected abstract virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    internal abstract virtual bool TryGenerateProperty(TSimpleNameSyntax propertyName, SemanticModel semanticModel, ITypeInferenceService typeInference, CancellationToken cancellationToken, IPropertySymbol& property);
}
internal class Microsoft.CodeAnalysis.GenerateType.GenerateTypeDialogOptions : object {
    [CompilerGeneratedAttribute]
private bool <IsPublicOnlyAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeKindOptions <TypeKindOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttribute>k__BackingField;
    public bool IsPublicOnlyAccessibility { get; }
    public TypeKindOptions TypeKindOptions { get; }
    public bool IsAttribute { get; }
    public GenerateTypeDialogOptions(bool isPublicOnlyAccessibility, TypeKindOptions typeKindOptions, bool isAttribute);
    [CompilerGeneratedAttribute]
public bool get_IsPublicOnlyAccessibility();
    [CompilerGeneratedAttribute]
public TypeKindOptions get_TypeKindOptions();
    [CompilerGeneratedAttribute]
public bool get_IsAttribute();
}
internal class Microsoft.CodeAnalysis.GenerateType.GenerateTypeOptionsResult : object {
    public static GenerateTypeOptionsResult Cancelled;
    [CompilerGeneratedAttribute]
private Accessibility <Accessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <ExistingDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNewFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Folders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeKind <TypeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreFoldersValidIdentifiers>k__BackingField;
    public Accessibility Accessibility { get; }
    public Document ExistingDocument { get; }
    public bool IsCancelled { get; }
    public bool IsNewFile { get; }
    public IList`1<string> Folders { get; }
    public string NewFileName { get; }
    public Project Project { get; }
    public TypeKind TypeKind { get; }
    public string FullFilePath { get; }
    public string TypeName { get; }
    public string DefaultNamespace { get; }
    public bool AreFoldersValidIdentifiers { get; }
    public GenerateTypeOptionsResult(Accessibility accessibility, TypeKind typeKind, string typeName, Project project, bool isNewFile, string newFileName, IList`1<string> folders, string fullFilePath, Document existingDocument, bool areFoldersValidIdentifiers, string defaultNamespace, bool isCancelled);
    private GenerateTypeOptionsResult(bool isCancelled);
    private static GenerateTypeOptionsResult();
    [CompilerGeneratedAttribute]
public Accessibility get_Accessibility();
    [CompilerGeneratedAttribute]
public Document get_ExistingDocument();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public bool get_IsNewFile();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Folders();
    [CompilerGeneratedAttribute]
public string get_NewFileName();
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public TypeKind get_TypeKind();
    [CompilerGeneratedAttribute]
public string get_FullFilePath();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_DefaultNamespace();
    [CompilerGeneratedAttribute]
public bool get_AreFoldersValidIdentifiers();
}
internal interface Microsoft.CodeAnalysis.GenerateType.IGenerateTypeOptionsService {
    public abstract virtual GenerateTypeOptionsResult GetGenerateTypeOptions(string className, GenerateTypeDialogOptions generateTypeDialogOptions, Document document, INotificationService notificationService, IProjectManagementService projectManagementService, ISyntaxFactsService syntaxFactsService);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.GenerateType.IGenerateTypeService {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GenerateTypeAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<ValueTuple`3<INamespaceSymbol, INamespaceOrTypeSymbol, Location>> GetOrGenerateEnclosingNamespaceSymbolAsync(INamedTypeSymbol namedTypeSymbol, String[] containers, Document selectedDocument, SyntaxNode selectedDocumentRoot, CancellationToken cancellationToken);
    public abstract virtual string GetRootNamespace(CompilationOptions options);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.GenerateType.TypeKindOptions : Enum {
    public int value__;
    public static TypeKindOptions None;
    public static TypeKindOptions Class;
    public static TypeKindOptions Structure;
    public static TypeKindOptions Interface;
    public static TypeKindOptions Enum;
    public static TypeKindOptions Delegate;
    public static TypeKindOptions Module;
    public static TypeKindOptions AllOptions;
    public static TypeKindOptions Attribute;
    public static TypeKindOptions BaseList;
    public static TypeKindOptions AllOptionsWithModule;
    public static TypeKindOptions MemberAccessWithNamespace;
    public static TypeKindOptions GenericInCompatibleTypes;
}
internal class Microsoft.CodeAnalysis.GenerateType.TypeKindOptionsHelper : object {
    public static bool IsClass(TypeKindOptions option);
    public static bool IsStructure(TypeKindOptions option);
    public static bool IsInterface(TypeKindOptions option);
    public static bool IsEnum(TypeKindOptions option);
    public static bool IsDelegate(TypeKindOptions option);
    public static bool IsModule(TypeKindOptions option);
    public static TypeKindOptions RemoveOptions(TypeKindOptions fromValue, TypeKindOptions[] removeValues);
    internal static TypeKindOptions AddOption(TypeKindOptions toValue, TypeKindOptions addValue);
}
internal enum Microsoft.CodeAnalysis.Glyph : Enum {
    public int value__;
    public static Glyph None;
    public static Glyph Assembly;
    public static Glyph BasicFile;
    public static Glyph BasicProject;
    public static Glyph ClassPublic;
    public static Glyph ClassProtected;
    public static Glyph ClassPrivate;
    public static Glyph ClassInternal;
    public static Glyph CSharpFile;
    public static Glyph CSharpProject;
    public static Glyph ConstantPublic;
    public static Glyph ConstantProtected;
    public static Glyph ConstantPrivate;
    public static Glyph ConstantInternal;
    public static Glyph DelegatePublic;
    public static Glyph DelegateProtected;
    public static Glyph DelegatePrivate;
    public static Glyph DelegateInternal;
    public static Glyph EnumPublic;
    public static Glyph EnumProtected;
    public static Glyph EnumPrivate;
    public static Glyph EnumInternal;
    public static Glyph EnumMemberPublic;
    public static Glyph EnumMemberProtected;
    public static Glyph EnumMemberPrivate;
    public static Glyph EnumMemberInternal;
    public static Glyph Error;
    public static Glyph StatusInformation;
    public static Glyph EventPublic;
    public static Glyph EventProtected;
    public static Glyph EventPrivate;
    public static Glyph EventInternal;
    public static Glyph ExtensionMethodPublic;
    public static Glyph ExtensionMethodProtected;
    public static Glyph ExtensionMethodPrivate;
    public static Glyph ExtensionMethodInternal;
    public static Glyph FieldPublic;
    public static Glyph FieldProtected;
    public static Glyph FieldPrivate;
    public static Glyph FieldInternal;
    public static Glyph InterfacePublic;
    public static Glyph InterfaceProtected;
    public static Glyph InterfacePrivate;
    public static Glyph InterfaceInternal;
    public static Glyph Intrinsic;
    public static Glyph Keyword;
    public static Glyph Label;
    public static Glyph Local;
    public static Glyph Namespace;
    public static Glyph MethodPublic;
    public static Glyph MethodProtected;
    public static Glyph MethodPrivate;
    public static Glyph MethodInternal;
    public static Glyph ModulePublic;
    public static Glyph ModuleProtected;
    public static Glyph ModulePrivate;
    public static Glyph ModuleInternal;
    public static Glyph OpenFolder;
    public static Glyph Operator;
    public static Glyph Parameter;
    public static Glyph PropertyPublic;
    public static Glyph PropertyProtected;
    public static Glyph PropertyPrivate;
    public static Glyph PropertyInternal;
    public static Glyph RangeVariable;
    public static Glyph Reference;
    public static Glyph StructurePublic;
    public static Glyph StructureProtected;
    public static Glyph StructurePrivate;
    public static Glyph StructureInternal;
    public static Glyph TypeParameter;
    public static Glyph Snippet;
    public static Glyph CompletionWarning;
    public static Glyph AddReference;
    public static Glyph NuGet;
    public static Glyph TargetTypeMatch;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.GlyphExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<Glyph> GetGlyphs(ImmutableArray`1<string> tags);
    [ExtensionAttribute]
public static Glyph GetFirstGlyph(ImmutableArray`1<string> tags);
    private static Glyph GetGlyph(string tag, ImmutableArray`1<string> allTags);
    public static Accessibility GetAccessibility(ImmutableArray`1<string> tags);
}
internal static class Microsoft.CodeAnalysis.GlyphTags : object {
    public static ImmutableArray`1<string> GetTags(Glyph glyph);
}
internal abstract class Microsoft.CodeAnalysis.GoToBase.AbstractGoToBaseService : object {
    [NullableContextAttribute("1")]
protected abstract virtual Task`1<IMethodSymbol> FindNextConstructorInChainAsync(Solution solution, IMethodSymbol constructor, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected static IMethodSymbol FindBaseNoArgConstructor(IMethodSymbol constructor);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GoToBase.AbstractGoToBaseService/<FindBasesAsync>d__2")]
public sealed virtual Task FindBasesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.GoToBase.FindBaseHelpers : object {
    public static ImmutableArray`1<ISymbol> FindBases(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GoToBase.IGoToBaseService {
    [NullableContextAttribute("1")]
public abstract virtual Task FindBasesAsync(IFindUsagesContext context, Document document, int position, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.GoToDefinition.AbstractGoToDefinitionSymbolService : object {
    protected abstract virtual Task`1<ISymbol> FindRelatedExplicitlyDeclaredSymbolAsync(Project project, ISymbol symbol, CancellationToken cancellationToken);
    protected abstract virtual Nullable`1<int> GetTargetPositionIfControlFlow(SemanticModel semanticModel, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GoToDefinition.AbstractGoToDefinitionSymbolService/<GetSymbolProjectAndBoundSpanAsync>d__2")]
public sealed virtual Task`1<ValueTuple`3<ISymbol, Project, TextSpan>> GetSymbolProjectAndBoundSpanAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GoToDefinition.AbstractGoToDefinitionSymbolService/<GetTargetIfControlFlowAsync>d__3")]
public sealed virtual Task`1<ValueTuple`2<Nullable`1<int>, TextSpan>> GetTargetIfControlFlowAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.GoToDefinition.GoToDefinitionFeatureHelpers : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GoToDefinition.GoToDefinitionFeatureHelpers/<TryGetPreferredSymbolAsync>d__0")]
public static Task`1<ISymbol> TryGetPreferredSymbolAsync(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GoToDefinition.GoToDefinitionFeatureHelpers/<GetDefinitionsAsync>d__1")]
public static Task`1<ImmutableArray`1<DefinitionItem>> GetDefinitionsAsync(ISymbol symbol, Solution solution, bool thirdPartyNavigationAllowed, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.GoToDefinition.IGoToDefinitionSymbolService {
    public abstract virtual Task`1<ValueTuple`3<ISymbol, Project, TextSpan>> GetSymbolProjectAndBoundSpanAsync(Document document, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<ValueTuple`2<Nullable`1<int>, TextSpan>> GetTargetIfControlFlowAsync(Document document, int position, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Highlighting.AbstractKeywordHighlighter : object {
    private bool _findInsideTrivia;
    [NullableAttribute("1")]
private static ObjectPool`1<List`1<TextSpan>> s_textSpanListPool;
    protected AbstractKeywordHighlighter(bool findInsideTrivia);
    private static AbstractKeywordHighlighter();
    [NullableContextAttribute("1")]
protected abstract virtual bool IsHighlightableNode(SyntaxNode node);
    protected virtual bool ContainsHighlightableToken(TemporaryArray`1& tokens);
    [NullableContextAttribute("1")]
public sealed virtual void AddHighlights(SyntaxNode root, int position, List`1<TextSpan> highlights, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static bool AnyIntersects(int position, List`1<TextSpan> highlights);
    [NullableContextAttribute("1")]
protected abstract virtual void AddHighlightsForNode(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
    protected static TextSpan EmptySpan(int position);
    internal void AddTouchingTokens(SyntaxNode root, int position, TemporaryArray`1& tokens);
    private static void AddTouchingTokens(SyntaxNode root, int position, TemporaryArray`1& tokens, bool findInsideTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Highlighting.AbstractKeywordHighlighter`1 : AbstractKeywordHighlighter {
    protected AbstractKeywordHighlighter`1(bool findInsideTrivia);
    protected sealed virtual bool IsHighlightableNode(SyntaxNode node);
    protected sealed virtual void AddHighlightsForNode(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
    protected abstract virtual void AddHighlights(TNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.CodeAnalysis.Highlighting.ExportHighlighterAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public ExportHighlighterAttribute(string language);
    [CompilerGeneratedAttribute]
public string get_Language();
}
[ExportAttribute("Microsoft.CodeAnalysis.Highlighting.IHighlightingService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Highlighting.HighlightingService : object {
    private List`1<Lazy`2<IHighlighter, LanguageMetadata>> _highlighters;
    private static ObjectPool`1<List`1<TextSpan>> s_listPool;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public HighlightingService(IEnumerable`1<Lazy`2<IHighlighter, LanguageMetadata>> highlighters);
    private static HighlightingService();
    public sealed virtual void AddHighlights(SyntaxNode root, int position, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Highlighting.IHighlighter {
    public abstract virtual void AddHighlights(SyntaxNode root, int position, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Highlighting.IHighlightingService {
    public abstract virtual void AddHighlights(SyntaxNode root, int position, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.CompileTimeSolutionProvider : object {
    private static string RazorEncConfigFileName;
    private static string RazorSourceGeneratorTypeName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_razorSourceGeneratorAssemblyNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_razorSourceGeneratorFileNamePrefixes;
    private object _gate;
    private ConditionalWeakTable`2<Solution, Solution> _designTimeToCompileTimeSolution;
    [NullableAttribute("2")]
private Solution _lastCompileTimeSolution;
    public CompileTimeSolutionProvider(Workspace workspace);
    private static CompileTimeSolutionProvider();
    private static bool IsRazorAnalyzerConfig(TextDocumentState documentState);
    public sealed virtual Solution GetCompileTimeSolution(Solution designTimeSolution);
    private static string GetIdentifierFromPath(string filePath);
    private static bool IsRazorDesignTimeDocument(DocumentState documentState);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Host.CompileTimeSolutionProvider/<TryGetCompileTimeDocumentAsync>d__13")]
internal static Task`1<Document> TryGetCompileTimeDocumentAsync(Document designTimeDocument, Solution compileTimeSolution, CancellationToken cancellationToken, string generatedDocumentPathPrefix);
    private static OneOrMany`1<string> BuildGeneratedDocumentPaths(string designTimeProjectDirectoryName, string designTimeDocumentFilePath, string generatedDocumentPathPrefix);
    private static string GetRelativeDocumentPath(string projectDirectory, string designTimeDocumentFilePath);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__8_0(object s, WorkspaceChangeEventArgs e);
    [CompilerGeneratedAttribute]
internal static string <BuildGeneratedDocumentPaths>g__GetGeneratedDocumentPath|14_1(string prefix, string relativeDocumentPath);
}
internal interface Microsoft.CodeAnalysis.Host.ICompileTimeSolutionProvider {
    [NullableContextAttribute("1")]
public abstract virtual Solution GetCompileTimeSolution(Solution designTimeSolution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ImplementAbstractClass.AbstractImplementAbstractClassCodeFixProvider`1 : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractImplementAbstractClassCodeFixProvider`1(string diagnosticId);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual SyntaxToken GetClassIdentifier(TClassNode classNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.AbstractImplementAbstractClassCodeFixProvider`1/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static string GetCodeActionId(string assemblyName, string abstractTypeFullyQualifiedName, string through);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData : object {
    private Document _document;
    private ImplementTypeGenerationOptions _options;
    private SyntaxNode _classNode;
    private SyntaxToken _classIdentifier;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> _unimplementedMembers;
    public INamedTypeSymbol ClassType;
    public INamedTypeSymbol AbstractClassType;
    public ImplementAbstractClassData(Document document, ImplementTypeGenerationOptions options, SyntaxNode classNode, SyntaxToken classIdentifier, INamedTypeSymbol classType, INamedTypeSymbol abstractClassType, ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> unimplementedMembers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<TryGetDataAsync>d__8")]
public static Task`1<ImplementAbstractClassData> TryGetDataAsync(Document document, SyntaxNode classNode, SyntaxToken classIdentifier, ImplementTypeGenerationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<TryImplementAbstractClassAsync>d__9")]
public static Task`1<Document> TryImplementAbstractClassAsync(Document document, SyntaxNode classNode, SyntaxToken classIdentifier, ImplementTypeGenerationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<ImplementAbstractClassAsync>d__10")]
public Task`1<Document> ImplementAbstractClassAsync(ISymbol throughMember, Nullable`1<bool> canDelegateAllMembers, CancellationToken cancellationToken);
    private ImmutableArray`1<ISymbol> GenerateMembers(Compilation compilation, ISymbol throughMember, ImplementTypePropertyGenerationBehavior propertyGenerationBehavior, CancellationToken cancellationToken);
    private ISymbol GenerateMember(Compilation compilation, ISymbol member, ISymbol throughMember, ImplementTypePropertyGenerationBehavior propertyGenerationBehavior, CancellationToken cancellationToken);
    private ISymbol GenerateMember(Compilation compilation, ISymbol member, ISymbol throughMember, bool addUnsafe, ImplementTypePropertyGenerationBehavior propertyGenerationBehavior);
    private ISymbol GenerateMethod(Compilation compilation, IMethodSymbol method, ISymbol throughMember, DeclarationModifiers modifiers, Accessibility accessibility);
    private IPropertySymbol GenerateProperty(Compilation compilation, IPropertySymbol property, ISymbol throughMember, DeclarationModifiers modifiers, Accessibility accessibility, ImplementTypePropertyGenerationBehavior propertyGenerationBehavior);
    private IEventSymbol GenerateEvent(IEventSymbol event, ISymbol throughMember, Accessibility accessibility, DeclarationModifiers modifiers);
    [NullableContextAttribute("2")]
private IMethodSymbol GetEventAddOrRemoveMethod(IEventSymbol event, IMethodSymbol accessor, ISymbol throughMember, Func`3<SyntaxNode, SyntaxNode, SyntaxNode> createAddOrRemoveHandler);
    [NullableContextAttribute("2")]
private bool ShouldGenerateAccessor(IMethodSymbol method);
    public ImmutableArray`1<ValueTuple`2<ISymbol, bool>> GetDelegatableMembers(CancellationToken cancellationToken);
    private static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ImplementAbstractClass.ImplementAbstractClassData/<GetBaseTypesAndThis>d__21")]
private static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [CompilerGeneratedAttribute]
private bool <GetDelegatableMembers>b__19_0(ITypeSymbol t);
}
internal abstract class Microsoft.CodeAnalysis.ImplementInterface.AbstractImplementInterfaceService : object {
    protected static string DisposingName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_disposedValueNameParts;
    [NullableAttribute("1")]
private static SymbolDisplayFormat s_format;
    protected bool CanImplementImplicitly { get; }
    protected bool HasHiddenExplicitImplementation { get; }
    private static AbstractImplementInterfaceService();
    protected abstract virtual string ToDisplayString(IMethodSymbol disposeImplMethod, SymbolDisplayFormat format);
    protected abstract virtual bool get_CanImplementImplicitly();
    protected abstract virtual bool get_HasHiddenExplicitImplementation();
    protected abstract virtual bool TryInitializeState(Document document, SemanticModel model, SyntaxNode interfaceNode, CancellationToken cancellationToken, SyntaxNode& classOrStructDecl, INamedTypeSymbol& classOrStructType, IEnumerable`1& interfaceTypes);
    protected abstract virtual bool AllowDelegateAndEnumConstraints(ParseOptions options);
    protected abstract virtual SyntaxNode AddCommentInsideIfStatement(SyntaxNode ifDisposingStatement, SyntaxTriviaList trivia);
    protected abstract virtual SyntaxNode CreateFinalizer(SyntaxGenerator generator, INamedTypeSymbol classType, string disposeMethodDisplayString);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImplementInterface.AbstractImplementInterfaceService/<ImplementInterfaceAsync>d__13")]
public sealed virtual Task`1<Document> ImplementInterfaceAsync(Document document, ImplementTypeGenerationOptions options, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<CodeAction> GetCodeActions(Document document, ImplementTypeGenerationOptions options, SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ImplementInterface.AbstractImplementInterfaceService/<GetActions>d__15")]
private IEnumerable`1<CodeAction> GetActions(Document document, ImplementTypeGenerationOptions options, State state, CancellationToken cancellationToken);
    private static bool AnyImplementedImplicitly(State state);
    private static ImmutableArray`1<ISymbol> GetDelegatableMembers(State state, CancellationToken cancellationToken);
    protected static TNode AddComment(SyntaxGenerator g, string comment, TNode node);
    protected static TNode AddComments(SyntaxGenerator g, string comment1, string comment2, TNode node);
    protected static TNode AddComments(SyntaxGenerator g, String[] comments, TNode node);
    protected static SyntaxTriviaList CreateCommentTrivia(SyntaxGenerator generator, String[] comments);
    [NullableContextAttribute("1")]
private static IMethodSymbol TryGetIDisposableDispose(Compilation compilation);
    [NullableContextAttribute("1")]
private static bool ShouldImplementDisposePattern(State state, bool explicitly);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ImplementInterface.IImplementInterfaceService {
    public abstract virtual Task`1<Document> ImplementInterfaceAsync(Document document, ImplementTypeGenerationOptions options, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<CodeAction> GetCodeActions(Document document, ImplementTypeGenerationOptions options, SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.ImplementInterface.ImplementHelpers : object {
    [NullableContextAttribute("1")]
public static ImmutableArray`1<ISymbol> GetDelegatableMembers(Document document, INamedTypeSymbol namedType, Func`2<ITypeSymbol, bool> includeMemberType, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService : object {
    private static SymbolDisplayFormat s_displayFormat;
    protected string GlobalImportsTitle { get; }
    private static AbstractInheritanceMarginService();
    protected abstract virtual ImmutableArray`1<SyntaxNode> GetMembers(IEnumerable`1<SyntaxNode> nodesToSearch);
    protected abstract virtual SyntaxToken GetDeclarationToken(SyntaxNode declarationNode);
    protected abstract virtual string get_GlobalImportsTitle();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<GetInheritanceMemberItemsAsync>d__4")]
public sealed virtual ValueTask`1<ImmutableArray`1<InheritanceMarginItem>> GetInheritanceMemberItemsAsync(Document document, TextSpan spanToSearch, bool includeGlobalImports, bool frozenPartialSemantics, CancellationToken cancellationToken);
    private static bool CanHaveInheritanceTarget(ISymbol symbol);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<GetSymbolInheritanceChainItemsAsync>d__7")]
private static ValueTask`1<ImmutableArray`1<InheritanceMarginItem>> GetSymbolInheritanceChainItemsAsync(Project project, Document document, ImmutableArray`1<ValueTuple`2<ISymbol, int>> symbolAndLineNumbers, bool frozenPartialSemantics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<GetMemberSymbolsAsync>d__8")]
private ValueTask`1<ValueTuple`2<Project, ImmutableArray`1<ValueTuple`2<ISymbol, int>>>> GetMemberSymbolsAsync(Document document, TextSpan spanToSearch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<GetInheritanceMarginItemsInProcessAsync>d__9")]
private Task`1<ImmutableArray`1<InheritanceMarginItem>> GetInheritanceMarginItemsInProcessAsync(Document document, TextSpan spanToSearch, bool includeGlobalImports, bool frozenPartialSemantics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<GetGlobalImportsItemsAsync>d__10")]
private Task`1<ImmutableArray`1<InheritanceMarginItem>> GetGlobalImportsItemsAsync(Document document, TextSpan spanToSearch, bool frozenPartialSemantics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<AddInheritanceMemberItemsForNamedTypeAsync>d__11")]
private static ValueTask AddInheritanceMemberItemsForNamedTypeAsync(Solution solution, INamedTypeSymbol memberSymbol, int lineNumber, ArrayBuilder`1<InheritanceMarginItem> builder, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<AddInheritanceMemberItemsForMembersAsync>d__12")]
private static ValueTask AddInheritanceMemberItemsForMembersAsync(Solution solution, ISymbol memberSymbol, int lineNumber, ArrayBuilder`1<InheritanceMarginItem> builder, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<CreateInheritanceMemberItemForInterfaceAsync>d__13")]
private static ValueTask`1<Nullable`1<InheritanceMarginItem>> CreateInheritanceMemberItemForInterfaceAsync(Solution solution, INamedTypeSymbol interfaceSymbol, int lineNumber, ImmutableArray`1<ISymbol> baseSymbols, ImmutableArray`1<ISymbol> derivedTypesSymbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<CreateInheritanceMemberItemForInterfaceMemberAsync>d__14")]
private static ValueTask`1<Nullable`1<InheritanceMarginItem>> CreateInheritanceMemberItemForInterfaceMemberAsync(Solution solution, ISymbol memberSymbol, int lineNumber, ImmutableArray`1<ISymbol> implementingMembers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<CreateInheritanceItemForClassAndStructureAsync>d__15")]
private static ValueTask`1<Nullable`1<InheritanceMarginItem>> CreateInheritanceItemForClassAndStructureAsync(Solution solution, INamedTypeSymbol memberSymbol, int lineNumber, ImmutableArray`1<ISymbol> baseSymbols, ImmutableArray`1<ISymbol> derivedTypesSymbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<CreateInheritanceMemberItemForClassOrStructMemberAsync>d__16")]
private static ValueTask`1<Nullable`1<InheritanceMarginItem>> CreateInheritanceMemberItemForClassOrStructMemberAsync(Solution solution, ISymbol memberSymbol, int lineNumber, ImmutableArray`1<ISymbol> implementedMembers, ImmutableArray`1<ISymbol> overridingMembers, ImmutableArray`1<ISymbol> overriddenMembers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<CreateInheritanceItemAsync>d__17")]
private static ValueTask`1<Nullable`1<InheritanceTargetItem>> CreateInheritanceItemAsync(Solution solution, ISymbol targetSymbol, InheritanceRelationship inheritanceRelationship, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetImplementedSymbolsForTypeMember(ISymbol memberSymbol, ImmutableArray`1<ISymbol> overriddenSymbols);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<GetImplementingSymbolsForTypeMemberAsync>d__19")]
private static Task`1<ImmutableArray`1<ISymbol>> GetImplementingSymbolsForTypeMemberAsync(Solution solution, ISymbol memberSymbol, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetOverriddenSymbols(ISymbol memberSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InheritanceMargin.AbstractInheritanceMarginService/<GetDerivedTypesAndImplementationsAsync>d__21")]
private static Task`1<ImmutableArray`1<INamedTypeSymbol>> GetDerivedTypesAndImplementationsAsync(Solution solution, INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    private static DefinitionItem ToSlimDefinitionItem(ISymbol symbol, Solution solution);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<InheritanceTargetItem> GetNonNullTargetItems(ImmutableArray`1<Nullable`1<InheritanceTargetItem>> inheritanceTargetItems);
}
internal interface Microsoft.CodeAnalysis.InheritanceMargin.IInheritanceMarginService {
    public abstract virtual ValueTask`1<ImmutableArray`1<InheritanceMarginItem>> GetInheritanceMemberItemsAsync(Document document, TextSpan spanToSearch, bool includeGlobalImports, bool frozenPartialSemantics, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.InheritanceMargin.InheritanceMarginItem : ValueType {
    [DataMemberAttribute]
public int LineNumber;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string TopLevelDisplayText;
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> DisplayTexts;
    [DataMemberAttribute]
public Glyph Glyph;
    [DataMemberAttribute]
public ImmutableArray`1<InheritanceTargetItem> TargetItems;
    public InheritanceMarginItem(int lineNumber, string topLevelDisplayText, ImmutableArray`1<TaggedText> displayTexts, Glyph glyph, ImmutableArray`1<InheritanceTargetItem> targetItems);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InheritanceMarginItem other);
    public static Nullable`1<InheritanceMarginItem> CreateOrdered(int lineNumber, string topLevelDisplayText, ImmutableArray`1<TaggedText> displayTexts, Glyph glyph, ImmutableArray`1<InheritanceTargetItem> targetItems);
    public static ImmutableArray`1<InheritanceTargetItem> Order(ImmutableArray`1<InheritanceTargetItem> targetItems);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.InheritanceMargin.InheritanceRelationship : Enum {
    public int value__;
    public static InheritanceRelationship None;
    public static InheritanceRelationship ImplementedInterface;
    public static InheritanceRelationship BaseType;
    public static InheritanceRelationship DerivedType;
    public static InheritanceRelationship InheritedInterface;
    public static InheritanceRelationship ImplementingType;
    public static InheritanceRelationship ImplementedMember;
    public static InheritanceRelationship OverriddenMember;
    public static InheritanceRelationship OverridingMember;
    public static InheritanceRelationship ImplementingMember;
    public static InheritanceRelationship InheritedImport;
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.InheritanceMargin.InheritanceTargetItem : ValueType {
    [DataMemberAttribute]
public InheritanceRelationship RelationToMember;
    [NullableAttribute("1")]
[DataMemberAttribute]
public DetachedDefinitionItem DefinitionItem;
    [DataMemberAttribute]
public Glyph Glyph;
    [DataMemberAttribute]
public Glyph LanguageGlyph;
    [NullableAttribute("1")]
[DataMemberAttribute]
public string DisplayName;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string ProjectName;
    [NullableContextAttribute("1")]
public InheritanceTargetItem(InheritanceRelationship relationToMember, DetachedDefinitionItem definitionItem, Glyph glyph, Glyph languageGlyph, string displayName, string projectName);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InheritanceTargetItem left, InheritanceTargetItem right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InheritanceTargetItem left, InheritanceTargetItem right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InheritanceTargetItem other);
}
internal interface Microsoft.CodeAnalysis.InheritanceMargin.IRemoteInheritanceMarginService {
    public abstract virtual ValueTask`1<ImmutableArray`1<InheritanceMarginItem>> GetInheritanceMarginItemsAsync(Checksum solutionChecksum, DocumentId documentId, TextSpan spanToSearch, bool includeGlobalImports, bool frozenPartialSemantics, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6 : AbstractInitializeParameterCodeRefactoringProvider`4<TTypeDeclarationSyntax, TParameterSyntax, TStatementSyntax, TExpressionSyntax> {
    protected abstract virtual bool CanOffer(SyntaxNode body);
    protected abstract virtual bool PrefersThrowExpression(TSimplifierOptions options);
    protected abstract virtual string EscapeResourceString(string input);
    protected abstract virtual TStatementSyntax CreateParameterCheckIfStatement(TExpressionSyntax condition, TStatementSyntax ifTrueStatement, TSimplifierOptions options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6/<GetRefactoringsForAllParametersAsync>d__4")]
protected virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForAllParametersAsync(Document document, SyntaxNode functionDeclaration, IMethodSymbol methodSymbol, IBlockOperation blockStatementOpt, ImmutableArray`1<SyntaxNode> listOfParameterNodes, TextSpan parameterSpan, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6/<GetRefactoringsForSingleParameterAsync>d__5")]
protected virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForSingleParameterAsync(Document document, TParameterSyntax parameterSyntax, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol methodSymbol, IBlockOperation blockStatementOpt, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6/<UpdateDocumentForRefactoringAsync>d__6")]
private Task`1<Document> UpdateDocumentForRefactoringAsync(Document document, IBlockOperation blockStatementOpt, List`1<int> listOfParametersOrdinals, TextSpan parameterSpan, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ValueTuple`2<TParameterSyntax, IParameterSymbol> GetParameterAtOrdinal(int index, IReadOnlyList`1<TParameterSyntax> parameterNodes, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ContainsNullCoalesceCheck(ISyntaxFactsService syntaxFacts, SemanticModel semanticModel, IOperation statement, IParameterSymbol parameter, CancellationToken cancellationToken);
    private static bool IsIfNullCheck(IOperation statement, IParameterSymbol parameter);
    protected bool ParameterValidForNullCheck(Document document, IParameterSymbol parameter, SemanticModel semanticModel, IBlockOperation blockStatementOpt, CancellationToken cancellationToken);
    private static bool IsStringCheck(IOperation condition, IParameterSymbol parameter);
    private static bool IsNullCheck(IOperation operand1, IOperation operand2, IParameterSymbol parameter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6/<AddNullCheckAsync>d__13")]
private Task`1<Document> AddNullCheckAsync(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatement, TSimplifierOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6/<AddStringCheckAsync>d__14")]
private Task`1<Document> AddStringCheckAsync(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, string methodName, TSimplifierOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6/<AddNullCheckStatementAsync>d__15")]
private Task`1<Document> AddNullCheckStatementAsync(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatement, Func`3<SemanticModel, SyntaxGenerator, TStatementSyntax> generateNullCheck, CancellationToken cancellationToken);
    private TStatementSyntax CreateNullCheckStatement(SemanticModel semanticModel, SyntaxGenerator generator, IParameterSymbol parameter, TSimplifierOptions options);
    private TStatementSyntax CreateStringCheckStatement(Compilation compilation, SyntaxGenerator generator, IParameterSymbol parameter, string methodName, TSimplifierOptions options);
    private static SyntaxNode GetStatementToAddNullCheckAfter(SemanticModel semanticModel, IParameterSymbol parameter, IBlockOperation blockStatement, CancellationToken cancellationToken);
    private static IOperation TryFindParameterCheckStatement(SemanticModel semanticModel, IParameterSymbol parameterSymbol, IBlockOperation blockStatement, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractAddParameterCheckCodeRefactoringProvider`6/<TryAddNullCheckToAssignmentAsync>d__20")]
private Task`1<Document> TryAddNullCheckToAssignmentAsync(Document document, IParameterSymbol parameter, IBlockOperation blockStatement, TSimplifierOptions options, CancellationToken cancellationToken);
    private static SyntaxNode GetTypeNode(Compilation compilation, SyntaxGenerator generator, Type type);
    private static SyntaxNode CreateArgumentNullException(Compilation compilation, SyntaxGenerator generator, IParameterSymbol parameter);
    private SyntaxNode CreateArgumentException(Compilation compilation, SyntaxGenerator generator, IParameterSymbol parameter, string methodName);
    private static ValueTuple`2<string, string> GetPreAndPostTextParts(string text);
    private static SyntaxNode InterpolatedStringText(SyntaxGenerator generator, string content, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4 : AbstractInitializeParameterCodeRefactoringProvider`4<TTypeDeclarationSyntax, TParameterSyntax, TStatementSyntax, TExpressionSyntax> {
    [NullableContextAttribute("2")]
protected abstract virtual SyntaxNode TryGetLastStatement(IBlockOperation blockStatement);
    protected abstract virtual Accessibility DetermineDefaultFieldAccessibility(INamedTypeSymbol containingType);
    protected abstract virtual Accessibility DetermineDefaultPropertyAccessibility();
    protected abstract virtual SyntaxNode GetAccessorBody(IMethodSymbol accessor, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode RemoveThrowNotImplemented(SyntaxNode propertySyntax);
    protected abstract virtual bool TryUpdateTupleAssignment(IBlockOperation blockStatement, IParameterSymbol parameter, ISymbol fieldOrProperty, SyntaxEditor editor);
    protected sealed virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForAllParametersAsync(Document document, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatementOpt, ImmutableArray`1<SyntaxNode> listOfParameterNodes, TextSpan parameterSpan, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<GetRefactoringsForSingleParameterAsync>d__7")]
protected sealed virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForSingleParameterAsync(Document document, TParameterSyntax parameterSyntax, IParameterSymbol parameter, SyntaxNode constructorDeclaration, IMethodSymbol method, IBlockOperation blockStatement, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<HandleNoExistingFieldOrPropertyAsync>d__8")]
private Task`1<ImmutableArray`1<CodeAction>> HandleNoExistingFieldOrPropertyAsync(Document document, IParameterSymbol parameter, SyntaxNode constructorDeclaration, IMethodSymbol method, IBlockOperation blockStatement, ImmutableArray`1<NamingRule> rules, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private ValueTuple`2<CodeAction, CodeAction> AddAllParameterInitializationActions(Document document, SyntaxNode constructorDeclaration, IMethodSymbol method, IBlockOperation blockStatement, ImmutableArray`1<NamingRule> rules, AccessibilityModifiersRequired accessibilityModifiersRequired, CodeGenerationOptionsProvider fallbackOptions);
    private ValueTuple`2<CodeAction, CodeAction> AddSpecificParameterInitializationActions(Document document, IParameterSymbol parameter, SyntaxNode constructorDeclaration, IBlockOperation blockStatement, ImmutableArray`1<NamingRule> rules, AccessibilityModifiersRequired accessibilityModifiersRequired, CodeGenerationOptionsProvider fallbackOptions);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<IParameterSymbol> GetParametersWithoutAssociatedMembers(IBlockOperation blockStatement, ImmutableArray`1<NamingRule> rules, IMethodSymbol method);
    private ImmutableArray`1<CodeAction> HandleExistingFieldOrProperty(Document document, IParameterSymbol parameter, SyntaxNode functionDeclaration, IBlockOperation blockStatement, ISymbol fieldOrProperty, bool isThrowNotImplementedProperty, CodeGenerationOptionsProvider fallbackOptions);
    [NullableContextAttribute("2")]
private static ISymbol TryFindSiblingFieldOrProperty(IParameterSymbol parameter, IBlockOperation blockStatement);
    private IFieldSymbol CreateField(IParameterSymbol parameter, AccessibilityModifiersRequired accessibilityModifiersRequired, ImmutableArray`1<NamingRule> rules);
    private IPropertySymbol CreateProperty(IParameterSymbol parameter, AccessibilityModifiersRequired accessibilityModifiersRequired, ImmutableArray`1<NamingRule> rules);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<AddAllSymbolInitializationsAsync>d__16")]
private Task`1<Solution> AddAllSymbolInitializationsAsync(Document document, SyntaxNode constructorDeclaration, IBlockOperation blockStatement, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<ISymbol> fieldsOrProperties, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<AddSingleSymbolInitializationAsync>d__17")]
private Task`1<Solution> AddSingleSymbolInitializationAsync(Document document, SyntaxNode constructorDeclaration, IBlockOperation blockStatement, IParameterSymbol parameter, ISymbol fieldOrProperty, bool isThrowNotImplementedProperty, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private void AddAssignment(SyntaxNode constructorDeclaration, IBlockOperation blockStatement, IParameterSymbol parameter, ISymbol fieldOrProperty, SyntaxEditor editor);
    private static CodeGenerationContext GetAddContext(IParameterSymbol parameter, IBlockOperation blockStatement, SyntaxNode typeDeclaration, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private SyntaxNode TryGetStatementToAddInitializationAfter(IParameterSymbol parameter, IBlockOperation blockStatement);
    [NullableContextAttribute("2")]
private static IOperation TryFindFieldOrPropertyAssignmentStatement(IParameterSymbol parameter, IBlockOperation blockStatement);
    [NullableContextAttribute("2")]
protected static bool TryGetPartsOfTupleAssignmentOperation(IOperation operation, ITupleOperation& targetTuple, ITupleOperation& valueTuple);
    [NullableContextAttribute("2")]
private static IOperation TryFindFieldOrPropertyAssignmentStatement(IParameterSymbol parameter, IBlockOperation blockStatement, ISymbol& fieldOrProperty);
    private static bool IsParameterReferenceOrCoalesceOfParameterReference(IAssignmentOperation assignmentExpression, IParameterSymbol parameter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeMemberFromParameterCodeRefactoringProvider`4/<TryFindMatchingUninitializedFieldOrPropertySymbolAsync>d__25")]
private Task`1<ValueTuple`2<ISymbol, bool>> TryFindMatchingUninitializedFieldOrPropertySymbolAsync(Document document, IParameterSymbol parameter, IBlockOperation blockStatement, ImmutableArray`1<NamingRule> rules, ImmutableArray`1<string> parameterWords, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <TryFindMatchingUninitializedFieldOrPropertySymbolAsync>g__ContainsMemberAssignment|25_0(IBlockOperation blockStatement, ISymbol member);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <TryFindMatchingUninitializedFieldOrPropertySymbolAsync>g__IsThrowNotImplementedProperty|25_1(IPropertySymbol property, <>c__DisplayClass25_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeParameterCodeRefactoringProvider`4 : CodeRefactoringProvider {
    protected abstract virtual bool IsFunctionDeclaration(SyntaxNode node);
    protected abstract virtual bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    protected abstract virtual SyntaxNode GetBody(SyntaxNode functionDeclaration);
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForAllParametersAsync(Document document, SyntaxNode functionDeclaration, IMethodSymbol method, IBlockOperation blockStatement, ImmutableArray`1<SyntaxNode> listOfParameterNodes, TextSpan parameterSpan, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetRefactoringsForSingleParameterAsync(Document document, TParameterSyntax parameterSyntax, IParameterSymbol parameter, SyntaxNode functionDeclaration, IMethodSymbol methodSymbol, IBlockOperation blockStatement, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfter, TStatementSyntax statement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InitializeParameter.AbstractInitializeParameterCodeRefactoringProvider`4/<ComputeRefactoringsAsync>d__6")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    protected bool CanOfferRefactoring(SyntaxNode functionDeclaration, SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, IBlockOperation& blockStatement);
    protected static bool ContainsParameterReference(SemanticModel semanticModel, IOperation condition, IParameterSymbol parameter, CancellationToken cancellationToken);
    protected static bool IsFieldOrPropertyAssignment(IOperation statement, INamedTypeSymbol containingType, IAssignmentOperation& assignmentExpression);
    protected static bool IsFieldOrPropertyAssignment(IOperation statement, INamedTypeSymbol containingType, IAssignmentOperation& assignmentExpression, ISymbol& fieldOrProperty);
    protected static bool IsFieldOrPropertyReference(IOperation operation, INamedTypeSymbol containingType);
    [NullableContextAttribute("2")]
protected static bool IsFieldOrPropertyReference(IOperation operation, INamedTypeSymbol containingType, ISymbol& fieldOrProperty);
    [CompilerGeneratedAttribute]
internal static bool <ComputeRefactoringsAsync>g__TryGetParameterSymbol|6_0(SyntaxNode parameterNode, SemanticModel semanticModel, IParameterSymbol& parameter, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.InitializeParameter.InitializeParameterHelpersCore : object {
    public static ImmutableArray`1<ValueTuple`2<IParameterSymbol, bool>> GetSiblingParameters(IParameterSymbol parameter);
    public static bool IsParameterReference(IOperation operation, IParameterSymbol parameter);
    public static bool IsParameterReferenceOrCoalesceOfParameterReference(IOperation value, IParameterSymbol parameter);
    public static string GenerateUniqueName(IParameterSymbol parameter, ImmutableArray`1<string> parameterNameParts, NamingRule rule);
}
internal abstract class Microsoft.CodeAnalysis.InlineHints.AbstractInlineHintsService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineHints.AbstractInlineHintsService/<GetInlineHintsAsync>d__0")]
public sealed virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, InlineHintsOptions options, bool displayAllOverride, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InlineHints.AbstractInlineParameterNameHintsService : object {
    protected abstract virtual void AddAllParameterNameHintLocations(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, ArrayBuilder`1<ValueTuple`4<int, string, IParameterSymbol, HintKind>> buffer, CancellationToken cancellationToken);
    protected abstract virtual bool IsIndexer(SyntaxNode node, IParameterSymbol parameter);
    protected abstract virtual string GetReplacementText(string parameterName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineHints.AbstractInlineParameterNameHintsService/<GetInlineHintsAsync>d__4")]
public sealed virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, InlineParameterHintsOptions options, SymbolDescriptionOptions displayOptions, bool displayAllOverride, CancellationToken cancellationToken);
    private static bool ParametersDifferOnlyBySuffix(ArrayBuilder`1<ValueTuple`4<int, string, IParameterSymbol, HintKind>> parameterHints);
    private static bool HintMatches(HintKind kind, bool literalParameters, bool objectCreationParameters, bool otherParameters);
    [NullableContextAttribute("2")]
protected static bool MatchesMethodIntent(IParameterSymbol parameter);
    private static bool ParameterMatchesArgumentName(string identifierArgument, IParameterSymbol parameter, ISyntaxFactsService syntaxFacts);
    protected static string GetIdentifierNameFromArgument(SyntaxNode argument, ISyntaxFactsService syntaxFacts);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__ParametersDifferOnlyByAlphaSuffix|5_0(ArrayBuilder`1<ValueTuple`4<int, string, IParameterSymbol, HintKind>> parameterHints);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__ParametersDifferOnlyByNumericSuffix|5_1(ArrayBuilder`1<ValueTuple`4<int, string, IParameterSymbol, HintKind>> parameterHints);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__HasAlphaSuffix|5_2(IParameterSymbol parameter, ReadOnlyMemory`1& prefix);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__HasNumericSuffix|5_3(IParameterSymbol parameter, ReadOnlyMemory`1& prefix);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__IsUpperAlpha|5_4(char c);
    [CompilerGeneratedAttribute]
internal static bool <ParametersDifferOnlyBySuffix>g__IsNumeric|5_5(char c);
    [CompilerGeneratedAttribute]
internal static bool <MatchesMethodIntent>g__TryGetSuffix|7_0(string prefix, string nameValue, ReadOnlyMemory`1& suffix);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <MatchesMethodIntent>g__SuffixMatchesParameterName|7_1(ReadOnlyMemory`1<char> suffix, string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InlineHints.AbstractInlineTypeHintsService : object {
    protected static SymbolDisplayFormat s_minimalTypeStyle;
    private static AbstractInlineTypeHintsService();
    protected abstract virtual Nullable`1<TypeHint> TryGetTypeHint(SemanticModel semanticModel, SyntaxNode node, bool displayAllOverride, bool forImplicitVariableTypes, bool forLambdaParameterTypes, bool forImplicitObjectCreation, bool forCollectionExpressions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineHints.AbstractInlineTypeHintsService/<GetInlineHintsAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, InlineTypeHintsOptions options, SymbolDescriptionOptions displayOptions, bool displayAllOverride, CancellationToken cancellationToken);
    private static void AddParts(IStructuralTypeDisplayService anonymousTypeService, ArrayBuilder`1<SymbolDisplayPart> finalParts, ImmutableArray`1<SymbolDisplayPart> parts, SemanticModel semanticModel, int position, HashSet`1<INamedTypeSymbol> seenSymbols);
}
internal interface Microsoft.CodeAnalysis.InlineHints.IInlineHintsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, InlineHintsOptions options, bool displayAllOverride, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.InlineHints.IInlineParameterNameHintsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, InlineParameterHintsOptions options, SymbolDescriptionOptions displayOptions, bool displayAllOverride, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.InlineHints.IInlineTypeHintsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<InlineHint>> GetInlineHintsAsync(Document document, TextSpan textSpan, InlineTypeHintsOptions options, SymbolDescriptionOptions displayOptions, bool displayAllOverride, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.InlineHints.InlineHint : ValueType {
    public TextSpan Span;
    public ImmutableArray`1<TaggedText> DisplayParts;
    public Nullable`1<TextChange> ReplacementTextChange;
    public double Ranking;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<Document, CancellationToken, Task`1<ImmutableArray`1<TaggedText>>> _getDescriptionAsync;
    public InlineHint(TextSpan span, ImmutableArray`1<TaggedText> displayParts, Func`3<Document, CancellationToken, Task`1<ImmutableArray`1<TaggedText>>> getDescriptionAsync);
    public InlineHint(TextSpan span, ImmutableArray`1<TaggedText> displayParts, Nullable`1<TextChange> replacementTextChange, Func`3<Document, CancellationToken, Task`1<ImmutableArray`1<TaggedText>>> getDescriptionAsync);
    public InlineHint(TextSpan span, ImmutableArray`1<TaggedText> displayParts, Nullable`1<TextChange> replacementTextChange, double ranking, Func`3<Document, CancellationToken, Task`1<ImmutableArray`1<TaggedText>>> getDescriptionAsync);
    [NullableContextAttribute("1")]
public Task`1<ImmutableArray`1<TaggedText>> GetDescriptionAsync(Document document, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.InlineHints.InlineHintHelpers : object {
    public static Func`3<Document, CancellationToken, Task`1<ImmutableArray`1<TaggedText>>> GetDescriptionFunction(int position, SymbolKey symbolKey, SymbolDescriptionOptions options);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineHints.InlineHintHelpers/<GetDescriptionAsync>d__1")]
private static Task`1<ImmutableArray`1<TaggedText>> GetDescriptionAsync(Document document, int position, SymbolKey symbolKey, SymbolDescriptionOptions options, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.InlineHints.InlineHintsConstants : object {
    public static double ParameterRanking;
    public static double TypeRanking;
    private static InlineHintsConstants();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.InlineHints.InlineHintsOptions : ValueType {
    [CompilerGeneratedAttribute]
private InlineParameterHintsOptions <ParameterOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineTypeHintsOptions <TypeOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDescriptionOptions <DisplayOptions>k__BackingField;
    public static InlineHintsOptions Default;
    [DataMemberAttribute]
public InlineParameterHintsOptions ParameterOptions { get; public set; }
    [DataMemberAttribute]
public InlineTypeHintsOptions TypeOptions { get; public set; }
    [DataMemberAttribute]
public SymbolDescriptionOptions DisplayOptions { get; public set; }
    private static InlineHintsOptions();
    [CompilerGeneratedAttribute]
public InlineParameterHintsOptions get_ParameterOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParameterOptions(InlineParameterHintsOptions value);
    [CompilerGeneratedAttribute]
public InlineTypeHintsOptions get_TypeOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeOptions(InlineTypeHintsOptions value);
    [CompilerGeneratedAttribute]
public SymbolDescriptionOptions get_DisplayOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisplayOptions(SymbolDescriptionOptions value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InlineHintsOptions left, InlineHintsOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InlineHintsOptions left, InlineHintsOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InlineHintsOptions other);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.InlineHints.InlineParameterHintsOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <EnabledForParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForLiteralParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForIndexerParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForObjectCreationParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForOtherParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressForParametersThatDifferOnlyBySuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressForParametersThatMatchMethodIntent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressForParametersThatMatchArgumentName>k__BackingField;
    public static InlineParameterHintsOptions Default;
    [DataMemberAttribute]
public bool EnabledForParameters { get; public set; }
    [DataMemberAttribute]
public bool ForLiteralParameters { get; public set; }
    [DataMemberAttribute]
public bool ForIndexerParameters { get; public set; }
    [DataMemberAttribute]
public bool ForObjectCreationParameters { get; public set; }
    [DataMemberAttribute]
public bool ForOtherParameters { get; public set; }
    [DataMemberAttribute]
public bool SuppressForParametersThatDifferOnlyBySuffix { get; public set; }
    [DataMemberAttribute]
public bool SuppressForParametersThatMatchMethodIntent { get; public set; }
    [DataMemberAttribute]
public bool SuppressForParametersThatMatchArgumentName { get; public set; }
    private static InlineParameterHintsOptions();
    [CompilerGeneratedAttribute]
public bool get_EnabledForParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EnabledForParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForLiteralParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForLiteralParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForIndexerParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForIndexerParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForObjectCreationParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForObjectCreationParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForOtherParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForOtherParameters(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressForParametersThatDifferOnlyBySuffix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SuppressForParametersThatDifferOnlyBySuffix(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressForParametersThatMatchMethodIntent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SuppressForParametersThatMatchMethodIntent(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressForParametersThatMatchArgumentName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SuppressForParametersThatMatchArgumentName(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InlineParameterHintsOptions left, InlineParameterHintsOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InlineParameterHintsOptions left, InlineParameterHintsOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InlineParameterHintsOptions other);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.InlineHints.InlineTypeHintsOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <EnabledForTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForImplicitVariableTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForLambdaParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForImplicitObjectCreation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForCollectionExpressions>k__BackingField;
    public static InlineTypeHintsOptions Default;
    [DataMemberAttribute]
public bool EnabledForTypes { get; public set; }
    [DataMemberAttribute]
public bool ForImplicitVariableTypes { get; public set; }
    [DataMemberAttribute]
public bool ForLambdaParameterTypes { get; public set; }
    [DataMemberAttribute]
public bool ForImplicitObjectCreation { get; public set; }
    [DataMemberAttribute]
public bool ForCollectionExpressions { get; public set; }
    private static InlineTypeHintsOptions();
    [CompilerGeneratedAttribute]
public bool get_EnabledForTypes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EnabledForTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForImplicitVariableTypes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForImplicitVariableTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForLambdaParameterTypes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForLambdaParameterTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForImplicitObjectCreation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForImplicitObjectCreation(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForCollectionExpressions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForCollectionExpressions(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InlineTypeHintsOptions left, InlineTypeHintsOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InlineTypeHintsOptions left, InlineTypeHintsOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InlineTypeHintsOptions other);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.InlineHints.TypeHint : ValueType {
    private static ImmutableArray`1<SymbolDisplayPart> s_spaceArray;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextChange> <TextChange>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SymbolDisplayPart> <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SymbolDisplayPart> <Suffix>k__BackingField;
    [NullableAttribute("1")]
public ITypeSymbol Type { get; }
    public TextSpan Span { get; }
    public Nullable`1<TextChange> TextChange { get; }
    public ImmutableArray`1<SymbolDisplayPart> Prefix { get; }
    public ImmutableArray`1<SymbolDisplayPart> Suffix { get; }
    [NullableContextAttribute("1")]
public TypeHint(ITypeSymbol type, TextSpan span, Nullable`1<TextChange> textChange, bool leadingSpace, bool trailingSpace);
    private static TypeHint();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public Nullable`1<TextChange> get_TextChange();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SymbolDisplayPart> get_Prefix();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SymbolDisplayPart> get_Suffix();
    private static ImmutableArray`1<SymbolDisplayPart> CreateSpaceSymbolPartArray(bool hasSpace);
    public void Deconstruct(ITypeSymbol& type, TextSpan& span, Nullable`1& textChange, ImmutableArray`1& prefix, ImmutableArray`1& suffix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4 : CodeRefactoringProvider {
    private static string TemporaryName;
    private ISyntaxFacts _syntaxFacts;
    private ISemanticFactsService _semanticFactsService;
    protected AbstractInlineMethodRefactoringProvider`4(ISyntaxFacts syntaxFacts, ISemanticFactsService semanticFactsService);
    protected abstract virtual TExpressionSyntax GetRawInlineExpression(TMethodDeclarationSyntax calleeMethodDeclarationSyntaxNode);
    protected abstract virtual SyntaxNode GenerateTypeSyntax(ITypeSymbol symbol, bool allowVar);
    protected abstract virtual TExpressionSyntax GenerateLiteralExpression(ITypeSymbol typeSymbol, object value);
    protected abstract virtual bool IsFieldDeclarationSyntax(SyntaxNode node);
    protected abstract virtual bool IsValidExpressionUnderExpressionStatement(TExpressionSyntax expressionNode);
    protected abstract virtual bool CanBeReplacedByThrowExpression(SyntaxNode syntaxNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<ComputeRefactoringsAsync>d__10")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private ImmutableArray`1<CodeAction> GenerateCodeActions(Document document, TInvocationSyntax calleeMethodInvocationNode, IMethodSymbol calleeMethodSymbol, TMethodDeclarationSyntax calleeMethodNode, ISymbol callerSymbol, SyntaxNode callerMethodNode, TExpressionSyntax inlineExpression, IInvocationOperation invocationOperation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<InlineMethodAsync>d__12")]
private Task`1<Solution> InlineMethodAsync(Document document, TInvocationSyntax calleeInvocationNode, IMethodSymbol calleeMethodSymbol, TMethodDeclarationSyntax calleeMethodNode, ISymbol callerSymbol, SyntaxNode callerNode, TExpressionSyntax rawInlineExpression, IInvocationOperation invocationOperation, bool removeCalleeDeclarationNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<GetChangedCallerAsync>d__13")]
private Task`1<SyntaxNode> GetChangedCallerAsync(Document document, TInvocationSyntax calleeInvocationNode, IMethodSymbol calleeMethodSymbol, ISymbol callerSymbol, SyntaxNode callerDeclarationNode, TStatementSyntax statementContainsInvocation, TExpressionSyntax rawInlineExpression, MethodParametersInfo<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> methodParametersInfo, InlineMethodContext<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> inlineMethodContext, CancellationToken cancellationToken);
    private ValueTuple`2<SyntaxNode, SyntaxNode> GetInlineNode(TInvocationSyntax calleeInvocationNode, IMethodSymbol calleeMethodSymbol, TStatementSyntax statementContainsInvocation, TExpressionSyntax rawInlineExpression, MethodParametersInfo<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> methodParametersInfo, InlineMethodContext<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> inlineMethodContext, SemanticModel semanticModel, SyntaxGenerator syntaxGenerator, CancellationToken cancellationToken);
    private ISymbol GetCallerSymbol(TInvocationSyntax calleeMethodInvocationNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<GetInlineMethodContextAsync>d__17")]
private Task`1<InlineMethodContext<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax>> GetInlineMethodContextAsync(Document document, TMethodDeclarationSyntax calleeMethodNode, TInvocationSyntax calleeInvocationNode, IMethodSymbol calleeMethodSymbol, TExpressionSyntax rawInlineExpression, MethodParametersInfo<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax> methodParametersInfo, CancellationToken cancellationToken);
    private static ImmutableArray`1<TStatementSyntax> GetLocalDeclarationStatementsNeedInsert(SyntaxGenerator syntaxGenerator, ImmutableArray`1<ValueTuple`2<IParameterSymbol, TExpressionSyntax>> parametersToGenerateFreshVariablesFor, ImmutableArray`1<ValueTuple`2<IParameterSymbol, string>> parametersWithVariableDeclarationArgument, ImmutableDictionary`2<ISymbol, string> renameTable);
    private bool ContainsAwaitExpression(TExpressionSyntax inlineExpression);
    private static TStatementSyntax CreateLocalDeclarationStatement(SyntaxGenerator syntaxGenerator, ImmutableDictionary`2<ISymbol, string> renameTable, ValueTuple`2<IParameterSymbol, TExpressionSyntax> parameterAndExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<ReplaceAllSyntaxNodesForSymbolAsync>d__21")]
private static Task`1<TExpressionSyntax> ReplaceAllSyntaxNodesForSymbolAsync(Document document, TExpressionSyntax inlineExpression, SyntaxGenerator syntaxGenerator, ImmutableDictionary`2<ISymbol, SyntaxNode> replacementTable, CancellationToken cancellationToken);
    private ImmutableDictionary`2<ISymbol, SyntaxNode> ComputeReplacementTable(IMethodSymbol calleeMethodSymbol, ImmutableArray`1<ValueTuple`2<IParameterSymbol, string>> parametersWithVariableDeclarationArgument, ImmutableDictionary`2<IParameterSymbol, TExpressionSyntax> parametersToReplace, SyntaxGenerator syntaxGenerator, ImmutableDictionary`2<ISymbol, string> renameTable);
    private static ImmutableDictionary`2<ISymbol, string> ComputeRenameTable(ISemanticFactsService semanticFacts, SemanticModel callerSemanticModel, SemanticModel calleeSemanticModel, SyntaxNode calleeInvocationNode, TExpressionSyntax rawInlineExpression, ImmutableArray`1<IParameterSymbol> parametersNeedGenerateFreshVariableFor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<GetMethodParametersInfoAsync>d__26")]
private Task`1<MethodParametersInfo<TMethodDeclarationSyntax, TStatementSyntax, TExpressionSyntax, TInvocationSyntax>> GetMethodParametersInfoAsync(Document document, TInvocationSyntax calleeInvocationNode, TMethodDeclarationSyntax calleeMethodNode, TStatementSyntax statementContainingInvocation, TExpressionSyntax rawInlineExpression, IInvocationOperation invocationOperation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<GetArgumentsReadOnlyOnceAsync>d__27")]
private static Task`1<ImmutableArray`1<IArgumentOperation>> GetArgumentsReadOnlyOnceAsync(Document document, ImmutableArray`1<IArgumentOperation> arguments, TMethodDeclarationSyntax calleeMethodNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineMethod.AbstractInlineMethodRefactoringProvider`4/<ShouldMergeInlineContentAndVariableDeclarationArgumentAsync>d__28")]
private Task`1<bool> ShouldMergeInlineContentAndVariableDeclarationArgumentAsync(Document calleeDocument, TInvocationSyntax calleInvocationNode, ImmutableArray`1<ValueTuple`2<IParameterSymbol, string>> parametersWithVariableDeclarationArgument, TExpressionSyntax inlineExpressionNode, CancellationToken cancellationToken);
    private TExpressionSyntax GenerateArgumentExpression(SyntaxGenerator syntaxGenerator, IArgumentOperation argumentOperation);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <InlineMethodAsync>b__12_0(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <ContainsAwaitExpression>b__19_0(SyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.InlineTemporary.AbstractInlineTemporaryCodeRefactoringProvider`2 : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InlineTemporary.AbstractInlineTemporaryCodeRefactoringProvider`2/<GetReferenceLocationsAsync>d__0")]
protected static Task`1<ImmutableArray`1<TIdentifierNameSyntax>> GetReferenceLocationsAsync(Document document, TVariableDeclaratorSyntax variableDeclarator, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.InternalLanguageNames : object {
    [NullableAttribute("1")]
public static string TypeScript;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5 : CodeRefactoringProvider {
    protected abstract virtual SyntaxNode GenerateExpressionFromOptionalParameter(IParameterSymbol parameterSymbol);
    protected abstract virtual SyntaxNode UpdateArgumentListSyntax(SyntaxNode argumentList, SeparatedSyntaxList`1<TArgumentSyntax> arguments);
    protected abstract virtual SyntaxNode GetLocalDeclarationFromDeclarator(SyntaxNode variableDecl);
    protected abstract virtual bool IsDestructor(IMethodSymbol methodSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5/<ComputeRefactoringsAsync>d__5")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool IsValidExpression(SyntaxNode expression, ISyntaxFactsService syntaxFacts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5/<GetActionsAsync>d__7")]
private Task`1<Nullable`1<ValueTuple`2<ImmutableArray`1<CodeAction>, ImmutableArray`1<CodeAction>>>> GetActionsAsync(Document document, TExpressionSyntax expression, IMethodSymbol methodSymbol, SyntaxNode containingMethod, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5/<ShouldExpressionDisplayCodeActionAsync>d__8")]
private static Task`1<ValueTuple`2<bool, bool>> ShouldExpressionDisplayCodeActionAsync(Document document, TExpressionSyntax expression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5/<IntroduceParameterAsync>d__9")]
private Task`1<Solution> IntroduceParameterAsync(Document originalDocument, TExpressionSyntax expression, IMethodSymbol methodSymbol, SyntaxNode containingMethod, Dictionary`2<Document, List`1<TExpressionSyntax>> methodCallSites, bool allOccurrences, IntroduceParameterCodeActionKind<TExpressionSyntax, TInvocationExpressionSyntax, TObjectCreationExpressionSyntax, TIdentifierNameSyntax, TArgumentSyntax> selectedCodeAction, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceParameter.AbstractIntroduceParameterCodeRefactoringProvider`5/<FindCallSitesAsync>d__10")]
protected static Task`1<Dictionary`2<Document, List`1<TExpressionSyntax>>> FindCallSitesAsync(Document document, IMethodSymbol methodSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`3 : CodeRefactoringProvider {
    protected string CodeActionTitle { get; }
    protected abstract virtual string get_CodeActionTitle();
    protected abstract virtual bool CanRefactorToContainBlockStatements(SyntaxNode parent);
    protected abstract virtual SyntaxList`1<TStatementSyntax> GetSurroundingStatements(TLocalDeclarationSyntax declarationStatement);
    protected abstract virtual SyntaxNode WithStatements(SyntaxNode parentOfStatementsToSurround, SyntaxList`1<TStatementSyntax> statements);
    protected abstract virtual bool HasCatchBlocks(TTryStatementSyntax tryStatement);
    protected abstract virtual ValueTuple`2<SyntaxList`1<TStatementSyntax>, SyntaxList`1<TStatementSyntax>> GetTryFinallyStatements(TTryStatementSyntax tryStatement);
    protected abstract virtual TStatementSyntax CreateUsingStatement(TLocalDeclarationSyntax declarationStatement, SyntaxList`1<TStatementSyntax> statementsToSurround);
    protected abstract virtual bool TryCreateUsingLocalDeclaration(ParseOptions options, TLocalDeclarationSyntax declarationStatement, TLocalDeclarationSyntax& usingDeclarationStatement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__9")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`3/<FindDisposableLocalDeclarationAsync>d__10")]
private Task`1<ValueTuple`2<TLocalDeclarationSyntax, string>> FindDisposableLocalDeclarationAsync(Document document, TextSpan selection, CancellationToken cancellationToken);
    private static bool IsLegalUsingStatementType(Compilation compilation, ITypeSymbol disposableType, ITypeSymbol type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceUsingStatement.AbstractIntroduceUsingStatementCodeRefactoringProvider`3/<IntroduceUsingStatementAsync>d__12")]
private Task`1<Document> IntroduceUsingStatementAsync(Document document, TLocalDeclarationSyntax declarationStatement, string variableName, CancellationToken cancellationToken);
    private bool ShouldReplaceTryStatementWithUsing(ISyntaxFactsService syntaxFacts, TLocalDeclarationSyntax declarationStatement, string variableName, TTryStatementSyntax tryStatement, SyntaxList`1& tryStatements);
    private static SyntaxList`1<TStatementSyntax> GetStatementsToSurround(TLocalDeclarationSyntax declarationStatement, SyntaxList`1<TStatementSyntax> surroundingStatements, SemanticModel semanticModel, ISyntaxFactsService syntaxFactsService, Boolean& consumedLastSurroundingStatement, CancellationToken cancellationToken);
    private static TStatementSyntax FindSiblingStatementContainingLastUsage(TStatementSyntax declarationSyntax, SemanticModel semanticModel, ISyntaxFactsService syntaxFactsService, CancellationToken cancellationToken);
    private static void AddReferencedLocalVariables(HashSet`1<ISymbol> referencedVariables, SyntaxNode node, IReadOnlyList`1<ISymbol> localVariables, SemanticModel semanticModel, ISyntaxFactsService syntaxFactsService, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4 : CodeRefactoringProvider {
    protected abstract virtual bool IsValid(TExpressionStatementSyntax expressionStatement, TextSpan span);
    protected abstract virtual TLocalDeclarationStatementSyntax FixupLocalDeclaration(TExpressionStatementSyntax expressionStatement, TLocalDeclarationStatementSyntax localDeclaration);
    protected abstract virtual TExpressionStatementSyntax FixupDeconstruction(TExpressionStatementSyntax expressionStatement, TExpressionStatementSyntax localDeclaration);
    protected abstract virtual Task`1<TExpressionStatementSyntax> CreateTupleDeconstructionAsync(Document document, CodeActionOptionsProvider optionsProvider, INamedTypeSymbol tupleType, TExpressionSyntax expression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4/<ComputeRefactoringsAsync>d__4")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4/<GetExpressionStatementAsync>d__5")]
protected Task`1<TExpressionStatementSyntax> GetExpressionStatementAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4/<IntroduceLocalAsync>d__6")]
private Task`1<Document> IntroduceLocalAsync(Document document, CodeActionOptionsProvider optionsProvider, TExpressionStatementSyntax expressionStatement, ITypeSymbol type, bool deconstruct, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4/<GenerateUniqueNameAsync>d__7")]
protected static Task`1<SyntaxToken> GenerateUniqueNameAsync(Document document, TExpressionSyntax expression, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6 : object {
    protected abstract virtual bool IsInNonFirstQueryClause(TExpressionSyntax expression);
    protected abstract virtual bool IsInFieldInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInParameterInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInConstructorInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInAttributeArgumentInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInAutoPropertyInitializer(TExpressionSyntax expression);
    protected abstract virtual bool IsInExpressionBodiedMember(TExpressionSyntax expression);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetContainingExecutableBlocks(TExpressionSyntax expression);
    protected abstract virtual IList`1<bool> GetInsertionIndices(TTypeDeclarationSyntax destination, CancellationToken cancellationToken);
    protected abstract virtual bool CanIntroduceVariableFor(TExpressionSyntax expression);
    protected abstract virtual bool CanReplace(TExpressionSyntax expression);
    protected abstract virtual bool IsExpressionInStaticLocalFunction(TExpressionSyntax expression);
    protected abstract virtual Task`1<Document> IntroduceQueryLocalAsync(SemanticDocument document, TExpressionSyntax expression, bool allOccurrences, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> IntroduceLocalAsync(SemanticDocument document, TExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> IntroduceFieldAsync(SemanticDocument document, TExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    protected abstract virtual int DetermineFieldInsertPosition(TTypeDeclarationSyntax oldDeclaration, TTypeDeclarationSyntax newDeclaration);
    protected abstract virtual int DetermineConstantInsertPosition(TTypeDeclarationSyntax oldDeclaration, TTypeDeclarationSyntax newDeclaration);
    protected virtual bool BlockOverlapsHiddenPosition(SyntaxNode block, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6/<IntroduceVariableAsync>d__20")]
public sealed virtual Task`1<CodeAction> IntroduceVariableAsync(Document document, TextSpan textSpan, CodeCleanupOptions options, CancellationToken cancellationToken);
    private ValueTuple`2<string, ImmutableArray`1<CodeAction>> CreateActions(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, CancellationToken cancellationToken);
    private string AddActionsAndGetTitle(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, ArrayBuilder`1<CodeAction> actions, CancellationToken cancellationToken);
    private static string GetConstantOrFieldResource(bool isConstant);
    private static string GetConstantOrLocalResource(bool isConstant);
    private void CreateConstantFieldActions(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, ArrayBuilder`1<CodeAction> actions, CancellationToken cancellationToken);
    protected int GetFieldInsertionIndex(bool isConstant, TTypeDeclarationSyntax oldType, TTypeDeclarationSyntax newType, CancellationToken cancellationToken);
    private bool CanGenerateIntoContainer(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, CancellationToken cancellationToken);
    private CodeAction CreateAction(State<TService, TExpressionSyntax, TTypeSyntax, TTypeDeclarationSyntax, TQueryExpressionSyntax, TNameSyntax> state, bool allOccurrences, bool isConstant, bool isLocal, bool isQueryLocal);
    protected static SyntaxToken GenerateUniqueFieldName(SemanticDocument semanticDocument, TExpressionSyntax expression, bool isConstant, CancellationToken cancellationToken);
    protected static SyntaxToken GenerateUniqueLocalName(SemanticDocument semanticDocument, TExpressionSyntax expression, bool isConstant, SyntaxNode containerOpt, CancellationToken cancellationToken);
    protected ISet`1<TExpressionSyntax> FindMatches(SemanticDocument originalDocument, TExpressionSyntax expressionInOriginal, SemanticDocument currentDocument, SyntaxNode withinNodeInCurrent, bool allOccurrences, CancellationToken cancellationToken);
    private bool NodeMatchesExpression(SemanticModel originalSemanticModel, SemanticModel currentSemanticModel, TExpressionSyntax expressionInOriginal, TExpressionSyntax nodeInCurrent, bool allOccurrences, CancellationToken cancellationToken);
    protected TNode Rewrite(SemanticDocument originalDocument, TExpressionSyntax expressionInOriginal, TExpressionSyntax variableName, SemanticDocument currentDocument, TNode withinNodeInCurrent, bool allOccurrences, CancellationToken cancellationToken);
    protected abstract virtual TNode RewriteCore(TNode node, SyntaxNode replacementNode, ISet`1<TExpressionSyntax> matches);
    protected static ITypeSymbol GetTypeSymbol(SemanticDocument document, TExpressionSyntax expression, CancellationToken cancellationToken, bool objectAsDefault);
    protected static IEnumerable`1<IParameterSymbol> GetAnonymousMethodParameters(SemanticDocument document, TExpressionSyntax expression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.AbstractIntroduceVariableService`6/<ComplexifyParentingStatementsAsync>d__37")]
protected static Task`1<ValueTuple`2<SemanticDocument, ISet`1<TExpressionSyntax>>> ComplexifyParentingStatementsAsync(SemanticDocument semanticDocument, ISet`1<TExpressionSyntax> matches, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <NodeMatchesExpression>g__IsInstanceMemberReference|32_0(IOperation operation);
}
internal interface Microsoft.CodeAnalysis.IntroduceVariable.IIntroduceVariableService {
    public abstract virtual Task`1<CodeAction> IntroduceVariableAsync(Document document, TextSpan textSpan, CodeCleanupOptions options, CancellationToken cancellationToken);
}
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.IntroduceVariable.IntroduceVariableCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.IntroduceVariable.IntroduceVariableCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InvertConditional.AbstractInvertConditionalCodeRefactoringProvider`1 : CodeRefactoringProvider {
    protected abstract virtual bool ShouldOffer(TConditionalExpressionSyntax conditional);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertConditional.AbstractInvertConditionalCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertConditional.AbstractInvertConditionalCodeRefactoringProvider`1/<FindConditionalAsync>d__2")]
private static Task`1<TConditionalExpressionSyntax> FindConditionalAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertConditional.AbstractInvertConditionalCodeRefactoringProvider`1/<InvertConditionalAsync>d__3")]
private static Task`1<Document> InvertConditionalAsync(Document document, TConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InvertIf.AbstractInvertIfCodeRefactoringProvider`4 : CodeRefactoringProvider {
    protected abstract virtual string GetTitle();
    protected abstract virtual SyntaxList`1<TStatementSyntax> GetStatements(SyntaxNode node);
    protected abstract virtual TStatementSyntax GetNextStatement(TStatementSyntax node);
    [NullableContextAttribute("0")]
protected abstract virtual TStatementSyntax GetJumpStatement(TSyntaxKind kind);
    [NullableContextAttribute("0")]
protected abstract virtual Nullable`1<TSyntaxKind> GetJumpStatementKind(SyntaxNode node);
    protected abstract virtual bool IsNoOpSyntaxNode(SyntaxNode node);
    protected abstract virtual bool IsExecutableStatement(SyntaxNode node);
    protected abstract virtual bool IsStatementContainer(SyntaxNode node);
    [NullableContextAttribute("0")]
protected abstract virtual bool IsSingleStatementStatementRange(StatementRange<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement> statementRange);
    protected abstract virtual bool CanControlFlowOut(SyntaxNode node);
    protected abstract virtual bool CanInvert(TIfStatementSyntax ifNode);
    protected abstract virtual bool IsElseless(TIfStatementSyntax ifNode);
    [NullableContextAttribute("0")]
protected abstract virtual StatementRange<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement> GetIfBodyStatementRange(TIfStatementSyntax ifNode);
    protected abstract virtual SyntaxNode GetCondition(TIfStatementSyntax ifNode);
    protected abstract virtual IEnumerable`1<TStatementSyntax> UnwrapBlock(TEmbeddedStatement ifBody);
    protected abstract virtual TEmbeddedStatement GetIfBody(TIfStatementSyntax ifNode);
    protected abstract virtual TEmbeddedStatement GetElseBody(TIfStatementSyntax ifNode);
    protected abstract virtual TEmbeddedStatement GetEmptyEmbeddedStatement();
    protected abstract virtual TEmbeddedStatement AsEmbeddedStatement(IEnumerable`1<TStatementSyntax> statements, TEmbeddedStatement original);
    protected abstract virtual TIfStatementSyntax UpdateIf(SourceText sourceText, TIfStatementSyntax ifNode, SyntaxNode condition, TEmbeddedStatement trueStatement, TEmbeddedStatement falseStatement);
    protected abstract virtual SyntaxNode WithStatements(SyntaxNode node, IEnumerable`1<TStatementSyntax> statements);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertIf.AbstractInvertIfCodeRefactoringProvider`4/<ComputeRefactoringsAsync>d__22")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private InvertIfStyle<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement> GetInvertIfStyle(ISyntaxKinds syntaxKinds, TIfStatementSyntax ifNode, SemanticModel semanticModel, SyntaxNode& subsequentSingleExitPoint);
    [NullableContextAttribute("0")]
private bool SingleSubsequentStatement(ImmutableArray`1<StatementRange<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement>> subsequentStatementRanges);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertIf.AbstractInvertIfCodeRefactoringProvider`4/<InvertIfAsync>d__25")]
private Task`1<Document> InvertIfAsync(Document document, TIfStatementSyntax ifNode, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static void AnalyzeSubsequentControlFlow(SemanticModel semanticModel, ImmutableArray`1<StatementRange<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement>> subsequentStatementRanges, Boolean& subsequentEndPointIsReachable, SyntaxNode& subsequentSingleExitPoint);
    [NullableContextAttribute("0")]
private static void AnalyzeControlFlow(SemanticModel semanticModel, StatementRange<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement> statementRange, Boolean& endPointIsReachable, SyntaxNode& singleExitPoint);
    [NullableContextAttribute("0")]
private static bool SubsequentStatementsAreInTheSameBlock(TIfStatementSyntax ifNode, ImmutableArray`1<StatementRange<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement>> subsequentStatementRanges);
    [NullableContextAttribute("0")]
private TSyntaxKind GetNearestParentJumpStatementKind(SyntaxNode ifNode);
    [NullableContextAttribute("0")]
private bool IsEmptyStatementRange(StatementRange<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement> statementRange);
    [NullableContextAttribute("0")]
private ImmutableArray`1<StatementRange<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement>> GetSubsequentStatementRanges(TIfStatementSyntax ifNode);
    private SyntaxNode GetRootWithInvertIfStatement(SourceText text, SyntaxNode root, TIfStatementSyntax ifNode, InvertIfStyle<TSyntaxKind, TStatementSyntax, TIfStatementSyntax, TEmbeddedStatement> invertIfStyle, SyntaxNode subsequentSingleExitPoint, SyntaxNode negatedExpression, ISyntaxFacts syntaxFacts);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<SyntaxTrivia> <GetRootWithInvertIfStatement>g__GetTriviaAfterSpace|32_0(IEnumerable`1<SyntaxTrivia> syntaxTrivias, <>c__DisplayClass32_0& );
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<SyntaxTrivia> <GetRootWithInvertIfStatement>g__GetTriviaUntilSpace|32_1(IEnumerable`1<SyntaxTrivia> syntaxTrivias, <>c__DisplayClass32_0& );
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<SyntaxTrivia> <GetRootWithInvertIfStatement>g__GetTrailingSpace|32_2(IEnumerable`1<SyntaxTrivia> syntaxTrivias, <>c__DisplayClass32_0& );
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<SyntaxTrivia> <GetRootWithInvertIfStatement>g__GetLeadingSpace|32_3(IEnumerable`1<SyntaxTrivia> syntaxTrivias, <>c__DisplayClass32_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3 : CodeRefactoringProvider {
    private static SyntaxAnnotation s_annotation;
    private static AbstractInvertLogicalCodeRefactoringProvider`3();
    [NullableContextAttribute("0")]
protected abstract virtual string GetOperatorText(TSyntaxKind binaryExprKind);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3/<InvertLogicalAsync>d__3")]
private static Task`1<Document> InvertLogicalAsync(Document document1, SyntaxNode binaryExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3/<InvertInnerExpressionAsync>d__4")]
private static Task`1<Document> InvertInnerExpressionAsync(Document document, SyntaxNode binaryExpression, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.InvertLogical.AbstractInvertLogicalCodeRefactoringProvider`3/<InvertOuterExpressionAsync>d__5")]
private static Task`1<Document> InvertOuterExpressionAsync(Document document, CancellationToken cancellationToken);
    private string GetTitle(ISyntaxKindsService syntaxKinds, int binaryExprKind);
    private static int InvertedKind(ISyntaxKindsService syntaxKinds, int binaryExprKind);
}
internal interface Microsoft.CodeAnalysis.LanguageServer.ILspBuildOnlyDiagnostics {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageServer.ILspBuildOnlyDiagnosticsMetadata {
    public string LanguageName { get; }
    public String[] BuildOnlyDiagnostics { get; }
    public abstract virtual string get_LanguageName();
    public abstract virtual String[] get_BuildOnlyDiagnostics();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.LanguageServer.LspBuildOnlyDiagnosticsAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <LanguageName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BuildOnlyDiagnostics>k__BackingField;
    public string LanguageName { get; }
    public String[] BuildOnlyDiagnostics { get; }
    public LspBuildOnlyDiagnosticsAttribute(string languageName, String[] buildOnlyDiagnostics);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LanguageName();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_BuildOnlyDiagnostics();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.LanguageServerIndexFormat.SymbolMoniker : object {
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Scheme { get; }
    public string Identifier { get; }
    public SymbolMoniker(string scheme, string identifier);
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    public static bool HasMoniker(ISymbol symbol);
    public static SymbolMoniker Create(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static string <Create>g__GetRequiredDocumentationCommentId|8_0(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.LanguageServerIndexFormat.WellKnownSymbolMonikerSchemes : object {
    public static string DotnetNamespace;
    public static string DotnetXmlDoc;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractStructuralTypeDisplayService : object {
    protected static SymbolDisplayFormat s_minimalWithoutExpandedTuples;
    private static SymbolDisplayFormat s_delegateDisplay;
    protected ISyntaxFacts SyntaxFactsService { get; }
    private static AbstractStructuralTypeDisplayService();
    protected abstract virtual ISyntaxFacts get_SyntaxFactsService();
    protected abstract virtual ImmutableArray`1<SymbolDisplayPart> GetNormalAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> GetAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
    private ImmutableArray`1<SymbolDisplayPart> GetDelegateAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SymbolDisplayPart> MassageDelegateParts(IMethodSymbol invokeMethod, ImmutableArray`1<SymbolDisplayPart> parts);
    public sealed virtual StructuralTypeDisplayInfo GetTypeDisplayInfo(ISymbol orderSymbol, ImmutableArray`1<INamedTypeSymbol> directStructuralTypeReferences, SemanticModel semanticModel, int position);
    private static Dictionary`2<INamedTypeSymbol, string> GenerateStructuralTypeNames(IList`1<INamedTypeSymbol> anonymousTypes);
    private static string GenerateStructuralTypeName(int current);
    private static ImmutableArray`1<INamedTypeSymbol> OrderStructuralTypes(ImmutableArray`1<INamedTypeSymbol> structuralTypes, ISymbol symbol);
    private static ImmutableArray`1<INamedTypeSymbol> GetTransitiveStructuralTypeReferences(ImmutableArray`1<INamedTypeSymbol> structuralTypes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.LanguageService.AbstractStructuralTypeDisplayService/<LineBreak>d__13")]
protected static IEnumerable`1<SymbolDisplayPart> LineBreak(int count);
    protected static SymbolDisplayPart PlainText(string text);
    private static SymbolDisplayPart Part(SymbolDisplayPartKind kind, string text);
    private static SymbolDisplayPart Part(SymbolDisplayPartKind kind, ISymbol symbol, string text);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.LanguageService.AbstractStructuralTypeDisplayService/<Space>d__17")]
protected static IEnumerable`1<SymbolDisplayPart> Space(int count);
    protected static SymbolDisplayPart Punctuation(string text);
    protected static SymbolDisplayPart Keyword(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractSymbolDisplayService : object {
    protected LanguageServices LanguageServices;
    protected AbstractSymbolDisplayService(LanguageServices services);
    protected abstract virtual AbstractSymbolDescriptionBuilder CreateDescriptionBuilder(SemanticModel semanticModel, int position, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> ToDescriptionStringAsync(SemanticModel semanticModel, int position, ISymbol symbol, SymbolDescriptionOptions options, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LanguageService.AbstractSymbolDisplayService/<ToDescriptionStringAsync>d__5")]
public sealed virtual Task`1<string> ToDescriptionStringAsync(SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionOptions options, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LanguageService.AbstractSymbolDisplayService/<ToDescriptionPartsAsync>d__6")]
public sealed virtual Task`1<ImmutableArray`1<SymbolDisplayPart>> ToDescriptionPartsAsync(SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionOptions options, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LanguageService.AbstractSymbolDisplayService/<ToDescriptionGroupsAsync>d__7")]
public sealed virtual Task`1<IDictionary`2<SymbolDescriptionGroups, ImmutableArray`1<TaggedText>>> ToDescriptionGroupsAsync(SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IStructuralTypeDisplayService {
    public abstract virtual StructuralTypeDisplayInfo GetTypeDisplayInfo(ISymbol orderSymbol, ImmutableArray`1<INamedTypeSymbol> structuralTypes, SemanticModel semanticModel, int position);
    public abstract virtual ImmutableArray`1<SymbolDisplayPart> GetAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISymbolDisplayService {
    public abstract virtual Task`1<string> ToDescriptionStringAsync(SemanticModel semanticModel, int position, ISymbol symbol, SymbolDescriptionOptions options, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> ToDescriptionStringAsync(SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionOptions options, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<SymbolDisplayPart>> ToDescriptionPartsAsync(SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionOptions options, SymbolDescriptionGroups groups, CancellationToken cancellationToken);
    public abstract virtual Task`1<IDictionary`2<SymbolDescriptionGroups, ImmutableArray`1<TaggedText>>> ToDescriptionGroupsAsync(SemanticModel semanticModel, int position, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.LanguageService.StructuralTypeDisplayInfo : ValueType {
    [CompilerGeneratedAttribute]
private IDictionary`2<INamedTypeSymbol, string> <StructuralTypeToName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <TypesParts>k__BackingField;
    public IDictionary`2<INamedTypeSymbol, string> StructuralTypeToName { get; }
    public IList`1<SymbolDisplayPart> TypesParts { get; }
    public StructuralTypeDisplayInfo(IDictionary`2<INamedTypeSymbol, string> structuralTypeToName, IList`1<SymbolDisplayPart> typesParts);
    [CompilerGeneratedAttribute]
public IDictionary`2<INamedTypeSymbol, string> get_StructuralTypeToName();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_TypesParts();
    public IList`1<SymbolDisplayPart> ReplaceStructuralTypes(IList`1<SymbolDisplayPart> parts, SemanticModel semanticModel, int position);
    public static IList`1<SymbolDisplayPart> ReplaceStructuralTypes(IList`1<SymbolDisplayPart> parts, IDictionary`2<INamedTypeSymbol, string> structuralTypeToName, SemanticModel semanticModel, int position);
    public static bool ReplaceStructuralTypes(IList`1<SymbolDisplayPart> parts, IDictionary`2<INamedTypeSymbol, string> structuralTypeToName, SemanticModel semanticModel, int position, List`1& newParts);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.LanguageService.SymbolDescriptionGroups : Enum {
    public int value__;
    public static SymbolDescriptionGroups None;
    public static SymbolDescriptionGroups MainDescription;
    public static SymbolDescriptionGroups AwaitableUsageText;
    public static SymbolDescriptionGroups Documentation;
    public static SymbolDescriptionGroups TypeParameterMap;
    public static SymbolDescriptionGroups StructuralTypes;
    public static SymbolDescriptionGroups Exceptions;
    public static SymbolDescriptionGroups Captures;
    public static SymbolDescriptionGroups ReturnsDocumentation;
    public static SymbolDescriptionGroups ValueDocumentation;
    public static SymbolDescriptionGroups RemarksDocumentation;
    public static SymbolDescriptionGroups All;
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.LanguageService.SymbolDescriptionOptions : ValueType {
    [CompilerGeneratedAttribute]
private QuickInfoOptions <QuickInfoOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ClassificationOptions <ClassificationOptions>k__BackingField;
    public static SymbolDescriptionOptions Default;
    [DataMemberAttribute]
public QuickInfoOptions QuickInfoOptions { get; public set; }
    [DataMemberAttribute]
public ClassificationOptions ClassificationOptions { get; public set; }
    private static SymbolDescriptionOptions();
    [CompilerGeneratedAttribute]
public QuickInfoOptions get_QuickInfoOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QuickInfoOptions(QuickInfoOptions value);
    [CompilerGeneratedAttribute]
public ClassificationOptions get_ClassificationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClassificationOptions(ClassificationOptions value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SymbolDescriptionOptions left, SymbolDescriptionOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SymbolDescriptionOptions left, SymbolDescriptionOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SymbolDescriptionOptions other);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.LegacySolutionEvents.ILegacySolutionEventsAggregationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.LegacySolutionEvents.DefaultLegacySolutionEventsAggregationService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Lazy`1<ILegacySolutionEventsListener>> _eventsServices;
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DefaultLegacySolutionEventsAggregationService(IEnumerable`1<Lazy`1<ILegacySolutionEventsListener>> eventsServices);
    [NullableContextAttribute("1")]
public sealed virtual bool ShouldReportChanges(SolutionServices services);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LegacySolutionEvents.DefaultLegacySolutionEventsAggregationService/<OnWorkspaceChangedAsync>d__3")]
public sealed virtual ValueTask OnWorkspaceChangedAsync(WorkspaceChangeEventArgs args, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LegacySolutionEvents.ILegacySolutionEventsAggregationService {
    public abstract virtual bool ShouldReportChanges(SolutionServices services);
    public abstract virtual ValueTask OnWorkspaceChangedAsync(WorkspaceChangeEventArgs args, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LegacySolutionEvents.ILegacySolutionEventsListener {
    public abstract virtual bool ShouldReportChanges(SolutionServices services);
    public abstract virtual ValueTask OnWorkspaceChangedAsync(WorkspaceChangeEventArgs args, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.LegacySolutionEvents.IRemoteLegacySolutionEventsAggregationService {
    public abstract virtual ValueTask`1<bool> ShouldReportChangesAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual ValueTask OnWorkspaceChangedAsync(Checksum oldSolutionChecksum, Checksum newSolutionChecksum, WorkspaceChangeKind kind, ProjectId projectId, DocumentId documentId, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.LineSeparators.ILineSeparatorService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<TextSpan>> GetLineSeparatorsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual SyntaxNode GetInitializerNode(TSymbolSyntax declaration);
    protected abstract virtual ImmutableList`1<TSymbolSyntax> GetVariableDeclarators(TFieldDeclarationSyntax declaration);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyCodeFixProvider`2/<MakeFieldReadonlyAsync>d__6")]
private Task MakeFieldReadonlyAsync(Document document, SyntaxEditor editor, List`1<TSymbolSyntax> declarators, CancellationToken cancellationToken);
    private static DeclarationModifiers WithReadOnly(DeclarationModifiers modifiers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeFieldReadonly.AbstractMakeFieldReadonlyDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ISyntaxKinds SyntaxKinds { get; }
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    protected abstract virtual ISyntaxKinds get_SyntaxKinds();
    protected abstract virtual bool IsWrittenTo(SemanticModel semanticModel, TThisExpression expression, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    protected virtual void InitializeWorker(AnalysisContext context);
    private static Location GetDiagnosticLocation(IFieldSymbol field);
    private static bool IsFieldWrite(IFieldReferenceOperation fieldReference, ISymbol owningSymbol);
    private static CodeStyleOption2`1<bool> GetCodeStyleOption(IFieldSymbol field, AnalyzerOptions options, Location& diagnosticLocation);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(CompilationStartAnalysisContext context);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <InitializeWorker>g__IsCandidateField|7_6(IFieldSymbol symbol, INamedTypeSymbol threadStaticAttribute, INamedTypeSymbol dataContractAttribute, INamedTypeSymbol dataMemberAttribute);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <InitializeWorker>g__IsDataContractSerializable|7_7(IFieldSymbol symbol, INamedTypeSymbol dataContractAttribute, INamedTypeSymbol dataMemberAttribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeMemberStatic.AbstractMakeMemberStaticCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    protected abstract virtual bool TryGetMemberDeclaration(SyntaxNode node, SyntaxNode& memberDeclaration);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider : CodeFixProvider {
    private static string AsyncSuffix;
    protected abstract virtual bool IsSupportedDiagnostic(Diagnostic diagnostic, CancellationToken cancellationToken);
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual string GetMakeAsyncTaskFunctionResource();
    protected abstract virtual string GetMakeAsyncVoidFunctionResource();
    protected abstract virtual bool IsAsyncReturnType(ITypeSymbol type, KnownTaskTypes knownTypes);
    protected abstract virtual SyntaxNode AddAsyncTokenAndFixReturnType(bool keepVoid, IMethodSymbol methodSymbol, SyntaxNode node, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static IMethodSymbol GetMethodSymbol(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsLikelyEntryPointName(string name, Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<FixNodeAsync>d__11")]
private Task`1<Solution> FixNodeAsync(Document document, Diagnostic diagnostic, bool keepVoid, bool isEntryPoint, CancellationToken cancellationToken);
    private SyntaxNode GetContainingFunction(Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<RenameThenAddAsyncTokenAsync>d__13")]
private Task`1<Solution> RenameThenAddAsyncTokenAsync(bool keepVoid, Document document, SyntaxNode node, IMethodSymbol methodSymbol, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodAsynchronous.AbstractMakeMethodAsynchronousCodeFixProvider/<AddAsyncTokenAsync>d__14")]
private Task`1<Solution> AddAsyncTokenAsync(bool keepVoid, Document document, IMethodSymbol methodSymbol, KnownTaskTypes knownTypes, SyntaxNode node, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <FixNodeAsync>g__NeedsRename|11_0(<>c__DisplayClass11_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider : CodeFixProvider {
    private static string AsyncSuffix;
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual SyntaxNode RemoveAsyncTokenAndFixReturnType(IMethodSymbol methodSymbol, SyntaxNode node, KnownTaskTypes knownTypes);
    public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<FixNodeAsync>d__5")]
private Task`1<Solution> FixNodeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RenameThenRemoveAsyncTokenAsync>d__6")]
private Task`1<Solution> RenameThenRemoveAsyncTokenAsync(Document document, SyntaxNode node, IMethodSymbol methodSymbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAsyncTokenAsync>d__7")]
private Task`1<Solution> RemoveAsyncTokenAsync(Document document, IMethodSymbol methodSymbol, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__8")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__9")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Solution solution, ImmutableArray`1<ReferenceLocation> locations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeMethodSynchronous.AbstractMakeMethodSynchronousCodeFixProvider/<RemoveAwaitFromCallersAsync>d__10")]
private static Task`1<Solution> RemoveAwaitFromCallersAsync(Solution currentSolution, IGrouping`2<Document, ReferenceLocation> group, CancellationToken cancellationToken);
    private static void RemoveAwaitFromCallerIfPresent(SyntaxEditor editor, ISyntaxFactsService syntaxFacts, ReferenceLocation referenceLocation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeTypeAbstract.AbstractMakeTypeAbstractCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableContextAttribute("2")]
protected abstract virtual bool IsValidRefactoringContext(SyntaxNode node, TTypeDeclarationSyntax& typeDeclaration);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MakeTypePartial.AbstractMakeTypePartialCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MakeTypePartial.AbstractMakeTypePartialCodeFixProvider/<FixAllAsync>d__2")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.MapCode.IMapCodeService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Nullable`1<ImmutableArray`1<TextChange>>> MapCodeAsync(Document document, ImmutableArray`1<string> contents, ImmutableArray`1<ValueTuple`2<Document, TextSpan>> prioritizedFocusLocations, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.AbstractMetadataAsSourceService/<AddSourceToAsync>d__4")]
public sealed virtual Task`1<Document> AddSourceToAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CleanCodeGenerationOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected abstract virtual Task`1<Document> AddNullableRegionsAsync(Document document, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected abstract virtual ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(Document document);
    [NullableContextAttribute("1")]
protected abstract virtual Task`1<Document> AddAssemblyInfoRegionAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected abstract virtual Task`1<Document> ConvertDocCommentsToRegularCommentsAsync(Document document, IDocumentationCommentFormattingService docCommentFormattingService, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<AbstractReducer> GetReducers();
    [NullableContextAttribute("1")]
private static INamespaceOrTypeSymbol CreateCodeGenerationSymbol(Document document, ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportMetadataAsSourceFileProviderAttribute("Decompilation")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider : object {
    internal static string ProviderName;
    private Dictionary`2<UniqueDocumentKey, MetadataAsSourceGeneratedFileInfo> _keyToInformation;
    private ConcurrentDictionary`2<string, MetadataAsSourceGeneratedFileInfo> _generatedFilenameToInformation;
    private IImplementationAssemblyLookupService _implementationAssemblyLookupService;
    private IBidirectionalMap`2<MetadataAsSourceGeneratedFileInfo, DocumentId> _openedDocumentIds;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DecompilationMetadataAsSourceFileProvider(IImplementationAssemblyLookupService implementationAssemblyLookupService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider/<GetGeneratedFileAsync>d__6")]
public sealed virtual Task`1<MetadataAsSourceFile> GetGeneratedFileAsync(MetadataAsSourceWorkspace metadataWorkspace, Workspace sourceWorkspace, Project sourceProject, ISymbol symbol, bool signaturesOnly, MetadataAsSourceOptions options, string tempPath, TelemetryMessage telemetryMessage, CancellationToken cancellationToken);
    private ValueTuple`3<MetadataReference, string, bool> GetReferenceInfo(Compilation compilation, IAssemblySymbol containingAssembly);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider/<RelocateSymbol_NoLockAsync>d__8")]
private Task`1<Location> RelocateSymbol_NoLockAsync(Solution solution, MetadataAsSourceGeneratedFileInfo fileInfo, SymbolKey symbolId, CancellationToken cancellationToken);
    private static void AssertIsMainThread(MetadataAsSourceWorkspace workspace);
    public sealed virtual bool ShouldCollapseOnOpen(MetadataAsSourceWorkspace workspace, string filePath, BlockStructureOptions blockStructureOptions);
    public sealed virtual bool TryAddDocumentToWorkspace(MetadataAsSourceWorkspace workspace, string filePath, SourceTextContainer sourceTextContainer);
    public sealed virtual bool TryRemoveDocumentFromWorkspace(MetadataAsSourceWorkspace workspace, string filePath);
    private bool RemoveDocumentFromWorkspace(MetadataAsSourceWorkspace workspace, MetadataAsSourceGeneratedFileInfo fileInfo);
    public sealed virtual Project MapDocument(Document document);
    public sealed virtual void CleanupGeneratedFiles(MetadataAsSourceWorkspace workspace);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.DecompilationMetadataAsSourceFileProvider/<GetUniqueDocumentKeyAsync>d__16")]
private static Task`1<UniqueDocumentKey> GetUniqueDocumentKeyAsync(Project project, INamedTypeSymbol topLevelNamedType, bool signaturesOnly, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.MetadataAsSource.DocumentationCommentUtilities : object {
    private static ObjectPool`1<List`1<string>> s_pool;
    private static DocumentationCommentUtilities();
    public static string ExtractXMLFragment(string input, string docCommentPrefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.MetadataAsSource.ExportMetadataAsSourceFileProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public ExportMetadataAsSourceFileProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileProvider {
    public abstract virtual Task`1<MetadataAsSourceFile> GetGeneratedFileAsync(MetadataAsSourceWorkspace metadataWorkspace, Workspace sourceWorkspace, Project sourceProject, ISymbol symbol, bool signaturesOnly, MetadataAsSourceOptions options, string tempPath, TelemetryMessage telemetryMessage, CancellationToken cancellationToken);
    public abstract virtual void CleanupGeneratedFiles(MetadataAsSourceWorkspace workspace);
    public abstract virtual bool TryAddDocumentToWorkspace(MetadataAsSourceWorkspace workspace, string filePath, SourceTextContainer sourceTextContainer);
    public abstract virtual bool TryRemoveDocumentFromWorkspace(MetadataAsSourceWorkspace workspace, string filePath);
    public abstract virtual bool ShouldCollapseOnOpen(MetadataAsSourceWorkspace workspace, string filePath, BlockStructureOptions blockStructureOptions);
    public abstract virtual Project MapDocument(Document document);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService {
    public abstract virtual Task`1<MetadataAsSourceFile> GetGeneratedFileAsync(Workspace sourceWorkspace, Project sourceProject, ISymbol symbol, bool signaturesOnly, MetadataAsSourceOptions options, CancellationToken cancellationToken);
    public abstract virtual bool TryAddDocumentToWorkspace(string filePath, SourceTextContainer buffer);
    public abstract virtual bool TryRemoveDocumentFromWorkspace(string filePath);
    public abstract virtual bool IsNavigableMetadataSymbol(ISymbol symbol);
    [NullableContextAttribute("2")]
public abstract virtual Workspace TryGetWorkspace();
}
internal interface Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Document> AddSourceToAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CleanCodeGenerationOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFile : object {
    private string _filePath;
    private Location _identifierLocation;
    private string _documentTitle;
    private string _documentTooltip;
    public string FilePath { get; }
    public Location IdentifierLocation { get; }
    public string DocumentTitle { get; }
    public string DocumentTooltip { get; }
    internal MetadataAsSourceFile(string filePath, Location identifierLocation, string documentTitle, string documentTooltip);
    public string get_FilePath();
    public Location get_IdentifierLocation();
    public string get_DocumentTitle();
    public string get_DocumentTooltip();
}
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileProviderMetadata : OrderableLanguageMetadata {
    [NullableContextAttribute("1")]
public MetadataAsSourceFileProviderMetadata(IDictionary`2<string, object> data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceFileService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService : object {
    private static string MetadataAsSource;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableArray`1<Lazy`2<IMetadataAsSourceFileProvider, MetadataAsSourceFileProviderMetadata>>> _providers;
    [NullableAttribute("2")]
private MetadataAsSourceWorkspace _workspace;
    private SemaphoreSlim _gate;
    private Mutex _mutex;
    private string _rootTemporaryPathWithGuid;
    private string _rootTemporaryPath;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public MetadataAsSourceFileService(IEnumerable`1<Lazy`2<IMetadataAsSourceFileProvider, MetadataAsSourceFileProviderMetadata>> providers);
    private static string CreateMutexName(string directoryName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService/<GetGeneratedFileAsync>d__9")]
public sealed virtual Task`1<MetadataAsSourceFile> GetGeneratedFileAsync(Workspace sourceWorkspace, Project sourceProject, ISymbol symbol, bool signaturesOnly, MetadataAsSourceOptions options, CancellationToken cancellationToken);
    private static void AssertIsMainThread(MetadataAsSourceWorkspace workspace);
    public sealed virtual bool TryAddDocumentToWorkspace(string filePath, SourceTextContainer sourceTextContainer);
    public sealed virtual bool TryRemoveDocumentFromWorkspace(string filePath);
    public bool ShouldCollapseOnOpen(string filePath, BlockStructureOptions blockStructureOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceFileService/<MapSymbolAsync>d__14")]
internal Task`1<SymbolMappingResult> MapSymbolAsync(Document document, SymbolKey symbolId, CancellationToken cancellationToken);
    public sealed virtual bool IsNavigableMetadataSymbol(ISymbol symbol);
    [NullableContextAttribute("2")]
public sealed virtual Workspace TryGetWorkspace();
    [CompilerGeneratedAttribute]
internal static void <GetGeneratedFileAsync>g__CleanupGeneratedFiles|9_0(string rootDirectory);
    [CompilerGeneratedAttribute]
internal static void <GetGeneratedFileAsync>g__TryDeleteFolderWhichContainsReadOnlyFiles|9_1(string directoryPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceGeneratedFileInfo : object {
    public ProjectId SourceProjectId;
    public Workspace Workspace;
    public AssemblyIdentity AssemblyIdentity;
    public string LanguageName;
    public bool SignaturesOnly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<MetadataReference> References;
    public string TemporaryFilePath;
    [NullableAttribute("2")]
private ParseOptions _parseOptions;
    public static Encoding Encoding { get; }
    public static SourceHashAlgorithm ChecksumAlgorithm { get; }
    public MetadataAsSourceGeneratedFileInfo(string rootPath, Workspace sourceWorkspace, Project sourceProject, INamedTypeSymbol topLevelNamedType, bool signaturesOnly);
    public static Encoding get_Encoding();
    public static SourceHashAlgorithm get_ChecksumAlgorithm();
    public ValueTuple`2<ProjectInfo, DocumentId> GetProjectInfoAndDocumentId(SolutionServices services, bool loadFileFromDisk);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceHelpers : object {
    public static string GetAssemblyInfo(IAssemblySymbol assemblySymbol);
    public static string GetAssemblyDisplay(Compilation compilation, IAssemblySymbol assemblySymbol);
    public static INamedTypeSymbol GetTopLevelContainingNamedType(ISymbol symbol);
    public static INamedTypeSymbol TryGetTopLevelContainingNamedType(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceHelpers/<GetLocationInGeneratedSourceAsync>d__4")]
public static Task`1<Location> GetLocationInGeneratedSourceAsync(SymbolKey symbolId, Document generatedDocument, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static Location GetFirstSourceLocation(SymbolKeyResolution resolution);
    public static bool IsReferenceAssembly(IAssemblySymbol assemblySymbol);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceOptions : ValueType {
    [CompilerGeneratedAttribute]
private CleanCodeGenerationOptions <GenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NavigateToDecompiledSources>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysUseDefaultSymbolServers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NavigateToSourceLinkAndEmbeddedSources>k__BackingField;
    [DataMemberAttribute]
public CleanCodeGenerationOptions GenerationOptions { get; public set; }
    [DataMemberAttribute]
public bool NavigateToDecompiledSources { get; public set; }
    [DataMemberAttribute]
public bool AlwaysUseDefaultSymbolServers { get; public set; }
    [DataMemberAttribute]
public bool NavigateToSourceLinkAndEmbeddedSources { get; public set; }
    public MetadataAsSourceOptions(CleanCodeGenerationOptions GenerationOptions);
    [CompilerGeneratedAttribute]
public CleanCodeGenerationOptions get_GenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GenerationOptions(CleanCodeGenerationOptions value);
    [CompilerGeneratedAttribute]
public bool get_NavigateToDecompiledSources();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NavigateToDecompiledSources(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysUseDefaultSymbolServers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AlwaysUseDefaultSymbolServers(bool value);
    [CompilerGeneratedAttribute]
public bool get_NavigateToSourceLinkAndEmbeddedSources();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NavigateToSourceLinkAndEmbeddedSources(bool value);
    [NullableContextAttribute("1")]
public static MetadataAsSourceOptions GetDefault(LanguageServices languageServices);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MetadataAsSourceOptions left, MetadataAsSourceOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MetadataAsSourceOptions left, MetadataAsSourceOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MetadataAsSourceOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(CleanCodeGenerationOptions& GenerationOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MetadataAsSource.MetadataAsSourceWorkspace : Workspace {
    public MetadataAsSourceFileService FileService;
    public MetadataAsSourceWorkspace(MetadataAsSourceFileService fileService, HostServices hostServices);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.MetadataAsSource.SymbolMappingServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MetadataAsSource.TelemetryMessage : object {
    [NullableAttribute("2")]
private string _pdbSource;
    [NullableAttribute("2")]
private string _sourceFileSource;
    [NullableAttribute("2")]
private string _referenceAssembly;
    [NullableAttribute("2")]
private string _dll;
    private Nullable`1<bool> _decompiled;
    private IDisposable _logBlock;
    public TelemetryMessage(CancellationToken cancellationToken);
    public void SetPdbSource(string source);
    public void SetSourceFileSource(string source);
    public void SetReferenceAssembly(string referenceAssembly);
    public void SetDll(string dll);
    public void SetDecompiled(bool decompiled);
    private void SetLogProperties(Dictionary`2<string, object> properties);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1 : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1/<MoveDeclarationNearReferenceAsync>d__2")]
private static Task`1<Document> MoveDeclarationNearReferenceAsync(Document document, SyntaxNode statement, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.MoveStaticMembers.AbstractMoveStaticMembersRefactoringProvider : CodeRefactoringProvider {
    protected abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedNodesAsync(CodeRefactoringContext context);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveStaticMembers.AbstractMoveStaticMembersRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal interface Microsoft.CodeAnalysis.MoveStaticMembers.IMoveStaticMembersOptionsService {
    [NullableContextAttribute("1")]
public abstract virtual MoveStaticMembersOptions GetMoveMembersToTypeOptions(Document document, INamedTypeSymbol selectedType, ImmutableArray`1<ISymbol> selectedNodeSymbols);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNewType>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceDisplay>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ISymbol> <SelectedMembers>k__BackingField;
    public static MoveStaticMembersOptions Cancelled;
    public bool IsCancelled { get; }
    [NullableAttribute("1")]
public string FileName { get; }
    public bool IsNewType { get; }
    public INamedTypeSymbol Destination { get; }
    public string TypeName { get; }
    public string NamespaceDisplay { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISymbol> SelectedMembers { get; }
    [NullableContextAttribute("1")]
public MoveStaticMembersOptions(INamedTypeSymbol destination, ImmutableArray`1<ISymbol> selectedMembers, bool isCancelled);
    [NullableContextAttribute("1")]
public MoveStaticMembersOptions(string fileName, string fullTypeName, ImmutableArray`1<ISymbol> selectedMembers, bool isCancelled);
    private static MoveStaticMembersOptions();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public bool get_IsNewType();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_Destination();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_NamespaceDisplay();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ISymbol> get_SelectedMembers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersWithDialogCodeAction : CodeActionWithOptions {
    private Document _document;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISymbol> _selectedMembers;
    private INamedTypeSymbol _selectedType;
    private IMoveStaticMembersOptionsService _service;
    private CleanCodeGenerationOptionsProvider _fallbackOptions;
    public string Title { get; }
    public MoveStaticMembersWithDialogCodeAction(Document document, IMoveStaticMembersOptionsService service, INamedTypeSymbol selectedType, CleanCodeGenerationOptionsProvider fallbackOptions, ImmutableArray`1<ISymbol> selectedMembers);
    public virtual string get_Title();
    [NullableContextAttribute("2")]
public virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersWithDialogCodeAction/<ComputeOperationsAsync>d__9")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    private static TypeKind GetNewTypeKind(INamedTypeSymbol oldType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersWithDialogCodeAction/<RefactorAndMoveAsync>d__11")]
private Task`1<Solution> RefactorAndMoveAsync(ImmutableArray`1<ISymbol> selectedMembers, ImmutableArray`1<SyntaxNode> oldMemberNodes, Solution oldSolution, INamedTypeSymbol newType, ImmutableArray`1<int> typeArgIndices, DocumentId sourceDocId, DocumentId newTypeDocId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersWithDialogCodeAction/<RefactorReferencesAsync>d__12")]
private static Task`1<Solution> RefactorReferencesAsync(ILookup`2<ProjectId, ValueTuple`2<ReferenceLocation, bool>> projectToLocations, Solution solution, INamedTypeSymbol newType, ImmutableArray`1<int> typeArgIndices, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersWithDialogCodeAction/<FixReferencesSingleDocumentAsync>d__13")]
private static Task`1<SyntaxNode> FixReferencesSingleDocumentAsync(ImmutableArray`1<ValueTuple`2<ReferenceLocation, bool>> referenceLocations, Document doc, INamedTypeSymbol newType, ImmutableArray`1<int> typeArgIndices, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveStaticMembers.MoveStaticMembersWithDialogCodeAction/<FindMemberReferencesAsync>d__14")]
private static Task`1<ImmutableArray`1<ValueTuple`2<ReferenceLocation, bool>>> FindMemberReferencesAsync(Solution solution, ProjectId projectId, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceCodeAction : CodeActionWithOptions {
    private IMoveToNamespaceService _moveToNamespaceService;
    private MoveToNamespaceAnalysisResult _moveToNamespaceAnalysisResult;
    private CodeCleanupOptionsProvider _cleanupOptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    protected AbstractMoveToNamespaceCodeAction(IMoveToNamespaceService moveToNamespaceService, MoveToNamespaceAnalysisResult analysisResult, CodeCleanupOptionsProvider cleanupOptions);
    public sealed virtual ImmutableArray`1<string> get_Tags();
    public sealed virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceCodeAction/<ComputeOperationsAsync>d__7")]
protected sealed virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    private static ImmutableArray`1<CodeActionOperation> CreateRenameOperations(MoveToNamespaceResult moveToNamespaceResult);
    public static AbstractMoveToNamespaceCodeAction Generate(IMoveToNamespaceService changeNamespaceService, MoveToNamespaceAnalysisResult analysisResult, CodeCleanupOptionsProvider cleanupOptions);
}
internal abstract class Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3 : object {
    [CompilerGeneratedAttribute]
private IMoveToNamespaceOptionsService <OptionsService>k__BackingField;
    private static SymbolDisplayFormat QualifiedNamespaceFormat;
    public IMoveToNamespaceOptionsService OptionsService { get; }
    protected AbstractMoveToNamespaceService`3(IMoveToNamespaceOptionsService moveToNamespaceOptionsService);
    private static AbstractMoveToNamespaceService`3();
    protected abstract virtual string GetNamespaceName(SyntaxNode namespaceSyntax);
    protected abstract virtual bool IsContainedInNamespaceDeclaration(TNamespaceDeclarationSyntax namespaceSyntax, int position);
    [CompilerGeneratedAttribute]
public sealed virtual IMoveToNamespaceOptionsService get_OptionsService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<GetCodeActionsAsync>d__6")]
public sealed virtual Task`1<ImmutableArray`1<AbstractMoveToNamespaceCodeAction>> GetCodeActionsAsync(Document document, TextSpan span, CodeCleanupOptionsProvider cleanupOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<AnalyzeTypeAtPositionAsync>d__7")]
public sealed virtual Task`1<MoveToNamespaceAnalysisResult> AnalyzeTypeAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<TryAnalyzeNamespaceAsync>d__8")]
private Task`1<MoveToNamespaceAnalysisResult> TryAnalyzeNamespaceAsync(Document document, SyntaxNode node, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<TryAnalyzeNamedTypeAsync>d__9")]
private Task`1<MoveToNamespaceAnalysisResult> TryAnalyzeNamedTypeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    private static TNamespaceDeclarationSyntax GetContainingNamespace(TNamedTypeDeclarationSyntax namedTypeSyntax);
    private static int GetNamespaceInSpineCount(SyntaxNode node);
    private static bool ContainsMultipleTypesInSpine(SyntaxNode node);
    public sealed virtual Task`1<MoveToNamespaceResult> MoveToNamespaceAsync(MoveToNamespaceAnalysisResult analysisResult, string targetNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<GetMemberSymbolsAsync>d__14")]
private static Task`1<ImmutableArray`1<ISymbol>> GetMemberSymbolsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<MoveItemsInNamespaceAsync>d__15")]
private static Task`1<MoveToNamespaceResult> MoveItemsInNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CodeCleanupOptionsProvider options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<MoveTypeToNamespaceAsync>d__16")]
private static Task`1<MoveToNamespaceResult> MoveTypeToNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<PropagateChangeToLinkedDocumentsAsync>d__17")]
private static Task`1<Solution> PropagateChangeToLinkedDocumentsAsync(Document document, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private static string GetNewSymbolName(ISymbol symbol, string targetNamespace);
    protected static string GetQualifiedName(INamespaceSymbol namespaceSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.AbstractMoveToNamespaceService`3/<GetNamespacesAsync>d__21")]
private static Task`1<IEnumerable`1<string>> GetNamespacesAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual MoveToNamespaceOptionsResult GetChangeNamespaceOptions(Document document, string defaultNamespace, ImmutableArray`1<string> namespaces);
}
internal interface Microsoft.CodeAnalysis.MoveToNamespace.IMoveToNamespaceOptionsService {
    public abstract virtual MoveToNamespaceOptionsResult GetChangeNamespaceOptions(string defaultNamespace, ImmutableArray`1<string> availableNamespaces, ISyntaxFacts syntaxFactsService);
}
internal interface Microsoft.CodeAnalysis.MoveToNamespace.IMoveToNamespaceService {
    public IMoveToNamespaceOptionsService OptionsService { get; }
    public abstract virtual Task`1<ImmutableArray`1<AbstractMoveToNamespaceCodeAction>> GetCodeActionsAsync(Document document, TextSpan span, CodeCleanupOptionsProvider options, CancellationToken cancellationToken);
    public abstract virtual Task`1<MoveToNamespaceAnalysisResult> AnalyzeTypeAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<MoveToNamespaceResult> MoveToNamespaceAsync(MoveToNamespaceAnalysisResult analysisResult, string targetNamespace, CodeCleanupOptionsProvider options, CancellationToken cancellationToken);
    public abstract virtual MoveToNamespaceOptionsResult GetChangeNamespaceOptions(Document document, string defaultNamespace, ImmutableArray`1<string> namespaces);
    public abstract virtual IMoveToNamespaceOptionsService get_OptionsService();
}
internal class Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceAnalysisResult : object {
    public static MoveToNamespaceAnalysisResult Invalid;
    [CompilerGeneratedAttribute]
private bool <CanPerform>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <SyntaxNode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerType <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Namespaces>k__BackingField;
    public bool CanPerform { get; }
    public Document Document { get; }
    public SyntaxNode SyntaxNode { get; }
    public string OriginalNamespace { get; }
    public ContainerType Container { get; }
    public ImmutableArray`1<string> Namespaces { get; }
    public MoveToNamespaceAnalysisResult(Document document, SyntaxNode syntaxNode, string originalNamespace, ImmutableArray`1<string> namespaces, ContainerType container);
    private static MoveToNamespaceAnalysisResult();
    [CompilerGeneratedAttribute]
public bool get_CanPerform();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public SyntaxNode get_SyntaxNode();
    [CompilerGeneratedAttribute]
public string get_OriginalNamespace();
    [CompilerGeneratedAttribute]
public ContainerType get_Container();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Namespaces();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceCodeActionProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceCodeActionProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
internal class Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceOptionsResult : object {
    public static MoveToNamespaceOptionsResult Cancelled;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    public bool IsCancelled { get; }
    public string Namespace { get; }
    public MoveToNamespaceOptionsResult(string namespace);
    private static MoveToNamespaceOptionsResult();
    [CompilerGeneratedAttribute]
public bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public string get_Namespace();
}
internal class Microsoft.CodeAnalysis.MoveToNamespace.MoveToNamespaceResult : object {
    public static MoveToNamespaceResult Failed;
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <UpdatedSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <OriginalSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <UpdatedDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ISymbol> <NewNameOriginalSymbolMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewName>k__BackingField;
    public bool Succeeded { get; }
    public Solution UpdatedSolution { get; }
    public Solution OriginalSolution { get; }
    public DocumentId UpdatedDocumentId { get; }
    public ImmutableDictionary`2<string, ISymbol> NewNameOriginalSymbolMapping { get; }
    public string NewName { get; }
    public MoveToNamespaceResult(Solution originalSolution, Solution updatedSolution, DocumentId updatedDocumentId, ImmutableDictionary`2<string, ISymbol> newNameOriginalSymbolMapping);
    private static MoveToNamespaceResult();
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public Solution get_UpdatedSolution();
    [CompilerGeneratedAttribute]
public Solution get_OriginalSolution();
    [CompilerGeneratedAttribute]
public DocumentId get_UpdatedDocumentId();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ISymbol> get_NewNameOriginalSymbolMapping();
    [CompilerGeneratedAttribute]
public string get_NewName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.NameTupleElement.AbstractNameTupleElementCodeRefactoringProvider`2 : CodeRefactoringProvider {
    protected abstract virtual TArgumentSyntax WithName(TArgumentSyntax argument, string argumentName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NameTupleElement.AbstractNameTupleElementCodeRefactoringProvider`2/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NameTupleElement.AbstractNameTupleElementCodeRefactoringProvider`2/<TryGetArgumentInfoAsync>d__2")]
private static Task`1<ValueTuple`3<SyntaxNode, TArgumentSyntax, string>> TryGetArgumentInfoAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NameTupleElement.AbstractNameTupleElementCodeRefactoringProvider`2/<AddNamedElementAsync>d__3")]
private Task`1<Document> AddNamedElementAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`3<IChecksummedPersistentStorageService, DocumentKey, StringTable>, AsyncLazy`1<TopLevelSyntaxTreeIndex>> s_cachedIndexMap;
    [NullableAttribute("2")]
private static StringTable s_stringTable;
    public static IImmutableSet`1<string> AllKinds;
    [CompilerGeneratedAttribute]
private IImmutableSet`1<string> <KindsProvided>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
private static ImmutableArray`1<ValueTuple`2<PatternMatchKind, NavigateToMatchKind>> s_kindPairs;
    public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    private static AbstractNavigateToSearchService();
    private static void ClearCachedData();
    [NullableContextAttribute("2")]
private static bool ShouldSearchCachedDocuments(ConcurrentDictionary`2& cachedIndexMap, StringTable& stringTable);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchCachedDocumentsAsync>d__4")]
public sealed virtual Task SearchCachedDocumentsAsync(Solution solution, ImmutableArray`1<Project> projects, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, Document activeDocument, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchCachedDocumentsInCurrentProcessAsync>d__5")]
public static Task SearchCachedDocumentsInCurrentProcessAsync(IChecksummedPersistentStorageService storageService, ImmutableArray`1<DocumentKey> documentKeys, ImmutableArray`1<DocumentKey> priorityDocumentKeys, string searchPattern, IImmutableSet`1<string> kinds, Func`4<ImmutableArray`1<RoslynNavigateToItem>, VoidResult, CancellationToken, Task> onItemsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
    private static Task`1<TopLevelSyntaxTreeIndex> GetIndexAsync(IChecksummedPersistentStorageService storageService, DocumentKey documentKey, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual IImmutableSet`1<string> get_KindsProvided();
    public sealed virtual bool get_CanFilter();
    private static Func`4<ImmutableArray`1<RoslynNavigateToItem>, VoidResult, CancellationToken, Task> GetOnItemsFoundCallback(Solution solution, Document activeDocument, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound);
    private static PooledDisposer`1<PooledHashSet`1<T>> GetPooledHashSet(IEnumerable`1<T> items, PooledHashSet`1& instance);
    private static PooledDisposer`1<PooledHashSet`1<T>> GetPooledHashSet(ImmutableArray`1<T> items, PooledHashSet`1& instance);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<Prioritize>d__16`1")]
private static IEnumerable`1<T> Prioritize(IEnumerable`1<T> items, Func`2<T, bool> isPriority);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchGeneratedDocumentsAsync>d__17")]
public sealed virtual Task SearchGeneratedDocumentsAsync(Solution solution, ImmutableArray`1<Project> projects, string searchPattern, IImmutableSet`1<string> kinds, Document activeDocument, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchGeneratedDocumentsInCurrentProcessAsync>d__18")]
public static Task SearchGeneratedDocumentsInCurrentProcessAsync(ImmutableArray`1<Project> projects, string pattern, IImmutableSet`1<string> kinds, Func`4<ImmutableArray`1<RoslynNavigateToItem>, VoidResult, CancellationToken, Task> onItemsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchSingleDocumentAsync>d__20")]
private static ValueTask SearchSingleDocumentAsync(Document document, string patternName, string patternContainer, DeclaredSymbolInfoKindSet kinds, Action`1<RoslynNavigateToItem> onItemFound, CancellationToken cancellationToken);
    private static void ProcessIndex(DocumentKey documentKey, Document document, string patternName, string patternContainer, DeclaredSymbolInfoKindSet kinds, TopLevelSyntaxTreeIndex index, ArrayBuilder`1<ValueTuple`2<TopLevelSyntaxTreeIndex, ProjectId>> linkedIndices, Action`1<RoslynNavigateToItem> onItemFound, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static RoslynNavigateToItem ConvertResult(DocumentKey documentKey, Document document, DeclaredSymbolInfo declaredSymbolInfo, TemporaryArray`1& nameMatches, TemporaryArray`1& containerMatches, ImmutableArray`1<ProjectId> additionalMatchingProjects);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<ProjectId> GetAdditionalProjectsWithMatch(Document document, DeclaredSymbolInfo declaredSymbolInfo, ArrayBuilder`1<ValueTuple`2<TopLevelSyntaxTreeIndex, ProjectId>> linkedIndices);
    private static string GetItemKind(DeclaredSymbolInfo declaredSymbolInfo);
    [NullableContextAttribute("0")]
private static NavigateToMatchKind GetNavigateToMatchKind(TemporaryArray`1& nameMatches);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchDocumentAsync>d__27")]
public sealed virtual Task SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchDocumentInCurrentProcessAsync>d__28")]
public static Task SearchDocumentInCurrentProcessAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, Func`4<ImmutableArray`1<RoslynNavigateToItem>, VoidResult, CancellationToken, Task> onItemsFound, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchProjectsAsync>d__29")]
public sealed virtual Task SearchProjectsAsync(Solution solution, ImmutableArray`1<Project> projects, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, Document activeDocument, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.AbstractNavigateToSearchService/<SearchProjectsInCurrentProcessAsync>d__30")]
public static Task SearchProjectsInCurrentProcessAsync(ImmutableArray`1<Project> projects, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, Func`4<ImmutableArray`1<RoslynNavigateToItem>, VoidResult, CancellationToken, Task> onItemsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.NavigateTo.DefaultNavigateToSearchHost : object {
    private Solution _solution;
    private IAsynchronousOperationListener _asyncListener;
    private CancellationToken _disposalToken;
    private static object s_gate;
    [NullableAttribute("2")]
private static Task s_remoteHostHydrateTask;
    public DefaultNavigateToSearchHost(Solution solution, IAsynchronousOperationListener asyncListener, CancellationToken disposalToken);
    private static DefaultNavigateToSearchHost();
    public sealed virtual INavigateToSearchService GetNavigateToSearchService(Project project);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.DefaultNavigateToSearchHost/<IsFullyLoadedAsync>d__7")]
public sealed virtual ValueTask`1<bool> IsFullyLoadedAsync(CancellationToken cancellationToken);
    private Task GetRemoteHostHydrateTask();
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.DefaultNavigateToSearchHost/<<GetRemoteHostHydrateTask>b__8_1>d")]
[CompilerGeneratedAttribute]
private Task <GetRemoteHostHydrateTask>b__8_1();
}
internal interface Microsoft.CodeAnalysis.NavigateTo.IAdvancedNavigateToSearchService {
    [NullableContextAttribute("1")]
public abstract virtual Task SearchCachedDocumentsAsync(Solution solution, ImmutableArray`1<Project> projects, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, Document activeDocument, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual Task SearchGeneratedDocumentsAsync(Solution solution, ImmutableArray`1<Project> projects, string searchPattern, IImmutableSet`1<string> kinds, Document activeDocument, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchCallback {
    public abstract virtual void Done(bool isFullyLoaded);
    public abstract virtual void ReportIncomplete();
    public abstract virtual Task AddResultsAsync(ImmutableArray`1<INavigateToSearchResult> results, CancellationToken cancellationToken);
    public abstract virtual void ReportProgress(int current, int maximum);
}
internal interface Microsoft.CodeAnalysis.NavigateTo.INavigateToSearcherHost {
    [NullableContextAttribute("1")]
public abstract virtual INavigateToSearchService GetNavigateToSearchService(Project project);
    public abstract virtual ValueTask`1<bool> IsFullyLoadedAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchResult {
    public string AdditionalInformation { get; }
    public string Kind { get; }
    public NavigateToMatchKind MatchKind { get; }
    public bool IsCaseSensitive { get; }
    public string Name { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<TextSpan> NameMatchSpans { get; }
    public string SecondarySort { get; }
    [NullableAttribute("2")]
public string Summary { get; }
    public INavigableItem NavigableItem { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<PatternMatch> Matches { get; }
    public abstract virtual string get_AdditionalInformation();
    public abstract virtual string get_Kind();
    public abstract virtual NavigateToMatchKind get_MatchKind();
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual string get_Name();
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<TextSpan> get_NameMatchSpans();
    public abstract virtual string get_SecondarySort();
    [NullableContextAttribute("2")]
public abstract virtual string get_Summary();
    public abstract virtual INavigableItem get_NavigableItem();
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<PatternMatch> get_Matches();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService {
    public IImmutableSet`1<string> KindsProvided { get; }
    public bool CanFilter { get; }
    public abstract virtual IImmutableSet`1<string> get_KindsProvided();
    public abstract virtual bool get_CanFilter();
    public abstract virtual Task SearchDocumentAsync(Document document, string searchPattern, IImmutableSet`1<string> kinds, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, CancellationToken cancellationToken);
    public abstract virtual Task SearchProjectsAsync(Solution solution, ImmutableArray`1<Project> projects, ImmutableArray`1<Document> priorityDocuments, string searchPattern, IImmutableSet`1<string> kinds, Document activeDocument, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task> onResultsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.NavigateTo.IRemoteNavigateToSearchService {
    public abstract virtual ValueTask SearchDocumentAsync(Checksum solutionChecksum, DocumentId documentId, string searchPattern, ImmutableArray`1<string> kinds, RemoteServiceCallbackId callbackId, CancellationToken cancellationToken);
    public abstract virtual ValueTask SearchProjectsAsync(Checksum solutionChecksum, ImmutableArray`1<ProjectId> projectIds, ImmutableArray`1<DocumentId> priorityDocumentIds, string searchPattern, ImmutableArray`1<string> kinds, RemoteServiceCallbackId callbackId, CancellationToken cancellationToken);
    public abstract virtual ValueTask SearchGeneratedDocumentsAsync(Checksum solutionChecksum, ImmutableArray`1<ProjectId> projectIds, string searchPattern, ImmutableArray`1<string> kinds, RemoteServiceCallbackId callbackId, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public abstract virtual ValueTask SearchCachedDocumentsAsync(ImmutableArray`1<DocumentKey> documentKeys, ImmutableArray`1<DocumentKey> priorityDocumentKeys, string searchPattern, ImmutableArray`1<string> kinds, RemoteServiceCallbackId callbackId, CancellationToken cancellationToken);
    public abstract virtual ValueTask HydrateAsync(Checksum solutionChecksum, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.NavigateTo.IWorkspaceNavigateToSearcherHostService {
    public abstract virtual ValueTask`1<bool> IsFullyLoadedAsync(CancellationToken cancellationToken);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.NavigateTo.NavigateToDocumentSupport : Enum {
    public int value__;
    public static NavigateToDocumentSupport RegularDocuments;
    public static NavigateToDocumentSupport GeneratedDocuments;
    public static NavigateToDocumentSupport AllDocuments;
}
internal static class Microsoft.CodeAnalysis.NavigateTo.NavigateToItemKind : object {
    public static string Line;
    public static string File;
    public static string Class;
    public static string Structure;
    public static string Interface;
    public static string Delegate;
    public static string Enum;
    public static string Module;
    public static string Constant;
    public static string EnumItem;
    public static string Field;
    public static string Method;
    public static string Property;
    public static string Event;
    public static string OtherSymbol;
}
internal enum Microsoft.CodeAnalysis.NavigateTo.NavigateToMatchKind : Enum {
    public int value__;
    public static NavigateToMatchKind Exact;
    public static NavigateToMatchKind Prefix;
    public static NavigateToMatchKind Substring;
    public static NavigateToMatchKind Regular;
    public static NavigateToMatchKind None;
    public static NavigateToMatchKind CamelCaseExact;
    public static NavigateToMatchKind CamelCasePrefix;
    public static NavigateToMatchKind CamelCaseNonContiguousPrefix;
    public static NavigateToMatchKind CamelCaseSubstring;
    public static NavigateToMatchKind CamelCaseNonContiguousSubstring;
    public static NavigateToMatchKind Fuzzy;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher : object {
    private static ObjectPool`1<HashSet`1<INavigateToSearchResult>> s_searchResultPool;
    private INavigateToSearcherHost _host;
    private Solution _solution;
    private INavigateToSearchCallback _callback;
    private string _searchPattern;
    private IImmutableSet`1<string> _kinds;
    private IStreamingProgressTracker _progress_doNotAccessDirectly;
    [NullableAttribute("2")]
private Document _activeDocument;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Document> _visibleDocuments;
    private int _remainingProgressItems;
    private NavigateToSearcher(INavigateToSearcherHost host, Solution solution, INavigateToSearchCallback callback, string searchPattern, IImmutableSet`1<string> kinds);
    private static NavigateToSearcher();
    public static NavigateToSearcher Create(Solution solution, IAsynchronousOperationListener asyncListener, INavigateToSearchCallback callback, string searchPattern, IImmutableSet`1<string> kinds, CancellationToken disposalToken);
    public static NavigateToSearcher Create(Solution solution, INavigateToSearchCallback callback, string searchPattern, IImmutableSet`1<string> kinds, INavigateToSearcherHost host);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<AddProgressItemsAsync>d__13")]
private Task AddProgressItemsAsync(int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<ProgressItemsCompletedAsync>d__14")]
private Task ProgressItemsCompletedAsync(int count, CancellationToken cancellationToken);
    public Task SearchAsync(NavigateToSearchScope searchScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<SearchAsync>d__16")]
public Task SearchAsync(NavigateToSearchScope searchScope, NavigateToDocumentSupport documentSupport, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<SearchCurrentDocumentAsync>d__17")]
private Task SearchCurrentDocumentAsync(CancellationToken cancellationToken);
    private Task SearchCurrentProjectAsync(NavigateToDocumentSupport documentSupport, CancellationToken cancellationToken);
    private INavigateToSearchService GetNavigateToSearchService(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<SearchAllProjectsAsync>d__20")]
private Task SearchAllProjectsAsync(bool isFullyLoaded, NavigateToDocumentSupport documentSupport, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<SearchSpecificProjectsAsync>d__21")]
private Task SearchSpecificProjectsAsync(bool isFullyLoaded, NavigateToDocumentSupport documentSupport, ImmutableArray`1<ImmutableArray`1<Project>> orderedProjects, CancellationToken cancellationToken);
    private ImmutableArray`1<ImmutableArray`1<Project>> GetOrderedProjectsToProcess();
    private ImmutableArray`1<Document> GetPriorityDocuments(ImmutableArray`1<Project> projects);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearcher/<ProcessOrderedProjectsAsync>d__24")]
private Task ProcessOrderedProjectsAsync(bool parallel, ImmutableArray`1<ImmutableArray`1<Project>> orderedProjects, HashSet`1<INavigateToSearchResult> seenResults, Func`5<INavigateToSearchService, ImmutableArray`1<Project>, Func`2<ImmutableArray`1<INavigateToSearchResult>, Task>, Func`1<Task>, Task> processProjectAsync, CancellationToken cancellationToken);
    private Task SearchFullyLoadedProjectsAsync(ImmutableArray`1<ImmutableArray`1<Project>> orderedProjects, HashSet`1<INavigateToSearchResult> seenItems, CancellationToken cancellationToken);
    private Task SearchCachedDocumentsAsync(ImmutableArray`1<ImmutableArray`1<Project>> orderedProjects, HashSet`1<INavigateToSearchResult> seenItems, CancellationToken cancellationToken);
    private Task SearchGeneratedDocumentsAsync(ImmutableArray`1<ImmutableArray`1<Project>> orderedProjects, HashSet`1<INavigateToSearchResult> seenItems, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchResultComparer : object {
    [NullableAttribute("1")]
public static IEqualityComparer`1<INavigateToSearchResult> Instance;
    private static NavigateToSearchResultComparer();
    public sealed virtual bool Equals(INavigateToSearchResult x, INavigateToSearchResult y);
    public sealed virtual int GetHashCode(INavigateToSearchResult obj);
}
internal static class Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchResultHelpers : object {
    public static ImmutableArray`1<PatternMatch> GetMatches(INavigateToSearchResult result);
    private static PatternMatchKind GetPatternMatchKind(NavigateToMatchKind matchKind);
}
internal enum Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchScope : Enum {
    public int value__;
    public static NavigateToSearchScope Solution;
    public static NavigateToSearchScope Project;
    public static NavigateToSearchScope Document;
}
internal class Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchServiceCallback : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`4<ImmutableArray`1<RoslynNavigateToItem>, VoidResult, CancellationToken, Task> <onItemsFound>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<Task> <onProjectCompleted>P;
    [CompilerGeneratedAttribute]
private CancellationToken <cancellationToken>P;
    public NavigateToSearchServiceCallback(Func`4<ImmutableArray`1<RoslynNavigateToItem>, VoidResult, CancellationToken, Task> onItemsFound, Func`1<Task> onProjectCompleted, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchServiceCallback/<OnItemsFoundAsync>d__4")]
public ValueTask OnItemsFoundAsync(ImmutableArray`1<RoslynNavigateToItem> items);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchServiceCallback/<OnProjectCompletedAsync>d__5")]
public ValueTask OnProjectCompletedAsync();
}
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.NavigateTo.IRemoteNavigateToSearchService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.NavigateTo.NavigateToSearchServiceServerCallbackDispatcher : RemoteServiceCallbackDispatcher {
    [NullableContextAttribute("1")]
private NavigateToSearchServiceCallback GetCallback(RemoteServiceCallbackId callbackId);
    public sealed virtual ValueTask OnItemsFoundAsync(RemoteServiceCallbackId callbackId, ImmutableArray`1<RoslynNavigateToItem> items);
    public sealed virtual ValueTask OnProjectCompletedAsync(RemoteServiceCallbackId callbackId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.NavigateTo.NavigateToUtilities : object {
    public static ImmutableHashSet`1<string> GetKindsProvided(Solution solution);
    public static TextSpan GetBoundedSpan(INavigableItem item, SourceText sourceText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem : ValueType {
    [DataMemberAttribute]
public bool IsStale;
    [DataMemberAttribute]
public DocumentKey DocumentKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ProjectId> AdditionalMatchingProjects;
    [DataMemberAttribute]
public DeclaredSymbolInfo DeclaredSymbolInfo;
    [DataMemberAttribute]
public string Kind;
    [DataMemberAttribute]
public NavigateToMatchKind MatchKind;
    [DataMemberAttribute]
public bool IsCaseSensitive;
    [NullableAttribute("0")]
[DataMemberAttribute]
public ImmutableArray`1<TextSpan> NameMatchSpans;
    [NullableAttribute("0")]
[DataMemberAttribute]
public ImmutableArray`1<PatternMatch> Matches;
    public DocumentId DocumentId { get; }
    [NullableContextAttribute("0")]
public RoslynNavigateToItem(bool isStale, DocumentKey documentKey, ImmutableArray`1<ProjectId> additionalMatchingProjects, DeclaredSymbolInfo declaredSymbolInfo, string kind, NavigateToMatchKind matchKind, bool isCaseSensitive, ImmutableArray`1<TextSpan> nameMatchSpans, ImmutableArray`1<PatternMatch> matches);
    public DocumentId get_DocumentId();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigateTo.RoslynNavigateToItem/<TryCreateSearchResultAsync>d__12")]
public Task`1<INavigateToSearchResult> TryCreateSearchResultAsync(Solution solution, Document activeDocument, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Navigation.AbstractNavigableItemsService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Navigation.AbstractNavigableItemsService/<GetNavigableItemsAsync>d__0")]
public sealed virtual Task`1<ImmutableArray`1<INavigableItem>> GetNavigableItemsAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Navigation.DefaultDocumentNavigationService : object {
    public sealed virtual Task`1<bool> CanNavigateToSpanAsync(Workspace workspace, DocumentId documentId, TextSpan textSpan, bool allowInvalidSpan, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> CanNavigateToPositionAsync(Workspace workspace, DocumentId documentId, int position, int virtualSpace, CancellationToken cancellationToken);
    public sealed virtual Task`1<INavigableLocation> GetLocationForSpanAsync(Workspace workspace, DocumentId documentId, TextSpan textSpan, bool allowInvalidSpan, CancellationToken cancellationToken);
    public sealed virtual Task`1<INavigableLocation> GetLocationForPositionAsync(Workspace workspace, DocumentId documentId, int position, int virtualSpace, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Navigation.DefaultSymbolNavigationService : object {
    [NullableContextAttribute("1")]
public sealed virtual Task`1<INavigableLocation> GetNavigableLocationAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<bool> TrySymbolNavigationNotifyAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<Nullable`1<ValueTuple`2<string, LinePosition>>> GetExternalNavigationSymbolLocationAsync(DefinitionItem definitionItem, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Navigation.DefaultSymbolNavigationServiceFactory : object {
    private ISymbolNavigationService _singleton;
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Navigation.DefinitionLocation : object {
    [CompilerGeneratedAttribute]
private INavigableLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public INavigableLocation Location { get; public set; }
    public DocumentSpan Span { get; public set; }
    public DefinitionLocation(INavigableLocation Location, DocumentSpan Span);
    [CompilerGeneratedAttribute]
private DefinitionLocation(DefinitionLocation original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public INavigableLocation get_Location();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Location(INavigableLocation value);
    [CompilerGeneratedAttribute]
public DocumentSpan get_Span();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Span(DocumentSpan value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DefinitionLocation left, DefinitionLocation right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DefinitionLocation left, DefinitionLocation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(DefinitionLocation other);
    [CompilerGeneratedAttribute]
public DefinitionLocation <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(INavigableLocation& Location, DocumentSpan& Span);
}
internal static class Microsoft.CodeAnalysis.Navigation.DefinitionLocationServiceHelpers : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Navigation.DefinitionLocationServiceHelpers/<GetDefinitionLocationFromLegacyImplementationsAsync>d__0")]
public static Task`1<DefinitionLocation> GetDefinitionLocationFromLegacyImplementationsAsync(Document document, int position, Func`2<CancellationToken, Task`1<IEnumerable`1<ValueTuple`2<Document, TextSpan>>>> getNavigableItems, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static DocumentSpan <GetDefinitionLocationFromLegacyImplementationsAsync>g__GetDocumentSpan|0_0(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static char <GetDefinitionLocationFromLegacyImplementationsAsync>g__GetChar|0_1(int position, <>c__DisplayClass0_0& );
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Navigation.ICrossLanguageSymbolNavigationService {
    public abstract virtual Task`1<INavigableLocation> TryGetNavigableLocationAsync(string assemblyName, string documentationCommentId, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Navigation.IDefinitionLocationService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<DefinitionLocation> GetDefinitionLocationAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Navigation.IDocumentNavigationService {
    public abstract virtual Task`1<bool> CanNavigateToSpanAsync(Workspace workspace, DocumentId documentId, TextSpan textSpan, bool allowInvalidSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CanNavigateToPositionAsync(Workspace workspace, DocumentId documentId, int position, int virtualSpace, CancellationToken cancellationToken);
    public abstract virtual Task`1<INavigableLocation> GetLocationForSpanAsync(Workspace workspace, DocumentId documentId, TextSpan textSpan, bool allowInvalidSpan, CancellationToken cancellationToken);
    public abstract virtual Task`1<INavigableLocation> GetLocationForPositionAsync(Workspace workspace, DocumentId documentId, int position, int virtualSpace, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Navigation.IDocumentNavigationServiceExtensions : object {
    [ExtensionAttribute]
public static Task`1<bool> CanNavigateToSpanAsync(IDocumentNavigationService service, Workspace workspace, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> CanNavigateToPositionAsync(IDocumentNavigationService service, Workspace workspace, DocumentId documentId, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<INavigableLocation> GetLocationForSpanAsync(IDocumentNavigationService service, Workspace workspace, DocumentId documentId, TextSpan textSpan, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<INavigableLocation> GetLocationForPositionAsync(IDocumentNavigationService service, Workspace workspace, DocumentId documentId, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Navigation.INavigableItem {
    public Glyph Glyph { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<TaggedText> DisplayTaggedParts { get; }
    public bool DisplayFileLocation { get; }
    public bool IsImplicitlyDeclared { get; }
    public NavigableDocument Document { get; }
    public TextSpan SourceSpan { get; }
    public bool IsStale { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<INavigableItem> ChildItems { get; }
    public abstract virtual Glyph get_Glyph();
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<TaggedText> get_DisplayTaggedParts();
    public abstract virtual bool get_DisplayFileLocation();
    public abstract virtual bool get_IsImplicitlyDeclared();
    public abstract virtual NavigableDocument get_Document();
    public abstract virtual TextSpan get_SourceSpan();
    public abstract virtual bool get_IsStale();
    public abstract virtual ImmutableArray`1<INavigableItem> get_ChildItems();
}
internal interface Microsoft.CodeAnalysis.Navigation.INavigableItemsService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<INavigableItem>> GetNavigableItemsAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Navigation.INavigableLocation {
    public abstract virtual Task`1<bool> NavigateToAsync(NavigationOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Navigation.ISymbolNavigationService {
    public abstract virtual Task`1<INavigableLocation> GetNavigableLocationAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> TrySymbolNavigationNotifyAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
    public abstract virtual Task`1<Nullable`1<ValueTuple`2<string, LinePosition>>> GetExternalNavigationSymbolLocationAsync(DefinitionItem definitionItem, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Navigation.NavigableItemFactory : object {
    public static INavigableItem GetItemFromSymbolLocation(Solution solution, ISymbol symbol, Location location, Nullable`1<ImmutableArray`1<TaggedText>> displayTaggedParts);
    public static ImmutableArray`1<INavigableItem> GetItemsFromPreferredSourceLocations(Solution solution, ISymbol symbol, Nullable`1<ImmutableArray`1<TaggedText>> displayTaggedParts, CancellationToken cancellationToken);
    public static IEnumerable`1<Location> GetPreferredSourceLocations(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    private static IEnumerable`1<Location> GetPreferredSourceLocations(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.Navigation.NavigableLocation : object {
    [NullableAttribute("1")]
private Func`3<NavigationOptions, CancellationToken, Task`1<bool>> _callback;
    [NullableContextAttribute("1")]
public NavigableLocation(Func`3<NavigationOptions, CancellationToken, Task`1<bool>> callback);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<bool> NavigateToAsync(NavigationOptions options, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Navigation.NavigationOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <PreferProvisionalTab>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ActivateTab>k__BackingField;
    public static NavigationOptions Default;
    public bool PreferProvisionalTab { get; public set; }
    public bool ActivateTab { get; public set; }
    public NavigationOptions(bool PreferProvisionalTab, bool ActivateTab);
    private static NavigationOptions();
    [CompilerGeneratedAttribute]
public bool get_PreferProvisionalTab();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferProvisionalTab(bool value);
    [CompilerGeneratedAttribute]
public bool get_ActivateTab();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ActivateTab(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NavigationOptions left, NavigationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NavigationOptions left, NavigationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NavigationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& PreferProvisionalTab, Boolean& ActivateTab);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.NavigationBar.AbstractNavigationBarItemService : object {
    protected abstract virtual Task`1<ImmutableArray`1<RoslynNavigationBarItem>> GetItemsInCurrentProcessAsync(Document document, bool supportsCodeGeneration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigationBar.AbstractNavigationBarItemService/<GetItemsAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<RoslynNavigationBarItem>> GetItemsAsync(Document document, bool supportsCodeGeneration, bool frozenPartialSemantics, CancellationToken cancellationToken);
    protected static Nullable`1<SymbolItemLocation> GetSymbolLocation(Solution solution, ISymbol symbol, SyntaxTree tree, Func`2<SyntaxReference, TextSpan> computeFullSpan);
    private static Nullable`1<SymbolItemLocation> GetSymbolLocation(Solution solution, ISymbol symbol, SyntaxTree tree, Func`2<SyntaxReference, TextSpan> computeFullSpan, ImmutableArray`1<SyntaxReference> allReferences);
    protected static Nullable`1<SymbolItemLocation> GetSymbolLocation(Solution solution, ISymbol symbol, SyntaxTree tree, ISymbolDeclarationService symbolDeclarationService);
}
internal interface Microsoft.CodeAnalysis.NavigationBar.INavigationBarItemService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<RoslynNavigationBarItem>> GetItemsAsync(Document document, bool supportsCodeGeneration, bool frozenPartialSemantics, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.NavigationBar.IRemoteNavigationBarItemService {
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableNavigationBarItem>> GetItemsAsync(Checksum solutionChecksum, DocumentId documentId, bool supportsCodeGeneration, bool forceFrozenPartialSemanticsForCrossProcessOperations, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItem : object {
    public RoslynNavigationBarItemKind Kind;
    public string Text;
    public Glyph Glyph;
    public bool Bolded;
    public bool Grayed;
    public int Indent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<RoslynNavigationBarItem> ChildItems;
    protected RoslynNavigationBarItem(RoslynNavigationBarItemKind kind, string text, Glyph glyph, bool bolded, bool grayed, int indent, ImmutableArray`1<RoslynNavigationBarItem> childItems);
    protected internal abstract virtual SerializableNavigationBarItem Dehydrate();
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RoslynNavigationBarItem other);
}
internal enum Microsoft.CodeAnalysis.NavigationBar.RoslynNavigationBarItemKind : Enum {
    public int value__;
    public static RoslynNavigationBarItemKind Symbol;
    public static RoslynNavigationBarItemKind GenerateDefaultConstructor;
    public static RoslynNavigationBarItemKind GenerateEventHandler;
    public static RoslynNavigationBarItemKind GenerateFinalizer;
    public static RoslynNavigationBarItemKind GenerateMethod;
    public static RoslynNavigationBarItemKind Actionless;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.NavigationBar.SerializableNavigationBarItem : object {
    [DataMemberAttribute]
public RoslynNavigationBarItemKind Kind;
    [DataMemberAttribute]
public string Text;
    [DataMemberAttribute]
public Glyph Glyph;
    [DataMemberAttribute]
public bool Bolded;
    [DataMemberAttribute]
public bool Grayed;
    [DataMemberAttribute]
public int Indent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<SerializableNavigationBarItem> ChildItems;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string Name;
    [DataMemberAttribute]
public bool IsObsolete;
    [DataMemberAttribute]
public Nullable`1<SymbolItemLocation> Location;
    [DataMemberAttribute]
public Nullable`1<SymbolKey> DestinationTypeSymbolKey;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string ContainerName;
    [DataMemberAttribute]
public Nullable`1<SymbolKey> EventSymbolKey;
    [DataMemberAttribute]
public Nullable`1<SymbolKey> MethodToReplicateSymbolKey;
    [NullableContextAttribute("2")]
private SerializableNavigationBarItem(RoslynNavigationBarItemKind kind, string text, Glyph glyph, bool bolded, bool grayed, int indent, ImmutableArray`1<SerializableNavigationBarItem> childItems, string name, bool isObsolete, Nullable`1<SymbolItemLocation> location, Nullable`1<SymbolKey> destinationTypeSymbolKey, string containerName, Nullable`1<SymbolKey> eventSymbolKey, Nullable`1<SymbolKey> methodToReplicateSymbolKey);
    public RoslynNavigationBarItem Rehydrate();
    public static ImmutableArray`1<SerializableNavigationBarItem> Dehydrate(ImmutableArray`1<RoslynNavigationBarItem> values);
    public static SerializableNavigationBarItem ActionlessItem(string text, Glyph glyph, ImmutableArray`1<SerializableNavigationBarItem> childItems, int indent, bool bolded, bool grayed);
    public static SerializableNavigationBarItem SymbolItem(string text, Glyph glyph, string name, bool isObsolete, SymbolItemLocation location, ImmutableArray`1<SerializableNavigationBarItem> childItems, int indent, bool bolded, bool grayed);
    public static SerializableNavigationBarItem GenerateFinalizer(string text, SymbolKey destinationTypeSymbolKey);
    public static SerializableNavigationBarItem GenerateEventHandler(string eventName, Glyph glyph, string containerName, SymbolKey eventSymbolKey, SymbolKey destinationTypeSymbolKey);
    public static SerializableNavigationBarItem GenerateMethod(string text, Glyph glyph, SymbolKey destinationTypeSymbolId, SymbolKey methodToReplicateSymbolId);
    public static SerializableNavigationBarItem GenerateDefaultConstructor(string text, SymbolKey destinationTypeSymbolKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.NewLines.ConsecutiveStatementPlacement.AbstractConsecutiveStatementPlacementDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxFacts _syntaxFacts;
    protected AbstractConsecutiveStatementPlacementDiagnosticAnalyzer`1(ISyntaxFacts syntaxFacts);
    protected abstract virtual bool IsBlockLikeStatement(SyntaxNode node);
    protected abstract virtual Location GetDiagnosticLocation(SyntaxNode block);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node, CancellationToken cancellationToken);
    private void ProcessBlockLikeStatement(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode block);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__5_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.NewLines.ConsecutiveStatementPlacement.ConsecutiveStatementPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, Diagnostic diagnostic, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NewLines.ConsecutiveStatementPlacement.ConsecutiveStatementPlacementCodeFixProvider/<FixAllAsync>d__5")]
public static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.NewLines.MultipleBlankLines.AbstractMultipleBlankLinesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxFacts _syntaxFacts;
    protected AbstractMultipleBlankLinesDiagnosticAnalyzer(ISyntaxFacts syntaxFacts);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node, CancellationToken cancellationToken);
    private void CheckToken(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxToken token);
    private bool ContainsMultipleBlankLines(SyntaxToken token, SyntaxTrivia& firstBadTrivia);
    private bool IsEndOfLine(SyntaxTriviaList triviaList, int index);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.NewLines.MultipleBlankLines.MultipleBlankLinesCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NewLines.MultipleBlankLines.MultipleBlankLinesCodeFixProvider/<FixAllAsync>d__5")]
private static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static SyntaxTriviaList UpdateLeadingTrivia(ISyntaxKindsService syntaxKinds, SyntaxTriviaList triviaList);
    private static bool IsEndOfLine(ISyntaxKindsService syntaxKinds, SyntaxTriviaList triviaList, int index);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
}
internal interface Microsoft.CodeAnalysis.Notification.INotificationService {
    public abstract virtual void SendNotification(string message, string title, NotificationSeverity severity);
    public abstract virtual bool ConfirmMessageBox(string message, string title, NotificationSeverity severity);
}
internal interface Microsoft.CodeAnalysis.Notification.INotificationServiceCallback {
    public Action`3<string, string, NotificationSeverity> NotificationCallback { get; public set; }
    public abstract virtual Action`3<string, string, NotificationSeverity> get_NotificationCallback();
    public abstract virtual void set_NotificationCallback(Action`3<string, string, NotificationSeverity> value);
}
internal enum Microsoft.CodeAnalysis.Notification.NotificationSeverity : Enum {
    public int value__;
    public static NotificationSeverity Information;
    public static NotificationSeverity Warning;
    public static NotificationSeverity Error;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private ISyntaxFacts _syntaxFacts;
    private AbstractOrderModifiersHelpers _helpers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> FixableCompilerErrorIds { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractOrderModifiersCodeFixProvider(ISyntaxFacts syntaxFacts, AbstractOrderModifiersHelpers helpers);
    protected abstract virtual ImmutableArray`1<string> get_FixableCompilerErrorIds();
    protected abstract virtual CodeStyleOption2`1<string> GetCodeStyleOption(AnalyzerOptionsProvider options);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider/<RegisterCodeFixesAsync>d__8")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersCodeFixProvider/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private ISyntaxFacts _syntaxFacts;
    private AbstractOrderModifiersHelpers _helpers;
    protected AbstractOrderModifiersDiagnosticAnalyzer(ISyntaxFacts syntaxFacts, Option2`1<CodeStyleOption2`1<string>> option, AbstractOrderModifiersHelpers helpers);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual CodeStyleOption2`1<string> GetPreferredOrderStyle(SyntaxTreeAnalysisContext context);
    private void AnalyzeSyntaxTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    protected abstract virtual void Recurse(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, NotificationOption2 notificationOption, SyntaxNode root);
    protected void CheckModifiers(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, NotificationOption2 notificationOption, SyntaxNode memberDeclaration);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.OrderModifiers.AbstractOrderModifiersHelpers : object {
    private static Char[] s_comma;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Tuple`2<string, Dictionary`2<int, int>> _lastParsed;
    private static AbstractOrderModifiersHelpers();
    protected abstract virtual int GetKeywordKind(string trimmed);
    public static bool IsOrdered(Dictionary`2<int, int> preferredOrder, SyntaxTokenList modifiers);
    public bool TryGetOrComputePreferredOrder(string value, Dictionary`2& preferredOrder);
    protected virtual bool TryParse(string value, Dictionary`2& parsed);
}
internal abstract class Microsoft.CodeAnalysis.Organizing.AbstractOrganizingService : object {
    private IEnumerable`1<ISyntaxOrganizer> _organizers;
    protected AbstractOrganizingService(IEnumerable`1<ISyntaxOrganizer> organizers);
    public sealed virtual IEnumerable`1<ISyntaxOrganizer> GetDefaultOrganizers();
    protected abstract virtual Task`1<Document> ProcessAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> OrganizeAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
    protected Func`2<SyntaxNode, IEnumerable`1<ISyntaxOrganizer>> GetNodeToOrganizers(IEnumerable`1<ISyntaxOrganizer> organizers);
}
internal interface Microsoft.CodeAnalysis.Organizing.IOrganizingService {
    public abstract virtual IEnumerable`1<ISyntaxOrganizer> GetDefaultOrganizers();
    public abstract virtual Task`1<Document> OrganizeAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Organizing.Organizers.AbstractSyntaxNodeOrganizer`1 : object {
    public IEnumerable`1<Type> SyntaxNodeTypes { get; }
    public sealed virtual IEnumerable`1<Type> get_SyntaxNodeTypes();
    public sealed virtual SyntaxNode OrganizeNode(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual TSyntaxNode Organize(TSyntaxNode node, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Organizing.Organizers.ExportSyntaxNodeOrganizerAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public ExportSyntaxNodeOrganizerAttribute(string languageName);
    [CompilerGeneratedAttribute]
public string get_Language();
}
internal interface Microsoft.CodeAnalysis.Organizing.Organizers.ISyntaxOrganizer {
    public IEnumerable`1<Type> SyntaxNodeTypes { get; }
    public abstract virtual IEnumerable`1<Type> get_SyntaxNodeTypes();
    public abstract virtual SyntaxNode OrganizeNode(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Organizing.OrganizingService : object {
    public static Task`1<Document> OrganizeAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.PasteTracking.IPasteTrackingService {
    public abstract virtual bool TryGetPastedTextSpan(SourceTextContainer sourceTextContainer, TextSpan& textSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.DocumentDebugInfoReader : object {
    private MetadataReaderProvider _pdbReaderProvider;
    private PEReader _peReader;
    private MetadataReader _dllReader;
    private MetadataReader _pdbReader;
    public DocumentDebugInfoReader(PEReader peReader, MetadataReaderProvider pdbReaderProvider);
    public ImmutableArray`1<SourceDocument> FindSourceDocuments(EntityHandle entityHandle);
    [NullableContextAttribute("2")]
private string TryGetSourceLinkUrl(DocumentHandle handle);
    [NullableContextAttribute("2")]
private Byte[] TryGetEmbeddedTextBytes(DocumentHandle handle);
    public ImmutableDictionary`2<string, string> GetCompilationOptions();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.PdbSourceDocument.IImplementationAssemblyLookupService {
    public abstract virtual bool TryFindImplementationAssemblyPath(string referencedDllPath, String& implementationDllPath);
    public abstract virtual string FollowTypeForwards(ISymbol symbol, string dllPath, IPdbSourceDocumentLogger logger);
    public abstract virtual void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.PdbSourceDocument.IImplementationAssemblyLookupService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.ImplementationAssemblyLookupService : object {
    private static SymbolDisplayFormat s_metadataSymbolDisplayFormat;
    private static string PathSeparatorString;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, Dictionary`2<ValueTuple`2<string, string>, string>> _typeForwardCache;
    private object _cacheLock;
    private static ImplementationAssemblyLookupService();
    public sealed virtual bool TryFindImplementationAssemblyPath(string referencedDllPath, String& implementationDllPath);
    public sealed virtual string FollowTypeForwards(ISymbol symbol, string dllPath, IPdbSourceDocumentLogger logger);
    public sealed virtual void Clear();
    private static bool TryNugetLibToRef(String[] pathParts, String& implementationDllPath);
    private static bool TryTargetingPackToSharedSdk(String[] pathParts, String& implementationDllPath);
    private static Dictionary`2<ValueTuple`2<string, string>, string> GetAllTypeForwards(MetadataReader md);
    [CompilerGeneratedAttribute]
private bool <FollowTypeForwards>g__TryGetCachedTypeForwards|6_0(string dllPath, Dictionary`2& typeForwards);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.PdbSourceDocument.IPdbFileLocatorService {
    public abstract virtual Task`1<DocumentDebugInfoReader> GetDocumentDebugInfoReaderAsync(string dllPath, bool useDefaultSymbolServers, TelemetryMessage telemetry, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.PdbSourceDocument.IPdbSourceDocumentLoaderService {
    public abstract virtual Task`1<SourceFileInfo> LoadSourceDocumentAsync(string tempFilePath, SourceDocument sourceDocument, Encoding encoding, TelemetryMessage telemetry, bool useExtendedTimeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.PdbSourceDocument.IPdbSourceDocumentLogger {
    public abstract virtual void Clear();
    public abstract virtual void Log(string message);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.PdbSourceDocument.ISourceLinkService {
    public abstract virtual Task`1<SourceFilePathResult> GetSourceFilePathAsync(string url, string relativePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<PdbFilePathResult> GetPdbFilePathAsync(string dllPath, PEReader peReader, bool useDefaultSymbolServers, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.PdbSourceDocument.IPdbFileLocatorService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.PdbFileLocatorService : object {
    private static int SymbolLocatorTimeout;
    private ISourceLinkService _sourceLinkService;
    private IPdbSourceDocumentLogger _logger;
    [ImportingConstructorAttribute]
public PdbFileLocatorService(ISourceLinkService sourceLinkService, IPdbSourceDocumentLogger logger);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PdbSourceDocument.PdbFileLocatorService/<GetDocumentDebugInfoReaderAsync>d__4")]
public sealed virtual Task`1<DocumentDebugInfoReader> GetDocumentDebugInfoReaderAsync(string dllPath, bool useDefaultSymbolServers, TelemetryMessage telemetry, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static FileStream <GetDocumentDebugInfoReaderAsync>g__ReadFileIfExists|4_1(string fileName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.PdbFilePathResult : object {
    [CompilerGeneratedAttribute]
private string <PdbFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string PdbFilePath { get; public set; }
    public PdbFilePathResult(string PdbFilePath);
    [CompilerGeneratedAttribute]
protected PdbFilePathResult(PdbFilePathResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_PdbFilePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PdbFilePath(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PdbFilePathResult left, PdbFilePathResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PdbFilePathResult left, PdbFilePathResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PdbFilePathResult other);
    [CompilerGeneratedAttribute]
public virtual PdbFilePathResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& PdbFilePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.PdbSourceDocument.IPdbSourceDocumentLoaderService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentLoaderService : object {
    private static int SourceLinkTimeout;
    private static int ExtendedSourceLinkTimeout;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ISourceLinkService> _sourceLinkService;
    [NullableAttribute("2")]
private IPdbSourceDocumentLogger _logger;
    [NullableContextAttribute("2")]
[ImportingConstructorAttribute]
public PdbSourceDocumentLoaderService(Lazy`1<ISourceLinkService> sourceLinkService, IPdbSourceDocumentLogger logger);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentLoaderService/<LoadSourceDocumentAsync>d__5")]
public sealed virtual Task`1<SourceFileInfo> LoadSourceDocumentAsync(string tempFilePath, SourceDocument sourceDocument, Encoding encoding, TelemetryMessage telemetry, bool useExtendedTimeout, CancellationToken cancellationToken);
    private SourceFileInfo TryGetEmbeddedSourceFile(string tempFilePath, SourceDocument sourceDocument, Encoding encoding, TelemetryMessage telemetry);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentLoaderService/<TryGetSourceLinkFileAsync>d__7")]
private Task`1<SourceFileInfo> TryGetSourceLinkFileAsync(SourceDocument sourceDocument, Encoding encoding, TelemetryMessage telemetry, bool useExtendedTimeout, CancellationToken cancellationToken);
    private SourceFileInfo TryGetOriginalFile(SourceDocument sourceDocument, Encoding encoding, TelemetryMessage telemetry);
    private static SourceFileInfo LoadSourceFile(string filePath, SourceDocument sourceDocument, Encoding encoding, string sourceDescription, bool ignoreChecksum, bool fromRemoteLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentLoggerExtensions : object {
    [ExtensionAttribute]
public static void Log(IPdbSourceDocumentLogger logger, string message, object arg0);
    [ExtensionAttribute]
public static void Log(IPdbSourceDocumentLogger logger, string message, object arg0, object arg1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportMetadataAsSourceFileProviderAttribute("PdbSource")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider : object {
    internal static string ProviderName;
    private IPdbFileLocatorService _pdbFileLocatorService;
    private IPdbSourceDocumentLoaderService _pdbSourceDocumentLoaderService;
    private IImplementationAssemblyLookupService _implementationAssemblyLookupService;
    [NullableAttribute("2")]
private IPdbSourceDocumentLogger _logger;
    private Dictionary`2<string, ProjectId> _assemblyToProjectMap;
    private HashSet`1<ProjectId> _sourceLinkEnabledProjects;
    private ConcurrentDictionary`2<string, SourceDocumentInfo> _fileToDocumentInfoMap;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public PdbSourceDocumentMetadataAsSourceFileProvider(IPdbFileLocatorService pdbFileLocatorService, IPdbSourceDocumentLoaderService pdbSourceDocumentLoaderService, IImplementationAssemblyLookupService implementationAssemblyLookupService, IPdbSourceDocumentLogger logger);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PdbSourceDocument.PdbSourceDocumentMetadataAsSourceFileProvider/<GetGeneratedFileAsync>d__9")]
public sealed virtual Task`1<MetadataAsSourceFile> GetGeneratedFileAsync(MetadataAsSourceWorkspace metadataWorkspace, Workspace sourceWorkspace, Project sourceProject, ISymbol symbol, bool signaturesOnly, MetadataAsSourceOptions options, string tempPath, TelemetryMessage telemetryMessage, CancellationToken cancellationToken);
    private ProjectInfo CreateProjectInfo(Workspace workspace, Project project, ImmutableDictionary`2<string, string> pdbCompilationOptions, string assemblyName, string assemblyVersion, SourceHashAlgorithm checksumAlgorithm);
    private ImmutableArray`1<DocumentInfo> CreateDocumentInfos(SourceFileInfo[] sourceFileInfos, Encoding encoding, ProjectId projectId, Workspace sourceWorkspace, Project sourceProject);
    private static void AssertIsMainThread(MetadataAsSourceWorkspace workspace);
    public sealed virtual bool ShouldCollapseOnOpen(MetadataAsSourceWorkspace workspace, string filePath, BlockStructureOptions blockStructureOptions);
    public sealed virtual bool TryAddDocumentToWorkspace(MetadataAsSourceWorkspace workspace, string filePath, SourceTextContainer sourceTextContainer);
    public sealed virtual bool TryRemoveDocumentFromWorkspace(MetadataAsSourceWorkspace workspace, string filePath);
    public sealed virtual Project MapDocument(Document document);
    public sealed virtual void CleanupGeneratedFiles(MetadataAsSourceWorkspace workspace);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.SourceDocument : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceHashAlgorithm <ChecksumAlgorithm>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EmbeddedTextBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceLinkUrl>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [NullableAttribute("1")]
public string FilePath { get; public set; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; public set; }
    [NullableAttribute("0")]
public ImmutableArray`1<byte> Checksum { get; public set; }
    public Byte[] EmbeddedTextBytes { get; public set; }
    public string SourceLinkUrl { get; public set; }
    public SourceDocument(string FilePath, SourceHashAlgorithm ChecksumAlgorithm, ImmutableArray`1<byte> Checksum, Byte[] EmbeddedTextBytes, string SourceLinkUrl);
    [CompilerGeneratedAttribute]
private SourceDocument(SourceDocument original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_FilePath();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilePath(string value);
    [CompilerGeneratedAttribute]
public SourceHashAlgorithm get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChecksumAlgorithm(SourceHashAlgorithm value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_Checksum();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Checksum(ImmutableArray`1<byte> value);
    [CompilerGeneratedAttribute]
public Byte[] get_EmbeddedTextBytes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EmbeddedTextBytes(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_SourceLinkUrl();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceLinkUrl(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SourceDocument left, SourceDocument right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SourceDocument left, SourceDocument right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SourceDocument other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public SourceDocument <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& FilePath, SourceHashAlgorithm& ChecksumAlgorithm, ImmutableArray`1& Checksum, Byte[]& EmbeddedTextBytes, String& SourceLinkUrl);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.SourceDocumentInfo : ValueType {
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceHashAlgorithm <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectId <SourceProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private Workspace <SourceWorkspace>k__BackingField;
    public DocumentId DocumentId { get; public set; }
    public Encoding Encoding { get; public set; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; public set; }
    public ProjectId SourceProjectId { get; public set; }
    public Workspace SourceWorkspace { get; public set; }
    public SourceDocumentInfo(DocumentId DocumentId, Encoding Encoding, SourceHashAlgorithm ChecksumAlgorithm, ProjectId SourceProjectId, Workspace SourceWorkspace);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
public void set_DocumentId(DocumentId value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SourceHashAlgorithm get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
public void set_ChecksumAlgorithm(SourceHashAlgorithm value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ProjectId get_SourceProjectId();
    [CompilerGeneratedAttribute]
public void set_SourceProjectId(ProjectId value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Workspace get_SourceWorkspace();
    [CompilerGeneratedAttribute]
public void set_SourceWorkspace(Workspace value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SourceDocumentInfo left, SourceDocumentInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SourceDocumentInfo left, SourceDocumentInfo right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SourceDocumentInfo other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(DocumentId& DocumentId, Encoding& Encoding, SourceHashAlgorithm& ChecksumAlgorithm, ProjectId& SourceProjectId, Workspace& SourceWorkspace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.SourceFileInfo : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private TextLoader <Loader>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceHashAlgorithm <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FromRemoteLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public string FilePath { get; public set; }
    public string SourceDescription { get; public set; }
    public TextLoader Loader { get; public set; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; public set; }
    public bool FromRemoteLocation { get; public set; }
    public SourceFileInfo(string FilePath, string SourceDescription, TextLoader Loader, SourceHashAlgorithm ChecksumAlgorithm, bool FromRemoteLocation);
    [CompilerGeneratedAttribute]
private SourceFileInfo(SourceFileInfo original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilePath(string value);
    [CompilerGeneratedAttribute]
public string get_SourceDescription();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceDescription(string value);
    [CompilerGeneratedAttribute]
public TextLoader get_Loader();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Loader(TextLoader value);
    [CompilerGeneratedAttribute]
public SourceHashAlgorithm get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChecksumAlgorithm(SourceHashAlgorithm value);
    [CompilerGeneratedAttribute]
public bool get_FromRemoteLocation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FromRemoteLocation(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SourceFileInfo left, SourceFileInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SourceFileInfo left, SourceFileInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SourceFileInfo other);
    [CompilerGeneratedAttribute]
public SourceFileInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& FilePath, String& SourceDescription, TextLoader& Loader, SourceHashAlgorithm& ChecksumAlgorithm, Boolean& FromRemoteLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PdbSourceDocument.SourceFilePathResult : object {
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string SourceFilePath { get; public set; }
    public SourceFilePathResult(string SourceFilePath);
    [CompilerGeneratedAttribute]
protected SourceFilePathResult(SourceFilePathResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SourceFilePath(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SourceFilePathResult left, SourceFilePathResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SourceFilePathResult left, SourceFilePathResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SourceFilePathResult other);
    [CompilerGeneratedAttribute]
public virtual SourceFilePathResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& SourceFilePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PdbSourceDocument.SymbolSourceDocumentFinder : object {
    public static HashSet`1<DocumentHandle> FindDocumentHandles(EntityHandle handle, MetadataReader dllReader, MetadataReader pdbReader);
    private static void ProcessMethodDef(MethodDefinitionHandle methodDefHandle, MetadataReader dllReader, MetadataReader pdbReader, HashSet`1<DocumentHandle> docList, bool processDeclaringType);
    private static void ProcessEventDef(EventDefinitionHandle eventDefHandle, MetadataReader dllReader, MetadataReader pdbReader, HashSet`1<DocumentHandle> docList);
    private static void ProcessPropertyDef(PropertyDefinitionHandle propertyDefHandle, MetadataReader dllReader, MetadataReader pdbReader, HashSet`1<DocumentHandle> docList);
    private static void ProcessFieldDef(FieldDefinitionHandle fieldDefHandle, MetadataReader dllReader, MetadataReader pdbReader, HashSet`1<DocumentHandle> docList);
    private static void ProcessTypeDef(TypeDefinitionHandle typeDefHandle, MetadataReader dllReader, MetadataReader pdbReader, HashSet`1<DocumentHandle> docList, bool processContainingType);
    private static void AddDocumentsFromTypeDefinitionDocuments(TypeDefinitionHandle typeDefHandle, MetadataReader pdbReader, HashSet`1<DocumentHandle> docList);
}
internal interface Microsoft.CodeAnalysis.PickMembers.IPickMembersService {
    public abstract virtual PickMembersResult PickMembers(string title, ImmutableArray`1<ISymbol> members, ImmutableArray`1<PickMembersOption> options, bool selectAll);
}
internal class Microsoft.CodeAnalysis.PickMembers.PickMembersOption : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public string Id { get; }
    public string Title { get; }
    public bool Value { get; public set; }
    public PickMembersOption(string id, string title, bool value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(bool value);
}
internal class Microsoft.CodeAnalysis.PickMembers.PickMembersResult : object {
    [NullableAttribute("1")]
public static PickMembersResult Canceled;
    public bool IsCanceled;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISymbol> Members;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<PickMembersOption> Options;
    public bool SelectedAll;
    private PickMembersResult(bool isCanceled);
    public PickMembersResult(ImmutableArray`1<ISymbol> members, ImmutableArray`1<PickMembersOption> options, bool selectedAll);
    private static PickMembersResult();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractPopulateSwitchCodeFixProvider`4(string diagnosticId);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual ITypeSymbol GetSwitchType(TSwitchOperation switchStatement);
    protected abstract virtual ICollection`1<ISymbol> GetMissingEnumMembers(TSwitchOperation switchOperation);
    protected abstract virtual bool HasNullSwitchArm(TSwitchOperation switchOperation);
    protected abstract virtual TSwitchArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, TMemberAccessExpression caseLabel);
    protected abstract virtual TSwitchArmSyntax CreateNullSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected abstract virtual TSwitchArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected abstract virtual int InsertPosition(TSwitchOperation switchOperation);
    protected abstract virtual TSwitchSyntax InsertSwitchArms(SyntaxGenerator generator, TSwitchSyntax switchNode, int insertLocation, List`1<TSwitchArmSyntax> newArms);
    protected abstract virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, TSwitchOperation switchOperation);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private Task`1<Document> FixAsync(Document document, Diagnostic diagnostic, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4/<FixWithEditorAsync>d__16")]
private Task FixWithEditorAsync(Document document, SyntaxEditor editor, ImmutableArray`1<Diagnostic> diagnostics, bool addCases, bool addDefaultCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchCodeFixProvider`4/<FixOneDiagnosticAsync>d__17")]
private Task FixOneDiagnosticAsync(Document document, SyntaxEditor editor, Diagnostic diagnostic, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, CancellationToken cancellationToken);
    protected TSwitchSyntax UpdateSwitchNode(SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, TSwitchOperation switchOperation);
    protected static void AddMissingBraces(Document document, SyntaxNode& root, TSwitchSyntax& switchNode);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    protected OperationKind OperationKind { get; }
    protected AbstractPopulateSwitchDiagnosticAnalyzer`2(string diagnosticId, EnforceOnBuild enforceOnBuild);
    private static AbstractPopulateSwitchDiagnosticAnalyzer`2();
    protected abstract virtual OperationKind get_OperationKind();
    protected abstract virtual bool IsSwitchTypeUnknown(TSwitchOperation operation);
    protected abstract virtual IOperation GetValueOfSwitchOperation(TSwitchOperation operation);
    protected abstract virtual bool HasConstantCase(TSwitchOperation operation, object value);
    protected abstract virtual ICollection`1<ISymbol> GetMissingEnumMembers(TSwitchOperation operation);
    protected abstract virtual bool HasDefaultCase(TSwitchOperation operation);
    protected abstract virtual bool HasExhaustiveNullAndTypeCheckCases(TSwitchOperation operation);
    protected abstract virtual Location GetDiagnosticLocation(TSwitchSyntax switchBlock);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
    private ValueTuple`2<bool, bool> AnalyzeSwitch(TSwitchOperation switchOperation, ITypeSymbol type);
    private ValueTuple`2<bool, bool> AnalyzeBooleanSwitch(TSwitchOperation operation, ITypeSymbol type);
    private ValueTuple`2<bool, bool> AnalyzeEnumSwitch(TSwitchOperation operation, ITypeSymbol type);
    [NullableContextAttribute("2")]
protected static bool ConstantValueEquals(Optional`1<object> constantValue, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchExpressionCodeFixProvider`4 : AbstractPopulateSwitchCodeFixProvider`4<ISwitchExpressionOperation, TSwitchSyntax, TSwitchArmSyntax, TMemberAccessExpressionSyntax> {
    protected sealed virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, ISwitchExpressionOperation switchExpression);
    protected sealed virtual ITypeSymbol GetSwitchType(ISwitchExpressionOperation switchExpression);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation switchOperation);
    protected virtual bool HasNullSwitchArm(ISwitchExpressionOperation switchOperation);
    protected static TExpressionSyntax Exception(SyntaxGenerator generator, Compilation compilation);
    protected sealed virtual int InsertPosition(ISwitchExpressionOperation switchExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchExpressionDiagnosticAnalyzer`1 : AbstractPopulateSwitchDiagnosticAnalyzer`2<ISwitchExpressionOperation, TSwitchSyntax> {
    protected OperationKind OperationKind { get; }
    protected sealed virtual OperationKind get_OperationKind();
    protected virtual IOperation GetValueOfSwitchOperation(ISwitchExpressionOperation operation);
    protected virtual bool IsSwitchTypeUnknown(ISwitchExpressionOperation operation);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation operation);
    protected sealed virtual bool HasDefaultCase(ISwitchExpressionOperation operation);
    protected virtual bool HasExhaustiveNullAndTypeCheckCases(ISwitchExpressionOperation operation);
    protected virtual bool HasConstantCase(ISwitchExpressionOperation operation, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchStatementCodeFixProvider`3 : AbstractPopulateSwitchCodeFixProvider`4<ISwitchOperation, TSwitchSyntax, TSwitchArmSyntax, TMemberAccessExpression> {
    protected sealed virtual void FixOneDiagnostic(Document document, SyntaxEditor editor, SemanticModel semanticModel, bool addCases, bool addDefaultCase, bool onlyOneDiagnostic, bool hasMissingCases, bool hasMissingDefaultCase, TSwitchSyntax switchNode, ISwitchOperation switchOperation);
    protected sealed virtual ITypeSymbol GetSwitchType(ISwitchOperation switchOperation);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation switchOperation);
    protected sealed virtual bool HasNullSwitchArm(ISwitchOperation switchOperation);
    protected sealed virtual TSwitchSyntax InsertSwitchArms(SyntaxGenerator generator, TSwitchSyntax switchNode, int insertLocation, List`1<TSwitchArmSyntax> newArms);
    protected sealed virtual TSwitchArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected sealed virtual TSwitchArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, TMemberAccessExpression caseLabel);
    protected virtual TSwitchArmSyntax CreateNullSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected sealed virtual int InsertPosition(ISwitchOperation switchStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.PopulateSwitch.AbstractPopulateSwitchStatementDiagnosticAnalyzer`1 : AbstractPopulateSwitchDiagnosticAnalyzer`2<ISwitchOperation, TSwitchSyntax> {
    protected OperationKind OperationKind { get; }
    protected sealed virtual OperationKind get_OperationKind();
    protected virtual IOperation GetValueOfSwitchOperation(ISwitchOperation operation);
    protected sealed virtual bool IsSwitchTypeUnknown(ISwitchOperation operation);
    protected sealed virtual ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation operation);
    protected sealed virtual bool HasDefaultCase(ISwitchOperation operation);
    protected virtual bool HasExhaustiveNullAndTypeCheckCases(ISwitchOperation operation);
    protected sealed virtual Location GetDiagnosticLocation(TSwitchSyntax switchBlock);
    protected virtual bool HasConstantCase(ISwitchOperation operation, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PopulateSwitch.PopulateSwitchExpressionHelpers : object {
    public static ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchExpressionOperation operation);
    public static bool HasNullSwitchArm(ISwitchExpressionOperation operation);
    private static void RemoveExistingEnumMembers(ISwitchExpressionOperation operation, Dictionary`2<long, ISymbol> enumMembers);
    internal static void HandleBinaryPattern(IBinaryPatternOperation binaryPattern, Dictionary`2<long, ISymbol> enumMembers);
    private static void RemoveIfConstantPatternHasValue(IOperation operation, Dictionary`2<long, ISymbol> enumMembers);
    public static bool HasDefaultCase(ISwitchExpressionOperation operation);
    public static bool IsDefault(ISwitchExpressionArmOperation arm);
    public static bool IsDefault(IPatternOperation pattern);
    public static bool HasExhaustiveNullAndTypeCheckCases(ISwitchExpressionOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PopulateSwitch.PopulateSwitchStatementHelpers : object {
    public static string MissingCases;
    public static string MissingDefaultCase;
    public static bool HasDefaultCase(ISwitchOperation switchStatement);
    private static bool HasDefaultCase(ISwitchCaseOperation switchCase);
    public static ICollection`1<ISymbol> GetMissingEnumMembers(ISwitchOperation switchStatement);
    public static bool HasNullSwitchArm(ISwitchOperation operation);
    private static bool TryRemoveExistingEnumMembers(ISwitchOperation switchStatement, Dictionary`2<long, ISymbol> enumValues);
    public static bool TryGetAllEnumMembers(ITypeSymbol enumType, Dictionary`2<long, ISymbol> enumValues);
    public static bool HasExhaustiveNullAndTypeCheckCases(ISwitchOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PredefinedEmbeddedLanguageNames : object {
    public static string Regex;
    public static string Json;
    public static string CSharpTest;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
}
internal static class Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeConstants : object {
    public static string PreferFrameworkType;
    public static ImmutableDictionary`2<string, string> Properties;
    private static PreferFrameworkTypeConstants();
}
internal abstract class Microsoft.CodeAnalysis.PreferFrameworkType.PreferFrameworkTypeDiagnosticAnalyzerBase`5 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ImmutableArray`1<TSyntaxKind> SyntaxKindsOfInterest { get; }
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ImmutableArray`1<TSyntaxKind> get_SyntaxKindsOfInterest();
    [NullableContextAttribute("1")]
protected abstract virtual bool IsPredefinedTypeReplaceableWithFrameworkType(TPredefinedTypeSyntax node);
    [NullableContextAttribute("1")]
protected abstract virtual bool IsIdentifierNameReplaceableWithFrameworkType(SemanticModel semanticModel, TIdentifierNameSyntax node);
    [NullableContextAttribute("1")]
protected abstract virtual bool IsInMemberAccessOrCrefReferenceContext(TExpressionSyntax node);
    [NullableContextAttribute("1")]
protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected void AnalyzeNode(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <AnalyzeNode>g__IsFrameworkTypePreferred|9_0(CodeStyleOption2`1<bool> optionValue);
}
internal interface Microsoft.CodeAnalysis.ProjectManagement.IProjectManagementService {
    public abstract virtual IList`1<string> GetFolders(ProjectId projectId, Workspace workspace);
    public abstract virtual string GetDefaultNamespace(Project project, Workspace workspace);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.PullMemberUp.MemberAnalysisResult : ValueType {
    public ISymbol Member;
    public bool ChangeOriginalToPublic;
    public bool ChangeOriginalToNonStatic;
    public bool MakeMemberDeclarationAbstract;
    public bool ChangeDestinationTypeToAbstract;
    public bool PullMemberUpNeedsToDoExtraChanges { get; }
    public MemberAnalysisResult(ISymbol member, bool changeOriginalToPublic, bool changeOriginalToNonStatic, bool makeMemberDeclarationAbstract, bool changeDestinationTypeToAbstract);
    public bool get_PullMemberUpNeedsToDoExtraChanges();
}
internal static class Microsoft.CodeAnalysis.PullMemberUp.MemberAndDestinationValidator : object {
    [NullableContextAttribute("1")]
public static bool IsDestinationValid(Solution solution, INamedTypeSymbol destination, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static bool IsMemberValid(ISymbol member);
}
internal class Microsoft.CodeAnalysis.PullMemberUp.PullMembersUpOptions : object {
    public INamedTypeSymbol Destination;
    public ImmutableArray`1<MemberAnalysisResult> MemberAnalysisResults;
    public bool PullUpOperationNeedsToDoExtraChanges;
    public PullMembersUpOptions(INamedTypeSymbol destination, ImmutableArray`1<MemberAnalysisResult> memberAnalysisResults);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessCodeFixprovider`2 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual string GetTitle();
    protected abstract virtual TSimpleNameSyntax GetNode(Diagnostic diagnostic, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QualifyMemberAccess.AbstractQualifyMemberAccessDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ISimplification Simplification { get; }
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    protected abstract virtual bool CanMemberAccessBeQualified(ISymbol containingSymbol, SyntaxNode node);
    protected abstract virtual bool IsAlreadyQualifiedMemberAccess(TExpressionSyntax node);
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual Location GetLocation(IOperation operation);
    protected abstract virtual ISimplification get_Simplification();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    private void AnalyzeOperation(OperationAnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context, IOperation operation, IOperation instanceOperation);
    private static bool IsStaticMemberOrIsLocalFunction(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <IsStaticMemberOrIsLocalFunction>g__IsStaticMemberOrIsLocalFunctionHelper|11_0(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QuickInfo.AbstractEmbeddedLanguageQuickInfoProvider : CommonQuickInfoProvider {
    private EmbeddedLanguageProviderFeatureService _embeddedLanguageProviderFeature;
    public AbstractEmbeddedLanguageQuickInfoProvider(string languageName, EmbeddedLanguageInfo info, ISyntaxKinds syntaxKinds, IEnumerable`1<Lazy`2<IEmbeddedLanguageQuickInfoProvider, EmbeddedLanguageMetadata>> allServices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.AbstractEmbeddedLanguageQuickInfoProvider/<BuildQuickInfoAsync>d__2")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(QuickInfoContext context, SyntaxToken token);
    protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(CommonQuickInfoContext context, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoContext : ValueType {
    public SolutionServices Services;
    public SemanticModel SemanticModel;
    public int Position;
    public SymbolDescriptionOptions Options;
    public CancellationToken CancellationToken;
    public CommonQuickInfoContext(SolutionServices services, SemanticModel semanticModel, int position, SymbolDescriptionOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider : QuickInfoProvider {
    protected abstract virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(QuickInfoContext context, SyntaxToken token);
    protected abstract virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(CommonQuickInfoContext context, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider/<GetQuickInfoAsync>d__2")]
public virtual Task`1<QuickInfoItem> GetQuickInfoAsync(QuickInfoContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider/<GetQuickInfoAsync>d__3")]
public Task`1<QuickInfoItem> GetQuickInfoAsync(CommonQuickInfoContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider/<GetTokensAsync>d__4")]
protected Task`1<ImmutableArray`1<SyntaxToken>> GetTokensAsync(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected virtual bool ShouldCheckPreviousToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider/<GetQuickInfoAsync>d__6")]
private Task`1<QuickInfoItem> GetQuickInfoAsync(QuickInfoContext context, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonQuickInfoProvider/<GetQuickInfoAsync>d__7")]
private Task`1<QuickInfoItem> GetQuickInfoAsync(CommonQuickInfoContext context, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider : CommonQuickInfoProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<BuildQuickInfoAsync>d__0")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(QuickInfoContext context, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<BuildQuickInfoAsync>d__1")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(CommonQuickInfoContext context, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<ComputeQuickInfoDataAsync>d__2")]
private Task`1<ValueTuple`2<TokenInformation, SupportedPlatformData>> ComputeQuickInfoDataAsync(QuickInfoContext context, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.CommonSemanticQuickInfoProvider/<ComputeFromLinkedDocumentsAsync>d__3")]
private Task`1<ValueTuple`2<TokenInformation, SupportedPlatformData>> ComputeFromLinkedDocumentsAsync(QuickInfoContext context, SyntaxToken token, ImmutableArray`1<DocumentId> linkedDocumentIds);
    private static bool HasNoErrors(ImmutableArray`1<ISymbol> symbols);
    private static SyntaxToken FindTokenInLinkedDocument(SyntaxToken token, SemanticModel linkedModel, CancellationToken cancellationToken);
    protected static Task`1<QuickInfoItem> CreateContentAsync(SolutionServices services, SemanticModel semanticModel, SyntaxToken token, TokenInformation tokenInformation, SupportedPlatformData supportedPlatforms, SymbolDescriptionOptions options, OnTheFlyDocsElement onTheFlyDocsElement, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected abstract virtual bool GetBindableNodeForTokenIndicatingLambda(SyntaxToken token, SyntaxNode& found);
    [NullableContextAttribute("2")]
protected abstract virtual bool GetBindableNodeForTokenIndicatingPossibleIndexerAccess(SyntaxToken token, SyntaxNode& found);
    protected abstract virtual bool GetBindableNodeForTokenIndicatingMemberAccess(SyntaxToken token, SyntaxToken& found);
    protected virtual Task`1<OnTheFlyDocsElement> GetOnTheFlyDocsElementAsync(QuickInfoContext context, CancellationToken cancellationToken);
    protected virtual NullableFlowState GetNullabilityAnalysis(SemanticModel semanticModel, ISymbol symbol, SyntaxNode node, CancellationToken cancellationToken);
    private TokenInformation BindToken(SolutionServices services, SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    private ImmutableArray`1<ISymbol> GetSymbolsFromToken(SyntaxToken token, SolutionServices services, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsOk(ISymbol symbol);
    private static bool IsAccessible(ISymbol symbol, INamedTypeSymbol within);
}
internal class Microsoft.CodeAnalysis.QuickInfo.ExportEmbeddedLanguageQuickInfoProviderAttribute : ExportEmbeddedLanguageFeatureServiceAttribute {
    [NullableContextAttribute("1")]
public ExportEmbeddedLanguageQuickInfoProviderAttribute(string name, String[] languages, String[] identifiers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.QuickInfo.ExportQuickInfoProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public ExportQuickInfoProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
}
internal interface Microsoft.CodeAnalysis.QuickInfo.IEmbeddedLanguageQuickInfoProvider {
    [NullableContextAttribute("1")]
public abstract virtual QuickInfoItem GetQuickInfo(QuickInfoContext context, SemanticModel semanticModel, SyntaxToken token);
}
internal static class Microsoft.CodeAnalysis.QuickInfo.IndentationHelper : object {
    public static ImmutableArray`1<ClassifiedSpan> GetSpansWithAlignedIndentation(SourceText text, ImmutableArray`1<ClassifiedSpan> classifiedSpans, int tabSize);
    private static int DetermineIndentationColumn(SourceText text, ImmutableArray`1<ClassifiedSpan> spans, int tabSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.QuickInfo.OnTheFlyDocsElement : object {
    [CompilerGeneratedAttribute]
private string <SymbolSignature>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <DeclarationCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasComments>k__BackingField;
    public string SymbolSignature { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> DeclarationCode { get; }
    public string Language { get; }
    public bool HasComments { get; public set; }
    public OnTheFlyDocsElement(string symbolSignature, ImmutableArray`1<string> declarationCode, string language, bool hasComments);
    [CompilerGeneratedAttribute]
public string get_SymbolSignature();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_DeclarationCode();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public bool get_HasComments();
    [CompilerGeneratedAttribute]
public void set_HasComments(bool value);
}
internal static class Microsoft.CodeAnalysis.QuickInfo.OnTheFlyDocsLogger : object {
    [NullableAttribute("1")]
private static CountLogAggregator`1<ActionInfo> s_countLogAggregator;
    private static OnTheFlyDocsLogger();
    internal static void LogHoveredSourceSymbol();
    internal static void LogHoveredMetadataSymbol();
    internal static void LogShowedOnTheFlyDocsLink();
    internal static void LogShowedOnTheFlyDocsLinkWithDocComments();
    internal static void LogOnTheFlyDocsResultsRequested();
    internal static void LogOnTheFlyDocsResultsRequestedWithDocComments();
    public static void ReportTelemetry();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.QuickInfo.QuickInfoContext : object {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDescriptionOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public Document Document { get; }
    public int Position { get; }
    public SymbolDescriptionOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public QuickInfoContext(Document document, int position, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public SymbolDescriptionOptions get_Options();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Microsoft.CodeAnalysis.QuickInfo.QuickInfoItem : object {
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Tags>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<QuickInfoSection> <Sections>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TextSpan> <RelatedSpans>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OnTheFlyDocsElement <OnTheFlyDocsElement>k__BackingField;
    public TextSpan Span { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<QuickInfoSection> Sections { get; }
    public ImmutableArray`1<TextSpan> RelatedSpans { get; }
    [NullableAttribute("2")]
internal OnTheFlyDocsElement OnTheFlyDocsElement { get; }
    private QuickInfoItem(TextSpan span, ImmutableArray`1<string> tags, ImmutableArray`1<QuickInfoSection> sections, ImmutableArray`1<TextSpan> relatedSpans, OnTheFlyDocsElement onTheFlyDocsElement);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Tags();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<QuickInfoSection> get_Sections();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TextSpan> get_RelatedSpans();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal OnTheFlyDocsElement get_OnTheFlyDocsElement();
    public static QuickInfoItem Create(TextSpan span, ImmutableArray`1<string> tags, ImmutableArray`1<QuickInfoSection> sections, ImmutableArray`1<TextSpan> relatedSpans);
    internal static QuickInfoItem Create(TextSpan span, ImmutableArray`1<string> tags, ImmutableArray`1<QuickInfoSection> sections, ImmutableArray`1<TextSpan> relatedSpans, OnTheFlyDocsElement onTheFlyDocsElement);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.QuickInfo.QuickInfoOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <ShowRemarksInQuickInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeNavigationHintsInQuickInfo>k__BackingField;
    public static QuickInfoOptions Default;
    [DataMemberAttribute]
public bool ShowRemarksInQuickInfo { get; public set; }
    [DataMemberAttribute]
public bool IncludeNavigationHintsInQuickInfo { get; public set; }
    private static QuickInfoOptions();
    [CompilerGeneratedAttribute]
public bool get_ShowRemarksInQuickInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowRemarksInQuickInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeNavigationHintsInQuickInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeNavigationHintsInQuickInfo(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(QuickInfoOptions left, QuickInfoOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(QuickInfoOptions left, QuickInfoOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(QuickInfoOptions other);
}
internal abstract class Microsoft.CodeAnalysis.QuickInfo.QuickInfoProvider : object {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<QuickInfoItem> GetQuickInfoAsync(QuickInfoContext context);
}
internal class Microsoft.CodeAnalysis.QuickInfo.QuickInfoProviderMetadata : OrderableLanguageMetadata {
    [NullableContextAttribute("1")]
public QuickInfoProviderMetadata(IDictionary`2<string, object> data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.QuickInfo.QuickInfoProviderNames : object {
    public static string Semantic;
    public static string Syntactic;
    public static string DiagnosticAnalyzer;
    public static string EmbeddedLanguages;
}
public class Microsoft.CodeAnalysis.QuickInfo.QuickInfoSection : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <TaggedParts>k__BackingField;
    [NullableAttribute("2")]
private string _text;
    [NullableAttribute("1")]
public string Kind { get; }
    public ImmutableArray`1<TaggedText> TaggedParts { get; }
    [NullableAttribute("1")]
public string Text { get; }
    private QuickInfoSection(string kind, ImmutableArray`1<TaggedText> taggedParts);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_TaggedParts();
    public static QuickInfoSection Create(string kind, ImmutableArray`1<TaggedText> taggedParts);
    [NullableContextAttribute("1")]
public string get_Text();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.QuickInfo.QuickInfoSectionKinds : object {
    public static string Description;
    public static string DocumentationComments;
    public static string RemarksDocumentationComments;
    public static string ReturnsDocumentationComments;
    public static string ValueDocumentationComments;
    public static string TypeParameters;
    public static string AnonymousTypes;
    public static string Usage;
    public static string Exception;
    public static string Text;
    public static string Captures;
    internal static string NullabilityAnalysis;
}
public abstract class Microsoft.CodeAnalysis.QuickInfo.QuickInfoService : object {
    [NullableContextAttribute("2")]
public static QuickInfoService GetService(Document document);
    [NullableContextAttribute("1")]
public Task`1<QuickInfoItem> GetQuickInfoAsync(Document document, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
internal virtual Task`1<QuickInfoItem> GetQuickInfoAsync(Document document, int position, SymbolDescriptionOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.QuickInfo.QuickInfoServiceWithProviders : QuickInfoService {
    private LanguageServices _services;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<QuickInfoProvider> _providers;
    protected QuickInfoServiceWithProviders(LanguageServices services);
    private ImmutableArray`1<QuickInfoProvider> GetProviders();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.QuickInfoServiceWithProviders/<GetQuickInfoAsync>d__4")]
internal virtual Task`1<QuickInfoItem> GetQuickInfoAsync(Document document, int position, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.QuickInfoServiceWithProviders/<GetQuickInfoAsync>d__5")]
internal Task`1<QuickInfoItem> GetQuickInfoAsync(SemanticModel semanticModel, int position, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetProviders>b__3_0(Lazy`2<QuickInfoProvider, QuickInfoProviderMetadata> lz);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.QuickInfo.QuickInfoUtilities : object {
    public static Task`1<QuickInfoItem> CreateQuickInfoItemAsync(SolutionServices services, SemanticModel semanticModel, TextSpan span, ImmutableArray`1<ISymbol> symbols, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.QuickInfo.QuickInfoUtilities/<CreateQuickInfoItemAsync>d__1")]
public static Task`1<QuickInfoItem> CreateQuickInfoItemAsync(SolutionServices services, SemanticModel semanticModel, TextSpan span, ImmutableArray`1<ISymbol> symbols, SupportedPlatformData supportedPlatforms, bool showAwaitReturn, NullableFlowState flowState, SymbolDescriptionOptions options, OnTheFlyDocsElement onTheFlyDocsElement, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <CreateQuickInfoItemAsync>g__TryGetGroupText|1_0(SymbolDescriptionGroups group, ImmutableArray`1& taggedParts, <>c__DisplayClass1_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <CreateQuickInfoItemAsync>g__AddSection|1_1(string kind, ImmutableArray`1<TaggedText> taggedParts, <>c__DisplayClass1_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2 : SyntaxEditorBasedCodeFixProvider {
    protected abstract virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected abstract virtual SyntaxNode RemoveAsyncModifier(SyntaxGenerator generator, SyntaxNode methodLikeNode);
    protected abstract virtual SyntaxNode ConvertToBlockBody(SyntaxNode node, TExpressionSyntax expressionBody);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveAsyncModifier.AbstractRemoveAsyncModifierCodeFixProvider`2/<FixAllAsync>d__4")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static IMethodSymbol GetMethodSymbol(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool ShouldOfferFix(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static bool IsTaskType(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private SyntaxNode RemoveAsyncModifier(SolutionServices solutionServices, ISyntaxFacts syntaxFacts, SyntaxGenerator generator, SyntaxNode node, ITypeSymbol returnType, KnownTaskTypes knownTypes, bool needsReturnStatementAdded);
    private static ControlFlowAnalysis GetControlFlowAnalysis(SyntaxGenerator generator, SemanticModel semanticModel, SyntaxNode node);
    private static SyntaxNode AddReturnStatement(SyntaxGenerator generator, SyntaxNode node);
    private SyntaxNode ChangeReturnStatements(SolutionServices solutionServices, ISyntaxFacts syntaxFacts, SyntaxGenerator generator, SyntaxNode node, ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static SyntaxNode GetReturnTaskCompletedTaskStatement(SyntaxGenerator generator, ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static SyntaxNode WrapExpressionWithTaskFromResult(SyntaxGenerator generator, SyntaxNode expression, ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static SyntaxNode TypeExpressionForStaticMemberAccess(SyntaxGenerator generator, INamedTypeSymbol typeSymbol);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <TypeExpressionForStaticMemberAccess>g__QualifiedNameToMemberAccess|14_0(int qualifiedNameSyntaxKind, int memberAccessExpressionSyntaxKind, SyntaxNode expression, SyntaxGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveRedundantEquality.AbstractRemoveRedundantEqualityDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private ISyntaxFacts <syntaxFacts>P;
    protected AbstractRemoveRedundantEqualityDiagnosticAnalyzer(ISyntaxFacts syntaxFacts);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeIsPatternOperator(OperationAnalysisContext context);
    private void AnalyzeBinaryOperator(OperationAnalysisContext context);
    private void AnalyzeOperator(OperationAnalysisContext context, IOperation leftOperand, IOperation rightOperand, bool isOperatorEquals, SyntaxToken operatorToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static Nullable`1<bool> <AnalyzeOperator>g__TryGetLiteralValue|6_0(IOperation operand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RemoveRedundantEquality.RedundantEqualityConstants : object {
    public static string RedundantSide;
    public static string Left;
    public static string Right;
    public static string Negate;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.RemoveRedundantEquality.RemoveRedundantEqualityCodeFixProvider : ForkingSyntaxEditorBasedCodeFixProvider`1<SyntaxNode> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ValueTuple`2<string, string> GetTitleAndEquivalenceKey(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveRedundantEquality.RemoveRedundantEqualityCodeFixProvider/<FixAsync>d__4")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, SyntaxNode node, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FixAsync>g__RewriteNode|4_0(<>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FixAsync>g__WithElasticTrailingTrivia|4_1(SyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryCast.AbstractRemoveUnnecessaryCastDiagnosticAnalyzer`2 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    protected ImmutableArray`1<TLanguageKindEnum> SyntaxKindsOfInterest { get; }
    protected abstract virtual ImmutableArray`1<TLanguageKindEnum> get_SyntaxKindsOfInterest();
    [NullableContextAttribute("1")]
protected abstract virtual TextSpan GetFadeSpan(TCastExpression node);
    [NullableContextAttribute("1")]
protected abstract virtual bool IsUnnecessaryCast(SemanticModel model, TCastExpression node, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
private Diagnostic TryRemoveCastExpression(SemanticModel model, TCastExpression node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual ISyntaxFormatting GetSyntaxFormatting();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual string GetTitle();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsCodeFixProvider/<RemoveUnnecessaryImportsAsync>d__6")]
private Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    internal static string EnableGenerateDocumentationFileId;
    private static DiagnosticDescriptor s_fixableIdDescriptor;
    private static DiagnosticDescriptor s_enableGenerateDocumentationFileIdDescriptor;
    private DiagnosticDescriptor _classificationIdDescriptor;
    private DiagnosticDescriptor _generatedCodeClassificationIdDescriptor;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IUnnecessaryImportsProvider`1<TSyntaxNode> UnnecessaryImportsProvider { get; }
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    protected AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1(LocalizableString titleAndMessage);
    private static AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1();
    private static ImmutableArray`1<DiagnosticDescriptor> GetDescriptors(LocalizableString titleAndMessage, DiagnosticDescriptor& classificationIdDescriptor, DiagnosticDescriptor& generatedCodeClassificationIdDescriptor);
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual ImmutableArray`1<SyntaxNode> MergeImports(ImmutableArray`1<TSyntaxNode> unnecessaryImports);
    protected abstract virtual bool IsRegularCommentOrDocComment(SyntaxTrivia trivia);
    protected abstract virtual IUnnecessaryImportsProvider`1<TSyntaxNode> get_UnnecessaryImportsProvider();
    protected virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    protected abstract virtual Nullable`1<SyntaxToken> TryGetLastToken(SyntaxNode node);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSemanticModel(SemanticModelAnalysisContext context);
    private void AnalyzeCompilation(CompilationAnalysisContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1/<GetContiguousSpans>d__19")]
private IEnumerable`1<TextSpan> GetContiguousSpans(ImmutableArray`1<SyntaxNode> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1/<CreateClassificationDiagnostics>d__20")]
private static IEnumerable`1<Diagnostic> CreateClassificationDiagnostics(IEnumerable`1<TextSpan> contiguousSpans, SyntaxTree tree, DiagnosticDescriptor descriptor, CancellationToken cancellationToken);
    protected abstract virtual IEnumerable`1<TextSpan> GetFixableDiagnosticSpans(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1/<CreateFixableDiagnostics>d__22")]
private IEnumerable`1<Diagnostic> CreateFixableDiagnostics(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static int <GetContiguousSpans>g__GetEnd|19_0(SyntaxNode node, <>c__DisplayClass19_0& );
}
internal static class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.RemoveUnnecessaryImportsConstants : object {
    [NullableAttribute("1")]
public static string DiagnosticFixableId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual bool CanRemoveParentheses(TParenthesizedExpressionSyntax current, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    [NullableContextAttribute("0")]
protected abstract virtual TLanguageKindEnum GetSyntaxKind();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool CanRemoveParentheses(TParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static Location GetDiagnosticSquiggleLocation(TParenthesizedExpressionSyntax parenthesizedExpression, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RemoveUnnecessaryParentheses.ParenthesesDiagnosticAnalyzersHelper : object {
    internal static ImmutableHashSet`1<IOption2> Options;
    private static ParenthesesDiagnosticAnalyzersHelper();
    internal static CodeStyleOption2`1<ParenthesesPreference> GetLanguageOption(AnalyzerOptionsProvider options, PrecedenceKind precedenceKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    internal static string DocCommentIdKey;
    private static LocalizableResourceString s_localizableTitle;
    private static LocalizableResourceString s_localizableInvalidScopeMessage;
    private static LocalizableResourceString s_localizableInvalidOrMissingTargetMessage;
    private static DiagnosticDescriptor s_invalidScopeDescriptor;
    private static DiagnosticDescriptor s_invalidOrMissingTargetDescriptor;
    private static LocalizableResourceString s_localizableLegacyFormatTitle;
    private static LocalizableResourceString s_localizableLegacyFormatMessage;
    internal static DiagnosticDescriptor LegacyFormatTargetDescriptor;
    private static AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer();
    protected abstract virtual void RegisterAttributeSyntaxAction(CompilationStartAnalysisContext context, CompilationAnalyzer compilationAnalyzer);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__12_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    private static LocalizableResourceString s_localizableRemoveUnnecessarySuppression;
    internal static DiagnosticDescriptor s_removeUnnecessarySuppressionDescriptor;
    private Lazy`1<ImmutableHashSet`1<int>> _lazySupportedCompilerErrorCodes;
    protected string CompilerErrorCodePrefix { get; }
    protected int CompilerErrorCodeDigitCount { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    private static AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer();
    protected abstract virtual string get_CompilerErrorCodePrefix();
    protected abstract virtual int get_CompilerErrorCodeDigitCount();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected abstract virtual ValueTuple`2<Assembly, string> GetCompilerDiagnosticAnalyzerInfo();
    protected abstract virtual bool ContainsPragmaDirective(SyntaxNode root);
    private ImmutableHashSet`1<int> GetSupportedCompilerErrorCodes();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<AnalyzeAsync>d__17")]
public sealed virtual Task AnalyzeAsync(SemanticModel semanticModel, Nullable`1<TextSpan> span, CompilationWithAnalyzers compilationWithAnalyzers, Func`2<DiagnosticAnalyzer, ImmutableArray`1<DiagnosticDescriptor>> getSupportedDiagnostics, Action`1<Diagnostic> reportDiagnostic, CancellationToken cancellationToken);
    private bool ProcessPragmaDirectives(SyntaxNode root, Nullable`1<TextSpan> span, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, PooledHashSet`1<string> compilerDiagnosticIds, ImmutableArray`1<string> userExclusions);
    private bool IsSupportedId(SyntaxNode idNode, String& id, Boolean& isCompilerDiagnosticId);
    private static bool IsSupportedAnalyzerDiagnosticId(string id);
    [NullableContextAttribute("2")]
private static ValueTuple`3<ImmutableArray`1<string>, ImmutableArray`1<string>, bool> ParseUserExclusions(string userExclusions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<GetReportedDiagnosticsForIdsAsync>d__22")]
private static Task`1<ValueTuple`2<ImmutableArray`1<Diagnostic>, ImmutableArray`1<string>>> GetReportedDiagnosticsForIdsAsync(ImmutableHashSet`1<string> idsToAnalyze, SyntaxNode root, SemanticModel semanticModel, CompilationWithAnalyzers compilationWithAnalyzers, Func`2<DiagnosticAnalyzer, ImmutableArray`1<DiagnosticDescriptor>> getSupportedDiagnostics, PooledHashSet`1<string> compilerDiagnosticIds, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<ProcessReportedDiagnosticsAsync>d__23")]
private static Task ProcessReportedDiagnosticsAsync(ImmutableArray`1<Diagnostic> diagnostics, SyntaxTree tree, CompilationWithAnalyzers compilationWithAnalyzers, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, CancellationToken cancellationToken);
    private static void ReportUnnecessarySuppressions(PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, Action`1<Diagnostic> reportDiagnostic, DiagnosticSeverity severity, Compilation compilation);
    private static bool TryGetTogglingPragmaDirective(SyntaxTrivia pragma, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, SyntaxTrivia& togglePragma);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<ProcessSuppressMessageAttributesAsync>d__26")]
private Task`1<bool> ProcessSuppressMessageAttributesAsync(SyntaxNode root, SemanticModel semanticModel, Nullable`1<TextSpan> span, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, ImmutableArray`1<string> userIdExclusions, ImmutableArray`1<string> userCategoryExclusions, CancellationToken cancellationToken);
    private static bool TryGetSuppressedDiagnosticId(AttributeData attribute, INamedTypeSymbol suppressMessageAttributeType, String& id, String& category);
    [CompilerGeneratedAttribute]
internal static void <GetReportedDiagnosticsForIdsAsync>g__AddAllDiagnostics|22_0(ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> diagnostics, ArrayBuilder`1<Diagnostic> reportedDiagnostics);
    [CompilerGeneratedAttribute]
internal static void <GetReportedDiagnosticsForIdsAsync>g__AddAllCompilationDiagnosticsForTree|22_1(AnalysisResult analysisResult, SyntaxTree tree, ArrayBuilder`1<Diagnostic> reportedDiagnostics);
    [CompilerGeneratedAttribute]
internal static void <ProcessReportedDiagnosticsAsync>g__ProcessPragmaSuppressions|23_0(Diagnostic diagnostic, SyntaxTree tree, PooledDictionary`2<string, List`1<ValueTuple`2<SyntaxTrivia, bool>>> idToPragmasMap, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer/<<ProcessReportedDiagnosticsAsync>g__ProcessAttributeSuppressionsAsync|23_1>d")]
[CompilerGeneratedAttribute]
internal static Task <ProcessReportedDiagnosticsAsync>g__ProcessAttributeSuppressionsAsync|23_1(Diagnostic diagnostic, AttributeData attribute, PooledDictionary`2<string, List`1<SyntaxNode>> idToSuppressMessageAttributesMap, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <ReportUnnecessarySuppressions>g__AddUnnecessaryPragmaDiagnostics|24_0(ArrayBuilder`1<Diagnostic> diagnosticsBuilder, PooledDictionary`2<SyntaxTrivia, bool> pragmasToIsUsedMap, ArrayBuilder`1<ValueTuple`3<SyntaxTrivia, ImmutableArray`1<string>, bool>> sortedPragmasWithIds, DiagnosticSeverity severity);
    [CompilerGeneratedAttribute]
internal static void <ReportUnnecessarySuppressions>g__AddUnnecessarySuppressMessageAttributeDiagnostics|24_1(ArrayBuilder`1<Diagnostic> diagnosticsBuilder, PooledDictionary`2<SyntaxNode, bool> suppressMessageAttributesToIsUsedMap, DiagnosticSeverity severity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryAttributeSuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryAttributeSuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryInlineSuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessarySuppressions.RemoveUnnecessaryInlineSuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <FixAllAsync>g__RemoveNode|4_0(Location location, SyntaxEditor editor, HashSet`1<SyntaxNode> processedNodes, ISyntaxFacts syntaxFacts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual void AdjustAndAddAppropriateDeclaratorsToRemove(HashSet`1<TFieldDeclarationSyntax> fieldDeclarators, HashSet`1<SyntaxNode> declarators);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersCodeFixProvider`1/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected static void AdjustAndAddAppropriateDeclaratorsToRemove(SyntaxNode parentDeclaration, IEnumerable`1<SyntaxNode> childDeclarators, HashSet`1<SyntaxNode> declarators);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedMembers.AbstractRemoveUnusedMembersDiagnosticAnalyzer`4 : AbstractCodeQualityDiagnosticAnalyzer {
    private static SymbolDisplayFormat ContainingTypeAndNameOnlyFormat;
    private static DiagnosticDescriptor s_removeUnusedMembersRule;
    internal static DiagnosticDescriptor s_removeUnreadMembersRule;
    private static AbstractRemoveUnusedMembersDiagnosticAnalyzer`4();
    protected abstract virtual IEnumerable`1<TTypeDeclarationSyntax> GetTypeDeclarations(INamedTypeSymbol namedType, CancellationToken cancellationToken);
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetMembers(TTypeDeclarationSyntax typeDeclaration);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected virtual void HandleNamedTypeSymbolStart(SymbolStartAnalysisContext context, Action`2<ISymbol, ValueUsageInfo> onSymbolUsageFound);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(CompilationStartAnalysisContext compilationStartContext);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public static string DiscardVariableName;
    private static string UnusedValuePreferenceKey;
    private static string IsUnusedLocalAssignmentKey;
    private static string IsRemovableAssignmentKey;
    private static DiagnosticDescriptor s_expressionValueIsUnusedRule;
    private static DiagnosticDescriptor s_valueAssignedIsUnusedRule;
    private static DiagnosticDescriptor s_unusedParameterRule;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<ValueTuple`3<UnusedValuePreference, bool, bool>, ImmutableDictionary`2<string, string>> s_propertiesMap;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    protected AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer(Option2`1<CodeStyleOption2`1<UnusedValuePreference>> unusedValueExpressionStatementOption, Option2`1<CodeStyleOption2`1<UnusedValuePreference>> unusedValueAssignmentOption);
    private static AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual Location GetDefinitionLocationToFade(IOperation unusedDefinition);
    protected abstract virtual bool SupportsDiscard(SyntaxTree tree);
    protected abstract virtual bool MethodHasHandlesClause(IMethodSymbol method);
    protected abstract virtual bool IsIfConditionalDirective(SyntaxNode node);
    protected abstract virtual bool ReturnsThrow(SyntaxNode node);
    protected abstract virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueExpressionStatementOption(AnalyzerOptionsProvider provider);
    protected abstract virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueAssignmentOption(AnalyzerOptionsProvider provider);
    protected virtual bool ShouldBailOutFromRemovableAssignmentAnalysis(IOperation unusedSymbolWriteOperation);
    protected abstract virtual bool IsCallStatement(IExpressionStatementOperation expressionStatement);
    protected abstract virtual bool IsExpressionOfExpressionBody(IExpressionStatementOperation expressionStatement);
    private static ImmutableDictionary`2<ValueTuple`3<UnusedValuePreference, bool, bool>, ImmutableDictionary`2<string, string>> CreatePropertiesMap();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private bool TryGetOptions(SyntaxTree syntaxTree, AnalyzerOptions analyzerOptions, CompilationOptions compilationOptions, CancellationToken cancellationToken, Options& options);
    public static bool ShouldReportUnusedParameters(ISymbol symbol, UnusedParametersPreference unusedParametersPreference, ReportDiagnostic unusedParametersSeverity);
    public static bool TryGetUnusedValuePreference(Diagnostic diagnostic, UnusedValuePreference& preference);
    public static bool GetIsUnusedLocalDiagnostic(Diagnostic diagnostic);
    public static bool GetIsRemovableAssignmentDiagnostic(Diagnostic diagnostic);
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntries|21_0(UnusedValuePreference preference, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntries2|21_1(UnusedValuePreference preference, bool isUnusedLocalAssignment, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static void <CreatePropertiesMap>g__AddEntryCore|21_2(UnusedValuePreference preference, bool isUnusedLocalAssignment, bool isRemovableAssignment, <>c__DisplayClass21_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__25_0(CompilationStartAnalysisContext compilationContext);
    [CompilerGeneratedAttribute]
private ValueTuple`2<UnusedValuePreference, NotificationOption2> <TryGetOptions>g__GetPreferenceAndSeverity|26_0(CodeStyleOption2`1<UnusedValuePreference> option, <>c__DisplayClass26_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11 : SyntaxEditorBasedCodeFixProvider {
    private static SyntaxAnnotation s_memberAnnotation;
    private static SyntaxAnnotation s_newLocalDeclarationStatementAnnotation;
    private static SyntaxAnnotation s_unusedLocalDeclarationAnnotation;
    private static SyntaxAnnotation s_existingLocalDeclarationWithoutInitializerAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static AbstractRemoveUnusedValuesCodeFixProvider`11();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual ISyntaxFormatting GetSyntaxFormatting();
    protected abstract virtual SyntaxNode TryUpdateNameForFlaggedNode(SyntaxNode node, SyntaxToken newName);
    protected abstract virtual SyntaxToken GetForEachStatementIdentifier(TForEachStatementSyntax node);
    protected abstract virtual TBlockSyntax WrapWithBlockIfNecessary(IEnumerable`1<TStatementSyntax> statements);
    protected abstract virtual void InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(TSwitchCaseBlockSyntax switchCaseBlock, SyntaxEditor editor, TLocalDeclarationStatementSyntax declarationStatement);
    protected abstract virtual SyntaxNode GetReplacementNodeForCompoundAssignment(SyntaxNode originalCompoundAssignment, SyntaxNode newAssignmentTarget, SyntaxEditor editor, ISyntaxFactsService syntaxFacts);
    protected abstract virtual SyntaxNode GetReplacementNodeForVarPattern(SyntaxNode originalVarPattern, SyntaxNode newNameNode);
    protected virtual SyntaxNode TryUpdateParentOfUpdatedNode(SyntaxNode parent, SyntaxNode newNameNode, SyntaxEditor editor, ISyntaxFacts syntaxFacts, SemanticModel semanticModel);
    protected abstract virtual SyntaxNode ComputeReplacementNode(SyntaxNode originalOldNode, SyntaxNode changedOldNode, SyntaxNode proposedReplacementNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<RegisterCodeFixesAsync>d__15")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool IsForEachIterationVariableDiagnostic(Diagnostic diagnostic, Document document, CancellationToken cancellationToken);
    private static string GetEquivalenceKey(UnusedValuePreference preference, bool isRemovableAssignment);
    private static string GetEquivalenceKey(Diagnostic diagnostic);
    private static bool NeedsToMoveNewLocalDeclarationsNearReference(string diagnosticId);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    private static IEnumerable`1<IGrouping`2<SyntaxNode, Diagnostic>> GetDiagnosticsGroupedByMember(ImmutableArray`1<Diagnostic> diagnostics, ISyntaxFactsService syntaxFacts, SyntaxNode root, String& diagnosticId, UnusedValuePreference& preference, Boolean& removeAssignments);
    private static IEnumerable`1<IGrouping`2<SyntaxNode, Diagnostic>> GetDiagnosticsGroupedByMember(ImmutableArray`1<Diagnostic> diagnostics, ISyntaxFactsService syntaxFacts, SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PreprocessDocumentAsync>d__23")]
private static Task`1<Document> PreprocessDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllAsync>d__24")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<GetNewRootAsync>d__25")]
private Task`1<SyntaxNode> GetNewRootAsync(Document document, SyntaxFormattingOptions options, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllAsync>d__26")]
private Task FixAllAsync(string diagnosticId, IEnumerable`1<Diagnostic> diagnostics, Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode containingMemberDeclaration, UnusedValuePreference preference, bool removeAssignments, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor, CancellationToken cancellationToken);
    private static void FixAllExpressionValueIsUnusedDiagnostics(IOrderedEnumerable`1<Diagnostic> diagnostics, Document document, SemanticModel semanticModel, SyntaxNode root, UnusedValuePreference preference, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<FixAllValueAssignedIsUnusedDiagnosticsAsync>d__28")]
private Task FixAllValueAssignedIsUnusedDiagnosticsAsync(IOrderedEnumerable`1<Diagnostic> diagnostics, Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode containingMemberDeclaration, UnusedValuePreference preference, bool removeAssignments, UniqueVariableNameGenerator<TExpressionSyntax, TStatementSyntax, TBlockSyntax, TExpressionStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, TForEachStatementSyntax, TSwitchCaseBlockSyntax, TSwitchCaseLabelOrClauseSyntax, TCatchStatementSyntax, TCatchBlockSyntax> nameGenerator, SyntaxEditor editor, CancellationToken cancellationToken);
    protected abstract virtual TLocalDeclarationStatementSyntax GetCandidateLocalDeclarationForRemoval(TVariableDeclaratorSyntax declarator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PostProcessDocumentAsync>d__30")]
private Task`1<SyntaxNode> PostProcessDocumentAsync(Document document, SyntaxFormattingOptions options, SyntaxNode currentRoot, string diagnosticId, UnusedValuePreference preference, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<PostProcessDocumentCoreAsync>d__31")]
private static Task`1<SyntaxNode> PostProcessDocumentCoreAsync(Func`5<SyntaxNode, Document, SyntaxFormattingOptions, CancellationToken, Task`1<SyntaxNode>> processMemberDeclarationAsync, SyntaxNode currentRoot, Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<ReplaceDiscardDeclarationsWithAssignmentsAsync>d__32")]
private Task`1<SyntaxNode> ReplaceDiscardDeclarationsWithAssignmentsAsync(SyntaxNode memberDeclaration, Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<AdjustLocalDeclarationsAsync>d__33")]
private Task`1<SyntaxNode> AdjustLocalDeclarationsAsync(SyntaxNode memberDeclaration, Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedParametersAndValues.AbstractRemoveUnusedValuesCodeFixProvider`11/<IsLocalDeclarationWithNoReferencesAsync>d__34")]
private static Task`1<bool> IsLocalDeclarationWithNoReferencesAsync(TLocalDeclarationStatementSyntax declStatement, Document document, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.RemoveUnusedVariable.AbstractRemoveUnusedVariableCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    protected abstract virtual bool IsCatchDeclarationIdentifier(SyntaxToken token);
    protected abstract virtual SyntaxNode GetNodeToRemoveOrReplace(SyntaxNode node);
    protected abstract virtual void RemoveOrReplaceNode(SyntaxEditor editor, SyntaxNode node, IBlockFactsService blockFacts);
    protected abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetVariables(TLocalDeclarationStatement localDeclarationStatement);
    protected abstract virtual bool ShouldOfferFixForLocalDeclaration(IBlockFactsService blockFacts, SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedVariable.AbstractRemoveUnusedVariableCodeFixProvider`3/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnusedVariable.AbstractRemoveUnusedVariableCodeFixProvider`3/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor syntaxEditor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected static void RemoveNode(SyntaxEditor editor, SyntaxNode node, IBlockFactsService blockFacts);
    private static SyntaxRemoveOptions CreateSyntaxRemoveOptions(TLocalDeclarationStatement localDeclaration, IBlockFactsService blockFacts);
    private void MergeNodesToRemove(HashSet`1<SyntaxNode> nodesToRemove);
}
internal interface Microsoft.CodeAnalysis.Rename.IRenameIssuesService {
    [NullableContextAttribute("1")]
public abstract virtual bool CheckLanguageSpecificIssues(SemanticModel semantic, ISymbol symbol, SyntaxToken triggerToken, String& langError);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Rename.SymbolicRenameInfo : object {
    [NullableAttribute("1")]
private static string AttributeSuffix;
    [CompilerGeneratedAttribute]
private string <LocalizedErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <TriggerToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TriggerText>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceRenameOverloads>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentSpan> <DocumentSpans>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRenamingAttributePrefix>k__BackingField;
    [MemberNotNullWhenAttribute("True", "LocalizedErrorMessage")]
[MemberNotNullWhenAttribute("False", "Document")]
[MemberNotNullWhenAttribute("False", "TriggerText")]
[MemberNotNullWhenAttribute("False", "Symbol")]
public bool IsError { get; }
    public string LocalizedErrorMessage { get; }
    public Document Document { get; }
    public SyntaxToken TriggerToken { get; }
    public string TriggerText { get; }
    public ISymbol Symbol { get; }
    public bool ForceRenameOverloads { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<DocumentSpan> DocumentSpans { get; }
    public bool IsRenamingAttributePrefix { get; }
    [NullableContextAttribute("1")]
private SymbolicRenameInfo(string localizedErrorMessage);
    [NullableContextAttribute("1")]
private SymbolicRenameInfo(Document document, SyntaxToken triggerToken, string triggerText, ISymbol symbol, bool forceRenameOverloads, ImmutableArray`1<DocumentSpan> documentSpans);
    [MemberNotNullWhenAttribute("True", "LocalizedErrorMessage")]
[MemberNotNullWhenAttribute("False", "Document")]
[MemberNotNullWhenAttribute("False", "TriggerText")]
[MemberNotNullWhenAttribute("False", "Symbol")]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public string get_LocalizedErrorMessage();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public SyntaxToken get_TriggerToken();
    [CompilerGeneratedAttribute]
public string get_TriggerText();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public bool get_ForceRenameOverloads();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentSpan> get_DocumentSpans();
    [CompilerGeneratedAttribute]
public bool get_IsRenamingAttributePrefix();
    [NullableContextAttribute("1")]
private bool CanRenameAttributePrefix(string triggerText);
    [NullableContextAttribute("1")]
public string GetWithoutAttributeSuffix(string value);
    [NullableContextAttribute("1")]
private bool HasAttributeSuffix(string value);
    [NullableContextAttribute("1")]
public string GetFinalSymbolName(string replacementText);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SymbolicRenameInfo/<GetRenameInfoAsync>d__33")]
public static Task`1<SymbolicRenameInfo> GetRenameInfoAsync(Document document, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SymbolicRenameInfo/<GetTriggerTokenAsync>d__34")]
private static Task`1<SyntaxToken> GetTriggerTokenAsync(Document document, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SymbolicRenameInfo/<GetRenameInfoAsync>d__35")]
private static Task`1<SymbolicRenameInfo> GetRenameInfoAsync(Document document, SyntaxToken triggerToken, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <CanRenameAttributePrefix>g__IsRenamingAttributeTypeWithAttributeSuffix|29_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ReplaceConditionalWithStatements.AbstractReplaceConditionalWithStatementsCodeRefactoringProvider`9 : CodeRefactoringProvider {
    protected abstract virtual bool HasSingleVariable(TLocalDeclarationStatementSyntax localDeclarationStatement, TVariableSyntax& variable);
    protected abstract virtual bool CanRewriteLocalDeclarationStatement(TLocalDeclarationStatementSyntax localDeclarationStatement);
    protected abstract virtual TLocalDeclarationStatementSyntax GetUpdatedLocalDeclarationStatement(SyntaxGenerator generator, TLocalDeclarationStatementSyntax localDeclarationStatement, ILocalSymbol symbol);
    private static bool IsSupportedSimpleStatement(ISyntaxFacts syntaxFacts, TStatementSyntax statement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceConditionalWithStatements.AbstractReplaceConditionalWithStatementsCodeRefactoringProvider`9/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [NullableContextAttribute("2")]
private static TConditionalExpressionSyntax TryFindConditional(SyntaxNode top, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private void TryHandleConditionalExpression(CodeRefactoringContext context, TConditionalExpressionSyntax conditionalExpression);
    private static TExpressionSyntax GetTopExpression(TConditionalExpressionSyntax conditionalExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceConditionalWithStatements.AbstractReplaceConditionalWithStatementsCodeRefactoringProvider`9/<ReplaceConditionalExpressionInSingleStatementAsync>d__8")]
private static Task`1<Document> ReplaceConditionalExpressionInSingleStatementAsync(Document document, TConditionalExpressionSyntax conditionalExpression, TStatementSyntax statement, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceConditionalWithStatements.AbstractReplaceConditionalWithStatementsCodeRefactoringProvider`9/<ReplaceConditionalExpressionInLocalDeclarationStatementAsync>d__9")]
private Task`1<Document> ReplaceConditionalExpressionInLocalDeclarationStatementAsync(Document document, TConditionalExpressionSyntax conditionalExpression, TVariableSyntax variable, TLocalDeclarationStatementSyntax localDeclarationStatement, CancellationToken cancellationToken);
    private static TStatementSyntax ConvertToIfStatement(SemanticModel semanticModel, SyntaxGenerator generator, SyntaxNode container, TConditionalExpressionSyntax conditionalExpression, Func`2<SyntaxNode, SyntaxNode> wrapConvertedSyntax, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <ConvertToIfStatement>g__Rewrite|10_0(TExpressionSyntax expression, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static SyntaxNode <ConvertToIfStatement>g__TryConvert|10_1(SyntaxNode expression, ITypeSymbol conditionalType, <>c__DisplayClass10_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ReplaceDocCommentTextWithTag.AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider : CodeRefactoringProvider {
    protected abstract virtual bool IsInXMLAttribute(SyntaxToken token);
    protected abstract virtual bool IsKeyword(string text);
    protected abstract virtual bool IsXmlTextToken(SyntaxToken token);
    protected abstract virtual SyntaxNode ParseExpression(string text);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceDocCommentTextWithTag.AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private bool TryRegisterSeeCrefTagIfSymbol(CodeRefactoringContext context, SemanticModel semanticModel, SyntaxToken token, TextSpan replacementSpan, CancellationToken cancellationToken);
    private static ISymbol GetEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static void RegisterRefactoring(CodeRefactoringContext context, TextSpan expandedSpan, string replacement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceDocCommentTextWithTag.AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider/<ReplaceTextAsync>d__8")]
private static Task`1<Document> ReplaceTextAsync(Document document, TextSpan span, string replacement, CancellationToken cancellationToken);
    private static TextSpan ExpandSpan(SourceText sourceText, TextSpan span, bool fullyQualifiedName);
    private static bool ShouldExpandSpanForwardOneCharacter(SourceText sourceText, int endExclusive, bool fullyQualifiedName);
    private static bool ShouldExpandSpanBackwardOneCharacter(SourceText sourceText, int startInclusive, bool fullyQualifiedName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ReplaceMethodWithProperty.AbstractReplaceMethodWithPropertyService`1 : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.AbstractReplaceMethodWithPropertyService`1/<GetMethodDeclarationAsync>d__0")]
public Task`1<SyntaxNode> GetMethodDeclarationAsync(CodeRefactoringContext context);
    [NullableContextAttribute("2")]
protected static string GetWarning(GetAndSetMethods getAndSetMethods);
    private static bool OverridesMetadataSymbol(IMethodSymbol method);
    protected static TPropertyDeclaration SetLeadingTrivia(ISyntaxFacts syntaxFacts, GetAndSetMethods getAndSetMethods, TPropertyDeclaration property);
    private static void AddParamListTriviaIfNeeded(ISyntaxFacts syntaxFacts, SyntaxNode methodDeclaration, List`1<SyntaxTrivia> finalLeadingTrivia);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ReplaceMethodWithProperty.GetAndSetMethods : ValueType {
    public IMethodSymbol GetMethod;
    public IMethodSymbol SetMethod;
    public SyntaxNode GetMethodDeclaration;
    public SyntaxNode SetMethodDeclaration;
    public GetAndSetMethods(IMethodSymbol getMethod, IMethodSymbol setMethod, SyntaxNode getMethodDeclaration, SyntaxNode setMethodDeclaration);
}
internal interface Microsoft.CodeAnalysis.ReplaceMethodWithProperty.IReplaceMethodWithPropertyService {
    public abstract virtual Task`1<SyntaxNode> GetMethodDeclarationAsync(CodeRefactoringContext context);
    public abstract virtual void ReplaceGetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public abstract virtual void ReplaceSetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public abstract virtual void ReplaceGetMethodWithProperty(CodeGenerationOptions options, ParseOptions parseOptions, SyntaxEditor editor, SemanticModel semanticModel, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged, CancellationToken cancellationToken);
    public abstract virtual void RemoveSetMethod(SyntaxEditor editor, SyntaxNode setMethodDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider : CodeRefactoringProvider {
    private static string GetPrefix;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool HasGetPrefix(string text);
    private static bool HasPrefix(string text, string prefix);
    private static IMethodSymbol FindSetMethod(IMethodSymbol getMethod);
    private static bool IsValidGetMethod(IMethodSymbol getMethod);
    private static bool OverridesMethodFromSystemObject(IMethodSymbol method);
    private static bool IsValidSetMethod(IMethodSymbol setMethod, IMethodSymbol getMethod);
    private static bool IsValidSetMethod(IMethodSymbol setMethod);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<ReplaceMethodsWithPropertyAsync>d__10")]
private static Task`1<Solution> ReplaceMethodsWithPropertyAsync(Document document, string propertyName, bool nameChanged, IMethodSymbol getMethod, IMethodSymbol setMethod, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<UpdateReferencesAsync>d__11")]
private static Task`1<Solution> UpdateReferencesAsync(Solution updatedSolution, string propertyName, bool nameChanged, ILookup`2<Document, ReferenceLocation> getReferencesByDocument, ILookup`2<Document, ReferenceLocation> setReferencesByDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<UpdateReferencesInDocumentAsync>d__12")]
private static Task`1<Solution> UpdateReferencesInDocumentAsync(string propertyName, bool nameChanged, Solution updatedSolution, Document originalDocument, IEnumerable`1<ReferenceLocation> getReferences, IEnumerable`1<ReferenceLocation> setReferences, CancellationToken cancellationToken);
    private static void ReplaceGetReferences(string propertyName, bool nameChanged, IEnumerable`1<ReferenceLocation> getReferences, SyntaxNode root, SyntaxEditor editor, IReplaceMethodWithPropertyService service, CancellationToken cancellationToken);
    private static void ReplaceSetReferences(string propertyName, bool nameChanged, IEnumerable`1<ReferenceLocation> setReferences, SyntaxNode root, SyntaxEditor editor, IReplaceMethodWithPropertyService service, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<ReplaceGetMethodsAndRemoveSetMethodsAsync>d__15")]
private static Task`1<Solution> ReplaceGetMethodsAndRemoveSetMethodsAsync(Solution originalSolution, Solution updatedSolution, string propertyName, bool nameChanged, IEnumerable`1<ReferencedSymbol> getMethodReferences, IEnumerable`1<ReferencedSymbol> setMethodReferences, bool updateSetMethod, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<ReplaceGetMethodsAndRemoveSetMethodsAsync>d__16")]
private static Task`1<Solution> ReplaceGetMethodsAndRemoveSetMethodsAsync(string propertyName, bool nameChanged, Solution updatedSolution, DocumentId documentId, ValueSet<DocumentId, IMethodSymbol> originalGetDefinitions, ValueSet<DocumentId, IMethodSymbol> originalSetDefinitions, bool updateSetMethod, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<GetGetSetPairsAsync>d__17")]
private static Task`1<ImmutableArray`1<GetAndSetMethods>> GetGetSetPairsAsync(Solution updatedSolution, Compilation compilation, DocumentId documentId, ValueSet<DocumentId, IMethodSymbol> originalDefinitions, bool updateSetMethod, CancellationToken cancellationToken);
    private static TSymbol GetSymbolInCurrentCompilation(Compilation compilation, TSymbol originalDefinition, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<GetMethodDeclarationAsync>d__19")]
private static Task`1<SyntaxNode> GetMethodDeclarationAsync(IMethodSymbol method, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.ReplaceMethodWithPropertyCodeRefactoringProvider/<GetDefinitionsByDocumentIdAsync>d__20")]
private static Task`1<MultiDictionary`2<DocumentId, IMethodSymbol>> GetDefinitionsByDocumentIdAsync(Solution originalSolution, IEnumerable`1<ReferencedSymbol> referencedSymbols, CancellationToken cancellationToken);
    private static string GetDefinitionIssues(IEnumerable`1<ReferencedSymbol> getMethodReferences);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ReplacePropertyWithMethods.AbstractReplacePropertyWithMethodsService`5 : object {
    public abstract virtual SyntaxNode GetPropertyNodeToReplace(SyntaxNode propertyDeclaration);
    public abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetReplacementMembersAsync(Document document, IPropertySymbol property, SyntaxNode propertyDeclaration, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual TCrefSyntax TryGetCrefSyntax(TIdentifierNameSyntax identifierName);
    protected abstract virtual TCrefSyntax CreateCrefSyntax(TCrefSyntax originalCref, SyntaxToken identifierToken, SyntaxNode parameterType);
    protected abstract virtual TExpressionSyntax UnwrapCompoundAssignment(SyntaxNode compoundAssignment, TExpressionSyntax readExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.AbstractReplacePropertyWithMethodsService`5/<GetPropertyDeclarationAsync>d__5")]
public sealed virtual Task`1<SyntaxNode> GetPropertyDeclarationAsync(CodeRefactoringContext context);
    protected static SyntaxNode GetFieldReference(SyntaxGenerator generator, IFieldSymbol propertyBackingField);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.AbstractReplacePropertyWithMethodsService`5/<ReplaceReferenceAsync>d__7")]
public sealed virtual Task ReplaceReferenceAsync(Document document, SyntaxEditor editor, SyntaxNode identifierName, IPropertySymbol property, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ReplacePropertyWithMethods.IReplacePropertyWithMethodsService {
    public abstract virtual Task`1<SyntaxNode> GetPropertyDeclarationAsync(CodeRefactoringContext context);
    public abstract virtual Task ReplaceReferenceAsync(Document document, SyntaxEditor editor, SyntaxNode identifierName, IPropertySymbol property, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetReplacementMembersAsync(Document document, IPropertySymbol property, SyntaxNode propertyDeclaration, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode GetPropertyNodeToReplace(SyntaxNode propertyDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider : CodeRefactoringProvider {
    private static string GetPrefix;
    private static string SetPrefix;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ReplacePropertyWithMethodsAsync>d__4")]
private Task`1<Solution> ReplacePropertyWithMethodsAsync(Document document, IPropertySymbol propertySymbol, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ImmutableDictionary`2<IPropertySymbol, IFieldSymbol> CreateDefinitionToBackingFieldMap(IEnumerable`1<ReferencedSymbol> propertyReferences);
    private static bool HasAnyMatchingGetOrSetMethods(IPropertySymbol property, string name);
    private static bool HasAnyMatchingGetMethods(IPropertySymbol property, string name);
    private static bool HasAnyMatchingSetMethods(IPropertySymbol property, string name);
    private static IFieldSymbol GetBackingField(IPropertySymbol property);
    private static string GetDefinitionIssues(IEnumerable`1<ReferencedSymbol> getMethodReferences);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<UpdateReferencesAsync>d__11")]
private Task`1<Solution> UpdateReferencesAsync(Solution updatedSolution, ILookup`2<Document, ValueTuple`2<IPropertySymbol, ReferenceLocation>> referencesByDocument, ImmutableDictionary`2<IPropertySymbol, IFieldSymbol> propertyToBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<UpdateReferencesInDocumentAsync>d__12")]
private Task`1<Solution> UpdateReferencesInDocumentAsync(Solution updatedSolution, Document originalDocument, IEnumerable`1<ValueTuple`2<IPropertySymbol, ReferenceLocation>> references, ImmutableDictionary`2<IPropertySymbol, IFieldSymbol> propertyToBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ReplaceReferencesAsync>d__13")]
private Task ReplaceReferencesAsync(Document originalDocument, IEnumerable`1<ValueTuple`2<IPropertySymbol, ReferenceLocation>> references, IDictionary`2<IPropertySymbol, IFieldSymbol> propertyToBackingField, SyntaxNode root, SyntaxEditor editor, IReplacePropertyWithMethodsService service, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ReplaceDefinitionsWithMethodsAsync>d__14")]
private static Task`1<Solution> ReplaceDefinitionsWithMethodsAsync(Solution originalSolution, Solution updatedSolution, IEnumerable`1<ReferencedSymbol> references, ImmutableDictionary`2<IPropertySymbol, IFieldSymbol> definitionToBackingField, string desiredGetMethodName, string desiredSetMethodName, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<GetDefinitionsByDocumentIdAsync>d__15")]
private static Task`1<MultiDictionary`2<DocumentId, IPropertySymbol>> GetDefinitionsByDocumentIdAsync(Solution originalSolution, IEnumerable`1<ReferencedSymbol> referencedSymbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<ReplaceDefinitionsWithMethodsAsync>d__16")]
private static Task`1<Solution> ReplaceDefinitionsWithMethodsAsync(Solution updatedSolution, DocumentId documentId, ValueSet<DocumentId, IPropertySymbol> originalDefinitions, IDictionary`2<IPropertySymbol, IFieldSymbol> definitionToBackingField, string desiredGetMethodName, string desiredSetMethodName, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<GetCurrentPropertiesAsync>d__17")]
private static Task`1<ImmutableArray`1<ValueTuple`2<IPropertySymbol, SyntaxNode>>> GetCurrentPropertiesAsync(Solution updatedSolution, Compilation compilation, DocumentId documentId, ValueSet<DocumentId, IPropertySymbol> originalDefinitions, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.ReplacePropertyWithMethodsCodeRefactoringProvider/<GetPropertyDeclarationAsync>d__18")]
private static Task`1<SyntaxNode> GetPropertyDeclarationAsync(IPropertySymbol property, CancellationToken cancellationToken);
    private static TSymbol GetSymbolInCurrentCompilation(Compilation compilation, TSymbol originalDefinition, CancellationToken cancellationToken);
    public sealed virtual bool Equals(ValueTuple`2<IPropertySymbol, ReferenceLocation> x, ValueTuple`2<IPropertySymbol, ReferenceLocation> y);
    public sealed virtual int GetHashCode(ValueTuple`2<IPropertySymbol, ReferenceLocation> obj);
}
internal static class Microsoft.CodeAnalysis.RoslynAssemblyHelper : object {
    public static bool HasRoslynPublicKey(object source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SemanticSearch.AbstractSemanticSearchService : object {
    private static FindReferencesSearchOptions s_findReferencesSearchOptions;
    private static int StackDisplayDepthLimit;
    private static AbstractSemanticSearchService();
    protected abstract virtual Compilation CreateCompilation(SourceText query, IEnumerable`1<MetadataReference> references, SolutionServices services, SyntaxTree& queryTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticSearch.AbstractSemanticSearchService/<ExecuteQueryAsync>d__4")]
public sealed virtual Task`1<ExecuteQueryResult> ExecuteQueryAsync(Solution solution, string query, string referenceAssembliesDir, ISemanticSearchResultsObserver observer, OptionsProvider`1<ClassificationOptions> classificationOptions, TraceSource traceSource, CancellationToken cancellationToken);
    private static ImmutableArray`1<TaggedText> GetExceptionTypeTaggedText(Exception e, Compilation compilation);
    private static void FormatStackTrace(Exception e, Assembly queryAssembly, LinePosition& position, ImmutableArray`1& formattedTrace);
    private static string GetStackTraceText(IEnumerable`1<StackFrame> frames);
    [NullableContextAttribute("2")]
private static bool TryGetFindMethod(Assembly queryAssembly, MethodInfo& method, String& error, String[]& errorMessageArgs);
    [NullableContextAttribute("2")]
private static MethodInfo GetFindMethod(Type type, bool allowLocalFunction, String& error);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SemanticSearch.ExecuteQueryResult : ValueType {
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <ErrorMessageArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <EmitTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ExecutionTime>k__BackingField;
    [DataMemberAttribute]
public string ErrorMessage { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public String[] ErrorMessageArgs { get; public set; }
    [DataMemberAttribute]
public TimeSpan EmitTime { get; public set; }
    [DataMemberAttribute]
public TimeSpan ExecutionTime { get; public set; }
    public ExecuteQueryResult(string ErrorMessage, String[] ErrorMessageArgs, TimeSpan EmitTime, TimeSpan ExecutionTime);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public String[] get_ErrorMessageArgs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ErrorMessageArgs(String[] value);
    [CompilerGeneratedAttribute]
public TimeSpan get_EmitTime();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EmitTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ExecutionTime();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExecutionTime(TimeSpan value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ExecuteQueryResult left, ExecuteQueryResult right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ExecuteQueryResult left, ExecuteQueryResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExecuteQueryResult other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& ErrorMessage, String[]& ErrorMessageArgs, TimeSpan& EmitTime, TimeSpan& ExecutionTime);
}
internal interface Microsoft.CodeAnalysis.SemanticSearch.IRemoteSemanticSearchService {
    [NullableContextAttribute("1")]
public abstract virtual ValueTask`1<ExecuteQueryResult> ExecuteQueryAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, string language, string query, string referenceAssembliesDir, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SemanticSearch.ISemanticSearchResultsObserver {
    public abstract virtual ValueTask OnUserCodeExceptionAsync(UserCodeExceptionInfo exception, CancellationToken cancellationToken);
    public abstract virtual ValueTask OnCompilationFailureAsync(ImmutableArray`1<QueryCompilationError> errors, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual ValueTask OnDefinitionFoundAsync(DefinitionItem definition, CancellationToken cancellationToken);
    public abstract virtual ValueTask AddItemsAsync(int itemCount, CancellationToken cancellationToken);
    public abstract virtual ValueTask ItemsCompletedAsync(int itemCount, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SemanticSearch.ISemanticSearchService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ExecuteQueryResult> ExecuteQueryAsync(Solution solution, string query, string referenceAssembliesDir, ISemanticSearchResultsObserver observer, OptionsProvider`1<ClassificationOptions> classificationOptions, TraceSource traceSource, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SemanticSearch.ISemanticSearchWorkspaceHost {
    public SemanticSearchWorkspace Workspace { get; }
    public abstract virtual SemanticSearchWorkspace get_Workspace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SemanticSearch.QueryCompilationError : ValueType {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [DataMemberAttribute]
public string Id { get; public set; }
    [DataMemberAttribute]
public string Message { get; public set; }
    [DataMemberAttribute]
public TextSpan Span { get; public set; }
    public QueryCompilationError(string Id, string Message, TextSpan Span);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Span(TextSpan value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(QueryCompilationError left, QueryCompilationError right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(QueryCompilationError left, QueryCompilationError right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(QueryCompilationError other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& Message, TextSpan& Span);
}
internal static class Microsoft.CodeAnalysis.SemanticSearch.RemoteSemanticSearchServiceProxy : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticSearch.RemoteSemanticSearchServiceProxy/<ExecuteQueryAsync>d__2")]
public static ValueTask`1<ExecuteQueryResult> ExecuteQueryAsync(Solution solution, string language, string query, string referenceAssembliesDir, ISemanticSearchResultsObserver results, OptionsProvider`1<ClassificationOptions> classificationOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SemanticSearch.SearchCompilationFailureDefinitionItem : DefinitionItem {
    internal bool IsExternal { get; }
    public SearchCompilationFailureDefinitionItem(QueryCompilationError error, Document queryDocument);
    internal virtual bool get_IsExternal();
    public virtual Task`1<INavigableLocation> GetNavigableLocationAsync(Workspace workspace, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.SemanticSearch.SearchExceptionDefinitionItem : DefinitionItem {
    internal bool IsExternal { get; }
    public SearchExceptionDefinitionItem(string message, ImmutableArray`1<TaggedText> exceptionTypeName, ImmutableArray`1<TaggedText> stackTrace, DocumentSpan documentSpan);
    internal virtual bool get_IsExternal();
    [NullableContextAttribute("1")]
public virtual Task`1<INavigableLocation> GetNavigableLocationAsync(Workspace workspace, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Shared.IDocumentSupportsFeatureService", "SemanticSearch")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchDocumentSupportsFeatureService : object {
    public sealed virtual bool SupportsCodeFixes(Document document);
    public sealed virtual bool SupportsRefactorings(Document document);
    public sealed virtual bool SupportsRename(Document document);
    public sealed virtual bool SupportsNavigationToAnyPosition(Document document);
    public sealed virtual bool SupportsSemanticSnippets(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
internal class Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchProjectConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlobalUsings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EditorConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseOptions <ParseOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [RequiredMemberAttribute]
public string Language { get; public set; }
    [RequiredMemberAttribute]
public string Query { get; public set; }
    [RequiredMemberAttribute]
public string GlobalUsings { get; public set; }
    [RequiredMemberAttribute]
public string EditorConfig { get; public set; }
    [RequiredMemberAttribute]
public ParseOptions ParseOptions { get; public set; }
    [RequiredMemberAttribute]
public CompilationOptions CompilationOptions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Query(string value);
    [CompilerGeneratedAttribute]
public string get_GlobalUsings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GlobalUsings(string value);
    [CompilerGeneratedAttribute]
public string get_EditorConfig();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EditorConfig(string value);
    [CompilerGeneratedAttribute]
public ParseOptions get_ParseOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParseOptions(ParseOptions value);
    [CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CompilationOptions(CompilationOptions value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchUtilities : object {
    public static string ReferenceAssemblyDirectoryName;
    public static string GlobalUsingsDocumentName;
    public static string ConfigDocumentName;
    public static string FindMethodName;
    public static string QueryProjectName;
    public static string QueryDocumentName;
    private static string s_thisAssemblyDirectory;
    public static string ReferenceAssembliesDirectory;
    private static SemanticSearchUtilities();
    public static List`1<MetadataReference> GetMetadataReferences(IMetadataService metadataService, string directory);
    public static string GetDocumentFilePath(string language);
    public static string GetConfigDocumentFilePath();
    public static SourceText CreateSourceText(string query);
    public static Document GetQueryDocument(Solution solution);
    public static ProjectId GetQueryProjectId(Solution solution);
    public static Project GetQueryProject(Solution solution);
    public static DocumentId GetQueryDocumentId(Solution solution);
    public static bool IsQueryDocument(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchWorkspace : Workspace {
    [CompilerGeneratedAttribute]
private SemanticSearchProjectConfiguration <config>P;
    public bool CanOpenDocuments { get; }
    protected SemanticSearchWorkspace(HostServices services, SemanticSearchProjectConfiguration config);
    public virtual bool get_CanOpenDocuments();
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticSearch.SemanticSearchWorkspace/<UpdateQueryDocumentAsync>d__5")]
public Task`1<Document> UpdateQueryDocumentAsync(string query, CancellationToken cancellationToken);
    protected virtual void ApplyQueryDocumentTextChanged(SourceText newText);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SemanticSearch.UserCodeExceptionInfo : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ProjectDisplayName>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <StackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [NullableAttribute("1")]
[DataMemberAttribute]
public string ProjectDisplayName { get; public set; }
    [NullableAttribute("1")]
[DataMemberAttribute]
public string Message { get; public set; }
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> TypeName { get; public set; }
    [DataMemberAttribute]
public ImmutableArray`1<TaggedText> StackTrace { get; public set; }
    [DataMemberAttribute]
public TextSpan Span { get; public set; }
    public UserCodeExceptionInfo(string ProjectDisplayName, string Message, ImmutableArray`1<TaggedText> TypeName, ImmutableArray`1<TaggedText> StackTrace, TextSpan Span);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_ProjectDisplayName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProjectDisplayName(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_TypeName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeName(ImmutableArray`1<TaggedText> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_StackTrace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_StackTrace(ImmutableArray`1<TaggedText> value);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Span(TextSpan value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UserCodeExceptionInfo left, UserCodeExceptionInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UserCodeExceptionInfo left, UserCodeExceptionInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UserCodeExceptionInfo other);
    [CompilerGeneratedAttribute]
public void Deconstruct(String& ProjectDisplayName, String& Message, ImmutableArray`1& TypeName, ImmutableArray`1& StackTrace, TextSpan& Span);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Shared.IDocumentSupportsFeatureService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Shared.DefaultDocumentSupportsFeatureService : object {
    public sealed virtual bool SupportsCodeFixes(Document document);
    public sealed virtual bool SupportsNavigationToAnyPosition(Document document);
    public sealed virtual bool SupportsRefactorings(Document document);
    public sealed virtual bool SupportsRename(Document document);
    public sealed virtual bool SupportsSemanticSnippets(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<ReplaceNodeAsync>d__0`1")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceNodeAsync(Document document, TNode oldNode, TNode newNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Document ReplaceNodeSynchronously(Document document, TNode oldNode, TNode newNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Document ReplaceNode(Document document, SyntaxNode root, TNode oldNode, TNode newNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<ReplaceNodesAsync>d__3")]
[ExtensionAttribute]
public static Task`1<Document> ReplaceNodesAsync(Document document, IEnumerable`1<SyntaxNode> nodes, Func`3<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetUnionItemsFromDocumentAndLinkedDocumentsAsync>d__4`1")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<T>> GetUnionItemsFromDocumentAndLinkedDocumentsAsync(Document document, IEqualityComparer`1<T> comparer, Func`2<Document, Task`1<ImmutableArray`1<T>>> getItemsWorker);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<IsValidContextForDocumentOrLinkedDocumentsAsync>d__5")]
[ExtensionAttribute]
public static Task`1<bool> IsValidContextForDocumentOrLinkedDocumentsAsync(Document document, Func`3<Document, CancellationToken, Task`1<bool>> contextChecker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetNamingRulesAsync>d__6")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<NamingRule>> GetNamingRulesAsync(Document document, NamingStylePreferencesProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetApplicableNamingRuleAsync>d__7")]
[ExtensionAttribute]
public static Task`1<NamingRule> GetApplicableNamingRuleAsync(Document document, ISymbol symbol, NamingStylePreferencesProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetApplicableNamingRuleAsync>d__8")]
[ExtensionAttribute]
public static Task`1<NamingRule> GetApplicableNamingRuleAsync(Document document, SymbolKind symbolKind, Accessibility accessibility, NamingStylePreferencesProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetApplicableNamingRuleAsync>d__9")]
[ExtensionAttribute]
public static Task`1<NamingRule> GetApplicableNamingRuleAsync(Document document, SymbolKindOrTypeKind kind, DeclarationModifiers modifiers, Nullable`1<Accessibility> accessibility, NamingStylePreferencesProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions2 : object {
    [NullableAttribute("1")]
public static SymbolDisplayFormat CrefFormat;
    private static ISymbolExtensions2();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Glyph GetGlyph(ISymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TaggedText> GetDocumentationParts(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static DocumentationComment GetAppropriateDocumentationComment(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static DocumentationComment GetParameterDocumentation(IParameterSymbol parameter, Compilation compilation, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Func`2<CancellationToken, IEnumerable`1<TaggedText>> GetDocumentationPartsFactory(ISymbol symbol, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static DocumentationComment GetMethodDocumentation(IMethodSymbol method, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
[ObsoleteAttribute("Use overload without ISymbolDisplayService")]
public static ImmutableArray`1<TSymbol> Sort(ImmutableArray`1<TSymbol> symbols, ISymbolDisplayService symbolDisplayService, SemanticModel semanticModel, int position);
    [ExtensionAttribute]
public static ImmutableArray`1<TSymbol> Sort(ImmutableArray`1<TSymbol> symbols, SemanticModel semanticModel, int position);
    private static INamedTypeSymbol GetNamedType(ITypeSymbol type);
    private static int CompareParameters(ImmutableArray`1<IParameterSymbol> xParameters, String[] xTypeNames, ImmutableArray`1<IParameterSymbol> yParameters, String[] yTypeNames);
    private static int CompareProperties(IPropertySymbol xProperty, String[] xTypeNames, IPropertySymbol yProperty, String[] yTypeNames);
    private static int CompareMethods(IMethodSymbol xMethod, String[] xTypeNames, IMethodSymbol yMethod, String[] yTypeNames);
    private static int CompareEvents(IEventSymbol xEvent, String[] xTypeNames, IEventSymbol yEvent, String[] yTypeNames);
    private static int CompareNamedTypes(INamedTypeSymbol xNamedType, INamedTypeSymbol yNamedType);
    private static String[] GetParameterTypeNames(ISymbol symbol, SemanticModel semanticModel, int position);
    private static ImmutableArray`1<IParameterSymbol> GetMethodOrIndexerOrEventParameters(ISymbol symbol);
    private static int Compare(TSymbol s1, TSymbol s2, ConcurrentDictionary`2<TSymbol, String[]> symbolToParameterTypeNames, Func`2<TSymbol, String[]> getParameterTypeNames);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions : object {
    [ExtensionAttribute]
public static Glyph GetGlyph(Project project);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenListExtensions : object {
    [ExtensionAttribute]
internal static string GetValueText(SyntaxTokenList tokens);
}
internal interface Microsoft.CodeAnalysis.Shared.IDocumentSupportsFeatureService {
    public abstract virtual bool SupportsCodeFixes(Document document);
    public abstract virtual bool SupportsRefactorings(Document document);
    public abstract virtual bool SupportsRename(Document document);
    public abstract virtual bool SupportsNavigationToAnyPosition(Document document);
    public abstract virtual bool SupportsSemanticSnippets(Document document);
}
internal static class Microsoft.CodeAnalysis.Shared.Naming.FallbackNamingRules : object {
    public static ImmutableArray`1<NamingRule> Default;
    internal static ImmutableArray`1<NamingRule> CompletionFallbackRules;
    internal static ImmutableArray`1<NamingRule> CompletionSupplementaryRules;
    private static FallbackNamingRules();
    private static NamingRule CreateGetAsyncRule();
    private static NamingRule CreateCamelCaseFieldsAndParametersRule();
    private static NamingRule CreateEndWithAsyncRule();
    private static NamingRule CreateMethodStartsWithGetRule();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Naming.IdentifierNameParts : ValueType {
    public string BaseName;
    public ImmutableArray`1<string> BaseNameParts;
    public IdentifierNameParts(string baseName, ImmutableArray`1<string> baseNameParts);
    public static IdentifierNameParts CreateIdentifierNameParts(ISymbol symbol, ImmutableArray`1<NamingRule> rules);
    private static string RemovePrefixesAndSuffixes(ISymbol symbol, ImmutableArray`1<NamingRule> rules, string baseName);
    private static ImmutableArray`1<string> CreateWords(TemporaryArray`1& parts, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping : object {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ISymbol, SyntaxAnnotation> <SymbolToDeclarationAnnotationMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <AnnotatedSolution>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<DocumentId, ImmutableArray`1<ISymbol>> <DocumentIdsToSymbolMap>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxAnnotation <TypeNodeAnnotation>k__BackingField;
    public ImmutableDictionary`2<ISymbol, SyntaxAnnotation> SymbolToDeclarationAnnotationMap { get; }
    public Solution AnnotatedSolution { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<ISymbol>> DocumentIdsToSymbolMap { get; }
    public SyntaxAnnotation TypeNodeAnnotation { get; }
    public AnnotatedSymbolMapping(ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationAnnotationMap, Solution annotatedSolution, ImmutableDictionary`2<DocumentId, ImmutableArray`1<ISymbol>> documentIdsToSymbolMap, SyntaxAnnotation typeNodeAnnotation);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<ISymbol, SyntaxAnnotation> get_SymbolToDeclarationAnnotationMap();
    [CompilerGeneratedAttribute]
public Solution get_AnnotatedSolution();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<ISymbol>> get_DocumentIdsToSymbolMap();
    [CompilerGeneratedAttribute]
public SyntaxAnnotation get_TypeNodeAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.AnnotatedSymbolMapping/<CreateAsync>d__13")]
public static Task`1<AnnotatedSymbolMapping> CreateAsync(IEnumerable`1<ISymbol> symbols, Solution solution, SyntaxNode typeNode, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Utilities.DeserializationConstructorCheck : ValueType {
    private INamedTypeSymbol _iSerializableType;
    private INamedTypeSymbol _serializationInfoType;
    private INamedTypeSymbol _streamingContextType;
    [NullableContextAttribute("1")]
public DeserializationConstructorCheck(Compilation compilation);
    [NullableContextAttribute("1")]
public bool IsDeserializationConstructor(IMethodSymbol methodSymbol);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.ExtractTypeHelpers : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.ExtractTypeHelpers/<AddTypeToExistingFileAsync>d__0")]
public static Task`1<ValueTuple`2<Document, SyntaxAnnotation>> AddTypeToExistingFileAsync(Document document, INamedTypeSymbol newType, AnnotatedSymbolMapping symbolMapping, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.ExtractTypeHelpers/<AddTypeToNewFileAsync>d__1")]
public static Task`1<ValueTuple`2<Document, SyntaxAnnotation>> AddTypeToNewFileAsync(Solution solution, string containingNamespaceDisplay, string fileName, ProjectId projectId, IEnumerable`1<string> folders, INamedTypeSymbol newSymbol, Document hintDocument, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public static string GetTypeParameterSuffix(Document document, SyntaxFormattingOptions formattingOptions, INamedTypeSymbol type, IEnumerable`1<ISymbol> extractableMembers, CancellationToken cancellationToken);
    public static ImmutableArray`1<ITypeParameterSymbol> GetRequiredTypeParametersForMembers(INamedTypeSymbol type, IEnumerable`1<ISymbol> includedMembers);
    private static ImmutableArray`1<ITypeParameterSymbol> GetPotentialTypeParameters(INamedTypeSymbol type);
    private static ImmutableArray`1<ITypeParameterSymbol> GetDirectlyReferencedTypeParameters(IEnumerable`1<ITypeParameterSymbol> potentialTypeParameters, IEnumerable`1<ISymbol> includedMembers);
    private static bool DoesMemberReferenceTypeParameter(ISymbol member, ITypeParameterSymbol typeParameter, HashSet`1<ITypeSymbol> checkedTypes);
    private static bool DoesTypeReferenceTypeParameter(ITypeSymbol type, ITypeParameterSymbol typeParameter, HashSet`1<ITypeSymbol> checkedTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Utilities.HashCodeAnalyzer : ValueType {
    private Compilation _compilation;
    private IMethodSymbol _objectGetHashCodeMethod;
    [NullableAttribute("2")]
private INamedTypeSymbol _equalityComparerType;
    public INamedTypeSymbol SystemHashCodeType;
    private HashCodeAnalyzer(Compilation compilation, IMethodSymbol objectGetHashCodeMethod, INamedTypeSymbol equalityComparerType, INamedTypeSymbol systemHashCodeType);
    public static bool TryGetAnalyzer(Compilation compilation, HashCodeAnalyzer& analyzer);
    [NullableContextAttribute("2")]
public ValueTuple`3<bool, ImmutableArray`1<ISymbol>, ImmutableArray`1<IOperation>> GetHashedMembers(ISymbol owningSymbol, IOperation operation);
    private Nullable`1<ValueTuple`2<bool, ImmutableArray`1<ISymbol>>> MatchTuplePattern(IMethodSymbol method, ImmutableArray`1<IOperation> statements);
    private Nullable`1<ValueTuple`2<bool, ImmutableArray`1<ISymbol>>> MatchAccumulatorPattern(IMethodSymbol method, ImmutableArray`1<IOperation> statements);
    [NullableContextAttribute("2")]
private bool OverridesSystemObject(IMethodSymbol method);
    private static bool IsLocalReference(IOperation value, ILocalSymbol accumulatorVariable);
    private static bool IsLiteralNumber(IOperation value);
    private static IOperation Unwrap(IOperation value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.LinkedFilesSymbolEquivalenceComparer : object {
    public static LinkedFilesSymbolEquivalenceComparer Instance;
    private static LinkedFilesSymbolEquivalenceComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ISymbol x, ISymbol y);
    public sealed virtual int GetHashCode(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SupportedPlatformData : object {
    public List`1<ProjectId> InvalidProjects;
    public IEnumerable`1<ProjectId> CandidateProjects;
    public Solution Solution;
    public SupportedPlatformData(Solution solution, List`1<ProjectId> invalidProjects, IEnumerable`1<ProjectId> candidateProjects);
    public IList`1<SymbolDisplayPart> ToDisplayParts();
    private static string Supported(bool supported);
    public bool HasValidAndInvalidProjects();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider : object {
    protected static SymbolDisplayFormat MinimallyQualifiedWithoutParametersFormat;
    protected static SymbolDisplayFormat MinimallyQualifiedWithoutTypeParametersFormat;
    private static AbstractSignatureHelpProvider();
    public abstract virtual bool IsTriggerCharacter(char ch);
    public abstract virtual bool IsRetriggerCharacter(char ch);
    protected abstract virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    protected static SignatureHelpItems CreateSignatureHelpItems(IList`1<SignatureHelpItem> items, TextSpan applicableSpan, Nullable`1<SignatureHelpState> state, Nullable`1<int> selectedItemIndex, int parameterIndexOverride);
    protected static SignatureHelpItems CreateCollectionInitializerSignatureHelpItems(IList`1<SignatureHelpItem> items, TextSpan applicableSpan, Nullable`1<SignatureHelpState> state);
    private static ValueTuple`2<IList`1<SignatureHelpItem>, Nullable`1<int>> Filter(IList`1<SignatureHelpItem> items, ImmutableArray`1<string> parameterNames, Nullable`1<int> selectedItem);
    private static bool Include(SignatureHelpItem item, ImmutableArray`1<string> parameterNames);
    [ObsoleteAttribute("Use overload without ISymbolDisplayService")]
protected SignatureHelpItem CreateItem(ISymbol orderSymbol, SemanticModel semanticModel, int position, ISymbolDisplayService symbolDisplayService, IStructuralTypeDisplayService structuralTypeDisplayService, bool isVariadic, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IList`1<SymbolDisplayPart> prefixParts, IList`1<SymbolDisplayPart> separatorParts, IList`1<SymbolDisplayPart> suffixParts, IList`1<SignatureHelpSymbolParameter> parameters, IList`1<SymbolDisplayPart> descriptionParts);
    protected static SignatureHelpItem CreateItem(ISymbol orderSymbol, SemanticModel semanticModel, int position, IStructuralTypeDisplayService structuralTypeDisplayService, bool isVariadic, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IList`1<SymbolDisplayPart> prefixParts, IList`1<SymbolDisplayPart> separatorParts, IList`1<SymbolDisplayPart> suffixParts, IList`1<SignatureHelpSymbolParameter> parameters, IList`1<SymbolDisplayPart> descriptionParts);
    protected static SignatureHelpItem CreateItemImpl(ISymbol orderSymbol, SemanticModel semanticModel, int position, IStructuralTypeDisplayService structuralTypeDisplayService, bool isVariadic, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IList`1<SymbolDisplayPart> prefixParts, IList`1<SymbolDisplayPart> separatorParts, IList`1<SymbolDisplayPart> suffixParts, IList`1<SignatureHelpSymbolParameter> parameters, IList`1<SymbolDisplayPart> descriptionParts);
    private static SignatureHelpSymbolParameter ReplaceStructuralTypes(SignatureHelpSymbolParameter parameter, StructuralTypeDisplayInfo info, SemanticModel semanticModel, int position);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider/<GetItemsAsync>d__14")]
public sealed virtual Task`1<SignatureHelpItems> GetItemsAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.AbstractSignatureHelpProvider/<FindActiveRelatedDocumentsAsync>d__15")]
private static Task`1<ImmutableArray`1<Document>> FindActiveRelatedDocumentsAsync(int position, Document document, CancellationToken cancellationToken);
    private static SignatureHelpItem UpdateItem(SignatureHelpItem item, SupportedPlatformData platformData);
    protected static Nullable`1<int> TryGetSelectedIndex(ImmutableArray`1<TSymbol> candidates, ISymbol currentSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SignatureHelp.CommonSignatureHelpUtilities : object {
    internal static Nullable`1<SignatureHelpState> GetSignatureHelpState(TArgumentList argumentList, int position, Func`2<TArgumentList, SyntaxToken> getOpenToken, Func`2<TArgumentList, SyntaxToken> getCloseToken, Func`2<TArgumentList, SyntaxNodeOrTokenList> getArgumentsWithSeparators, Func`2<TArgumentList, IEnumerable`1<string>> getArgumentNames);
    private static bool TryGetCurrentArgumentIndex(TArgumentList argumentList, int position, Func`2<TArgumentList, SyntaxToken> getOpenToken, Func`2<TArgumentList, SyntaxToken> getCloseToken, Func`2<TArgumentList, SyntaxNodeOrTokenList> getArgumentsWithSeparators, Int32& index);
    internal static TextSpan GetSignatureHelpSpan(TArgumentList argumentList, Func`2<TArgumentList, SyntaxToken> getCloseToken);
    internal static TextSpan GetSignatureHelpSpan(TArgumentList argumentList, int start, Func`2<TArgumentList, SyntaxToken> getCloseToken);
    internal static bool TryGetSyntax(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, Func`2<SyntaxToken, bool> isTriggerToken, Func`3<TSyntax, SyntaxToken, bool> isArgumentListToken, CancellationToken cancellationToken, TSyntax& expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.CommonSignatureHelpUtilities/<GetCollectionInitializerAddMethodsAsync>d__5")]
public static Task`1<ImmutableArray`1<IMethodSymbol>> GetCollectionInitializerAddMethodsAsync(Document document, SyntaxNode initializer, SignatureHelpOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.SignatureHelp.ExportSignatureHelpProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public ExportSignatureHelpProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SignatureHelp.ISignatureHelpProvider {
    public abstract virtual bool IsTriggerCharacter(char ch);
    public abstract virtual bool IsRetriggerCharacter(char ch);
    public abstract virtual Task`1<SignatureHelpItems> GetItemsAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItem : object {
    [CompilerGeneratedAttribute]
private bool <IsVariadic>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <PrefixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <SuffixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <SeparatorDisplayParts>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SignatureHelpParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TaggedText> <DescriptionParts>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Func`2<CancellationToken, IEnumerable`1<TaggedText>> <DocumentationFactory>k__BackingField;
    [NullableAttribute("1")]
private static Func`2<CancellationToken, IEnumerable`1<TaggedText>> s_emptyDocumentationFactory;
    public bool IsVariadic { get; }
    public ImmutableArray`1<TaggedText> PrefixDisplayParts { get; }
    public ImmutableArray`1<TaggedText> SuffixDisplayParts { get; }
    public ImmutableArray`1<TaggedText> SeparatorDisplayParts { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<SignatureHelpParameter> Parameters { get; }
    public ImmutableArray`1<TaggedText> DescriptionParts { get; internal set; }
    [NullableAttribute("1")]
public Func`2<CancellationToken, IEnumerable`1<TaggedText>> DocumentationFactory { get; }
    [NullableContextAttribute("1")]
public SignatureHelpItem(bool isVariadic, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IEnumerable`1<TaggedText> prefixParts, IEnumerable`1<TaggedText> separatorParts, IEnumerable`1<TaggedText> suffixParts, IEnumerable`1<SignatureHelpParameter> parameters, IEnumerable`1<TaggedText> descriptionParts);
    [NullableContextAttribute("1")]
public SignatureHelpItem(bool isVariadic, Func`2<CancellationToken, IEnumerable`1<SymbolDisplayPart>> documentationFactory, IEnumerable`1<SymbolDisplayPart> prefixParts, IEnumerable`1<SymbolDisplayPart> separatorParts, IEnumerable`1<SymbolDisplayPart> suffixParts, IEnumerable`1<SignatureHelpParameter> parameters, IEnumerable`1<SymbolDisplayPart> descriptionParts);
    private static SignatureHelpItem();
    [CompilerGeneratedAttribute]
public bool get_IsVariadic();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_PrefixDisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_SuffixDisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_SeparatorDisplayParts();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SignatureHelpParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaggedText> get_DescriptionParts();
    [CompilerGeneratedAttribute]
internal void set_DescriptionParts(ImmutableArray`1<TaggedText> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Func`2<CancellationToken, IEnumerable`1<TaggedText>> get_DocumentationFactory();
    [NullableContextAttribute("1")]
internal IEnumerable`1<TaggedText> GetAllParts();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpItems : object {
    [CompilerGeneratedAttribute]
private IList`1<SignatureHelpItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <ApplicableSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgumentCount>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ArgumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SelectedItemIndex>k__BackingField;
    public IList`1<SignatureHelpItem> Items { get; }
    public TextSpan ApplicableSpan { get; }
    public int ArgumentIndex { get; }
    public int ArgumentCount { get; }
    [NullableAttribute("2")]
public string ArgumentName { get; }
    public Nullable`1<int> SelectedItemIndex { get; }
    public SignatureHelpItems(IList`1<SignatureHelpItem> items, TextSpan applicableSpan, int argumentIndex, int argumentCount, string argumentName, Nullable`1<int> selectedItem);
    [CompilerGeneratedAttribute]
public IList`1<SignatureHelpItem> get_Items();
    [CompilerGeneratedAttribute]
public TextSpan get_ApplicableSpan();
    [CompilerGeneratedAttribute]
public int get_ArgumentIndex();
    [CompilerGeneratedAttribute]
public int get_ArgumentCount();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ArgumentName();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SelectedItemIndex();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <HideAdvancedMembers>k__BackingField;
    public static SignatureHelpOptions Default;
    [DataMemberAttribute]
public bool HideAdvancedMembers { get; public set; }
    private static SignatureHelpOptions();
    [CompilerGeneratedAttribute]
public bool get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HideAdvancedMembers(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SignatureHelpOptions left, SignatureHelpOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SignatureHelpOptions left, SignatureHelpOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SignatureHelpOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, IEnumerable`1<TaggedText>> <DocumentationFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TaggedText> <PrefixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TaggedText> <SuffixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TaggedText> <DisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TaggedText> <SelectedDisplayParts>k__BackingField;
    private static Func`2<CancellationToken, IEnumerable`1<TaggedText>> s_emptyDocumentationFactory;
    public string Name { get; }
    public Func`2<CancellationToken, IEnumerable`1<TaggedText>> DocumentationFactory { get; }
    public IList`1<TaggedText> PrefixDisplayParts { get; }
    public IList`1<TaggedText> SuffixDisplayParts { get; }
    public IList`1<TaggedText> DisplayParts { get; }
    public bool IsOptional { get; }
    public IList`1<TaggedText> SelectedDisplayParts { get; }
    [NullableContextAttribute("2")]
public SignatureHelpParameter(string name, bool isOptional, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IEnumerable`1<TaggedText> displayParts, IEnumerable`1<TaggedText> prefixDisplayParts, IEnumerable`1<TaggedText> suffixDisplayParts, IEnumerable`1<TaggedText> selectedDisplayParts);
    [NullableContextAttribute("2")]
public SignatureHelpParameter(string name, bool isOptional, Func`2<CancellationToken, IEnumerable`1<SymbolDisplayPart>> documentationFactory, IEnumerable`1<SymbolDisplayPart> displayParts, IEnumerable`1<SymbolDisplayPart> prefixDisplayParts, IEnumerable`1<SymbolDisplayPart> suffixDisplayParts, IEnumerable`1<SymbolDisplayPart> selectedDisplayParts);
    private static SignatureHelpParameter();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, IEnumerable`1<TaggedText>> get_DocumentationFactory();
    [CompilerGeneratedAttribute]
public IList`1<TaggedText> get_PrefixDisplayParts();
    [CompilerGeneratedAttribute]
public IList`1<TaggedText> get_SuffixDisplayParts();
    [CompilerGeneratedAttribute]
public IList`1<TaggedText> get_DisplayParts();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public IList`1<TaggedText> get_SelectedDisplayParts();
    internal IEnumerable`1<TaggedText> GetAllParts();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, ImmutableArray`1<ISignatureHelpProvider>> _providersByLanguage;
    private IEnumerable`1<Lazy`2<ISignatureHelpProvider, OrderableLanguageMetadata>> _allProviders;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public SignatureHelpService(IEnumerable`1<Lazy`2<ISignatureHelpProvider, OrderableLanguageMetadata>> allProviders);
    private ImmutableArray`1<ISignatureHelpProvider> GetProviders(string language);
    public Task`1<ValueTuple`2<ISignatureHelpProvider, SignatureHelpItems>> GetSignatureHelpAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpService/<GetSignatureHelpAsync>d__5")]
public static Task`1<ValueTuple`2<ISignatureHelpProvider, SignatureHelpItems>> GetSignatureHelpAsync(ImmutableArray`1<ISignatureHelpProvider> providers, Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ISignatureHelpProvider> <GetProviders>b__3_0(string language);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpState : ValueType {
    public int ArgumentIndex;
    public int ArgumentCount;
    public string ArgumentName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> ArgumentNames;
    public SignatureHelpState(int argumentIndex, int argumentCount, string argumentName, ImmutableArray`1<string> argumentNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpSymbolParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, IEnumerable`1<TaggedText>> <DocumentationFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <PrefixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <SuffixDisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <DisplayParts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SymbolDisplayPart> <SelectedDisplayParts>k__BackingField;
    private static Func`2<CancellationToken, IEnumerable`1<TaggedText>> s_emptyDocumentationFactory;
    public string Name { get; }
    public Func`2<CancellationToken, IEnumerable`1<TaggedText>> DocumentationFactory { get; }
    public IList`1<SymbolDisplayPart> PrefixDisplayParts { get; }
    public IList`1<SymbolDisplayPart> SuffixDisplayParts { get; }
    public IList`1<SymbolDisplayPart> DisplayParts { get; }
    public bool IsOptional { get; }
    public IList`1<SymbolDisplayPart> SelectedDisplayParts { get; }
    [NullableContextAttribute("2")]
public SignatureHelpSymbolParameter(string name, bool isOptional, Func`2<CancellationToken, IEnumerable`1<TaggedText>> documentationFactory, IEnumerable`1<SymbolDisplayPart> displayParts, IEnumerable`1<SymbolDisplayPart> prefixDisplayParts, IEnumerable`1<SymbolDisplayPart> suffixDisplayParts, IEnumerable`1<SymbolDisplayPart> selectedDisplayParts);
    private static SignatureHelpSymbolParameter();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, IEnumerable`1<TaggedText>> get_DocumentationFactory();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_PrefixDisplayParts();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_SuffixDisplayParts();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_DisplayParts();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public IList`1<SymbolDisplayPart> get_SelectedDisplayParts();
    internal IEnumerable`1<SymbolDisplayPart> GetAllParts();
    public static SignatureHelpParameter op_Explicit(SignatureHelpSymbolParameter parameter);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerInfo : ValueType {
    [CompilerGeneratedAttribute]
private SignatureHelpTriggerReason <TriggerReason>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <TriggerCharacter>k__BackingField;
    public SignatureHelpTriggerReason TriggerReason { get; }
    public Nullable`1<char> TriggerCharacter { get; }
    internal SignatureHelpTriggerInfo(SignatureHelpTriggerReason triggerReason, Nullable`1<char> triggerCharacter);
    [CompilerGeneratedAttribute]
public SignatureHelpTriggerReason get_TriggerReason();
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_TriggerCharacter();
}
internal enum Microsoft.CodeAnalysis.SignatureHelp.SignatureHelpTriggerReason : Enum {
    public int value__;
    public static SignatureHelpTriggerReason InvokeSignatureHelpCommand;
    public static SignatureHelpTriggerReason TypeCharCommand;
    public static SignatureHelpTriggerReason RetriggerCommand;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyBooleanExpression.AbstractSimplifyConditionalDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_takeCondition;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_negateCondition;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_takeConditionOrWhenFalse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_negateConditionAndWhenFalse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_negateConditionOrWhenTrue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_takeConditionAndWhenTrue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_takeConditionAndWhenFalse;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractSimplifyConditionalDiagnosticAnalyzer`3();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual CommonConversion GetConversion(SemanticModel semanticModel, TExpressionSyntax node, CancellationToken cancellationToken);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeConditionalExpression(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <AnalyzeConditionalExpression>g__ReportDiagnostic|13_0(ImmutableDictionary`2<string, string> properties, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsSimpleBooleanType|13_1(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsTrue|13_2(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsFalse|13_3(TExpressionSyntax node, <>c__DisplayClass13_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeConditionalExpression>g__IsBoolValue|13_4(TExpressionSyntax node, bool value, <>c__DisplayClass13_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyBooleanExpressionConstants : object {
    public static string Negate;
    public static string Or;
    public static string And;
    public static string WhenTrue;
    public static string WhenFalse;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyConditionalCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyBooleanExpression.SimplifyConditionalCodeFixProvider/<FixAllAsync>d__5")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationCodeFixProvider`5 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    protected abstract virtual TInterpolationSyntax WithExpression(TInterpolationSyntax interpolation, TExpressionSyntax expression);
    protected abstract virtual TInterpolationSyntax WithAlignmentClause(TInterpolationSyntax interpolation, TInterpolationAlignmentClause alignmentClause);
    protected abstract virtual TInterpolationSyntax WithFormatClause(TInterpolationSyntax interpolation, TInterpolationFormatClause formatClause);
    protected abstract virtual string Escape(TInterpolatedStringExpressionSyntax interpolatedString, string formatString);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationCodeFixProvider`5/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private TInterpolationSyntax Update(SyntaxGeneratorInternal generator, TInterpolatedStringExpressionSyntax interpolatedString, TInterpolationSyntax interpolation, TExpressionSyntax unwrapped, TExpressionSyntax alignment, string formatString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationDiagnosticAnalyzer`2 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    protected abstract virtual IVirtualCharService GetVirtualCharService();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInterpolation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationHelpers : object {
    protected bool PermitNonLiteralAlignmentComponents { get; }
    protected abstract virtual bool get_PermitNonLiteralAlignmentComponents();
    protected abstract virtual SyntaxNode GetPreservedInterpolationExpressionSyntax(IOperation operation);
    public void UnwrapInterpolation(IVirtualCharService virtualCharService, ISyntaxFacts syntaxFacts, IInterpolationOperation interpolation, TExpressionSyntax& unwrapped, TExpressionSyntax& alignment, Boolean& negate, String& formatString, ImmutableArray`1& unnecessaryLocations);
    [NullableContextAttribute("2")]
private static IOperation Unwrap(IOperation expression, bool towardsParent);
    private void UnwrapFormatString(IVirtualCharService virtualCharService, ISyntaxFacts syntaxFacts, IOperation expression, IOperation& unwrapped, String& formatString, List`1<TextSpan> unnecessarySpans);
    private static bool IsObjectToStringOverride(IMethodSymbol method);
    private static bool UsesInvariantCultureReferenceInsideFormattableStringInvariant(IInvocationOperation invocation, int formatProviderArgumentIndex);
    private static bool IsInvariantCultureReference(IOperation operation);
    private static bool IsInsideFormattableStringInvariant(IOperation operation);
    private static bool IsType(INamedTypeSymbol type, SemanticModel semanticModel);
    [NullableContextAttribute("2")]
private static INamedTypeSymbol FindType(SemanticModel semanticModel);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyInterpolation.AbstractSimplifyInterpolationHelpers/<AncestorsAndSelf>d__12")]
private static IEnumerable`1<IOperation> AncestorsAndSelf(IOperation operation);
    private static TextSpan GetSpanWithinLiteralQuotes(IVirtualCharService virtualCharService, SyntaxToken formatToken);
    private void UnwrapAlignmentPadding(IOperation expression, IOperation& unwrapped, TExpressionSyntax& alignment, Boolean& negate, List`1<TextSpan> unnecessarySpans);
    private static bool HasNonImplicitInstance(IInvocationOperation invocation, IOperation& instance);
    private static bool IsSpaceChar(IArgumentOperation argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyLinqExpression.AbstractSimplifyLinqExpressionCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    protected ISyntaxFacts SyntaxFacts { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static TInvocationExpressionSyntax <FixAllAsync>g__GetInvocation|5_2(SyntaxNode root, Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyLinqExpression.AbstractSimplifyLinqExpressionDiagnosticAnalyzer`2 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static IImmutableSet`1<string> s_nonEnumerableReturningLinqMethodNames;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractSimplifyLinqExpressionDiagnosticAnalyzer`2();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual IInvocationOperation TryGetNextInvocationInChain(IInvocationOperation invocation);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    public void AnalyzeInvocationOperation(OperationAnalysisContext context, INamedTypeSymbol enumerableType, IMethodSymbol whereMethod, ImmutableArray`1<IMethodSymbol> linqMethods);
    [CompilerGeneratedAttribute]
internal static bool <OnCompilationStart>g__TryGetEnumerableTypeSymbol|7_1(Compilation compilation, INamedTypeSymbol& enumerableType);
    [CompilerGeneratedAttribute]
internal static bool <OnCompilationStart>g__TryGetLinqWhereExtensionMethod|7_2(INamedTypeSymbol enumerableType, IMethodSymbol& whereMethod);
    [CompilerGeneratedAttribute]
internal static bool <OnCompilationStart>g__TryGetLinqMethodsThatDoNotReturnEnumerables|7_3(INamedTypeSymbol enumerableType, ImmutableArray`1& linqMethods);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeInvocationOperation>g__IsWhereLinqMethod|8_1(IInvocationOperation invocation, <>c__DisplayClass8_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AnalyzeInvocationOperation>g__IsInvocationNonEnumerableReturningLinqMethod|8_2(IInvocationOperation invocation, <>c__DisplayClass8_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <AnalyzeInvocationOperation>g__TryGetSymbolOfMemberAccess|8_3(IInvocationOperation invocation, <>c__DisplayClass8_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <AnalyzeInvocationOperation>g__TryGetMethodName|8_4(IInvocationOperation invocation, <>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyThisOrMe.AbstractSimplifyThisOrMeCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual string GetTitle();
    protected abstract virtual SyntaxNode Rewrite(SyntaxNode root, ISet`1<TMemberAccessExpressionSyntax> memberAccessNodes);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyThisOrMe.AbstractSimplifyThisOrMeCodeFixProvider`1/<FixAllAsync>d__6")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyThisOrMe.AbstractSimplifyThisOrMeDiagnosticAnalyzer`4 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    protected ISyntaxKinds SyntaxKinds { get; }
    protected ISimplification Simplification { get; }
    protected AbstractMemberAccessExpressionSimplifier`3<TExpressionSyntax, TMemberAccessExpressionSyntax, TThisExpressionSyntax> Simplifier { get; }
    protected abstract virtual ISyntaxKinds get_SyntaxKinds();
    protected abstract virtual ISimplification get_Simplification();
    protected abstract virtual AbstractMemberAccessExpressionSimplifier`3<TExpressionSyntax, TMemberAccessExpressionSyntax, TThisExpressionSyntax> get_Simplifier();
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
}
internal abstract class Microsoft.CodeAnalysis.SimplifyTypeNames.AbstractSimplifyTypeNamesCodeFixProvider`2 : SyntaxEditorBasedCodeFixProvider {
    private SimplifyTypeNamesDiagnosticAnalyzerBase`2<TSyntaxKind, TSimplifierOptions> _analyzer;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected AbstractSimplifyTypeNamesCodeFixProvider`2(SimplifyTypeNamesDiagnosticAnalyzerBase`2<TSyntaxKind, TSimplifierOptions> analyzer);
    protected abstract virtual string GetTitle(string diagnosticId, string nodeText);
    protected abstract virtual SyntaxNode AddSimplificationAnnotationTo(SyntaxNode node);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    private ValueTuple`2<SyntaxNode, string> GetNodeToSimplify(SyntaxNode root, SemanticModel model, TextSpan span, TSimplifierOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyTypeNames.AbstractSimplifyTypeNamesCodeFixProvider`2/<RegisterCodeFixesAsync>d__8")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SimplifyTypeNames.AbstractSimplifyTypeNamesCodeFixProvider`2/<FixAllAsync>d__9")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private bool CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, TSimplifierOptions options, TextSpan span, String& diagnosticId, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <FixAllAsync>b__9_0(SyntaxNode current, SyntaxGenerator _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SimplifyTypeNames.SimplifyTypeNamesDiagnosticAnalyzerBase`2 : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    private static LocalizableString s_localizableMessage;
    private static LocalizableString s_localizableTitleSimplifyNames;
    private static DiagnosticDescriptor s_descriptorSimplifyNames;
    private static LocalizableString s_localizableTitleSimplifyMemberAccess;
    private static DiagnosticDescriptor s_descriptorSimplifyMemberAccess;
    private static DiagnosticDescriptor s_descriptorPreferBuiltinOrFrameworkType;
    private static SimplifyTypeNamesDiagnosticAnalyzerBase`2();
    internal abstract virtual bool IsCandidate(SyntaxNode node);
    internal abstract virtual bool CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, TSimplifierOptions options, TextSpan& issueSpan, String& diagnosticId, Boolean& inDeclaration, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    [NullableContextAttribute("0")]
protected static ImmutableArray`1<NotificationOption2> GetAllNotifications(SimplifierOptions options);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeCompilation(CompilationStartAnalysisContext context);
    protected abstract virtual bool IsIgnoredCodeBlock(SyntaxNode codeBlock);
    protected abstract virtual ImmutableArray`1<Diagnostic> AnalyzeCodeBlock(CodeBlockAnalysisContext context, SyntaxNode root);
    protected abstract virtual ImmutableArray`1<Diagnostic> AnalyzeSemanticModel(SemanticModelAnalysisContext context, SyntaxNode root, TextSpanMutableIntervalTree codeBlockIntervalTree);
    public bool TrySimplify(SemanticModel model, SyntaxNode node, Diagnostic& diagnostic, TSimplifierOptions options, AnalyzerOptions analyzerOptions, CancellationToken cancellationToken);
    internal static Diagnostic CreateDiagnostic(SemanticModel model, TSimplifierOptions options, AnalyzerOptions analyzerOptions, TextSpan issueSpan, string diagnosticId, bool inDeclaration);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SnippetFunctionService : object {
    public string SwitchCaseFormat { get; }
    public string SwitchDefaultCaseForm { get; }
    public abstract virtual string get_SwitchCaseFormat();
    public abstract virtual string get_SwitchDefaultCaseForm();
    public abstract virtual Task`1<string> GetContainingClassNameAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SnippetFunctionService/<GetSimplifiedTypeNameAsync>d__5")]
public static Task`1<string> GetSimplifiedTypeNameAsync(Document document, TextSpan fieldSpan, string fullyQualifiedTypeName, SimplifierOptions simplifierOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SnippetFunctionService/<GetSwitchExpansionAsync>d__6")]
public Task`1<string> GetSwitchExpansionAsync(Document document, TextSpan caseGenerationLocation, TextSpan switchExpressionLocation, SimplifierOptions simplifierOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static bool TryGetSnippetFunctionInfo(string xmlFunctionText, String& snippetFunctionName, String& param);
    protected abstract virtual Task`1<ITypeSymbol> GetEnumSymbolAsync(Document document, TextSpan switchExpressionSpan, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ValueTuple`2<Document, TextSpan>> GetDocumentWithEnumCaseAsync(Document document, string fullyQualifiedTypeName, string firstEnumMemberName, TextSpan caseGenerationLocation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SnippetFunctionService/<GetSimplifiedEnumNameAsync>d__10")]
private Task`1<string> GetSimplifiedEnumNameAsync(Document document, string fullyQualifiedTypeName, string firstEnumMemberName, TextSpan caseGenerationLocation, SimplifierOptions simplifierOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SnippetFunctionService/<GetSimplifiedTypeNameAtSpanAsync>d__11")]
private static Task`1<string> GetSimplifiedTypeNameAtSpanAsync(Document documentWithFullyQualifiedTypeName, TextSpan fullyQualifiedTypeSpan, SimplifierOptions simplifierOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.AbstractConsoleSnippetProvider`4 : AbstractSingleChangeSnippetProvider`1<TExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AdditionalFilterTexts>k__BackingField;
    public string Identifier { get; }
    public string Description { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AdditionalFilterTexts { get; }
    public sealed virtual string get_Identifier();
    public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_AdditionalFilterTexts();
    protected abstract virtual TArgumentListSyntax GetArgumentList(TExpressionSyntax expression);
    protected abstract virtual SyntaxToken GetOpenParenToken(TArgumentListSyntax argumentList);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractConsoleSnippetProvider`4/<GenerateSnippetTextChangeAsync>d__9")]
protected sealed virtual Task`1<TextChange> GenerateSnippetTextChangeAsync(Document document, int position, CancellationToken cancellationToken);
    protected sealed virtual int GetTargetCaretPosition(TExpressionSyntax caretTarget, SourceText sourceText);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractConsoleSnippetProvider`4/<AnnotateNodesToReformatAsync>d__11")]
protected sealed virtual Task`1<SyntaxNode> AnnotateNodesToReformatAsync(Document document, int position, CancellationToken cancellationToken);
    protected sealed virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(TExpressionSyntax node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected static INamedTypeSymbol GetConsoleSymbolFromMetaDataName(Compilation compilation);
    protected sealed virtual TExpressionSyntax FindAddedSnippetSyntaxNode(SyntaxNode root, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.AbstractForEachLoopSnippetProvider`1 : AbstractInlineStatementSnippetProvider`1<TStatementSyntax> {
    protected sealed virtual bool IsValidAccessingType(ITypeSymbol type, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.AbstractIfSnippetProvider`2 : AbstractConditionalBlockSnippetProvider`2<TIfStatementSyntax, TExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AdditionalFilterTexts>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AdditionalFilterTexts { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_AdditionalFilterTexts();
    protected sealed virtual TIfStatementSyntax GenerateStatement(SyntaxGenerator generator, SyntaxContext syntaxContext, InlineExpressionInfo inlineExpressionInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1 : object {
    protected SyntaxAnnotation FindSnippetAnnotation;
    public string Identifier { get; }
    public string Description { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AdditionalFilterTexts { get; }
    public abstract virtual string get_Identifier();
    public abstract virtual string get_Description();
    public virtual ImmutableArray`1<string> get_AdditionalFilterTexts();
    protected abstract virtual bool IsValidSnippetLocation(SnippetContext& modreq(System.Runtime.InteropServices.InAttribute) context, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ImmutableArray`1<TextChange>> GenerateSnippetTextChangesAsync(Document document, int position, CancellationToken cancellationToken);
    protected abstract virtual int GetTargetCaretPosition(TSnippetSyntax caretTarget, SourceText sourceText);
    protected abstract virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(TSnippetSyntax node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public sealed virtual ValueTask`1<Nullable`1<SnippetData>> GetSnippetDataAsync(SnippetContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1/<GetSnippetAsync>d__12")]
public sealed virtual Task`1<SnippetChange> GetSnippetAsync(Document document, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static SyntaxNode GenerateElasticTriviaForSyntax(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1/<CleanupDocumentAsync>d__14")]
private Task`1<Document> CleanupDocumentAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1/<GetDocumentWithSnippetAndTriviaAsync>d__15")]
private Task`1<Document> GetDocumentWithSnippetAndTriviaAsync(Document snippetDocument, int position, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1/<GetDocumentWithSnippetAsync>d__16")]
private static Task`1<Document> GetDocumentWithSnippetAsync(Document document, ImmutableArray`1<TextChange> snippets, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1/<AddFormatAnnotationAsync>d__17")]
private Task`1<Document> AddFormatAnnotationAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1/<AnnotateNodesToReformatAsync>d__18")]
protected virtual Task`1<SyntaxNode> AnnotateNodesToReformatAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual TSnippetSyntax FindAddedSnippetSyntaxNode(SyntaxNode root, int position);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractSnippetProvider`1/<AddIndentationToDocumentAsync>d__20")]
private Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, TSnippetSyntax snippet, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Snippets.AbstractSnippetService : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Lazy`2<ISnippetProvider, LanguageMetadata>> _lazySnippetProviders;
    private Dictionary`2<string, ISnippetProvider> _identifierToProviderMap;
    private object _snippetProvidersLock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISnippetProvider> _snippetProviders;
    protected AbstractSnippetService(IEnumerable`1<Lazy`2<ISnippetProvider, LanguageMetadata>> lazySnippetProviders);
    public sealed virtual ISnippetProvider GetSnippetProvider(string snippetIdentifier);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.AbstractSnippetService/<GetSnippetsAsync>d__6")]
public sealed virtual Task`1<ImmutableArray`1<SnippetData>> GetSnippetsAsync(SnippetContext context, CancellationToken cancellationToken);
    private ImmutableArray`1<ISnippetProvider> GetSnippetProviders(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Snippets.CommonSnippetIdentifiers : object {
    public static string ConsoleWriteLine;
    public static string Constructor;
    public static string Property;
    public static string GetOnlyProperty;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Snippets.ExportSnippetProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public ExportSnippetProviderAttribute(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Snippets.InlineExpressionInfo : object {
    [CompilerGeneratedAttribute]
private SyntaxNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInfo <TypeInfo>k__BackingField;
    public SyntaxNode Node { get; }
    public TypeInfo TypeInfo { get; }
    public InlineExpressionInfo(SyntaxNode node, TypeInfo typeInfo);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Node();
    [CompilerGeneratedAttribute]
public TypeInfo get_TypeInfo();
}
internal interface Microsoft.CodeAnalysis.Snippets.IRoslynLSPSnippetExpander {
    public abstract virtual bool CanExpandSnippet();
}
internal interface Microsoft.CodeAnalysis.Snippets.ISnippetInfoService {
    public abstract virtual IEnumerable`1<SnippetInfo> GetSnippetsIfAvailable();
    public abstract virtual bool SnippetShortcutExists_NonBlocking(string shortcut);
    public abstract virtual bool ShouldFormatSnippet(SnippetInfo snippetInfo);
}
internal interface Microsoft.CodeAnalysis.Snippets.ISnippetService {
    public abstract virtual Task`1<ImmutableArray`1<SnippetData>> GetSnippetsAsync(SnippetContext context, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual ISnippetProvider GetSnippetProvider(string snippetIdentifier);
}
internal static class Microsoft.CodeAnalysis.Snippets.RoslynLSPSnippetConverter : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.RoslynLSPSnippetConverter/<GenerateLSPSnippetAsync>d__0")]
public static Task`1<string> GenerateLSPSnippetAsync(Document document, int caretPosition, ImmutableArray`1<SnippetPlaceholder> placeholders, TextChange textChange, int triggerLocation, CancellationToken cancellationToken);
    private static string ConvertToLSPSnippetString(TextChange textChange, ImmutableArray`1<SnippetPlaceholder> placeholders, int caretPosition);
    private static void PopulateMapOfSpanStartsToLSPStringItem(Dictionary`2<int, ValueTuple`2<string, int>> dictionary, ImmutableArray`1<SnippetPlaceholder> placeholders, int textChangeStart);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.RoslynLSPSnippetConverter/<ExtendSnippetTextChangeAsync>d__3")]
private static Task`1<TextChange> ExtendSnippetTextChangeAsync(Document document, TextChange textChange, ImmutableArray`1<SnippetPlaceholder> placeholders, int caretPosition, int triggerLocation, CancellationToken cancellationToken);
    private static TextSpan GetUpdatedTextSpan(TextChange textChange, ImmutableArray`1<SnippetPlaceholder> placeholders, int caretPosition, int triggerLocation);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Snippets.SnippetChange : ValueType {
    public ImmutableArray`1<TextChange> TextChanges;
    public int CursorPosition;
    public ImmutableArray`1<SnippetPlaceholder> Placeholders;
    public SnippetChange(ImmutableArray`1<TextChange> textChanges, int cursorPosition, ImmutableArray`1<SnippetPlaceholder> placeholders);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Snippets.SnippetContext : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxContext <SyntaxContext>k__BackingField;
    public Document Document { get; }
    public int Position { get; }
    internal SyntaxContext SyntaxContext { get; }
    internal SnippetContext(SyntaxContext syntaxContext);
    public Document get_Document();
    public int get_Position();
    [CompilerGeneratedAttribute]
internal SyntaxContext get_SyntaxContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Snippets.SnippetData : ValueType {
    public string Description;
    public string Identifier;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AdditionalFilterTexts;
    public SnippetData(string description, string identifier, ImmutableArray`1<string> additionalFilterTexts);
}
internal class Microsoft.CodeAnalysis.Snippets.SnippetInfo : object {
    [CompilerGeneratedAttribute]
private string <Shortcut>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Shortcut { get; }
    public string Title { get; }
    public string Description { get; }
    public string Path { get; }
    public SnippetInfo(string shortcut, string title, string description, string path);
    [CompilerGeneratedAttribute]
public string get_Shortcut();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public string get_Path();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Snippets.SnippetPlaceholder : ValueType {
    [NullableAttribute("1")]
public string Identifier;
    public ImmutableArray`1<int> PlaceHolderPositions;
    public SnippetPlaceholder(string identifier, ImmutableArray`1<int> placeholderPositions);
    [NullableContextAttribute("1")]
public SnippetPlaceholder(string identifier, int placeholderPosition);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractConditionalBlockSnippetProvider`2 : AbstractInlineStatementSnippetProvider`1<TStatementSyntax> {
    protected abstract virtual TExpressionSyntax GetCondition(TStatementSyntax node);
    protected sealed virtual bool IsValidAccessingType(ITypeSymbol type, Compilation compilation);
    protected sealed virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(TStatementSyntax node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractConstructorSnippetProvider`1 : AbstractSingleChangeSnippetProvider`1<TConstructorDeclarationSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AdditionalFilterTexts>k__BackingField;
    public string Identifier { get; }
    public string Description { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AdditionalFilterTexts { get; }
    public sealed virtual string get_Identifier();
    public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_AdditionalFilterTexts();
    protected sealed virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(TConstructorDeclarationSyntax node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractElseSnippetProvider`1 : AbstractStatementSnippetProvider`1<TElseClauseSyntax> {
    protected sealed virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(TElseClauseSyntax node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractForLoopSnippetProvider`1 : AbstractInlineStatementSnippetProvider`1<TStatementSyntax> {
    protected sealed virtual bool IsValidAccessingType(ITypeSymbol type, Compilation compilation);
    protected static bool IsSuitableIntegerType(ITypeSymbol type);
    protected static IPropertySymbol FindLengthProperty(ITypeSymbol type, Compilation compilation);
    protected static IPropertySymbol FindCountProperty(ITypeSymbol type, Compilation compilation);
    private static IPropertySymbol FindAccessibleIntegerProperty(ITypeSymbol type, Compilation compilation, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractInlineStatementSnippetProvider`1 : AbstractStatementSnippetProvider`1<TStatementSyntax> {
    [CompilerGeneratedAttribute]
private bool <ConstructedFromInlineExpression>k__BackingField;
    protected bool ConstructedFromInlineExpression { get; private set; }
    protected abstract virtual bool IsValidAccessingType(ITypeSymbol type, Compilation compilation);
    protected abstract virtual TStatementSyntax GenerateStatement(SyntaxGenerator generator, SyntaxContext syntaxContext, InlineExpressionInfo inlineExpressionInfo);
    [CompilerGeneratedAttribute]
protected bool get_ConstructedFromInlineExpression();
    [CompilerGeneratedAttribute]
private void set_ConstructedFromInlineExpression(bool value);
    protected virtual bool IsValidSnippetLocation(SnippetContext& modreq(System.Runtime.InteropServices.InAttribute) context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractInlineStatementSnippetProvider`1/<GenerateSnippetTextChangeAsync>d__7")]
protected sealed virtual Task`1<TextChange> GenerateSnippetTextChangeAsync(Document document, int position, CancellationToken cancellationToken);
    protected sealed virtual TStatementSyntax FindAddedSnippetSyntaxNode(SyntaxNode root, int position);
    private static bool TryGetInlineExpressionInfo(SyntaxToken targetToken, ISyntaxFactsService syntaxFacts, SemanticModel semanticModel, InlineExpressionInfo& expressionInfo, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractLockSnippetProvider`1 : AbstractStatementSnippetProvider`1<TLockStatementSyntax> {
    protected sealed virtual Task`1<TextChange> GenerateSnippetTextChangeAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractMainMethodSnippetProvider`3 : AbstractSingleChangeSnippetProvider`1<TMethodDeclarationSyntax> {
    protected abstract virtual TTypeSyntax GenerateReturnType(SyntaxGenerator generator);
    protected abstract virtual IEnumerable`1<TStatementSyntax> GenerateInnerStatements(SyntaxGenerator generator);
    protected sealed virtual Task`1<TextChange> GenerateSnippetTextChangeAsync(Document document, int position, CancellationToken cancellationToken);
    protected sealed virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(TMethodDeclarationSyntax node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractPropertySnippetProvider`1 : AbstractSingleChangeSnippetProvider`1<TPropertyDeclarationSyntax> {
    protected abstract virtual Task`1<TPropertyDeclarationSyntax> GenerateSnippetSyntaxAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractPropertySnippetProvider`1/<GenerateSnippetTextChangeAsync>d__1")]
protected sealed virtual Task`1<TextChange> GenerateSnippetTextChangeAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractSingleChangeSnippetProvider`1 : AbstractSnippetProvider`1<TSnippetSyntax> {
    protected abstract virtual Task`1<TextChange> GenerateSnippetTextChangeAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractSingleChangeSnippetProvider`1/<GenerateSnippetTextChangesAsync>d__1")]
protected sealed virtual Task`1<ImmutableArray`1<TextChange>> GenerateSnippetTextChangesAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractStatementSnippetProvider`1 : AbstractSingleChangeSnippetProvider`1<TStatementSyntax> {
    protected virtual bool IsValidSnippetLocation(SnippetContext& modreq(System.Runtime.InteropServices.InAttribute) context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractTypeSnippetProvider`1 : AbstractSnippetProvider`1<TTypeDeclarationSyntax> {
    protected abstract virtual SyntaxToken GetTypeDeclarationIdentifier(TTypeDeclarationSyntax node);
    protected abstract virtual Task`1<TTypeDeclarationSyntax> GenerateTypeDeclarationAsync(Document document, int position, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Nullable`1<TextChange>> GetAccessibilityModifiersChangeAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractTypeSnippetProvider`1/<GenerateSnippetTextChangesAsync>d__3")]
protected sealed virtual Task`1<ImmutableArray`1<TextChange>> GenerateSnippetTextChangesAsync(Document document, int position, CancellationToken cancellationToken);
    protected sealed virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(TTypeDeclarationSyntax node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractTypeSnippetProvider`1/<AreAccessibilityModifiersRequiredAsync>d__5")]
protected static Task`1<bool> AreAccessibilityModifiersRequiredAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Snippets.SnippetProviders.AbstractWhileLoopSnippetProvider`2 : AbstractConditionalBlockSnippetProvider`2<TWhileStatementSyntax, TExpressionSyntax> {
    protected sealed virtual TWhileStatementSyntax GenerateStatement(SyntaxGenerator generator, SyntaxContext syntaxContext, InlineExpressionInfo inlineExpressionInfo);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Snippets.SnippetProviders.ISnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    public abstract virtual string get_Identifier();
    public abstract virtual string get_Description();
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<Nullable`1<SnippetData>> GetSnippetDataAsync(SnippetContext context, CancellationToken cancellationToken);
    public abstract virtual Task`1<SnippetChange> GetSnippetAsync(Document document, int position, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.SnippetUtilities : object {
    [NullableContextAttribute("1")]
public static bool TryGetWordOnLeft(int position, SourceText currentText, ISyntaxFactsService syntaxFactsService, Nullable`1& wordSpan);
}
internal abstract class Microsoft.CodeAnalysis.SolutionCrawler.AbstractDocumentDifferenceService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.AbstractDocumentDifferenceService/<GetChangedMemberAsync>d__0")]
public sealed virtual Task`1<SyntaxNode> GetChangedMemberAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static SyntaxNode GetChangedMember(ISyntaxFactsService syntaxFactsService, SyntaxNode oldRoot, SyntaxNode newRoot, TextChangeRange range);
    [NullableContextAttribute("1")]
private static SyntaxNode GetBestGuessChangedMember(ISyntaxFactsService syntaxFactsService, SyntaxNode oldRoot, SyntaxNode newRoot, TextChangeRange range);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SolutionCrawler.GlobalOperationAwareIdleProcessor : IdleProcessor {
    [NullableAttribute("2")]
private IGlobalOperationNotificationService _globalOperationNotificationService;
    public GlobalOperationAwareIdleProcessor(IAsynchronousOperationListener listener, IGlobalOperationNotificationService globalOperationNotificationService, TimeSpan backOffTimeSpan, CancellationToken shutdownToken);
    public virtual void Shutdown();
    private void OnGlobalOperationStarted(object sender, EventArgs e);
    private void OnGlobalOperationStopped(object sender, EventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SolutionCrawler.IdleProcessor : object {
    private static TimeSpan s_minimumDelay;
    private object _gate;
    protected IAsynchronousOperationListener Listener;
    protected CancellationToken CancellationToken;
    protected TimeSpan BackOffTimeSpan;
    [NullableAttribute("2")]
private Task _processorTask;
    private SharedStopwatch _timeSinceLastAccess;
    private bool _isPaused_doNotAccessDirectly;
    public Task AsyncProcessorTask { get; }
    protected IdleProcessor(IAsynchronousOperationListener listener, TimeSpan backOffTimeSpan, CancellationToken cancellationToken);
    private static IdleProcessor();
    protected abstract virtual Task WaitAsync(CancellationToken cancellationToken);
    protected abstract virtual Task ExecuteAsync();
    protected abstract virtual void OnPaused();
    protected void Start();
    protected void UpdateLastAccessTime();
    protected bool GetIsPaused();
    protected bool ShouldContinueToBackOff();
    protected void SetIsPaused(bool isPaused);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.IdleProcessor/<WaitForIdleAsync>d__17")]
protected Task`1<bool> WaitForIdleAsync(IExpeditableDelaySource expeditableDelaySource);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionCrawler.IdleProcessor/<ProcessAsync>d__18")]
private Task ProcessAsync();
    public virtual Task get_AsyncProcessorTask();
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IDocumentDifferenceService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<SyntaxNode> GetChangedMemberAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerOptionsService {
    public bool EnableDiagnosticsInSourceGeneratedFiles { get; }
    public abstract virtual bool get_EnableDiagnosticsInSourceGeneratedFiles();
}
[ObsoleteAttribute("Remove your implementation of this interface and let Roslyn know so that this interface can be removed.", "False")]
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IWorkCoordinatorPriorityService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<bool> IsLowPriorityAsync(Document document, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerRegistrationService : object {
    [NullableAttribute("1")]
internal static Option2`1<bool> EnableSolutionCrawler;
    private static SolutionCrawlerRegistrationService();
}
internal abstract class Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1 : CodeFixProvider {
    private static int MinTokenLength;
    private static Char[] s_punctuation;
    private static AbstractSpellCheckCodeFixProvider`1();
    public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual bool IsGeneric(SyntaxToken nameToken);
    protected abstract virtual bool IsGeneric(TSimpleName nameNode);
    protected abstract virtual bool IsGeneric(CompletionItem completionItem);
    protected abstract virtual SyntaxToken CreateIdentifier(SyntaxToken nameToken, string newName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<CheckNodeAsync>d__7")]
private Task CheckNodeAsync(CodeFixContext context, Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<CheckTokenAsync>d__8")]
private Task CheckTokenAsync(CodeFixContext context, Document document, SyntaxToken token, CancellationToken cancellationToken);
    protected abstract virtual bool ShouldSpellCheck(TSimpleName name);
    protected abstract virtual bool DescendIntoChildren(SyntaxNode arg);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<CreateSpellCheckCodeIssueAsync>d__11")]
private Task CreateSpellCheckCodeIssueAsync(CodeFixContext context, SyntaxToken nameToken, bool isGeneric, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<CheckItemsAsync>d__12")]
private Task CheckItemsAsync(CodeFixContext context, SyntaxToken nameToken, bool isGeneric, CompletionList completionList, WordSimilarityChecker similarityChecker);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<GetInsertionTextAsync>d__14")]
private static Task`1<string> GetInsertionTextAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private CodeAction CreateCodeAction(SyntaxToken nameToken, string oldName, string newName, Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckCodeFixProvider`1/<UpdateAsync>d__16")]
private Task`1<Document> UpdateAsync(Document document, SyntaxToken nameToken, string newName, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckSpanService : object {
    private Nullable`1<char> _escapeCharacter;
    protected AbstractSpellCheckSpanService(Nullable`1<char> escapeCharacter);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SpellCheck.AbstractSpellCheckSpanService/<GetSpansAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<SpellCheckSpan>> GetSpansAsync(Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SpellCheckSpan> <GetSpansAsync>g__GetSpans|2_0(<>c__DisplayClass2_0& );
}
internal interface Microsoft.CodeAnalysis.SpellCheck.ISpellCheckSpanService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<SpellCheckSpan>> GetSpansAsync(Document document, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.SpellCheck.SpellCheckKind : Enum {
    public int value__;
    public static SpellCheckKind Identifier;
    public static SpellCheckKind Comment;
    public static SpellCheckKind String;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SpellCheck.SpellCheckSpan : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private SpellCheckKind <Kind>k__BackingField;
    public TextSpan TextSpan { get; public set; }
    public SpellCheckKind Kind { get; public set; }
    public SpellCheckSpan(TextSpan TextSpan, SpellCheckKind Kind);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TextSpan(TextSpan value);
    [CompilerGeneratedAttribute]
public SpellCheckKind get_Kind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Kind(SpellCheckKind value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SpellCheckSpan left, SpellCheckSpan right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SpellCheckSpan left, SpellCheckSpan right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SpellCheckSpan other);
    [CompilerGeneratedAttribute]
public void Deconstruct(TextSpan& TextSpan, SpellCheckKind& Kind);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeConsecutiveIfStatementsCodeRefactoringProvider : AbstractMergeIfStatementsCodeRefactoringProvider {
    protected sealed virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, MergeDirection direction, string ifKeywordText);
    protected sealed virtual Task`1<bool> CanBeMergedUpAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& firstIfOrElseIf);
    protected sealed virtual Task`1<bool> CanBeMergedDownAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& secondIfOrElseIf);
    protected sealed virtual SyntaxNode GetChangedRoot(Document document, SyntaxNode root, SyntaxNode firstIfOrElseIf, SyntaxNode secondIfOrElseIf);
    private static bool CanBeMergedWithParent(ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, SyntaxNode& parentIfOrElseIf);
    private static bool CanBeMergedWithElseIf(ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, SyntaxNode& elseIfClause);
    private static Task`1<bool> CanBeMergedWithPreviousStatementAsync(Document document, ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& previousStatement);
    private static Task`1<bool> CanBeMergedWithNextStatementAsync(Document document, ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& nextStatement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeConsecutiveIfStatementsCodeRefactoringProvider/<CanStatementsBeMergedAsync>d__8")]
private static Task`1<bool> CanStatementsBeMergedAsync(Document document, ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode firstStatement, SyntaxNode secondStatement, CancellationToken cancellationToken);
    private static bool TryGetSiblingStatement(ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, SyntaxNode ifOrElseIf, int relativeIndex, SyntaxNode& statement);
    private static bool ContainEquivalentStatements(ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, SyntaxNode ifStatement1, SyntaxNode ifStatement2, IReadOnlyList`1& statements);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeIfStatementsCodeRefactoringProvider : CodeRefactoringProvider {
    protected abstract virtual bool IsApplicableSpan(SyntaxNode node, TextSpan span, SyntaxNode& ifOrElseIf);
    protected abstract virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, MergeDirection direction, string ifKeywordText);
    protected abstract virtual Task`1<bool> CanBeMergedUpAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& upperIfOrElseIf);
    protected abstract virtual Task`1<bool> CanBeMergedDownAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& lowerIfOrElseIf);
    protected abstract virtual SyntaxNode GetChangedRoot(Document document, SyntaxNode root, SyntaxNode upperIfOrElseIf, SyntaxNode lowerIfOrElseIf);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeIfStatementsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeIfStatementsCodeRefactoringProvider/<RefactorAsync>d__6")]
private Task`1<Document> RefactorAsync(Document document, TextSpan upperIfOrElseIfSpan, TextSpan lowerIfOrElseIfSpan, CancellationToken cancellationToken);
    protected static IReadOnlyList`1<SyntaxNode> WalkDownScopeBlocks(IBlockFacts blockFacts, IReadOnlyList`1<SyntaxNode> statements);
    protected static IReadOnlyList`1<SyntaxNode> WalkUpScopeBlocks(IBlockFactsService blockFacts, IReadOnlyList`1<SyntaxNode> statements);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <RefactorAsync>g__FindIfOrElseIf|6_0(TextSpan span, IIfLikeStatementGenerator ifGenerator, SyntaxNode root);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeNestedIfStatementsCodeRefactoringProvider : AbstractMergeIfStatementsCodeRefactoringProvider {
    protected sealed virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, MergeDirection direction, string ifKeywordText);
    protected sealed virtual Task`1<bool> CanBeMergedUpAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& outerIfOrElseIf);
    protected sealed virtual Task`1<bool> CanBeMergedDownAsync(Document document, SyntaxNode ifOrElseIf, CancellationToken cancellationToken, SyntaxNode& innerIfStatement);
    protected sealed virtual SyntaxNode GetChangedRoot(Document document, SyntaxNode root, SyntaxNode outerIfOrElseIf, SyntaxNode innerIfStatement);
    private static bool IsFirstStatementOfIfOrElseIf(IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode statement, SyntaxNode& ifOrElseIf);
    private static bool IsFirstStatementIfStatement(IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, SyntaxNode& ifStatement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractMergeNestedIfStatementsCodeRefactoringProvider/<CanBeMergedAsync>d__6")]
private static Task`1<bool> CanBeMergedAsync(Document document, ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode outerIfOrElseIf, SyntaxNode innerIfStatement, CancellationToken cancellationToken);
    private static bool IsElseIfOrElseClauseEquivalent(ISyntaxFactsService syntaxFacts, IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode elseIfOrElseClause1, SyntaxNode elseIfOrElseClause2);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIfStatementCodeRefactoringProvider : CodeRefactoringProvider {
    protected abstract virtual int GetLogicalExpressionKind(ISyntaxKindsService syntaxKinds);
    protected abstract virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string ifKeywordText);
    protected abstract virtual Task`1<SyntaxNode> GetChangedRootAsync(Document document, SyntaxNode root, SyntaxNode ifOrElseIf, SyntaxNode leftCondition, SyntaxNode rightCondition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIfStatementCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIfStatementCodeRefactoringProvider/<RefactorAsync>d__4")]
private Task`1<Document> RefactorAsync(Document document, TextSpan tokenSpan, TextSpan ifOrElseIfSpan, CancellationToken cancellationToken);
    private static bool IsPartOfBinaryExpressionChain(SyntaxToken token, int syntaxKind, SyntaxNode& rootExpression);
    private static ValueTuple`2<SyntaxNode, SyntaxNode> SplitBinaryExpressionChain(SyntaxToken token, SyntaxNode rootExpression, ISyntaxFactsService syntaxFacts);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider : AbstractSplitIfStatementCodeRefactoringProvider {
    protected sealed virtual int GetLogicalExpressionKind(ISyntaxKindsService syntaxKinds);
    protected sealed virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string ifKeywordText);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider/<GetChangedRootAsync>d__2")]
protected sealed virtual Task`1<SyntaxNode> GetChangedRootAsync(Document document, SyntaxNode root, SyntaxNode ifOrElseIf, SyntaxNode leftCondition, SyntaxNode rightCondition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider/<CanBeSeparateStatementsAsync>d__3")]
private static Task`1<bool> CanBeSeparateStatementsAsync(Document document, IBlockFactsService blockFacts, IIfLikeStatementGenerator ifGenerator, SyntaxNode ifOrElseIf, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.SplitOrMergeIfStatements.AbstractSplitIntoNestedIfStatementsCodeRefactoringProvider : AbstractSplitIfStatementCodeRefactoringProvider {
    protected sealed virtual int GetLogicalExpressionKind(ISyntaxKindsService syntaxKinds);
    protected sealed virtual CodeAction CreateCodeAction(Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string ifKeywordText);
    protected sealed virtual Task`1<SyntaxNode> GetChangedRootAsync(Document document, SyntaxNode root, SyntaxNode ifOrElseIf, SyntaxNode leftCondition, SyntaxNode rightCondition, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator {
    public abstract virtual bool IsIfOrElseIf(SyntaxNode node);
    public abstract virtual bool IsCondition(SyntaxNode expression, SyntaxNode& ifOrElseIf);
    public abstract virtual bool IsElseIfClause(SyntaxNode node, SyntaxNode& parentIfOrElseIf);
    public abstract virtual bool HasElseIfClause(SyntaxNode ifOrElseIf, SyntaxNode& elseIfClause);
    public abstract virtual SyntaxNode GetCondition(SyntaxNode ifOrElseIf);
    public abstract virtual SyntaxNode GetRootIfStatement(SyntaxNode ifOrElseIf);
    public abstract virtual ImmutableArray`1<SyntaxNode> GetElseIfAndElseClauses(SyntaxNode ifOrElseIf);
    public abstract virtual SyntaxNode WithCondition(SyntaxNode ifOrElseIf, SyntaxNode condition);
    public abstract virtual SyntaxNode WithStatementInBlock(SyntaxNode ifOrElseIf, SyntaxNode statement);
    public abstract virtual SyntaxNode WithStatementsOf(SyntaxNode ifOrElseIf, SyntaxNode otherIfOrElseIf);
    public abstract virtual SyntaxNode WithElseIfAndElseClausesOf(SyntaxNode ifStatement, SyntaxNode otherIfStatement);
    public abstract virtual SyntaxNode ToIfStatement(SyntaxNode ifOrElseIf);
    public abstract virtual SyntaxNode ToElseIfClause(SyntaxNode ifOrElseIf);
    public abstract virtual void InsertElseIfClause(SyntaxEditor editor, SyntaxNode afterIfOrElseIf, SyntaxNode elseIfClause);
    public abstract virtual void RemoveElseIfClause(SyntaxEditor editor, SyntaxNode elseIfClause);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.StackTraceExplorer.AbstractStackTraceSymbolResolver : object {
    public abstract virtual Task`1<IMethodSymbol> TryGetBestMatchAsync(Project project, INamedTypeSymbol type, StackFrameSimpleNameNode methodNode, StackFrameParameterList methodArguments, StackFrameTypeArgumentList methodTypeArguments, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected static bool MatchTypeArguments(ImmutableArray`1<ITypeSymbol> typeArguments, StackFrameTypeArgumentList stackFrameTypeArgumentList);
    protected static bool MatchType(ITypeSymbol type, StackFrameTypeNode stackFrameType);
    protected static bool MatchParameters(ImmutableArray`1<IParameterSymbol> parameters, StackFrameParameterList stackFrameParameters);
    [NullableContextAttribute("2")]
protected static IMethodSymbol TryGetBestMatch(ImmutableArray`1<IMethodSymbol> candidateFunctions, StackFrameTypeArgumentList methodTypeArguments, StackFrameParameterList methodArguments);
}
internal class Microsoft.CodeAnalysis.StackTraceExplorer.DefaultStackParser : object {
    [NullableContextAttribute("2")]
public sealed virtual bool TryParseLine(VirtualCharSequence line, ParsedFrame& parsedFrame);
}
internal class Microsoft.CodeAnalysis.StackTraceExplorer.DotnetStackFrameParser : object {
    [NullableContextAttribute("2")]
public sealed virtual bool TryParseLine(VirtualCharSequence line, ParsedFrame& parsedFrame);
}
internal class Microsoft.CodeAnalysis.StackTraceExplorer.IgnoredFrame : ParsedFrame {
    private VirtualCharSequence _originalText;
    public IgnoredFrame(VirtualCharSequence originalText);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal interface Microsoft.CodeAnalysis.StackTraceExplorer.IRemoteStackTraceExplorerService {
    public abstract virtual ValueTask`1<Nullable`1<SerializableDefinitionItem>> TryFindDefinitionAsync(Checksum solutionChecksum, string frameString, StackFrameSymbolPart symbolPart, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.StackTraceExplorer.IStackFrameParser {
    public abstract virtual bool TryParseLine(VirtualCharSequence line, ParsedFrame& parsedFrame);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.StackTraceExplorer.IStackTraceExplorerService {
    public abstract virtual ValueTuple`2<Document, int> GetDocumentAndLine(Solution solution, ParsedFrame frame);
    public abstract virtual Task`1<DefinitionItem> TryFindDefinitionAsync(Solution solution, ParsedFrame frame, StackFrameSymbolPart symbolPart, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.StackTraceExplorer.ParsedFrame : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.StackTraceExplorer.ParsedStackFrame : ParsedFrame {
    public StackFrameTree Tree;
    public StackFrameCompilationUnit Root { get; }
    public ParsedStackFrame(StackFrameTree tree);
    public StackFrameCompilationUnit get_Root();
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.StackTraceExplorer.StackFrameLocalMethodResolver : AbstractStackTraceSymbolResolver {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.StackTraceExplorer.StackFrameLocalMethodResolver/<TryGetBestMatchAsync>d__0")]
public virtual Task`1<IMethodSymbol> TryGetBestMatchAsync(Project project, INamedTypeSymbol type, StackFrameSimpleNameNode methodNode, StackFrameParameterList methodArguments, StackFrameTypeArgumentList methodTypeArguments, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.StackTraceExplorer.StackFrameMethodSymbolResolver : AbstractStackTraceSymbolResolver {
    [NullableContextAttribute("1")]
public virtual Task`1<IMethodSymbol> TryGetBestMatchAsync(Project project, INamedTypeSymbol type, StackFrameSimpleNameNode methodNode, StackFrameParameterList methodArguments, StackFrameTypeArgumentList methodTypeArguments, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.StackTraceExplorer.StackFrameSymbolPart : Enum {
    public int value__;
    public static StackFrameSymbolPart Method;
    public static StackFrameSymbolPart ContainingType;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceAnalysisResult : ValueType {
    [CompilerGeneratedAttribute]
private string <OriginalString>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ParsedFrame> <ParsedFrames>k__BackingField;
    public string OriginalString { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ParsedFrame> ParsedFrames { get; }
    public StackTraceAnalysisResult(string originalString, ImmutableArray`1<ParsedFrame> parsedLines);
    [CompilerGeneratedAttribute]
public string get_OriginalString();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ParsedFrame> get_ParsedFrames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceAnalyzer : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<IStackFrameParser> s_parsers;
    private static StackTraceAnalyzer();
    public static Task`1<StackTraceAnalysisResult> AnalyzeAsync(string callstack, CancellationToken cancellationToken);
    private static ImmutableArray`1<ParsedFrame> Parse(string callstack, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceAnalyzer/<SplitLines>d__3")]
private static IEnumerable`1<VirtualCharSequence> SplitLines(VirtualCharSequence callstack);
    private static VirtualCharSequence Trim(VirtualCharSequence virtualChars);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.StackTraceExplorer.IStackTraceExplorerService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceExplorerService : object {
    [NullableContextAttribute("1")]
public sealed virtual ValueTuple`2<Document, int> GetDocumentAndLine(Solution solution, ParsedFrame frame);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceExplorerService/<TryFindDefinitionAsync>d__2")]
public sealed virtual Task`1<DefinitionItem> TryFindDefinitionAsync(Solution solution, ParsedFrame frame, StackFrameSymbolPart symbolPart, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static ImmutableArray`1<Document> GetFileMatches(Solution solution, StackFrameCompilationUnit root, Int32& lineNumber);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceExplorerUtilities : object {
    private static AbstractStackTraceSymbolResolver[] _resolvers;
    private static StackTraceExplorerUtilities();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceExplorerUtilities/<GetDefinitionAsync>d__1")]
public static Task`1<DefinitionItem> GetDefinitionAsync(Solution solution, StackFrameCompilationUnit compilationUnit, StackFrameSymbolPart symbolPart, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.StackTraceExplorer.StackTraceExplorerUtilities/<TryGetBestMatchAsync>d__2")]
private static Task`1<IMethodSymbol> TryGetBestMatchAsync(Project project, string fullyQualifiedTypeName, StackFrameSimpleNameNode methodNode, StackFrameParameterList methodArguments, StackFrameTypeArgumentList methodTypeArguments, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static DefinitionItem <GetDefinitionAsync>g__GetDefinition|1_0(IMethodSymbol method, <>c__DisplayClass1_0& );
}
internal class Microsoft.CodeAnalysis.StackTraceExplorer.VSDebugCallstackParser : object {
    [NullableContextAttribute("2")]
public sealed virtual bool TryParseLine(VirtualCharSequence line, ParsedFrame& parsedFrame);
}
internal interface Microsoft.CodeAnalysis.StringIndentation.IStringIndentationService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<StringIndentationRegion>> GetStringIndentationRegionsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.StringIndentation.StringIndentationRegion : ValueType {
    public TextSpan IndentSpan;
    public ImmutableArray`1<TextSpan> OrderedHoleSpans;
    public StringIndentationRegion(TextSpan indentSpan, ImmutableArray`1<TextSpan> holeSpans);
}
internal abstract class Microsoft.CodeAnalysis.Structure.AbstractBlockStructureProvider : BlockStructureProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> _nodeProviderMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> _triviaProviderMap;
    protected AbstractBlockStructureProvider(ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> defaultNodeOutlinerMap, ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> defaultTriviaOutlinerMap);
    public virtual void ProvideBlockStructure(BlockStructureContext& modreq(System.Runtime.InteropServices.InAttribute) context);
}
internal abstract class Microsoft.CodeAnalysis.Structure.AbstractSyntaxNodeStructureProvider`1 : AbstractSyntaxStructureProvider {
    public sealed virtual void CollectBlockSpans(SyntaxTrivia trivia, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual void CollectBlockSpans(SyntaxToken previousToken, SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected abstract virtual void CollectBlockSpans(SyntaxToken previousToken, TSyntaxNode node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Structure.AbstractSyntaxStructureProvider : object {
    [NullableContextAttribute("1")]
public abstract virtual void CollectBlockSpans(SyntaxToken previousToken, SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
    public abstract virtual void CollectBlockSpans(SyntaxTrivia trivia, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Structure.AbstractSyntaxTriviaStructureProvider : AbstractSyntaxStructureProvider {
    [NullableContextAttribute("1")]
public sealed virtual void CollectBlockSpans(SyntaxToken previousToken, SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Structure.BlockSpan : ValueType {
    private static string Ellipses;
    [CompilerGeneratedAttribute]
private bool <IsCollapsible>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <HintSpan>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`3<TextSpan, TextSpan, string>> <SubHeadings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BannerText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoCollapse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultCollapsed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public bool IsCollapsible { get; }
    public TextSpan TextSpan { get; }
    public TextSpan HintSpan { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueTuple`3<TextSpan, TextSpan, string>> SubHeadings { get; }
    public string BannerText { get; }
    public bool AutoCollapse { get; }
    public bool IsDefaultCollapsed { get; }
    public string Type { get; }
    public BlockSpan(string type, bool isCollapsible, TextSpan textSpan, TextSpan hintSpan, ImmutableArray`1<ValueTuple`3<TextSpan, TextSpan, string>> subHeadings, string bannerText, bool autoCollapse, bool isDefaultCollapsed);
    public BlockSpan(string type, bool isCollapsible, TextSpan textSpan, string bannerText, bool autoCollapse, bool isDefaultCollapsed);
    [CompilerGeneratedAttribute]
public bool get_IsCollapsible();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public TextSpan get_HintSpan();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueTuple`3<TextSpan, TextSpan, string>> get_SubHeadings();
    [CompilerGeneratedAttribute]
public string get_BannerText();
    [CompilerGeneratedAttribute]
public bool get_AutoCollapse();
    [CompilerGeneratedAttribute]
public bool get_IsDefaultCollapsed();
    [CompilerGeneratedAttribute]
public string get_Type();
    public virtual string ToString();
    internal BlockSpan WithType(string type);
    internal BlockSpan WithIsCollapsible(bool isCollapsible);
    [NullableContextAttribute("0")]
internal BlockSpan With(Optional`1<bool> isCollapsible, Optional`1<TextSpan> textSpan, Optional`1<TextSpan> hintSpan, Optional`1<ImmutableArray`1<ValueTuple`3<TextSpan, TextSpan, string>>> subHeadings, Optional`1<string> type, Optional`1<string> bannerText, Optional`1<bool> autoCollapse, Optional`1<bool> isDefaultCollapsed);
}
internal class Microsoft.CodeAnalysis.Structure.BlockSpanCollector : object {
    [NullableAttribute("1")]
private BlockStructureOptions _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> _nodeProviderMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> _triviaProviderMap;
    private CancellationToken _cancellationToken;
    [NullableContextAttribute("1")]
private BlockSpanCollector(BlockStructureOptions options, ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> nodeOutlinerMap, ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> triviaOutlinerMap, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static void CollectBlockSpans(SyntaxNode syntaxRoot, BlockStructureOptions options, ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> nodeOutlinerMap, ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> triviaOutlinerMap, TemporaryArray`1& spans, CancellationToken cancellationToken);
    private void Collect(SyntaxNode root, TemporaryArray`1& spans);
    private void GetBlockSpans(SyntaxToken previousToken, SyntaxNode node, TemporaryArray`1& spans);
    private void GetBlockSpans(SyntaxToken token, TemporaryArray`1& spans);
    private void GetOutliningSpans(SyntaxTriviaList triviaList, TemporaryArray`1& spans);
}
internal class Microsoft.CodeAnalysis.Structure.BlockStructure : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BlockSpan> <Spans>k__BackingField;
    public ImmutableArray`1<BlockSpan> Spans { get; }
    public BlockStructure(ImmutableArray`1<BlockSpan> spans);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BlockSpan> get_Spans();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.Structure.BlockStructureContext : ValueType {
    public ArrayBuilder`1<BlockSpan> Spans;
    public SyntaxTree SyntaxTree;
    public BlockStructureOptions Options;
    public CancellationToken CancellationToken;
    public BlockStructureContext(SyntaxTree syntaxTree, BlockStructureOptions options, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Structure.BlockStructureExtensions : object {
    [ExtensionAttribute]
public static void Add(Builder<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Structure.BlockStructureOptions : object {
    [CompilerGeneratedAttribute]
private bool <ShowBlockStructureGuidesForCommentsAndPreprocessorRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowBlockStructureGuidesForDeclarationLevelConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowBlockStructureGuidesForCodeLevelConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowOutliningForCommentsAndPreprocessorRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowOutliningForDeclarationLevelConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowOutliningForCodeLevelConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollapseRegionsWhenFirstOpened>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollapseImportsWhenFirstOpened>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollapseMetadataImplementationsWhenFirstOpened>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollapseEmptyMetadataImplementationsWhenFirstOpened>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollapseRegionsWhenCollapsingToDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollapseLocalFunctionsWhenCollapsingToDefinitions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumBannerLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMetadataAsSource>k__BackingField;
    public static BlockStructureOptions Default;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    [DataMemberAttribute]
public bool ShowBlockStructureGuidesForCommentsAndPreprocessorRegions { get; public set; }
    [DataMemberAttribute]
public bool ShowBlockStructureGuidesForDeclarationLevelConstructs { get; public set; }
    [DataMemberAttribute]
public bool ShowBlockStructureGuidesForCodeLevelConstructs { get; public set; }
    [DataMemberAttribute]
public bool ShowOutliningForCommentsAndPreprocessorRegions { get; public set; }
    [DataMemberAttribute]
public bool ShowOutliningForDeclarationLevelConstructs { get; public set; }
    [DataMemberAttribute]
public bool ShowOutliningForCodeLevelConstructs { get; public set; }
    [DataMemberAttribute]
public bool CollapseRegionsWhenFirstOpened { get; public set; }
    [DataMemberAttribute]
public bool CollapseImportsWhenFirstOpened { get; public set; }
    [DataMemberAttribute]
public bool CollapseMetadataImplementationsWhenFirstOpened { get; public set; }
    [DataMemberAttribute]
public bool CollapseEmptyMetadataImplementationsWhenFirstOpened { get; public set; }
    [DataMemberAttribute]
public bool CollapseRegionsWhenCollapsingToDefinitions { get; public set; }
    [DataMemberAttribute]
public bool CollapseLocalFunctionsWhenCollapsingToDefinitions { get; public set; }
    [DataMemberAttribute]
public int MaximumBannerLength { get; public set; }
    [DataMemberAttribute]
public bool IsMetadataAsSource { get; public set; }
    [CompilerGeneratedAttribute]
private BlockStructureOptions(BlockStructureOptions original);
    private static BlockStructureOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_ShowBlockStructureGuidesForCommentsAndPreprocessorRegions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowBlockStructureGuidesForCommentsAndPreprocessorRegions(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowBlockStructureGuidesForDeclarationLevelConstructs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowBlockStructureGuidesForDeclarationLevelConstructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowBlockStructureGuidesForCodeLevelConstructs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowBlockStructureGuidesForCodeLevelConstructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowOutliningForCommentsAndPreprocessorRegions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowOutliningForCommentsAndPreprocessorRegions(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowOutliningForDeclarationLevelConstructs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowOutliningForDeclarationLevelConstructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowOutliningForCodeLevelConstructs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowOutliningForCodeLevelConstructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollapseRegionsWhenFirstOpened();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollapseRegionsWhenFirstOpened(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollapseImportsWhenFirstOpened();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollapseImportsWhenFirstOpened(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollapseMetadataImplementationsWhenFirstOpened();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollapseMetadataImplementationsWhenFirstOpened(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollapseEmptyMetadataImplementationsWhenFirstOpened();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollapseEmptyMetadataImplementationsWhenFirstOpened(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollapseRegionsWhenCollapsingToDefinitions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollapseRegionsWhenCollapsingToDefinitions(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollapseLocalFunctionsWhenCollapsingToDefinitions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollapseLocalFunctionsWhenCollapsingToDefinitions(bool value);
    [CompilerGeneratedAttribute]
public int get_MaximumBannerLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MaximumBannerLength(int value);
    [CompilerGeneratedAttribute]
public bool get_IsMetadataAsSource();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsMetadataAsSource(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BlockStructureOptions left, BlockStructureOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BlockStructureOptions left, BlockStructureOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BlockStructureOptions other);
    [CompilerGeneratedAttribute]
public BlockStructureOptions <Clone>$();
}
internal abstract class Microsoft.CodeAnalysis.Structure.BlockStructureProvider : object {
    public abstract virtual void ProvideBlockStructure(BlockStructureContext& modreq(System.Runtime.InteropServices.InAttribute) context);
}
internal abstract class Microsoft.CodeAnalysis.Structure.BlockStructureService : object {
    public string Language { get; }
    public static BlockStructureService GetService(Document document);
    public abstract virtual string get_Language();
    public abstract virtual Task`1<BlockStructure> GetBlockStructureAsync(Document document, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders : BlockStructureService {
    private SolutionServices _services;
    private ImmutableArray`1<BlockStructureProvider> _providers;
    protected BlockStructureServiceWithProviders(SolutionServices services);
    protected virtual ImmutableArray`1<BlockStructureProvider> GetBuiltInProviders();
    private ImmutableArray`1<BlockStructureProvider> GetImportedProviders();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Structure.BlockStructureServiceWithProviders/<GetBlockStructureAsync>d__5")]
public virtual Task`1<BlockStructure> GetBlockStructureAsync(Document document, BlockStructureOptions options, CancellationToken cancellationToken);
    private static BlockStructureContext CreateContext(SyntaxTree syntaxTree, BlockStructureOptions& options, CancellationToken cancellationToken);
    private static BlockStructure GetBlockStructure(BlockStructureContext& context, ImmutableArray`1<BlockStructureProvider> providers);
    private static BlockStructure CreateBlockStructure(BlockStructureContext& context);
    private static BlockSpan UpdateBlockSpan(BlockSpan blockSpan, BlockStructureOptions& options);
}
internal static class Microsoft.CodeAnalysis.Structure.BlockTypes : object {
    public static string Nonstructural;
    public static string Comment;
    public static string PreprocessorRegion;
    public static string Imports;
    public static string Namespace;
    public static string Type;
    public static string Member;
    public static string Statement;
    public static string Conditional;
    public static string Loop;
    public static string Expression;
    internal static bool IsCommentOrPreprocessorRegion(string type);
    internal static bool IsExpressionLevelConstruct(string type);
    internal static bool IsStatementLevelConstruct(string type);
    internal static bool IsCodeLevelConstruct(string type);
    internal static bool IsDeclarationLevelConstruct(string type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolDisplayPartKindTags : object {
    [ExtensionAttribute]
public static SymbolDisplayPartKind GetSymbolDisplayPartKind(INamedTypeSymbol namedType);
    public static string GetTag(SymbolDisplayPartKind kind);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SymbolMapping.DefaultSymbolMappingService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SymbolMapping.DefaultSymbolMappingService/<MapSymbolAsync>d__1")]
public sealed virtual Task`1<SymbolMappingResult> MapSymbolAsync(Document document, SymbolKey symbolId, CancellationToken cancellationToken);
    public sealed virtual Task`1<SymbolMappingResult> MapSymbolAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SymbolMapping.ISymbolMappingService {
    public abstract virtual Task`1<SymbolMappingResult> MapSymbolAsync(Document document, SymbolKey symbolId, CancellationToken cancellationToken);
    public abstract virtual Task`1<SymbolMappingResult> MapSymbolAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SymbolMapping.SymbolMappingResult : object {
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    public Project Project { get; }
    public ISymbol Symbol { get; }
    public Solution Solution { get; }
    internal SymbolMappingResult(Project project, ISymbol symbol);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    public Solution get_Solution();
}
internal class Microsoft.CodeAnalysis.SymbolSearch.AddReferenceDatabaseWrapper : object {
    [CompilerGeneratedAttribute]
private AddReferenceDatabase <Database>k__BackingField;
    public AddReferenceDatabase Database { get; }
    public AddReferenceDatabaseWrapper(AddReferenceDatabase database);
    [CompilerGeneratedAttribute]
public sealed virtual AddReferenceDatabase get_Database();
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.IAddReferenceDatabaseWrapper {
    public AddReferenceDatabase Database { get; }
    public abstract virtual AddReferenceDatabase get_Database();
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.IDatabaseFactoryService {
    public abstract virtual AddReferenceDatabase CreateDatabaseFromBytes(Byte[] bytes);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.IDelayService {
    public TimeSpan UpdateSucceededDelay { get; }
    public TimeSpan ExpectedFailureDelay { get; }
    public TimeSpan CatastrophicFailureDelay { get; }
    public TimeSpan FileWriteDelay { get; }
    public TimeSpan CachePollDelay { get; }
    public abstract virtual TimeSpan get_UpdateSucceededDelay();
    public abstract virtual TimeSpan get_ExpectedFailureDelay();
    public abstract virtual TimeSpan get_CatastrophicFailureDelay();
    public abstract virtual TimeSpan get_FileWriteDelay();
    public abstract virtual TimeSpan get_CachePollDelay();
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.IFileDownloader {
    public abstract virtual Task`1<Stream> ReadFileAsync();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SymbolSearch.IFileDownloaderFactory {
    public abstract virtual IFileDownloader CreateClient(string hostId, string serverPath, int pollingMinutes);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.IIOService {
    public abstract virtual void Create(DirectoryInfo directory);
    public abstract virtual void Delete(FileInfo file);
    public abstract virtual bool Exists(FileSystemInfo info);
    public abstract virtual Byte[] ReadAllBytes(string path);
    public abstract virtual void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public abstract virtual void Move(string sourceFileName, string destinationFileName);
    public abstract virtual void WriteAndFlushAllBytes(string path, Byte[] bytes);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.IPatchService {
    public abstract virtual Byte[] ApplyPatch(Byte[] databaseBytes, Byte[] patchBytes);
}
internal static class Microsoft.CodeAnalysis.SymbolSearch.NativePatching : object {
    private static bool ApplyDeltaB(DeltaApplyFlag applyFlags, DeltaInput source, DeltaInput delta, DeltaOutput& target);
    private static bool DeltaFree(IntPtr memory);
    public static Byte[] ApplyPatch(Byte[] sourceBytes, Byte[] patchBytes);
}
internal class Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngine : object {
    private ConcurrentDictionary`2<string, IAddReferenceDatabaseWrapper> _sourceToDatabase;
    internal static string ContentAttributeName;
    internal static string ChecksumAttributeName;
    internal static string UpToDateAttributeName;
    internal static string TooOldAttributeName;
    public static string HostId;
    private static string MicrosoftAssemblyReferencesName;
    private static int AddReferenceDatabaseTextFileFormatVersion;
    private static LinkedList`1<string> s_logs;
    private ConcurrentDictionary`2<string, object> _sourceToUpdateSentinel;
    private IDelayService _delayService;
    private IIOService _ioService;
    private IFileDownloaderFactory _fileDownloaderFactory;
    private IPatchService _patchService;
    private IDatabaseFactoryService _databaseFactoryService;
    private Func`3<Exception, CancellationToken, bool> _reportAndSwallowExceptionUnlessCanceled;
    public SymbolSearchUpdateEngine(IFileDownloaderFactory fileDownloaderFactory);
    internal SymbolSearchUpdateEngine(IFileDownloaderFactory fileDownloaderFactory, IDelayService delayService, IIOService ioService, IPatchService patchService, IDatabaseFactoryService databaseFactoryService, Func`3<Exception, CancellationToken, bool> reportAndSwallowExceptionUnlessCanceled);
    private static SymbolSearchUpdateEngine();
    public sealed virtual void Dispose();
    public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
    private static List`1<Symbol> FilterToViableTypes(PartialArray`1<Symbol> symbols);
    private static PackageWithTypeResult CreateResult(AddReferenceDatabase database, Symbol type);
    private static int GetRank(Symbol symbol);
    private static bool TryGetRankingSymbol(Symbol symbol, Symbol& rankingSymbol);
    private static bool TryGetRankingSymbolForPackage(Symbol package, Symbol& rankingSymbol);
    private static bool IsType(Symbol symbol);
    private static void GetFullName(ArrayBuilder`1<string> nameParts, Path8 path);
    public sealed virtual ValueTask UpdateContinuouslyAsync(string source, string localSettingsDirectory, CancellationToken cancellationToken);
    private static void LogInfo(string text);
    private static void LogException(Exception exception, string text);
    private static void Log(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineFactory : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineFactory/<CreateEngineAsync>d__0")]
public static ValueTask`1<ISymbolSearchUpdateEngine> CreateEngineAsync(Workspace workspace, IFileDownloaderFactory fileDownloaderFactory, CancellationToken cancellationToken);
    public static ISymbolSearchUpdateEngine CreateEngineInProcess(IFileDownloaderFactory fileDownloaderFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineProxy : object {
    private RemoteServiceConnection`1<IRemoteSymbolSearchUpdateService> _connection;
    public SymbolSearchUpdateEngineProxy(RemoteHostClient client);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineProxy/<FindPackagesWithTypeAsync>d__3")]
public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineProxy/<FindPackagesWithAssemblyAsync>d__4")]
public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineProxy/<FindReferenceAssembliesWithTypeAsync>d__5")]
public sealed virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateEngineProxy/<UpdateContinuouslyAsync>d__6")]
public sealed virtual ValueTask UpdateContinuouslyAsync(string sourceName, string localSettingsDirectory, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchUpdateNoOpEngine : object {
    public static SymbolSearchUpdateNoOpEngine Instance;
    private static SymbolSearchUpdateNoOpEngine();
    public sealed virtual void Dispose();
    public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
    public sealed virtual ValueTask UpdateContinuouslyAsync(string sourceName, string localSettingsDirectory, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SyncNamespaces.AbstractSyncNamespacesService`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2<TSyntaxKind, TNamespaceSyntax> DiagnosticAnalyzer { get; }
    public AbstractChangeNamespaceToMatchFolderCodeFixProvider CodeFixProvider { get; }
    public abstract virtual AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2<TSyntaxKind, TNamespaceSyntax> get_DiagnosticAnalyzer();
    public abstract virtual AbstractChangeNamespaceToMatchFolderCodeFixProvider get_CodeFixProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyncNamespaces.AbstractSyncNamespacesService`2/<SyncNamespacesAsync>d__4")]
public sealed virtual Task`1<Solution> SyncNamespacesAsync(ImmutableArray`1<Project> projects, CodeActionOptionsProvider options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyncNamespaces.AbstractSyncNamespacesService`2/<GetDiagnosticsByProjectAsync>d__5")]
private static Task`1<ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>>> GetDiagnosticsByProjectAsync(ImmutableArray`1<Project> projects, ImmutableArray`1<DiagnosticAnalyzer> diagnosticAnalyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyncNamespaces.AbstractSyncNamespacesService`2/<GetDiagnosticsAsync>d__6")]
private static Task`1<ImmutableArray`1<Diagnostic>> GetDiagnosticsAsync(Project project, ImmutableArray`1<DiagnosticAnalyzer> diagnosticAnalyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyncNamespaces.AbstractSyncNamespacesService`2/<GetFixAllContextAsync>d__7")]
private static Task`1<FixAllContext> GetFixAllContextAsync(Solution solution, CodeFixProvider codeFixProvider, ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> diagnosticsByProject, CodeActionOptionsProvider options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyncNamespaces.AbstractSyncNamespacesService`2/<ApplyCodeFixAsync>d__8")]
private static Task`1<Solution> ApplyCodeFixAsync(FixAllProvider fixAllProvider, FixAllContext fixAllContext, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SyncNamespaces.ISyncNamespacesService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Solution> SyncNamespacesAsync(ImmutableArray`1<Project> projects, CodeActionOptionsProvider options, IProgress`1<CodeAnalysisProgress> progressTracker, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
public class Microsoft.CodeAnalysis.TaggedText : ValueType {
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private TaggedTextStyle <Style>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <NavigationTarget>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <NavigationHint>k__BackingField;
    [DataMemberAttribute]
public string Tag { get; }
    [DataMemberAttribute]
public string Text { get; }
    [DataMemberAttribute]
internal TaggedTextStyle Style { get; }
    [NullableAttribute("2")]
[DataMemberAttribute]
internal string NavigationTarget { get; }
    [NullableAttribute("2")]
[DataMemberAttribute]
internal string NavigationHint { get; }
    public TaggedText(string tag, string text);
    internal TaggedText(string tag, string text, TaggedTextStyle style, string navigationTarget, string navigationHint);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
internal TaggedTextStyle get_Style();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_NavigationTarget();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_NavigationHint();
    public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TaggedText left, TaggedText right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TaggedText left, TaggedText right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TaggedText other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.TaggedTextExtensions : object {
    private static string LeftToRightMarkerPrefix;
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TaggedText> ToTaggedText(IEnumerable`1<SymbolDisplayPart> displayParts, TaggedTextStyle style, Func`2<ISymbol, string> getNavigationHint, bool includeNavigationHints);
    private static string GetTag(SymbolDisplayPart part);
    [NullableContextAttribute("2")]
private static string GetNavigationTarget(ISymbol symbol);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string JoinText(ImmutableArray`1<TaggedText> values);
    [ExtensionAttribute]
public static string ToClassificationTypeName(string taggedTextTag);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.TaggedTextExtensions/<ToClassifiedSpans>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<ClassifiedSpan> ToClassifiedSpans(IEnumerable`1<TaggedText> parts);
    [ExtensionAttribute]
public static string ToVisibleDisplayString(TaggedText part, bool includeLeftToRightMarker);
    [ExtensionAttribute]
public static string ToVisibleDisplayString(IEnumerable`1<TaggedText> parts, bool includeLeftToRightMarker);
    [ExtensionAttribute]
public static string GetFullText(IEnumerable`1<TaggedText> parts);
    [ExtensionAttribute]
public static void AddAliasName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddAssemblyName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddClassName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddDelegateName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddEnumName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddErrorTypeName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddEventName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddFieldName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddInterfaceName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddKeyword(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddLabelName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddLineBreak(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddNumericLiteral(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddStringLiteral(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddLocalName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddMethodName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddModuleName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddNamespaceName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddOperator(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddParameterName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddPropertyName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddPunctuation(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddRangeVariableName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddStructName(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddSpace(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddText(IList`1<TaggedText> parts, string text);
    [ExtensionAttribute]
public static void AddTypeParameterName(IList`1<TaggedText> parts, string text);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.TaggedTextStyle : Enum {
    public int value__;
    public static TaggedTextStyle None;
    public static TaggedTextStyle Strong;
    public static TaggedTextStyle Emphasis;
    public static TaggedTextStyle Underline;
    public static TaggedTextStyle Code;
    public static TaggedTextStyle PreserveWhitespace;
}
internal static class Microsoft.CodeAnalysis.Tagging.CompilationAvailableHelpers : object {
    private static bool s_shouldSkipComputation;
    [NullableContextAttribute("1")]
public static Task ComputeCompilationInCurrentProcessAsync(Project project, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.TaskList.AbstractTaskListService : object {
    protected abstract virtual bool PreprocessorHasComment(SyntaxTrivia trivia);
    protected abstract virtual bool IsSingleLineComment(SyntaxTrivia trivia);
    protected abstract virtual bool IsMultilineComment(SyntaxTrivia trivia);
    protected abstract virtual bool IsIdentifierCharacter(char ch);
    protected abstract virtual string GetNormalizedText(string message);
    protected abstract virtual int GetCommentStartingIndex(string message);
    protected abstract virtual void AppendTaskListItems(ImmutableArray`1<TaskListItemDescriptor> descriptors, SyntacticDocument document, SyntaxTrivia trivia, ArrayBuilder`1<TaskListItem> items);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TaskList.AbstractTaskListService/<GetTaskListItemsAsync>d__7")]
public sealed virtual Task`1<ImmutableArray`1<TaskListItem>> GetTaskListItemsAsync(Document document, ImmutableArray`1<TaskListItemDescriptor> descriptors, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TaskList.AbstractTaskListService/<GetTaskListItemsInProcessAsync>d__8")]
private Task`1<ImmutableArray`1<TaskListItem>> GetTaskListItemsInProcessAsync(Document document, ImmutableArray`1<TaskListItemDescriptor> descriptors, CancellationToken cancellationToken);
    private bool ContainsComments(SyntaxTrivia trivia);
    protected void AppendTaskListItemsOnSingleLine(ImmutableArray`1<TaskListItemDescriptor> descriptors, SyntacticDocument document, string message, int start, ArrayBuilder`1<TaskListItem> items);
    protected void ProcessMultilineComment(ImmutableArray`1<TaskListItemDescriptor> commentDescriptors, SyntacticDocument document, SyntaxTrivia trivia, int postfixLength, ArrayBuilder`1<TaskListItem> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Text.TextUtilities : object {
    internal static int GetLengthOfLineBreak(SourceText text, int index);
    private static int GetLengthOfLineBreakSlow(SourceText text, int index, char c);
    public static void GetStartAndLengthOfLineBreakEndingAt(SourceText text, int index, Int32& startLinebreak, Int32& lengthLinebreak);
    internal static bool IsAnyLineBreakCharacter(char c);
}
public static class Microsoft.CodeAnalysis.TextTags : object {
    public static string Alias;
    public static string Assembly;
    public static string Class;
    public static string Delegate;
    public static string Enum;
    public static string ErrorType;
    public static string Event;
    public static string Field;
    public static string Interface;
    public static string Keyword;
    public static string Label;
    public static string LineBreak;
    public static string NumericLiteral;
    public static string StringLiteral;
    public static string Local;
    public static string Method;
    public static string Module;
    public static string Namespace;
    public static string Operator;
    public static string Parameter;
    public static string Property;
    public static string Punctuation;
    public static string Space;
    public static string Struct;
    public static string AnonymousTypeIndicator;
    public static string Text;
    public static string TypeParameter;
    public static string RangeVariable;
    public static string EnumMember;
    public static string ExtensionMethod;
    public static string Constant;
    public static string Record;
    public static string RecordStruct;
    internal static string ContainerStart;
    internal static string ContainerEnd;
    internal static string CodeBlockStart;
    internal static string CodeBlockEnd;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider : CodeFixProvider {
    protected string TitleFormat { get; }
    protected abstract virtual string get_TitleFormat();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnsealClass.AbstractUnsealClassCodeFixProvider/<UnsealDeclarationsAsync>d__4")]
private static Task`1<Solution> UnsealDeclarationsAsync(Solution solution, ImmutableArray`1<SyntaxReference> declarationReferences, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.UnusedReferences.IReferenceCleanupService {
    public abstract virtual Task`1<ImmutableArray`1<ReferenceInfo>> GetProjectReferencesAsync(string projectPath, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> TryUpdateReferenceAsync(string projectPath, ReferenceUpdate referenceUpdate, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.UnusedReferences.IRemoteUnusedReferenceAnalysisService {
    public abstract virtual ValueTask`1<ImmutableArray`1<ReferenceInfo>> GetUnusedReferencesAsync(Checksum solutionChecksum, string projectFilePath, string projectAssetsFilePath, ImmutableArray`1<ReferenceInfo> projectReferences, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.UnusedReferences.IUnusedReferenceAnalysisService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<ReferenceInfo>> GetUnusedReferencesAsync(Solution solution, string projectFilePath, string projectAssetsFilePath, ImmutableArray`1<ReferenceInfo> projectReferences, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, Dictionary`2<string, ProjectAssetsTargetLibrary>> <Targets>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, ProjectAssetsLibrary> <Libraries>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <ProjectFileDependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectAssetsProject <Project>k__BackingField;
    public int Version { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, Dictionary`2<string, ProjectAssetsTargetLibrary>> Targets { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, ProjectAssetsLibrary> Libraries { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, List`1<string>> ProjectFileDependencyGroups { get; public set; }
    public ProjectAssetsProject Project { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Dictionary`2<string, ProjectAssetsTargetLibrary>> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(Dictionary`2<string, Dictionary`2<string, ProjectAssetsTargetLibrary>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ProjectAssetsLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(Dictionary`2<string, ProjectAssetsLibrary> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_ProjectFileDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_ProjectFileDependencyGroups(Dictionary`2<string, List`1<string>> value);
    [CompilerGeneratedAttribute]
public ProjectAssetsProject get_Project();
    [CompilerGeneratedAttribute]
public void set_Project(ProjectAssetsProject value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsLibrary : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsProject : object {
    [CompilerGeneratedAttribute]
private ProjectAssetsProjectRestore <Restore>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, ProjectAssetsProjectFramework> <Frameworks>k__BackingField;
    public ProjectAssetsProjectRestore Restore { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, ProjectAssetsProjectFramework> Frameworks { get; public set; }
    [CompilerGeneratedAttribute]
public ProjectAssetsProjectRestore get_Restore();
    [CompilerGeneratedAttribute]
public void set_Restore(ProjectAssetsProjectRestore value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ProjectAssetsProjectFramework> get_Frameworks();
    [CompilerGeneratedAttribute]
public void set_Frameworks(Dictionary`2<string, ProjectAssetsProjectFramework> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsProjectFramework : object {
    [CompilerGeneratedAttribute]
private string <TargetAlias>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, ProjectAssetsProjectFrameworkDependency> <Dependencies>k__BackingField;
    public string TargetAlias { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, ProjectAssetsProjectFrameworkDependency> Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TargetAlias();
    [CompilerGeneratedAttribute]
public void set_TargetAlias(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ProjectAssetsProjectFrameworkDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(Dictionary`2<string, ProjectAssetsProjectFrameworkDependency> value);
}
internal class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsProjectFrameworkDependency : object {
    [CompilerGeneratedAttribute]
private bool <AutoReferenced>k__BackingField;
    public bool AutoReferenced { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AutoReferenced();
    [CompilerGeneratedAttribute]
public void set_AutoReferenced(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsProjectRestore : object {
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesPath>k__BackingField;
    public string ProjectPath { get; public set; }
    public string PackagesPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
public void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public string get_PackagesPath();
    [CompilerGeneratedAttribute]
public void set_PackagesPath(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsReader : object {
    private static string NuGetEmptyFileName;
    [NullableContextAttribute("2")]
public static ImmutableArray`1<ReferenceInfo> AddDependencyHierarchies(ImmutableArray`1<ReferenceInfo> projectReferences, ProjectAssetsFile projectAssets);
    private static ReferenceInfo EnhanceReference(ProjectAssetsFile projectAssets, ReferenceInfo referenceInfo, ImmutableHashSet`1<string> autoReferences, ImmutableDictionary`2<string, ImmutableDictionary`2<string, string>> targetLibraryKeys, Dictionary`2<string, ReferenceInfo> builtReferences);
    private static ReferenceInfo BuildReference(ProjectAssetsFile projectAssets, string referenceName, bool treatAsUsed, ImmutableDictionary`2<string, ImmutableDictionary`2<string, string>> targetLibraryKeys, Dictionary`2<string, ReferenceInfo> builtReferences);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsTargetLibrary : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Dependencies>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, ProjectAssetsTargetLibraryCompile> <Compile>k__BackingField;
    public string Type { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> Dependencies { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, ProjectAssetsTargetLibraryCompile> Compile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ProjectAssetsTargetLibraryCompile> get_Compile();
    [CompilerGeneratedAttribute]
public void set_Compile(Dictionary`2<string, ProjectAssetsTargetLibraryCompile> value);
}
internal class Microsoft.CodeAnalysis.UnusedReferences.ProjectAssets.ProjectAssetsTargetLibraryCompile : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.UnusedReferences.ReferenceInfo : object {
    [CompilerGeneratedAttribute]
private ReferenceType <ReferenceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatAsUsed>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <CompilationAssemblies>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ReferenceInfo> <Dependencies>k__BackingField;
    [DataMemberAttribute]
public ReferenceType ReferenceType { get; }
    [DataMemberAttribute]
public string ItemSpecification { get; }
    [DataMemberAttribute]
public bool TreatAsUsed { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> CompilationAssemblies { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ReferenceInfo> Dependencies { get; }
    public ReferenceInfo(ReferenceType referenceType, string itemSpecification, bool treatAsUsed, ImmutableArray`1<string> compilationAssemblies, ImmutableArray`1<ReferenceInfo> dependencies);
    [CompilerGeneratedAttribute]
public ReferenceType get_ReferenceType();
    [CompilerGeneratedAttribute]
public string get_ItemSpecification();
    [CompilerGeneratedAttribute]
public bool get_TreatAsUsed();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_CompilationAssemblies();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ReferenceInfo> get_Dependencies();
    public ReferenceInfo WithItemSpecification(string itemSpecification);
    public ReferenceInfo WithDependencies(IEnumerable`1<ReferenceInfo> dependencies);
}
internal enum Microsoft.CodeAnalysis.UnusedReferences.ReferenceType : Enum {
    public int value__;
    public static ReferenceType Unknown;
    public static ReferenceType Assembly;
    public static ReferenceType Package;
    public static ReferenceType Project;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UnusedReferences.ReferenceUpdate : object {
    [CompilerGeneratedAttribute]
private UpdateAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceInfo <ReferenceInfo>k__BackingField;
    public UpdateAction Action { get; public set; }
    public ReferenceInfo ReferenceInfo { get; }
    public ReferenceUpdate(UpdateAction action, ReferenceInfo referenceInfo);
    [CompilerGeneratedAttribute]
public UpdateAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(UpdateAction value);
    [CompilerGeneratedAttribute]
public ReferenceInfo get_ReferenceInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UnusedReferences.UnusedReferencesRemover : object {
    [NullableAttribute("0")]
private static ImmutableArray`1<ReferenceType> s_processingOrder;
    private static UnusedReferencesRemover();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnusedReferences.UnusedReferencesRemover/<GetUnusedReferencesAsync>d__1")]
public static Task`1<ImmutableArray`1<ReferenceInfo>> GetUnusedReferencesAsync(Solution solution, string projectFilePath, ImmutableArray`1<ReferenceInfo> references, CancellationToken cancellationToken);
    internal static ImmutableArray`1<ReferenceInfo> GetUnusedReferences(HashSet`1<string> usedAssemblyFilePaths, HashSet`1<string> usedProjectFileNames, ImmutableArray`1<ReferenceInfo> references);
    private static ImmutableArray`1<ReferenceInfo> RemoveDirectlyUsedReferences(ImmutableArray`1<ReferenceInfo> references, HashSet`1<string> usedAssemblyFilePaths, HashSet`1<string> usedProjectFileNames);
    private static ImmutableArray`1<ReferenceInfo> RemoveTransitivelyUsedReferences(ImmutableArray`1<ReferenceInfo> references, HashSet`1<string> usedAssemblyFilePaths);
    internal static bool HasAnyCompilationAssembly(ReferenceInfo reference);
    internal static bool ContainsAnyCompilationAssembly(ReferenceInfo reference, HashSet`1<string> usedAssemblyFilePaths);
    internal static void RemoveAllCompilationAssemblies(ReferenceInfo reference, HashSet`1<string> usedAssemblyFilePaths);
    internal static ImmutableArray`1<string> GetAllCompilationAssemblies(ReferenceInfo reference);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnusedReferences.UnusedReferencesRemover/<UpdateReferencesAsync>d__9")]
public static Task UpdateReferencesAsync(Solution solution, string projectFilePath, ImmutableArray`1<ReferenceUpdate> referenceUpdates, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UnusedReferences.UnusedReferencesRemover/<ApplyReferenceUpdatesAsync>d__10")]
internal static Task ApplyReferenceUpdatesAsync(IReferenceCleanupService referenceCleanupService, string projectFilePath, ImmutableArray`1<ReferenceUpdate> referenceUpdates, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.UnusedReferences.UpdateAction : Enum {
    public int value__;
    public static UpdateAction None;
    public static UpdateAction TreatAsUsed;
    public static UpdateAction TreatAsUnused;
    public static UpdateAction Remove;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UpdateLegacySuppressions.UpdateLegacySuppressionsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UpdateLegacySuppressions.UpdateLegacySuppressionsCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UpgradeProject.AbstractUpgradeProjectCodeFixProvider : CodeFixProvider {
    public string UpgradeThisProjectResource { get; }
    public string UpgradeAllProjectsResource { get; }
    public abstract virtual string SuggestedVersion(ImmutableArray`1<Diagnostic> diagnostics);
    public abstract virtual Solution UpgradeProject(Project project, string version);
    public abstract virtual bool IsUpgrade(Project project, string newVersion);
    public abstract virtual string get_UpgradeThisProjectResource();
    public abstract virtual string get_UpgradeAllProjectsResource();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected ImmutableArray`1<CodeAction> GetUpgradeProjectCodeActions(CodeFixContext context);
    public Solution UpgradeAllProjects(Solution solution, string language, string version, CancellationToken cancellationToken);
    private bool CanUpgrade(Project project, string language, string version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.UpgradeProject.ProjectOptionsChangeAction : SolutionChangeAction {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    private ProjectOptionsChangeAction(string title, Func`3<IProgress`1<CodeAnalysisProgress>, CancellationToken, Task`1<Solution>> createChangedSolution);
    public virtual ImmutableArray`1<string> get_Tags();
    public static ProjectOptionsChangeAction Create(string title, Func`3<IProgress`1<CodeAnalysisProgress>, CancellationToken, Task`1<Solution>> createChangedSolution);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyAnalyzer`7 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ObjectPool`1<ConcurrentStack`1<AnalysisResult<TSyntaxKind, TPropertyDeclaration, TConstructorDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression, TIdentifierName>>> s_analysisResultPool;
    private static ObjectPool`1<ConcurrentSet`1<IFieldSymbol>> s_fieldSetPool;
    private static ObjectPool`1<ConcurrentSet`1<SyntaxNode>> s_nodeSetPool;
    private static ObjectPool`1<ConcurrentDictionary`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>>> s_fieldWriteLocationPool;
    private static Func`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>> s_createFieldWriteNodeSet;
    private ObjectPool`1<HashSet`1<string>> _fieldNamesPool;
    protected ISemanticFacts SemanticFacts { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    [NullableAttribute("0")]
protected TSyntaxKind PropertyDeclarationKind { get; }
    private static AbstractUseAutoPropertyAnalyzer`7();
    protected static void AddFieldWrite(ConcurrentDictionary`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>> fieldWrites, IFieldSymbol field, SyntaxNode node);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected ISyntaxFacts get_SyntaxFacts();
    [NullableContextAttribute("0")]
protected abstract virtual TSyntaxKind get_PropertyDeclarationKind();
    protected abstract virtual bool SupportsReadOnlyProperties(Compilation compilation);
    protected abstract virtual bool SupportsPropertyInitializer(Compilation compilation);
    protected abstract virtual bool CanExplicitInterfaceImplementationsBeFixed();
    protected abstract virtual TExpression GetFieldInitializer(TVariableDeclarator variable, CancellationToken cancellationToken);
    protected abstract virtual TExpression GetGetterExpression(IMethodSymbol getMethod, CancellationToken cancellationToken);
    protected abstract virtual TExpression GetSetterExpression(IMethodSymbol setMethod, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetFieldNode(TFieldDeclaration fieldDeclaration, TVariableDeclarator variableDeclarator);
    protected abstract virtual void RegisterIneligibleFieldsAction(HashSet`1<string> fieldNames, ConcurrentSet`1<IFieldSymbol> ineligibleFields, SemanticModel semanticModel, SyntaxNode codeBlock, CancellationToken cancellationToken);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void RegisterNonConstructorFieldWrites(HashSet`1<string> fieldNames, ConcurrentDictionary`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>> fieldWrites, SemanticModel semanticModel, SyntaxNode codeBlock, CancellationToken cancellationToken);
    private void AnalyzePropertyDeclaration(SyntaxNodeAnalysisContext context, INamedTypeSymbol containingType, ConcurrentStack`1<AnalysisResult<TSyntaxKind, TPropertyDeclaration, TConstructorDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression, TIdentifierName>> analysisResults);
    protected virtual bool CanConvert(IPropertySymbol property);
    private IFieldSymbol GetSetterField(SemanticModel semanticModel, IMethodSymbol setMethod, CancellationToken cancellationToken);
    private IFieldSymbol GetGetterField(SemanticModel semanticModel, IMethodSymbol getMethod, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static IFieldSymbol CheckFieldAccessExpression(SemanticModel semanticModel, TExpression expression, CancellationToken cancellationToken);
    private void Process(ConcurrentStack`1<AnalysisResult<TSyntaxKind, TPropertyDeclaration, TConstructorDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression, TIdentifierName>> analysisResults, ConcurrentSet`1<IFieldSymbol> ineligibleFields, ConcurrentDictionary`2<IFieldSymbol, ConcurrentSet`1<SyntaxNode>> nonConstructorFieldWrites, SymbolAnalysisContext context);
    private void Process(AnalysisResult<TSyntaxKind, TPropertyDeclaration, TConstructorDeclaration, TFieldDeclaration, TVariableDeclarator, TExpression, TIdentifierName> result, SymbolAnalysisContext context);
    [CompilerGeneratedAttribute]
private HashSet`1<string> <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__23_0(SymbolStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private bool <InitializeWorker>g__ShouldAnalyze|23_4(SymbolStartAnalysisContext context, INamedTypeSymbol namedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyCodeFixProvider`5 : CodeFixProvider {
    protected static SyntaxAnnotation SpecializedFormattingAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static AbstractUseAutoPropertyCodeFixProvider`5();
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual TPropertyDeclaration GetPropertyDeclaration(SyntaxNode node);
    protected abstract virtual SyntaxNode GetNodeToRemove(TVariableDeclarator declarator);
    protected abstract virtual ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected abstract virtual Task`1<SyntaxNode> UpdatePropertyAsync(Document propertyDocument, Compilation compilation, IFieldSymbol fieldSymbol, IPropertySymbol propertySymbol, TPropertyDeclaration propertyDeclaration, bool isWrittenOutsideConstructor, CancellationToken cancellationToken);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyCodeFixProvider`5/<ProcessResultAsync>d__9")]
private Task`1<Solution> ProcessResultAsync(CodeFixContext context, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxRemoveOptions CreateSyntaxRemoveOptions(SyntaxNode nodeToRemove);
    private static bool WillRemoveFirstFieldInTypeDirectlyAboveProperty(ISyntaxFactsService syntaxFacts, TPropertyDeclaration property, SyntaxNode fieldToRemove);
    private static bool CanEditDocument(Solution solution, DocumentId documentId, HashSet`1<DocumentId> linkedDocuments, Dictionary`2<DocumentId, bool> canEdit);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseAutoProperty.AbstractUseAutoPropertyCodeFixProvider`5/<FormatAsync>d__13")]
private Task`1<SyntaxNode> FormatAsync(SyntaxNode newRoot, Document document, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static bool IsWrittenToOutsideOfConstructorOrProperty(IFieldSymbol field, LightweightRenameLocations renameLocations, TPropertyDeclaration propertyDeclaration, CancellationToken cancellationToken);
    private static bool IsWrittenToOutsideOfConstructorOrProperty(Solution solution, RenameLocation location, TPropertyDeclaration propertyDeclaration, ISet`1<ValueTuple`2<string, TextSpan>> constructorSpans, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer`6 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual bool IsTargetTyped(SemanticModel semanticModel, TConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCoalesceExpression.AbstractUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer`4 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual bool IsTargetTyped(SemanticModel semanticModel, TConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForIfNullStatementCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FixAllAsync>g__GetWhenNullExpression|4_0(SyntaxNode whenTrueStatement, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForNullableTernaryConditionalCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForNullableTernaryConditionalCheckCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForTernaryConditionalCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCoalesceExpression.UseCoalesceExpressionForTernaryConditionalCheckCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void ApplyEdit(SyntaxEditor editor, SemanticModel semanticModel, INamedTypeSymbol expressionTypeOpt, ISyntaxFactsService syntaxFacts, ISemanticFactsService semanticFacts, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxNode GetCoalesceExpression(ISyntaxFactsService syntaxFacts, SyntaxGenerator generator, SyntaxNode whenPart, SyntaxNode whenTrue, SyntaxNode conditionalPartLow, SyntaxNode currentWhenTrue, SyntaxNode currentWhenFalse);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionExpression.AbstractUseCollectionExpressionCodeFixProvider`1 : ForkingSyntaxEditorBasedCodeFixProvider`1<TExpressionSyntax> {
    private string _title;
    private string _titleChangesSemantics;
    private string _equivalenceKey;
    private string _equivalenceKeyChangesSemantics;
    protected AbstractUseCollectionExpressionCodeFixProvider`1(string title, string equivalenceKey);
    protected virtual ValueTuple`2<string, string> GetTitleAndEquivalenceKey(CodeFixContext context);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractObjectCreationExpressionAnalyzer`7 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax> State;
    protected TObjectCreationExpressionSyntax _objectCreationExpression;
    protected bool _analyzeForCollectionExpression;
    private static ObjectPool`1<TAnalyzer> s_pool;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected SemanticModel SemanticModel { get; }
    private static AbstractObjectCreationExpressionAnalyzer`7();
    protected ISyntaxFacts get_SyntaxFacts();
    protected SemanticModel get_SemanticModel();
    protected abstract virtual bool ShouldAnalyze(CancellationToken cancellationToken);
    protected abstract virtual bool TryAddMatches(ArrayBuilder`1<TMatch> matches, CancellationToken cancellationToken);
    protected abstract virtual bool IsInitializerOfLocalDeclarationStatement(TLocalDeclarationStatementSyntax localDeclarationStatement, TObjectCreationExpressionSyntax rootExpression, TVariableDeclaratorSyntax& variableDeclarator);
    public static TAnalyzer Allocate();
    public sealed virtual void Dispose();
    public void Initialize(UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax> state, TObjectCreationExpressionSyntax objectCreationExpression, bool analyzeForCollectionExpression);
    protected void Clear();
    protected ImmutableArray`1<TMatch> AnalyzeWorker(CancellationToken cancellationToken);
    protected Nullable`1<UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax>> TryInitializeState(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax rootExpression, bool analyzeForCollectionExpression, CancellationToken cancellationToken);
    private Nullable`1<UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax>> TryInitializeVariableDeclarationCase(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax rootExpression, TStatementSyntax containingStatement, CancellationToken cancellationToken);
    private static Nullable`1<UpdateExpressionState`2<TExpressionSyntax, TStatementSyntax>> TryInitializeAssignmentCase(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax rootExpression, TStatementSyntax containingStatement, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerAnalyzer`9 : AbstractObjectCreationExpressionAnalyzer`7<TExpressionSyntax, TStatementSyntax, TObjectCreationExpressionSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, Match`1<TStatementSyntax>, TAnalyzer> {
    protected IUpdateExpressionSyntaxHelper`2<TExpressionSyntax, TStatementSyntax> SyntaxHelper { get; }
    protected abstract virtual bool IsComplexElementInitializer(SyntaxNode expression);
    protected abstract virtual bool HasExistingInvalidInitializerForCollection();
    protected abstract virtual bool ValidateMatchesForCollectionExpression(ArrayBuilder`1<Match`1<TStatementSyntax>> matches, CancellationToken cancellationToken);
    protected abstract virtual IUpdateExpressionSyntaxHelper`2<TExpressionSyntax, TStatementSyntax> get_SyntaxHelper();
    public ImmutableArray`1<Match`1<TStatementSyntax>> Analyze(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax objectCreationExpression, bool analyzeForCollectionExpression, CancellationToken cancellationToken);
    protected sealed virtual bool TryAddMatches(ArrayBuilder`1<Match`1<TStatementSyntax>> matches, CancellationToken cancellationToken);
    private Nullable`1<Match`1<TStatementSyntax>> TryAnalyzeStatement(TStatementSyntax statement, Boolean& seenInvocation, Boolean& seenIndexAssignment, CancellationToken cancellationToken);
    private Nullable`1<Match`1<TStatementSyntax>> TryAnalyzeStatementForCollectionInitializer(TStatementSyntax statement, Boolean& seenInvocation, Boolean& seenIndexAssignment, CancellationToken cancellationToken);
    protected sealed virtual bool ShouldAnalyze(CancellationToken cancellationToken);
    private bool TryAnalyzeIndexAssignment(TExpressionStatementSyntax statement, CancellationToken cancellationToken, TExpressionSyntax& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerCodeFixProvider`10 : AbstractUseCollectionExpressionCodeFixProvider`1<TObjectCreationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual TAnalyzer GetAnalyzer();
    protected abstract virtual Task`1<ValueTuple`2<SyntaxNode, SyntaxNode>> GetReplacementNodesAsync(Document document, CodeActionOptionsProvider fallbackOptions, TObjectCreationExpressionSyntax objectCreation, bool useCollectionExpression, ImmutableArray`1<Match`1<TStatementSyntax>> matches, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerCodeFixProvider`10/<FixAsync>d__5")]
protected sealed virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, TObjectCreationExpressionSyntax objectCreation, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCollectionInitializer.AbstractUseCollectionInitializerDiagnosticAnalyzer`10 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_descriptor;
    private static DiagnosticDescriptor s_unnecessaryCodeDescriptor;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractUseCollectionInitializerDiagnosticAnalyzer`10();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual bool AreCollectionInitializersSupported(Compilation compilation);
    protected abstract virtual bool AreCollectionExpressionsSupported(Compilation compilation);
    protected abstract virtual bool CanUseCollectionExpression(SemanticModel semanticModel, TObjectCreationExpressionSyntax objectCreationExpression, INamedTypeSymbol expressionType, bool allowSemanticsChange, CancellationToken cancellationToken, Boolean& changesSemantics);
    protected abstract virtual TAnalyzer GetAnalyzer();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol ienumerableType, INamedTypeSymbol expressionType);
    private void FadeOutCode(SyntaxNodeAnalysisContext context, ImmutableArray`1<Match`1<TStatementSyntax>> matches, ImmutableArray`1<Location> locations, ImmutableDictionary`2<string, string> properties);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`3<ImmutableArray`1<Match`1<TStatementSyntax>>, bool, bool>> <AnalyzeNode>g__GetCollectionInitializerMatches|12_1(<>c__DisplayClass12_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`3<ImmutableArray`1<Match`1<TStatementSyntax>>, bool, bool>> <AnalyzeNode>g__GetCollectionExpressionMatches|12_2(<>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.UseCollectionInitializer.IUpdateExpressionSyntaxHelper`2 {
    public abstract virtual void GetPartsOfForeachStatement(TStatementSyntax statement, SyntaxToken& awaitKeyword, SyntaxToken& identifier, TExpressionSyntax& expression, IEnumerable`1& statements);
    public abstract virtual void GetPartsOfIfStatement(TStatementSyntax statement, TExpressionSyntax& condition, IEnumerable`1& whenTrueStatements, IEnumerable`1& whenFalseStatements);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.UseCollectionInitializer.Match`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TStatementSyntax <Statement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSpread>k__BackingField;
    [NullableAttribute("1")]
public TStatementSyntax Statement { get; public set; }
    public bool UseSpread { get; public set; }
    [NullableContextAttribute("1")]
public Match`1(TStatementSyntax Statement, bool UseSpread);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TStatementSyntax get_Statement();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Statement(TStatementSyntax value);
    [CompilerGeneratedAttribute]
public bool get_UseSpread();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseSpread(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Match`1<TStatementSyntax> left, Match`1<TStatementSyntax> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Match`1<TStatementSyntax> left, Match`1<TStatementSyntax> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Match`1<TStatementSyntax> other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(TStatementSyntax& Statement, Boolean& UseSpread);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.UseCollectionInitializer.UpdateExpressionState`2 : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, bool>> s_multiAddNames;
    public SemanticModel SemanticModel;
    public ISyntaxFacts SyntaxFacts;
    public TExpressionSyntax StartExpression;
    [NullableAttribute("2")]
public TStatementSyntax ContainingStatement;
    public SyntaxNodeOrToken ValuePattern;
    [NullableAttribute("2")]
public ISymbol InitializedSymbol;
    public UpdateExpressionState`2(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TExpressionSyntax startExpression, SyntaxNodeOrToken valuePattern, ISymbol initializedSymbol);
    private static UpdateExpressionState`2();
    public IEnumerable`1<TStatementSyntax> GetSubsequentStatements();
    public bool ValuePatternMatches(TExpressionSyntax expression);
    public bool NodeContainsValuePatternOrReferencesInitializedSymbol(SyntaxNode expression, CancellationToken cancellationToken);
    public bool TryAnalyzeInvocationForCollectionExpression(TExpressionSyntax invocationExpression, bool allowLinq, CancellationToken cancellationToken, TExpressionSyntax& instance, Boolean& useSpread);
    [NullableContextAttribute("2")]
public bool TryAnalyzeAddInvocation(TExpressionSyntax invocationExpression, string requiredArgumentName, bool forCollectionExpression, CancellationToken cancellationToken, TExpressionSyntax& instance);
    private bool TryAnalyzeMultiAddInvocation(TExpressionSyntax invocationExpression, string methodName, string requiredArgumentName, CancellationToken cancellationToken, TExpressionSyntax& instance, Boolean& useSpread);
    private bool TryAnalyzeInvocation(TExpressionSyntax invocationExpression, string methodName, string requiredArgumentName, CancellationToken cancellationToken, TExpressionSyntax& instance, SeparatedSyntaxList`1& arguments);
    public Nullable`1<Match`1<TStatementSyntax>> TryAnalyzeStatementForCollectionExpression(IUpdateExpressionSyntaxHelper`2<TExpressionSyntax, TStatementSyntax> syntaxHelper, TStatementSyntax statement, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Nullable`1<Match`1<TStatementSyntax>> <TryAnalyzeStatementForCollectionExpression>g__TryAnalyzeExpressionStatement|15_0(TStatementSyntax expressionStatement, <>c__DisplayClass15_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Nullable`1<Match`1<TStatementSyntax>> <TryAnalyzeStatementForCollectionExpression>g__TryAnalyzeForeachStatement|15_1(TStatementSyntax foreachStatement, <>c__DisplayClass15_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Nullable`1<Match`1<TStatementSyntax>> <TryAnalyzeStatementForCollectionExpression>g__TryAnalyzeIfStatement|15_2(TStatementSyntax ifStatement, <>c__DisplayClass15_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseCollectionInitializer.UseCollectionInitializerHelpers : object {
    public static string UseCollectionExpressionName;
    public static string ChangesSemanticsName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableDictionary`2<string, string> UseCollectionExpressionProperties;
    private static UseCollectionInitializerHelpers();
    public static ImmutableArray`1<Location> GetLocationsToFade(ISyntaxFacts syntaxFacts, Match`1<TStatementSyntax> matchInfo);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.UseCollectionInitializer.UseCollectionInitializerHelpers/<GetSubsequentStatements>d__4`1")]
public static IEnumerable`1<TStatementSyntax> GetSubsequentStatements(ISyntaxFacts syntaxFacts, TStatementSyntax initialStatement);
    public static bool ChangesSemantics(Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentCodeFixProvider`3 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _binaryToAssignmentMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _assignmentToTokenMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("0")]
protected AbstractUseCompoundAssignmentCodeFixProvider`3(ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("0")]
protected abstract virtual SyntaxToken Token(TSyntaxKind kind);
    protected abstract virtual TAssignmentSyntax Assignment(TSyntaxKind assignmentOpKind, TExpressionSyntax left, SyntaxToken syntaxToken, TExpressionSyntax right);
    protected abstract virtual TExpressionSyntax Increment(TExpressionSyntax left, bool postfix);
    protected abstract virtual TExpressionSyntax Decrement(TExpressionSyntax left, bool postfix);
    protected abstract virtual SyntaxTriviaList PrepareRightExpressionLeadingTrivia(SyntaxTriviaList initialTrivia);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool PreferPostfix(ISyntaxFactsService syntaxFacts, TAssignmentSyntax currentAssignment);
}
internal abstract class Microsoft.CodeAnalysis.UseCompoundAssignment.AbstractUseCompoundAssignmentDiagnosticAnalyzer`3 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("1")]
private ISyntaxFacts _syntaxFacts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<TSyntaxKind, TSyntaxKind> _binaryToAssignmentMap;
    [NullableAttribute("1")]
private DiagnosticDescriptor _incrementDescriptor;
    [NullableAttribute("1")]
private DiagnosticDescriptor _decrementDescriptor;
    protected AbstractUseCompoundAssignmentDiagnosticAnalyzer`3(ISyntaxFacts syntaxFacts, ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds);
    protected abstract virtual TSyntaxKind GetAnalysisKind();
    protected abstract virtual bool IsSupported(TSyntaxKind assignmentKind, ParseOptions options);
    protected abstract virtual int TryGetIncrementOrDecrement(TSyntaxKind opKind, object constantValue);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeAssignment(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseCompoundAssignment.UseCompoundAssignmentUtilities : object {
    internal static string Increment;
    internal static string Decrement;
    [NullableContextAttribute("0")]
public static void GenerateMaps(ImmutableArray`1<ValueTuple`3<TSyntaxKind, TSyntaxKind, TSyntaxKind>> kinds, ImmutableDictionary`2& binaryToAssignmentMap, ImmutableDictionary`2& assignmentToTokenMap);
    public static bool IsSideEffectFree(ISyntaxFacts syntaxFacts, SyntaxNode expr, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsSideEffectFreeRecurse(ISyntaxFacts syntaxFacts, SyntaxNode expr, SemanticModel semanticModel, bool isTopLevel, CancellationToken cancellationToken);
    private static bool IsSideEffectFreeSymbol(SyntaxNode expr, SemanticModel semanticModel, bool isTopLevel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4 : SyntaxEditorBasedCodeFixProvider {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected abstract virtual ISyntaxFormatting GetSyntaxFormatting();
    protected abstract virtual TExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    protected abstract virtual TStatementSyntax WrapWithBlockIfAppropriate(TIfStatementSyntax ifStatement, TStatementSyntax statement);
    protected abstract virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<CreateConditionalExpressionAsync>d__8")]
protected Task`1<TExpressionSyntax> CreateConditionalExpressionAsync(Document document, IConditionalOperation ifOperation, IOperation trueStatement, IOperation falseStatement, IOperation trueValue, IOperation falseValue, bool isRef, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    protected virtual SyntaxNode WrapIfStatementIfNecessary(IConditionalOperation operation);
    protected virtual TExpressionSyntax WrapReturnExpressionIfNecessary(TExpressionSyntax returnExpression, IOperation returnOperation);
    private static TExpressionSyntax MakeRef(SyntaxGeneratorInternal generator, bool isRef, TExpressionSyntax syntaxNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionCodeFixProvider`4/<MakeMultiLineAsync>d__12")]
private static Task`1<bool> MakeMultiLineAsync(Document document, SyntaxNode condition, SyntaxNode trueSyntax, SyntaxNode falseSyntax, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private TExpressionSyntax CastValueIfNecessary(SyntaxGenerator generator, IOperation statement, IOperation value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractUseConditionalExpressionDiagnosticAnalyzer`1(string descriptorId, EnforceOnBuild enforceOnBuild, LocalizableResourceString message, PerLanguageOption2`1<CodeStyleOption2`1<bool>> option);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual ValueTuple`2<bool, bool> TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
    protected abstract virtual CodeStyleOption2`1<bool> GetStylePreference(OperationAnalysisContext context);
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6 : AbstractUseConditionalExpressionCodeFixProvider`4<TStatementSyntax, TIfStatementSyntax, TExpressionSyntax, TConditionalExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual TVariableDeclaratorSyntax WithInitializer(TVariableDeclaratorSyntax variable, TExpressionSyntax value);
    protected abstract virtual TVariableDeclaratorSyntax GetDeclaratorSyntax(IVariableDeclaratorOperation declarator);
    protected abstract virtual TLocalDeclarationStatementSyntax AddSimplificationToType(TLocalDeclarationStatementSyntax updatedLocalDeclaration);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6/<FixOneAsync>d__6")]
protected virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private void ConvertOnlyIfToConditionalExpression(SyntaxEditor editor, IConditionalOperation ifOperation, ISimpleAssignmentOperation assignment, TExpressionSyntax conditionalExpression);
    private bool TryConvertWhenAssignmentToLocalDeclaredImmediateAbove(ISyntaxFactsService syntaxFacts, SyntaxEditor editor, IConditionalOperation ifOperation, ISimpleAssignmentOperation trueAssignment, ISimpleAssignmentOperation falseAssignment, TExpressionSyntax conditionalExpression);
    [NullableContextAttribute("2")]
private static bool TryFindMatchingLocalDeclarationImmediatelyAbove(IConditionalOperation ifOperation, ISimpleAssignmentOperation trueAssignment, ISimpleAssignmentOperation falseAssignment, IVariableDeclarationGroupOperation& localDeclaration, IVariableDeclaratorOperation& declarator);
    private static bool ReferencesLocalVariable(IOperation operation, ILocalSymbol variable);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1 : AbstractUseConditionalExpressionDiagnosticAnalyzer`1<TIfStatementSyntax> {
    protected AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1(LocalizableResourceString message);
    protected sealed virtual CodeStyleOption2`1<bool> GetStylePreference(OperationAnalysisContext context);
    protected virtual ValueTuple`2<bool, bool> TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnCodeFixProvider`4 : AbstractUseConditionalExpressionCodeFixProvider`4<TStatementSyntax, TIfStatementSyntax, TExpressionSyntax, TConditionalExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnCodeFixProvider`4/<FixOneAsync>d__3")]
protected virtual Task FixOneAsync(Document document, Diagnostic diagnostic, SyntaxEditor editor, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseConditionalExpression.AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1 : AbstractUseConditionalExpressionDiagnosticAnalyzer`1<TIfStatementSyntax> {
    protected AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1(LocalizableResourceString message);
    protected sealed virtual CodeStyleOption2`1<bool> GetStylePreference(OperationAnalysisContext context);
    protected sealed virtual ValueTuple`2<bool, bool> TryMatchPattern(IConditionalOperation ifOperation, ISymbol containingSymbol);
    protected virtual bool IsStatementSupported(IOperation statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionCodeFixHelpers : object {
    public static SyntaxAnnotation SpecializedFormattingAnnotation;
    private static UseConditionalExpressionCodeFixHelpers();
    public static SyntaxRemoveOptions GetRemoveOptions(ISyntaxFactsService syntaxFacts, SyntaxNode syntax);
}
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionForAssignmentHelpers : object {
    [NullableContextAttribute("1")]
public static bool TryMatchPattern(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, Boolean& isRef, IOperation& trueStatement, IOperation& falseStatement, ISimpleAssignmentOperation& trueAssignment, ISimpleAssignmentOperation& falseAssignment);
    [NullableContextAttribute("2")]
private static bool TryGetAssignmentOrThrow(IOperation statement, ISimpleAssignmentOperation& assignment, IThrowOperation& throwOperation);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryMatchPattern>g__AreEqualOrHaveImplicitConversion|0_0(ITypeSymbol firstType, ITypeSymbol secondType, Compilation compilation);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryMatchPattern>g__ReferencesDeclaredVariableInAssignment|0_1(IOperation condition, IOperation trueTarget, IOperation falseTarget);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <TryMatchPattern>g__ContainsLocalReference|0_2(HashSet`1<ILocalSymbol> declaredPatternSymbols, IOperation target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionForReturnHelpers : object {
    public static bool TryMatchPattern(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, ISymbol containingSymbol, Boolean& isRef, IOperation& trueStatement, IOperation& falseStatement, IReturnOperation& trueReturn, IReturnOperation& falseReturn);
    private static bool IsReturnExprOrThrow(IOperation statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseConditionalExpression.UseConditionalExpressionHelpers : object {
    public static string CanSimplifyName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableDictionary`2<string, string> CanSimplifyProperties;
    private static UseConditionalExpressionHelpers();
    public static bool CanConvert(ISyntaxFacts syntaxFacts, IConditionalOperation ifOperation, IOperation whenTrue, IOperation whenFalse);
    [NullableContextAttribute("2")]
public static IOperation UnwrapSingleStatementBlock(IOperation statement);
    public static bool HasRegularComments(ISyntaxFacts syntaxFacts, SyntaxNode syntax);
    public static bool HasRegularCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTriviaList triviaList);
    [NullableContextAttribute("2")]
public static bool HasInconvertibleThrowStatement(ISyntaxFacts syntaxFacts, bool isRef, IThrowOperation trueThrow, IThrowOperation falseThrow);
    public static bool IsBooleanLiteral(IOperation trueValue, bool val);
    public static bool CanSimplify(IOperation trueValue, IOperation falseValue, bool isRef, Boolean& negate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseExplicitTupleName.UseExplicitTupleNameCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.UseExplicitTupleName.UseExplicitTupleNameDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string ElementName;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context);
    private static IFieldSymbol GetNamedField(INamedTypeSymbol containingType, IFieldSymbol unnamedField, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseInferredMemberName.AbstractUseInferredMemberNameCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual void LanguageSpecificRemoveSuggestedNode(SyntaxEditor editor, SyntaxNode node);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.UseInferredMemberName.AbstractUseInferredMemberNameDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    protected abstract virtual void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseIsNullCheck.AbstractUseIsNullCheckForReferenceEqualsCodeFixProvider`1 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual string GetTitle(bool negated, ParseOptions options);
    protected abstract virtual SyntaxNode CreateNullCheck(TExpressionSyntax argument, bool isUnconstrainedGeneric);
    protected abstract virtual SyntaxNode CreateNotNullCheck(TExpressionSyntax argument);
    private static bool IsSupportedDiagnostic(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseIsNullCheck.AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1(LocalizableString title);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool IsLanguageVersionSupported(Compilation compilation);
    protected abstract virtual bool IsUnconstrainedGenericSupported(Compilation compilation);
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context, IMethodSymbol referenceEqualsMethod, bool unconstraintedGenericSupported);
    private static ITypeParameterSymbol GetGenericParameterSymbol(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, SyntaxNode node1, SyntaxNode node2, CancellationToken cancellationToken);
    private static bool MatchesPattern(ISyntaxFacts syntaxFacts, SyntaxNode node1, SyntaxNode node2);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.UseIsNullCheck.UseIsNullConstants : object {
    public static string Kind;
    public static string ReferenceEqualsKey;
    public static string CastAndEqualityKey;
    public static string Negated;
    public static string UnconstrainedGeneric;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseNamedArguments.AbstractUseNamedArgumentsCodeRefactoringProvider : CodeRefactoringProvider {
    private IAnalyzer _argumentAnalyzer;
    private IAnalyzer _attributeArgumentAnalyzer;
    protected AbstractUseNamedArgumentsCodeRefactoringProvider(IAnalyzer argumentAnalyzer, IAnalyzer attributeArgumentAnalyzer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseNamedArguments.AbstractUseNamedArgumentsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationCodeFixProvider`13 : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("2")]
protected abstract virtual bool TryGetBlock(SyntaxNode node, TStatementSyntax& block);
    protected abstract virtual TStatementSyntax ReplaceBlockStatements(TStatementSyntax block, TStatementSyntax newInnerStatement);
    protected abstract virtual SyntaxNode PostProcessElseIf(TIfStatementSyntax ifStatement, TStatementSyntax newWhenTrueStatement);
    protected abstract virtual TElementBindingExpressionSyntax ElementBindingExpression(TElementBindingArgumentListSyntax argumentList);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationCodeFixProvider`13/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private void FixConditionalExpression(Document document, SyntaxEditor editor, SemanticModel semanticModel, Diagnostic diagnostic, SyntaxNode conditionalExpression, CancellationToken cancellationToken);
    private void FixIfStatement(Document document, SyntaxEditor editor, Diagnostic diagnostic, TIfStatementSyntax ifStatement);
    private TContainer CreateConditionalAccessExpression(ISyntaxFactsService syntaxFacts, SyntaxGeneratorInternal generator, bool whenPartIsNullable, TContainer container, SyntaxNode match);
    private TContainer CreateConditionalAccessExpression(ISyntaxFactsService syntaxFacts, SyntaxGeneratorInternal generator, TContainer whenPart, SyntaxNode match, SyntaxNode matchParent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseNullPropagation.AbstractUseNullPropagationDiagnosticAnalyzer`11 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_whenPartIsNullableProperties;
    [NullableAttribute("0")]
protected TSyntaxKind IfStatementSyntaxKind { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    private static AbstractUseNullPropagationDiagnosticAnalyzer`11();
    [NullableContextAttribute("2")]
protected abstract virtual bool TryGetPartsOfIfStatement(TIfStatementSyntax ifStatement, TExpressionSyntax& condition, TStatementSyntax& trueStatement);
    [NullableContextAttribute("2")]
private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context, IMethodSymbol referenceEqualsMethod);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected abstract virtual bool ShouldAnalyze(Compilation compilation);
    [NullableContextAttribute("0")]
protected abstract virtual TSyntaxKind get_IfStatementSyntaxKind();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual bool TryAnalyzePatternCondition(ISyntaxFacts syntaxFacts, TExpressionSyntax conditionNode, TExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeTernaryConditionalExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType, IMethodSymbol referenceEqualsMethod);
    private bool TryAnalyzeCondition(SyntaxNodeAnalysisContext context, ISyntaxFacts syntaxFacts, IMethodSymbol referenceEqualsMethod, TExpressionSyntax condition, TExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    private static bool TryAnalyzeBinaryExpressionCondition(ISyntaxFacts syntaxFacts, TBinaryExpressionSyntax condition, TExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    private static bool TryAnalyzeInvocationCondition(SyntaxNodeAnalysisContext context, ISyntaxFacts syntaxFacts, IMethodSymbol referenceEqualsMethod, TInvocationExpressionSyntax invocation, TExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    private static TExpressionSyntax GetConditionPartToCheck(ISyntaxFacts syntaxFacts, TExpressionSyntax conditionLeft, TExpressionSyntax conditionRight);
    internal static TExpressionSyntax GetWhenPartMatch(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, TExpressionSyntax expressionToMatch, TExpressionSyntax whenPart, CancellationToken cancellationToken);
    private static TExpressionSyntax RemoveObjectCastIfAny(ISyntaxFacts syntaxFacts, SemanticModel semanticModel, TExpressionSyntax node, CancellationToken cancellationToken);
    private static TExpressionSyntax Unwrap(ISyntaxFacts syntaxFacts, TExpressionSyntax node);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__13_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.UseNullPropagation.UseNullPropagationConstants : object {
    [NullableAttribute("1")]
public static string WhenPartIsNullable;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseNamedMemberInitializerAnalyzer`8 : AbstractObjectCreationExpressionAnalyzer`7<TExpressionSyntax, TStatementSyntax, TObjectCreationExpressionSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax, Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>, TAnalyzer> {
    public ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> Analyze(SemanticModel semanticModel, ISyntaxFacts syntaxFacts, TObjectCreationExpressionSyntax objectCreationExpression, CancellationToken cancellationToken);
    protected sealed virtual bool ShouldAnalyze(CancellationToken cancellationToken);
    protected sealed virtual bool TryAddMatches(ArrayBuilder`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsExplicitlyImplemented(ITypeSymbol classOrStructType, ISymbol member, ISymbol& typeMember);
    private bool ImplicitMemberAccessWouldBeAffected(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerCodeFixProvider`9 : ForkingSyntaxEditorBasedCodeFixProvider`1<TObjectCreationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected virtual ValueTuple`2<string, string> GetTitleAndEquivalenceKey(CodeFixContext context);
    protected abstract virtual TAnalyzer GetAnalyzer();
    protected abstract virtual TStatementSyntax GetNewStatement(TStatementSyntax statement, TObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerCodeFixProvider`9/<FixAsync>d__5")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, TObjectCreationExpressionSyntax objectCreation, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseObjectInitializer.AbstractUseObjectInitializerDiagnosticAnalyzer`9 : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_descriptor;
    private static DiagnosticDescriptor s_unnecessaryCodeDescriptor;
    protected bool FadeOutOperatorToken { get; }
    private static AbstractUseObjectInitializerDiagnosticAnalyzer`9();
    protected abstract virtual bool get_FadeOutOperatorToken();
    protected abstract virtual TAnalyzer GetAnalyzer();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    protected abstract virtual bool AreObjectInitializersSupported(Compilation compilation);
    protected abstract virtual bool IsValidContainingStatement(TStatementSyntax node);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private void FadeOutCode(SyntaxNodeAnalysisContext context, ImmutableArray`1<Match`4<TExpressionSyntax, TStatementSyntax, TMemberAccessExpressionSyntax, TAssignmentStatementSyntax>> matches, ImmutableArray`1<Location> locations);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__7_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.UseObjectInitializer.Match`4 : ValueType {
    public TAssignmentStatementSyntax Statement;
    public TMemberAccessExpressionSyntax MemberAccessExpression;
    public TExpressionSyntax Initializer;
    public string MemberName;
    public Match`4(TAssignmentStatementSyntax statement, TMemberAccessExpressionSyntax memberAccessExpression, TExpressionSyntax initializer, string memberName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.UseSystemHashCode.UseSystemHashCodeDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeOperationBlock(HashCodeAnalyzer analyzer, OperationBlockAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.UseThrowExpression.AbstractUseThrowExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected ISemanticFacts SemanticFacts { get; }
    protected AbstractUseThrowExpressionDiagnosticAnalyzer(Option2`1<CodeStyleOption2`1<bool>> preferThrowExpressionOption);
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected abstract virtual CodeStyleOption2`1<bool> PreferThrowExpressionStyle(OperationAnalysisContext context);
    protected abstract virtual bool IsSupported(Compilation compilation);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeOperation(OperationAnalysisContext context, INamedTypeSymbol expressionType);
    private static bool ValueIsAccessed(SemanticModel semanticModel, IConditionalOperation ifOperation, IBlockOperation containingBlock, ISymbol localOrParameter, IExpressionStatementOperation expressionStatement, IAssignmentOperation assignmentExpression);
    private static bool TryFindAssignmentExpression(IBlockOperation containingBlock, IConditionalOperation ifOperation, ISymbol localOrParameter, IExpressionStatementOperation& expressionStatement, IAssignmentOperation& assignmentExpression);
    private static bool TryDecomposeIfCondition(IConditionalOperation ifStatement, ISymbol& localOrParameter);
    private static bool TryGetLocalOrParameterSymbol(IOperation operation, ISymbol& localOrParameter);
    private static bool IsNull(IOperation operation);
    private static IConditionalOperation GetContainingIfOperation(SemanticModel semanticModel, IThrowOperation throwOperation, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__6_0(CompilationStartAnalysisContext startContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ValidateFormatString.AbstractValidateFormatStringDiagnosticAnalyzer`1 : DiagnosticAnalyzer {
    private static string DiagnosticID;
    private static LocalizableString Title;
    private static LocalizableString MessageFormat;
    private static DiagnosticDescriptor Rule;
    private static Regex s_removeEscapedBracketsRegex;
    private static Regex s_extractPlaceholdersRegex;
    private static string NameOfArgsParameter;
    private static string NameOfFormatStringParameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AbstractValidateFormatStringDiagnosticAnalyzer`1();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual ISyntaxFacts GetSyntaxFacts();
    protected abstract virtual SyntaxNode GetArgumentExpression(SyntaxNode syntaxNode);
    protected abstract virtual SyntaxNode TryGetMatchingNamedArgument(SeparatedSyntaxList`1<SyntaxNode> arguments, string searchArgumentName);
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol formatProviderType);
    private static bool IsValidFormatMethod(ISyntaxFacts syntaxFacts, SyntaxNode expression);
    private bool ArgsIsArrayOfReferenceTypes(SemanticModel semanticModel, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    private ITypeSymbol TryGetArgsArgumentType(SemanticModel semanticModel, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    protected SyntaxNode TryGetArgument(string searchArgumentName, SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters);
    private static IParameterSymbol GetParameterWithMatchingName(ImmutableArray`1<IParameterSymbol> parameters, string searchArgumentName);
    protected SyntaxNode TryGetFormatStringLiteralExpressionSyntax(SeparatedSyntaxList`1<SyntaxNode> arguments, ImmutableArray`1<IParameterSymbol> parameters, ISyntaxFacts syntaxFacts);
    [NullableContextAttribute("2")]
protected static IMethodSymbol TryGetValidFormatMethodSymbol(SymbolInfo symbolInfo);
    private static bool FormatCallWorksAtRuntime(string formatString, int numberOfPlaceholderArguments);
    protected static void ValidateAndReportDiagnostic(SyntaxNodeAnalysisContext context, int numberOfPlaceholderArguments, string formatString, int formatStringPosition);
    private static string RemoveEscapedBrackets(string formatString);
    private static bool PlaceholderIndexIsValid(string textInsideBrackets, int numberOfPlaceholderArguments);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_0(CompilationStartAnalysisContext startContext);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ValueTracking.IRemoteValueTrackingService {
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableValueTrackedItem>> TrackValueSourceAsync(Checksum solutionChecksum, TextSpan selection, DocumentId document, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableValueTrackedItem>> TrackValueSourceAsync(Checksum solutionChecksum, SerializableValueTrackedItem previousTrackedItem, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ValueTracking.IValueTrackingService {
    public abstract virtual Task`1<ImmutableArray`1<ValueTrackedItem>> TrackValueSourceAsync(TextSpan selection, Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<ValueTrackedItem>> TrackValueSourceAsync(Solution solution, ValueTrackedItem previousTrackedItem, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ValueTracking.SerializableValueTrackedItem : object {
    [CompilerGeneratedAttribute]
private SymbolKey <SymbolKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SerializableValueTrackedItem <Parent>k__BackingField;
    [DataMemberAttribute]
public SymbolKey SymbolKey { get; }
    [DataMemberAttribute]
public TextSpan TextSpan { get; }
    [DataMemberAttribute]
public DocumentId DocumentId { get; }
    [NullableAttribute("2")]
[DataMemberAttribute]
public SerializableValueTrackedItem Parent { get; }
    public SerializableValueTrackedItem(SymbolKey symbolKey, TextSpan textSpan, DocumentId documentId, SerializableValueTrackedItem parent);
    [CompilerGeneratedAttribute]
public SymbolKey get_SymbolKey();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SerializableValueTrackedItem get_Parent();
    public static SerializableValueTrackedItem Dehydrate(Solution solution, ValueTrackedItem valueTrackedItem, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.SerializableValueTrackedItem/<RehydrateAsync>d__14")]
public ValueTask`1<ValueTrackedItem> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ValueTracking.ValueTrackedItem : object {
    [CompilerGeneratedAttribute]
private SymbolKey <SymbolKey>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ValueTrackedItem <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <SourceText>k__BackingField;
    [CompilerGeneratedAttribute]
private Glyph <Glyph>k__BackingField;
    public SymbolKey SymbolKey { get; }
    [NullableAttribute("2")]
public ValueTrackedItem Parent { get; }
    public DocumentId DocumentId { get; }
    public TextSpan Span { get; }
    public SourceText SourceText { get; }
    public Glyph Glyph { get; }
    internal ValueTrackedItem(SymbolKey symbolKey, SourceText sourceText, TextSpan textSpan, DocumentId documentId, Glyph glyph, ValueTrackedItem parent);
    [CompilerGeneratedAttribute]
public SymbolKey get_SymbolKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ValueTrackedItem get_Parent();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public SourceText get_SourceText();
    [CompilerGeneratedAttribute]
public Glyph get_Glyph();
    public virtual string ToString();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTrackedItem/<TryCreateAsync>d__20")]
public static ValueTask`1<ValueTrackedItem> TryCreateAsync(Solution solution, Location location, ISymbol symbol, ValueTrackedItem parent, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ValueTracking.ValueTracker : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<TrackValueSourceAsync>d__0")]
public static Task TrackValueSourceAsync(TextSpan selection, Document document, ValueTrackingProgressCollector progressCollector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<TrackValueSourceAsync>d__1")]
public static Task TrackValueSourceAsync(Solution solution, ValueTrackedItem previousTrackedItem, ValueTrackingProgressCollector progressCollector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<AddItemsFromAssignmentAsync>d__2")]
private static Task AddItemsFromAssignmentAsync(Document document, SyntaxNode lhsNode, OperationCollector collector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<TrackVariableReferencesAsync>d__3")]
private static Task TrackVariableReferencesAsync(ISymbol symbol, OperationCollector collector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<TrackParameterSymbolAsync>d__4")]
private static Task TrackParameterSymbolAsync(IParameterSymbol parameterSymbol, OperationCollector collector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<TrackMethodSymbolAsync>d__5")]
private static Task TrackMethodSymbolAsync(IMethodSymbol methodSymbol, OperationCollector collector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<GetSelectedSymbolAsync>d__6")]
private static Task`1<ValueTuple`2<ISymbol, SyntaxNode>> GetSelectedSymbolAsync(TextSpan textSpan, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<TrackVariableDefinitionsAsync>d__7")]
private static Task TrackVariableDefinitionsAsync(ISymbol symbol, OperationCollector collector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTracker/<GetSymbolAsync>d__8")]
private static Task`1<ISymbol> GetSymbolAsync(ValueTrackedItem item, Solution solution, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <TrackMethodSymbolAsync>g__HasAValueReturn|5_0(IMethodSymbol methodSymbol);
    [CompilerGeneratedAttribute]
internal static bool <TrackMethodSymbolAsync>g__HasAnOutOrRefParam|5_1(IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ValueTracking.ValueTrackingProgressCollector : object {
    private object _lock;
    private Stack`1<ValueTrackedItem> _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ValueTrackedItem> OnNewItem;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ValueTrackedItem <Parent>k__BackingField;
    [NullableAttribute("2")]
internal ValueTrackedItem Parent { get; internal set; }
    [CompilerGeneratedAttribute]
public void add_OnNewItem(EventHandler`1<ValueTrackedItem> value);
    [CompilerGeneratedAttribute]
public void remove_OnNewItem(EventHandler`1<ValueTrackedItem> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ValueTrackedItem get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Parent(ValueTrackedItem value);
    public sealed virtual void Report(ValueTrackedItem item);
    public ImmutableArray`1<ValueTrackedItem> GetItems();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTrackingProgressCollector/<TryReportAsync>d__11")]
internal Task`1<bool> TryReportAsync(Solution solution, Location location, ISymbol symbol, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.ValueTracking.IValueTrackingService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ValueTracking.ValueTrackingService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTrackingService/<TrackValueSourceAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<ValueTrackedItem>> TrackValueSourceAsync(TextSpan selection, Document document, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ValueTracking.ValueTrackingService/<TrackValueSourceAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<ValueTrackedItem>> TrackValueSourceAsync(Solution solution, ValueTrackedItem previousTrackedItem, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper : object {
    [CompilerGeneratedAttribute]
private IIndentationService <IndentationService>k__BackingField;
    protected IIndentationService IndentationService { get; }
    protected AbstractSyntaxWrapper(IIndentationService indentationService);
    [CompilerGeneratedAttribute]
protected IIndentationService get_IndentationService();
    public abstract virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode node, SyntaxWrappingOptions options, bool containsSyntaxError, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.AbstractSyntaxWrapper/<ContainsUnformattableContentAsync>d__6")]
protected static Task`1<bool> ContainsUnformattableContentAsync(Document document, IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens, CancellationToken cancellationToken);
    protected static bool ContainsOverlappingSyntaxError(SyntaxNode declaration, TextSpan headerSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Wrapping.AbstractWrappingCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISyntaxWrapper> _wrappers;
    protected AbstractWrappingCodeRefactoringProvider(ImmutableArray`1<ISyntaxWrapper> wrappers);
    protected abstract virtual SyntaxWrappingOptions GetWrappingOptions(IOptionsReader options, CodeActionOptions ideOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.AbstractWrappingCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1 : AbstractSyntaxWrapper {
    private ISyntaxFacts _syntaxFacts;
    private IPrecedenceService _precedenceService;
    protected AbstractBinaryExpressionWrapper`1(IIndentationService indentationService, ISyntaxFacts syntaxFacts, IPrecedenceService precedenceService);
    protected abstract virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.BinaryExpression.AbstractBinaryExpressionWrapper`1/<TryCreateComputerAsync>d__4")]
public sealed virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode node, SyntaxWrappingOptions options, bool containsSyntaxError, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private ImmutableArray`1<SyntaxNodeOrToken> GetExpressionsAndOperators(PrecedenceKind precedence, TBinaryExpressionSyntax binaryExpr);
    private void AddExpressionsAndOperators(PrecedenceKind precedence, SyntaxNode expr, ArrayBuilder`1<SyntaxNodeOrToken> result);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private bool <AddExpressionsAndOperators>g__IsValidBinaryExpression|6_0(PrecedenceKind precedence, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2 : AbstractSyntaxWrapper {
    private ISyntaxFacts _syntaxFacts;
    private int _dotToken;
    private int _questionToken;
    protected AbstractChainedExpressionWrapper`2(IIndentationService indentationService, ISyntaxFacts syntaxFacts);
    protected abstract virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.ChainedExpression.AbstractChainedExpressionWrapper`2/<TryCreateComputerAsync>d__5")]
public sealed virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode node, SyntaxWrappingOptions options, bool containsSyntaxError, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private ImmutableArray`1<ImmutableArray`1<SyntaxNodeOrToken>> GetChainChunks(SyntaxNode node);
    private void BreakPiecesIntoChunks(ArrayBuilder`1<SyntaxNodeOrToken> pieces, ArrayBuilder`1<ImmutableArray`1<SyntaxNodeOrToken>> chunks);
    private int FindNextChunkStart(ArrayBuilder`1<SyntaxNodeOrToken> pieces, bool firstChunk, int index);
    private static bool IsNode(ArrayBuilder`1<SyntaxNodeOrToken> pieces, int index);
    private static bool IsToken(int tokenKind, ArrayBuilder`1<SyntaxNodeOrToken> pieces, int index);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SyntaxNodeOrToken> GetSubRange(ArrayBuilder`1<SyntaxNodeOrToken> pieces, int start, int end);
    [NullableContextAttribute("2")]
private bool IsDecomposableChainPart(SyntaxNode node);
    private void Decompose(SyntaxNode node, ArrayBuilder`1<SyntaxNodeOrToken> pieces);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Wrapping.Edit : ValueType {
    public SyntaxToken Left;
    public SyntaxToken Right;
    public SyntaxTriviaList NewLeftTrailingTrivia;
    public SyntaxTriviaList NewRightLeadingTrivia;
    private Edit(SyntaxToken left, SyntaxTriviaList newLeftTrailingTrivia, SyntaxToken right, SyntaxTriviaList newRightLeadingTrivia);
    [NullableContextAttribute("1")]
public string GetNewTrivia();
    [NullableContextAttribute("1")]
private static void AppendTrivia(PooledStringBuilder result, SyntaxTriviaList triviaList);
    public static Edit DeleteBetween(SyntaxNodeOrToken left, SyntaxNodeOrToken right);
    public static Edit UpdateBetween(SyntaxNodeOrToken left, SyntaxTriviaList leftTrailingTrivia, SyntaxTrivia rightLeadingTrivia, SyntaxNodeOrToken right);
    public static Edit UpdateBetween(SyntaxNodeOrToken left, SyntaxTriviaList leftTrailingTrivia, SyntaxTriviaList rightLeadingTrivia, SyntaxNodeOrToken right);
}
internal interface Microsoft.CodeAnalysis.Wrapping.ICodeActionComputer {
    public abstract virtual Task`1<ImmutableArray`1<CodeAction>> GetTopLevelCodeActionsAsync();
}
internal interface Microsoft.CodeAnalysis.Wrapping.ISyntaxWrapper {
    public abstract virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode node, SyntaxWrappingOptions options, bool containsSyntaxError, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2 : AbstractSyntaxWrapper {
    protected string Unwrap_list { get; }
    protected string Wrap_long_list { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Indent_all_items { get; }
    protected string Align_wrapped_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Wrap_every_item { get; }
    public bool Supports_WrapEveryGroup_UnwrapFirst { get; }
    public bool Supports_UnwrapGroup_WrapFirst_IndentRest { get; }
    public bool Supports_WrapLongGroup_UnwrapFirst { get; }
    protected bool ShouldMoveCloseBraceToNewLine { get; }
    protected AbstractSeparatedSyntaxListWrapper`2(IIndentationService indentationService);
    protected abstract virtual string get_Unwrap_list();
    protected abstract virtual string get_Wrap_long_list();
    protected abstract virtual string get_Unwrap_and_indent_all_items();
    protected abstract virtual string get_Unwrap_all_items();
    protected abstract virtual string get_Indent_all_items();
    protected abstract virtual string get_Align_wrapped_items();
    protected abstract virtual string get_Indent_wrapped_items();
    protected abstract virtual string get_Wrap_every_item();
    public abstract virtual bool get_Supports_WrapEveryGroup_UnwrapFirst();
    public abstract virtual bool get_Supports_UnwrapGroup_WrapFirst_IndentRest();
    public abstract virtual bool get_Supports_WrapLongGroup_UnwrapFirst();
    protected abstract virtual bool get_ShouldMoveCloseBraceToNewLine();
    protected abstract virtual bool ShouldMoveOpenBraceToNewLine(SyntaxWrappingOptions options);
    protected abstract virtual SyntaxToken FirstToken(TListSyntax listSyntax);
    protected abstract virtual SyntaxToken LastToken(TListSyntax listSyntax);
    protected abstract virtual TListSyntax TryGetApplicableList(SyntaxNode node);
    protected abstract virtual SeparatedSyntaxList`1<TListItemSyntax> GetListItems(TListSyntax listSyntax);
    protected abstract virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, bool containsSyntaxError, TListSyntax listSyntax);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.AbstractSeparatedSyntaxListWrapper`2/<TryCreateComputerAsync>d__31")]
public virtual Task`1<ICodeActionComputer> TryCreateComputerAsync(Document document, int position, SyntaxNode declaration, SyntaxWrappingOptions options, bool containsSyntaxError, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Wrapping.SeparatedSyntaxList.WrappingStyle : Enum {
    public int value__;
    public static WrappingStyle WrapFirst_IndentRest;
    public static WrappingStyle UnwrapFirst_AlignRest;
    public static WrappingStyle UnwrapFirst_IndentRest;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Wrapping.SyntaxWrappingOptions : object {
    public SyntaxFormattingOptions FormattingOptions;
    public OperatorPlacementWhenWrappingPreference OperatorPlacement;
    public bool UseTabs { get; }
    public int TabSize { get; }
    public string NewLine { get; }
    public int WrappingColumn { get; }
    protected SyntaxWrappingOptions(SyntaxFormattingOptions formattingOptions, OperatorPlacementWhenWrappingPreference operatorPlacement);
    public bool get_UseTabs();
    public int get_TabSize();
    public string get_NewLine();
    public int get_WrappingColumn();
}
internal class Microsoft.CodeAnalysis.Wrapping.WrapItemsAction : DocumentChangeAction {
    private static ImmutableArray`1<string> s_mruTitles;
    [CompilerGeneratedAttribute]
private string <ParentTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SortTitle>k__BackingField;
    public string ParentTitle { get; }
    public string SortTitle { get; }
    public WrapItemsAction(string title, string parentTitle, Func`3<IProgress`1<CodeAnalysisProgress>, CancellationToken, Task`1<Document>> createChangedDocument);
    private static WrapItemsAction();
    private static string GetSortTitle(string title, string parentTitle);
    [CompilerGeneratedAttribute]
public string get_ParentTitle();
    [CompilerGeneratedAttribute]
public string get_SortTitle();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.WrapItemsAction/<ComputePreviewOperationsAsync>d__9")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Wrapping.WrapItemsAction/<ComputeOperationsAsync>d__10")]
protected virtual Task`1<ImmutableArray`1<CodeActionOperation>> ComputeOperationsAsync(IProgress`1<CodeAnalysisProgress> progress, CancellationToken cancellationToken);
    public static ImmutableArray`1<CodeAction> SortActionsByMostRecentlyUsed(ImmutableArray`1<CodeAction> codeActions);
    public static ImmutableArray`1<T> SortByMostRecentlyUsed(ImmutableArray`1<T> items, ImmutableArray`1<string> mostRecentlyUsedKeys, Func`2<T, string> getKey);
    private static string GetSortTitle(CodeAction codeAction);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ImmutableArray`1<CodeActionOperation>> <>n__0(IProgress`1<CodeAnalysisProgress> progress, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Wrapping.WrappingGroup : ValueType {
    public bool IsInlinable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<WrapItemsAction> WrappingActions;
    public WrappingGroup(bool isInlinable, ImmutableArray`1<WrapItemsAction> wrappingActions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.SourceLink.Tools.SourceLinkMap : ValueType {
    private ReadOnlyCollection`1<Entry> _entries;
    public IReadOnlyList`1<Entry> Entries { get; }
    private SourceLinkMap(ReadOnlyCollection`1<Entry> mappings);
    public IReadOnlyList`1<Entry> get_Entries();
    public static SourceLinkMap Parse(string json);
    private static bool TryParseEntry(string key, string value, Entry& entry);
    public bool TryGetUri(string path, String& uri);
}
