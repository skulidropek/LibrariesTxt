[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SyntaxNodeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode WalkDownParentheses(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NetAnalyzers.Microsoft.CodeQuality.Analyzers.QualityGuidelines.CSharpAvoidMultipleEnumerationsAnalyzer : AvoidMultipleEnumerations {
    [NullableContextAttribute("1")]
protected virtual bool IsExpressionOfForEachStatement(SyntaxNode syntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.CSharp.NetAnalyzers.Microsoft.NetCore.Analyzers.Performance.CSharpUseStringMethodCharOverloadWithSingleCharacters : UseStringMethodCharOverloadWithSingleCharacters {
    [NullableContextAttribute("1")]
protected virtual SyntaxNode GetArgumentList(SyntaxNode argumentNode);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.CSharpDoNotInitializeUnnecessarilyFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.CSharpDoNotInitializeUnnecessarilyFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[ExtensionAttribute]
internal static class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CA1052CSharpCodeFixProviderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool IsDefaultConstructor(MemberDeclarationSyntax member);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpAvoidEmptyInterfacesFixer : AvoidEmptyInterfacesFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpCollectionsShouldImplementGenericInterfaceFixer : CollectionsShouldImplementGenericInterfaceFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpDeclareTypesInNamespacesFixer : DeclareTypesInNamespacesFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpDoNotHideBaseClassMethodsFixer : DoNotHideBaseClassMethodsFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpEnumsShouldHaveZeroValueFixer : EnumsShouldHaveZeroValueFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpEnumStorageShouldBeInt32Fixer : EnumStorageShouldBeInt32Fixer {
    [NullableContextAttribute("1")]
protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpIdentifiersShouldHaveCorrectPrefixFixer : IdentifiersShouldHaveCorrectPrefixFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpIdentifiersShouldHaveCorrectSuffixFixer : IdentifiersShouldHaveCorrectSuffixFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpIdentifiersShouldNotContainUnderscoresFixer : IdentifiersShouldNotContainUnderscoresFixer {
    protected virtual string GetNewName(string name);
    protected virtual SyntaxNode GetDeclarationNode(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpIdentifiersShouldNotHaveIncorrectSuffixFixer : IdentifiersShouldNotHaveIncorrectSuffixFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpIdentifiersShouldNotMatchKeywordsFixer : IdentifiersShouldNotMatchKeywordsFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpImplementIDisposableCorrectlyFixer : ImplementIDisposableCorrectlyFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpImplementStandardExceptionConstructorsAnalyzer : ImplementStandardExceptionConstructorsAnalyzer {
    protected virtual string GetConstructorSignatureNoParameter(ISymbol symbol);
    protected virtual string GetConstructorSignatureStringTypeParameter(ISymbol symbol);
    protected virtual string GetConstructorSignatureStringAndExceptionTypeParameter(ISymbol symbol);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpMarkAssembliesWithAssemblyVersionFixer : MarkAssembliesWithAssemblyVersionFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpMarkAssembliesWithClsCompliantFixer : MarkAssembliesWithClsCompliantFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpMovePInvokesToNativeMethodsClassFixer : MovePInvokesToNativeMethodsClassFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpOverrideEqualsAndOperatorEqualsOnValueTypesFixer : OverrideEqualsAndOperatorEqualsOnValueTypesFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpOverrideEqualsOnOverloadingOperatorEqualsFixer : OverrideEqualsOnOverloadingOperatorEqualsFixer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpOverrideGetHashCodeOnOverridingEqualsFixer : OverrideGetHashCodeOnOverridingEqualsFixer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpPassSystemUriObjectsInsteadOfStringsAnalyzer : PassSystemUriObjectsInsteadOfStringsAnalyzer {
    [NullableContextAttribute("1")]
protected virtual SyntaxNode GetInvocationExpression(SyntaxNode invocationNode);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpPropertyNamesShouldNotMatchGetMethodsFixer : PropertyNamesShouldNotMatchGetMethodsFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpStaticHolderTypesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpStaticHolderTypesFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpStaticHolderTypesFixer/<MakeClassStaticAsync>d__5")]
private static Task`1<Document> MakeClassStaticAsync(Document document, ClassDeclarationSyntax classDeclaration, CancellationToken ct);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpTypeNamesShouldNotMatchNamespacesFixer : TypeNamesShouldNotMatchNamespacesFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpUseEventsWhereAppropriateFixer : UseEventsWhereAppropriateFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpUsePreferredTermsAnalyzer : UsePreferredTermsAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpUsePreferredTermsFixer : UsePreferredTermsFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiDesignGuidelines.CSharpUsePropertiesWhereAppropriateFixer : UsePropertiesWhereAppropriateFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiReview.CSharpAvoidCallingProblematicMethodsAnalyzer : AvoidCallingProblematicMethodsAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.ApiReview.CSharpAvoidCallingProblematicMethodsFixer : AvoidCallingProblematicMethodsFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.Documentation.CSharpAvoidUsingCrefTagsWithAPrefixAnalyzer : AvoidUsingCrefTagsWithAPrefixAnalyzer {
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeXmlAttribute(SyntaxNodeAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.Documentation.CSharpAvoidUsingCrefTagsWithAPrefixFixer : AvoidUsingCrefTagsWithAPrefixFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.Maintainability.CSharpAvoidDeadConditionalCode : AvoidDeadConditionalCode {
    [NullableContextAttribute("1")]
protected virtual bool IsSwitchArmExpressionWithWhenClause(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.Maintainability.CSharpAvoidUninstantiatedInternalClasses : AvoidUninstantiatedInternalClassesAnalyzer {
    [NullableContextAttribute("1")]
public virtual void RegisterLanguageSpecificChecks(CompilationStartAnalysisContext context, ConcurrentDictionary`2<INamedTypeSymbol, object> instantiatedTypes);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.Maintainability.CSharpAvoidUninstantiatedInternalClassesFixer : AvoidUninstantiatedInternalClassesFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.Maintainability.CSharpUseNameofInPlaceOfStringAnalyzer : UseNameofInPlaceOfStringAnalyzer {
    [NullableContextAttribute("1")]
protected virtual bool IsApplicableToLanguageVersion(ParseOptions options);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.Maintainability.CSharpVariableNamesShouldNotMatchFieldNamesAnalyzer : VariableNamesShouldNotMatchFieldNamesAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.Maintainability.CSharpVariableNamesShouldNotMatchFieldNamesFixer : VariableNamesShouldNotMatchFieldNamesFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.QualityGuidelines.CSharpAvoidDuplicateElementInitializationFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.CSharp.Analyzers.QualityGuidelines.CSharpAvoidDuplicateElementInitializationFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Document RemoveElementInitializer(ExpressionSyntax elementInitializer, InitializerExpressionSyntax objectInitializer, SyntaxNode root, Document document);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.QualityGuidelines.CSharpDoNotInitializeUnnecessarilyAnalyzer : DoNotInitializeUnnecessarilyAnalyzer {
    [NullableContextAttribute("1")]
protected virtual bool IsNullSuppressed(IOperation op);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.QualityGuidelines.CSharpMarkMembersAsStaticFixer : MarkMembersAsStaticFixer {
    protected virtual IEnumerable`1<SyntaxNode> GetTypeArguments(SyntaxNode node);
    protected virtual SyntaxNode GetExpressionOfInvocation(SyntaxNode invocation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.QualityGuidelines.CSharpPreferJaggedArraysOverMultidimensionalFixer : PreferJaggedArraysOverMultidimensionalFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.CSharp.Analyzers.QualityGuidelines.CSharpUseLiteralsWhereAppropriate : UseLiteralsWhereAppropriateAnalyzer {
    [NullableContextAttribute("1")]
protected virtual bool IsConstantInterpolatedStringSupported(ParseOptions compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.CSharp.Analyzers.QualityGuidelines.CSharpUseLiteralsWhereAppropriateFixer : UseLiteralsWhereAppropriateFixer {
    protected virtual SyntaxNode GetFieldDeclaration(SyntaxNode syntaxNode);
    protected virtual bool IsStaticKeyword(SyntaxToken syntaxToken);
    protected virtual bool IsReadonlyKeyword(SyntaxToken syntaxToken);
    protected virtual SyntaxToken GetConstKeywordToken();
    protected virtual SyntaxTokenList GetModifiers(SyntaxNode fieldSyntax);
    protected virtual SyntaxNode WithModifiers(SyntaxNode fieldSyntax, SyntaxTokenList modifiers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.InteropServices.CSharpDisableRuntimeMarshallingFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.InteropServices.CSharpDisableRuntimeMarshallingFixer/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Nullable`1<int> FindFirstUnusedIdentifierIndex(SemanticModel model, int docOffset, string baseName);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.InteropServices.CSharpDisableRuntimeMarshallingFixer/<UseDisabledMarshallingEquivalentAsync>d__7")]
private static Task`1<Document> UseDisabledMarshallingEquivalentAsync(SyntaxNode node, Document document, CancellationToken ct);
    private static bool TryRewriteMethodCall(SyntaxNode node, DocumentEditor editor, IdentifierGenerator pointerIdentifierGenerator, bool addRenameAnnotation, CancellationToken ct);
    private static void AddUnsafeModifierToEnclosingMethod(DocumentEditor editor, SyntaxNode syntax);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <TryRewriteMethodCall>g__GetTypeOfTypeSyntax|8_0(TypeOfExpressionSyntax syntax);
    [CompilerGeneratedAttribute]
internal static BaseMethodDeclarationSyntax <AddUnsafeModifierToEnclosingMethod>g__FindEnclosingMethod|9_0(SyntaxNode syntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.CSharpUseSpanClearInsteadOfFillAnalyzer : UseSpanClearInsteadOfFillAnalyzer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.InteropServices.CSharpDynamicInterfaceCastableImplementationFixer : DynamicInterfaceCastableImplementationFixer {
    private static SyntaxToken EscapedThisToken;
    private static CSharpDynamicInterfaceCastableImplementationFixer();
    [AsyncStateMachineAttribute("Microsoft.NetCore.CSharp.Analyzers.InteropServices.CSharpDynamicInterfaceCastableImplementationFixer/<ImplementInterfacesOnDynamicCastableImplementationAsync>d__0")]
protected virtual Task`1<Document> ImplementInterfacesOnDynamicCastableImplementationAsync(SyntaxNode root, SyntaxNode declaration, Document document, SyntaxGenerator generator, CancellationToken cancellationToken);
    private static SyntaxNode AddSetAccessor(IPropertySymbol property, SyntaxNode declaration, SyntaxGenerator generator, SyntaxNode[] defaultMethodBodyStatements, bool includeAccessibility);
    private static SyntaxNode GenerateEventImplementation(IEventSymbol evt, SyntaxGenerator generator, SyntaxNode[] defaultMethodBodyStatements);
    [AsyncStateMachineAttribute("Microsoft.NetCore.CSharp.Analyzers.InteropServices.CSharpDynamicInterfaceCastableImplementationFixer/<MakeMemberDeclaredOnImplementationTypeStaticAsync>d__3")]
protected virtual Task`1<Document> MakeMemberDeclaredOnImplementationTypeStaticAsync(SyntaxNode declaration, Document document, CancellationToken cancellationToken);
    protected virtual bool CodeFixSupportsDeclaration(SyntaxNode declaration);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <ImplementInterfacesOnDynamicCastableImplementationAsync>g__GenerateMethodImplementation|0_0(IMethodSymbol method, <>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static SyntaxNode <ImplementInterfacesOnDynamicCastableImplementationAsync>g__GeneratePropertyImplementation|0_1(IPropertySymbol property, <>c__DisplayClass0_0& );
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.InteropServices.CSharpMarkBooleanPInvokeArgumentsWithMarshalAsAnalyzer : MarkBooleanPInvokeArgumentsWithMarshalAsAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.InteropServices.CSharpMarkBooleanPInvokeArgumentsWithMarshalAsFixer : MarkBooleanPInvokeArgumentsWithMarshalAsFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.InteropServices.CSharpSpecifyMarshalingForPInvokeStringArgumentsFixer : SpecifyMarshalingForPInvokeStringArgumentsFixer {
    protected virtual bool IsAttribute(SyntaxNode node);
    protected virtual SyntaxNode FindNamedArgument(IReadOnlyList`1<SyntaxNode> arguments, string argumentName);
    protected virtual bool IsDeclareStatement(SyntaxNode node);
    protected virtual Task`1<Document> FixDeclareStatementAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.InteropServices.CSharpUseManagedEquivalentsOfWin32ApiAnalyzer : UseManagedEquivalentsOfWin32ApiAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.InteropServices.CSharpUseManagedEquivalentsOfWin32ApiFixer : UseManagedEquivalentsOfWin32ApiFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpConstantExpectedAnalyzer : ConstantExpectedAnalyzer {
    private static CSharpDiagnosticHelper s_diagnosticHelper;
    private static IdentifierNameSyntax s_constantExpectedIdentifier;
    private static IdentifierNameSyntax s_constantExpectedAttributeIdentifier;
    protected DiagnosticHelper Helper { get; }
    private static CSharpConstantExpectedAnalyzer();
    protected virtual DiagnosticHelper get_Helper();
    protected virtual void RegisterAttributeSyntax(CompilationStartAnalysisContext context, ConstantExpectedContext constantExpectedContext);
    private void OnAttributeNode(SyntaxNodeAnalysisContext context, ConstantExpectedContext constantExpectedContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpDoNotGuardDictionaryRemoveByContainsKeyFixer : DoNotGuardDictionaryRemoveByContainsKeyFixer {
    protected virtual bool SyntaxSupportedByFixer(SyntaxNode conditionalSyntax);
    protected virtual Document ReplaceConditionWithChild(Document document, SyntaxNode root, SyntaxNode conditionalOperationNode, SyntaxNode childOperationNode);
    private static SyntaxNode GetNegatedExpression(Document document, SyntaxNode newConditionNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpDoNotGuardSetAddOrRemoveByContainsFixer : DoNotGuardSetAddOrRemoveByContainsFixer {
    protected virtual bool SyntaxSupportedByFixer(SyntaxNode conditionalSyntax, SyntaxNode childStatementSyntax);
    protected virtual Document ReplaceConditionWithChild(Document document, SyntaxNode root, SyntaxNode conditionalOperationNode, SyntaxNode childOperationNode);
    private static SyntaxNode GetNegatedExpression(Document document, SyntaxNode newConditionNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpDoNotUseCountWhenAnyCanBeUsedFixer : DoNotUseCountWhenAnyCanBeUsedFixer {
    protected virtual bool TryGetFixer(SyntaxNode node, string operation, bool isAsync, SyntaxNode& expression, IEnumerable`1& arguments);
    private static bool TryGetExpressionAndInvocationArguments(ExpressionSyntax sourceExpression, bool isAsync, SyntaxNode& expression, IEnumerable`1& arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpPreferDictionaryTryMethodsOverContainsKeyGuardFixer : PreferDictionaryTryMethodsOverContainsKeyGuardFixer {
    private static string Var;
    [AsyncStateMachineAttribute("Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpPreferDictionaryTryMethodsOverContainsKeyGuardFixer/<RegisterCodeFixesAsync>d__1")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpPreferDictionaryTryMethodsOverContainsKeyGuardFixer/<GetTryGetValueActionAsync>d__2")]
private static Task`1<CodeAction> GetTryGetValueActionAsync(Diagnostic diagnostic, SyntaxNode root, Document document, MemberAccessExpressionSyntax containsKeyAccess, InvocationExpressionSyntax containsKeyInvocation, CancellationToken cancellationToken);
    private static CodeAction GetTryAddAction(Diagnostic diagnostic, SyntaxNode root, Document document, InvocationExpressionSyntax containsKeyInvocation, MemberAccessExpressionSyntax containsKeyAccess);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpPreferHashDataOverComputeHashFixer : PreferHashDataOverComputeHashFixer {
    private static CSharpPreferHashDataOverComputeHashFixAllProvider s_fixAllProvider;
    private static CSharpPreferHashDataOverComputeHashFixHelper s_helper;
    protected PreferHashDataOverComputeHashFixHelper Helper { get; }
    private static CSharpPreferHashDataOverComputeHashFixer();
    public sealed virtual FixAllProvider GetFixAllProvider();
    protected virtual PreferHashDataOverComputeHashFixHelper get_Helper();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpPreferIsEmptyOverCountFixer : PreferIsEmptyOverCountFixer {
    [NullableContextAttribute("1")]
protected virtual SyntaxNode GetObjectExpressionFromOperation(SyntaxNode node, string operationKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpPreferLengthCountIsEmptyOverAnyFixer : PreferLengthCountIsEmptyOverAnyFixer {
    protected virtual SyntaxNode ReplaceAnyWithIsEmpty(SyntaxNode root, SyntaxNode node);
    protected virtual SyntaxNode ReplaceAnyWithLength(SyntaxNode root, SyntaxNode node);
    protected virtual SyntaxNode ReplaceAnyWithCount(SyntaxNode root, SyntaxNode node);
    private static SyntaxNode ReplaceAnyWithPropertyCheck(SyntaxNode root, SyntaxNode node, string propertyName);
    [CompilerGeneratedAttribute]
internal static BinaryExpressionSyntax <ReplaceAnyWithPropertyCheck>g__GetBinaryExpression|3_0(ExpressionSyntax expression, string member, SyntaxKind expressionKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpRecommendCaseInsensitiveStringComparisonFixer : RecommendCaseInsensitiveStringComparisonFixer {
    protected virtual IEnumerable`1<SyntaxNode> GetNewArgumentsForInvocation(SyntaxGenerator generator, string caseChangingApproachValue, IInvocationOperation mainInvocationOperation, INamedTypeSymbol stringComparisonType, string leftOffendingMethod, string rightOffendingMethod, SyntaxNode& mainInvocationInstance);
    protected virtual IEnumerable`1<SyntaxNode> GetNewArgumentsForBinary(SyntaxGenerator generator, SyntaxNode rightNode, SyntaxNode typeMemberAccess);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUseAsSpanInsteadOfRangeIndexerFixer : UseAsSpanInsteadOfRangeIndexerFixer {
    [NullableContextAttribute("1")]
protected virtual bool TrySplitExpression(SyntaxNode node, SyntaxNode& toReplace, SyntaxNode& target, IEnumerable`1& arguments);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUsePropertyInsteadOfCountMethodWhenAvailableFixer : UsePropertyInsteadOfCountMethodWhenAvailableFixer {
    [NullableContextAttribute("2")]
protected virtual bool TryGetExpression(SyntaxNode invocationNode, SyntaxNode& memberAccessNode, SyntaxNode& nameNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUseSearchValuesAnalyzer : UseSearchValuesAnalyzer {
    protected virtual bool IsConstantByteOrCharArrayVariableDeclaratorSyntax(SemanticModel semanticModel, SyntaxNode syntax, Int32& length);
    protected virtual bool IsConstantByteOrCharReadOnlySpanPropertyDeclarationSyntax(SemanticModel semanticModel, SyntaxNode syntax, Int32& length);
    protected virtual bool IsConstantByteOrCharArrayCreationSyntax(SemanticModel semanticModel, SyntaxNode syntax, Int32& length);
    internal static ExpressionSyntax TryGetPropertyGetterExpression(PropertyDeclarationSyntax propertyDeclaration);
    internal static bool IsConstantByteOrCharArrayCreationExpression(SemanticModel semanticModel, ExpressionSyntax expression, List`1<char> values, Int32& length);
    private static bool IsUtf8StringLiteralExpression(ExpressionSyntax expression, Int32& length);
    protected virtual bool ArrayFieldUsesAreLikelyReadOnly(SyntaxNode syntax);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <IsConstantByteOrCharArrayCreationExpression>g__TryGetByteOrCharLiteral|4_0(ExpressionSyntax expression, Char& value);
    [CompilerGeneratedAttribute]
internal static bool <ArrayFieldUsesAreLikelyReadOnly>g__IsFieldReference|6_0(ExpressionSyntax expression, string fieldName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUseSearchValuesFixer : UseSearchValuesFixer {
    [AsyncStateMachineAttribute("Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUseSearchValuesFixer/<GetTypeSymbolAsync>d__0")]
protected virtual ValueTask`1<ValueTuple`3<SyntaxNode, INamedTypeSymbol, bool>> GetTypeSymbolAsync(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual SyntaxNode ReplaceSearchValuesFieldName(SyntaxNode node);
    protected virtual SyntaxNode GetDeclaratorInitializer(SyntaxNode syntax);
    protected virtual SyntaxNode TryReplaceArrayCreationWithInlineLiteralExpression(IOperation operation);
    private static bool ContainsAnyComments(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUseSpanClearInsteadOfFillFixer : UseSpanClearInsteadOfFillFixer {
    [NullableContextAttribute("2")]
protected virtual SyntaxNode GetInvocationTarget(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFix : UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFix {
    protected virtual SyntaxNode AppendElasticMarker(SyntaxNode replacement);
    protected virtual SyntaxNode HandleCharStringComparisonOverload(SyntaxGenerator generator, SyntaxNode instance, SyntaxNode[] arguments, bool shouldNegate);
    private static ValueTuple`2<ArgumentSyntax, int> GetCharacterArgumentAndIndex(SyntaxNode[] arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUseStringContainsCharOverloadWithSingleCharactersFixer : UseStringContainsCharOverloadWithSingleCharactersCodeFix {
    protected virtual bool TryGetArgumentName(SyntaxNode violatingNode, String& argumentName);
    protected virtual bool TryGetLiteralValueFromNode(SyntaxNode violatingNode, Char& charLiteral);
    [CompilerGeneratedAttribute]
internal static bool <TryGetLiteralValueFromNode>g__TryGetCharFromLiteralExpressionSyntax|1_0(LiteralExpressionSyntax sourceLiteralExpressionSyntax, Char& parsedCharLiteral);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Performance.CSharpUseStringMethodCharOverloadWithSingleCharactersFixer : UseStringMethodCharOverloadWithSingleCharactersFixer {
    protected virtual bool TryGetChar(SemanticModel model, SyntaxNode argumentListNode, Char& c);
    protected virtual CodeAction CreateCodeAction(Document document, SyntaxNode argumentListNode, char sourceCharLiteral);
    [CompilerGeneratedAttribute]
internal static bool <TryGetChar>g__TryGetCharFromLiteralExpressionSyntax|0_0(LiteralExpressionSyntax sourceLiteralExpressionSyntax, Char& parsedCharLiteral);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Resources.CSharpMarkAssembliesWithNeutralResourcesLanguageAnalyzer : MarkAssembliesWithNeutralResourcesLanguageAnalyzer {
    protected virtual void RegisterAttributeAnalyzer(CompilationStartAnalysisContext context, Action onResourceFound, INamedTypeSymbol generatedCode);
    private static bool CheckAttribute(AttributeSyntax attribute);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpAvoidZeroLengthArrayAllocationsAnalyzer : AvoidZeroLengthArrayAllocationsAnalyzer {
    [NullableContextAttribute("1")]
protected virtual bool IsAttributeSyntax(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpCallGCSuppressFinalizeCorrectlyFixer : CallGCSuppressFinalizeCorrectlyFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpDetectPreviewFeatureAnalyzer : DetectPreviewFeatureAnalyzer {
    protected virtual SyntaxNode GetPreviewSyntaxNodeForFieldsOrEvents(ISymbol fieldOrEventSymbol, ISymbol previewSymbol);
    private static TypeSyntax GetElementTypeForNullableAndArrayTypeNodes(TypeSyntax parameterType);
    protected virtual SyntaxNode GetPreviewParameterSyntaxNodeForMethod(IMethodSymbol methodSymbol, ISymbol parameterSymbol);
    protected virtual SyntaxNode GetPreviewReturnTypeSyntaxNodeForMethodOrProperty(ISymbol methodOrPropertySymbol, ISymbol previewReturnTypeSymbol);
    private static bool TryMatchGenericSyntaxNodeWithGivenSymbol(GenericNameSyntax genericName, ISymbol previewReturnTypeSymbol, SyntaxNode& syntaxNode);
    protected virtual SyntaxNode GetConstraintSyntaxNodeForTypeConstrainedByPreviewTypes(ISymbol typeOrMethodSymbol, ISymbol previewInterfaceConstraintSymbol);
    private static bool TryGetConstraintClauseNode(SyntaxList`1<TypeParameterConstraintClauseSyntax> constraintClauses, ISymbol previewInterfaceConstraintSymbol, SyntaxNode& syntaxNode);
    protected virtual SyntaxNode GetPreviewInterfaceNodeForTypeImplementingPreviewInterface(ISymbol typeSymbol, ISymbol previewInterfaceSymbol);
    private static bool TryGetPreviewInterfaceNodeForTypeImplementingPreviewInterface(SeparatedSyntaxList`1<BaseTypeSyntax> baseListTypes, ISymbol previewInterfaceSymbol, SyntaxNode& previewInterfaceNode);
    private static bool IsSyntaxToken(SyntaxToken identifier, ISymbol previewInterfaceSymbol);
    private static bool IsIdentifierNameSyntax(TypeSyntax identifier, ISymbol previewInterfaceSymbol);
    protected virtual SyntaxNode GetPreviewImplementsClauseSyntaxNodeForMethodOrProperty(ISymbol methodOrPropertySymbol, ISymbol previewSymbol);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpDisposableTypesShouldDeclareFinalizerFixer : DisposableTypesShouldDeclareFinalizerFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpDisposeMethodsShouldCallBaseClassDisposeFixer : DisposeMethodsShouldCallBaseClassDisposeFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpDoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyFixer : DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyFixer {
    [NullableContextAttribute("2")]
private protected sealed virtual SyntaxNode AdjustSyntaxNode(SyntaxNode syntaxNode);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpDoNotUseStackallocInLoopsAnalyzer : DoNotUseStackallocInLoopsAnalyzer {
    private static ImmutableArray`1<SyntaxKind> s_stackallocKinds;
    private static CSharpDoNotUseStackallocInLoopsAnalyzer();
    [NullableContextAttribute("1")]
public sealed virtual void Initialize(AnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <Initialize>g__ShouldWarn|1_2(IOperation op, SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpDoNotUseTimersThatPreventPowerStateChangesAnalyzer : DoNotUseTimersThatPreventPowerStateChangesAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpDoNotUseTimersThatPreventPowerStateChangesFixer : DoNotUseTimersThatPreventPowerStateChangesFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpForwardCancellationTokenToInvocationsAnalyzer : ForwardCancellationTokenToInvocationsAnalyzer {
    protected virtual SyntaxNode GetInvocationMethodNameNode(SyntaxNode invocationNode);
    protected virtual bool ArgumentsImplicitOrNamed(INamedTypeSymbol cancellationTokenType, ImmutableArray`1<IArgumentOperation> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpForwardCancellationTokenToInvocationsFixer : ForwardCancellationTokenToInvocationsFixer`1<ArgumentSyntax> {
    protected virtual bool TryGetInvocation(SemanticModel model, SyntaxNode node, CancellationToken ct, IInvocationOperation& invocation);
    protected virtual bool IsArgumentNamed(IArgumentOperation argumentOperation);
    protected virtual SyntaxNode GetConditionalOperationInvocationExpression(SyntaxNode invocationNode);
    protected virtual bool TryGetExpressionAndArguments(SyntaxNode invocationNode, SyntaxNode& expression, ImmutableArray`1& arguments);
    protected virtual SyntaxNode GetTypeSyntaxForArray(IArrayTypeSymbol type);
    protected virtual IEnumerable`1<SyntaxNode> GetExpressions(ImmutableArray`1<ArgumentSyntax> newArguments);
    protected virtual SyntaxNode GetArrayCreationExpression(SyntaxGenerator generator, SyntaxNode typeSyntax, IEnumerable`1<SyntaxNode> expressions);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpMarkAllNonSerializableFieldsFixer : MarkAllNonSerializableFieldsFixer {
    [NullableContextAttribute("1")]
protected virtual SyntaxNode GetFieldDeclarationNode(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpNormalizeStringsToUppercaseFixer : NormalizeStringsToUppercaseFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpPreferAsSpanOverSubstringFixer : PreferAsSpanOverSubstringFixer {
    private protected virtual void ReplaceNonConditionalInvocationMethodName(SyntaxEditor editor, SyntaxNode memberInvocation, string newName);
    private protected virtual void ReplaceNamedArgumentName(SyntaxEditor editor, SyntaxNode invocation, string oldArgumentName, string newArgumentName);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpPreferDictionaryContainsMethods : PreferDictionaryContainsMethods {
    [NullableContextAttribute("1")]
private protected virtual bool TryGetPropertyReferenceOperation(IInvocationOperation containsInvocation, IPropertySymbol& propertySymbol);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpPreferDictionaryContainsMethodsFixer : PreferDictionaryContainsMethodsFixer {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpPreferDictionaryContainsMethodsFixer/<RegisterCodeFixesAsync>d__0")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpPreferStreamAsyncMemoryOverloadsFixer : PreferStreamAsyncMemoryOverloadsFixer {
    protected virtual SyntaxNode GetArgumentByPositionOrName(IInvocationOperation invocation, int index, string name, Boolean& isNamed);
    protected virtual bool IsPassingZeroAndBufferLength(SemanticModel model, SyntaxNode bufferValueNode, SyntaxNode offsetValueNode, SyntaxNode countValueNode);
    protected virtual SyntaxNode GetNodeWithNullability(IInvocationOperation invocation);
    protected virtual SyntaxNode GetNamedArgument(SyntaxGenerator generator, SyntaxNode node, bool isNamed, string newName);
    protected virtual SyntaxNode GetNamedMemberInvocation(SyntaxGenerator generator, SyntaxNode node, string memberName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpPreventNumericIntPtrUIntPtrBehavioralChanges : PreventNumericIntPtrUIntPtrBehavioralChanges {
    private static string IntPtr;
    private static string UIntPtr;
    protected virtual bool IsWithinCheckedContext(IOperation operation);
    [NullableContextAttribute("2")]
protected virtual bool IsAliasUsed(ISymbol symbol);
    [NullableContextAttribute("2")]
private static bool IdentifierNameIsIntPtrOrUIntPtr(ExpressionSyntax syntax);
    protected virtual bool IsAliasUsed(SyntaxNode syntax);
    private static TypeSyntax GetType(SyntaxNode syntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpProvideDeserializationMethodsForOptionalFieldsAnalyzer : ProvideDeserializationMethodsForOptionalFieldsAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpProvideDeserializationMethodsForOptionalFieldsFixer : ProvideDeserializationMethodsForOptionalFieldsFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpSpecifyCultureForToLowerAndToUpperAnalyzer : SpecifyCultureForToLowerAndToUpperAnalyzer {
    [NullableContextAttribute("1")]
protected virtual Location GetMethodNameLocation(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpSpecifyCultureForToLowerAndToUpperFixer : SpecifyCultureForToLowerAndToUpperFixerBase {
    protected virtual bool ShouldFix(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpSpecifyCultureForToLowerAndToUpperFixer/<SpecifyCurrentCultureAsync>d__1")]
protected virtual Task`1<Document> SpecifyCurrentCultureAsync(Document document, SyntaxGenerator generator, SyntaxNode root, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual Task`1<Document> UseInvariantVersionAsync(Document document, SyntaxGenerator generator, SyntaxNode root, SyntaxNode node);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpSpecifyCultureInfoFixer : SpecifyCultureInfoFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpSpecifyIFormatProviderFixer : SpecifyIFormatProviderFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpSpecifyStringComparisonFixer : SpecifyStringComparisonFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpTestForEmptyStringsUsingStringLengthFixer : TestForEmptyStringsUsingStringLengthFixer {
    protected virtual SyntaxNode GetExpression(SyntaxNode node);
    protected virtual bool IsEqualsOperator(SyntaxNode node);
    protected virtual bool IsNotEqualsOperator(SyntaxNode node);
    protected virtual SyntaxNode GetLeftOperand(SyntaxNode binaryExpressionSyntax);
    protected virtual SyntaxNode GetRightOperand(SyntaxNode binaryExpressionSyntax);
    protected virtual bool IsFixableBinaryExpression(SyntaxNode node);
    protected virtual bool IsFixableInvocationExpression(SyntaxNode node);
    protected virtual SyntaxNode GetInvocationTarget(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpTestForNaNCorrectlyFixer : TestForNaNCorrectlyFixer {
    protected virtual SyntaxNode GetBinaryExpression(SyntaxNode node);
    protected virtual bool IsEqualsOperator(SyntaxNode node);
    protected virtual bool IsNotEqualsOperator(SyntaxNode node);
    protected virtual SyntaxNode GetLeftOperand(SyntaxNode binaryExpressionSyntax);
    protected virtual SyntaxNode GetRightOperand(SyntaxNode binaryExpressionSyntax);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpUseOrdinalStringComparisonAnalyzer : UseOrdinalStringComparisonAnalyzer {
    [NullableContextAttribute("1")]
protected virtual Location GetMethodNameLocation(SyntaxNode invocationNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpUseOrdinalStringComparisonFixer : UseOrdinalStringComparisonFixerBase {
    protected virtual bool IsInArgumentContext(SyntaxNode node);
    protected virtual Task`1<Document> FixArgumentAsync(Document document, SyntaxGenerator generator, SyntaxNode root, SyntaxNode argument);
    protected virtual bool IsInIdentifierNameContext(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpUseOrdinalStringComparisonFixer/<FixIdentifierNameAsync>d__3")]
protected virtual Task`1<Document> FixIdentifierNameAsync(Document document, SyntaxGenerator generator, SyntaxNode root, SyntaxNode identifier, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpUseSpanBasedStringConcat : UseSpanBasedStringConcat {
    private protected virtual bool TryGetTopMostConcatOperation(IBinaryOperation binaryOperation, IBinaryOperation& rootBinaryOperation);
    private protected virtual IOperation WalkDownBuiltInImplicitConversionOnConcatOperand(IOperation operand);
    [CompilerGeneratedAttribute]
internal static bool <TryGetTopMostConcatOperation>g__IsConcatOperation|0_0(IBinaryOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Runtime.CSharpUseSpanBasedStringConcatFixer : UseSpanBasedStringConcatFixer {
    private protected virtual SyntaxNode ReplaceInvocationMethodName(SyntaxGenerator generator, SyntaxNode invocationSyntax, string newName);
    private protected virtual IOperation WalkDownBuiltInImplicitConversionOnConcatOperand(IOperation operand);
    private protected virtual bool IsNamedArgument(IArgumentOperation argumentOperation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Security.CSharpDataSetDataTableInIFormatterSerializableObjectGraphAnalyzer : DataSetDataTableInIFormatterSerializableObjectGraphAnalyzer {
    [NullableContextAttribute("1")]
protected virtual string ToString(TypedConstant typedConstant);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Security.CSharpDataSetDataTableInSerializableObjectGraphAnalyzer : DataSetDataTableInSerializableObjectGraphAnalyzer {
    [NullableContextAttribute("1")]
protected virtual string ToString(TypedConstant typedConstant);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Security.CSharpDataSetDataTableInSerializableTypeAnalyzer : DataSetDataTableInSerializableTypeAnalyzer {
    [NullableContextAttribute("1")]
protected virtual string ToString(TypedConstant typedConstant);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Security.CSharpDataSetDataTableInWebSerializableObjectGraphAnalyzer : DataSetDataTableInWebSerializableObjectGraphAnalyzer {
    [NullableContextAttribute("1")]
protected virtual string ToString(TypedConstant typedConstant);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.CSharp.Analyzers.Tasks.CSharpDoNotCreateTasksWithoutPassingATaskSchedulerFixer : DoNotCreateTasksWithoutPassingATaskSchedulerFixer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.CSharp.Analyzers.Usage.CSharpImplementGenericMathInterfacesCorrectly : ImplementGenericMathInterfacesCorrectly {
    protected virtual SyntaxNode FindTheTypeArgumentOfTheInterfaceFromTypeDeclaration(ISymbol typeSymbol, ISymbol theInterfaceSymbol);
    private static SyntaxNode FindTypeArgumentFromBaseInterfaceList(SeparatedSyntaxList`1<BaseTypeSyntax> baseListTypes, ISymbol anInterfaceSymbol);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpAvoidDuplicateAcceleratorsAnalyzer : AvoidDuplicateAcceleratorsAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpAvoidDuplicateAcceleratorsFixer : AvoidDuplicateAcceleratorsFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpCallBaseClassMethodsOnISerializableTypesAnalyzer : CallBaseClassMethodsOnISerializableTypesAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpCallBaseClassMethodsOnISerializableTypesFixer : CallBaseClassMethodsOnISerializableTypesFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpDoNotMarkServicedComponentsWithWebMethodAnalyzer : DoNotMarkServicedComponentsWithWebMethodAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpDoNotMarkServicedComponentsWithWebMethodFixer : DoNotMarkServicedComponentsWithWebMethodFixer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpSetLocaleForDataTypesAnalyzer : SetLocaleForDataTypesAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpSetLocaleForDataTypesFixer : SetLocaleForDataTypesFixer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetFramework.CSharp.Analyzers.CSharpTypesShouldNotExtendCertainBaseTypesFixer : TypesShouldNotExtendCertainBaseTypesFixer {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
