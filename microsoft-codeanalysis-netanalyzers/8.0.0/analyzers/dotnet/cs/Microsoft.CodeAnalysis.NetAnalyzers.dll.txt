[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Analyzer.Utilities.AbstractCategorizedAnalyzerConfigOptions : object {
    private static string DotnetCodeQualityKeyPrefix;
    private static string BuildPropertyKeyPrefix;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<OptionKey, ValueTuple`2<bool, object>> _computedOptionValuesMap;
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    protected abstract virtual bool TryGetOptionValue(string optionKeyPrefix, string optionKeySuffix, string optionName, String& valueString);
    public sealed virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue, OptionKind kind);
    public sealed virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`2<T, TArg> tryParseValue, TArg arg, T defaultValue, OptionKind kind);
    private static string MapOptionKindToKeyPrefix(OptionKind optionKind);
    public bool TryGetOptionValue(string optionName, OptionKind kind, DiagnosticDescriptor rule, TryParseValue`2<T, TArg> tryParseValue, TArg arg, T defaultValue, T& value);
    private ValueTuple`2<bool, object> ComputeOptionValue(string optionName, OptionKind kind, DiagnosticDescriptor rule, TryParseValue`2<T, TArg> tryParseValue, TArg arg);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetSpecificOptionValue|11_0(string specificOptionKey, string optionKeyPrefix, T& specificOptionValue, <>c__DisplayClass11_0`2& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetAnySpecificOptionValue|11_1(IEnumerable`1<string> specificOptionKeys, string optionKeyPrefix, T& specificOptionValue, <>c__DisplayClass11_0`2& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetGeneralOptionValue|11_2(string optionKeyPrefix, T& generalOptionValue, <>c__DisplayClass11_0`2& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.AdditionalFileProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AdditionalText> _additionalFiles;
    internal AdditionalFileProvider(ImmutableArray`1<AdditionalText> additionalFiles);
    public static AdditionalFileProvider FromOptions(AnalyzerOptions options);
    public AdditionalText GetFile(string fileName);
    public IEnumerable`1<AdditionalText> GetMatchingFiles(string pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.AggregateCategorizedAnalyzerConfigOptions : object {
    public static AggregateCategorizedAnalyzerConfigOptions Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<SyntaxTreeCategorizedAnalyzerConfigOptions> _globalOptions;
    private ImmutableDictionary`2<SyntaxTree, Lazy`1<SyntaxTreeCategorizedAnalyzerConfigOptions>> _perTreeOptions;
    public bool IsEmpty { get; }
    private AggregateCategorizedAnalyzerConfigOptions(Lazy`1<SyntaxTreeCategorizedAnalyzerConfigOptions> globalOptions, ImmutableDictionary`2<SyntaxTree, Lazy`1<SyntaxTreeCategorizedAnalyzerConfigOptions>> perTreeOptions);
    private static AggregateCategorizedAnalyzerConfigOptions();
    public sealed virtual bool get_IsEmpty();
    public static AggregateCategorizedAnalyzerConfigOptions Create(AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider, Compilation compilation);
    public sealed virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue, OptionKind kind);
    public sealed virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`2<T, TArg> tryParseValue, TArg arg, T defaultValue, OptionKind kind);
    private bool TryGetOptionValue(string optionName, OptionKind kind, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`2<T, TArg> tryParseValue, TArg arg, T defaultValue, T& value);
    [CompilerGeneratedAttribute]
internal static SyntaxTreeCategorizedAnalyzerConfigOptions <Create>g__Create|6_1(SyntaxTree tree, AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.AnalyzerConfigOptionsProviderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsEmpty(AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.AnalyzerOptionsExtensions : object {
    private static ConditionalWeakTable`2<AnalyzerOptions, ICategorizedAnalyzerConfigOptions> s_cachedOptions;
    private static ImmutableHashSet`1<OutputKind> s_defaultOutputKinds;
    private static AnalyzerOptionsExtensions();
    private static bool TryGetSyntaxTreeForOption(ISymbol symbol, SyntaxTree& tree);
    [ExtensionAttribute]
public static SymbolVisibilityGroup GetSymbolVisibilityGroupOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, SymbolVisibilityGroup defaultValue);
    [ExtensionAttribute]
private static SymbolVisibilityGroup GetSymbolVisibilityGroupOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, SymbolVisibilityGroup defaultValue);
    [ExtensionAttribute]
private static SymbolModifiers GetRequiredModifiersOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, SymbolModifiers defaultValue);
    [ExtensionAttribute]
private static SymbolModifiers GetRequiredModifiersOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, SymbolModifiers defaultValue);
    [ExtensionAttribute]
public static EnumValuesPrefixTrigger GetEnumValuesPrefixTriggerOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, EnumValuesPrefixTrigger defaultValue);
    [ExtensionAttribute]
private static EnumValuesPrefixTrigger GetEnumValuesPrefixTriggerOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, EnumValuesPrefixTrigger defaultValue);
    [ExtensionAttribute]
public static ImmutableHashSet`1<OutputKind> GetOutputKindsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static ImmutableHashSet`1<SymbolKind> GetAnalyzedSymbolKindsOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, ImmutableHashSet`1<SymbolKind> defaultSymbolKinds);
    [ExtensionAttribute]
private static ImmutableHashSet`1<SymbolKind> GetAnalyzedSymbolKindsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, ImmutableHashSet`1<SymbolKind> defaultSymbolKinds);
    [ExtensionAttribute]
private static TEnum GetFlagsEnumOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, TEnum defaultValue);
    [ExtensionAttribute]
private static ImmutableHashSet`1<TEnum> GetNonFlagsEnumOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, ImmutableHashSet`1<TEnum> defaultValue);
    [ExtensionAttribute]
private static TEnum GetNonFlagsEnumOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, TEnum defaultValue);
    [ExtensionAttribute]
public static bool GetBoolOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, bool defaultValue);
    [ExtensionAttribute]
public static bool GetBoolOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, bool defaultValue);
    [ExtensionAttribute]
public static UInt32 GetUnsignedIntegralOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, UInt32 defaultValue);
    [ExtensionAttribute]
public static string GetStringOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetNullCheckValidationMethodsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetAdditionalStringFormattingMethodsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static bool IsConfiguredToSkipAnalysis(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
public static bool IsConfiguredToSkipAnalysis(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, ISymbol containingContextSymbol, Compilation compilation);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetDisallowedSymbolNamesWithValueOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
private static SymbolNamesWithValueOption`1<Unit> GetDisallowedSymbolNamesWithValueOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<string> GetAdditionalRequiredSuffixesOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
private static SymbolNamesWithValueOption`1<string> GetAdditionalRequiredSuffixesOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<INamedTypeSymbol> GetAdditionalRequiredGenericInterfaces(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
private static SymbolNamesWithValueOption`1<INamedTypeSymbol> GetAdditionalRequiredGenericInterfaces(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetInheritanceExcludedSymbolNamesOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, string defaultForcedValue);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetAdditionalUseResultsMethodsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetEnumerationMethodsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetLinqChainMethodsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation);
    [ExtensionAttribute]
private static SymbolNamesWithValueOption`1<TValue> GetSymbolNamesWithValueOption(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, Func`2<string, NameParts<TValue>> getTypeAndSuffixFunc, string namePrefix, string optionDefaultValue, string optionForcedValue);
    [ExtensionAttribute]
public static string GetMSBuildPropertyValue(AnalyzerOptions options, string optionName, Compilation compilation);
    [ExtensionAttribute]
public static ImmutableArray`1<string> GetMSBuildItemMetadataValues(AnalyzerOptions options, string itemOptionName, Compilation compilation);
    [ExtensionAttribute]
public static bool MatchesConfiguredVisibility(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, SymbolVisibilityGroup defaultRequiredVisibility);
    [ExtensionAttribute]
public static bool MatchesConfiguredVisibility(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, ISymbol containingContextSymbol, Compilation compilation, SymbolVisibilityGroup defaultRequiredVisibility);
    [ExtensionAttribute]
public static bool MatchesConfiguredModifiers(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, SymbolModifiers defaultRequiredModifiers);
    [ExtensionAttribute]
private static ICategorizedAnalyzerConfigOptions GetOrComputeCategorizedAnalyzerConfigOptions(AnalyzerOptions options, Compilation compilation);
    [ExtensionAttribute]
public static InterproceduralAnalysisKind GetInterproceduralAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, InterproceduralAnalysisKind defaultValue);
    [ExtensionAttribute]
public static InterproceduralAnalysisKind GetInterproceduralAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, InterproceduralAnalysisKind defaultValue);
    [ExtensionAttribute]
public static DisposeAnalysisKind GetDisposeAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, DisposeAnalysisKind defaultValue);
    [ExtensionAttribute]
public static DisposeAnalysisKind GetDisposeAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, DisposeAnalysisKind defaultValue);
    [ExtensionAttribute]
public static bool GetDisposeOwnershipTransferAtConstructorOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, bool defaultValue);
    [ExtensionAttribute]
public static bool GetDisposeOwnershipTransferAtConstructorOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, bool defaultValue);
    [ExtensionAttribute]
public static bool GetDisposeOwnershipTransferAtMethodCall(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, bool defaultValue);
    [ExtensionAttribute]
public static bool GetDisposeOwnershipTransferAtMethodCall(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, bool defaultValue);
    [ExtensionAttribute]
public static bool GetCopyAnalysisOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, bool defaultValue);
    [ExtensionAttribute]
public static bool GetCopyAnalysisOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, bool defaultValue);
    [ExtensionAttribute]
public static PointsToAnalysisKind GetPointsToAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, PointsToAnalysisKind defaultValue);
    [ExtensionAttribute]
public static PointsToAnalysisKind GetPointsToAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, PointsToAnalysisKind defaultValue);
    [CompilerGeneratedAttribute]
internal static bool <GetNonFlagsEnumOptionValue>g__TryParseValue|13_0(string value, ImmutableHashSet`1& result);
    [CompilerGeneratedAttribute]
internal static bool <GetStringOptionValue>g__TryParseValue|18_0(string value, String& result);
    [CompilerGeneratedAttribute]
internal static SymbolNamesWithValueOption`1<Unit> <IsConfiguredToSkipAnalysis>g__GetExcludedSymbolNamesWithValueOption|22_0(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static SymbolNamesWithValueOption`1<Unit> <IsConfiguredToSkipAnalysis>g__GetExcludedTypeNamesWithDerivedTypesOption|22_1(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static NameParts<string> <GetAdditionalRequiredSuffixesOption>g__GetParts|26_0(string name);
    [CompilerGeneratedAttribute]
internal static NameParts<INamedTypeSymbol> <GetAdditionalRequiredGenericInterfaces>g__GetParts|28_1(string name, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static bool <GetSymbolNamesWithValueOption>g__TryParse|33_0(string s, ValueTuple`4<Compilation, Func`2<string, NameParts<TValue>>, string, string> arg, SymbolNamesWithValueOption`1& option);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static SymbolNamesWithValueOption`1<TValue> <GetSymbolNamesWithValueOption>g__GetDefaultValue|33_1(<>c__DisplayClass33_0`1& );
    [CompilerGeneratedAttribute]
internal static ICategorizedAnalyzerConfigOptions <GetOrComputeCategorizedAnalyzerConfigOptions>g__GetOrComputeCategorizedAnalyzerConfigOptions_Slow|39_0(AnalyzerOptions options, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.BoundedCache`2 : BoundedCacheWithFactory`2<TKey, TValue> {
    public TValue GetOrCreateValue(TKey key);
    [CompilerGeneratedAttribute]
internal static TValue <GetOrCreateValue>g__CreateDefaultValue|0_0(TKey _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.BoundedCacheWithFactory`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<WeakReference`1<Entry<TKey, TValue>>> _weakReferencedEntries;
    public TValue GetOrCreateValue(TKey key, Func`2<TKey, TValue> valueFactory);
}
internal static class Analyzer.Utilities.CategorizedAnalyzerConfigOptionsExtensions : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.DiagnosticCategory : object {
    public static string Design;
    public static string Globalization;
    public static string Interoperability;
    public static string Mobility;
    public static string Performance;
    public static string Reliability;
    public static string Security;
    public static string Usage;
    public static string Naming;
    public static string Library;
    public static string Documentation;
    public static string Maintainability;
    public static string RoslynDiagnosticsDesign;
    public static string RoslynDiagnosticsMaintainability;
    public static string RoslynDiagnosticsPerformance;
    public static string RoslynDiagnosticsReliability;
    public static string RoslynDiagnosticsUsage;
    public static string MicrosoftCodeAnalysisCorrectness;
    public static string MicrosoftCodeAnalysisDesign;
    public static string MicrosoftCodeAnalysisDocumentation;
    public static string MicrosoftCodeAnalysisLocalization;
    public static string MicrosoftCodeAnalysisPerformance;
    public static string MicrosoftCodeAnalysisCompatibility;
    public static string MicrosoftCodeAnalysisReleaseTracking;
}
internal static class Analyzer.Utilities.DiagnosticDescriptorHelper : object {
    [NullableContextAttribute("1")]
public static DiagnosticDescriptor Create(string id, LocalizableString title, LocalizableString messageFormat, string category, RuleLevel ruleLevel, LocalizableString description, bool isPortedFxCopRule, bool isDataflowRule, bool isEnabledByDefaultInAggressiveMode, bool isReportedAtCompilationEnd, String[] additionalCustomTags);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<DiagnosticSeverity, bool> <Create>g__GetDefaultSeverityAndEnabledByDefault|0_0(RuleLevel ruleLevel);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static String[] <Create>g__GetDefaultCustomTags|0_1(bool isPortedFxCopRule, bool isDataflowRule, bool isEnabledByDefaultInAggressiveMode);
}
internal static class Analyzer.Utilities.DiagnosticHelpers : object {
    [NullableContextAttribute("2")]
public static bool TryConvertToUInt64(object value, SpecialType specialType, UInt64& convertedValue);
    [NullableContextAttribute("1")]
public static string GetMemberName(ISymbol symbol);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.DisposeAnalysisHelper : object {
    [NullableAttribute("1")]
private static String[] s_disposeOwnershipTransferLikelyTypes;
    [NullableAttribute("1")]
private static BoundedCacheWithFactory`2<Compilation, DisposeAnalysisHelper> s_DisposeHelperCache;
    [NullableAttribute("1")]
private static ImmutableHashSet`1<OperationKind> s_DisposableCreationKinds;
    [NullableAttribute("1")]
private WellKnownTypeProvider _wellKnownTypeProvider;
    [NullableAttribute("1")]
private ImmutableHashSet`1<INamedTypeSymbol> _disposeOwnershipTransferLikelyTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<INamedTypeSymbol, ImmutableHashSet`1<IFieldSymbol>> _lazyDisposableFieldsMap;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <IDisposable>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <IAsyncDisposable>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ConfiguredAsyncDisposable>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ValueTask>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ConfiguredValueTaskAwaitable>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <StringReader>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <MemoryStream>k__BackingField;
    public INamedTypeSymbol IDisposable { get; }
    public INamedTypeSymbol IAsyncDisposable { get; }
    public INamedTypeSymbol ConfiguredAsyncDisposable { get; }
    public INamedTypeSymbol Task { get; }
    public INamedTypeSymbol ValueTask { get; }
    public INamedTypeSymbol ConfiguredValueTaskAwaitable { get; }
    public INamedTypeSymbol StringReader { get; }
    public INamedTypeSymbol MemoryStream { get; }
    [NullableContextAttribute("1")]
private DisposeAnalysisHelper(Compilation compilation);
    private static DisposeAnalysisHelper();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_IDisposable();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_IAsyncDisposable();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_ConfiguredAsyncDisposable();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_Task();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_ValueTask();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_ConfiguredValueTaskAwaitable();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_StringReader();
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_MemoryStream();
    [NullableContextAttribute("1")]
private static ImmutableHashSet`1<INamedTypeSymbol> GetDisposeOwnershipTransferLikelyTypes(Compilation compilation);
    private void EnsureDisposableFieldsMap();
    [NullableContextAttribute("1")]
public static bool TryGetOrCreate(Compilation compilation, DisposeAnalysisHelper& disposeHelper);
    [NullableContextAttribute("1")]
public static Func`2<ITypeSymbol, bool> GetIsDisposableDelegate(Compilation compilation);
    [NullableContextAttribute("1")]
public bool TryGetOrComputeResult(ImmutableArray`1<IOperation> operationBlocks, IMethodSymbol containingMethod, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, PointsToAnalysisKind defaultPointsToAnalysisKind, bool trackInstanceFields, bool trackExceptionPaths, DisposeAnalysisResult& disposeAnalysisResult, PointsToAnalysisResult& pointsToAnalysisResult, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, bool defaultDisposeOwnershipTransferAtConstructor);
    [NullableContextAttribute("1")]
private bool HasDisposableOwnershipTransferForConstructorParameter(IMethodSymbol containingMethod);
    [NullableContextAttribute("1")]
private bool IsDisposableCreation(IOperation operation);
    [NullableContextAttribute("1")]
public bool HasAnyDisposableCreationDescendant(ImmutableArray`1<IOperation> operationBlocks, IMethodSymbol containingMethod);
    [NullableContextAttribute("1")]
public bool IsDisposableTypeNotRequiringToBeDisposed(ITypeSymbol typeSymbol);
    [NullableContextAttribute("1")]
public ImmutableHashSet`1<IFieldSymbol> GetDisposableFields(INamedTypeSymbol namedType);
    [NullableContextAttribute("1")]
public bool IsDisposableCreationOrDisposeOwnershipTransfer(AbstractLocation location, IMethodSymbol containingMethod);
    public bool IsDisposable(ITypeSymbol type);
    [NullableContextAttribute("1")]
public DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static DisposeAnalysisHelper <TryGetOrCreate>g__CreateDisposeAnalysisHelper|33_0(Compilation compilation);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <HasDisposableOwnershipTransferForConstructorParameter>b__36_0(IParameterSymbol p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetDisposableFields>b__40_0(IFieldSymbol f);
}
internal enum Analyzer.Utilities.DisposeAnalysisKind : Enum {
    public int value__;
    public static DisposeAnalysisKind AllPaths;
    public static DisposeAnalysisKind AllPathsOnlyNotDisposed;
    public static DisposeAnalysisKind NonExceptionPaths;
    public static DisposeAnalysisKind NonExceptionPathsOnlyNotDisposed;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.DisposeAnalysisKindExtensions : object {
    [ExtensionAttribute]
public static bool AreExceptionPathsAndMayBeNotDisposedViolationsEnabled(DisposeAnalysisKind disposeAnalysisKind);
    [ExtensionAttribute]
public static bool AreExceptionPathsEnabled(DisposeAnalysisKind disposeAnalysisKind);
    [ExtensionAttribute]
public static bool AreMayBeNotDisposedViolationsEnabled(DisposeAnalysisKind disposeAnalysisKind);
}
internal enum Analyzer.Utilities.DisposeMethodKind : Enum {
    public int value__;
    public static DisposeMethodKind None;
    public static DisposeMethodKind Dispose;
    public static DisposeMethodKind DisposeBool;
    public static DisposeMethodKind DisposeAsync;
    public static DisposeMethodKind DisposeCoreAsync;
    public static DisposeMethodKind Close;
    public static DisposeMethodKind CloseAsync;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.DocumentExtensions : object {
    [AsyncStateMachineAttribute("Analyzer.Utilities.DocumentExtensions/<GetRequiredSemanticModelAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<SemanticModel> GetRequiredSemanticModelAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Analyzer.Utilities.DocumentExtensions/<GetRequiredSyntaxTreeAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxTree> GetRequiredSyntaxTreeAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Analyzer.Utilities.DocumentExtensions/<GetRequiredSyntaxRootAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxNode> GetRequiredSyntaxRootAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Analyzer.Utilities.DoNotCatchGeneralUnlessRethrownAnalyzer : DiagnosticAnalyzer {
    private bool _shouldCheckLambdas;
    [NullableAttribute("2")]
private string _enablingMethodAttributeFullyQualifiedName;
    private bool _allowExcludedSymbolNames;
    private bool RequiresAttributeOnMethod { get; }
    [NullableContextAttribute("2")]
protected DoNotCatchGeneralUnlessRethrownAnalyzer(bool shouldCheckLambdas, string enablingMethodAttributeFullyQualifiedName, bool allowExcludedSymbolNames);
    private bool get_RequiresAttributeOnMethod();
    protected abstract virtual Diagnostic CreateDiagnostic(IMethodSymbol containingMethod, SyntaxToken catchKeyword);
    protected virtual bool IsConfiguredDisallowedExceptionType(INamedTypeSymbol namedTypeSymbol, IMethodSymbol containingMethod, Compilation compilation, AnalyzerOptions analyzerOptions, CancellationToken cancellationToken);
    public virtual void Initialize(AnalysisContext context);
    private INamedTypeSymbol GetRequiredAttributeType(Compilation compilation);
    private static IReadOnlyCollection`1<INamedTypeSymbol> GetDisallowedCatchTypes(Compilation compilation);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.EditorConfigOptionNames : object {
    public static string ApiSurface;
    public static string RequiredModifiers;
    public static string ExcludeAsyncVoidMethods;
    public static string EnablePlatformAnalyzerOnPreNet5Target;
    public static string OutputKind;
    public static string ExcludeSingleLetterTypeParameters;
    public static string SufficientIterationCountForWeakKDFAlgorithm;
    public static string ExcludeExtensionMethodThisParameter;
    public static string NullCheckValidationMethods;
    public static string AdditionalStringFormattingMethods;
    public static string TryDetermineAdditionalStringFormattingMethodsAutomatically;
    public static string ExcludedSymbolNames;
    public static string ExcludedTypeNamesWithDerivedTypes;
    public static string DisallowedSymbolNames;
    public static string UnsafeDllImportSearchPathBits;
    public static string ExcludeAspnetCoreMvcControllerBase;
    public static string EnumValuesPrefixTrigger;
    public static string AdditionalRequiredSuffixes;
    public static string ExcludeIndirectBaseTypes;
    public static string AdditionalRequiredGenericInterfaces;
    public static string AdditionalInheritanceExcludedSymbolNames;
    public static string AnalyzedSymbolKinds;
    public static string UseNamingHeuristic;
    public static string AdditionalUseResultsMethods;
    public static string AllowedSuffixes;
    public static string ExcludeStructs;
    public static string ExcludeOrDefaultMethods;
    public static string EnumerationMethods;
    public static string LinqChainMethods;
    public static string AssumeMethodEnumeratesParameters;
    public static string AdditionalEnumNoneNames;
    public static string IgnoreInternalsVisibleTo;
    public static string InterproceduralAnalysisKind;
    public static string MaxInterproceduralMethodCallChain;
    public static string MaxInterproceduralLambdaOrLocalFunctionCallChain;
    public static string DisposeAnalysisKind;
    public static string DisposeOwnershipTransferAtConstructor;
    public static string DisposeOwnershipTransferAtMethodCall;
    public static string CopyAnalysis;
    public static string PointsToAnalysisKind;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.AdditionalTextExtensions : object {
    private static Encoding s_utf8bom;
    private static SourceText s_emptySourceText;
    private static AdditionalTextExtensions();
    [ExtensionAttribute]
public static SourceText GetTextOrEmpty(AdditionalText text, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.CharExtensions : object {
    [ExtensionAttribute]
public static bool IsAscii(char c);
    [ExtensionAttribute]
public static bool IsPrintableAscii(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.CompilationExtensions : object {
    private static Byte[] mscorlibPublicKeyToken;
    private static string WebAppProjectGuidString;
    private static string WebSiteProjectGuidString;
    private static CompilationExtensions();
    [ExtensionAttribute]
internal static bool IsWebProject(Compilation compilation, AnalyzerOptions options);
    [ExtensionAttribute]
internal static INamedTypeSymbol GetOrCreateTypeByMetadataName(Compilation compilation, string fullTypeName);
    [ExtensionAttribute]
internal static bool TryGetOrCreateTypeByMetadataName(Compilation compilation, string fullTypeName, INamedTypeSymbol& namedTypeSymbol);
    [ExtensionAttribute]
internal static bool TargetsDotNetFramework(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.DiagnosticExtensions : object {
    [NullableAttribute("2")]
private static PropertyInfo s_syntaxTreeDiagnosticOptionsProperty;
    [NullableAttribute("2")]
private static PropertyInfo s_compilationOptionsSyntaxTreeOptionsProviderProperty;
    private static DiagnosticExtensions();
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, ImmutableArray`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, ImmutableArray`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxToken token, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(ISymbol symbol, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(ISymbol symbol, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, ImmutableArray`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IEnumerable`1<Location> locations, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IEnumerable`1<Location> locations, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static void ReportNoLocationDiagnostic(CompilationAnalysisContext context, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static void ReportNoLocationDiagnostic(Compilation compilation, DiagnosticDescriptor rule, Action`1<Diagnostic> addDiagnostic, ImmutableDictionary`2<string, string> properties, Object[] args);
    [CompilerGeneratedAttribute]
internal static Nullable`1<DiagnosticSeverity> <ReportNoLocationDiagnostic>g__GetEffectiveSeverity|17_0(<>c__DisplayClass17_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static void AddKeyValueIfNotNull(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void AddRange(IDictionary`2<TKey, TValue> dictionary, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static bool IsEqualTo(IReadOnlyDictionary`2<TKey, TValue> dictionary, IReadOnlyDictionary`2<TKey, TValue> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IEnumerableExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<object, bool> s_notNullTest;
    private static IEnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> WhereAsArray(IEnumerable`1<TSource> source, Func`2<TSource, bool> selector);
    [ExtensionAttribute]
public static void Dispose(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool HasExactly(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasMoreThan(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasFewerThan(IEnumerable`1<TSource> source, int count);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.IEnumerableExtensions/<<Concat>g__ConcatImpl|0_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<T> <Concat>g__ConcatImpl|0_0(IEnumerable`1<T> source, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> WhereMethodDoesNotContainAttribute(IEnumerable`1<IMethodSymbol> methods, INamedTypeSymbol attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodOverloadsWithDesiredParameterAtLeadingOrTrailing(IEnumerable`1<IMethodSymbol> methods, IMethodSymbol selectedOverload, INamedTypeSymbol expectedParameterType, bool trailingOnly);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodOverloadsWithDesiredParameterAtTrailing(IEnumerable`1<IMethodSymbol> methods, IMethodSymbol selectedOverload, INamedTypeSymbol expectedTrailingParameterType);
    [ExtensionAttribute]
public static IMethodSymbol GetFirstOrDefaultMemberWithParameterTypes(IEnumerable`1<IMethodSymbol> members, ITypeSymbol[] expectedParameterTypesInOrder);
    [ExtensionAttribute]
public static IMethodSymbol GetFirstOrDefaultMemberWithParameterInfos(IEnumerable`1<IMethodSymbol> members, ParameterInfo[] expectedParameterTypesInOrder);
    [ExtensionAttribute]
public static IMethodSymbol GetFirstOrDefaultMemberWithParameterTypes(IEnumerable`1<IMethodSymbol> members, IReadOnlyList`1<ITypeSymbol> expectedParameterTypesInOrder);
    [CompilerGeneratedAttribute]
internal static bool <GetFirstOrDefaultMemberWithParameterTypes>g__Predicate|5_0(IMethodSymbol member, <>c__DisplayClass5_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IMethodSymbolExtensions : object {
    private static ImmutableHashSet`1<string> s_collectionAddMethodNameVariants;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static BoundedCache`2<Compilation, ConcurrentDictionary`2<IMethodSymbol, IBlockOperation>> s_methodToTopmostOperationBlockCache;
    private static IMethodSymbolExtensions();
    [ExtensionAttribute]
public static bool IsObjectEqualsOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsObjectEquals(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsStaticObjectEqualsOrReferenceEquals(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsGetHashCodeOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsToStringOverride(IMethodSymbol method);
    private static bool IsObjectMethodOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsFinalizer(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsImplementationOfInterfaceMethod(IMethodSymbol method, ITypeSymbol typeArgument, INamedTypeSymbol interfaceType, string interfaceMethodName);
    [ExtensionAttribute]
public static bool IsDisposeImplementation(IMethodSymbol method, Compilation compilation);
    [ExtensionAttribute]
public static bool IsAsyncDisposeImplementation(IMethodSymbol method, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDisposeImplementation(IMethodSymbol method, INamedTypeSymbol iDisposable);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAsyncDisposeImplementation(IMethodSymbol method, INamedTypeSymbol iAsyncDisposable, INamedTypeSymbol valueTaskType);
    [ExtensionAttribute]
private static bool HasDisposeMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasDisposeSignatureByConvention(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasDisposeBoolMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
private static bool HasDisposeCloseMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
private static bool HasDisposeCloseAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol taskType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static bool HasDisposeAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol task, INamedTypeSymbol valueTask, INamedTypeSymbol configuredValueTaskAwaitable);
    [ExtensionAttribute]
private static bool HasOverriddenDisposeCoreAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol task);
    [ExtensionAttribute]
public static DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method, INamedTypeSymbol iDisposable, INamedTypeSymbol iAsyncDisposable, INamedTypeSymbol configuredAsyncDisposable, INamedTypeSymbol task, INamedTypeSymbol valueTask, INamedTypeSymbol configuredValueTaskAwaitable);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOnDeserializationImplementation(IMethodSymbol method, INamedTypeSymbol iDeserializationCallback);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSerializationConstructor(IMethodSymbol method, INamedTypeSymbol serializationInfoType, INamedTypeSymbol streamingContextType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGetObjectData(IMethodSymbol method, INamedTypeSymbol serializationInfoType, INamedTypeSymbol streamingContextType);
    [ExtensionAttribute]
public static bool IsPropertyGetter(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsIndexerGetter(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsEventAccessor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsOperator(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool HasOptionalParameters(IMethodSymbol methodSymbol);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.IMethodSymbolExtensions/<GetOverloads>d__30")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetOverloads(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsCollectionAddMethod(IMethodSymbol method, ImmutableHashSet`1<INamedTypeSymbol> iCollectionTypes);
    [ExtensionAttribute]
public static bool IsTaskFromResultMethod(IMethodSymbol method, INamedTypeSymbol taskType);
    [ExtensionAttribute]
public static bool IsTaskConfigureAwaitMethod(IMethodSymbol method, INamedTypeSymbol genericTaskType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAsyncDisposableConfigureAwaitMethod(IMethodSymbol method, INamedTypeSymbol asyncDisposableType, INamedTypeSymbol taskAsyncEnumerableExtensions);
    [ExtensionAttribute]
public static IBlockOperation GetTopmostOperationBlock(IMethodSymbol method, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunctionOrDelegate(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunction(IMethodSymbol method);
    [ExtensionAttribute]
public static int GetParameterIndex(IMethodSymbol methodSymbol, IParameterSymbol parameterSymbol);
    [ExtensionAttribute]
public static bool HasEventHandlerSignature(IMethodSymbol method, INamedTypeSymbol eventArgsType);
    [ExtensionAttribute]
public static bool IsLockMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingMonitor);
    [ExtensionAttribute]
public static bool IsInterlockedExchangeMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingInterlocked);
    [ExtensionAttribute]
public static bool IsInterlockedCompareExchangeMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingInterlocked);
    [ExtensionAttribute]
public static bool HasParameterWithDelegateType(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOverrideOrVirtualMethodOf(IMethodSymbol methodSymbol, INamedTypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsArgumentNullCheckMethod(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsBenchmarkOrXUnitTestMethod(IMethodSymbol method, ConcurrentDictionary`2<INamedTypeSymbol, bool> knownTestAttributes, INamedTypeSymbol benchmarkAttribute, INamedTypeSymbol xunitFactAttribute);
    [ExtensionAttribute]
public static bool IsAutoPropertyAccessor(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTopLevelStatementsEntryPointMethod(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGetAwaiterFromAwaitablePattern(IMethodSymbol method, INamedTypeSymbol inotifyCompletionType, INamedTypeSymbol icriticalNotifyCompletionType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGetResultFromAwaiterPattern(IMethodSymbol method, INamedTypeSymbol inotifyCompletionType, INamedTypeSymbol icriticalNotifyCompletionType);
    [ExtensionAttribute]
public static ImmutableArray`1<IMethodSymbol> GetOriginalDefinitions(IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions : object {
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions/<GetBaseTypesAndThis>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypesAndThis(INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFromOrImplementsAnyConstructionOf(INamedTypeSymbol type, INamedTypeSymbol parentType);
    [ExtensionAttribute]
public static bool ImplementsOperator(INamedTypeSymbol symbol, string op);
    [ExtensionAttribute]
public static bool ImplementsEqualityOperators(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool OverridesEquals(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool OverridesGetHashCode(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool HasFinalizer(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsStaticHolderType(INamedTypeSymbol symbol);
    private static bool IsQualifyingMember(ISymbol member);
    private static bool IsDisqualifyingMember(ISymbol member);
    [ExtensionAttribute]
public static bool IsBenchmarkOrXUnitTestAttribute(INamedTypeSymbol attributeClass, ConcurrentDictionary`2<INamedTypeSymbol, bool> knownTestAttributes, INamedTypeSymbol benchmarkAttribute, INamedTypeSymbol xunitFactAttribute);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTopLevelStatementsEntryPointType(INamedTypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IOperationExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static BoundedCache`2<Compilation, ConcurrentDictionary`2<IOperation, ControlFlowGraph>> s_operationToCfgCache;
    [NullableAttribute("0")]
private static ImmutableArray`1<OperationKind> s_LambdaAndLocalFunctionKinds;
    private static IOperationExtensions();
    [ExtensionAttribute]
public static ITypeSymbol GetReceiverType(IInvocationOperation invocation, Compilation compilation, bool beforeConversion, CancellationToken cancellationToken);
    private static ITypeSymbol GetReceiverType(SyntaxNode receiverSyntax, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool HasNullConstantValue(IOperation operation);
    [ExtensionAttribute]
public static bool TryGetBoolConstantValue(IOperation operation, Boolean& constantValue);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, long comparand);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, ulong comparand);
    private static bool HasConstantValue(Optional`1<object> constantValue, ITypeSymbol constantValueType, ulong comparand);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetElementType(IArrayCreationOperation arrayCreation);
    [ExtensionAttribute]
public static ImmutableArray`1<IOperation> WithoutFullyImplicitOperations(ImmutableArray`1<IOperation> operations);
    [ExtensionAttribute]
public static ImmutableArray`1<IOperation> GetTopmostExplicitDescendants(IOperation operation);
    [ExtensionAttribute]
public static bool IsOperationNoneRoot(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IBlockOperation GetTopmostParentBlock(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IBlockOperation GetFirstParentBlock(IOperation operation);
    [ExtensionAttribute]
public static TOperation GetAncestor(IOperation root, OperationKind ancestorKind, Func`2<TOperation, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static IOperation GetAncestor(IOperation root, ImmutableArray`1<OperationKind> ancestorKinds, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static IConditionalAccessOperation GetConditionalAccess(IConditionalAccessInstanceOperation operation);
    [ExtensionAttribute]
public static IOperation GetInstance(IInstanceReferenceOperation operation, bool isInsideAnonymousObjectInitializer);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate, IOperation& foundOperation);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, OperationKind kind);
    [ExtensionAttribute]
public static bool IsComparisonOperator(IBinaryOperation binaryOperation);
    [ExtensionAttribute]
public static bool IsAdditionOrSubstractionOperation(IBinaryOperation binaryOperation, Char& binaryOperator);
    [ExtensionAttribute]
public static IOperation GetRoot(IOperation operation);
    [ExtensionAttribute]
public static bool TryGetEnclosingControlFlowGraph(IOperation operation, ControlFlowGraph& cfg);
    [ExtensionAttribute]
public static ControlFlowGraph GetEnclosingControlFlowGraph(IBlockOperation blockOperation);
    private static ControlFlowGraph CreateControlFlowGraph(IOperation operation);
    [ExtensionAttribute]
public static PooledHashSet`1<ISymbol> GetCaptures(IOperation operation, IMethodSymbol lambdaOrLocalFunction);
    [ExtensionAttribute]
public static bool IsWithinLambdaOrLocalFunction(IOperation operation, IOperation& containingLambdaOrLocalFunctionOperation);
    [ExtensionAttribute]
public static bool IsWithinExpressionTree(IOperation operation, INamedTypeSymbol linqExpressionTreeType);
    [ExtensionAttribute]
public static ITypeSymbol GetPatternType(IPatternOperation pattern);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryGetParentTupleOperation(ITupleOperation tupleOperation, ITupleOperation& parentTupleOperation, IOperation& elementOfParentTupleContainingTuple);
    [ExtensionAttribute]
public static bool IsExtensionMethodAndHasNoInstance(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static IOperation GetInstance(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static SyntaxNode GetInstanceSyntax(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static ITypeSymbol GetInstanceType(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetReferencedMemberOrLocalOrParameter(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkDownParentheses(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IOperation WalkUpParentheses(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkDownConversion(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkDownConversion(IOperation operation, Func`2<IConversionOperation, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IOperation WalkUpConversion(IOperation operation);
    [ExtensionAttribute]
public static IOperation GetThrownException(IThrowOperation operation);
    [ExtensionAttribute]
public static ITypeSymbol GetThrownExceptionType(IThrowOperation operation);
    [ExtensionAttribute]
public static bool HasArgument(IInvocationOperation invocationOperation, TOperation& firstFoundArgument);
    [ExtensionAttribute]
public static bool HasAnyExplicitDescendant(IOperation operation, Func`2<IOperation, bool> descendIntoOperation);
    [ExtensionAttribute]
public static bool IsSetMethodInvocation(IPropertyReferenceOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryGetArgumentForParameterAtIndex(ImmutableArray`1<IArgumentOperation> arguments, int parameterIndex, IArgumentOperation& result);
    [ExtensionAttribute]
public static IArgumentOperation GetArgumentForParameterAtIndex(ImmutableArray`1<IArgumentOperation> arguments, int parameterIndex);
    [ExtensionAttribute]
public static ImmutableArray`1<IArgumentOperation> GetArgumentsInParameterOrder(ImmutableArray`1<IArgumentOperation> arguments);
    [ExtensionAttribute]
public static ValueUsageInfo GetValueUsageInfo(IOperation operation, ISymbol containingSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInLeftOfDeconstructionAssignment(IOperation operation, IDeconstructionAssignmentOperation& deconstructionAssignment);
    [ExtensionAttribute]
public static RefKind GetRefKind(IReturnOperation operation, ISymbol containingSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IMethodSymbol TryGetContainingAnonymousFunctionOrLocalFunction(IOperation operation);
    [ExtensionAttribute]
public static bool IsAnyCompoundAssignment(IOperation operation);
    [ExtensionAttribute]
public static bool IsInsideCatchRegion(IOperation operation, ControlFlowGraph cfg);
    [ExtensionAttribute]
public static bool IsLValueFlowCaptureReference(IFlowCaptureReferenceOperation flowCaptureReference);
    [CompilerGeneratedAttribute]
internal static void <GetCaptures>g__ProcessLocalOrParameter|28_0(ISymbol symbol, <>c__DisplayClass28_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IPropertySymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsAutoProperty(IPropertySymbol propertySymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsIsCompletedFromAwaiterPattern(IPropertySymbol property, INamedTypeSymbol inotifyCompletionType, INamedTypeSymbol icriticalNotifyCompletionType);
    [ExtensionAttribute]
public static ImmutableArray`1<IPropertySymbol> GetOriginalDefinitions(IPropertySymbol propertySymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ISymbolExtensions : object {
    private static SymbolDisplayFormat s_memberDisplayFormat;
    private static ISymbolExtensions();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAccessorMethod(ISymbol symbol);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ISymbolExtensions/<GetAccessors>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetAccessors(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDefaultConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPublic(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsProtected(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPrivate(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsPropertyWithBackingField(ISymbol symbol, IFieldSymbol& backingField);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsBackingFieldForProperty(ISymbol symbol, IPropertySymbol& propertySymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConversionOperator(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsExternallyVisible(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static bool MatchMemberDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodDerivedByName(IMethodSymbol method, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMemberByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchFieldByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static string FormatMemberName(ISymbol member);
    [ExtensionAttribute]
public static bool ContainsParameterOfType(IEnumerable`1<IParameterSymbol> parameters, INamedTypeSymbol type);
    [ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersOfType(IEnumerable`1<IParameterSymbol> parameters, INamedTypeSymbol type);
    [ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersOfType(IEnumerable`1<IParameterSymbol> parameters, SpecialType specialType);
    [ExtensionAttribute]
public static bool HasOverloadWithParameterOfType(IEnumerable`1<IMethodSymbol> overloads, IMethodSymbol self, INamedTypeSymbol type, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ISymbolExtensions/<GetParameterIndices>d__31")]
[ExtensionAttribute]
public static IEnumerable`1<int> GetParameterIndices(IMethodSymbol method, IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ParametersAreSame(IMethodSymbol method1, IMethodSymbol method2);
    [ExtensionAttribute]
public static bool ParameterTypesAreSame(IMethodSymbol method1, IMethodSymbol method2, IEnumerable`1<int> parameterIndices, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ParameterTypesAreSame(IParameterSymbol parameter1, IParameterSymbol parameter2);
    [ExtensionAttribute]
public static bool ReturnTypeAndParametersAreSame(IMethodSymbol method, IMethodSymbol otherMethod);
    [ExtensionAttribute]
public static bool IsFromMscorlib(ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
public static IMethodSymbol GetMatchingOverload(IMethodSymbol method, IEnumerable`1<IMethodSymbol> overloads, int parameterIndex, INamedTypeSymbol type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol, TSymbol& interfaceMember);
    [ExtensionAttribute]
public static bool IsImplementationOfInterfaceMember(ISymbol symbol, ISymbol interfaceMember);
    [ExtensionAttribute]
public static bool IsOverrideOrImplementationOfInterfaceMember(ISymbol symbol, ISymbol interfaceMember);
    [ExtensionAttribute]
public static ISymbol GetOverriddenMember(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsImplementationOfAnyExplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberOrLocalOrParameterType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReadOnlyFieldOrProperty(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static AttributeData GetAttribute(ISymbol symbol, INamedTypeSymbol attributeType);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ISymbolExtensions/<GetAttributes>d__50")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributes(ISymbol symbol, IEnumerable`1<INamedTypeSymbol> attributesToMatch);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetAttributes(ISymbol symbol, INamedTypeSymbol[] attributeTypesToMatch);
    [ExtensionAttribute]
public static bool HasAnyAttribute(ISymbol symbol, IEnumerable`1<INamedTypeSymbol> attributesToMatch);
    [ExtensionAttribute]
public static bool HasAnyAttribute(ISymbol symbol, INamedTypeSymbol[] attributeTypesToMatch);
    [ExtensionAttribute]
public static bool HasAnyAttribute(ISymbol symbol, INamedTypeSymbol attribute);
    [ExtensionAttribute]
public static bool HasDerivedTypeAttribute(ITypeSymbol symbol, INamedTypeSymbol attribute);
    [ExtensionAttribute]
public static bool HasDerivedMethodAttribute(IMethodSymbol symbol, INamedTypeSymbol attribute);
    [ExtensionAttribute]
public static Boolean[] HasAttributes(ISymbol symbol, INamedTypeSymbol[] attributes);
    [ExtensionAttribute]
public static bool IsInSource(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLambdaOrLocalFunction(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSymbolWithSpecialDiscardName(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConst(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReadOnly(ISymbol symbol);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsAssignableTo(ITypeSymbol fromSymbol, ITypeSymbol toSymbol, Compilation compilation);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsPrimitiveType(ITypeSymbol type);
    [ExtensionAttribute]
public static bool Inherits(ITypeSymbol type, ITypeSymbol possibleBase);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ITypeSymbolExtensions/<GetBaseTypes>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type, Func`2<INamedTypeSymbol, bool> takeWhilePredicate);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFrom(ITypeSymbol symbol, ITypeSymbol candidateBaseType, bool baseTypesOnly, bool checkTypeParameterConstraints);
    [ExtensionAttribute]
public static bool IsDisposable(ITypeSymbol type, INamedTypeSymbol iDisposable, INamedTypeSymbol iAsyncDisposable, INamedTypeSymbol configuredAsyncDisposable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetApplicableAttributes(INamedTypeSymbol type, INamedTypeSymbol attributeUsageAttribute);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetApplicableExportAttributes(INamedTypeSymbol type, INamedTypeSymbol exportAttributeV1, INamedTypeSymbol exportAttributeV2, INamedTypeSymbol inheritedExportAttribute);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasValueCopySemantics(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool CanHoldNullValue(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNonNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsReferenceTypeOrNullableValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNullableOfBoolean(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static ITypeSymbol GetNullableValueTypeUnderlyingType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static ITypeSymbol GetUnderlyingValueTupleTypeOrThis(ITypeSymbol typeSymbol);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasAnyCollectionCountProperty(ITypeSymbol invocationTarget, WellKnownTypeProvider wellKnownTypeProvider);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsDisposable>g__IsInterfaceOrImplementsInterface|6_1(ITypeSymbol type, INamedTypeSymbol interfaceType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <GetApplicableAttributes>g__IsInheritedAttribute|7_0(AttributeData attributeData, INamedTypeSymbol attributeUsageAttribute);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <HasAnyCollectionCountProperty>g__isAnySupportedCollectionType|18_0(ITypeSymbol type, <>c__DisplayClass18_0& );
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.KeyValuePairExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static KeyValuePair`2<TKey, TValue> AsNullable(KeyValuePair`2<TKey, TValue> pair);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ExtractAll(List`1<T> list, Func`3<T, TArg, bool> predicate, TArg argument);
}
internal static class Analyzer.Utilities.Extensions.MethodKindEx : object {
    public static MethodKind LocalFunction;
    private static UInt32 LocalFunctionValueAssertion1;
    private static UInt32 LocalFunctionValueAssertion2;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.OperationBlockAnalysisContextExtension : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsMethodNotImplementedOrSupported(OperationBlockStartAnalysisContext context, bool checkPlatformNotSupported);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsMethodNotImplementedOrSupported>g__IsSingleStatementBody|0_1(IBlockOperation body);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.OperationBlocksExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ControlFlowGraph GetControlFlowGraph(ImmutableArray`1<IOperation> operationBlocks);
}
internal static class Analyzer.Utilities.Extensions.OperationKinds : object {
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<OperationKind> <MemberReference>k__BackingField;
    public static ImmutableArray`1<OperationKind> MemberReference { get; }
    private static OperationKinds();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<OperationKind> get_MemberReference();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.Extensions.ParameterInfo : object {
    [CompilerGeneratedAttribute]
private int <ArrayRank>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ParameterType>k__BackingField;
    public int ArrayRank { get; private set; }
    public bool IsArray { get; private set; }
    public bool IsParams { get; private set; }
    public INamedTypeSymbol ParameterType { get; private set; }
    private ParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
    [CompilerGeneratedAttribute]
public int get_ArrayRank();
    [CompilerGeneratedAttribute]
private void set_ArrayRank(int value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParams();
    [CompilerGeneratedAttribute]
private void set_IsParams(bool value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_ParameterType();
    [CompilerGeneratedAttribute]
private void set_ParameterType(INamedTypeSymbol value);
    public static ParameterInfo GetParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SemanticModelExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IOperation GetOperationWalkingUpParentChain(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SourceTextExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T Parse(SourceText text, Func`2<StreamReader, T> parser);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static bool HasSuffix(string str, string suffix);
    [ExtensionAttribute]
public static string WithoutSuffix(string str, string suffix);
    [ExtensionAttribute]
public static bool IsASCII(string value);
}
internal enum Analyzer.Utilities.Extensions.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
    public static SymbolVisibility Friend;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SymbolVisibilityExtensions : object {
    [ExtensionAttribute]
public static bool IsAtLeastAsVisibleAs(SymbolVisibility typeVisibility, SymbolVisibility comparisonVisibility);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.UriExtensions : object {
    private static ImmutableHashSet`1<string> s_uriWords;
    private static UriExtensions();
    [ExtensionAttribute]
public static bool ParameterNamesContainUriWordSubstring(IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SymbolNameContainsUriWordSubstring(ISymbol symbol, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.UriExtensions/<GetParametersThatContainUriWords>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersThatContainUriWords(IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SymbolNameContainsUriWords(ISymbol symbol, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.VersionExtension : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGreaterThanOrEqualTo(Version current, Version compare);
}
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.ConstructorMapper : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ValueContentAbstractValueCallback <MapFromValueContentAbstractValue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PointsToAbstractValueCallback <MapFromPointsToAbstractValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<PropertySetAbstractValueKind> <PropertyAbstractValues>k__BackingField;
    [NullableAttribute("2")]
internal ValueContentAbstractValueCallback MapFromValueContentAbstractValue { get; }
    [NullableAttribute("2")]
internal PointsToAbstractValueCallback MapFromPointsToAbstractValue { get; }
    internal ImmutableArray`1<PropertySetAbstractValueKind> PropertyAbstractValues { get; }
    internal bool RequiresValueContentAnalysis { get; }
    public ConstructorMapper(ImmutableArray`1<PropertySetAbstractValueKind> propertyAbstractValues);
    [NullableContextAttribute("1")]
public ConstructorMapper(ValueContentAbstractValueCallback mapFromValueContentAbstractValueCallback);
    [NullableContextAttribute("1")]
public ConstructorMapper(PointsToAbstractValueCallback mapFromPointsToAbstractValueCallback);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ValueContentAbstractValueCallback get_MapFromValueContentAbstractValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal PointsToAbstractValueCallback get_MapFromPointsToAbstractValue();
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<PropertySetAbstractValueKind> get_PropertyAbstractValues();
    internal bool get_RequiresValueContentAnalysis();
    internal void Validate(int propertyCount);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(ConstructorMapper other);
}
public enum Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.HazardousUsageEvaluationResult : Enum {
    public int value__;
    public static HazardousUsageEvaluationResult Unflagged;
    public static HazardousUsageEvaluationResult MaybeFlagged;
    public static HazardousUsageEvaluationResult Flagged;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.HazardousUsageEvaluator : object {
    [CompilerGeneratedAttribute]
private HazardousUsageEvaluatorKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainingTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterNameOfPropertySetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationEvaluationCallback <InvocationEvaluator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DerivedClass>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationCallback <ValueEvaluator>k__BackingField;
    public HazardousUsageEvaluatorKind Kind { get; }
    public string ContainingTypeName { get; }
    public string MethodName { get; }
    public string ParameterNameOfPropertySetObject { get; }
    public InvocationEvaluationCallback InvocationEvaluator { get; }
    public bool DerivedClass { get; }
    public EvaluationCallback ValueEvaluator { get; }
    [NullableContextAttribute("1")]
public HazardousUsageEvaluator(string trackedTypeMethodName, InvocationEvaluationCallback evaluator, bool derivedClass);
    [NullableContextAttribute("1")]
public HazardousUsageEvaluator(string containingType, string methodName, string parameterNameOfPropertySetObject, InvocationEvaluationCallback evaluator, bool derivedClass);
    [NullableContextAttribute("1")]
public HazardousUsageEvaluator(HazardousUsageEvaluatorKind kind, EvaluationCallback evaluator, bool derivedClass);
    [CompilerGeneratedAttribute]
public HazardousUsageEvaluatorKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_ContainingTypeName();
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public string get_ParameterNameOfPropertySetObject();
    [CompilerGeneratedAttribute]
public InvocationEvaluationCallback get_InvocationEvaluator();
    [CompilerGeneratedAttribute]
public bool get_DerivedClass();
    [CompilerGeneratedAttribute]
public EvaluationCallback get_ValueEvaluator();
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public bool Equals(HazardousUsageEvaluator other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.HazardousUsageEvaluatorCollection : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<ValueTuple`5<HazardousUsageEvaluatorKind, string, string, string, bool>, HazardousUsageEvaluator> <HazardousUsageEvaluators>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<ValueTuple`5<HazardousUsageEvaluatorKind, string, string, string, bool>, HazardousUsageEvaluator> HazardousUsageEvaluators { get; }
    public HazardousUsageEvaluatorCollection(IEnumerable`1<HazardousUsageEvaluator> hazardousUsageEvaluators);
    public HazardousUsageEvaluatorCollection(HazardousUsageEvaluator[] hazardousUsageEvaluators);
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ValueTuple`5<HazardousUsageEvaluatorKind, string, string, string, bool>, HazardousUsageEvaluator> get_HazardousUsageEvaluators();
    internal bool TryGetHazardousUsageEvaluator(string trackedTypeMethodName, HazardousUsageEvaluator& hazardousUsageEvaluator, bool derivedClasses);
    internal bool TryGetHazardousUsageEvaluator(string containingType, string methodName, string parameterName, HazardousUsageEvaluator& hazardousUsageEvaluator);
    [NullableContextAttribute("2")]
internal bool TryGetReturnHazardousUsageEvaluator(HazardousUsageEvaluator& hazardousUsageEvaluator, bool derivedClass);
    [NullableContextAttribute("2")]
internal bool TryGetInitializationHazardousUsageEvaluator(HazardousUsageEvaluator& hazardousUsageEvaluator, bool derivedClass);
    [NullableContextAttribute("2")]
internal bool TryGetArgumentHazardousUsageEvaluator(HazardousUsageEvaluator& hazardousUsageEvaluator, bool derivedClass);
    internal ImmutableDictionary`2<ValueTuple`2<INamedTypeSymbol, bool>, string> GetTypeToNameMapping(WellKnownTypeProvider wellKnownTypeProvider);
}
internal enum Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.HazardousUsageEvaluatorKind : Enum {
    public int value__;
    public static HazardousUsageEvaluatorKind Invocation;
    public static HazardousUsageEvaluatorKind Return;
    public static HazardousUsageEvaluatorKind Initialization;
    public static HazardousUsageEvaluatorKind Argument;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertyMapper : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PropertyIndex>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ValueContentAbstractValueCallback <MapFromValueContentAbstractValue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PointsToAbstractValueCallback <MapFromPointsToAbstractValue>k__BackingField;
    internal string PropertyName { get; }
    internal int PropertyIndex { get; }
    [NullableAttribute("2")]
internal ValueContentAbstractValueCallback MapFromValueContentAbstractValue { get; }
    [NullableAttribute("2")]
internal PointsToAbstractValueCallback MapFromPointsToAbstractValue { get; }
    internal bool RequiresValueContentAnalysis { get; }
    public PropertyMapper(string propertyName, ValueContentAbstractValueCallback mapFromValueContentAbstractValueCallback);
    public PropertyMapper(string propertyName, ValueContentAbstractValueCallback mapFromValueContentAbstractValueCallback, int propertyIndex);
    public PropertyMapper(string propertyName, PointsToAbstractValueCallback mapFromPointsToAbstractValueCallback);
    public PropertyMapper(string propertyName, PointsToAbstractValueCallback mapFromPointsToAbstractValueCallback, int propertyIndex);
    [CompilerGeneratedAttribute]
internal string get_PropertyName();
    [CompilerGeneratedAttribute]
internal int get_PropertyIndex();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ValueContentAbstractValueCallback get_MapFromValueContentAbstractValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal PointsToAbstractValueCallback get_MapFromPointsToAbstractValue();
    internal bool get_RequiresValueContentAnalysis();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(PropertyMapper other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertyMapperCollection : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ValueTuple`2<int, PropertyMapper>> <PropertyMappersWithIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresValueContentAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PropertyValuesCount>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ValueTuple`2<int, PropertyMapper>> PropertyMappersWithIndex { get; }
    internal bool RequiresValueContentAnalysis { get; }
    internal int PropertyValuesCount { get; }
    public PropertyMapperCollection(IEnumerable`1<PropertyMapper> propertyMappers);
    public PropertyMapperCollection(PropertyMapper[] propertyMappers);
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ValueTuple`2<int, PropertyMapper>> get_PropertyMappersWithIndex();
    [CompilerGeneratedAttribute]
internal bool get_RequiresValueContentAnalysis();
    [CompilerGeneratedAttribute]
internal int get_PropertyValuesCount();
    internal bool TryGetPropertyMapper(string propertyName, PropertyMapper& propertyMapper, Int32& index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertySetAbstractValue : object {
    public static PropertySetAbstractValue Unknown;
    private static ValuePool Pool;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<PropertySetAbstractValueKind> <KnownPropertyAbstractValues>k__BackingField;
    [NullableAttribute("0")]
private ImmutableArray`1<PropertySetAbstractValueKind> KnownPropertyAbstractValues { get; }
    public int KnownValuesCount { get; }
    public PropertySetAbstractValueKind Item { get; }
    [NullableContextAttribute("0")]
private PropertySetAbstractValue(ImmutableArray`1<PropertySetAbstractValueKind> propertyAbstractValues);
    private static PropertySetAbstractValue();
    public static PropertySetAbstractValue GetInstance(PropertySetAbstractValueKind v1);
    public static PropertySetAbstractValue GetInstance(PropertySetAbstractValueKind v1, PropertySetAbstractValueKind v2);
    public static PropertySetAbstractValue GetInstance(ArrayBuilder`1<PropertySetAbstractValueKind> propertyAbstractValues);
    [NullableContextAttribute("0")]
public static PropertySetAbstractValue GetInstance(ImmutableArray`1<PropertySetAbstractValueKind> propertyAbstractValues);
    private static bool TryGetPooledInstance(IReadOnlyList`1<PropertySetAbstractValueKind> values, PropertySetAbstractValue& instance);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<PropertySetAbstractValueKind> get_KnownPropertyAbstractValues();
    public int get_KnownValuesCount();
    public PropertySetAbstractValueKind get_Item(int index);
    internal PropertySetAbstractValue ReplaceAt(int index, PropertySetAbstractValueKind kind);
}
internal enum Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertySetAbstractValueKind : Enum {
    public int value__;
    public static PropertySetAbstractValueKind Unknown;
    public static PropertySetAbstractValueKind Unflagged;
    public static PropertySetAbstractValueKind Flagged;
    public static PropertySetAbstractValueKind MaybeFlagged;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertySetAnalysis : ForwardDataFlowAnalysis`5<DictionaryAnalysisData`2<AbstractLocation, PropertySetAbstractValue>, PropertySetAnalysisContext, PropertySetAnalysisResult, PropertySetBlockAnalysisResult, PropertySetAbstractValue> {
    public static MapAbstractDomain`2<AbstractLocation, PropertySetAbstractValue> PropertySetAnalysisDomainInstance;
    private PropertySetAnalysis(MapAbstractDomain`2<AbstractLocation, PropertySetAbstractValue> analysisDomain, PropertySetDataFlowOperationVisitor operationVisitor);
    private static PropertySetAnalysis();
    internal static PropertySetAnalysisResult GetOrComputeResult(ControlFlowGraph cfg, Compilation compilation, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, ImmutableHashSet`1<string> typeToTrackMetadataNames, ConstructorMapper constructorMapper, PropertyMapperCollection propertyMappers, HazardousUsageEvaluatorCollection hazardousUsageEvaluators, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis);
    public static PooledDictionary`2<ValueTuple`2<Location, IMethodSymbol>, HazardousUsageEvaluationResult> BatchGetOrComputeHazardousUsages(Compilation compilation, IEnumerable`1<ValueTuple`2<IOperation, ISymbol>> rootOperationsNeedingAnalysis, AnalyzerOptions analyzerOptions, string typeToTrackMetadataName, ConstructorMapper constructorMapper, PropertyMapperCollection propertyMappers, HazardousUsageEvaluatorCollection hazardousUsageEvaluators, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis);
    public static PooledDictionary`2<ValueTuple`2<Location, IMethodSymbol>, HazardousUsageEvaluationResult> BatchGetOrComputeHazardousUsages(Compilation compilation, IEnumerable`1<ValueTuple`2<IOperation, ISymbol>> rootOperationsNeedingAnalysis, AnalyzerOptions analyzerOptions, ImmutableHashSet`1<string> typeToTrackMetadataNames, ConstructorMapper constructorMapper, PropertyMapperCollection propertyMappers, HazardousUsageEvaluatorCollection hazardousUsageEvaluators, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis);
    public static HazardousUsageEvaluationResult MergeHazardousUsageEvaluationResult(HazardousUsageEvaluationResult r1, HazardousUsageEvaluationResult r2);
    private static PropertySetAnalysisResult TryGetOrComputeResultForAnalysisContext(PropertySetAnalysisContext analysisContext);
    protected virtual PropertySetAnalysisResult ToResult(PropertySetAnalysisContext analysisContext, DataFlowAnalysisResult`2<PropertySetBlockAnalysisResult, PropertySetAbstractValue> dataFlowAnalysisResult);
    protected virtual PropertySetBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AbstractLocation, PropertySetAbstractValue> blockAnalysisData);
    [CompilerGeneratedAttribute]
internal static PropertySetAnalysisResult <BatchGetOrComputeHazardousUsages>g__InvokeDfaAndAccumulateResults|6_0(ControlFlowGraph cfg, ISymbol owningSymbol, <>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertySetAnalysisContext : AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AbstractLocation, PropertySetAbstractValue>, PropertySetAnalysisContext, PropertySetAnalysisResult, PropertySetAbstractValue> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <TypeToTrackMetadataNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorMapper <ConstructorMapper>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyMapperCollection <PropertyMappers>k__BackingField;
    [CompilerGeneratedAttribute]
private HazardousUsageEvaluatorCollection <HazardousUsageEvaluators>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<ValueTuple`2<INamedTypeSymbol, bool>, string> <HazardousUsageTypesToNames>k__BackingField;
    public ImmutableHashSet`1<string> TypeToTrackMetadataNames { get; }
    public ConstructorMapper ConstructorMapper { get; }
    public PropertyMapperCollection PropertyMappers { get; }
    public HazardousUsageEvaluatorCollection HazardousUsageEvaluators { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<ValueTuple`2<INamedTypeSymbol, bool>, string> HazardousUsageTypesToNames { get; }
    private PropertySetAnalysisContext(AbstractValueDomain`1<PropertySetAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Func`2<PropertySetAnalysisContext, PropertySetAnalysisResult> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AbstractLocation, PropertySetAbstractValue>, PropertySetAnalysisContext, PropertySetAbstractValue> interproceduralAnalysisData, ImmutableHashSet`1<string> typeToTrackMetadataNames, ConstructorMapper constructorMapper, PropertyMapperCollection propertyMappers, HazardousUsageEvaluatorCollection hazardousUsageEvaluators, ImmutableDictionary`2<ValueTuple`2<INamedTypeSymbol, bool>, string> hazardousUsageTypesToNames);
    public static PropertySetAnalysisContext Create(AbstractValueDomain`1<PropertySetAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Func`2<PropertySetAnalysisContext, PropertySetAnalysisResult> tryGetOrComputeAnalysisResult, ImmutableHashSet`1<string> typeToTrackMetadataNames, ConstructorMapper constructorMapper, PropertyMapperCollection propertyMappers, HazardousUsageEvaluatorCollection hazardousUsageEvaluators);
    public virtual PropertySetAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AbstractLocation, PropertySetAbstractValue>, PropertySetAnalysisContext, PropertySetAbstractValue> interproceduralAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_TypeToTrackMetadataNames();
    [CompilerGeneratedAttribute]
public ConstructorMapper get_ConstructorMapper();
    [CompilerGeneratedAttribute]
public PropertyMapperCollection get_PropertyMappers();
    [CompilerGeneratedAttribute]
public HazardousUsageEvaluatorCollection get_HazardousUsageEvaluators();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<ValueTuple`2<INamedTypeSymbol, bool>, string> get_HazardousUsageTypesToNames();
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AbstractLocation, PropertySetAbstractValue>, PropertySetAnalysisContext, PropertySetAnalysisResult, PropertySetAbstractValue> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertySetAnalysisResult : DataFlowAnalysisResult`2<PropertySetBlockAnalysisResult, PropertySetAbstractValue> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<ValueTuple`2<Location, IMethodSymbol>, HazardousUsageEvaluationResult> <HazardousUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IMethodSymbol> <VisitedLocalFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IFlowAnonymousFunctionOperation> <VisitedLambdas>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<ValueTuple`2<Location, IMethodSymbol>, HazardousUsageEvaluationResult> HazardousUsages { get; }
    public ImmutableHashSet`1<IMethodSymbol> VisitedLocalFunctions { get; }
    public ImmutableHashSet`1<IFlowAnonymousFunctionOperation> VisitedLambdas { get; }
    public PropertySetAnalysisResult(DataFlowAnalysisResult`2<PropertySetBlockAnalysisResult, PropertySetAbstractValue> propertySetAnalysisResult, ImmutableDictionary`2<ValueTuple`2<Location, IMethodSymbol>, HazardousUsageEvaluationResult> hazardousUsages, ImmutableHashSet`1<IMethodSymbol> visitedLocalFunctions, ImmutableHashSet`1<IFlowAnonymousFunctionOperation> visitedLambdas);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<ValueTuple`2<Location, IMethodSymbol>, HazardousUsageEvaluationResult> get_HazardousUsages();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IMethodSymbol> get_VisitedLocalFunctions();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IFlowAnonymousFunctionOperation> get_VisitedLambdas();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertySetBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AbstractLocation, PropertySetAbstractValue> <Data>k__BackingField;
    public ImmutableDictionary`2<AbstractLocation, PropertySetAbstractValue> Data { get; }
    public PropertySetBlockAnalysisResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AbstractLocation, PropertySetAbstractValue> blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AbstractLocation, PropertySetAbstractValue> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.PropertySetAnalysis.PropertySetCallbacks : object {
    public static PropertySetAbstractValueKind FlagIfNull(PointsToAbstractValue pointsToAbstractValue);
    public static PropertySetAbstractValueKind EvaluateLiteralValues(ValueContentAbstractValue valueContentAbstractValue, Func`2<object, bool> badLiteralValuePredicate);
    public static HazardousUsageEvaluationResult HazardousIfAllFlaggedOrAllUnknown(PropertySetAbstractValue propertySetAbstractValue);
    public static HazardousUsageEvaluationResult HazardousIfAllFlaggedAndAtLeastOneKnown(PropertySetAbstractValue propertySetAbstractValue);
    public static HazardousUsageEvaluationResult HazardousIfAllFlaggedOrAllUnknown(IMethodSymbol methodSymbol, PropertySetAbstractValue propertySetAbstractValue);
    public static HazardousUsageEvaluationResult HazardousIfAllFlaggedAndAtLeastOneKnown(IMethodSymbol methodSymbol, PropertySetAbstractValue propertySetAbstractValue);
    private static HazardousUsageEvaluationResult HazardousIfAllFlagged(PropertySetAbstractValue propertySetAbstractValue, bool assumeAllUnknownInsecure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.AnySanitizers : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SanitizerInfo> <SanitizerInfos>k__BackingField;
    public static ImmutableHashSet`1<SanitizerInfo> SanitizerInfos { get; }
    private static AnySanitizers();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SanitizerInfo> get_SanitizerInfos();
}
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.ArrayLengthMatcher : MulticastDelegate {
    public ArrayLengthMatcher(object object, IntPtr method);
    public virtual bool Invoke(int length);
    public virtual IAsyncResult BeginInvoke(int length, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.DllSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static DllSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.FilePathInjectionSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static FilePathInjectionSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.HardcodedBytesSources : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SourceInfo> <SourceInfos>k__BackingField;
    public static ImmutableHashSet`1<SourceInfo> SourceInfos { get; }
    private static HardcodedBytesSources();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SourceInfo> get_SourceInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.HardcodedCertificateSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static HardcodedCertificateSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.HardcodedCertificateSources : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SourceInfo> <SourceInfos>k__BackingField;
    public static ImmutableHashSet`1<SourceInfo> SourceInfos { get; }
    private static HardcodedCertificateSources();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SourceInfo> get_SourceInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.HardcodedEncryptionKeySinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static HardcodedEncryptionKeySinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.HardcodedSymmetricAlgorithmKeysSources : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SourceInfo> <SourceInfos>k__BackingField;
    public static ImmutableHashSet`1<SourceInfo> SourceInfos { get; }
    private static HardcodedSymmetricAlgorithmKeysSources();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SourceInfo> get_SourceInfos();
    private static ImmutableHashSet`1<SourceInfo> BuildSources();
    private static bool IsLegalKeySize(int byteCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.InformationDisclosureSources : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SourceInfo> <SourceInfos>k__BackingField;
    public static ImmutableHashSet`1<SourceInfo> SourceInfos { get; }
    private static InformationDisclosureSources();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SourceInfo> get_SourceInfos();
}
[NullableContextAttribute("1")]
internal interface Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.ITaintedDataInfo {
    public string FullTypeName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> DependencyFullTypeNames { get; }
    public bool IsInterface { get; }
    public bool RequiresParameterReferenceAnalysis { get; }
    public bool RequiresValueContentAnalysis { get; }
    public abstract virtual string get_FullTypeName();
    public abstract virtual ImmutableArray`1<string> get_DependencyFullTypeNames();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_RequiresParameterReferenceAnalysis();
    public abstract virtual bool get_RequiresValueContentAnalysis();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.LdapSanitizers : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SanitizerInfo> <SanitizerInfos>k__BackingField;
    public static ImmutableHashSet`1<SanitizerInfo> SanitizerInfos { get; }
    private static LdapSanitizers();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SanitizerInfo> get_SanitizerInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.LdapSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static LdapSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.MethodMatcher : MulticastDelegate {
    public MethodMatcher(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(string methodName, ImmutableArray`1<IArgumentOperation> arguments);
    public virtual IAsyncResult BeginInvoke(string methodName, ImmutableArray`1<IArgumentOperation> arguments, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.ParameterMatcher : MulticastDelegate {
    public ParameterMatcher(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(IParameterSymbol parameter, WellKnownTypeProvider wellKnownTypeProvider);
    public virtual IAsyncResult BeginInvoke(IParameterSymbol parameter, WellKnownTypeProvider wellKnownTypeProvider, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.PointsToCheck : MulticastDelegate {
    public PointsToCheck(object object, IntPtr method);
    public virtual bool Invoke(ImmutableArray`1<PointsToAbstractValue> pointsTos);
    public virtual IAsyncResult BeginInvoke(ImmutableArray`1<PointsToAbstractValue> pointsTos, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.PooledHashSetExtensions : object {
    [ExtensionAttribute]
public static void AddSinkInfo(PooledHashSet`1<SinkInfo> builder, string fullTypeName, SinkKind sinkKind, bool isInterface, bool isAnyStringParameterInConstructorASink, IEnumerable`1<string> sinkProperties, IEnumerable`1<ValueTuple`2<string, String[]>> sinkMethodParameters);
    [ExtensionAttribute]
public static void AddSinkInfo(PooledHashSet`1<SinkInfo> builder, string fullTypeName, IEnumerable`1<SinkKind> sinkKinds, bool isInterface, bool isAnyStringParameterInConstructorASink, IEnumerable`1<string> sinkProperties, IEnumerable`1<ValueTuple`2<string, String[]>> sinkMethodParameters);
    [ExtensionAttribute]
public static void AddSourceInfo(PooledHashSet`1<SourceInfo> builder, string fullTypeName, IEnumerable`1<ParameterMatcher> taintedArguments);
    [ExtensionAttribute]
public static void AddSourceInfo(PooledHashSet`1<SourceInfo> builder, ImmutableArray`1<string> dependencyFullTypeNames, string fullTypeName, IEnumerable`1<ParameterMatcher> taintedArguments);
    [ExtensionAttribute]
public static void AddSourceInfo(PooledHashSet`1<SourceInfo> builder, string fullTypeName, bool isInterface, IEnumerable`1<string> taintedProperties, IEnumerable`1<string> taintedMethods);
    [ExtensionAttribute]
public static void AddSourceInfoSpecifyingTaintedTargets(PooledHashSet`1<SourceInfo> builder, string fullTypeName, bool isInterface, IEnumerable`1<string> taintedProperties, IEnumerable`1<ValueTuple`2<MethodMatcher, ValueTuple`2[]>> taintedMethodsNeedsPointsToAnalysis, IEnumerable`1<ValueTuple`2<MethodMatcher, ValueTuple`2[]>> taintedMethodsNeedsValueContentAnalysis, IEnumerable`1<ValueTuple`2<MethodMatcher, ValueTuple`2[]>> transferMethods, IEnumerable`1<string> transferProperties, bool taintConstantArray, ArrayLengthMatcher constantArrayLengthMatcher);
    [ExtensionAttribute]
public static void AddSourceInfo(PooledHashSet`1<SourceInfo> builder, string fullTypeName, bool isInterface, IEnumerable`1<string> taintedProperties, IEnumerable`1<ValueTuple`2<MethodMatcher, PointsToCheck[]>> taintedMethodsNeedsPointsToAnalysis, IEnumerable`1<ValueTuple`2<MethodMatcher, ValueContentCheck[]>> taintedMethodsNeedsValueContentAnalysis, bool taintConstantArray, ArrayLengthMatcher constantArrayLengthMatcher);
    [ExtensionAttribute]
public static void AddSanitizerInfo(PooledHashSet`1<SanitizerInfo> builder, string fullTypeName, bool isInterface, bool isConstructorSanitizing, IEnumerable`1<string> sanitizingMethods, IEnumerable`1<string> sanitizingInstanceMethods);
    [ExtensionAttribute]
public static void AddSanitizerInfo(PooledHashSet`1<SanitizerInfo> builder, string fullTypeName, bool isInterface, bool isConstructorSanitizing, IEnumerable`1<ValueTuple`2<MethodMatcher, ValueTuple`2[]>> sanitizingMethods, IEnumerable`1<string> sanitizingInstanceMethods);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.PrimitiveTypeConverterSanitizers : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SanitizerInfo> <SanitizerInfos>k__BackingField;
    public static ImmutableHashSet`1<SanitizerInfo> SanitizerInfos { get; }
    private static PrimitiveTypeConverterSanitizers();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SanitizerInfo> get_SanitizerInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.ProcessCommandSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static ProcessCommandSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.RedirectSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static RedirectSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.RegexSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static RegexSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.SanitizerInfo : object {
    [CompilerGeneratedAttribute]
private string <FullTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConstructorSanitizing>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<string, string>>>> <SanitizingMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <SanitizingInstanceMethods>k__BackingField;
    public string FullTypeName { get; }
    public bool IsInterface { get; }
    public bool IsConstructorSanitizing { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<string, string>>>> SanitizingMethods { get; }
    public ImmutableHashSet`1<string> SanitizingInstanceMethods { get; }
    public bool RequiresValueContentAnalysis { get; }
    public bool RequiresParameterReferenceAnalysis { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> DependencyFullTypeNames { get; }
    public SanitizerInfo(string fullTypeName, bool isInterface, bool isConstructorSanitizing, ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<string, string>>>> sanitizingMethods, ImmutableHashSet`1<string> sanitizingInstanceMethods);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullTypeName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInterface();
    [CompilerGeneratedAttribute]
public bool get_IsConstructorSanitizing();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<string, string>>>> get_SanitizingMethods();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_SanitizingInstanceMethods();
    public sealed virtual bool get_RequiresValueContentAnalysis();
    public sealed virtual bool get_RequiresParameterReferenceAnalysis();
    public sealed virtual ImmutableArray`1<string> get_DependencyFullTypeNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SanitizerInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.SinkInfo : object {
    [CompilerGeneratedAttribute]
private string <FullTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<SinkKind> <SinkKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnyStringParameterInConstructorASink>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <SinkProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ImmutableHashSet`1<string>> <SinkMethodParameters>k__BackingField;
    public string FullTypeName { get; }
    public ImmutableHashSet`1<SinkKind> SinkKinds { get; }
    public bool IsInterface { get; }
    public bool IsAnyStringParameterInConstructorASink { get; }
    public ImmutableHashSet`1<string> SinkProperties { get; }
    public ImmutableDictionary`2<string, ImmutableHashSet`1<string>> SinkMethodParameters { get; }
    public bool RequiresValueContentAnalysis { get; }
    public bool RequiresParameterReferenceAnalysis { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> DependencyFullTypeNames { get; }
    public SinkInfo(string fullTypeName, ImmutableHashSet`1<SinkKind> sinkKinds, bool isInterface, bool isAnyStringParameterInConstructorASink, ImmutableHashSet`1<string> sinkProperties, ImmutableDictionary`2<string, ImmutableHashSet`1<string>> sinkMethodParameters);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullTypeName();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<SinkKind> get_SinkKinds();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInterface();
    [CompilerGeneratedAttribute]
public bool get_IsAnyStringParameterInConstructorASink();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_SinkProperties();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ImmutableHashSet`1<string>> get_SinkMethodParameters();
    public sealed virtual bool get_RequiresValueContentAnalysis();
    public sealed virtual bool get_RequiresParameterReferenceAnalysis();
    public sealed virtual ImmutableArray`1<string> get_DependencyFullTypeNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SinkInfo other);
}
public enum Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.SinkKind : Enum {
    public int value__;
    public static SinkKind Sql;
    public static SinkKind Dll;
    public static SinkKind InformationDisclosure;
    public static SinkKind Xss;
    public static SinkKind FilePathInjection;
    public static SinkKind ProcessCommand;
    public static SinkKind Regex;
    public static SinkKind Ldap;
    public static SinkKind Redirect;
    public static SinkKind XPath;
    public static SinkKind Xml;
    public static SinkKind Xaml;
    public static SinkKind ZipSlip;
    public static SinkKind HardcodedEncryptionKey;
    public static SinkKind HardcodedCertificate;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.SourceInfo : object {
    [CompilerGeneratedAttribute]
private string <FullTypeName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <DependencyFullTypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <TransferProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <TaintedProperties>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<string>>> <TaintedMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<ParameterMatcher> <TaintedArguments>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<PointsToCheck, string>>>> <TaintedMethodsNeedsPointsToAnalysis>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<ValueContentCheck, string>>>> <TaintedMethodsNeedsValueContentAnalysis>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<string, string>>>> <TransferMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TaintConstantArray>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ArrayLengthMatcher <ConstantArrayLengthMatcher>k__BackingField;
    public string FullTypeName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> DependencyFullTypeNames { get; }
    public bool IsInterface { get; }
    public ImmutableHashSet`1<string> TransferProperties { get; }
    public ImmutableHashSet`1<string> TaintedProperties { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<string>>> TaintedMethods { get; }
    public ImmutableHashSet`1<ParameterMatcher> TaintedArguments { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<PointsToCheck, string>>>> TaintedMethodsNeedsPointsToAnalysis { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<ValueContentCheck, string>>>> TaintedMethodsNeedsValueContentAnalysis { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<string, string>>>> TransferMethods { get; }
    public bool TaintConstantArray { get; }
    [NullableAttribute("2")]
public ArrayLengthMatcher ConstantArrayLengthMatcher { get; }
    public bool RequiresValueContentAnalysis { get; }
    public bool RequiresParameterReferenceAnalysis { get; }
    public SourceInfo(string fullTypeName, bool isInterface, ImmutableHashSet`1<string> taintedProperties, ImmutableHashSet`1<ParameterMatcher> taintedArguments, ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<string>>> taintedMethods, ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<PointsToCheck, string>>>> taintedMethodsNeedsPointsToAnalysis, ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<ValueContentCheck, string>>>> taintedMethodsNeedsValueContentAnalysis, ImmutableHashSet`1<string> transferProperties, ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<string, string>>>> transferMethods, bool taintConstantArray, ArrayLengthMatcher constantArrayLengthMatcher, Nullable`1<ImmutableArray`1<string>> dependencyFullTypeNames);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullTypeName();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_DependencyFullTypeNames();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInterface();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_TransferProperties();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_TaintedProperties();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<string>>> get_TaintedMethods();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ParameterMatcher> get_TaintedArguments();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<PointsToCheck, string>>>> get_TaintedMethodsNeedsPointsToAnalysis();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<ValueContentCheck, string>>>> get_TaintedMethodsNeedsValueContentAnalysis();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ValueTuple`2<MethodMatcher, ImmutableHashSet`1<ValueTuple`2<string, string>>>> get_TransferMethods();
    [CompilerGeneratedAttribute]
public bool get_TaintConstantArray();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ArrayLengthMatcher get_ConstantArrayLengthMatcher();
    public sealed virtual bool get_RequiresValueContentAnalysis();
    public sealed virtual bool get_RequiresParameterReferenceAnalysis();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SourceInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.SqlSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static SqlSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.StringTranferSources : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SourceInfo> <SourceInfos>k__BackingField;
    public static ImmutableHashSet`1<SourceInfo> SourceInfos { get; }
    private static StringTranferSources();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SourceInfo> get_SourceInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.SymbolAccess : CacheBasedEquatable`1<SymbolAccess> {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <AccessingMethod>k__BackingField;
    public ISymbol Symbol { get; }
    public Location Location { get; }
    public ISymbol AccessingMethod { get; }
    public SymbolAccess(ISymbol symbol, SyntaxNode syntaxNode, ISymbol accessingMethod);
    public SymbolAccess(ISymbol symbol, Location location, ISymbol accessingMethod);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
public ISymbol get_AccessingMethod();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<SymbolAccess> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerDisplayAttribute("{Kind} ({SourceOrigins.Count} source origins)")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataAbstractValue : CacheBasedEquatable`1<TaintedDataAbstractValue> {
    public static TaintedDataAbstractValue NotTainted;
    [CompilerGeneratedAttribute]
private TaintedDataAbstractValueKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<SymbolAccess> <SourceOrigins>k__BackingField;
    public TaintedDataAbstractValueKind Kind { get; }
    public ImmutableHashSet`1<SymbolAccess> SourceOrigins { get; }
    private TaintedDataAbstractValue(TaintedDataAbstractValueKind kind, ImmutableHashSet`1<SymbolAccess> sourceOrigins);
    private static TaintedDataAbstractValue();
    [CompilerGeneratedAttribute]
public TaintedDataAbstractValueKind get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<SymbolAccess> get_SourceOrigins();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<TaintedDataAbstractValue> obj);
    internal static TaintedDataAbstractValue CreateTainted(ISymbol taintedSymbol, SyntaxNode accessingSyntax, ISymbol accessingMethod);
    internal static TaintedDataAbstractValue MergeTainted(TaintedDataAbstractValue value1, TaintedDataAbstractValue value2);
    internal static TaintedDataAbstractValue MergeTainted(IEnumerable`1<TaintedDataAbstractValue> taintedValues);
}
internal enum Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataAbstractValueKind : Enum {
    public int value__;
    public static TaintedDataAbstractValueKind NotTainted;
    public static TaintedDataAbstractValueKind Tainted;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataAnalysis : ForwardDataFlowAnalysis`5<TaintedDataAnalysisData, TaintedDataAnalysisContext, TaintedDataAnalysisResult, TaintedDataBlockAnalysisResult, TaintedDataAbstractValue> {
    internal static AbstractValueDomain`1<TaintedDataAbstractValue> ValueDomainInstance;
    private TaintedDataAnalysis(TaintedDataAnalysisDomain analysisDomain, TaintedDataOperationVisitor operationVisitor);
    private static TaintedDataAnalysis();
    internal static TaintedDataAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, Compilation compilation, ISymbol containingMethod, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, TaintedDataSymbolMap`1<SourceInfo> taintedSourceInfos, TaintedDataSymbolMap`1<SanitizerInfo> taintedSanitizerInfos, TaintedDataSymbolMap`1<SinkInfo> taintedSinkInfos);
    private static TaintedDataAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, Compilation compilation, ISymbol containingMethod, AnalyzerOptions analyzerOptions, TaintedDataSymbolMap`1<SourceInfo> taintedSourceInfos, TaintedDataSymbolMap`1<SanitizerInfo> taintedSanitizerInfos, TaintedDataSymbolMap`1<SinkInfo> taintedSinkInfos, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig);
    private static TaintedDataAnalysisResult TryGetOrComputeResultForAnalysisContext(TaintedDataAnalysisContext analysisContext);
    protected virtual TaintedDataAnalysisResult ToResult(TaintedDataAnalysisContext analysisContext, DataFlowAnalysisResult`2<TaintedDataBlockAnalysisResult, TaintedDataAbstractValue> dataFlowAnalysisResult);
    protected virtual TaintedDataBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, TaintedDataAnalysisData blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataAnalysisContext : AbstractDataFlowAnalysisContext`4<TaintedDataAnalysisData, TaintedDataAnalysisContext, TaintedDataAnalysisResult, TaintedDataAbstractValue> {
    [CompilerGeneratedAttribute]
private TaintedDataSymbolMap`1<SourceInfo> <SourceInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private TaintedDataSymbolMap`1<SanitizerInfo> <SanitizerInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private TaintedDataSymbolMap`1<SinkInfo> <SinkInfos>k__BackingField;
    public TaintedDataSymbolMap`1<SourceInfo> SourceInfos { get; }
    public TaintedDataSymbolMap`1<SanitizerInfo> SanitizerInfos { get; }
    public TaintedDataSymbolMap`1<SinkInfo> SinkInfos { get; }
    private TaintedDataAnalysisContext(AbstractValueDomain`1<TaintedDataAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Func`2<TaintedDataAnalysisContext, TaintedDataAnalysisResult> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<TaintedDataAnalysisData, TaintedDataAnalysisContext, TaintedDataAbstractValue> interproceduralAnalysisData, TaintedDataSymbolMap`1<SourceInfo> taintedSourceInfos, TaintedDataSymbolMap`1<SanitizerInfo> taintedSanitizerInfos, TaintedDataSymbolMap`1<SinkInfo> taintedSinkInfos);
    public static TaintedDataAnalysisContext Create(AbstractValueDomain`1<TaintedDataAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Func`2<TaintedDataAnalysisContext, TaintedDataAnalysisResult> tryGetOrComputeAnalysisResult, TaintedDataSymbolMap`1<SourceInfo> taintedSourceInfos, TaintedDataSymbolMap`1<SanitizerInfo> taintedSanitizerInfos, TaintedDataSymbolMap`1<SinkInfo> taintedSinkInfos);
    public virtual TaintedDataAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<TaintedDataAnalysisData, TaintedDataAnalysisContext, TaintedDataAbstractValue> interproceduralAnalysisData);
    [CompilerGeneratedAttribute]
public TaintedDataSymbolMap`1<SourceInfo> get_SourceInfos();
    [CompilerGeneratedAttribute]
public TaintedDataSymbolMap`1<SanitizerInfo> get_SanitizerInfos();
    [CompilerGeneratedAttribute]
public TaintedDataSymbolMap`1<SinkInfo> get_SinkInfos();
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<TaintedDataAnalysisData, TaintedDataAnalysisContext, TaintedDataAnalysisResult, TaintedDataAbstractValue> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataAnalysisData : AnalysisEntityBasedPredicateAnalysisData`1<TaintedDataAbstractValue> {
    protected AbstractValueDomain`1<TaintedDataAbstractValue> ValueDomain { get; }
    public TaintedDataAnalysisData(IDictionary`2<AnalysisEntity, TaintedDataAbstractValue> fromData);
    public TaintedDataAnalysisData(TaintedDataAnalysisData fromData);
    public TaintedDataAnalysisData(TaintedDataAnalysisData fromData, TaintedDataAnalysisData data, MapAbstractDomain`2<AnalysisEntity, TaintedDataAbstractValue> coreDataAnalysisDomain);
    protected virtual AbstractValueDomain`1<TaintedDataAbstractValue> get_ValueDomain();
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<TaintedDataAbstractValue> Clone();
    public virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<TaintedDataAbstractValue> other, MapAbstractDomain`2<AnalysisEntity, TaintedDataAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<TaintedDataAbstractValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<TaintedDataAbstractValue> data, MapAbstractDomain`2<AnalysisEntity, TaintedDataAbstractValue> coreDataAnalysisDomain);
    public void Reset(TaintedDataAbstractValue resetValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataAnalysisResult : DataFlowAnalysisResult`2<TaintedDataBlockAnalysisResult, TaintedDataAbstractValue> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<TaintedDataSourceSink> <TaintedDataSourceSinks>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TaintedDataSourceSink> TaintedDataSourceSinks { get; }
    public TaintedDataAnalysisResult(DataFlowAnalysisResult`2<TaintedDataBlockAnalysisResult, TaintedDataAbstractValue> dataFlowAnalysisResult, ImmutableArray`1<TaintedDataSourceSink> taintedDataSourceSinks);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TaintedDataSourceSink> get_TaintedDataSourceSinks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, TaintedDataAbstractValue> <Data>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, TaintedDataAbstractValue> Data { get; }
    public TaintedDataBlockAnalysisResult(BasicBlock basicBlock, TaintedDataAnalysisData blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, TaintedDataAbstractValue> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataConfig : object {
    private static BoundedCacheWithFactory`2<Compilation, TaintedDataConfig> s_ConfigsByCompilation;
    private static ImmutableDictionary`2<SinkKind, ImmutableHashSet`1<SourceInfo>> s_sinkKindToSourceInfo;
    private static ImmutableDictionary`2<SinkKind, ImmutableHashSet`1<SanitizerInfo>> s_sinkKindToSanitizerInfo;
    private static ImmutableDictionary`2<SinkKind, bool> s_sinkKindHasTaintArraySource;
    [CompilerGeneratedAttribute]
private WellKnownTypeProvider <WellKnownTypeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SourceInfo>>> <SourceSymbolMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SanitizerInfo>>> <SanitizerSymbolMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SinkInfo>>> <SinkSymbolMap>k__BackingField;
    private WellKnownTypeProvider WellKnownTypeProvider { get; }
    private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SourceInfo>>> SourceSymbolMap { get; }
    private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SanitizerInfo>>> SanitizerSymbolMap { get; }
    private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SinkInfo>>> SinkSymbolMap { get; }
    private TaintedDataConfig(WellKnownTypeProvider wellKnownTypeProvider, ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SourceInfo>>> sourceSymbolMap, ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SanitizerInfo>>> sanitizerSymbolMap, ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SinkInfo>>> sinkSymbolMap);
    private static TaintedDataConfig();
    [CompilerGeneratedAttribute]
private WellKnownTypeProvider get_WellKnownTypeProvider();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SourceInfo>>> get_SourceSymbolMap();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SanitizerInfo>>> get_SanitizerSymbolMap();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<SinkInfo>>> get_SinkSymbolMap();
    public static TaintedDataConfig GetOrCreate(Compilation compilation);
    private static TaintedDataConfig Create(Compilation compilation);
    public TaintedDataSymbolMap`1<SourceInfo> GetSourceSymbolMap(SinkKind sinkKind);
    public TaintedDataSymbolMap`1<SanitizerInfo> GetSanitizerSymbolMap(SinkKind sinkKind);
    public TaintedDataSymbolMap`1<SinkInfo> GetSinkSymbolMap(SinkKind sinkKind);
    public static bool HasTaintArraySource(SinkKind sinkKind);
    private TaintedDataSymbolMap`1<T> GetFromMap(SinkKind sinkKind, ImmutableDictionary`2<SinkKind, Lazy`1<TaintedDataSymbolMap`1<T>>> map);
    private static ImmutableHashSet`1<SourceInfo> GetSourceInfos(SinkKind sinkKind);
    private static ImmutableHashSet`1<SanitizerInfo> GetSanitizerInfos(SinkKind sinkKind);
    private static ImmutableHashSet`1<SinkInfo> GetSinkInfos(SinkKind sinkKind);
}
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataProperties : object {
    [NullableAttribute("1")]
public static string IndexerName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataSourceSink : object {
    [CompilerGeneratedAttribute]
private SymbolAccess <Sink>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<SinkKind> <SinkKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<SymbolAccess> <SourceOrigins>k__BackingField;
    public SymbolAccess Sink { get; }
    public ImmutableHashSet`1<SinkKind> SinkKinds { get; }
    public ImmutableHashSet`1<SymbolAccess> SourceOrigins { get; }
    public TaintedDataSourceSink(SymbolAccess sink, ImmutableHashSet`1<SinkKind> sinkKinds, ImmutableHashSet`1<SymbolAccess> sourceOrigins);
    [CompilerGeneratedAttribute]
public SymbolAccess get_Sink();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<SinkKind> get_SinkKinds();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<SymbolAccess> get_SourceOrigins();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataSymbolMap`1 : object {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ITypeSymbol, TInfo> <ConcreteInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ITypeSymbol, TInfo> <InterfaceInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresValueContentAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresParameterReferenceAnalysis>k__BackingField;
    private ImmutableDictionary`2<ITypeSymbol, TInfo> ConcreteInfos { get; }
    private ImmutableDictionary`2<ITypeSymbol, TInfo> InterfaceInfos { get; }
    public bool IsEmpty { get; }
    public bool RequiresValueContentAnalysis { get; }
    public bool RequiresParameterReferenceAnalysis { get; }
    public TaintedDataSymbolMap`1(WellKnownTypeProvider wellKnownTypeProvider, IEnumerable`1<TInfo> taintedDataInfos);
    private static bool TryResolveDependencies(TInfo info, WellKnownTypeProvider wellKnownTypeProvider);
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ITypeSymbol, TInfo> get_ConcreteInfos();
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ITypeSymbol, TInfo> get_InterfaceInfos();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public bool get_RequiresValueContentAnalysis();
    [CompilerGeneratedAttribute]
public bool get_RequiresParameterReferenceAnalysis();
    [IteratorStateMachineAttribute("Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataSymbolMap`1/<GetInfosForType>d__16")]
public IEnumerable`1<TInfo> GetInfosForType(INamedTypeSymbol namedTypeSymbol);
    public sealed virtual bool Equals(TaintedDataSymbolMap`1<TInfo> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedDataSymbolMapExtensions : object {
    [ExtensionAttribute]
public static bool IsSourceMethod(TaintedDataSymbolMap`1<SourceInfo> sourceSymbolMap, IMethodSymbol method, ImmutableArray`1<IArgumentOperation> arguments, Lazy`1<PointsToAnalysisResult> pointsToFactory, Lazy`1<ValueTuple`2<PointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>>> valueContentFactory, PooledHashSet`1& allTaintedTargets);
    [ExtensionAttribute]
public static bool IsSourceProperty(TaintedDataSymbolMap`1<SourceInfo> sourceSymbolMap, IPropertySymbol propertySymbol);
    [ExtensionAttribute]
public static bool IsSourceParameter(TaintedDataSymbolMap`1<SourceInfo> sourceSymbolMap, IParameterSymbol parameterSymbol, WellKnownTypeProvider wellKnownTypeProvider);
    [ExtensionAttribute]
public static bool IsSourceConstantArrayOfType(TaintedDataSymbolMap`1<SourceInfo> sourceSymbolMap, IArrayTypeSymbol arrayTypeSymbol, IArrayInitializerOperation arrayInitializerOperation);
    [ExtensionAttribute]
public static bool IsSourceTransferMethod(TaintedDataSymbolMap`1<SourceInfo> sourceSymbolMap, IMethodSymbol method, ImmutableArray`1<IArgumentOperation> arguments, ISet`1<string> taintedParameterNames, PooledHashSet`1& taintedParameterPairs);
    [ExtensionAttribute]
public static bool IsSourceTransferProperty(TaintedDataSymbolMap`1<SourceInfo> sourceSymbolMap, IPropertyReferenceOperation propertyReferenceOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.TaintedTargetValue : object {
    public static string Return;
    public static string This;
}
internal class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.ValueContentCheck : MulticastDelegate {
    public ValueContentCheck(object object, IntPtr method);
    public virtual bool Invoke(ImmutableArray`1<PointsToAbstractValue> pointsTos, ImmutableArray`1<ValueContentAbstractValue> valueContents);
    public virtual IAsyncResult BeginInvoke(ImmutableArray`1<PointsToAbstractValue> pointsTos, ImmutableArray`1<ValueContentAbstractValue> valueContents, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.WebInputSources : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SourceInfo> <SourceInfos>k__BackingField;
    private static BoundedCacheWithFactory`2<Compilation, ConcurrentDictionary`2<INamedTypeSymbol, bool>> s_classIsControllerByCompilation;
    public static ImmutableHashSet`1<SourceInfo> SourceInfos { get; }
    private static WebInputSources();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SourceInfo> get_SourceInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.WebOutputSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static WebOutputSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.XamlSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static XamlSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.XmlSanitizers : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SanitizerInfo> <SanitizerInfos>k__BackingField;
    public static ImmutableHashSet`1<SanitizerInfo> SanitizerInfos { get; }
    private static XmlSanitizers();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SanitizerInfo> get_SanitizerInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.XmlSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static XmlSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.XPathSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static XPathSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.XssSanitizers : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SanitizerInfo> <SanitizerInfos>k__BackingField;
    public static ImmutableHashSet`1<SanitizerInfo> SanitizerInfos { get; }
    private static XssSanitizers();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SanitizerInfo> get_SanitizerInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.ZipSlipSanitizers : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SanitizerInfo> <SanitizerInfos>k__BackingField;
    public static ImmutableHashSet`1<SanitizerInfo> SanitizerInfos { get; }
    private static ZipSlipSanitizers();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SanitizerInfo> get_SanitizerInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.ZipSlipSinks : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SinkInfo> <SinkInfos>k__BackingField;
    public static ImmutableHashSet`1<SinkInfo> SinkInfos { get; }
    private static ZipSlipSinks();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SinkInfo> get_SinkInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis.ZipSlipSources : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<SourceInfo> <SourceInfos>k__BackingField;
    public static ImmutableHashSet`1<SourceInfo> SourceInfos { get; }
    private static ZipSlipSources();
    [CompilerGeneratedAttribute]
public static ImmutableHashSet`1<SourceInfo> get_SourceInfos();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FxCopWellKnownDiagnosticTags : object {
    public static string PortedFromFxCop;
    public static String[] PortedFxCopRule;
    public static String[] PortedFxCopRuleEnabledInAggressiveMode;
    public static String[] PortedFxCopDataflowRule;
    public static String[] PortedFxCopDataflowRuleEnabledInAggressiveMode;
    private static FxCopWellKnownDiagnosticTags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.HashUtilities : object {
    [ExtensionAttribute]
internal static int GetHashCodeOrDefault(T obj);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static int GetHashCodeOrDefault(Nullable`1<T> obj);
    [NullableContextAttribute("2")]
internal static int Combine(ImmutableArray`1<T> array);
    [NullableContextAttribute("2")]
internal static void Combine(ImmutableArray`1<T> array, RoslynHashCode& hashCode);
    internal static int Combine(ImmutableStack`1<T> stack);
    internal static void Combine(ImmutableStack`1<T> stack, RoslynHashCode& hashCode);
    internal static int Combine(ImmutableHashSet`1<T> set);
    internal static void Combine(ImmutableHashSet`1<T> set, RoslynHashCode& hashCode);
    internal static int Combine(ImmutableDictionary`2<TKey, TValue> dictionary);
    internal static void Combine(ImmutableDictionary`2<TKey, TValue> dictionary, RoslynHashCode& hashCode);
}
[NullableContextAttribute("1")]
internal interface Analyzer.Utilities.ICategorizedAnalyzerConfigOptions {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue, OptionKind kind);
    public abstract virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`2<T, TArg> tryParseValue, TArg arg, T defaultValue, OptionKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.Lightup.IFunctionPointerInvocationOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    [NullableAttribute("2")]
private static Type WrappedType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<IOperation, ImmutableArray`1<IArgumentOperation>> ArgumentsAccessor;
    private static Func`2<IOperation, IOperation> TargetAccessor;
    private static Func`2<IOperation, IMethodSymbol> GetFunctionPointerSignatureAccessor;
    [CompilerGeneratedAttribute]
private IOperation <WrappedOperation>k__BackingField;
    public IOperation WrappedOperation { get; }
    [NullableAttribute("2")]
public ITypeSymbol Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public IOperation Target { get; }
    private IFunctionPointerInvocationOperationWrapper(IOperation operation);
    private static IFunctionPointerInvocationOperationWrapper();
    private static Func`2<IOperation, IMethodSymbol> CreateFunctionPointerSignatureAccessor(Type wrappedType);
    [CompilerGeneratedAttribute]
public sealed virtual IOperation get_WrappedOperation();
    [NullableContextAttribute("2")]
public ITypeSymbol get_Type();
    public ImmutableArray`1<IArgumentOperation> get_Arguments();
    public IOperation get_Target();
    public IMethodSymbol GetFunctionPointerSignature();
    public static IFunctionPointerInvocationOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[NullableContextAttribute("2")]
internal interface Analyzer.Utilities.Lightup.IOperationWrapper {
    public IOperation WrappedOperation { get; }
    public abstract virtual IOperation get_WrappedOperation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.Lightup.IUtf8StringOperationWrapper : ValueType {
    internal static string WrappedTypeName;
    [NullableAttribute("2")]
private static Type WrappedType;
    private static Func`2<IOperation, string> ValueAccessor;
    [CompilerGeneratedAttribute]
private IOperation <WrappedOperation>k__BackingField;
    public IOperation WrappedOperation { get; }
    [NullableAttribute("2")]
public ITypeSymbol Type { get; }
    public string Value { get; }
    private IUtf8StringOperationWrapper(IOperation operation);
    private static IUtf8StringOperationWrapper();
    [CompilerGeneratedAttribute]
public sealed virtual IOperation get_WrappedOperation();
    [NullableContextAttribute("2")]
public ITypeSymbol get_Type();
    public string get_Value();
    public static IUtf8StringOperationWrapper FromOperation(IOperation operation);
    public static bool IsInstance(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.Lightup.LightupHelpers : object {
    private static ConcurrentDictionary`2<Type, ConcurrentDictionary`2<OperationKind, bool>> s_supportedOperationWrappers;
    private static LightupHelpers();
    [NullableContextAttribute("2")]
internal static bool CanWrapOperation(IOperation operation, Type underlyingType);
    internal static Func`2<TOperation, TProperty> CreateOperationPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    internal static Func`2<TSyntax, TProperty> CreateSyntaxPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    internal static Func`2<TSymbol, TProperty> CreateSymbolPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    private static Func`2<T, TProperty> CreatePropertyAccessor(Type type, string parameterName, string propertyName, TProperty fallbackResult);
    internal static Func`3<TSyntax, TProperty, TSyntax> CreateSyntaxWithPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    internal static Func`3<TSymbol, TProperty, TSymbol> CreateSymbolWithPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    private static Func`3<T, TProperty, T> CreateWithPropertyAccessor(Type type, string parameterName, string propertyName, TProperty fallbackResult);
    internal static Func`3<T, TArg, TValue> CreateAccessorWithArgument(Type type, string parameterName, Type argumentType, string argumentName, string methodName, TValue fallbackResult);
    private static void VerifyTypeArgument(Type type);
    private static void VerifyResultTypeCompatibility(Type resultType);
    [NullableContextAttribute("2")]
private static bool TryGetProperty(Type type, string propertyName, PropertyInfo& propertyInfo);
    [NullableContextAttribute("2")]
private static bool TryGetMethod(Type type, string methodName, MethodInfo& methodInfo);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static TProperty <CreatePropertyAccessor>g__FallbackAccessor|5_1(T instance, TProperty fallbackResult);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <CreateWithPropertyAccessor>g__FallbackAccessor|8_3(T instance, TProperty newValue, TProperty fallbackResult);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static TValue <CreateAccessorWithArgument>g__FallbackAccessor|9_1(T instance, TValue fallbackResult);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.Lightup.NullableSyntaxAnnotationEx : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Oblivious>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <AnnotatedOrNotAnnotated>k__BackingField;
    public static SyntaxAnnotation Oblivious { get; }
    public static SyntaxAnnotation AnnotatedOrNotAnnotated { get; }
    private static NullableSyntaxAnnotationEx();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Oblivious();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_AnnotatedOrNotAnnotated();
}
internal static class Analyzer.Utilities.Lightup.OperationKindEx : object {
    public static OperationKind FunctionPointerInvocation;
    public static OperationKind ImplicitIndexerReference;
    public static OperationKind Utf8String;
    public static OperationKind Attribute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.Lightup.OperationWrapperHelper : object {
    private static Assembly s_codeAnalysisAssembly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<Type, Type> WrappedTypes;
    private static OperationWrapperHelper();
    internal static Type GetWrappedType(Type wrapperType);
}
internal static class Analyzer.Utilities.MSBuildItemOptionNames : object {
    [NullableAttribute("1")]
public static string SupportedPlatform;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.MSBuildItemOptionNamesHelpers : object {
    public static char ValuesSeparator;
    private static Char[] s_itemMetadataValuesSeparators;
    private static MSBuildItemOptionNamesHelpers();
    public static string GetPropertyNameForItemOptionName(string itemOptionName);
    [ConditionalAttribute("DEBUG")]
public static void VerifySupportedItemOptionName(string itemOptionName);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<string> ParseItemOptionValue(string itemOptionValue);
    [IteratorStateMachineAttribute("Analyzer.Utilities.MSBuildItemOptionNamesHelpers/<ProduceTrimmedArray>d__5")]
private static IEnumerable`1<string> ProduceTrimmedArray(string itemOptionValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.MSBuildPropertyOptionNames : object {
    public static string TargetFramework;
    public static string TargetPlatformMinVersion;
    public static string UsingMicrosoftNETSdkWeb;
    public static string ProjectTypeGuids;
    public static string InvariantGlobalization;
    public static string PlatformNeutralAssembly;
    public static string EnforceExtendedAnalyzerRules;
}
internal static class Analyzer.Utilities.MSBuildPropertyOptionNamesHelpers : object {
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void VerifySupportedPropertyOptionName(string propertyOptionName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.OptionKey : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`2<string, string>, OptionKey> s_keys;
    private static int s_lastOrdinal;
    private int _ordinal;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    private OptionKey(string name);
    private static OptionKey();
    [CompilerGeneratedAttribute]
public string get_Name();
    public static OptionKey GetOrCreate(string ruleId, string optionName);
    public static bool op_Equality(OptionKey left, OptionKey right);
    public static bool op_Inequality(OptionKey left, OptionKey right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(OptionKey other);
}
internal enum Analyzer.Utilities.OptionKind : Enum {
    public int value__;
    public static OptionKind DotnetCodeQuality;
    public static OptionKind BuildProperty;
}
internal enum Analyzer.Utilities.Options.EnumValuesPrefixTrigger : Enum {
    public int value__;
    public static EnumValuesPrefixTrigger AnyEnumValue;
    public static EnumValuesPrefixTrigger AllEnumValues;
    public static EnumValuesPrefixTrigger Heuristic;
}
internal static class Analyzer.Utilities.PathHelper : object {
    [NullableAttribute("1")]
private static Char[] DirectorySeparatorCharacters;
    private static PathHelper();
    public static ReadOnlySpan`1<char> GetFileName(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Analyzer.Utilities.PooledObjects.ArrayBuilder`1/DebuggerProxy")]
internal class Analyzer.Utilities.PooledObjects.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void SetItem(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public sealed virtual void Dispose();
    private void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    internal static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    internal static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    [NullableContextAttribute("0")]
internal Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.PooledObjects.Extensions.ArrayBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, T item);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.PooledObjects.Extensions.PooledHashSetExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddRange(PooledHashSet`1<T> builder, IEnumerable`1<T> set2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.PooledObjects.ObjectPool`1 : object {
    [NullableAttribute("2")]
private T _firstItem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Element[] _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj, CancellationToken cancellationToken);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal static void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledConcurrentDictionary`2 : ConcurrentDictionary`2<K, V> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledConcurrentDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledConcurrentDictionary`2<K, V>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<K>, ObjectPool`1<PooledConcurrentDictionary`2<K, V>>> s_poolInstancesByComparer;
    private PooledConcurrentDictionary`2(ObjectPool`1<PooledConcurrentDictionary`2<K, V>> pool);
    private PooledConcurrentDictionary`2(ObjectPool`1<PooledConcurrentDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledConcurrentDictionary`2();
    public sealed virtual void Dispose();
    public void Free(CancellationToken cancellationToken);
    public static ObjectPool`1<PooledConcurrentDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledConcurrentDictionary`2<K, V> GetInstance(IEqualityComparer`1<K> keyComparer);
    public static PooledConcurrentDictionary`2<K, V> GetInstance(IEnumerable`1<KeyValuePair`2<K, V>> initializer, IEqualityComparer`1<K> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1 : object {
    private PooledConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    private PooledConcurrentSet`1(PooledConcurrentDictionary`2<T, byte> dictionary);
    public sealed virtual void Dispose();
    public void Free(CancellationToken cancellationToken);
    public static PooledConcurrentSet`1<T> GetInstance(IEqualityComparer`1<T> comparer);
    public static PooledConcurrentSet`1<T> GetInstance(IEnumerable`1<T> initializer, IEqualityComparer`1<T> comparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsReadOnly();
    public bool Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [NullableContextAttribute("0")]
public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1/<GetEnumeratorCore>d__19")]
private IEnumerator`1<T> GetEnumeratorCore();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledDictionary`2 : Dictionary`2<K, V> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<K>, ObjectPool`1<PooledDictionary`2<K, V>>> s_poolInstancesByComparer;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledDictionary`2();
    public sealed virtual void Dispose();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public ImmutableDictionary`2<TKey, TValue> ToImmutableDictionaryAndFree(Func`2<KeyValuePair`2<K, V>, TKey> keySelector, Func`2<KeyValuePair`2<K, V>, TValue> elementSelector, IEqualityComparer`1<TKey> comparer);
    public void Free(CancellationToken cancellationToken);
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance(IEnumerable`1<KeyValuePair`2<K, V>> initializer, IEqualityComparer`1<K> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledHashSet`1 : HashSet`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<T>, ObjectPool`1<PooledHashSet`1<T>>> s_poolInstancesByComparer;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool, IEqualityComparer`1<T> comparer);
    private static PooledHashSet`1();
    public sealed virtual void Dispose();
    public void Free(CancellationToken cancellationToken);
    public ImmutableHashSet`1<T> ToImmutableAndFree();
    public ImmutableHashSet`1<T> ToImmutable();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool(IEqualityComparer`1<T> comparer);
    public static PooledHashSet`1<T> GetInstance(IEqualityComparer`1<T> comparer);
    public static PooledHashSet`1<T> GetInstance(IEnumerable`1<T> initializer, IEqualityComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledSortedSet`1 : SortedSet`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledSortedSet`1<T>> _pool;
    private static ObjectPool`1<PooledSortedSet`1<T>> s_poolInstance;
    private static ConcurrentDictionary`2<IComparer`1<T>, ObjectPool`1<PooledSortedSet`1<T>>> s_poolInstancesByComparer;
    public PooledSortedSet`1(ObjectPool`1<PooledSortedSet`1<T>> pool, IComparer`1<T> comparer);
    private static PooledSortedSet`1();
    public sealed virtual void Dispose();
    public void Free(CancellationToken cancellationToken);
    private static ObjectPool`1<PooledSortedSet`1<T>> CreatePool(IComparer`1<T> comparer);
    public static PooledSortedSet`1<T> GetInstance(IComparer`1<T> comparer);
    public static PooledSortedSet`1<T> GetInstance(IEnumerable`1<T> initializer, IComparer`1<T> comparer);
}
internal class Analyzer.Utilities.PooledObjects.TemporaryDictionary`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TemporaryDictionary`2<TKey, TValue> Empty;
    [NullableAttribute("1")]
private static Dictionary`2<TKey, TValue> EmptyDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledDictionary`2<TKey, TValue> _storage;
    public Enumerable<TKey, TValue> NonConcurrentEnumerable { get; }
    private static TemporaryDictionary`2();
    [IsReadOnlyAttribute]
public Enumerable<TKey, TValue> get_NonConcurrentEnumerable();
    public void Free(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private PooledDictionary`2<TKey, TValue> GetOrCreateStorage(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
internal void Add(TKey key, TValue value, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.PooledObjects.TemporarySet`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TemporarySet`1<T> Empty;
    private static HashSet`1<T> EmptyHashSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledHashSet`1<T> _storage;
    [NullableAttribute("0")]
public Enumerable<T> NonConcurrentEnumerable { get; }
    private static TemporarySet`1();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
public Enumerable<T> get_NonConcurrentEnumerable();
    public void Free(CancellationToken cancellationToken);
    private PooledHashSet`1<T> GetOrCreateStorage(CancellationToken cancellationToken);
    public bool Add(T item, CancellationToken cancellationToken);
    [IsReadOnlyAttribute]
public bool Contains(T item);
    [IsReadOnlyAttribute]
public bool Contains_NonConcurrent(T item);
    [IsReadOnlyAttribute]
public bool Any_NonConcurrent();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator_NonConcurrent();
    [IsReadOnlyAttribute]
public IEnumerable`1<T> AsEnumerable_NonConcurrent();
}
internal static class Analyzer.Utilities.RoslynDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Analyzer.Utilities.RoslynHashCode : ValueType {
    private static UInt32 s_seed;
    private static UInt32 Prime1;
    private static UInt32 Prime2;
    private static UInt32 Prime3;
    private static UInt32 Prime4;
    private static UInt32 Prime5;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static RoslynHashCode();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    [IsReadOnlyAttribute]
public int ToHashCode();
    [IsReadOnlyAttribute]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.RoslynString : object {
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SingleThreadedConcurrentDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<TKey, Entry<TKey, TValue>> BackingDictionary;
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Analyzer.Utilities.SmallDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AvlNode<K, V> _root;
    public IEqualityComparer`1<K> Comparer;
    public static SmallDictionary`2<K, V> Empty;
    public bool IsEmpty { get; }
    public V Item { get; public set; }
    [NullableAttribute("0")]
public KeyCollection<K, V> Keys { get; }
    [NullableAttribute("0")]
public ValueCollection<K, V> Values { get; }
    public SmallDictionary`2(IEqualityComparer`1<K> comparer);
    public SmallDictionary`2(SmallDictionary`2<K, V> other, IEqualityComparer`1<K> comparer);
    private static SmallDictionary`2();
    private bool CompareKeys(K k1, K k2);
    private int GetHashCode(K k);
    public bool get_IsEmpty();
    public void Remove(K key);
    private static AvlNode<K, V> Remove(AvlNode<K, V> currentNode, int hashCode);
    private static AvlNode<K, V> MinValueNode(AvlNode<K, V> node);
    private static int Height(AvlNode<K, V> node);
    public bool TryGetValue(K key, V& value);
    public void Add(K key, V value);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool ContainsKey(K key);
    [ConditionalAttribute("DEBUG")]
internal void AssertBalanced();
    private bool TryGetValue(int hashCode, K key, V& value);
    private bool GetFromList(Node<K, V> next, K key, V& value);
    private void Insert(int hashCode, K key, V value, bool add);
    private static AvlNode<K, V> LeftSimple(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> RightSimple(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> LeftComplex(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> RightComplex(AvlNode<K, V> unbalanced);
    private void HandleInsert(AvlNode<K, V> node, AvlNode<K, V> parent, K key, V value, bool add);
    private void AddNode(AvlNode<K, V> node, AvlNode<K, V> parent, K key, V value);
    [NullableContextAttribute("0")]
public KeyCollection<K, V> get_Keys();
    [NullableContextAttribute("0")]
public ValueCollection<K, V> get_Values();
    [NullableContextAttribute("0")]
public Enumerator<K, V> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int HeightApprox();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SymbolByDisplayStringComparer : object {
    [CompilerGeneratedAttribute]
private SymbolDisplayStringCache <SymbolDisplayStringCache>k__BackingField;
    public SymbolDisplayStringCache SymbolDisplayStringCache { get; }
    public SymbolByDisplayStringComparer(Compilation compilation);
    public SymbolByDisplayStringComparer(SymbolDisplayStringCache symbolDisplayStringCache);
    [CompilerGeneratedAttribute]
public SymbolDisplayStringCache get_SymbolDisplayStringCache();
    public sealed virtual int Compare(ITypeSymbol x, ITypeSymbol y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.SymbolDisplayFormats : object {
    public static SymbolDisplayFormat ShortSymbolDisplayFormat;
    public static SymbolDisplayFormat QualifiedTypeAndNamespaceSymbolDisplayFormat;
    private static SymbolDisplayFormats();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SymbolDisplayStringCache : object {
    private static BoundedCacheWithFactory`2<Compilation, ConcurrentDictionary`2<SymbolDisplayFormat, SymbolDisplayStringCache>> s_byCompilationCache;
    private static SymbolDisplayFormat NullSymbolDisplayFormat;
    private ConcurrentDictionary`2<ISymbol, string> SymbolToDisplayNames;
    [NullableAttribute("2")]
private SymbolDisplayFormat Format;
    [NullableContextAttribute("2")]
private SymbolDisplayStringCache(SymbolDisplayFormat format);
    private static SymbolDisplayStringCache();
    public static SymbolDisplayStringCache GetOrCreate(Compilation compilation, SymbolDisplayFormat format);
    public string GetDisplayString(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static ConcurrentDictionary`2<SymbolDisplayFormat, SymbolDisplayStringCache> <GetOrCreate>g__CreateConcurrentDictionary|5_0(Compilation compilation);
    [CompilerGeneratedAttribute]
internal static SymbolDisplayStringCache <GetOrCreate>g__CreateSymbolDisplayStringCache|5_1(SymbolDisplayFormat format);
    [CompilerGeneratedAttribute]
private string <GetDisplayString>b__6_0(ISymbol s);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.SymbolModifiers : Enum {
    public int value__;
    public static SymbolModifiers None;
    public static SymbolModifiers Static;
    public static SymbolModifiers Shared;
    public static SymbolModifiers Const;
    public static SymbolModifiers ReadOnly;
    public static SymbolModifiers Abstract;
    public static SymbolModifiers Virtual;
    public static SymbolModifiers Override;
    public static SymbolModifiers Sealed;
    public static SymbolModifiers Extern;
    public static SymbolModifiers Async;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.SymbolModifiersExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SymbolModifiers modifiers, SymbolModifiers modifiersToCheck);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SymbolModifiers GetSymbolModifiers(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SymbolNamesWithValueOption`1 : object {
    internal static SymbolKind AllKinds;
    internal static char WildcardChar;
    public static SymbolNamesWithValueOption`1<TValue> Empty;
    private ImmutableDictionary`2<string, TValue> _names;
    private ImmutableDictionary`2<ISymbol, TValue> _symbols;
    private ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> _wildcardNamesBySymbolKind;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ISymbol, KeyValuePair`2<string, TValue>> _wildcardMatchResult;
    private ConcurrentDictionary`2<ISymbol, string> _symbolToDeclarationId;
    public bool IsEmpty { get; }
    private SymbolNamesWithValueOption`1(ImmutableDictionary`2<string, TValue> names, ImmutableDictionary`2<ISymbol, TValue> symbols, ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> wildcardNamesBySymbolKind);
    private static SymbolNamesWithValueOption`1();
    public static SymbolNamesWithValueOption`1<TValue> Create(ImmutableArray`1<string> symbolNames, Compilation compilation, string optionalPrefix, Func`2<string, NameParts<TValue>> getSymbolNamePartsFunc);
    public bool get_IsEmpty();
    public bool Contains(ISymbol symbol);
    public bool TryGetValue(ISymbol symbol, TValue& value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolNamesWithValueOption`1<TValue> other);
    public virtual int GetHashCode();
    private bool TryGetFirstWildcardMatch(ISymbol symbol, String& firstMatchName, TValue& firstMatchValue);
    [NullableContextAttribute("0")]
internal TestAccessor<TValue> GetTestAccessor();
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessWildcardName|10_2(NameParts<TValue> parts, PooledDictionary`2<SymbolKind, PooledDictionary`2<string, TValue>> wildcardNamesBuilder);
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessName|10_3(NameParts<TValue> parts, PooledDictionary`2<string, TValue> namesBuilder);
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessSymbolName|10_4(NameParts<TValue> parts, Compilation compilation, string optionalPrefix, PooledDictionary`2<ISymbol, TValue> symbolsBuilder);
    [CompilerGeneratedAttribute]
internal static string <TryGetFirstWildcardMatch>g__GetDeclarationId|18_7(ISymbol symbol);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.SymbolVisibilityGroup : Enum {
    public int value__;
    public static SymbolVisibilityGroup None;
    public static SymbolVisibilityGroup Public;
    public static SymbolVisibilityGroup Internal;
    public static SymbolVisibilityGroup Private;
    public static SymbolVisibilityGroup Friend;
    public static SymbolVisibilityGroup All;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.SymbolVisibilityGroupExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SymbolVisibilityGroup symbolVisibilityGroup, SymbolVisibility symbolVisibility);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.SyntaxGeneratorExtensions : object {
    private static string LeftIdentifierName;
    private static string RightIdentifierName;
    private static string ReferenceEqualsMethodName;
    private static string EqualsMethodName;
    private static string CompareToMethodName;
    private static string SystemNotImplementedExceptionTypeName;
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorEqualityDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode TypeExpressionForStaticMemberAccess(SyntaxGenerator generator, INamedTypeSymbol typeSymbol);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorInequalityDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorLessThanDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorLessThanOrEqualDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorGreaterThanDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultOperatorGreaterThanOrEqualDeclaration(SyntaxGenerator generator, INamedTypeSymbol containingType);
    [ExtensionAttribute]
private static SyntaxNode ComparisonOperatorDeclaration(SyntaxGenerator generator, OperatorKind operatorKind, INamedTypeSymbol containingType, SyntaxNode[] statements);
    [ExtensionAttribute]
public static SyntaxNode DefaultEqualsOverrideDeclaration(SyntaxGenerator generator, Compilation compilation, INamedTypeSymbol containingType);
    [ExtensionAttribute]
public static SyntaxNode DefaultGetHashCodeOverrideDeclaration(SyntaxGenerator generator, Compilation compilation);
    [IteratorStateMachineAttribute("Analyzer.Utilities.SyntaxGeneratorExtensions/<DefaultMethodBody>d__16")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> DefaultMethodBody(SyntaxGenerator generator, Compilation compilation);
    [ExtensionAttribute]
public static SyntaxNode DefaultMethodStatement(SyntaxGenerator generator, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode TryGetContainingDeclaration(SyntaxGenerator generator, SyntaxNode node, DeclarationKind kind);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <TypeExpressionForStaticMemberAccess>g__QualifiedNameToMemberAccess|7_0(int qualifiedNameSyntaxKind, int memberAccessExpressionSyntaxKind, SyntaxNode expression, SyntaxGenerator generator);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.SyntaxNodeExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Optional`1<SyntaxAnnotation> s_addImportsAnnotation;
    private static SyntaxAnnotation AddImportsAnnotation { get; }
    private static SyntaxAnnotation get_AddImportsAnnotation();
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode WithAddImportsAnnotation(SyntaxNode syntaxNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SyntaxTreeCategorizedAnalyzerConfigOptions : AbstractCategorizedAnalyzerConfigOptions {
    [NullableAttribute("2")]
private AnalyzerConfigOptions _analyzerConfigOptions;
    private static ConditionalWeakTable`2<ImmutableDictionary`2<string, string>, SyntaxTreeCategorizedAnalyzerConfigOptions> s_perTreeOptionsCache;
    public static SyntaxTreeCategorizedAnalyzerConfigOptions Empty;
    public bool IsEmpty { get; }
    [NullableContextAttribute("2")]
private SyntaxTreeCategorizedAnalyzerConfigOptions(AnalyzerConfigOptions analyzerConfigOptions);
    private static SyntaxTreeCategorizedAnalyzerConfigOptions();
    public static SyntaxTreeCategorizedAnalyzerConfigOptions Create(AnalyzerConfigOptions analyzerConfigOptions);
    public virtual bool get_IsEmpty();
    protected virtual bool TryGetOptionValue(string optionKeyPrefix, string optionKeySuffix, string optionName, String& valueString);
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> <Create>g__TryGetBackingOptionsDictionary|4_1(AnalyzerConfigOptions analyzerConfigOptions);
}
internal class Analyzer.Utilities.Unit : ValueType {
    public static Unit Default { get; }
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Unit other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(Unit first, Unit second);
    public static bool op_Inequality(Unit first, Unit second);
    public static Unit get_Default();
}
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.UnusedValue : ValueType {
}
[FlagsAttribute]
internal enum Analyzer.Utilities.ValueUsageInfo : Enum {
    public int value__;
    public static ValueUsageInfo None;
    public static ValueUsageInfo Read;
    public static ValueUsageInfo Write;
    public static ValueUsageInfo Reference;
    public static ValueUsageInfo Name;
    public static ValueUsageInfo ReadWrite;
    public static ValueUsageInfo ReadableReference;
    public static ValueUsageInfo WritableReference;
    public static ValueUsageInfo ReadableWritableReference;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.ValueUsageInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsReadFrom(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsWrittenTo(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsNameOnly(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsReference(ValueUsageInfo valueUsageInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.WellKnownTypeNames : object {
    public static string BenchmarkDotNetAttributesBenchmarkAttribute;
    public static string MicrosoftAspNetCoreAntiforgeryIAntiforgery;
    public static string MicrosoftAspNetCoreHttpCookieOptions;
    public static string MicrosoftAspNetCoreHttpHttpRequest;
    public static string MicrosoftAspNetCoreHttpInternalResponseCookies;
    public static string MicrosoftAspNetCoreHttpIResponseCookies;
    public static string MicrosoftAspNetCoreMvcController;
    public static string MicrosoftAspNetCoreMvcControllerAttribute;
    public static string MicrosoftAspNetCoreMvcControllerBase;
    public static string MicrosoftAspNetCoreMvcFiltersAuthorizationFilterContext;
    public static string MicrosoftAspNetCoreMvcFiltersFilterCollection;
    public static string MicrosoftAspNetCoreMvcFiltersIAsyncAuthorizationFilter;
    public static string MicrosoftAspNetCoreMvcFiltersIAuthorizationFilter;
    public static string MicrosoftAspNetCoreMvcFiltersIFilterMetadata;
    public static string MicrosoftAspNetCoreMvcFromServicesAttribute;
    public static string MicrosoftAspNetCoreMvcHttpDeleteAttribute;
    public static string MicrosoftAspNetCoreMvcHttpGetAttribute;
    public static string MicrosoftAspNetCoreMvcHttpHeadAttribute;
    public static string MicrosoftAspNetCoreMvcHttpOptionsAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPatchAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPostAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPutAttribute;
    public static string MicrosoftAspNetCoreMvcNonActionAttribute;
    public static string MicrosoftAspNetCoreMvcNonControllerAttribute;
    public static string MicrosoftAspNetCoreMvcRouteAttribute;
    public static string MicrosoftAspNetCoreMvcRoutingHttpMethodAttribute;
    public static string MicrosoftAspNetCoreRazorHostingRazorCompiledItemAttribute;
    public static string MicrosoftCodeAnalysisCompilation;
    public static string MicrosoftCodeAnalysisCSharpCSharpCompilation;
    public static string MicrosoftCodeAnalysisCSharpCSharpExtensions;
    public static string MicrosoftCodeAnalysisCSharpExtensions;
    public static string MicrosoftCodeAnalysisDiagnostic;
    public static string MicrosoftCodeAnalysisDiagnosticDescriptor;
    public static string MicrosoftCodeAnalysisDiagnosticsAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCodeBlockAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCodeBlockStartAnalysisContext1;
    public static string MicrosoftCodeAnalysisDiagnosticsCompilationEndAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCompilationStartAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsDiagnosticAnalyzer;
    public static string MicrosoftCodeAnalysisDiagnosticsDiagnosticAnalyzerAttribute;
    public static string MicrosoftCodeAnalysisDiagnosticsGeneratedCodeAnalysisFlags;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationBlockAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationBlockStartAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSemanticModelAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSymbolAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSyntaxNodeAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSyntaxTreeAnalysisContext;
    public static string MicrosoftCodeAnalysisGeneratorAttribute;
    public static string MicrosoftCodeAnalysisHostMefMefConstruction;
    public static string MicrosoftCodeAnalysisIIncrementalGenerator;
    public static string MicrosoftCodeAnalysisISourceGenerator;
    public static string MicrosoftCodeAnalysisLocalizableResourceString;
    public static string MicrosoftCodeAnalysisLocalizableString;
    public static string MicrosoftCodeAnalysisSharedCollectionsTemporaryArrayExtensions;
    public static string MicrosoftCodeAnalysisSymbolKind;
    public static string MicrosoftCodeAnalysisVisualBasicExtensions;
    public static string MicrosoftCodeAnalysisVisualBasicVisualBasicCompilation;
    public static string MicrosoftCodeAnalysisVisualBasicVisualBasicExtensions;
    public static string MicrosoftEntityFrameworkCoreDbContext;
    public static string MicrosoftEntityFrameworkCoreDbSet1;
    public static string MicrosoftEntityFrameworkCoreEntityFrameworkQueryableExtensions;
    public static string MicrosoftEntityFrameworkCoreRelationalQueryableExtensions;
    public static string MicrosoftExtensionsLoggingILogger;
    public static string MicrosoftExtensionsLoggingLoggerExtensions;
    public static string MicrosoftExtensionsLoggingLoggerMessage;
    public static string MicrosoftIdentityModelTokensAudienceValidator;
    public static string MicrosoftIdentityModelTokensLifetimeValidator;
    public static string MicrosoftIdentityModelTokensSecurityToken;
    public static string MicrosoftIdentityModelTokensTokenValidationParameters;
    public static string MicrosoftSecurityApplicationAntiXss;
    public static string MicrosoftSecurityApplicationAntiXssEncoder;
    public static string MicrosoftSecurityApplicationEncoder;
    public static string MicrosoftSecurityApplicationUnicodeCharacterEncoder;
    public static string MicrosoftVisualBasicDevicesComputerInfo;
    public static string MicrosoftVisualStudioTestToolsUnitTestingAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingCollectionAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingDataTestMethodAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingExpectedExceptionAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingStringAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestCleanupAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestInitializeAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestMethodAttribute;
    public static string MicrosoftWindowsAzureStorageCloudStorageAccount;
    public static string MicrosoftWindowsAzureStorageSharedAccessProtocol;
    public static string NewtonsoftJsonJsonConvert;
    public static string NewtonsoftJsonJsonIgnoreAttribute;
    public static string NewtonsoftJsonJsonSerializer;
    public static string NewtonsoftJsonJsonSerializerSettings;
    public static string NewtonsoftJsonTypeNameHandling;
    public static string NUnitFrameworkAssert;
    public static string NUnitFrameworkInterfacesITestBuilder;
    public static string NUnitFrameworkOneTimeSetUpAttribute;
    public static string NUnitFrameworkOneTimeTearDownAttribute;
    public static string NUnitFrameworkSetUpAttribute;
    public static string NUnitFrameworkTearDownAttribute;
    public static string NUnitFrameworkTestAttribute;
    public static string RoslynUtilitiesNonDefaultableAttribute;
    public static string SystemActivator;
    public static string SystemAppContext;
    public static string SystemAppDomain;
    public static string SystemArgumentException;
    public static string SystemArgumentNullException;
    public static string SystemArgumentOutOfRangeException;
    public static string SystemAttribute;
    public static string SystemAttributeTargets;
    public static string SystemAttributeUsageAttribute;
    public static string SystemBoolean;
    public static string SystemBuffer;
    public static string SystemBuffersMemoryManager1;
    public static string SystemBuffersSearchValues;
    public static string SystemBuffersSearchValues1;
    public static string SystemByte;
    public static string SystemChar;
    public static string SystemCLSCompliantAttribute;
    public static string SystemCodeDomCompilerGeneratedCodeAttribute;
    public static string SystemCollectionsConcurrentConcurrentBag1;
    public static string SystemCollectionsConcurrentConcurrentDictionary2;
    public static string SystemCollectionsConcurrentConcurrentQueue1;
    public static string SystemCollectionsConcurrentConcurrentStack1;
    public static string SystemCollectionsGenericDictionary2;
    public static string SystemCollectionsGenericHashSet1;
    public static string SystemCollectionsGenericIAsyncEnumerable1;
    public static string SystemCollectionsGenericICollection1;
    public static string SystemCollectionsGenericIDictionary2;
    public static string SystemCollectionsGenericIEnumerable1;
    public static string SystemCollectionsGenericIEnumerator1;
    public static string SystemCollectionsGenericIEqualityComparer1;
    public static string SystemCollectionsGenericIList1;
    public static string SystemCollectionsGenericIReadOnlyCollection1;
    public static string SystemCollectionsGenericIReadOnlyDictionary2;
    public static string SystemCollectionsGenericIReadOnlyList1;
    public static string SystemCollectionsGenericIReadOnlySet1;
    public static string SystemCollectionsGenericISet1;
    public static string SystemCollectionsGenericKeyNotFoundException;
    public static string SystemCollectionsGenericLinkedList1;
    public static string SystemCollectionsGenericList1;
    public static string SystemCollectionsGenericPriorityQueue2;
    public static string SystemCollectionsGenericQueue1;
    public static string SystemCollectionsGenericStack1;
    public static string SystemCollectionsGenericSortedSet1;
    public static string SystemCollectionsICollection;
    public static string SystemCollectionsIDictionary;
    public static string SystemCollectionsIEnumerable;
    public static string SystemCollectionsIEnumerator;
    public static string SystemCollectionsIHashCodeProvider;
    public static string SystemCollectionsIList;
    public static string SystemCollectionsImmutableIImmutableDictionary2;
    public static string SystemCollectionsImmutableIImmutableList;
    public static string SystemCollectionsImmutableIImmutableList1;
    public static string SystemCollectionsImmutableImmutableList;
    public static string SystemCollectionsImmutableIImmutableQueue1;
    public static string SystemCollectionsImmutableIImmutableSet1;
    public static string SystemCollectionsImmutableIImmutableStack1;
    public static string SystemCollectionsImmutableImmutableArray;
    public static string SystemCollectionsImmutableImmutableArray1;
    public static string SystemCollectionsImmutableImmutableDictionary;
    public static string SystemCollectionsImmutableImmutableDictionary2;
    public static string SystemCollectionsImmutableImmutableHashSet;
    public static string SystemCollectionsImmutableImmutableHashSet1;
    public static string SystemCollectionsImmutableImmutableList1;
    public static string SystemCollectionsImmutableImmutableSortedDictionary;
    public static string SystemCollectionsImmutableImmutableSortedDictionary2;
    public static string SystemCollectionsImmutableImmutableSortedSet;
    public static string SystemCollectionsImmutableImmutableSortedSet1;
    public static string SystemCollectionsObjectModelReadOnlyCollection1;
    public static string SystemCollectionsObjectModelReadOnlyDictionary2;
    public static string SystemCollectionsObjectModelReadOnlyObservableCollection1;
    public static string SystemCollectionsQueue;
    public static string SystemCollectionsSpecializedNameValueCollection;
    public static string SystemCollectionsStack;
    public static string SystemComponentModelComponent;
    public static string SystemComponentModelCompositionExportAttribute;
    public static string SystemComponentModelCompositionImportingConstructorAttribute;
    public static string SystemComponentModelCompositionInheritedExportAttribute;
    public static string SystemComponentModelDesignerAttribute;
    public static string SystemComponentModelDesignerCategoryAttribute;
    public static string SystemComponentModelLocalizableAttribute;
    public static string SystemCompositionExportAttribute;
    public static string SystemCompositionImportingConstructorAttribute;
    public static string SystemConfigurationConfigurationSection;
    public static string SystemConfigurationIConfigurationSectionHandler;
    public static string SystemConsole;
    public static string SystemConvert;
    public static string SystemDataDataRow;
    public static string SystemDataDataSet;
    public static string SystemDataDataTable;
    public static string SystemDataDataViewManager;
    public static string SystemDataEntityDbSet1;
    public static string SystemDataEntityQueryableExtensions;
    public static string SystemDataIDataAdapter;
    public static string SystemDataIDbCommand;
    public static string SystemDataOdbcOdbcParameter;
    public static string SystemDataOleDbOleDbParameter;
    public static string SystemDataSqlClientSqlParameter;
    public static string SystemDataTypedTableBase1;
    public static string SystemDateTime;
    public static string SystemDateTimeOffset;
    public static string SystemDecimal;
    public static string SystemDiagnosticContractsContract;
    public static string SystemDiagnosticsCodeAnalysisConstantExpectedAttribute;
    public static string SystemDiagnosticsCodeAnalysisNotNullAttribute;
    public static string SystemDiagnosticsCodeAnalysisNotNullIfNotNullAttribute;
    public static string SystemDiagnosticsCodeAnalysisStringSyntaxAttributeName;
    public static string SystemDiagnosticsConditionalAttribute;
    public static string SystemDiagnosticsContractsPureAttribute;
    public static string SystemDiagnosticsDebug;
    public static string SystemDiagnosticsDebuggerNonUserCode;
    public static string SystemDiagnosticsDebuggerTypeProxyAttribute;
    public static string SystemDiagnosticsProcess;
    public static string SystemDiagnosticsProcessModule;
    public static string SystemDiagnosticsProcessStartInfo;
    public static string SystemDiagnosticsTraceListener;
    public static string SystemDiagnosticsTracingEventSource;
    public static string SystemDirectoryDirectoryEntry;
    public static string SystemDirectoryServicesActiveDirectoryADSearcher;
    public static string SystemDirectoryServicesDirectorySearcher;
    public static string SystemDouble;
    public static string SystemEnvironment;
    public static string SystemEventArgs;
    public static string SystemEventHandler1;
    public static string SystemException;
    public static string SystemExecutionEngineException;
    public static string SystemFlagsAttribute;
    public static string SystemFunc2;
    public static string SystemGC;
    public static string SystemGlobalizationCultureInfo;
    public static string SystemGuid;
    public static string SystemHashCode;
    public static string SystemIAsyncDisposable;
    public static string SystemIComparable;
    public static string SystemIComparable1;
    public static string SystemIDisposable;
    public static string SystemIEquatable1;
    public static string SystemIFormatProvider;
    public static string SystemIndex;
    public static string SystemInt16;
    public static string SystemInt32;
    public static string SystemInt64;
    public static string SystemInvalidOperationException;
    public static string SystemIOCompressionZipArchiveEntry;
    public static string SystemIOCompressionZipFileExtensions;
    public static string SystemIODirectory;
    public static string SystemIODirectoryInfo;
    public static string SystemIOFile;
    public static string SystemIOFileInfo;
    public static string SystemIOFileStream;
    public static string SystemIOLogLogStore;
    public static string SystemIOMemoryStream;
    public static string SystemIOPath;
    public static string SystemIOStream;
    public static string SystemIOStringReader;
    public static string SystemIOUnmanagedMemoryStream;
    public static string SystemIParsable1;
    public static string SystemIProgress1;
    public static string SystemLinqEnumerable;
    public static string SystemLinqExpressionsExpression1;
    public static string SystemLinqIOrderedEnumerable1;
    public static string SystemLinqQueryable;
    public static string SystemMarshalByRefObject;
    public static string SystemMemory1;
    public static string SystemMemoryExtensions;
    public static string SystemNetHttpHttpClient;
    public static string SystemNetHttpHttpClientHandler;
    public static string SystemNetHttpWinHttpHandler;
    public static string SystemNetSecurityProtocolType;
    public static string SystemNetSecurityRemoteCertificateValidationCallback;
    public static string SystemNetSecuritySslPolicyErrors;
    public static string SystemNetServicePointManager;
    public static string SystemNonSerializedAttribute;
    public static string SystemNotImplementedException;
    public static string SystemNotSupportedException;
    public static string SystemNullable1;
    public static string SystemNumber;
    public static string SystemNumericsINumber1;
    public static string SystemObject;
    public static string SystemObjectDisposedException;
    public static string SystemObsoleteAttribute;
    public static string SystemOperatingSystem;
    public static string SystemOperationCanceledException;
    public static string SystemOutOfMemoryException;
    public static string SystemPlatformNotSupportedException;
    public static string SystemRandom;
    public static string SystemRange;
    public static string SystemReadOnlyMemory1;
    public static string SystemReadOnlySpan1;
    public static string SystemReflectionAssembly;
    public static string SystemReflectionAssemblyName;
    public static string SystemReflectionAssemblyVersionAttribute;
    public static string SystemReflectionMemberInfo;
    public static string SystemReflectionParameterInfo;
    public static string SystemResourcesNeutralResourcesLanguageAttribute;
    public static string SystemResourcesResourceManager;
    public static string SystemRuntimeCompilerServicesAsyncMethodBuilderAttribute;
    public static string SystemRuntimeCompilerServicesCallerFilePathAttribute;
    public static string SystemRuntimeCompilerServicesCallerLineNumberAttribute;
    public static string SystemRuntimeCompilerServicesCallerMemberNameAttribute;
    public static string SystemRuntimeCompilerServicesCallerArgumentExpressionAttribute;
    public static string SystemRuntimeCompilerServicesCompilerGeneratedAttribute;
    public static string SystemRuntimeCompilerServicesConfiguredAsyncDisposable;
    public static string SystemRuntimeCompilerServicesConfiguredValueTaskAwaitable;
    public static string SystemRuntimeCompilerServicesConfiguredValueTaskAwaitable1;
    public static string SystemRuntimeCompilerServicesDisableRuntimeMarshallingAttribute;
    public static string SystemRuntimeCompilerServicesICriticalNotifyCompletion;
    public static string SystemRuntimeCompilerServicesInlineArrayAttribute;
    public static string SystemRuntimeCompilerServicesINotifyCompletion;
    public static string SystemRuntimeCompilerServicesInternalsVisibleToAttribute;
    public static string SystemRuntimeCompilerServicesMethodImplOptions;
    public static string SystemRuntimeCompilerServicesModuleInitializerAttribute;
    public static string SystemRuntimeCompilerServicesRestrictedInternalsVisibleToAttribute;
    public static string SystemRuntimeCompilerServicesRuntimeFeature;
    public static string SystemRuntimeCompilerServicesTaskAwaiter;
    public static string SystemRuntimeCompilerServicesTypeForwardedToAttribute;
    public static string SystemRuntimeCompilerServicesValueTaskAwaiter;
    public static string SystemRuntimeExceptionServicesHandleProcessCorruptedStateExceptionsAttribute;
    public static string SystemRuntimeInteropServicesCharSet;
    public static string SystemRuntimeInteropServicesCoClassAttribute;
    public static string SystemRuntimeInteropServicesComImportAttribute;
    public static string SystemRuntimeInteropServicesComSourceInterfacesAttribute;
    public static string SystemRuntimeInteropServicesComVisibleAttribute;
    public static string SystemRuntimeInteropServicesDefaultDllImportSearchPathsAttribute;
    public static string SystemRuntimeInteropServicesDllImportAttribute;
    public static string SystemRuntimeInteropServicesDynamicInterfaceCastableImplementationAttribute;
    public static string SystemRuntimeInteropServicesFieldOffsetAttribute;
    public static string SystemRuntimeInteropServicesGCHandle;
    public static string SystemRuntimeInteropServicesHandleRef;
    public static string SystemRuntimeInteropServicesLCIDConversionAttribute;
    public static string SystemRuntimeInteropServicesLibraryImportAttribute;
    public static string SystemRuntimeInteropServicesMarshal;
    public static string SystemRuntimeInteropServicesMarshalAsAttribute;
    public static string SystemRuntimeInteropServicesOSPlatform;
    public static string SystemRuntimeInteropServicesOutAttribute;
    public static string SystemRuntimeInteropServicesRuntimeInformation;
    public static string SystemRuntimeInteropServicesSafeHandle;
    public static string SystemRuntimeInteropServicesStructLayoutAttribute;
    public static string SystemRuntimeInteropServicesUnmanagedFunctionPoitnerAttribute;
    public static string SystemRuntimeInteropServicesUnmanagedType;
    public static string SystemRuntimeSerializationDataContractAttribute;
    public static string SystemRuntimeSerializationDataContractSerializer;
    public static string SystemRuntimeSerializationDataMemberAttribute;
    public static string SystemRuntimeSerializationFormattersBinaryBinaryFormatter;
    public static string SystemRuntimeSerializationFormattersSoapSoapFormatter;
    public static string SystemRuntimeSerializationIDeserializationCallback;
    public static string SystemRuntimeSerializationIgnoreDataMemberAttribute;
    public static string SystemRuntimeSerializationISerializable;
    public static string SystemRuntimeSerializationJsonDataContractJsonSerializer;
    public static string SystemRuntimeSerializationKnownTypeAttribute;
    public static string SystemRuntimeSerializationNetDataContractSerializer;
    public static string SystemRuntimeSerializationOnDeserializedAttribute;
    public static string SystemRuntimeSerializationOnDeserializingAttribute;
    public static string SystemRuntimeSerializationOnSerializedAttribute;
    public static string SystemRuntimeSerializationOnSerializingAttribute;
    public static string SystemRuntimeSerializationSerializationInfo;
    public static string SystemRuntimeSerializationStreamingContext;
    public static string SystemRuntimeVersioningRequiresPreviewFeaturesAttribute;
    public static string SystemRuntimeVersioningSupportedOSPlatformAttribute;
    public static string SystemRuntimeVersioningUnsupportedOSPlatformAttribute;
    public static string SystemSecurityAuthenticationSslProtocols;
    public static string SystemSecurityCryptographyAesCcm;
    public static string SystemSecurityCryptographyAesGcm;
    public static string SystemSecurityCryptographyAsymmetricAlgorithm;
    public static string SystemSecurityCryptographyCipherMode;
    public static string SystemSecurityCryptographyCryptoConfig;
    public static string SystemSecurityCryptographyDES;
    public static string SystemSecurityCryptographyDSA;
    public static string SystemSecurityCryptographyDSASignatureFormatter;
    public static string SystemSecurityCryptographyHashAlgorithm;
    public static string SystemSecurityCryptographyHashAlgorithmName;
    public static string SystemSecurityCryptographyHMACMD5;
    public static string SystemSecurityCryptographyHMACRIPEMD160;
    public static string SystemSecurityCryptographyHMACSHA1;
    public static string SystemSecurityCryptographyMD5;
    public static string SystemSecurityCryptographyPasswordDeriveBytes;
    public static string SystemSecurityCryptographyRC2;
    public static string SystemSecurityCryptographyRfc2898DeriveBytes;
    public static string SystemSecurityCryptographyRIPEMD160;
    public static string SystemSecurityCryptographyRSA;
    public static string SystemSecurityCryptographySHA1;
    public static string SystemSecurityCryptographySHA256;
    public static string SystemSecurityCryptographySymmetricAlgorithm;
    public static string SystemSecurityCryptographyTripleDES;
    public static string SystemSecurityCryptographyX509CertificatesStoreName;
    public static string SystemSecurityCryptographyX509CertificatesX509Certificate;
    public static string SystemSecurityCryptographyX509CertificatesX509Certificate2;
    public static string SystemSecurityCryptographyX509CertificatesX509Chain;
    public static string SystemSecurityCryptographyX509CertificatesX509Store;
    public static string SystemSecurityIPermission;
    public static string SystemSecurityPolicyIMembershipCondition;
    public static string SystemSerializableAttribute;
    public static string SystemServiceModelMessageContractAttribute;
    public static string SystemServiceModelOperationContractAttribute;
    public static string SystemSingle;
    public static string SystemSpan1;
    public static string SystemStackOverflowException;
    public static string SystemString;
    public static string SystemStringComparer;
    public static string SystemStringComparison;
    public static string SystemSystemException;
    public static string SystemTextCompositeFormat;
    public static string SystemTextEncoding;
    public static string SystemTextJsonJsonSerializerOptions;
    public static string SystemTextJsonJsonSerializer;
    public static string SystemTextRegularExpressionsRegex;
    public static string SystemTextStringBuilder;
    public static string SystemThreadStaticAttribute;
    public static string SystemThreadingCancellationToken;
    public static string SystemThreadingInterlocked;
    public static string SystemThreadingMonitor;
    public static string SystemThreadingSpinLock;
    public static string SystemThreadingTasksConfigureAwaitOptions;
    public static string SystemThreadingTasksTaskAsyncEnumerableExtensions;
    public static string SystemThreadingTasksTask;
    public static string SystemThreadingTasksTask1;
    public static string SystemThreadingTasksTaskCompletionSource;
    public static string SystemThreadingTasksTaskCompletionSource1;
    public static string SystemThreadingTasksTaskContinuationOptions;
    public static string SystemThreadingTasksTaskCreationOptions;
    public static string SystemThreadingTasksTaskFactory;
    public static string SystemThreadingTasksTaskScheduler;
    public static string SystemThreadingTasksValueTask;
    public static string SystemThreadingTasksValueTask1;
    public static string SystemThreadingThread;
    public static string SystemTimeSpan;
    public static string SystemType;
    public static string SystemUri;
    public static string SystemWebConfigurationHttpRuntimeSection;
    public static string SystemWebHttpApplication;
    public static string SystemWebHttpCookie;
    public static string SystemWebHttpRequest;
    public static string SystemWebHttpRequestBase;
    public static string SystemWebHttpRequestWrapper;
    public static string SystemWebHttpResponse;
    public static string SystemWebHttpResponseBase;
    public static string SystemWebHttpRouteAttribute;
    public static string SystemWebHttpServerUtility;
    public static string SystemWebHttpServerUtilityBase;
    public static string SystemWebHttpServerUtilityWrapper;
    public static string SystemWebHttpUtility;
    public static string SystemWebMvcAcceptVerbsAttribute;
    public static string SystemWebMvcActionResult;
    public static string SystemWebMvcChildActionOnlyAttribute;
    public static string SystemWebMvcController;
    public static string SystemWebMvcControllerBase;
    public static string SystemWebMvcHttpDeleteAttribute;
    public static string SystemWebMvcHttpGetAttribute;
    public static string SystemWebMvcHttpHeadAttribute;
    public static string SystemWebMvcHttpOptionsAttribute;
    public static string SystemWebMvcHttpPatchAttribute;
    public static string SystemWebMvcHttpPostAttribute;
    public static string SystemWebMvcHttpPutAttribute;
    public static string SystemWebMvcHttpVerbs;
    public static string SystemWebMvcNonActionAttribute;
    public static string SystemWebMvcValidateAntiForgeryTokenAttribute;
    public static string SystemWebMvcValidateInputAttribute;
    public static string SystemWebScriptSerializationJavaScriptSerializer;
    public static string SystemWebScriptSerializationJavaScriptTypeResolver;
    public static string SystemWebScriptSerializationSimpleTypeResolver;
    public static string SystemWebSecurityAntiXssAntiXssEncoder;
    public static string SystemWebSecurityAntiXssUnicodeCharacterEncoder;
    public static string SystemWebServicesWebMethodAttribute;
    public static string SystemWebUIAdaptersPageAdapter;
    public static string SystemWebUIControl;
    public static string SystemWebUIDataBoundLiteralControl;
    public static string SystemWebUIDesignerDataBoundLiteralControl;
    public static string SystemWebUIHtmlControlsHtmlContainerControl;
    public static string SystemWebUIHtmlControlsHtmlInputControl;
    public static string SystemWebUIHtmlControlsHtmlTitle;
    public static string SystemWebUIHtmlTextWriter;
    public static string SystemWebUIIndexedString;
    public static string SystemWebUIITextControl;
    public static string SystemWebUILiteralControl;
    public static string SystemWebUILosFormatter;
    public static string SystemWebUIObjectStateFormatter;
    public static string SystemWebUIPage;
    public static string SystemWebUIPageTheme;
    public static string SystemWebUIResourceBasedLiteralControl;
    public static string SystemWebUISimplePropertyEntry;
    public static string SystemWebUIStateItem;
    public static string SystemWebUIStringPropertyBuilder;
    public static string SystemWebUITemplateBuilder;
    public static string SystemWebUITemplateControl;
    public static string SystemWebUITemplateParser;
    public static string SystemWebUIWebControlsBaseDataList;
    public static string SystemWebUIWebControlsBaseValidator;
    public static string SystemWebUIWebControlsBulletedList;
    public static string SystemWebUIWebControlsButton;
    public static string SystemWebUIWebControlsButtonColumn;
    public static string SystemWebUIWebControlsButtonField;
    public static string SystemWebUIWebControlsCalendar;
    public static string SystemWebUIWebControlsChangePassword;
    public static string SystemWebUIWebControlsCheckBox;
    public static string SystemWebUIWebControlsCheckBoxField;
    public static string SystemWebUIWebControlsCommandEventArgs;
    public static string SystemWebUIWebControlsCreateUserWizard;
    public static string SystemWebUIWebControlsDataKey;
    public static string SystemWebUIWebControlsDataList;
    public static string SystemWebUIWebControlsDetailsView;
    public static string SystemWebUIWebControlsDetailsViewInsertEventArgs;
    public static string SystemWebUIWebControlsDetailsViewUpdateEventArgs;
    public static string SystemWebUIWebControlsFormView;
    public static string SystemWebUIWebControlsFormViewInsertEventArgs;
    public static string SystemWebUIWebControlsFormViewUpdateEventArgs;
    public static string SystemWebUIWebControlsGridView;
    public static string SystemWebUIWebControlsHiddenField;
    public static string SystemWebUIWebControlsHyperLink;
    public static string SystemWebUIWebControlsHyperLinkColumn;
    public static string SystemWebUIWebControlsHyperLinkField;
    public static string SystemWebUIWebControlsImage;
    public static string SystemWebUIWebControlsImageButton;
    public static string SystemWebUIWebControlsLabel;
    public static string SystemWebUIWebControlsLinkButton;
    public static string SystemWebUIWebControlsListControl;
    public static string SystemWebUIWebControlsListItem;
    public static string SystemWebUIWebControlsLiteral;
    public static string SystemWebUIWebControlsLogin;
    public static string SystemWebUIWebControlsMenu;
    public static string SystemWebUIWebControlsMenuItem;
    public static string SystemWebUIWebControlsMenuItemBinding;
    public static string SystemWebUIWebControlsPasswordRecovery;
    public static string SystemWebUIWebControlsQueryStringParameter;
    public static string SystemWebUIWebControlsRadioButtonList;
    public static string SystemWebUIWebControlsRepeatInfo;
    public static string SystemWebUIWebControlsServerValidateEventArgs;
    public static string SystemWebUIWebControlsSqlDataSource;
    public static string SystemWebUIWebControlsTable;
    public static string SystemWebUIWebControlsTableCell;
    public static string SystemWebUIWebControlsTextBox;
    public static string SystemWebUIWebControlsTreeNode;
    public static string SystemWebUIWebControlsTreeNodeBinding;
    public static string SystemWebUIWebControlsTreeView;
    public static string SystemWebUIWebControlsUnit;
    public static string SystemWebUIWebControlsWebPartsAppearanceEditorPart;
    public static string SystemWebUIWebControlsWebPartsPersonalizationEntry;
    public static string SystemWebUIWebControlsWebPartsWebPartCatalogAddVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartCatalogCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsCancelVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsConfigureVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsConnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsDisconnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartDeleteVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorApplyVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorCancelVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorOKVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartExportVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartHeaderCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartHelpVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartMinimizeVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartRestoreVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartVerb;
    public static string SystemWebUIWebControlsXmlDataSource;
    public static string SystemWebUIXPathBinder;
    public static string SystemWebUtilHttpEncoder;
    public static string SystemWindowsAssemblyPart;
    public static string SystemWindowsMarkupXamlReader;
    public static string SystemXmlDtdProcessing;
    public static string SystemXmlSchemaXmlSchema;
    public static string SystemXmlSchemaXmlSchemaCollection;
    public static string SystemXmlSchemaXmlSchemaXPath;
    public static string SystemXmlSerializationXmlAnyAttributeAttribute;
    public static string SystemXmlSerializationXmlAnyElementAttribute;
    public static string SystemXmlSerializationXmlArrayAttribute;
    public static string SystemXmlSerializationXmlArrayItemAttribute;
    public static string SystemXmlSerializationXmlAttributeAttribute;
    public static string SystemXmlSerializationXmlChoiceIdentifierAttribute;
    public static string SystemXmlSerializationXmlElementAttribute;
    public static string SystemXmlSerializationXmlEnumAttribute;
    public static string SystemXmlSerializationXmlIgnoreAttribute;
    public static string SystemXmlSerializationXmlIncludeAttribute;
    public static string SystemXmlSerializationXmlRootAttribute;
    public static string SystemXmlSerializationXmlSerializer;
    public static string SystemXmlSerializationXmlTextAttribute;
    public static string SystemXmlSerializationXmlTypeAttribute;
    public static string SystemXmlXmlAttribute;
    public static string SystemXmlXmlDocument;
    public static string SystemXmlXmlDocumentFragment;
    public static string SystemXmlXmlElement;
    public static string SystemXmlXmlEntity;
    public static string SystemXmlXmlNode;
    public static string SystemXmlXmlNotation;
    public static string SystemXmlXmlReader;
    public static string SystemXmlXmlReaderSettings;
    public static string SystemXmlXmlResolver;
    public static string SystemXmlXmlSecureResolver;
    public static string SystemXmlXmlTextReader;
    public static string SystemXmlXmlTextWriter;
    public static string SystemXmlXmlValidatingReader;
    public static string SystemXmlXmlWriter;
    public static string SystemXmlXPathXPathDocument;
    public static string SystemXmlXPathXPathExpression;
    public static string SystemXmlXPathXPathNavigator;
    public static string SystemXmlXslXslCompiledTransform;
    public static string SystemXmlXslXslTransform;
    public static string SystemXmlXslXsltSettings;
    public static string XunitAssert;
    public static string XunitCombinatorialDataAttribute;
    public static string XunitCombinatorialRangeAttribute;
    public static string XunitFactAttribute;
    public static string XunitSdkDataAttribute;
    public static string XunitTraitAttribute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Analyzer.Utilities.WellKnownTypeProvider : object {
    private static BoundedCacheWithFactory`2<Compilation, WellKnownTypeProvider> s_providerCache;
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableArray`1<IAssemblySymbol>> _referencedAssemblies;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, INamedTypeSymbol> _fullNameToTypeMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<string, ImmutableArray`1<string>> _fullTypeNameToNamespaceNames;
    public Compilation Compilation { get; }
    private WellKnownTypeProvider(Compilation compilation);
    private static WellKnownTypeProvider();
    public static WellKnownTypeProvider GetOrCreate(Compilation compilation);
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    public bool TryGetOrCreateTypeByMetadataName(string fullTypeName, INamedTypeSymbol& namedTypeSymbol);
    private bool TryGetOrCreateTypeByMetadataNameSlow(string fullTypeName, INamedTypeSymbol& namedTypeSymbol);
    public INamedTypeSymbol GetOrCreateTypeByMetadataName(string fullTypeName);
    internal bool IsTaskOfType(ITypeSymbol typeSymbol, Func`2<ITypeSymbol, bool> typeArgumentPredicate);
    private static ImmutableArray`1<string> GetNamespaceNamesFromFullTypeName(string fullTypeName);
    private static bool IsIdentifierPartCharacter(char ch);
    private static bool IsSubsetOfCollection(ImmutableArray`1<T> set1, ICollection`1<T> set2);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IAssemblySymbol> <.ctor>b__1_0();
    [CompilerGeneratedAttribute]
internal static WellKnownTypeProvider <GetOrCreate>g__CreateWellKnownTypeProvider|2_0(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.WordParser : object {
    private static char NullChar;
    private WordParserOptions _options;
    private StringBuilder _buffer;
    private string _text;
    [NullableAttribute("2")]
private string _peekedWord;
    private int _index;
    private char _prefix;
    private bool SkipMnemonics { get; }
    private bool SplitCompoundWords { get; }
    public WordParser(string text, WordParserOptions options);
    public WordParser(string text, WordParserOptions options, char prefix);
    private bool get_SkipMnemonics();
    private bool get_SplitCompoundWords();
    internal static Collection`1<string> Parse(string text, WordParserOptions options);
    internal static Collection`1<string> Parse(string text, WordParserOptions options, char prefix);
    public static bool ContainsWord(string text, WordParserOptions options, ImmutableArray`1<string> words);
    internal static bool ContainsWord(string text, WordParserOptions options, char prefix, ImmutableArray`1<string> words);
    [NullableContextAttribute("2")]
public string NextWord();
    [NullableContextAttribute("2")]
public string PeekWord();
    [NullableContextAttribute("2")]
private string NextWordCore();
    private bool ParseNext();
    private bool TryParseWord(char c);
    private bool TryParsePrefix();
    private void ParseWholeWord();
    private void ParseInteger();
    private void ParseHex();
    private void ParseNumeric();
    private void ParseLowercase();
    private void ParseUppercase();
    private void ParseWithoutCase();
    private void ParseAllCaps();
    private void Read();
    private void Skip();
    private char Peek();
    private char Peek(int lookAhead);
    private void Unread();
    private bool IsIgnored(char c);
    private static bool IsLower(char c);
    private static bool IsUpper(char c);
    private static bool IsLetterOrDigit(char c);
    private static bool IsLetterWithoutCase(char c);
    private static bool IsDigit(char c);
    private static bool IsHexDigit(char c);
    private static bool IsIntraWordPunctuation(char c);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.WordParserOptions : Enum {
    public int value__;
    public static WordParserOptions None;
    public static WordParserOptions IgnoreMnemonicsIndicators;
    public static WordParserOptions SplitCompoundWords;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData : object {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ComputationalComplexityMetrics <ComputationalComplexityMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaintainabilityIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<INamedTypeSymbol> <CoupledNamedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SourceLines>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExecutableLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DepthOfInheritance>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<CodeAnalysisMetricData> <Children>k__BackingField;
    public ISymbol Symbol { get; }
    internal ComputationalComplexityMetrics ComputationalComplexityMetrics { get; }
    public int MaintainabilityIndex { get; }
    public ImmutableHashSet`1<INamedTypeSymbol> CoupledNamedTypes { get; }
    public long SourceLines { get; }
    public long ExecutableLines { get; }
    public int CyclomaticComplexity { get; }
    public Nullable`1<int> DepthOfInheritance { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CodeAnalysisMetricData> Children { get; }
    internal CodeAnalysisMetricData(ISymbol symbol, int maintainabilityIndex, ComputationalComplexityMetrics computationalComplexityMetrics, ImmutableHashSet`1<INamedTypeSymbol> coupledNamedTypes, long linesOfCode, int cyclomaticComplexity, Nullable`1<int> depthOfInheritance, ImmutableArray`1<CodeAnalysisMetricData> children);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
internal ComputationalComplexityMetrics get_ComputationalComplexityMetrics();
    [CompilerGeneratedAttribute]
public int get_MaintainabilityIndex();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<INamedTypeSymbol> get_CoupledNamedTypes();
    [CompilerGeneratedAttribute]
public long get_SourceLines();
    [CompilerGeneratedAttribute]
public long get_ExecutableLines();
    [CompilerGeneratedAttribute]
public int get_CyclomaticComplexity();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DepthOfInheritance();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CodeAnalysisMetricData> get_Children();
    public sealed virtual string ToString();
    [ObsoleteAttribute("Use ComputeAsync(CodeMetricsAnalysisContext) instead.")]
public static Task`1<CodeAnalysisMetricData> ComputeAsync(Compilation compilation, CancellationToken cancellationToken);
    public static Task`1<CodeAnalysisMetricData> ComputeAsync(CodeMetricsAnalysisContext context);
    [ObsoleteAttribute("Use ComputeAsync(ISymbol, CodeMetricsAnalysisContext) instead.")]
public static Task`1<CodeAnalysisMetricData> ComputeAsync(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    public static Task`1<CodeAnalysisMetricData> ComputeAsync(ISymbol symbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData/<ComputeAsync>d__34")]
internal static Task`1<ImmutableArray`1<CodeAnalysisMetricData>> ComputeAsync(IEnumerable`1<ISymbol> children, CodeMetricsAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <ToString>g__appendChildren|29_0(string indent, <>c__DisplayClass29_0& );
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData/<<ComputeAsync>g__ComputeAsync|33_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<CodeAnalysisMetricData> <ComputeAsync>g__ComputeAsync|33_0(ISymbol symbol, CodeMetricsAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext : object {
    private ConcurrentDictionary`2<SyntaxTree, SemanticModel> _semanticModelMap;
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<INamedTypeSymbol, bool> <IsExcludedFromInheritanceCountFunc>k__BackingField;
    public Compilation Compilation { get; }
    public CancellationToken CancellationToken { get; }
    public Func`2<INamedTypeSymbol, bool> IsExcludedFromInheritanceCountFunc { get; }
    public CodeMetricsAnalysisContext(Compilation compilation, CancellationToken cancellationToken, Func`2<INamedTypeSymbol, bool> isExcludedFromInheritanceCountFunc);
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public Func`2<INamedTypeSymbol, bool> get_IsExcludedFromInheritanceCountFunc();
    internal SemanticModel GetSemanticModel(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics : object {
    internal static ComputationalComplexityMetrics Default;
    private static object s_nullConstantPlaceholder;
    private long _symbolUsageCounts;
    private long _constantUsageCounts;
    private ImmutableHashSet`1<OperationKind> _distinctOperatorKinds;
    private ImmutableHashSet`1<BinaryOperatorKind> _distinctBinaryOperatorKinds;
    private ImmutableHashSet`1<UnaryOperatorKind> _distinctUnaryOperatorKinds;
    private ImmutableHashSet`1<CaseKind> _distinctCaseKinds;
    private ImmutableHashSet`1<ISymbol> _distinctReferencedSymbols;
    private ImmutableHashSet`1<object> _distinctReferencedConstants;
    [CompilerGeneratedAttribute]
private long <TotalOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExecutableLines>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EffectiveLinesOfCode>k__BackingField;
    public bool IsDefault { get; }
    public long DistinctOperators { get; }
    public long DistinctOperands { get; }
    public long TotalOperators { get; }
    public long TotalOperands { get; }
    public long Vocabulary { get; }
    public long Length { get; }
    public double Volume { get; }
    public long ExecutableLines { get; }
    public long EffectiveLinesOfCode { get; }
    private ComputationalComplexityMetrics(long executableLinesOfCode, long effectiveLinesOfMaintainableCode, long operatorUsageCounts, long symbolUsageCounts, long constantUsageCounts, ImmutableHashSet`1<OperationKind> distinctOperatorKinds, ImmutableHashSet`1<BinaryOperatorKind> distinctBinaryOperatorKinds, ImmutableHashSet`1<UnaryOperatorKind> distinctUnaryOperatorKinds, ImmutableHashSet`1<CaseKind> distinctCaseKinds, ImmutableHashSet`1<ISymbol> distinctReferencedSymbols, ImmutableHashSet`1<object> distinctReferencedConstants);
    private static ComputationalComplexityMetrics();
    private static ComputationalComplexityMetrics Create(long executableLinesOfCode, long operatorUsageCounts, long symbolUsageCounts, long constantUsageCounts, bool hasSymbolInitializer, ImmutableHashSet`1<OperationKind> distinctOperatorKinds, ImmutableHashSet`1<BinaryOperatorKind> distinctBinaryOperatorKinds, ImmutableHashSet`1<UnaryOperatorKind> distinctUnaryOperatorKinds, ImmutableHashSet`1<CaseKind> distinctCaseKinds, ImmutableHashSet`1<ISymbol> distinctReferencedSymbols, ImmutableHashSet`1<object> distinctReferencedConstants);
    public static ComputationalComplexityMetrics Compute(IOperation operationBlock);
    public ComputationalComplexityMetrics Union(ComputationalComplexityMetrics other);
    public bool get_IsDefault();
    public long get_DistinctOperators();
    public long get_DistinctOperands();
    [CompilerGeneratedAttribute]
public long get_TotalOperators();
    public long get_TotalOperands();
    public long get_Vocabulary();
    public long get_Length();
    public double get_Volume();
    [CompilerGeneratedAttribute]
public long get_ExecutableLines();
    [CompilerGeneratedAttribute]
public long get_EffectiveLinesOfCode();
    [CompilerGeneratedAttribute]
internal static int <Compute>g__getExecutableLinesOfCode|12_0(IOperation operation, Boolean& hasSymbolInitializer);
    [CompilerGeneratedAttribute]
internal static bool <Compute>g__hasAnyExplicitExpression|12_1(IOperation operation);
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countOperator|12_2(IOperation operation, <>c__DisplayClass12_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <Compute>g__countOperand|12_3(ISymbol symbol, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countBinaryOperator|12_4(IOperation operation, BinaryOperatorKind operatorKind, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countUnaryOperator|12_5(IOperation operation, UnaryOperatorKind operatorKind, <>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper : object {
    internal static int GetAverageRoundedMetricValue(int total, int childrenCount);
    private static int RoundMetricValue(double value);
    internal static int NormalizeAndRoundMaintainabilityIndex(double maintIndex);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, IEnumerable`1<ITypeSymbol> coupledTypes);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, ITypeSymbol[] coupledTypes);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<IParameterSymbol> parameters);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<GetLinesOfCodeAsync>d__6")]
internal static Task`1<long> GetLinesOfCodeAsync(ImmutableArray`1<SyntaxReference> declarations, ISymbol symbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<GetTopmostSyntaxNodeForDeclarationAsync>d__7")]
internal static Task`1<SyntaxNode> GetTopmostSyntaxNodeForDeclarationAsync(SyntaxReference declaration, ISymbol declaredSymbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync>d__8")]
internal static Task`1<ValueTuple`2<int, ComputationalComplexityMetrics>> ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync(ImmutableArray`1<SyntaxReference> declarations, ISymbol symbol, Builder<INamedTypeSymbol> builder, CodeMetricsAnalysisContext context);
    private static void AddCoupledNamedTypesCore(Builder<INamedTypeSymbol> builder, ITypeSymbol typeOpt, WellKnownTypeProvider wellKnownTypeProvider);
    internal static void RemoveContainingTypes(ISymbol symbol, Builder<INamedTypeSymbol> coupledTypesBuilder);
    [ExtensionAttribute]
internal static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol member);
    [CompilerGeneratedAttribute]
internal static int <GetLinesOfCodeAsync>g__GetNewlineCount|6_0(SyntaxTriviaList trivialList, bool leading);
    [CompilerGeneratedAttribute]
internal static int <GetLinesOfCodeAsync>g__GetNewlineCount|6_1(ImmutableArray`1<string> triviaParts, bool leading);
    [CompilerGeneratedAttribute]
internal static bool <GetLinesOfCodeAsync>g__LoopConditionForLeading|6_2(int index, int length);
    [CompilerGeneratedAttribute]
internal static bool <GetLinesOfCodeAsync>g__LoopConditionForTrailing|6_3(int index, int _);
    [CompilerGeneratedAttribute]
internal static bool <ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync>g__hasConditionalLogic|8_0(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <AddCoupledNamedTypesCore>g__isIgnoreableType|9_0(INamedTypeSymbol namedType, WellKnownTypeProvider wellKnownTypeProvider);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions/<GetPredecessorsWithBranches>d__0")]
[ExtensionAttribute]
internal static IEnumerable`1<ValueTuple`2<BasicBlock, BranchWithInfo>> GetPredecessorsWithBranches(BasicBlock basicBlock, ControlFlowGraph cfg);
    [ExtensionAttribute]
internal static ITypeSymbol GetEnclosingRegionExceptionType(BasicBlock basicBlock);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions/<DescendantOperations>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(BasicBlock basicBlock);
    [ExtensionAttribute]
public static bool IsContainedInRegionOfKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind);
    [ExtensionAttribute]
public static ControlFlowRegion GetContainingRegionOfKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind);
    [ExtensionAttribute]
public static bool IsFirstBlockOfFinally(BasicBlock basicBlock, ControlFlowRegion& finallyRegion);
    [ExtensionAttribute]
public static bool IsLastBlockOfFinally(BasicBlock basicBlock, ControlFlowRegion& finallyRegion);
    [ExtensionAttribute]
public static bool IsFirstBlockOfRegionKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind, ControlFlowRegion& region);
    [ExtensionAttribute]
public static bool IsLastBlockOfRegionKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind, ControlFlowRegion& region);
    [ExtensionAttribute]
private static bool IsFirstOrLastBlockOfRegionKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind, bool first, ControlFlowRegion& foundRegion);
    [ExtensionAttribute]
public static bool IsFirstBlockOfCompilerGeneratedFinally(BasicBlock basicBlock, ControlFlowGraph cfg);
    [ExtensionAttribute]
internal static ControlFlowRegion GetInnermostRegionStartedByBlock(BasicBlock basicBlock, ControlFlowRegionKind regionKind);
    [ExtensionAttribute]
internal static int GetMaxSuccessorOrdinal(BasicBlock basicBlock);
    [ExtensionAttribute]
internal static bool DominatesPredecessors(BasicBlock basicBlock, ControlFlowGraph cfg);
    [CompilerGeneratedAttribute]
internal static bool <DominatesPredecessors>g__DominatesBlock|13_0(BasicBlock sourceBlock, BasicBlock basicBlock, PooledHashSet`1<int> processedOrdinals, ArrayBuilder`1<int> unprocessedOrdinals);
    [CompilerGeneratedAttribute]
internal static bool <DominatesPredecessors>g__DominatesBranch|13_1(ControlFlowBranch branch, BasicBlock basicBlock, PooledHashSet`1<int> processedOrdinals, ArrayBuilder`1<int> unprocessedOrdinals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.BranchWithInfo : object {
    private static Func`2<ControlFlowRegion, IEnumerable`1<ControlFlowRegion>> s_getTransitiveNestedRegions;
    [CompilerGeneratedAttribute]
private BasicBlock <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBranchSemantics <Kind>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ControlFlowRegion> <EnteringRegions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ControlFlowRegion> <FinallyRegions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ControlFlowRegion> <LeavingRegions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IOperation <BranchValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowConditionKind <ControlFlowConditionKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ILocalSymbol> <LeavingRegionLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CaptureId> <LeavingRegionFlowCaptures>k__BackingField;
    public BasicBlock Destination { get; }
    public ControlFlowBranchSemantics Kind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ControlFlowRegion> EnteringRegions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ControlFlowRegion> FinallyRegions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ControlFlowRegion> LeavingRegions { get; }
    [NullableAttribute("2")]
public IOperation BranchValue { get; }
    public ControlFlowConditionKind ControlFlowConditionKind { get; }
    public IEnumerable`1<ILocalSymbol> LeavingRegionLocals { get; }
    public IEnumerable`1<CaptureId> LeavingRegionFlowCaptures { get; }
    internal BranchWithInfo(ControlFlowBranch branch);
    internal BranchWithInfo(BasicBlock destination);
    private BranchWithInfo(BasicBlock destination, ImmutableArray`1<ControlFlowRegion> enteringRegions, ImmutableArray`1<ControlFlowRegion> leavingRegions, ImmutableArray`1<ControlFlowRegion> finallyRegions, ControlFlowBranchSemantics kind, IOperation branchValue, ControlFlowConditionKind controlFlowConditionKind, IEnumerable`1<ILocalSymbol> leavingRegionLocals, IEnumerable`1<CaptureId> leavingRegionFlowCaptures);
    private static BranchWithInfo();
    [CompilerGeneratedAttribute]
public BasicBlock get_Destination();
    [CompilerGeneratedAttribute]
public ControlFlowBranchSemantics get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ControlFlowRegion> get_EnteringRegions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ControlFlowRegion> get_FinallyRegions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ControlFlowRegion> get_LeavingRegions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IOperation get_BranchValue();
    [CompilerGeneratedAttribute]
public ControlFlowConditionKind get_ControlFlowConditionKind();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ILocalSymbol> get_LeavingRegionLocals();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CaptureId> get_LeavingRegionFlowCaptures();
    internal BranchWithInfo WithEmptyRegions(BasicBlock destination);
    internal BranchWithInfo With(IOperation branchValue, ControlFlowConditionKind controlFlowConditionKind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BranchWithInfo/<GetTransitiveNestedRegions>d__33")]
private static IEnumerable`1<ControlFlowRegion> GetTransitiveNestedRegions(ControlFlowRegion region);
    private static IEnumerable`1<ILocalSymbol> ComputeLeavingRegionLocals(ImmutableArray`1<ControlFlowRegion> leavingRegions);
    private static IEnumerable`1<CaptureId> ComputeLeavingRegionFlowCaptures(ImmutableArray`1<ControlFlowRegion> leavingRegions);
    private static ControlFlowConditionKind GetControlFlowConditionKind(ControlFlowBranch branch);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsBackEdge(ControlFlowBranch controlFlowBranch);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowConditionKindExtensions : object {
    [ExtensionAttribute]
public static ControlFlowConditionKind Negate(ControlFlowConditionKind controlFlowConditionKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions : object {
    [ExtensionAttribute]
public static BasicBlock GetEntry(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static BasicBlock GetExit(ControlFlowGraph cfg);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions/<DescendantOperations>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(ControlFlowGraph cfg);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions/<DescendantOperations>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> DescendantOperations(ControlFlowGraph cfg, OperationKind operationKind);
    [ExtensionAttribute]
internal static bool SupportsFlowAnalysis(ControlFlowGraph cfg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionExtensions : object {
    [ExtensionAttribute]
public static bool ContainsRegionOrSelf(ControlFlowRegion controlFlowRegion, ControlFlowRegion nestedRegion);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionExtensions/<DescendantOperations>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(ControlFlowRegion controlFlowRegion, ControlFlowGraph cfg);
}
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisData : object {
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisDomain`1 : object {
    public abstract virtual TAnalysisData Clone(TAnalysisData value);
    public abstract virtual TAnalysisData Merge(TAnalysisData value1, TAnalysisData value2);
    public abstract virtual int Compare(TAnalysisData oldValue, TAnalysisData newValue);
    public abstract virtual bool Equals(TAnalysisData value1, TAnalysisData value2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractBlockAnalysisResult : object {
    [CompilerGeneratedAttribute]
private BasicBlock <BasicBlock>k__BackingField;
    public BasicBlock BasicBlock { get; }
    protected AbstractBlockAnalysisResult(BasicBlock basicBlock);
    [CompilerGeneratedAttribute]
public BasicBlock get_BasicBlock();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDataFlowAnalysisContext`4 : CacheBasedEquatable`1<TAnalysisContext> {
    [CompilerGeneratedAttribute]
private AbstractValueDomain`1<TAbstractAnalysisValue> <ValueDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private WellKnownTypeProvider <WellKnownTypeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <OwningSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalyzerOptions <AnalyzerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private InterproceduralAnalysisConfiguration <InterproceduralAnalysisConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PessimisticAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PredicateAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExceptionPathsAnalysis>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> <CopyAnalysisResult>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PointsToAnalysisResult <PointsToAnalysisResult>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> <ValueContentAnalysisResult>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<TAnalysisContext, TAnalysisResult> <TryGetOrComputeAnalysisResult>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ControlFlowGraph <ParentControlFlowGraph>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> <InterproceduralAnalysisData>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private InterproceduralAnalysisPredicate <InterproceduralAnalysisPredicate>k__BackingField;
    public AbstractValueDomain`1<TAbstractAnalysisValue> ValueDomain { get; }
    public WellKnownTypeProvider WellKnownTypeProvider { get; }
    public ControlFlowGraph ControlFlowGraph { get; }
    public ISymbol OwningSymbol { get; }
    public AnalyzerOptions AnalyzerOptions { get; }
    public InterproceduralAnalysisConfiguration InterproceduralAnalysisConfiguration { get; }
    public bool PessimisticAnalysis { get; }
    public bool PredicateAnalysis { get; }
    public bool ExceptionPathsAnalysis { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> CopyAnalysisResult { get; }
    [NullableAttribute("2")]
public PointsToAnalysisResult PointsToAnalysisResult { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> ValueContentAnalysisResult { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<TAnalysisContext, TAnalysisResult> TryGetOrComputeAnalysisResult { get; }
    [NullableAttribute("2")]
protected ControlFlowGraph ParentControlFlowGraph { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> InterproceduralAnalysisData { get; }
    [NullableAttribute("2")]
public InterproceduralAnalysisPredicate InterproceduralAnalysisPredicate { get; }
    protected AbstractDataFlowAnalysisContext`4(AbstractValueDomain`1<TAbstractAnalysisValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool predicateAnalysis, bool exceptionPathsAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Func`2<TAnalysisContext, TAnalysisResult> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> interproceduralAnalysisData, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    [CompilerGeneratedAttribute]
public AbstractValueDomain`1<TAbstractAnalysisValue> get_ValueDomain();
    [CompilerGeneratedAttribute]
public WellKnownTypeProvider get_WellKnownTypeProvider();
    [CompilerGeneratedAttribute]
public sealed virtual ControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbol get_OwningSymbol();
    [CompilerGeneratedAttribute]
public AnalyzerOptions get_AnalyzerOptions();
    [CompilerGeneratedAttribute]
public InterproceduralAnalysisConfiguration get_InterproceduralAnalysisConfiguration();
    [CompilerGeneratedAttribute]
public bool get_PessimisticAnalysis();
    [CompilerGeneratedAttribute]
public bool get_PredicateAnalysis();
    [CompilerGeneratedAttribute]
public bool get_ExceptionPathsAnalysis();
    [CompilerGeneratedAttribute]
public DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> get_CopyAnalysisResult();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PointsToAnalysisResult get_PointsToAnalysisResult();
    [CompilerGeneratedAttribute]
public DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> get_ValueContentAnalysisResult();
    [CompilerGeneratedAttribute]
public Func`2<TAnalysisContext, TAnalysisResult> get_TryGetOrComputeAnalysisResult();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected ControlFlowGraph get_ParentControlFlowGraph();
    [CompilerGeneratedAttribute]
public InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> get_InterproceduralAnalysisData();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public InterproceduralAnalysisPredicate get_InterproceduralAnalysisPredicate();
    public abstract virtual TAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> interproceduralAnalysisData);
    public sealed virtual ControlFlowGraph GetLocalFunctionControlFlowGraph(IMethodSymbol localFunction);
    public sealed virtual ControlFlowGraph GetAnonymousFunctionControlFlowGraph(IFlowAnonymousFunctionOperation lambda);
    protected abstract virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected abstract virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> obj);
    protected sealed virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected sealed virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<TAnalysisContext> obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetLocalFunctionControlFlowGraph>b__50_0(TAnalysisContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetAnonymousFunctionControlFlowGraph>b__51_0(TAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDomain`1 : object {
    public T Bottom { get; }
    public abstract virtual T get_Bottom();
    public abstract virtual T Merge(T value1, T value2);
    public int Compare(T oldValue, T newValue);
    public bool Equals(T value1, T value2);
    public abstract virtual int Compare(T oldValue, T newValue, bool assertMonotonicity);
    [ConditionalAttribute("DEBUG")]
protected static void FireNonMonotonicAssertIfNeeded(bool assertMonotonicity);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractIndex : CacheBasedEquatable`1<AbstractIndex> {
    public static AbstractIndex Create(int index);
    public static AbstractIndex Create(AnalysisEntity analysisEntity);
    public static AbstractIndex Create(IOperation operation);
    internal bool IsConstant();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation : CacheBasedEquatable`1<AbstractLocation> {
    private bool _isSpecialSingleton;
    [NullableAttribute("1")]
public static AbstractLocation Null;
    [NullableAttribute("1")]
public static AbstractLocation NoLocation;
    [CompilerGeneratedAttribute]
private IOperation <Creation>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ImmutableStack`1<IOperation> <CreationCallStack>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalysisEntity <AnalysisEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<InterproceduralCaptureId> <CaptureId>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <LocationType>k__BackingField;
    public IOperation Creation { get; }
    [NullableAttribute("1")]
public ImmutableStack`1<IOperation> CreationCallStack { get; }
    public AnalysisEntity AnalysisEntity { get; }
    public ISymbol Symbol { get; }
    public Nullable`1<InterproceduralCaptureId> CaptureId { get; }
    public ITypeSymbol LocationType { get; }
    public bool IsNull { get; }
    public bool IsNoLocation { get; }
    public bool IsAnalysisEntityDefaultLocation { get; }
    private AbstractLocation(IOperation creation, ImmutableStack`1<IOperation> creationCallStack, AnalysisEntity analysisEntity, ISymbol symbol, Nullable`1<InterproceduralCaptureId> captureId, ITypeSymbol locationType, bool isSpecialSingleton);
    private static AbstractLocation();
    private static AbstractLocation Create(IOperation creation, ImmutableStack`1<IOperation> creationCallStack, AnalysisEntity analysisEntity, ISymbol symbol, Nullable`1<InterproceduralCaptureId> captureId, ITypeSymbol locationType);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateAllocationLocation(IOperation creation, ITypeSymbol locationType, PointsToAnalysisContext analysisContext);
    [NullableContextAttribute("1")]
internal static AbstractLocation CreateAllocationLocation(IOperation creation, ITypeSymbol locationType, ImmutableStack`1<IOperation> callStack);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateAnalysisEntityDefaultLocation(AnalysisEntity analysisEntity);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateThisOrMeLocation(INamedTypeSymbol namedTypeSymbol, ImmutableStack`1<IOperation> creationCallStack);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateSymbolLocation(ISymbol symbol, ImmutableStack`1<IOperation> creationCallStack);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateFlowCaptureLocation(InterproceduralCaptureId captureId, ITypeSymbol locationType, ImmutableStack`1<IOperation> creationCallStack);
    [CompilerGeneratedAttribute]
public IOperation get_Creation();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ImmutableStack`1<IOperation> get_CreationCallStack();
    public IOperation GetTopOfCreationCallStackOrCreation();
    [CompilerGeneratedAttribute]
public AnalysisEntity get_AnalysisEntity();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public Nullable`1<InterproceduralCaptureId> get_CaptureId();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_LocationType();
    public bool get_IsNull();
    public bool get_IsNoLocation();
    public bool get_IsAnalysisEntityDefaultLocation();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    [NullableContextAttribute("1")]
protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<AbstractLocation> obj);
    public SyntaxNode TryGetNodeToReportDiagnostic(PointsToAnalysisResult pointsToAnalysisResult);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <TryGetNodeToReportDiagnostic>g__TryGetSyntaxNodeToReportDiagnostic|38_0(IOperation creation, PointsToAnalysisResult pointsToAnalysisResult);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <TryGetNodeToReportDiagnostic>g__TryGetSyntaxNodeToReportDiagnosticCore|38_1(IOperation operation, <>c__DisplayClass38_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <TryGetNodeToReportDiagnostic>g__TryGetSyntaxNodeToReportDiagnosticForPointsValue|38_2(PointsToAbstractValue pointsToValue, IOperation operation, <>c__DisplayClass38_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocationDataFlowOperationVisitor`4 : DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> {
    protected AbstractLocationDataFlowOperationVisitor`4(TAnalysisContext analysisContext);
    protected abstract virtual TAbstractAnalysisValue GetAbstractValue(AbstractLocation location);
    protected abstract virtual void SetAbstractValue(AbstractLocation location, TAbstractAnalysisValue value);
    protected void SetAbstractValue(PointsToAbstractValue instanceLocation, TAbstractAnalysisValue value);
    protected void SetAbstractValue(IEnumerable`1<AbstractLocation> locations, TAbstractAnalysisValue value);
    protected abstract virtual void StopTrackingAbstractValue(AbstractLocation location);
    protected virtual void StopTrackingDataForParameter(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected virtual void ResetValueTypeInstanceAnalysisData(AnalysisEntity analysisEntity);
    protected virtual void ResetReferenceTypeInstanceAnalysisData(PointsToAbstractValue pointsToAbstractValue);
    protected virtual TAbstractAnalysisValue HandleInstanceCreation(IOperation creation, PointsToAbstractValue instanceLocation, TAbstractAnalysisValue defaultValue);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForEscapedRefOrOutArgument(IArgumentOperation operation, TAbstractAnalysisValue defaultValue);
    protected abstract virtual void SetValueForParameterPointsToLocationOnEntry(IParameterSymbol parameter, PointsToAbstractValue pointsToAbstractValue);
    protected abstract virtual void EscapeValueForParameterPointsToLocationOnExit(IParameterSymbol parameter, AnalysisEntity analysisEntity, ImmutableHashSet`1<AbstractLocation> escapedLocations);
    protected virtual void SetValueForParameterOnEntry(IParameterSymbol parameter, AnalysisEntity analysisEntity, ArgumentInfo`1<TAbstractAnalysisValue> assignedValue);
    protected virtual void EscapeValueForParameterOnExit(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected void ResetAnalysisData(DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> currentAnalysisData);
    protected static DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> GetClonedAnalysisDataHelper(IDictionary`2<AbstractLocation, TAbstractAnalysisValue> analysisData);
    protected static DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> GetEmptyAnalysisDataHelper();
    protected void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> coreDataAtException, DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> coreCurrentAnalysisData);
    public virtual TAbstractAnalysisValue VisitObjectCreation(IObjectCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitTypeParameterObjectCreation(ITypeParameterObjectCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitDynamicObjectCreation(IDynamicObjectCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitAnonymousObjectCreation(IAnonymousObjectCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitArrayCreation(IArrayCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitDelegateCreation(IDelegateCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitReDimClause(IReDimClauseOperation operation, object argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractValueDomain`1 : AbstractDomain`1<T> {
    public T UnknownOrMayBeValue { get; }
    public abstract virtual T get_UnknownOrMayBeValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity : CacheBasedEquatable`1<AnalysisEntity> {
    private int _ignoringLocationHashCode;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AbstractIndex> <Indices>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SyntaxNode <InstanceReferenceOperationSyntax>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<InterproceduralCaptureId> <CaptureId>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAbstractValue <InstanceLocation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AnalysisEntity <EntityForInstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AnalysisEntity <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsThisOrMeInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EqualsIgnoringInstanceLocationId>k__BackingField;
    public bool IsChildOrInstanceMember { get; }
    public bool HasConstantValue { get; }
    [NullableAttribute("2")]
public ISymbol Symbol { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<AbstractIndex> Indices { get; }
    [NullableAttribute("2")]
public SyntaxNode InstanceReferenceOperationSyntax { get; }
    public Nullable`1<InterproceduralCaptureId> CaptureId { get; }
    public PointsToAbstractValue InstanceLocation { get; }
    [NullableAttribute("2")]
public AnalysisEntity EntityForInstanceLocation { get; }
    public ITypeSymbol Type { get; }
    [NullableAttribute("2")]
public AnalysisEntity Parent { get; }
    public bool IsThisOrMeInstance { get; }
    public bool HasUnknownInstanceLocation { get; }
    public bool IsLValueFlowCaptureEntity { get; }
    public int EqualsIgnoringInstanceLocationId { get; private set; }
    [NullableContextAttribute("2")]
private AnalysisEntity(ISymbol symbol, ImmutableArray`1<AbstractIndex> indices, SyntaxNode instanceReferenceOperationSyntax, Nullable`1<InterproceduralCaptureId> captureId, PointsToAbstractValue location, ITypeSymbol type, AnalysisEntity parent, AnalysisEntity entityForInstanceLocation, bool isThisOrMeInstance);
    [NullableContextAttribute("2")]
private AnalysisEntity(ISymbol symbol, ImmutableArray`1<AbstractIndex> indices, PointsToAbstractValue location, ITypeSymbol type, AnalysisEntity parent, AnalysisEntity entityForInstanceLocation);
    private AnalysisEntity(IInstanceReferenceOperation instanceReferenceOperation, PointsToAbstractValue location);
    private AnalysisEntity(InterproceduralCaptureId captureId, ITypeSymbol capturedType, PointsToAbstractValue location);
    private AnalysisEntity(INamedTypeSymbol namedType, PointsToAbstractValue location, bool isThisOrMeInstance);
    public static AnalysisEntity Create(ISymbol symbol, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol type, PointsToAbstractValue instanceLocation, AnalysisEntity parent, AnalysisEntity entityForInstanceLocation);
    public static AnalysisEntity Create(IInstanceReferenceOperation instanceReferenceOperation, PointsToAbstractValue instanceLocation);
    public static AnalysisEntity Create(InterproceduralCaptureId interproceduralCaptureId, ITypeSymbol type, PointsToAbstractValue instanceLocation);
    public static AnalysisEntity CreateThisOrMeInstance(INamedTypeSymbol typeSymbol, PointsToAbstractValue instanceLocation);
    public AnalysisEntity WithMergedInstanceLocation(AnalysisEntity analysisEntityToMerge);
    public bool get_IsChildOrInstanceMember();
    internal bool ShouldBeTrackedForPointsToAnalysis(PointsToAnalysisKind pointsToAnalysisKind);
    internal bool ShouldBeTrackedForAnalysis(bool hasCompletePointsToAnalysisResult);
    public bool get_HasConstantValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AbstractIndex> get_Indices();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SyntaxNode get_InstanceReferenceOperationSyntax();
    [CompilerGeneratedAttribute]
public Nullable`1<InterproceduralCaptureId> get_CaptureId();
    [CompilerGeneratedAttribute]
public PointsToAbstractValue get_InstanceLocation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AnalysisEntity get_EntityForInstanceLocation();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AnalysisEntity get_Parent();
    [CompilerGeneratedAttribute]
public bool get_IsThisOrMeInstance();
    public bool get_HasUnknownInstanceLocation();
    public bool get_IsLValueFlowCaptureEntity();
    internal AnalysisEntity WithIndices(ImmutableArray`1<AbstractIndex> indices);
    [NullableContextAttribute("2")]
public bool EqualsIgnoringInstanceLocation(AnalysisEntity other);
    [CompilerGeneratedAttribute]
public int get_EqualsIgnoringInstanceLocationId();
    [CompilerGeneratedAttribute]
private void set_EqualsIgnoringInstanceLocationId(int value);
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<AnalysisEntity> obj);
    private void ComputeHashCodePartsIgnoringLocation(RoslynHashCode& hashCode);
    private int ComputeIgnoringLocationHashCode();
    public bool HasAncestor(AnalysisEntity ancestor);
    internal bool IsCandidatePredicateEntity();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityBasedPredicateAnalysisData`1 : PredicatedAnalysisData`2<AnalysisEntity, TValue> {
    [CompilerGeneratedAttribute]
private DictionaryAnalysisData`2<AnalysisEntity, TValue> <CoreAnalysisData>k__BackingField;
    public DictionaryAnalysisData`2<AnalysisEntity, TValue> CoreAnalysisData { get; }
    public bool HasAnyAbstractValue { get; }
    protected AbstractValueDomain`1<TValue> ValueDomain { get; }
    public TValue Item { get; }
    protected AnalysisEntityBasedPredicateAnalysisData`1(IDictionary`2<AnalysisEntity, TValue> fromData);
    protected AnalysisEntityBasedPredicateAnalysisData`1(AnalysisEntityBasedPredicateAnalysisData`1<TValue> fromData);
    protected AnalysisEntityBasedPredicateAnalysisData`1(AnalysisEntityBasedPredicateAnalysisData`1<TValue> data1, AnalysisEntityBasedPredicateAnalysisData`1<TValue> data2, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    protected AnalysisEntityBasedPredicateAnalysisData`1(DictionaryAnalysisData`2<AnalysisEntity, TValue> mergedCoreAnalysisData, PredicatedAnalysisData`2<AnalysisEntity, TValue> predicatedData1, PredicatedAnalysisData`2<AnalysisEntity, TValue> predicatedData2, bool isReachableData, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    [CompilerGeneratedAttribute]
public DictionaryAnalysisData`2<AnalysisEntity, TValue> get_CoreAnalysisData();
    public virtual bool get_HasAnyAbstractValue();
    protected abstract virtual AbstractValueDomain`1<TValue> get_ValueDomain();
    public abstract virtual AnalysisEntityBasedPredicateAnalysisData`1<TValue> Clone();
    public abstract virtual AnalysisEntityBasedPredicateAnalysisData`1<TValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<TValue> data, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    public abstract virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<TValue> other, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    protected int BaseCompareHelper(AnalysisEntityBasedPredicateAnalysisData`1<TValue> newData, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    public bool HasAbstractValue(AnalysisEntity analysisEntity);
    public bool TryGetValue(AnalysisEntity key, TValue& value);
    public TValue get_Item(AnalysisEntity key);
    [ConditionalAttribute("DEBUG")]
private void AssertValidAnalysisData();
    public virtual void SetAbstractValue(AnalysisEntity key, TValue value);
    public void RemoveEntries(AnalysisEntity key);
    public bool Equals(AnalysisEntityBasedPredicateAnalysisData`1<TValue> other);
    public virtual void Reset(Func`3<AnalysisEntity, TValue, TValue> getResetValue);
    public void StartTrackingPredicatedData(AnalysisEntity predicatedEntity, AnalysisEntityBasedPredicateAnalysisData`1<TValue> truePredicateData, AnalysisEntityBasedPredicateAnalysisData`1<TValue> falsePredicateData);
    public PredicateValueKind ApplyPredicatedDataForEntity(AnalysisEntity predicatedEntity, bool trueData);
    public void AddTrackedEntities(HashSet`1<AnalysisEntity> builder);
    private void ClearOverlappingAnalysisDataForIndexedEntity(AnalysisEntity analysisEntity, TValue value);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4 : DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> {
    protected bool SupportsPredicateAnalysis { get; }
    protected AnalysisEntityDataFlowOperationVisitor`4(TAnalysisContext analysisContext);
    protected virtual bool get_SupportsPredicateAnalysis();
    protected void AddTrackedEntities(HashSet`1<AnalysisEntity> builder, bool forInterproceduralAnalysis);
    protected abstract virtual void AddTrackedEntities(TAnalysisData analysisData, HashSet`1<AnalysisEntity> builder, bool forInterproceduralAnalysis);
    protected abstract virtual void SetAbstractValue(AnalysisEntity analysisEntity, TAbstractAnalysisValue value);
    protected abstract virtual void ResetAbstractValue(AnalysisEntity analysisEntity);
    protected abstract virtual TAbstractAnalysisValue GetAbstractValue(AnalysisEntity analysisEntity);
    protected abstract virtual bool HasAbstractValue(AnalysisEntity analysisEntity);
    protected abstract virtual void StopTrackingEntity(AnalysisEntity analysisEntity, TAnalysisData analysisData);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForReferenceOperation(IOperation operation, TAbstractAnalysisValue defaultValue);
    protected sealed virtual TAbstractAnalysisValue ComputeAnalysisValueForEscapedRefOrOutArgument(IArgumentOperation operation, TAbstractAnalysisValue defaultValue);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForEscapedRefOrOutArgument(AnalysisEntity analysisEntity, IArgumentOperation operation, TAbstractAnalysisValue defaultValue);
    protected void ResetAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> currentAnalysisData);
    protected virtual void ProcessOutOfScopeLocalsAndFlowCaptures(IEnumerable`1<ILocalSymbol> locals, IEnumerable`1<CaptureId> flowCaptures);
    private void StopTrackingDataForEntity(AnalysisEntity analysisEntity, PooledHashSet`1<AnalysisEntity> allEntities);
    private void StopTrackingDataForEntity(AnalysisEntity analysisEntity, TAnalysisData analysisData, PooledHashSet`1<AnalysisEntity> allEntities);
    private void StopTrackingDataForParamArrayParameterIndices(AnalysisEntity analysisEntity, TAnalysisData analysisData, PooledHashSet`1<AnalysisEntity> allEntities);
    protected sealed virtual void StopTrackingDataForParameter(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected sealed virtual void StopTrackingDataForParameters(ImmutableDictionary`2<IParameterSymbol, AnalysisEntity> parameterEntities);
    protected virtual TAnalysisData GetMergedAnalysisDataForPossibleThrowingOperation(TAnalysisData existingData, IOperation operation);
    protected virtual void SetAbstractValueForArrayElementInitializer(IArrayCreationOperation arrayCreation, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol elementType, IOperation initializer, TAbstractAnalysisValue value);
    protected virtual void SetAbstractValueForAssignment(IOperation target, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue, bool mayBeAssignment);
    protected virtual void SetAbstractValueForTupleElementAssignment(AnalysisEntity tupleElementEntity, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue);
    protected virtual void SetAbstractValueForAssignment(AnalysisEntity targetAnalysisEntity, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue);
    private void SetAbstractValueForAssignment(AnalysisEntity targetAnalysisEntity, AnalysisEntity assignedValueEntity, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue);
    protected virtual void SetValueForParameterOnEntry(IParameterSymbol parameter, AnalysisEntity analysisEntity, ArgumentInfo`1<TAbstractAnalysisValue> assignedValue);
    protected virtual void EscapeValueForParameterOnExit(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected virtual TAbstractAnalysisValue GetDefaultValueForParameterOnEntry(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected virtual TAbstractAnalysisValue GetDefaultValueForParameterOnExit(ITypeSymbol parameterType);
    protected virtual void ResetValueTypeInstanceAnalysisData(AnalysisEntity analysisEntity);
    protected virtual void ResetReferenceTypeInstanceAnalysisData(PointsToAbstractValue pointsToAbstractValue);
    private void ResetInstanceAnalysisDataCore(IEnumerable`1<AnalysisEntity> dependantAnalysisEntities);
    [NullableContextAttribute("2")]
private void TransferValueTypeInstanceAnalysisDataForAssignment(AnalysisEntity targetAnalysisEntity, AnalysisEntity valueAnalysisEntity, IOperation assignedValueOperation);
    private ImmutableHashSet`1<AnalysisEntity> GetChildAnalysisEntities(AnalysisEntity analysisEntity);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4/<GetChildAnalysisEntities>d__35")]
private static IEnumerable`1<AnalysisEntity> GetChildAnalysisEntities(AnalysisEntity analysisEntity, HashSet`1<AnalysisEntity> allEntities);
    protected static bool IsChildAnalysisEntity(AnalysisEntity entity, AnalysisEntity ancestorEntity);
    protected ImmutableHashSet`1<AnalysisEntity> GetChildAnalysisEntities(PointsToAbstractValue instanceLocation);
    private ImmutableHashSet`1<AnalysisEntity> GetChildAnalysisEntities(PointsToAbstractValue instanceLocation, Func`2<AnalysisEntity, bool> predicate);
    protected static bool IsChildAnalysisEntity(AnalysisEntity entity, PointsToAbstractValue instanceLocation);
    private ImmutableHashSet`1<AnalysisEntity> GetChildAnalysisEntities(Func`2<AnalysisEntity, bool> predicate);
    protected virtual TAnalysisData GetInitialInterproceduralAnalysisData(IMethodSymbol invokedMethod, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> invocationInstance, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> thisOrMeInstanceForCaller, ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> argumentValuesMap, IDictionary`2<AnalysisEntity, PointsToAbstractValue> pointsToValues, IDictionary`2<AnalysisEntity, CopyAbstractValue> copyValues, IDictionary`2<AnalysisEntity, ValueContentAbstractValue> valueContentValues, bool isLambdaOrLocalFunction, bool hasParameterWithDelegateType);
    protected abstract virtual TAnalysisData GetTrimmedCurrentAnalysisData(IEnumerable`1<AnalysisEntity> withEntities);
    protected TAnalysisData GetTrimmedCurrentAnalysisDataHelper(IEnumerable`1<AnalysisEntity> withEntities, IDictionary`2<AnalysisEntity, TAbstractAnalysisValue> existingValues, Action`3<TAnalysisData, AnalysisEntity, TAbstractAnalysisValue> setAbstractValue);
    protected abstract virtual void ApplyInterproceduralAnalysisResultCore(TAnalysisData resultData);
    protected sealed virtual void ApplyInterproceduralAnalysisResult(TAnalysisData resultData, bool isLambdaOrLocalFunction, bool hasDelegateTypeArgument, TAnalysisResult analysisResult);
    protected void ApplyInterproceduralAnalysisResultHelper(IDictionary`2<AnalysisEntity, TAbstractAnalysisValue> resultToApply);
    internal bool ShouldStopTrackingEntityAtExit(AnalysisEntity entity);
    [NullableContextAttribute("2")]
public virtual TAnalysisData GetMergedDataForUnhandledThrowOperations();
    protected DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> GetClonedAnalysisDataHelper(IDictionary`2<AnalysisEntity, TAbstractAnalysisValue> analysisData);
    protected void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> coreDataAtException, DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> coreCurrentAnalysisData, ThrownExceptionInfo throwBranchWithExceptionType);
    public virtual TAbstractAnalysisValue VisitDeconstructionAssignment(IDeconstructionAssignmentOperation operation, object argument);
    private void HandleDeconstructionAssignment(IOperation target, ImmutableHashSet`1<AnalysisEntity> childEntities);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetMergedAnalysisDataForPossibleThrowingOperation>b__20_0(AnalysisEntity e);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <GetInitialInterproceduralAnalysisData>g__AddWorklistEntityAndPointsToValue|41_0(AnalysisEntity analysisEntity, <>c__DisplayClass41_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <GetInitialInterproceduralAnalysisData>g__AddWorklistPointsToValue|41_1(PointsToAbstractValue pointsToValue, <>c__DisplayClass41_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetInitialInterproceduralAnalysisData>g__ShouldProcessPointsToValue|41_2(PointsToAbstractValue pointsToValue);
    [CompilerGeneratedAttribute]
internal static bool <HandleDeconstructionAssignment>g__IsMatchingAssignedEntity|52_0(AnalysisEntity tupleElementEntity, AnalysisEntity childEntity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityFactory : object {
    private ControlFlowGraph _controlFlowGraph;
    private WellKnownTypeProvider _wellKnownTypeProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IOperation, AnalysisEntity> _analysisEntityMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ITupleOperation, ImmutableArray`1<AnalysisEntity>> _tupleElementEntitiesMap;
    private Dictionary`2<CaptureId, AnalysisEntity> _captureIdEntityMap;
    private Dictionary`2<CaptureId, CopyAbstractValue> _captureIdCopyValueMap;
    private Dictionary`2<ISymbol, PointsToAbstractValue> _instanceLocationsForSymbols;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IOperation, PointsToAbstractValue> _getPointsToAbstractValue;
    private Func`1<bool> _getIsInsideAnonymousObjectInitializer;
    private Func`2<IFlowCaptureOperation, bool> _getIsLValueFlowCapture;
    [NullableAttribute("2")]
private AnalysisEntity _interproceduralThisOrMeInstanceForCaller;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableStack`1<IOperation> _interproceduralCallStack;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IOperation, AnalysisEntity> _interproceduralGetAnalysisEntityForFlowCapture;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ISymbol, ImmutableStack`1<IOperation>> _getInterproceduralCallStackForOwningSymbol;
    [CompilerGeneratedAttribute]
private AnalysisEntity <ThisOrMeInstance>k__BackingField;
    public AnalysisEntity ThisOrMeInstance { get; }
    internal AnalysisEntityFactory(ControlFlowGraph controlFlowGraph, WellKnownTypeProvider wellKnownTypeProvider, Func`2<IOperation, PointsToAbstractValue> getPointsToAbstractValue, Func`1<bool> getIsInsideAnonymousObjectInitializer, Func`2<IFlowCaptureOperation, bool> getIsLValueFlowCapture, INamedTypeSymbol containingTypeSymbol, AnalysisEntity interproceduralInvocationInstance, AnalysisEntity interproceduralThisOrMeInstanceForCaller, ImmutableStack`1<IOperation> interproceduralCallStack, ImmutableDictionary`2<ISymbol, PointsToAbstractValue> interproceduralCapturedVariablesMap, Func`2<IOperation, AnalysisEntity> interproceduralGetAnalysisEntityForFlowCapture, Func`2<ISymbol, ImmutableStack`1<IOperation>> getInterproceduralCallStackForOwningSymbol);
    [CompilerGeneratedAttribute]
public AnalysisEntity get_ThisOrMeInstance();
    [NullableContextAttribute("0")]
private static ImmutableArray`1<AbstractIndex> CreateAbstractIndices(ImmutableArray`1<T> indices);
    private static AbstractIndex CreateAbstractIndex(IOperation operation);
    public bool TryCreate(IOperation operation, AnalysisEntity& analysisEntity);
    private static void GetSymbolAndIndicesForMemberReference(IMemberReferenceOperation memberReference, ISymbol& symbol, ImmutableArray`1& indices);
    public bool TryCreateForSymbolDeclaration(ISymbol symbol, AnalysisEntity& analysisEntity);
    public bool TryCreateForTupleElements(ITupleOperation tupleOperation, ImmutableArray`1& elementEntities);
    public bool TryCreateForArrayElementInitializer(IArrayCreationOperation arrayCreation, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol elementType, AnalysisEntity& analysisEntity);
    public bool TryGetForFlowCapture(CaptureId captureId, AnalysisEntity& analysisEntity);
    public bool TryGetCopyValueForFlowCapture(CaptureId captureId, CopyAbstractValue& copyValue);
    public bool TryGetForInterproceduralAnalysis(IOperation operation, AnalysisEntity& analysisEntity);
    private AnalysisEntity GetOrCreateForFlowCapture(CaptureId captureId, ITypeSymbol type, IOperation flowCaptureOrReference, bool isLValueFlowCapture);
    [NullableContextAttribute("2")]
private bool TryCreate(ISymbol symbol, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol type, IOperation instance, AnalysisEntity& analysisEntity);
    [NullableContextAttribute("2")]
private PointsToAbstractValue EnsureLocation(PointsToAbstractValue instanceLocation, ISymbol symbol, AnalysisEntity parent);
    [NullableContextAttribute("2")]
private AnalysisEntity Create(ISymbol symbol, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol type, PointsToAbstractValue instanceLocation, AnalysisEntity parent, AnalysisEntity entityForInstanceLocation);
    public AnalysisEntity CreateWithNewInstanceRoot(AnalysisEntity analysisEntity, AnalysisEntity newRootInstance);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityMapAbstractDomain`1 : MapAbstractDomain`2<AnalysisEntity, TValue> {
    private static Func`2<AnalysisEntity, bool> s_defaultIsTrackedEntity;
    private static Func`2<PointsToAbstractValue, bool> s_defaultIsTrackedPointsToValue;
    private Func`2<AnalysisEntity, bool> _isTrackedEntity;
    private Func`2<PointsToAbstractValue, bool> _isTrackedPointsToValue;
    private protected AnalysisEntityMapAbstractDomain`1(AbstractValueDomain`1<TValue> valueDomain, Func`2<AnalysisEntity, bool> isTrackedEntity, Func`2<PointsToAbstractValue, bool> isTrackedPointsToValue);
    protected AnalysisEntityMapAbstractDomain`1(AbstractValueDomain`1<TValue> valueDomain, PointsToAnalysisResult pointsToAnalysisResult);
    private static AnalysisEntityMapAbstractDomain`1();
    protected abstract virtual TValue GetDefaultValue(AnalysisEntity analysisEntity);
    protected abstract virtual bool CanSkipNewEntry(AnalysisEntity analysisEntity, TValue value);
    protected virtual void OnNewMergedValue(TValue value);
    private bool CanSkipNewEntity(AnalysisEntity analysisEntity);
    protected abstract virtual void AssertValidEntryForMergedMap(AnalysisEntity analysisEntity, TValue value);
    protected virtual void AssertValidAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, TValue> map);
    public virtual DictionaryAnalysisData`2<AnalysisEntity, TValue> Merge(DictionaryAnalysisData`2<AnalysisEntity, TValue> map1, DictionaryAnalysisData`2<AnalysisEntity, TValue> map2);
    [CompilerGeneratedAttribute]
internal static bool <Merge>g__IsAnalysisEntityForFieldOrProperty|12_1(AnalysisEntity entity);
    [CompilerGeneratedAttribute]
private TValue <Merge>g__GetMergedValueForEntityPresentInOneMap|12_2(AnalysisEntity key, TValue value, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private TValue <Merge>g__GetMergedValue|12_3(ArrayBuilder`1<TValue> values, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private TValue <Merge>g__GetMergedValueCore|12_5(TValue value1, TValue value2, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private void <Merge>g__AddNewEntryToResultMap|12_4(AnalysisEntity key, TValue value, bool isNewKey, <>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ArgumentInfo`1 : CacheBasedEquatable`1<ArgumentInfo`1<TAbstractAnalysisValue>> {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AnalysisEntity <AnalysisEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAbstractValue <InstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private TAbstractAnalysisValue <Value>k__BackingField;
    public IOperation Operation { get; }
    [NullableAttribute("2")]
public AnalysisEntity AnalysisEntity { get; }
    public PointsToAbstractValue InstanceLocation { get; }
    public TAbstractAnalysisValue Value { get; }
    public ArgumentInfo`1(IOperation operation, AnalysisEntity analysisEntity, PointsToAbstractValue instanceLocation, TAbstractAnalysisValue value);
    [CompilerGeneratedAttribute]
public IOperation get_Operation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AnalysisEntity get_AnalysisEntity();
    [CompilerGeneratedAttribute]
public PointsToAbstractValue get_InstanceLocation();
    [CompilerGeneratedAttribute]
public TAbstractAnalysisValue get_Value();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<ArgumentInfo`1<TAbstractAnalysisValue>> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CacheBasedEquatable`1 : object {
    private int _lazyHashCode;
    private int GetOrComputeHashCode();
    protected abstract virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected abstract virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<T> obj);
    public sealed virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(T other);
    public static bool op_Equality(CacheBasedEquatable`1<T> value1, CacheBasedEquatable`1<T> value2);
    public static bool op_Inequality(CacheBasedEquatable`1<T> value1, CacheBasedEquatable`1<T> value2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ConversionInference : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsTryCast>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysSucceed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysFail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnboxing>k__BackingField;
    public bool IsTryCast { get; public set; }
    public bool AlwaysSucceed { get; public set; }
    public bool AlwaysFail { get; public set; }
    public bool IsBoxing { get; public set; }
    public bool IsUnboxing { get; public set; }
    public static ConversionInference Create(IConversionOperation operation);
    public static ConversionInference Create(IIsPatternOperation operation);
    [NullableContextAttribute("2")]
public static ConversionInference Create(ITypeSymbol targetType, ITypeSymbol sourceType, bool isTryCast);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsTryCast();
    [CompilerGeneratedAttribute]
public void set_IsTryCast(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AlwaysSucceed();
    [CompilerGeneratedAttribute]
public void set_AlwaysSucceed(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AlwaysFail();
    [CompilerGeneratedAttribute]
public void set_AlwaysFail(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsBoxing();
    [CompilerGeneratedAttribute]
public void set_IsBoxing(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsUnboxing();
    [CompilerGeneratedAttribute]
public void set_IsUnboxing(bool value);
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(ConversionInference other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public static bool op_Equality(ConversionInference left, ConversionInference right);
    public static bool op_Inequality(ConversionInference left, ConversionInference right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.AddressSharedEntitiesProvider`4 : object {
    private Builder<AnalysisEntity, CopyAbstractValue> _addressSharedEntitiesBuilder;
    public AddressSharedEntitiesProvider`4(TAnalysisContext analysisContext);
    public void SetAddressSharedEntities(ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> addressSharedEntities);
    public void UpdateAddressSharedEntitiesForParameter(IParameterSymbol parameter, AnalysisEntity analysisEntity, ArgumentInfo`1<TAbstractAnalysisValue> assignedValue);
    public CopyAbstractValue GetDefaultCopyValue(AnalysisEntity analysisEntity);
    public CopyAbstractValue TryGetAddressSharedCopyValue(AnalysisEntity analysisEntity);
    public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> GetAddressedSharedEntityMap();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<AnalysisEntity> <UpdateAddressSharedEntitiesForParameter>g__ComputeAddressSharedEntities|3_0(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <UpdateAddressSharedEntitiesForParameter>g__AddIfHasKnownInstanceLocation|3_1(AnalysisEntity entity, PooledHashSet`1<AnalysisEntity> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue : CacheBasedEquatable`1<CopyAbstractValue> {
    [CompilerGeneratedAttribute]
private static CopyAbstractValue <NotApplicable>k__BackingField;
    [CompilerGeneratedAttribute]
private static CopyAbstractValue <Invalid>k__BackingField;
    [CompilerGeneratedAttribute]
private static CopyAbstractValue <Unknown>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<AnalysisEntity> <AnalysisEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyAbstractValueKind <Kind>k__BackingField;
    public static CopyAbstractValue NotApplicable { get; }
    public static CopyAbstractValue Invalid { get; }
    public static CopyAbstractValue Unknown { get; }
    public ImmutableHashSet`1<AnalysisEntity> AnalysisEntities { get; }
    public CopyAbstractValueKind Kind { get; }
    internal CopyAbstractValue(ImmutableHashSet`1<AnalysisEntity> analysisEntities, CopyAbstractValueKind kind);
    private CopyAbstractValue(CopyAbstractValueKind kind);
    internal CopyAbstractValue(AnalysisEntity analysisEntity);
    internal CopyAbstractValue(ImmutableHashSet`1<AnalysisEntity> analysisEntities, bool isReferenceCopy);
    private static CopyAbstractValue();
    [CompilerGeneratedAttribute]
public static CopyAbstractValue get_NotApplicable();
    [CompilerGeneratedAttribute]
public static CopyAbstractValue get_Invalid();
    [CompilerGeneratedAttribute]
public static CopyAbstractValue get_Unknown();
    internal CopyAbstractValue WithEntityRemoved(AnalysisEntity entityToRemove);
    internal CopyAbstractValue WithEntitiesRemoved(IEnumerable`1<AnalysisEntity> entitiesToRemove);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<AnalysisEntity> get_AnalysisEntities();
    [CompilerGeneratedAttribute]
public CopyAbstractValueKind get_Kind();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<CopyAbstractValue> obj);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKind : Enum {
    public int value__;
    public static CopyAbstractValueKind NotApplicable;
    public static CopyAbstractValueKind KnownReferenceCopy;
    public static CopyAbstractValueKind KnownValueCopy;
    public static CopyAbstractValueKind Unknown;
    public static CopyAbstractValueKind Invalid;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKindExtensions : object {
    [ExtensionAttribute]
public static bool IsKnown(CopyAbstractValueKind kind);
    [ExtensionAttribute]
public static CopyAbstractValueKind MergeIfBothKnown(CopyAbstractValueKind kind, CopyAbstractValueKind kindToMerge);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis : ForwardDataFlowAnalysis`5<CopyAnalysisData, CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>, CopyBlockAnalysisResult, CopyAbstractValue> {
    internal static AbstractValueDomain`1<CopyAbstractValue> ValueDomainInstance;
    private CopyAnalysis(CopyDataFlowOperationVisitor operationVisitor);
    private static CopyAnalysis();
    public static DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, bool pessimisticAnalysis, PointsToAnalysisKind pointsToAnalysisKind, bool exceptionPathsAnalysis);
    private static DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> TryGetOrComputeResultForAnalysisContext(CopyAnalysisContext analysisContext);
    protected virtual DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> ToResult(CopyAnalysisContext analysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> dataFlowAnalysisResult);
    protected virtual CopyBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, CopyAnalysisData blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisContext : AbstractDataFlowAnalysisContext`4<CopyAnalysisData, CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>, CopyAbstractValue> {
    private CopyAnalysisContext(AbstractValueDomain`1<CopyAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, PointsToAnalysisResult pointsToAnalysisResult, Func`2<CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<CopyAnalysisData, CopyAnalysisContext, CopyAbstractValue> interproceduralAnalysisData, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    internal static CopyAnalysisContext Create(AbstractValueDomain`1<CopyAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, PointsToAnalysisResult pointsToAnalysisResult, Func`2<CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>> tryGetOrComputeAnalysisResult, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    public virtual CopyAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<CopyAnalysisData, CopyAnalysisContext, CopyAbstractValue> interproceduralAnalysisData);
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<CopyAnalysisData, CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>, CopyAbstractValue> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisData : AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> {
    protected AbstractValueDomain`1<CopyAbstractValue> ValueDomain { get; }
    internal CopyAnalysisData(IDictionary`2<AnalysisEntity, CopyAbstractValue> fromData);
    private CopyAnalysisData(CopyAnalysisData fromData);
    private CopyAnalysisData(CopyAnalysisData data1, CopyAnalysisData data2, MapAbstractDomain`2<AnalysisEntity, CopyAbstractValue> coreDataAnalysisDomain);
    protected virtual AbstractValueDomain`1<CopyAbstractValue> get_ValueDomain();
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> Clone();
    public virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> other, MapAbstractDomain`2<AnalysisEntity, CopyAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> data, MapAbstractDomain`2<AnalysisEntity, CopyAbstractValue> coreDataAnalysisDomain);
    internal void SetAbstactValueForEntities(CopyAbstractValue copyValue, AnalysisEntity entityBeingAssigned);
    public virtual void SetAbstractValue(AnalysisEntity key, CopyAbstractValue value);
    protected virtual void RemoveEntryInPredicatedData(AnalysisEntity key, DictionaryAnalysisData`2<AnalysisEntity, CopyAbstractValue> predicatedData);
    protected virtual void ApplyPredicatedData(DictionaryAnalysisData`2<AnalysisEntity, CopyAbstractValue> coreAnalysisData, DictionaryAnalysisData`2<AnalysisEntity, CopyAbstractValue> predicatedData);
    public virtual void Reset(Func`3<AnalysisEntity, CopyAbstractValue, CopyAbstractValue> getResetValue);
    [ConditionalAttribute("DEBUG")]
internal void AssertValidCopyAnalysisData(Func`2<AnalysisEntity, CopyAbstractValue> tryGetDefaultCopyValue, bool initializingParameters);
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidCopyAnalysisData(IDictionary`2<AnalysisEntity, CopyAbstractValue> map, Func`2<AnalysisEntity, CopyAbstractValue> tryGetDefaultCopyValue, bool initializingParameters);
    [ConditionalAttribute("DEBUG")]
private static void AssertValidCopyAnalysisEntity(AnalysisEntity analysisEntity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReachable>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> Data { get; }
    public bool IsReachable { get; }
    internal CopyBlockAnalysisResult(BasicBlock basicBlock, CopyAnalysisData blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysis`5 : object {
    private static BoundedCache`2<IOperation, SingleThreadedConcurrentDictionary`2<TAnalysisContext, TAnalysisResult>> s_resultCache;
    [CompilerGeneratedAttribute]
private AbstractAnalysisDomain`1<TAnalysisData> <AnalysisDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> <OperationVisitor>k__BackingField;
    protected AbstractAnalysisDomain`1<TAnalysisData> AnalysisDomain { get; }
    protected DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> OperationVisitor { get; }
    protected DataFlowAnalysis`5(AbstractAnalysisDomain`1<TAnalysisData> analysisDomain, DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> operationVisitor);
    private static DataFlowAnalysis`5();
    [CompilerGeneratedAttribute]
protected AbstractAnalysisDomain`1<TAnalysisData> get_AnalysisDomain();
    [CompilerGeneratedAttribute]
protected DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> get_OperationVisitor();
    protected TAnalysisResult TryGetOrComputeResultCore(TAnalysisContext analysisContext, bool cacheResult);
    private TAnalysisResult Run(TAnalysisContext analysisContext);
    private void RunCore(ControlFlowGraph cfg, PooledSortedSet`1<int> worklist, PooledSortedSet`1<int> pendingBlocksNeedingAtLeastOnePass, TAnalysisData initialAnalysisData, DataFlowAnalysisResultBuilder`1<TAnalysisData> resultBuilder, PooledHashSet`1<BasicBlock> uniqueSuccessors, PooledDictionary`2<int, List`1<BranchWithInfo>> finallyBlockSuccessorsMap, PooledDictionary`2<ControlFlowRegion, TAnalysisData> catchBlockInputDataMap, PooledDictionary`2<int, TAnalysisData> inputDataFromInfeasibleBranchesMap, PooledDictionary`2<int, Nullable`1<ValueTuple`2<int, ControlFlowConditionKind>>> blockToUniqueInputFlowMap, PooledDictionary`2<int, int> loopRangeMap, bool exceptionPathsAnalysisPostPass);
    private TAnalysisData GetClonedAnalysisDataOrEmptyData(TAnalysisData initialAnalysisData);
    public static TAnalysisData Flow(DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> operationVisitor, BasicBlock block, TAnalysisData data);
    public static TAnalysisData FlowBranch(DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> operationVisitor, ControlFlowBranch branch, TAnalysisData data);
    protected abstract virtual TAnalysisResult ToResult(TAnalysisContext analysisContext, DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> dataFlowAnalysisResult);
    protected abstract virtual TBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, TAnalysisData blockAnalysisData);
    private void UpdateInput(DataFlowAnalysisResultBuilder`1<TAnalysisData> builder, BasicBlock block, TAnalysisData newInput);
    private void CloneAndUpdateOutputIfEntryOrExitBlock(DataFlowAnalysisResultBuilder`1<TAnalysisData> builder, BasicBlock block, TAnalysisData newOutput);
    private static bool ComputeLoopRangeMap(ControlFlowGraph cfg, PooledDictionary`2<int, int> loopRangeMap);
    [CompilerGeneratedAttribute]
internal static ControlFlowRegion <RunCore>g__TryGetReachableCatchRegionStartingHandler|10_1(ControlFlowRegion tryAndCatchRegion, BasicBlock sourceBlock);
    [CompilerGeneratedAttribute]
internal static ControlFlowRegion <RunCore>g__GetEnclosingTryAndCatchRegionIfStartsHandler|10_5(BasicBlock block);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <ComputeLoopRangeMap>g__HandleBranch|18_0(ControlFlowBranch branch, <>c__DisplayClass18_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResult`2 : object {
    private ImmutableDictionary`2<BasicBlock, TBlockAnalysisResult> _basicBlockStateMap;
    private ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> _operationStateMap;
    private ImmutableDictionary`2<IOperation, PredicateValueKind> _predicateValueKindMap;
    private ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> _interproceduralResultsMap;
    private ImmutableDictionary`2<IMethodSymbol, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> _standaloneLocalFunctionAnalysisResultsMap;
    private TAbstractAnalysisValue _defaultUnknownValue;
    [NullableAttribute("2")]
private object _analysisDataForUnhandledThrowOperations;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> <ReturnValueAndPredicateKind>k__BackingField;
    [CompilerGeneratedAttribute]
private TBlockAnalysisResult <EntryBlockOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private TBlockAnalysisResult <ExitBlockOutput>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TBlockAnalysisResult <ExceptionPathsExitBlockOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaAndLocalFunctionAnalysisInfo <LambdaAndLocalFunctionAnalysisInfo>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TBlockAnalysisResult <MergedStateForUnhandledThrowOperations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> <TaskWrappedValuesMap>k__BackingField;
    public TBlockAnalysisResult Item { get; }
    public TAbstractAnalysisValue Item { get; }
    public TAbstractAnalysisValue Item { get; }
    public ControlFlowGraph ControlFlowGraph { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> ReturnValueAndPredicateKind { get; }
    public TBlockAnalysisResult EntryBlockOutput { get; }
    public TBlockAnalysisResult ExitBlockOutput { get; }
    [NullableAttribute("2")]
public TBlockAnalysisResult ExceptionPathsExitBlockOutput { get; }
    public LambdaAndLocalFunctionAnalysisInfo LambdaAndLocalFunctionAnalysisInfo { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult<TAbstractAnalysisValue>.AnalysisDataForUnhandledThrowOperations { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult<TAbstractAnalysisValue>.TaskWrappedValuesMap { get; }
    [NullableAttribute("2")]
public TBlockAnalysisResult MergedStateForUnhandledThrowOperations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> TaskWrappedValuesMap { get; }
    internal DataFlowAnalysisResult`2(ImmutableDictionary`2<BasicBlock, TBlockAnalysisResult> basicBlockStateMap, ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> operationStateMap, ImmutableDictionary`2<IOperation, PredicateValueKind> predicateValueKindMap, Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> returnValueAndPredicateKind, ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> interproceduralResultsMap, ImmutableDictionary`2<IMethodSymbol, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> standaloneLocalFunctionAnalysisResultsMap, LambdaAndLocalFunctionAnalysisInfo lambdaAndLocalFunctionAnalysisInfo, TBlockAnalysisResult entryBlockOutput, TBlockAnalysisResult exitBlockOutput, TBlockAnalysisResult exceptionPathsExitBlockOutput, TBlockAnalysisResult mergedStateForUnhandledThrowOperations, object analysisDataForUnhandledThrowOperations, Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> taskWrappedValuesMap, ControlFlowGraph cfg, TAbstractAnalysisValue defaultUnknownValue);
    protected DataFlowAnalysisResult`2(DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> other);
    internal DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> With(TBlockAnalysisResult mergedStateForUnhandledThrowOperationsOpt, object analysisDataForUnhandledThrowOperations);
    internal DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> With(ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> operationStateMap);
    public TBlockAnalysisResult get_Item(BasicBlock block);
    public TAbstractAnalysisValue get_Item(IOperation operation);
    public TAbstractAnalysisValue get_Item(OperationKind operationKind, SyntaxNode syntax);
    internal DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> TryGetInterproceduralResult(IOperation operation);
    internal DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> TryGetStandaloneLocalFunctionAnalysisResult(IMethodSymbol localFunction);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResult`2/<TryGetLambdaOrLocalFunctionResults>d__19")]
internal IEnumerable`1<DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue>> TryGetLambdaOrLocalFunctionResults(IOperation lambdaOrLocalFunctionOperation);
    [CompilerGeneratedAttribute]
public sealed virtual ControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> get_ReturnValueAndPredicateKind();
    [CompilerGeneratedAttribute]
public TBlockAnalysisResult get_EntryBlockOutput();
    [CompilerGeneratedAttribute]
public TBlockAnalysisResult get_ExitBlockOutput();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TBlockAnalysisResult get_ExceptionPathsExitBlockOutput();
    [CompilerGeneratedAttribute]
public sealed virtual LambdaAndLocalFunctionAnalysisInfo get_LambdaAndLocalFunctionAnalysisInfo();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult<TAbstractAnalysisValue>.get_AnalysisDataForUnhandledThrowOperations();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult<TAbstractAnalysisValue>.get_TaskWrappedValuesMap();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TBlockAnalysisResult get_MergedStateForUnhandledThrowOperations();
    public PredicateValueKind GetPredicateKind(IOperation operation);
    [CompilerGeneratedAttribute]
internal Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> get_TaskWrappedValuesMap();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResultBuilder`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledDictionary`2<BasicBlock, TAnalysisData> _info;
    [CompilerGeneratedAttribute]
private TAnalysisData <EntryBlockOutputData>k__BackingField;
    [CompilerGeneratedAttribute]
private TAnalysisData <ExitBlockOutputData>k__BackingField;
    public TAnalysisData Item { get; }
    public TAnalysisData EntryBlockOutputData { get; public set; }
    public TAnalysisData ExitBlockOutputData { get; public set; }
    [NullableContextAttribute("1")]
public TAnalysisData get_Item(BasicBlock block);
    [CompilerGeneratedAttribute]
public TAnalysisData get_EntryBlockOutputData();
    [CompilerGeneratedAttribute]
public void set_EntryBlockOutputData(TAnalysisData value);
    [CompilerGeneratedAttribute]
public TAnalysisData get_ExitBlockOutputData();
    [CompilerGeneratedAttribute]
public void set_ExitBlockOutputData(TAnalysisData value);
    [NullableContextAttribute("1")]
internal void Add(BasicBlock block);
    [NullableContextAttribute("1")]
internal void Update(BasicBlock block, TAnalysisData newData);
    [NullableContextAttribute("1")]
public DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> ToResult(Func`3<BasicBlock, TAnalysisData, TBlockAnalysisResult> getBlockResult, ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> stateMap, ImmutableDictionary`2<IOperation, PredicateValueKind> predicateValueKindMap, Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> returnValueAndPredicateKind, ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> interproceduralResultsMap, ImmutableDictionary`2<IMethodSymbol, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> standaloneLocalFunctionAnalysisResultsMap, LambdaAndLocalFunctionAnalysisInfo lambdaAndLocalFunctionAnalysisInfo, TAnalysisData entryBlockOutputData, TAnalysisData exitBlockData, TAnalysisData exceptionPathsExitBlockData, TAnalysisData mergedDataForUnhandledThrowOperations, Dictionary`2<ThrownExceptionInfo, TAnalysisData> analysisDataForUnhandledThrowOperations, Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> taskWrappedValuesMap, ControlFlowGraph cfg, TAbstractAnalysisValue defaultUnknownValue);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4 : OperationVisitor`2<object, TAbstractAnalysisValue> {
    private static DiagnosticDescriptor s_dummyDataflowAnalysisDescriptor;
    private ImmutableHashSet`1<CaptureId> _lValueFlowCaptures;
    private Builder<IOperation, TAbstractAnalysisValue> _valueCacheBuilder;
    private Builder<IOperation, PredicateValueKind> _predicateValueKindCacheBuilder;
    private HashSet`1<IArgumentOperation> _pendingArgumentsToReset;
    private List`1<IArgumentOperation> _pendingArgumentsToPostProcess;
    private HashSet`1<IOperation> _visitedFlowBranchConditions;
    private HashSet`1<IFlowAnonymousFunctionOperation> _visitedLambdas;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<IOperation> _returnValueOperations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<IParameterSymbol, AnalysisEntity> _lazyParameterEntities;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableHashSet`1<IMethodSymbol> _lazyContractCheckMethods;
    [NullableAttribute("2")]
private TAnalysisData _currentAnalysisData;
    [NullableAttribute("2")]
private BasicBlock _currentBasicBlock;
    private int _recursionDepth;
    private Builder<IMethodSymbol> _escapedLocalFunctions;
    private Builder<IMethodSymbol> _analyzedLocalFunctions;
    private Builder<IFlowAnonymousFunctionOperation> _escapedLambdas;
    private Builder<IFlowAnonymousFunctionOperation> _analyzedLambdas;
    private AddressSharedEntitiesProvider`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> _addressSharedEntitiesProvider;
    private Stack`1<IOperation> _interproceduralCallStack;
    private Builder<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> _interproceduralResultsBuilder;
    private Builder<IMethodSymbol, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> _standaloneLocalFunctionAnalysisResultsBuilder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IMethodSymbol, ControlFlowGraph> _interproceduralMethodToCfgMap;
    [CompilerGeneratedAttribute]
private bool <HasPointsToAnalysisResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompletePointsToAnalysisResult>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<ThrownExceptionInfo, TAnalysisData> <AnalysisDataForUnhandledThrowOperations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> <TaskWrappedValuesMap>k__BackingField;
    [CompilerGeneratedAttribute]
private TAnalysisContext <DataFlowAnalysisContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExecutingExceptionPathsAnalysisPostPass>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowConditionKind <FlowBranchConditionKind>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAbstractValue <ThisOrMePointsToAbstractValue>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalysisEntityFactory <AnalysisEntityFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInsideAnonymousObjectInitializer>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<BasicBlock, ThrownExceptionInfo> _exceptionPathsThrownExceptionInfoMap;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ExceptionNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ContractNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <IDisposableNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <IAsyncDisposableNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ConfiguredAsyncDisposable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ConfiguredValueTaskAwaitable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <TaskNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <TaskAsyncEnumerableExtensions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <MemoryStreamNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ValueTaskNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <GenericTaskNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <MonitorNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <InterlockedNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <SerializationInfoNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <StreamingContextNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <GenericIEquatableNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <StringReaderType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<INamedTypeSymbol> <CollectionNamedTypes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IMethodSymbol <DebugAssertMethod>k__BackingField;
    private InterproceduralAnalysisKind InterproceduralAnalysisKind { get; }
    private UInt32 MaxInterproceduralMethodCallChain { get; }
    private UInt32 MaxInterproceduralLambdaOrLocalFunctionCallChain { get; }
    protected bool HasPointsToAnalysisResult { get; }
    protected bool HasCompletePointsToAnalysisResult { get; }
    internal bool IsPointsToAnalysis { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<ThrownExceptionInfo, TAnalysisData> AnalysisDataForUnhandledThrowOperations { get; private set; }
    public ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> InterproceduralResultsMap { get; }
    public ImmutableDictionary`2<IMethodSymbol, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> StandaloneLocalFunctionAnalysisResultsMap { get; }
    internal LambdaAndLocalFunctionAnalysisInfo LambdaAndLocalFunctionAnalysisInfo { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> TaskWrappedValuesMap { get; private set; }
    protected TAnalysisContext DataFlowAnalysisContext { get; }
    public AbstractValueDomain`1<TAbstractAnalysisValue> ValueDomain { get; }
    protected ISymbol OwningSymbol { get; }
    protected WellKnownTypeProvider WellKnownTypeProvider { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Func`2<TAnalysisContext, TAnalysisResult> TryGetOrComputeAnalysisResult { get; }
    internal bool ExecutingExceptionPathsAnalysisPostPass { get; internal set; }
    internal bool SkipExceptionPathsAnalysisPostPass { get; }
    protected TAnalysisData CurrentAnalysisData { get; private set; }
    protected BasicBlock CurrentBasicBlock { get; private set; }
    protected ControlFlowConditionKind FlowBranchConditionKind { get; private set; }
    protected PointsToAbstractValue ThisOrMePointsToAbstractValue { get; }
    protected AnalysisEntityFactory AnalysisEntityFactory { get; }
    protected bool PessimisticAnalysis { get; }
    protected bool PredicateAnalysis { get; }
    protected bool IsInsideAnonymousObjectInitializer { get; private set; }
    private ThrownExceptionInfo DefaultThrownExceptionInfo { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol ExceptionNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol ContractNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol IDisposableNamedType { get; }
    [NullableAttribute("2")]
private INamedTypeSymbol IAsyncDisposableNamedType { get; }
    [NullableAttribute("2")]
private INamedTypeSymbol ConfiguredAsyncDisposable { get; }
    [NullableAttribute("2")]
private INamedTypeSymbol ConfiguredValueTaskAwaitable { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol TaskNamedType { get; }
    [NullableAttribute("2")]
private INamedTypeSymbol TaskAsyncEnumerableExtensions { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol MemoryStreamNamedType { get; }
    [NullableAttribute("2")]
private INamedTypeSymbol ValueTaskNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol GenericTaskNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol MonitorNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol InterlockedNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol SerializationInfoNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol StreamingContextNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol GenericIEquatableNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol StringReaderType { get; }
    protected ImmutableHashSet`1<INamedTypeSymbol> CollectionNamedTypes { get; }
    [NullableAttribute("2")]
private IMethodSymbol DebugAssertMethod { get; }
    protected DataFlowOperationVisitor`4(TAnalysisContext analysisContext);
    private static DataFlowOperationVisitor`4();
    private InterproceduralAnalysisKind get_InterproceduralAnalysisKind();
    private UInt32 get_MaxInterproceduralMethodCallChain();
    private UInt32 get_MaxInterproceduralLambdaOrLocalFunctionCallChain();
    protected abstract virtual TAbstractAnalysisValue GetAbstractDefaultValue(ITypeSymbol type);
    protected virtual TAbstractAnalysisValue GetAbstractDefaultValueForCatchVariable(ICatchClauseOperation catchClause);
    protected abstract virtual bool HasAnyAbstractValue(TAnalysisData data);
    protected abstract virtual void SetValueForParameterOnEntry(IParameterSymbol parameter, AnalysisEntity analysisEntity, ArgumentInfo`1<TAbstractAnalysisValue> assignedValue);
    protected abstract virtual void EscapeValueForParameterOnExit(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected abstract virtual void ResetCurrentAnalysisData();
    [CompilerGeneratedAttribute]
protected bool get_HasPointsToAnalysisResult();
    [CompilerGeneratedAttribute]
protected bool get_HasCompletePointsToAnalysisResult();
    internal virtual bool get_IsPointsToAnalysis();
    [CompilerGeneratedAttribute]
internal Dictionary`2<ThrownExceptionInfo, TAnalysisData> get_AnalysisDataForUnhandledThrowOperations();
    [CompilerGeneratedAttribute]
private void set_AnalysisDataForUnhandledThrowOperations(Dictionary`2<ThrownExceptionInfo, TAnalysisData> value);
    public ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> get_InterproceduralResultsMap();
    public ImmutableDictionary`2<IMethodSymbol, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> get_StandaloneLocalFunctionAnalysisResultsMap();
    internal LambdaAndLocalFunctionAnalysisInfo get_LambdaAndLocalFunctionAnalysisInfo();
    [CompilerGeneratedAttribute]
internal Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> get_TaskWrappedValuesMap();
    [CompilerGeneratedAttribute]
private void set_TaskWrappedValuesMap(Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> value);
    [CompilerGeneratedAttribute]
protected TAnalysisContext get_DataFlowAnalysisContext();
    public AbstractValueDomain`1<TAbstractAnalysisValue> get_ValueDomain();
    protected ISymbol get_OwningSymbol();
    protected WellKnownTypeProvider get_WellKnownTypeProvider();
    protected Func`2<TAnalysisContext, TAnalysisResult> get_TryGetOrComputeAnalysisResult();
    [CompilerGeneratedAttribute]
internal bool get_ExecutingExceptionPathsAnalysisPostPass();
    [CompilerGeneratedAttribute]
internal void set_ExecutingExceptionPathsAnalysisPostPass(bool value);
    internal virtual bool get_SkipExceptionPathsAnalysisPostPass();
    protected TAnalysisData get_CurrentAnalysisData();
    private void set_CurrentAnalysisData(TAnalysisData value);
    protected BasicBlock get_CurrentBasicBlock();
    private void set_CurrentBasicBlock(BasicBlock value);
    [CompilerGeneratedAttribute]
protected ControlFlowConditionKind get_FlowBranchConditionKind();
    [CompilerGeneratedAttribute]
private void set_FlowBranchConditionKind(ControlFlowConditionKind value);
    [CompilerGeneratedAttribute]
protected PointsToAbstractValue get_ThisOrMePointsToAbstractValue();
    [CompilerGeneratedAttribute]
protected AnalysisEntityFactory get_AnalysisEntityFactory();
    protected bool get_PessimisticAnalysis();
    protected bool get_PredicateAnalysis();
    [CompilerGeneratedAttribute]
protected bool get_IsInsideAnonymousObjectInitializer();
    [CompilerGeneratedAttribute]
private void set_IsInsideAnonymousObjectInitializer(bool value);
    protected bool IsLValueFlowCapture(IFlowCaptureOperation flowCapture);
    protected bool IsLValueFlowCaptureReference(IFlowCaptureReferenceOperation flowCaptureReference);
    private ThrownExceptionInfo get_DefaultThrownExceptionInfo();
    protected CopyAbstractValue GetDefaultCopyValue(AnalysisEntity analysisEntity);
    protected CopyAbstractValue TryGetAddressSharedCopyValue(AnalysisEntity analysisEntity);
    public virtual Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> GetReturnValueAndPredicateKind();
    private static PointsToAbstractValue GetThisOrMeInstancePointsToValue(TAnalysisContext analysisContext);
    public virtual TAnalysisData Flow(IOperation statement, BasicBlock block, TAnalysisData input);
    [ConditionalAttribute("DEBUG")]
private void AfterVisitRoot(IOperation operation);
    public TAnalysisData OnStartBlockAnalysis(BasicBlock block, TAnalysisData input);
    public TAnalysisData OnEndBlockAnalysis(BasicBlock block, TAnalysisData analysisData);
    protected abstract virtual void UpdateValuesForAnalysisData(TAnalysisData targetAnalysisData);
    protected void UpdateValuesForAnalysisData(DictionaryAnalysisData`2<TKey, TAbstractAnalysisValue> targetAnalysisData, DictionaryAnalysisData`2<TKey, TAbstractAnalysisValue> newAnalysisData);
    protected abstract virtual void StopTrackingDataForParameter(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected virtual void StopTrackingDataForParameters(ImmutableDictionary`2<IParameterSymbol, AnalysisEntity> parameterEntities);
    private void OnStartEntryBlockAnalysis(BasicBlock entryBlock);
    private void OnStartExitBlockAnalysis(BasicBlock exitBlock);
    private void PerformStandaloneLambdaOrLocalFunctionAnalysisOnExit();
    private bool IsStandaloneAnalysisRequiredForLocalFunction(IMethodSymbol localFunction);
    private bool IsStandaloneAnalysisRequiredForLambda(IFlowAnonymousFunctionOperation lambda);
    private void OnEndExitBlockAnalysis(BasicBlock exitBlock);
    protected bool IsParameterEntityForCurrentMethod(AnalysisEntity analysisEntity);
    public virtual ValueTuple`2<TAnalysisData, bool> FlowBranch(BasicBlock fromBlock, BranchWithInfo branch, TAnalysisData input);
    private protected virtual TAbstractAnalysisValue GetAbstractValueForImplicitWrappingTaskCreation(IOperation returnValueOperation, TAbstractAnalysisValue returnValue, PointsToAbstractValue implicitTaskPointsToValue);
    [NullableContextAttribute("2")]
protected virtual void ProcessReturnValue(IOperation returnValue);
    private TAbstractAnalysisValue GetAbstractValueForReturnOperation(IOperation returnValueOperation, PointsToAbstractValue& implicitTaskPointsToValue);
    protected virtual void HandlePossibleThrowingOperation(IOperation operation);
    protected virtual TAnalysisData GetMergedAnalysisDataForPossibleThrowingOperation(TAnalysisData existingData, IOperation operation);
    public TAnalysisData OnLeavingRegions(IEnumerable`1<ILocalSymbol> leavingRegionLocals, IEnumerable`1<CaptureId> leavingRegionFlowCaptures, BasicBlock currentBasicBlock, TAnalysisData input);
    protected virtual void ProcessOutOfScopeLocalsAndFlowCaptures(IEnumerable`1<ILocalSymbol> locals, IEnumerable`1<CaptureId> flowCaptures);
    private bool IsContractCheckArgument(IArgumentOperation operation);
    private bool IsContractCheckMethod(IMethodSymbol method);
    private bool IsAnyDebugAssertMethod(IMethodSymbol method);
    protected bool IsAnyAssertMethod(IMethodSymbol method);
    internal ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> GetStateMap();
    internal ImmutableDictionary`2<IOperation, PredicateValueKind> GetPredicateValueKindMap();
    [NullableContextAttribute("2")]
public virtual TAnalysisData GetMergedDataForUnhandledThrowOperations();
    public TAbstractAnalysisValue GetCachedAbstractValue(IOperation operation);
    protected void CacheAbstractValue(IOperation operation, TAbstractAnalysisValue value);
    protected NullAbstractValue GetNullAbstractValue(IOperation operation);
    protected virtual CopyAbstractValue GetCopyAbstractValue(IOperation operation);
    protected virtual PointsToAbstractValue GetPointsToAbstractValue(IOperation operation);
    protected virtual ValueContentAbstractValue GetValueContentAbstractValue(IOperation operation);
    protected ImmutableHashSet`1<AbstractLocation> GetEscapedLocations(IOperation operation);
    protected ImmutableHashSet`1<AbstractLocation> GetEscapedLocations(AnalysisEntity parameterEntity);
    protected bool TryGetPointsToAbstractValueAtEntryBlockEnd(AnalysisEntity analysisEntity, PointsToAbstractValue& pointsToAbstractValue);
    protected bool TryGetNullAbstractValueAtCurrentBlockEntry(AnalysisEntity analysisEntity, NullAbstractValue& nullAbstractValue);
    protected bool TryGetMergedNullAbstractValueAtUnhandledThrowOperationsInGraph(AnalysisEntity analysisEntity, NullAbstractValue& nullAbstractValue);
    private protected void SetTaskWrappedValue(PointsToAbstractValue pointsToValueForTask, TAbstractAnalysisValue wrappedValue);
    private protected bool TryGetTaskWrappedValue(PointsToAbstractValue pointsToAbstractValue, TAbstractAnalysisValue& wrappedValue);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForReferenceOperation(IOperation operation, TAbstractAnalysisValue defaultValue);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForEscapedRefOrOutArgument(IArgumentOperation operation, TAbstractAnalysisValue defaultValue);
    internal bool TryInferConversion(IConversionOperation operation, ConversionInference& inference);
    internal bool TryInferConversion(IIsPatternOperation operation, ConversionInference& inference);
    private bool TryInferConversion(IOperation sourceOperand, ITypeSymbol targetType, bool isTryCast, IOperation operation, ConversionInference& inference);
    protected virtual void UpdateReachability(BasicBlock basicBlock, TAnalysisData analysisData, bool isReachable);
    protected virtual bool IsReachableBlockData(TAnalysisData analysisData);
    private bool GetBlockReachability(BasicBlock basicBlock);
    protected bool IsCurrentBlockReachable();
    private void PerformPredicateAnalysis(IOperation operation);
    private void PerformPredicateAnalysisCore(IOperation operation, TAnalysisData targetAnalysisData);
    protected virtual void SetPredicateValueKind(IOperation operation, TAnalysisData analysisData, PredicateValueKind predicateValueKind);
    protected virtual PredicateValueKind SetValueForComparisonOperator(IBinaryOperation operation, TAnalysisData targetAnalysisData);
    protected virtual PredicateValueKind SetValueForEqualsOrNotEqualsComparisonOperator(IOperation leftOperand, IOperation rightOperand, bool equals, bool isReferenceEquality, TAnalysisData targetAnalysisData);
    protected virtual PredicateValueKind SetValueForIsNullComparisonOperator(IOperation leftOperand, bool equals, TAnalysisData targetAnalysisData);
    [NullableContextAttribute("2")]
protected virtual void StartTrackingPredicatedData(AnalysisEntity predicatedEntity, TAnalysisData truePredicateData, TAnalysisData falsePredicateData);
    protected virtual void StopTrackingPredicatedData(AnalysisEntity predicatedEntity);
    private bool HasPredicatedDataForEntity(AnalysisEntity predicatedEntity);
    protected virtual bool HasPredicatedDataForEntity(TAnalysisData analysisData, AnalysisEntity predicatedEntity);
    protected virtual void TransferPredicatedData(AnalysisEntity fromEntity, AnalysisEntity toEntity);
    protected virtual PredicateValueKind ApplyPredicatedDataForEntity(TAnalysisData analysisData, AnalysisEntity predicatedEntity, bool trueData);
    [NullableContextAttribute("2")]
protected virtual void ProcessThrowValue(IOperation thrownValue);
    protected abstract virtual void SetAbstractValueForArrayElementInitializer(IArrayCreationOperation arrayCreation, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol elementType, IOperation initializer, TAbstractAnalysisValue value);
    protected abstract virtual void SetAbstractValueForAssignment(IOperation target, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue, bool mayBeAssignment);
    protected abstract virtual void SetAbstractValueForTupleElementAssignment(AnalysisEntity tupleElementEntity, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue);
    private void HandleFlowCaptureReferenceAssignment(IFlowCaptureReferenceOperation flowCaptureReference, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue);
    protected abstract virtual void ResetValueTypeInstanceAnalysisData(AnalysisEntity analysisEntity);
    protected abstract virtual void ResetReferenceTypeInstanceAnalysisData(PointsToAbstractValue pointsToAbstractValue);
    private void ResetValueTypeInstanceAnalysisData(IOperation operation);
    private void ResetReferenceTypeInstanceAnalysisData(IOperation operation);
    [NullableContextAttribute("2")]
private void ResetInstanceAnalysisData(IOperation operation);
    public TAnalysisData MergeAnalysisData(TAnalysisData value1, TAnalysisData value2, BasicBlock forBlock, bool forBackEdge);
    protected abstract virtual TAnalysisData MergeAnalysisData(TAnalysisData value1, TAnalysisData value2);
    protected virtual TAnalysisData MergeAnalysisData(TAnalysisData value1, TAnalysisData value2, BasicBlock forBlock);
    protected virtual TAnalysisData MergeAnalysisDataForBackEdge(TAnalysisData value1, TAnalysisData value2, BasicBlock forBlock);
    protected abstract virtual TAnalysisData GetClonedAnalysisData(TAnalysisData analysisData);
    protected TAnalysisData GetClonedCurrentAnalysisData();
    public abstract virtual TAnalysisData GetEmptyAnalysisData();
    protected abstract virtual TAnalysisData GetExitBlockOutputData(TAnalysisResult analysisResult);
    protected abstract virtual bool Equals(TAnalysisData value1, TAnalysisData value2);
    protected static bool EqualsHelper(IDictionary`2<TKey, TValue> dict1, IDictionary`2<TKey, TValue> dict2);
    protected abstract virtual void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(TAnalysisData dataAtException, ThrownExceptionInfo throwBranchWithExceptionType);
    protected virtual void AssertValidAnalysisData(TAnalysisData analysisData);
    protected void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(DictionaryAnalysisData`2<TKey, TAbstractAnalysisValue> coreDataAtException, DictionaryAnalysisData`2<TKey, TAbstractAnalysisValue> coreCurrentAnalysisData, Func`2<TKey, bool> predicate);
    protected virtual TAnalysisData GetInitialInterproceduralAnalysisData(IMethodSymbol invokedMethod, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> invocationInstance, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> thisOrMeInstanceForCaller, ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> argumentValuesMap, IDictionary`2<AnalysisEntity, PointsToAbstractValue> pointsToValues, IDictionary`2<AnalysisEntity, CopyAbstractValue> copyValues, IDictionary`2<AnalysisEntity, ValueContentAbstractValue> valueContentValues, bool isLambdaOrLocalFunction, bool hasParameterWithDelegateType);
    protected virtual void ApplyInterproceduralAnalysisResult(TAnalysisData resultData, bool isLambdaOrLocalFunction, bool hasDelegateTypeArgument, TAnalysisResult analysisResult);
    private void ApplyInterproceduralAnalysisDataForUnhandledThrowOperations(Dictionary`2<ThrownExceptionInfo, TAnalysisData> interproceduralUnhandledThrowOperationsData);
    protected bool TryGetInterproceduralAnalysisResult(IOperation operation, TAnalysisResult& analysisResult);
    private TAbstractAnalysisValue PerformInterproceduralAnalysis(Func`1<ControlFlowGraph> getCfg, IMethodSymbol invokedMethod, IOperation instanceReceiver, ImmutableArray`1<IArgumentOperation> arguments, IOperation originalOperation, TAbstractAnalysisValue defaultValue, bool isLambdaOrLocalFunction, Boolean& wasAnalyzed);
    private ImmutableDictionary`2<ISymbol, PointsToAbstractValue> GetCapturedVariablesMap(ControlFlowGraph cfg, IMethodSymbol invokedMethod, bool isLambdaOrLocalFunction);
    private void PerformStandaloneLocalFunctionInterproceduralAnalysis(IMethodSymbol localFunction);
    private void PerformStandaloneLambdaInterproceduralAnalysis(IFlowAnonymousFunctionOperation lambda);
    private InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> GetInterproceduralAnalysisDataForStandaloneLambdaOrLocalFunctionAnalysis(ControlFlowGraph cfg, IMethodSymbol invokedMethod);
    protected TAbstractAnalysisValue VisitArray(IEnumerable`1<IOperation> operations, object argument);
    [NullableContextAttribute("2")]
public virtual TAbstractAnalysisValue Visit(IOperation operation, object argument);
    private TAbstractAnalysisValue VisitCore(IOperation operation, object argument);
    public virtual TAbstractAnalysisValue DefaultVisit(IOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitSimpleAssignment(ISimpleAssignmentOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitCompoundAssignment(ICompoundAssignmentOperation operation, object argument);
    public virtual TAbstractAnalysisValue ComputeValueForCompoundAssignment(ICompoundAssignmentOperation operation, TAbstractAnalysisValue targetValue, TAbstractAnalysisValue assignedValue, ITypeSymbol targetType, ITypeSymbol assignedValueType);
    public virtual TAbstractAnalysisValue VisitIncrementOrDecrement(IIncrementOrDecrementOperation operation, object argument);
    public virtual TAbstractAnalysisValue ComputeValueForIncrementOrDecrementOperation(IIncrementOrDecrementOperation operation, TAbstractAnalysisValue targetValue);
    public virtual TAbstractAnalysisValue VisitDeconstructionAssignment(IDeconstructionAssignmentOperation operation, object argument);
    protected virtual TAbstractAnalysisValue VisitAssignmentOperation(IAssignmentOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitArrayInitializer(IArrayInitializerOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitLocalReference(ILocalReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitParameterReference(IParameterReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitArrayElementReference(IArrayElementReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitDynamicMemberReference(IDynamicMemberReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitEventReference(IEventReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitFieldReference(IFieldReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitMethodReference(IMethodReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitPropertyReference(IPropertyReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitFlowCaptureReference(IFlowCaptureReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitFlowCapture(IFlowCaptureOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitDefaultValue(IDefaultValueOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitInterpolation(IInterpolationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitInterpolatedStringText(IInterpolatedStringTextOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitArgument(IArgumentOperation operation, object argument);
    protected virtual void PostProcessArgument(IArgumentOperation operation, bool isEscaped);
    private void PostProcessEscapedArgument(IArgumentOperation operation);
    public virtual TAbstractAnalysisValue VisitConstantPattern(IConstantPatternOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitParenthesized(IParenthesizedOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitTranslatedQuery(ITranslatedQueryOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitConversion(IConversionOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitObjectCreation(IObjectCreationOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitInvocation(IInvocationOperation operation, object argument);
    private TAbstractAnalysisValue VisitInvocation_NonLambdaOrDelegateOrLocalFunction(IInvocationOperation operation, object argument);
    private protected bool MarkEscapedLambdasAndLocalFunctions(PointsToAbstractValue pointsToAbstractValue);
    private bool ResolveLambdaOrDelegateOrLocalFunctionTargets(PointsToAbstractValue invocationTarget, PooledHashSet`1<ValueTuple`2<IMethodSymbol, IOperation>> methodTargetsOptBuilder, PooledHashSet`1<IFlowAnonymousFunctionOperation> lambdaTargets);
    private bool ResolveLambdaOrDelegateOrLocalFunctionTargets(IOperation operation, PooledHashSet`1<ValueTuple`2<IMethodSymbol, IOperation>> methodTargetsOptBuilder, PooledHashSet`1<IFlowAnonymousFunctionOperation> lambdaTargets);
    [NullableContextAttribute("2")]
private bool ResolveLambdaOrDelegateOrLocalFunctionTargetsCore(IOperation operation, PointsToAbstractValue invocationTarget, PooledHashSet`1<ValueTuple`2<IMethodSymbol, IOperation>> methodTargetsOptBuilder, PooledHashSet`1<IFlowAnonymousFunctionOperation> lambdaTargets);
    private TAbstractAnalysisValue VisitInvocation_LambdaOrDelegateOrLocalFunction(IInvocationOperation operation, object argument, ImmutableHashSet`1& resolvedMethodTargets);
    public virtual TAbstractAnalysisValue VisitInvocation_NonLambdaOrDelegateOrLocalFunction(IMethodSymbol method, IOperation visitedInstance, ImmutableArray`1<IArgumentOperation> visitedArguments, bool invokedAsDelegate, IOperation originalOperation, TAbstractAnalysisValue defaultValue);
    private ControlFlowGraph GetInterproceduralControlFlowGraph(IMethodSymbol method);
    private ImmutableStack`1<IOperation> GetInterproceduralCallStackForOwningSymbol(ISymbol forOwningSymbol);
    public virtual TAbstractAnalysisValue VisitInvocation_LocalFunction(IMethodSymbol localFunction, ImmutableArray`1<IArgumentOperation> visitedArguments, IOperation originalOperation, TAbstractAnalysisValue defaultValue);
    public virtual TAbstractAnalysisValue VisitInvocation_Lambda(IFlowAnonymousFunctionOperation lambda, ImmutableArray`1<IArgumentOperation> visitedArguments, IOperation originalOperation, TAbstractAnalysisValue defaultValue);
    public virtual TAbstractAnalysisValue VisitDelegateCreation(IDelegateCreationOperation operation, object argument);
    public virtual void HandleEnterLockOperation(IOperation lockedObject);
    private void ResetThisOrMeInstanceAnalysisData();
    public virtual TAbstractAnalysisValue VisitTuple(ITupleOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitUnaryOperatorCore(IUnaryOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitUnaryOperator(IUnaryOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitBinaryOperatorCore(IBinaryOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitBinaryOperator(IBinaryOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitIsNull(IIsNullOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitCaughtException(ICaughtExceptionOperation operation, object argument);
    [NullableContextAttribute("2")]
private void MergeAnalysisDataFromUnhandledThrowOperations(ITypeSymbol caughtExceptionType);
    public virtual TAbstractAnalysisValue VisitFlowAnonymousFunction(IFlowAnonymousFunctionOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitStaticLocalInitializationSemaphore(IStaticLocalInitializationSemaphoreOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitAnonymousObjectCreation(IAnonymousObjectCreationOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitReturn(IReturnOperation operation, object argument);
    public virtual TAbstractAnalysisValue GetAssignedValueForPattern(IIsPatternOperation operation, TAbstractAnalysisValue operandValue);
    public virtual TAbstractAnalysisValue VisitIsPattern(IIsPatternOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitAwait(IAwaitOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitUsing(IUsingOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitWhileLoop(IWhileLoopOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitForEachLoop(IForEachLoopOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitForLoop(IForLoopOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitForToLoop(IForToLoopOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitCoalesce(ICoalesceOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitConditional(IConditionalOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitConditionalAccess(IConditionalAccessOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitConditionalAccessInstance(IConditionalAccessInstanceOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitThrow(IThrowOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitVariableDeclaration(IVariableDeclarationOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitVariableDeclarationGroup(IVariableDeclarationGroupOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitVariableDeclarator(IVariableDeclaratorOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitTry(ITryOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitCatchClause(ICatchClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public virtual TAbstractAnalysisValue VisitLock(ILockOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitBranch(IBranchOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitLabeled(ILabeledOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitSwitch(ISwitchOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitSwitchCase(ISwitchCaseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitDefaultCaseClause(IDefaultCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitPatternCaseClause(IPatternCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitRangeCaseClause(IRangeCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitRelationalCaseClause(IRelationalCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitSingleValueCaseClause(ISingleValueCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitObjectOrCollectionInitializer(IObjectOrCollectionInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitMemberInitializer(IMemberInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitBlock(IBlockOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitVariableInitializer(IVariableInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitFieldInitializer(IFieldInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitParameterInitializer(IParameterInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitPropertyInitializer(IPropertyInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitEnd(IEndOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitEmpty(IEmptyOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitNameOf(INameOfOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitAnonymousFunction(IAnonymousFunctionOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitLocalFunction(ILocalFunctionOperation operation, object argument);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_ExceptionNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_ContractNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_IDisposableNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol get_IAsyncDisposableNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol get_ConfiguredAsyncDisposable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol get_ConfiguredValueTaskAwaitable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_TaskNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol get_TaskAsyncEnumerableExtensions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_MemoryStreamNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol get_ValueTaskNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_GenericTaskNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_MonitorNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_InterlockedNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_SerializationInfoNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_StreamingContextNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_GenericIEquatableNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_StringReaderType();
    [CompilerGeneratedAttribute]
protected ImmutableHashSet`1<INamedTypeSymbol> get_CollectionNamedTypes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private IMethodSymbol get_DebugAssertMethod();
    private ImmutableHashSet`1<INamedTypeSymbol> GetWellKnownCollectionTypes();
    [NullableContextAttribute("2")]
private protected bool IsDisposable(ITypeSymbol type);
    private protected DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__103_0();
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__HasDebugAssertSignature|103_1(IMethodSymbol method);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <FlowBranch>g__isConditionalBranchNeverTaken|123_0(<>c__DisplayClass123_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <FlowBranch>g__isPredicateAlwaysFalseForBranch|123_1(PredicateValueKind predicateValueKind, <>c__DisplayClass123_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryInferConversion>g__IsInterfaceOrTypeParameter|155_0(ITypeSymbol type);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <PerformPredicateAnalysis>g__IsRootOfCondition|160_0(<>c__DisplayClass160_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private AnalysisEntity <PerformPredicateAnalysis>g__GetPredicatedFlowCaptureEntity|160_1(<>c__DisplayClass160_0& );
    [CompilerGeneratedAttribute]
private bool <PerformPredicateAnalysisCore>g__IsOverrideOrImplementationOfEquatableEquals|161_0(IMethodSymbol methodSymbol);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <HandleFlowCaptureReferenceAssignment>g__HasUniqueCapturedEntity|176_0(<>c__DisplayClass176_0& );
    [CompilerGeneratedAttribute]
private void <ApplyInterproceduralAnalysisDataForUnhandledThrowOperations>g__ApplyInterproceduralAnalysisDataForUnhandledThrowOperation|197_0(ThrownExceptionInfo exceptionInfo, TAnalysisData analysisDataAtException);
    [CompilerGeneratedAttribute]
private TAbstractAnalysisValue <GetInterproceduralAnalysisDataForStandaloneLambdaOrLocalFunctionAnalysis>b__203_0(IOperation _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <VisitFlowCapture>g__PerformFlowCapturePredicateAnalysis|225_0(<>c__DisplayClass225_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <VisitInvocation>g__PostVisitInvocation|237_0(IMethodSymbol targetMethod, ImmutableArray`1<IArgumentOperation> arguments, <>c__DisplayClass237_0& );
    [CompilerGeneratedAttribute]
private void <VisitInvocation>g__ProcessInterlockedOperation|237_1(IMethodSymbol targetMethod, ImmutableArray`1<IArgumentOperation> arguments, INamedTypeSymbol interlockedType, <>c__DisplayClass237_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <ResolveLambdaOrDelegateOrLocalFunctionTargetsCore>g__AddMethodTarget|242_0(IMethodSymbol method, IOperation instance, <>c__DisplayClass242_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <ResolveLambdaOrDelegateOrLocalFunctionTargetsCore>g__AddLambdaTarget|242_1(IFlowAnonymousFunctionOperation lambda, <>c__DisplayClass242_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <ResolveLambdaOrDelegateOrLocalFunctionTargetsCore>g__HandleCreationOpt|242_2(IOperation creation, <>c__DisplayClass242_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <ResolveLambdaOrDelegateOrLocalFunctionTargetsCore>g__HandleDelegateCreationTarget|242_3(IDelegateCreationOperation delegateCreationOperation, <>c__DisplayClass242_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <MergeAnalysisDataFromUnhandledThrowOperations>g__ShouldHandlePendingThrow|259_0(ThrownExceptionInfo pendingThrow, <>c__DisplayClass259_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData`2 : AbstractAnalysisData {
    private PooledDictionary`2<TKey, TValue> _coreAnalysisData;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public DictionaryAnalysisData`2(IDictionary`2<TKey, TValue> initializer);
    public ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValue : CacheBasedEquatable`1<DisposeAbstractValue> {
    public static DisposeAbstractValue NotDisposable;
    public static DisposeAbstractValue Invalid;
    public static DisposeAbstractValue NotDisposed;
    public static DisposeAbstractValue Unknown;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IOperation> <DisposingOrEscapingOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private DisposeAbstractValueKind <Kind>k__BackingField;
    public ImmutableHashSet`1<IOperation> DisposingOrEscapingOperations { get; }
    public DisposeAbstractValueKind Kind { get; }
    private DisposeAbstractValue(DisposeAbstractValueKind kind);
    internal DisposeAbstractValue(ImmutableHashSet`1<IOperation> disposingOrEscapingOperations, DisposeAbstractValueKind kind);
    private static DisposeAbstractValue();
    internal DisposeAbstractValue WithNewDisposingOperation(IOperation disposingOperation);
    internal DisposeAbstractValue WithNewEscapingOperation(IOperation escapingOperation);
    [ConditionalAttribute("DEBUG")]
private static void VerifyArguments(ImmutableHashSet`1<IOperation> disposingOrEscapingOperations, DisposeAbstractValueKind kind);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IOperation> get_DisposingOrEscapingOperations();
    [CompilerGeneratedAttribute]
public DisposeAbstractValueKind get_Kind();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<DisposeAbstractValue> obj);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind : Enum {
    public int value__;
    public static DisposeAbstractValueKind NotDisposable;
    public static DisposeAbstractValueKind Invalid;
    public static DisposeAbstractValueKind NotDisposed;
    public static DisposeAbstractValueKind Escaped;
    public static DisposeAbstractValueKind NotDisposedOrEscaped;
    public static DisposeAbstractValueKind Disposed;
    public static DisposeAbstractValueKind MaybeDisposed;
    public static DisposeAbstractValueKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis : ForwardDataFlowAnalysis`5<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAnalysisResult, DisposeBlockAnalysisResult, DisposeAbstractValue> {
    private static bool PessimisticAnalysis;
    internal static MapAbstractDomain`2<AbstractLocation, DisposeAbstractValue> DisposeAnalysisDomainInstance;
    private DisposeAnalysis(MapAbstractDomain`2<AbstractLocation, DisposeAbstractValue> analysisDomain, DisposeDataFlowOperationVisitor operationVisitor);
    private static DisposeAnalysis();
    public static DisposeAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, ImmutableHashSet`1<INamedTypeSymbol> disposeOwnershipTransferLikelyTypes, PointsToAnalysisKind defaultPointsToAnalysisKind, bool trackInstanceFields, bool exceptionPathsAnalysis, PointsToAnalysisResult& pointsToAnalysisResult, InterproceduralAnalysisKind interproceduralAnalysisKind, bool performCopyAnalysisIfNotUserConfigured, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, bool defaultDisposeOwnershipTransferAtConstructor, bool defaultDisposeOwnershipTransferAtMethodCall);
    private static DisposeAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, ImmutableHashSet`1<INamedTypeSymbol> disposeOwnershipTransferLikelyTypes, bool disposeOwnershipTransferAtConstructor, bool disposeOwnershipTransferAtMethodCall, bool trackInstanceFields, bool exceptionPathsAnalysis, PointsToAnalysisKind pointsToAnalysisKind, bool performCopyAnalysis, Func`2<ITypeSymbol, bool> isDisposableTypeNotRequiringToBeDisposed, PointsToAnalysisResult& pointsToAnalysisResult);
    private static DisposeAnalysisResult TryGetOrComputeResultForAnalysisContext(DisposeAnalysisContext disposeAnalysisContext);
    protected virtual DisposeAnalysisResult ToResult(DisposeAnalysisContext analysisContext, DataFlowAnalysisResult`2<DisposeBlockAnalysisResult, DisposeAbstractValue> dataFlowAnalysisResult);
    protected virtual DisposeBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue> blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysisContext : AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAnalysisResult, DisposeAbstractValue> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<INamedTypeSymbol> <DisposeOwnershipTransferLikelyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisposeOwnershipTransferAtConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisposeOwnershipTransferAtMethodCall>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackInstanceFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ITypeSymbol, bool> <IsDisposableTypeNotRequiringToBeDisposed>k__BackingField;
    internal ImmutableHashSet`1<INamedTypeSymbol> DisposeOwnershipTransferLikelyTypes { get; }
    internal bool DisposeOwnershipTransferAtConstructor { get; }
    internal bool DisposeOwnershipTransferAtMethodCall { get; }
    internal bool TrackInstanceFields { get; }
    internal Func`2<ITypeSymbol, bool> IsDisposableTypeNotRequiringToBeDisposed { get; }
    private DisposeAnalysisContext(AbstractValueDomain`1<DisposeAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, PointsToAnalysisResult pointsToAnalysisResult, Func`2<DisposeAnalysisContext, DisposeAnalysisResult> tryGetOrComputeAnalysisResult, ImmutableHashSet`1<INamedTypeSymbol> disposeOwnershipTransferLikelyTypes, bool disposeOwnershipTransferAtConstructor, bool disposeOwnershipTransferAtMethodCall, bool trackInstanceFields, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAbstractValue> interproceduralAnalysisData, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, Func`2<ITypeSymbol, bool> isDisposableTypeNotRequiringToBeDisposed);
    internal static DisposeAnalysisContext Create(AbstractValueDomain`1<DisposeAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, bool pessimisticAnalysis, bool exceptionPathsAnalysis, PointsToAnalysisResult pointsToAnalysisResult, Func`2<DisposeAnalysisContext, DisposeAnalysisResult> tryGetOrComputeAnalysisResult, ImmutableHashSet`1<INamedTypeSymbol> disposeOwnershipTransferLikelyTypes, bool disposeOwnershipTransferAtConstructor, bool disposeOwnershipTransferAtMethodCall, bool trackInstanceFields, Func`2<ITypeSymbol, bool> isDisposableTypeNotRequiringToBeDisposed);
    public virtual DisposeAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAbstractValue> interproceduralAnalysisData);
    [CompilerGeneratedAttribute]
internal ImmutableHashSet`1<INamedTypeSymbol> get_DisposeOwnershipTransferLikelyTypes();
    [CompilerGeneratedAttribute]
internal bool get_DisposeOwnershipTransferAtConstructor();
    [CompilerGeneratedAttribute]
internal bool get_DisposeOwnershipTransferAtMethodCall();
    [CompilerGeneratedAttribute]
internal bool get_TrackInstanceFields();
    [CompilerGeneratedAttribute]
internal Func`2<ITypeSymbol, bool> get_IsDisposableTypeNotRequiringToBeDisposed();
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAnalysisResult, DisposeAbstractValue> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysisResult : DataFlowAnalysisResult`2<DisposeBlockAnalysisResult, DisposeAbstractValue> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<IFieldSymbol, PointsToAbstractValue> <TrackedInstanceFieldPointsToMap>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<IFieldSymbol, PointsToAbstractValue> TrackedInstanceFieldPointsToMap { get; }
    internal DisposeAnalysisResult(DataFlowAnalysisResult`2<DisposeBlockAnalysisResult, DisposeAbstractValue> coreDisposeAnalysisResult, ImmutableDictionary`2<IFieldSymbol, PointsToAbstractValue> trackedInstanceFieldPointsToMap);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<IFieldSymbol, PointsToAbstractValue> get_TrackedInstanceFieldPointsToMap();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AbstractLocation, DisposeAbstractValue> <Data>k__BackingField;
    public ImmutableDictionary`2<AbstractLocation, DisposeAbstractValue> Data { get; }
    internal DisposeBlockAnalysisResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue> blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AbstractLocation, DisposeAbstractValue> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ForwardDataFlowAnalysis`5 : DataFlowAnalysis`5<TAnalysisData, TAnalysisContext, TAnalysisResult, TBlockAnalysisResult, TAbstractAnalysisValue> {
    protected ForwardDataFlowAnalysis`5(AbstractAnalysisDomain`1<TAnalysisData> analysisDomain, DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> operationVisitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysis : ForwardDataFlowAnalysis`5<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet> {
    internal static MapAbstractDomain`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> GlobalFlowStateAnalysisDomainInstance;
    private GlobalFlowStateAnalysis(MapAbstractDomain`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> analysisDomain, GlobalFlowStateValueSetFlowOperationVisitor operationVisitor);
    private static GlobalFlowStateAnalysis();
    public static DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, Func`2<GlobalFlowStateAnalysisContext, GlobalFlowStateValueSetFlowOperationVisitor> createOperationVisitor, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, bool performValueContentAnalysis, bool pessimisticAnalysis, DataFlowAnalysisResult`2& valueContentAnalysisResult, InterproceduralAnalysisKind interproceduralAnalysisKind, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, ImmutableArray`1<INamedTypeSymbol> additionalSupportedValueTypes, Func`2<IOperation, ValueContentAbstractValue> getValueContentValueForAdditionalSupportedValueTypeOperation);
    private static DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, Func`2<GlobalFlowStateAnalysisContext, GlobalFlowStateValueSetFlowOperationVisitor> createOperationVisitor, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, PointsToAnalysisKind pointsToAnalysisKind, bool pessimisticAnalysis, bool performValueContentAnalysis, DataFlowAnalysisResult`2& valueContentAnalysisResult, ImmutableArray`1<INamedTypeSymbol> additionalSupportedValueTypes, Func`2<IOperation, ValueContentAbstractValue> getValueContentValueForAdditionalSupportedValueTypeOperation);
    private static DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet> TryGetOrComputeResultForAnalysisContext(GlobalFlowStateAnalysisContext analysisContext, Func`2<GlobalFlowStateAnalysisContext, GlobalFlowStateValueSetFlowOperationVisitor> createOperationVisitor);
    protected virtual DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet> ToResult(GlobalFlowStateAnalysisContext analysisContext, DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet> dataFlowAnalysisResult);
    protected virtual GlobalFlowStateBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisContext : AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateAnalysisValueSet> {
    private GlobalFlowStateAnalysisContext(AbstractValueDomain`1<GlobalFlowStateAnalysisValueSet> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Func`2<GlobalFlowStateAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet>> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateAnalysisContext, GlobalFlowStateAnalysisValueSet> interproceduralAnalysisData, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    internal static GlobalFlowStateAnalysisContext Create(AbstractValueDomain`1<GlobalFlowStateAnalysisValueSet> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Func`2<GlobalFlowStateAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet>> tryGetOrComputeAnalysisResult, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    public virtual GlobalFlowStateAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateAnalysisContext, GlobalFlowStateAnalysisValueSet> interproceduralAnalysisData);
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateAnalysisValueSet> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisValueSet : CacheBasedEquatable`1<GlobalFlowStateAnalysisValueSet> {
    public static GlobalFlowStateAnalysisValueSet Unset;
    public static GlobalFlowStateAnalysisValueSet Empty;
    public static GlobalFlowStateAnalysisValueSet Unknown;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IAbstractAnalysisValue> <AnalysisValues>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<GlobalFlowStateAnalysisValueSet> <Parents>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private GlobalFlowStateAnalysisValueSetKind <Kind>k__BackingField;
    public ImmutableHashSet`1<IAbstractAnalysisValue> AnalysisValues { get; }
    public ImmutableHashSet`1<GlobalFlowStateAnalysisValueSet> Parents { get; }
    public int Height { get; }
    public GlobalFlowStateAnalysisValueSetKind Kind { get; }
    private GlobalFlowStateAnalysisValueSet(ImmutableHashSet`1<IAbstractAnalysisValue> analysisValues, ImmutableHashSet`1<GlobalFlowStateAnalysisValueSet> parents, int height, GlobalFlowStateAnalysisValueSetKind kind);
    private static GlobalFlowStateAnalysisValueSet();
    public static GlobalFlowStateAnalysisValueSet Create(ImmutableHashSet`1<IAbstractAnalysisValue> analysisValues, ImmutableHashSet`1<GlobalFlowStateAnalysisValueSet> parents, int height);
    public static GlobalFlowStateAnalysisValueSet Create(IAbstractAnalysisValue analysisValue);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IAbstractAnalysisValue> get_AnalysisValues();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<GlobalFlowStateAnalysisValueSet> get_Parents();
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public GlobalFlowStateAnalysisValueSetKind get_Kind();
    private GlobalFlowStateAnalysisValueSet WithRootParent(GlobalFlowStateAnalysisValueSet newRoot);
    internal GlobalFlowStateAnalysisValueSet WithAdditionalAnalysisValues(GlobalFlowStateAnalysisValueSet newAnalysisValuesSet, bool negate);
    private GlobalFlowStateAnalysisValueSet WithAdditionalAnalysisValuesCore(GlobalFlowStateAnalysisValueSet newAnalysisValues);
    internal GlobalFlowStateAnalysisValueSet GetNegatedValue();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<GlobalFlowStateAnalysisValueSet> obj);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static GlobalFlowStateAnalysisValueSet <GetNegatedValue>g__GetNegateValueFromParents|21_0(ImmutableHashSet`1<GlobalFlowStateAnalysisValueSet> parents);
    [CompilerGeneratedAttribute]
private string <ToString>g__GetParentString|24_0();
    [CompilerGeneratedAttribute]
private string <ToString>g__GetAnalysisValuesString|24_1();
}
internal enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateAnalysisValueSetKind : Enum {
    public int value__;
    public static GlobalFlowStateAnalysisValueSetKind Unset;
    public static GlobalFlowStateAnalysisValueSetKind Known;
    public static GlobalFlowStateAnalysisValueSetKind Empty;
    public static GlobalFlowStateAnalysisValueSetKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> <Data>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> Data { get; }
    internal GlobalFlowStateBlockAnalysisResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateDataFlowOperationVisitor`3 : AnalysisEntityDataFlowOperationVisitor`4<DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue>, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> {
    [CompilerGeneratedAttribute]
private AnalysisEntity <GlobalEntity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPredicatedGlobalState>k__BackingField;
    private Builder<IOperation, TAbstractAnalysisValue> _globalValuesMapBuilder;
    protected AnalysisEntity GlobalEntity { get; }
    protected bool HasPredicatedGlobalState { get; }
    internal bool SkipExceptionPathsAnalysisPostPass { get; }
    protected TAbstractAnalysisValue GlobalState { get; protected set; }
    protected GlobalFlowStateDataFlowOperationVisitor`3(TAnalysisContext analysisContext, bool hasPredicatedGlobalState);
    [CompilerGeneratedAttribute]
protected AnalysisEntity get_GlobalEntity();
    [CompilerGeneratedAttribute]
protected bool get_HasPredicatedGlobalState();
    internal virtual bool get_SkipExceptionPathsAnalysisPostPass();
    protected abstract virtual void SetAbstractValue(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> analysisData, AnalysisEntity analysisEntity, TAbstractAnalysisValue value);
    internal ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> GetGlobalValuesMap();
    private static AnalysisEntity GetGlobalEntity(TAnalysisContext analysisContext);
    public sealed virtual DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> Flow(IOperation statement, BasicBlock block, DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> input);
    private void EnsureInitialized(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> input);
    protected TAbstractAnalysisValue get_GlobalState();
    protected void set_GlobalState(TAbstractAnalysisValue value);
    public virtual ValueTuple`2<DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue>, bool> FlowBranch(BasicBlock fromBlock, BranchWithInfo branch, DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> input);
    public virtual DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> GetEmptyAnalysisData();
    protected sealed virtual DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> GetClonedAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> analysisData);
    protected sealed virtual void AddTrackedEntities(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> analysisData, HashSet`1<AnalysisEntity> builder, bool forInterproceduralAnalysis);
    protected sealed virtual void StopTrackingEntity(AnalysisEntity analysisEntity, DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> analysisData);
    protected sealed virtual TAbstractAnalysisValue GetAbstractValue(AnalysisEntity analysisEntity);
    protected virtual void SetAbstractValue(AnalysisEntity analysisEntity, TAbstractAnalysisValue value);
    protected sealed virtual bool HasAbstractValue(AnalysisEntity analysisEntity);
    protected sealed virtual bool HasAnyAbstractValue(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> data);
    protected sealed virtual DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> GetTrimmedCurrentAnalysisData(IEnumerable`1<AnalysisEntity> withEntities);
    protected sealed virtual void ResetAbstractValue(AnalysisEntity analysisEntity);
    protected sealed virtual void ResetCurrentAnalysisData();
    protected sealed virtual void UpdateValuesForAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> targetAnalysisData);
    protected sealed virtual void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> dataAtException, ThrownExceptionInfo throwBranchWithExceptionType);
    protected sealed virtual void ApplyInterproceduralAnalysisResultCore(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> resultData);
    protected virtual DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> GetInitialInterproceduralAnalysisData(IMethodSymbol invokedMethod, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> invocationInstance, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> thisOrMeInstanceForCaller, ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> argumentValuesMap, IDictionary`2<AnalysisEntity, PointsToAbstractValue> pointsToValues, IDictionary`2<AnalysisEntity, CopyAbstractValue> copyValues, IDictionary`2<AnalysisEntity, ValueContentAbstractValue> valueContentValues, bool isLambdaOrLocalFunction, bool hasParameterWithDelegateType);
    [NullableContextAttribute("2")]
public virtual TAbstractAnalysisValue Visit(IOperation operation, object argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.GlobalFlowStateValueSetFlowOperationVisitor : GlobalFlowStateDataFlowOperationVisitor`3<GlobalFlowStateAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet>, GlobalFlowStateAnalysisValueSet> {
    protected GlobalFlowStateValueSetFlowOperationVisitor(GlobalFlowStateAnalysisContext analysisContext, bool hasPredicatedGlobalState);
    public sealed virtual ValueTuple`2<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet>, bool> FlowBranch(BasicBlock fromBlock, BranchWithInfo branch, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> input);
    protected void MergeAndSetGlobalState(GlobalFlowStateAnalysisValueSet value, bool negate);
    protected sealed virtual GlobalFlowStateAnalysisValueSet GetAbstractDefaultValue(ITypeSymbol type);
    protected sealed virtual void SetAbstractValue(AnalysisEntity analysisEntity, GlobalFlowStateAnalysisValueSet value);
    protected virtual void SetAbstractValue(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> analysisData, AnalysisEntity analysisEntity, GlobalFlowStateAnalysisValueSet value);
    protected sealed virtual DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> MergeAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> value1, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> value2);
    protected sealed virtual DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> MergeAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> value1, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> value2, BasicBlock forBlock);
    protected sealed virtual DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> MergeAnalysisDataForBackEdge(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> value1, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> value2, BasicBlock forBlock);
    protected sealed virtual DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> GetExitBlockOutputData(DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet> analysisResult);
    protected sealed virtual bool Equals(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> value1, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateAnalysisValueSet> value2);
    public virtual GlobalFlowStateAnalysisValueSet VisitInvocation_NonLambdaOrDelegateOrLocalFunction(IMethodSymbol method, IOperation visitedInstance, ImmutableArray`1<IArgumentOperation> visitedArguments, bool invokedAsDelegate, IOperation originalOperation, GlobalFlowStateAnalysisValueSet defaultValue);
    public virtual GlobalFlowStateAnalysisValueSet VisitUnaryOperatorCore(IUnaryOperation operation, object argument);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.GlobalFlowStateAnalysis.IAbstractAnalysisValue {
    public abstract virtual IAbstractAnalysisValue GetNegatedValue();
    public abstract virtual string ToString();
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisContext {
    public ControlFlowGraph ControlFlowGraph { get; }
    public ISymbol OwningSymbol { get; }
    public abstract virtual ControlFlowGraph get_ControlFlowGraph();
    public abstract virtual ISymbol get_OwningSymbol();
    public abstract virtual ControlFlowGraph GetLocalFunctionControlFlowGraph(IMethodSymbol localFunction);
    public abstract virtual ControlFlowGraph GetAnonymousFunctionControlFlowGraph(IFlowAnonymousFunctionOperation lambda);
}
[NullableContextAttribute("2")]
public interface Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult`1 {
    [NullableAttribute("1")]
public ControlFlowGraph ControlFlowGraph { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> ReturnValueAndPredicateKind { get; }
    public object AnalysisDataForUnhandledThrowOperations { get; }
    public object TaskWrappedValuesMap { get; }
    [NullableAttribute("1")]
public LambdaAndLocalFunctionAnalysisInfo LambdaAndLocalFunctionAnalysisInfo { get; }
    [NullableContextAttribute("1")]
public abstract virtual ControlFlowGraph get_ControlFlowGraph();
    public abstract virtual Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> get_ReturnValueAndPredicateKind();
    public abstract virtual object get_AnalysisDataForUnhandledThrowOperations();
    public abstract virtual object get_TaskWrappedValuesMap();
    [NullableContextAttribute("1")]
public abstract virtual LambdaAndLocalFunctionAnalysisInfo get_LambdaAndLocalFunctionAnalysisInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisConfiguration : ValueType {
    private static UInt32 DefaultMaxInterproceduralMethodCallChain;
    private static UInt32 DefaultMaxInterproceduralLambdaOrLocalFunctionCallChain;
    [CompilerGeneratedAttribute]
private InterproceduralAnalysisKind <InterproceduralAnalysisKind>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxInterproceduralMethodCallChain>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxInterproceduralLambdaOrLocalFunctionCallChain>k__BackingField;
    public InterproceduralAnalysisKind InterproceduralAnalysisKind { get; }
    public UInt32 MaxInterproceduralMethodCallChain { get; }
    public UInt32 MaxInterproceduralLambdaOrLocalFunctionCallChain { get; }
    private InterproceduralAnalysisConfiguration(InterproceduralAnalysisKind interproceduralAnalysisKind, UInt32 maxInterproceduralMethodCallChain, UInt32 maxInterproceduralLambdaOrLocalFunctionCallChain);
    public static InterproceduralAnalysisConfiguration Create(AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, ControlFlowGraph cfg, Compilation compilation, InterproceduralAnalysisKind defaultInterproceduralAnalysisKind, UInt32 defaultMaxInterproceduralMethodCallChain, UInt32 defaultMaxInterproceduralLambdaOrLocalFunctionCallChain);
    private static InterproceduralAnalysisConfiguration Create(AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, InterproceduralAnalysisKind defaultInterproceduralAnalysisKind, UInt32 defaultMaxInterproceduralMethodCallChain, UInt32 defaultMaxInterproceduralLambdaOrLocalFunctionCallChain);
    public static InterproceduralAnalysisConfiguration Create(AnalyzerOptions analyzerOptions, ImmutableArray`1<DiagnosticDescriptor> rules, ControlFlowGraph cfg, Compilation compilation, InterproceduralAnalysisKind defaultInterproceduralAnalysisKind, UInt32 defaultMaxInterproceduralMethodCallChain, UInt32 defaultMaxInterproceduralLambdaOrLocalFunctionCallChain);
    internal static InterproceduralAnalysisConfiguration Create(AnalyzerOptions analyzerOptions, ImmutableArray`1<DiagnosticDescriptor> rules, IOperation operation, Compilation compilation, InterproceduralAnalysisKind defaultInterproceduralAnalysisKind, UInt32 defaultMaxInterproceduralMethodCallChain, UInt32 defaultMaxInterproceduralLambdaOrLocalFunctionCallChain);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InterproceduralAnalysisKind get_InterproceduralAnalysisKind();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MaxInterproceduralMethodCallChain();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MaxInterproceduralLambdaOrLocalFunctionCallChain();
    [IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(InterproceduralAnalysisConfiguration other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    public static bool op_Equality(InterproceduralAnalysisConfiguration left, InterproceduralAnalysisConfiguration right);
    public static bool op_Inequality(InterproceduralAnalysisConfiguration left, InterproceduralAnalysisConfiguration right);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisData`3 : CacheBasedEquatable`1<InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue>> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TAnalysisData <InitialAnalysisData>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> <InvocationInstance>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> <ThisOrMeInstanceForCaller>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> <ArgumentValuesMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ISymbol, PointsToAbstractValue> <CapturedVariablesMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> <AddressSharedEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableStack`1<IOperation> <CallStack>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<TAnalysisContext> <MethodsBeingAnalyzed>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IOperation, TAbstractAnalysisValue> <GetCachedAbstractValueFromCaller>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<IMethodSymbol, ControlFlowGraph> <GetInterproceduralControlFlowGraph>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<IOperation, AnalysisEntity> <GetAnalysisEntityForFlowCapture>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<ISymbol, ImmutableStack`1<IOperation>> <GetInterproceduralCallStackForOwningSymbol>k__BackingField;
    [NullableAttribute("2")]
public TAnalysisData InitialAnalysisData { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> InvocationInstance { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> ThisOrMeInstanceForCaller { get; }
    public ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> ArgumentValuesMap { get; }
    public ImmutableDictionary`2<ISymbol, PointsToAbstractValue> CapturedVariablesMap { get; }
    public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> AddressSharedEntities { get; }
    public ImmutableStack`1<IOperation> CallStack { get; }
    public ImmutableHashSet`1<TAnalysisContext> MethodsBeingAnalyzed { get; }
    public Func`2<IOperation, TAbstractAnalysisValue> GetCachedAbstractValueFromCaller { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<IMethodSymbol, ControlFlowGraph> GetInterproceduralControlFlowGraph { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<IOperation, AnalysisEntity> GetAnalysisEntityForFlowCapture { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<ISymbol, ImmutableStack`1<IOperation>> GetInterproceduralCallStackForOwningSymbol { get; }
    public InterproceduralAnalysisData`3(TAnalysisData initialAnalysisData, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> invocationInstance, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> thisOrMeInstanceForCaller, ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> argumentValuesMap, ImmutableDictionary`2<ISymbol, PointsToAbstractValue> capturedVariablesMap, ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> addressSharedEntities, ImmutableStack`1<IOperation> callStack, ImmutableHashSet`1<TAnalysisContext> methodsBeingAnalyzed, Func`2<IOperation, TAbstractAnalysisValue> getCachedAbstractValueFromCaller, Func`2<IMethodSymbol, ControlFlowGraph> getInterproceduralControlFlowGraph, Func`2<IOperation, AnalysisEntity> getAnalysisEntityForFlowCapture, Func`2<ISymbol, ImmutableStack`1<IOperation>> getInterproceduralCallStackForOwningSymbol);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TAnalysisData get_InitialAnalysisData();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> get_InvocationInstance();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> get_ThisOrMeInstanceForCaller();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> get_ArgumentValuesMap();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<ISymbol, PointsToAbstractValue> get_CapturedVariablesMap();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> get_AddressSharedEntities();
    [CompilerGeneratedAttribute]
public ImmutableStack`1<IOperation> get_CallStack();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<TAnalysisContext> get_MethodsBeingAnalyzed();
    [CompilerGeneratedAttribute]
public Func`2<IOperation, TAbstractAnalysisValue> get_GetCachedAbstractValueFromCaller();
    [CompilerGeneratedAttribute]
public Func`2<IMethodSymbol, ControlFlowGraph> get_GetInterproceduralControlFlowGraph();
    [CompilerGeneratedAttribute]
public Func`2<IOperation, AnalysisEntity> get_GetAnalysisEntityForFlowCapture();
    [CompilerGeneratedAttribute]
public Func`2<ISymbol, ImmutableStack`1<IOperation>> get_GetInterproceduralCallStackForOwningSymbol();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue>> obj);
    private static void AddHashCodeParts(Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> instanceAndPointsToValue, RoslynHashCode& hashCode);
    private static bool EqualsByHashCodeParts(Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> left, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> right);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind : Enum {
    public int value__;
    public static InterproceduralAnalysisKind None;
    public static InterproceduralAnalysisKind ContextSensitive;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisPredicate : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IMethodSymbol, bool> _skipAnalysisForInvokedMethodPredicate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IMethodSymbol, bool> _skipAnalysisForInvokedLambdaOrLocalFunctionPredicate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IDataFlowAnalysisContext, bool> _skipAnalysisForInvokedContextPredicate;
    public InterproceduralAnalysisPredicate(Func`2<IMethodSymbol, bool> skipAnalysisForInvokedMethodPredicate, Func`2<IMethodSymbol, bool> skipAnalysisForInvokedLambdaOrLocalFunctionPredicate, Func`2<IDataFlowAnalysisContext, bool> skipAnalysisForInvokedContextPredicate);
    public bool SkipInterproceduralAnalysis(IMethodSymbol invokedMethod, bool isLambdaOrLocalFunction);
    public bool SkipInterproceduralAnalysis(IDataFlowAnalysisContext interproceduralAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralCaptureId : ValueType {
    [CompilerGeneratedAttribute]
private CaptureId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLValueFlowCapture>k__BackingField;
    public CaptureId Id { get; }
    public ControlFlowGraph ControlFlowGraph { get; }
    public bool IsLValueFlowCapture { get; }
    internal InterproceduralCaptureId(CaptureId captureId, ControlFlowGraph controlFlowGraph, bool isLValueFlowCapture);
    [CompilerGeneratedAttribute]
public CaptureId get_Id();
    [CompilerGeneratedAttribute]
public ControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
public bool get_IsLValueFlowCapture();
    public sealed virtual bool Equals(InterproceduralCaptureId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(InterproceduralCaptureId left, InterproceduralCaptureId right);
    public static bool op_Inequality(InterproceduralCaptureId left, InterproceduralCaptureId right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LambdaAndLocalFunctionAnalysisInfo : object {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IMethodSymbol> <EscapedLocalFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IMethodSymbol> <AnalyzedLocalFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IFlowAnonymousFunctionOperation> <EscapedLambdas>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IFlowAnonymousFunctionOperation> <AnalyzedLambdas>k__BackingField;
    public ImmutableHashSet`1<IMethodSymbol> EscapedLocalFunctions { get; }
    public ImmutableHashSet`1<IMethodSymbol> AnalyzedLocalFunctions { get; }
    public ImmutableHashSet`1<IFlowAnonymousFunctionOperation> EscapedLambdas { get; }
    public ImmutableHashSet`1<IFlowAnonymousFunctionOperation> AnalyzedLambdas { get; }
    internal LambdaAndLocalFunctionAnalysisInfo(Builder<IMethodSymbol> escapedLocalFunctions, Builder<IMethodSymbol> analyzedLocalFunctions, Builder<IFlowAnonymousFunctionOperation> escapedLambdas, Builder<IFlowAnonymousFunctionOperation> analyzedLambdas);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IMethodSymbol> get_EscapedLocalFunctions();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IMethodSymbol> get_AnalyzedLocalFunctions();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IFlowAnonymousFunctionOperation> get_EscapedLambdas();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IFlowAnonymousFunctionOperation> get_AnalyzedLambdas();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LValueFlowCapturesProvider : object {
    private static ConditionalWeakTable`2<ControlFlowGraph, ImmutableHashSet`1<CaptureId>> s_lValueFlowCapturesCache;
    private static LValueFlowCapturesProvider();
    public static ImmutableHashSet`1<CaptureId> GetOrCreateLValueFlowCaptures(ControlFlowGraph cfg);
    private static ImmutableHashSet`1<CaptureId> CreateLValueFlowCaptures(ControlFlowGraph cfg);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.MapAbstractDomain`2 : AbstractAnalysisDomain`1<DictionaryAnalysisData`2<TKey, TValue>> {
    [CompilerGeneratedAttribute]
private AbstractValueDomain`1<TValue> <ValueDomain>k__BackingField;
    protected AbstractValueDomain`1<TValue> ValueDomain { get; }
    public MapAbstractDomain`2(AbstractValueDomain`1<TValue> valueDomain);
    [CompilerGeneratedAttribute]
protected AbstractValueDomain`1<TValue> get_ValueDomain();
    public virtual DictionaryAnalysisData`2<TKey, TValue> Clone(DictionaryAnalysisData`2<TKey, TValue> value);
    public sealed virtual int Compare(DictionaryAnalysisData`2<TKey, TValue> oldValue, DictionaryAnalysisData`2<TKey, TValue> newValue);
    public sealed virtual bool Equals(DictionaryAnalysisData`2<TKey, TValue> value1, DictionaryAnalysisData`2<TKey, TValue> value2);
    private int Compare(DictionaryAnalysisData`2<TKey, TValue> oldValue, DictionaryAnalysisData`2<TKey, TValue> newValue, bool assertMonotonicity);
    [ConditionalAttribute("DEBUG")]
private static void FireNonMonotonicAssertIfNeeded(bool assertMonotonicity);
    public virtual DictionaryAnalysisData`2<TKey, TValue> Merge(DictionaryAnalysisData`2<TKey, TValue> value1, DictionaryAnalysisData`2<TKey, TValue> value2);
    internal DictionaryAnalysisData`2<TKey, TValue> Intersect(DictionaryAnalysisData`2<TKey, TValue> map1, DictionaryAnalysisData`2<TKey, TValue> map2, Func`3<TValue, TValue, TValue> intersect);
}
internal enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ParameterValidationAnalysis.ParameterValidationAbstractValue : Enum {
    public int value__;
    public static ParameterValidationAbstractValue NotApplicable;
    public static ParameterValidationAbstractValue NotValidated;
    public static ParameterValidationAbstractValue Validated;
    public static ParameterValidationAbstractValue MayBeValidated;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ParameterValidationAnalysis.ParameterValidationAnalysis : ForwardDataFlowAnalysis`5<DictionaryAnalysisData`2<AbstractLocation, ParameterValidationAbstractValue>, ParameterValidationAnalysisContext, ParameterValidationAnalysisResult, ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> {
    public static MapAbstractDomain`2<AbstractLocation, ParameterValidationAbstractValue> ParameterValidationAnalysisDomainInstance;
    private ParameterValidationAnalysis(MapAbstractDomain`2<AbstractLocation, ParameterValidationAbstractValue> analysisDomain, ParameterValidationDataFlowOperationVisitor operationVisitor);
    private static ParameterValidationAnalysis();
    public static ImmutableDictionary`2<IParameterSymbol, SyntaxNode> GetOrComputeHazardousParameterUsages(IBlockOperation topmostBlock, Compilation compilation, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, PointsToAnalysisKind defaultPointsToAnalysisKind, InterproceduralAnalysisKind interproceduralAnalysisKind, UInt32 defaultMaxInterproceduralMethodCallChain, bool pessimisticAnalysis);
    private static ImmutableDictionary`2<IParameterSymbol, SyntaxNode> GetOrComputeHazardousParameterUsages(ControlFlowGraph cfg, Compilation compilation, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, SymbolNamesWithValueOption`1<Unit> nullCheckValidationMethods, PointsToAnalysisKind pointsToAnalysisKind, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool performCopyAnalysis, bool pessimisticAnalysis);
    private static ParameterValidationAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, SymbolNamesWithValueOption`1<Unit> nullCheckValidationMethods, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, PointsToAnalysisResult pointsToAnalysisResult);
    private static ParameterValidationAnalysisResult TryGetOrComputeResultForAnalysisContext(ParameterValidationAnalysisContext analysisContext);
    protected virtual ParameterValidationAnalysisResult ToResult(ParameterValidationAnalysisContext analysisContext, DataFlowAnalysisResult`2<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> dataFlowAnalysisResult);
    protected virtual ParameterValidationBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AbstractLocation, ParameterValidationAbstractValue> blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ParameterValidationAnalysis.ParameterValidationAnalysisContext : AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AbstractLocation, ParameterValidationAbstractValue>, ParameterValidationAnalysisContext, ParameterValidationAnalysisResult, ParameterValidationAbstractValue> {
    [CompilerGeneratedAttribute]
private bool <TrackHazardousParameterUsages>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolNamesWithValueOption`1<Unit> <NullCheckValidationMethodNames>k__BackingField;
    public bool TrackHazardousParameterUsages { get; }
    private SymbolNamesWithValueOption`1<Unit> NullCheckValidationMethodNames { get; }
    private ParameterValidationAnalysisContext(AbstractValueDomain`1<ParameterValidationAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, SymbolNamesWithValueOption`1<Unit> nullCheckValidationMethods, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, PointsToAnalysisResult pointsToAnalysisResult, Func`2<ParameterValidationAnalysisContext, ParameterValidationAnalysisResult> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AbstractLocation, ParameterValidationAbstractValue>, ParameterValidationAnalysisContext, ParameterValidationAbstractValue> interproceduralAnalysisData, bool trackHazardousParameterUsages);
    public static ParameterValidationAnalysisContext Create(AbstractValueDomain`1<ParameterValidationAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, SymbolNamesWithValueOption`1<Unit> nullCheckValidationMethods, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, PointsToAnalysisResult pointsToAnalysisResult, Func`2<ParameterValidationAnalysisContext, ParameterValidationAnalysisResult> tryGetOrComputeAnalysisResult);
    public virtual ParameterValidationAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AbstractLocation, ParameterValidationAbstractValue>, ParameterValidationAnalysisContext, ParameterValidationAbstractValue> interproceduralAnalysisData);
    public ParameterValidationAnalysisContext WithTrackHazardousParameterUsages();
    [CompilerGeneratedAttribute]
public bool get_TrackHazardousParameterUsages();
    [CompilerGeneratedAttribute]
private SymbolNamesWithValueOption`1<Unit> get_NullCheckValidationMethodNames();
    public bool IsNullCheckValidationMethod(IMethodSymbol method);
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AbstractLocation, ParameterValidationAbstractValue>, ParameterValidationAnalysisContext, ParameterValidationAnalysisResult, ParameterValidationAbstractValue> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ParameterValidationAnalysis.ParameterValidationAnalysisResult : DataFlowAnalysisResult`2<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<IParameterSymbol, SyntaxNode> <HazardousParameterUsages>k__BackingField;
    public ImmutableDictionary`2<IParameterSymbol, SyntaxNode> HazardousParameterUsages { get; }
    public ParameterValidationAnalysisResult(DataFlowAnalysisResult`2<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> parameterValidationAnalysisResult, ImmutableDictionary`2<IParameterSymbol, SyntaxNode> hazardousParameterUsages);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<IParameterSymbol, SyntaxNode> get_HazardousParameterUsages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ParameterValidationAnalysis.ParameterValidationBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AbstractLocation, ParameterValidationAbstractValue> <Data>k__BackingField;
    public ImmutableDictionary`2<AbstractLocation, ParameterValidationAbstractValue> Data { get; }
    public ParameterValidationBlockAnalysisResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AbstractLocation, ParameterValidationAbstractValue> blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AbstractLocation, ParameterValidationAbstractValue> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.DefaultPointsToValueGenerator : object {
    private TrackedEntitiesBuilder _trackedEntitiesBuilder;
    private Builder<AnalysisEntity, PointsToAbstractValue> _defaultPointsToValueMapBuilder;
    public PointsToAnalysisKind PointsToAnalysisKind { get; }
    public bool HasAnyTrackedEntity { get; }
    public DefaultPointsToValueGenerator(TrackedEntitiesBuilder trackedEntitiesBuilder);
    public PointsToAnalysisKind get_PointsToAnalysisKind();
    public PointsToAbstractValue GetOrCreateDefaultValue(AnalysisEntity analysisEntity);
    public bool IsTrackedEntity(AnalysisEntity analysisEntity);
    public bool IsTrackedPointsToValue(PointsToAbstractValue value);
    public void AddTrackedPointsToValue(PointsToAbstractValue value);
    public bool get_HasAnyTrackedEntity();
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.NullAbstractValue : Enum {
    public int value__;
    public static NullAbstractValue Invalid;
    public static NullAbstractValue Undefined;
    public static NullAbstractValue Null;
    public static NullAbstractValue NotNull;
    public static NullAbstractValue MaybeNull;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue : CacheBasedEquatable`1<PointsToAbstractValue> {
    private static int LocationThreshold;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <Undefined>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <Invalid>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <Unknown>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <UnknownNull>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <UnknownNotNull>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <NoLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <NullLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<AbstractLocation> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IOperation> <LValueCapturedOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAbstractValueKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private NullAbstractValue <NullState>k__BackingField;
    public static PointsToAbstractValue Undefined { get; }
    public static PointsToAbstractValue Invalid { get; }
    public static PointsToAbstractValue Unknown { get; }
    public static PointsToAbstractValue UnknownNull { get; }
    public static PointsToAbstractValue UnknownNotNull { get; }
    public static PointsToAbstractValue NoLocation { get; }
    public static PointsToAbstractValue NullLocation { get; }
    public ImmutableHashSet`1<AbstractLocation> Locations { get; }
    public ImmutableHashSet`1<IOperation> LValueCapturedOperations { get; }
    public PointsToAbstractValueKind Kind { get; }
    public NullAbstractValue NullState { get; }
    private PointsToAbstractValue(ImmutableHashSet`1<AbstractLocation> locations, NullAbstractValue nullState);
    private PointsToAbstractValue(ImmutableHashSet`1<IOperation> lValueCapturedOperations);
    private PointsToAbstractValue(PointsToAbstractValueKind kind, NullAbstractValue nullState);
    private static PointsToAbstractValue();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_Undefined();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_Invalid();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_Unknown();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_UnknownNull();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_UnknownNotNull();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_NoLocation();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_NullLocation();
    internal static PointsToAbstractValue Create(AbstractLocation location, bool mayBeNull);
    internal static PointsToAbstractValue Create(IOperation lValueCapturedOperation);
    internal static PointsToAbstractValue Create(ImmutableHashSet`1<AbstractLocation> locations, NullAbstractValue nullState);
    internal static PointsToAbstractValue Create(ImmutableHashSet`1<IOperation> lValueCapturedOperations);
    internal PointsToAbstractValue MakeNonNull();
    internal PointsToAbstractValue MakeNull();
    internal PointsToAbstractValue MakeMayBeNull();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<AbstractLocation> get_Locations();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IOperation> get_LValueCapturedOperations();
    [CompilerGeneratedAttribute]
public PointsToAbstractValueKind get_Kind();
    [CompilerGeneratedAttribute]
public NullAbstractValue get_NullState();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<PointsToAbstractValue> obj);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind : Enum {
    public int value__;
    public static PointsToAbstractValueKind Invalid;
    public static PointsToAbstractValueKind Undefined;
    public static PointsToAbstractValueKind KnownLocations;
    public static PointsToAbstractValueKind KnownLValueCaptures;
    public static PointsToAbstractValueKind UnknownNull;
    public static PointsToAbstractValueKind UnknownNotNull;
    public static PointsToAbstractValueKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis : ForwardDataFlowAnalysis`5<PointsToAnalysisData, PointsToAnalysisContext, PointsToAnalysisResult, PointsToBlockAnalysisResult, PointsToAbstractValue> {
    internal static AbstractValueDomain`1<PointsToAbstractValue> ValueDomainInstance;
    private PointsToAnalysis(PointsToAnalysisDomain analysisDomain, PointsToDataFlowOperationVisitor operationVisitor);
    private static PointsToAnalysis();
    public static PointsToAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, PointsToAnalysisKind pointsToAnalysisKind, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, bool pessimisticAnalysis, bool performCopyAnalysis, bool exceptionPathsAnalysis);
    public static PointsToAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, PointsToAnalysisKind pointsToAnalysisKind, DataFlowAnalysisResult`2& copyAnalysisResult, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, bool pessimisticAnalysis, bool performCopyAnalysis, bool exceptionPathsAnalysis);
    private static PointsToAnalysisResult TryGetOrComputeResultForAnalysisContext(PointsToAnalysisContext analysisContext);
    [NullableContextAttribute("2")]
internal static bool ShouldBeTracked(ITypeSymbol typeSymbol, Func`2<ITypeSymbol, bool> isDisposable);
    internal static bool ShouldBeTracked(AnalysisEntity analysisEntity, PointsToAnalysisKind pointsToAnalysisKind, Func`2<ITypeSymbol, bool> isDisposable);
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidPointsToAnalysisData(PointsToAnalysisData data);
    protected virtual PointsToAnalysisResult ToResult(PointsToAnalysisContext analysisContext, DataFlowAnalysisResult`2<PointsToBlockAnalysisResult, PointsToAbstractValue> dataFlowAnalysisResult);
    protected virtual PointsToBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, PointsToAnalysisData blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisContext : AbstractDataFlowAnalysisContext`4<PointsToAnalysisData, PointsToAnalysisContext, PointsToAnalysisResult, PointsToAbstractValue> {
    [CompilerGeneratedAttribute]
private PointsToAnalysisKind <PointsToAnalysisKind>k__BackingField;
    public PointsToAnalysisKind PointsToAnalysisKind { get; }
    private PointsToAnalysisContext(AbstractValueDomain`1<PointsToAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, PointsToAnalysisKind pointsToAnalysisKind, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, Func`2<PointsToAnalysisContext, PointsToAnalysisResult> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<PointsToAnalysisData, PointsToAnalysisContext, PointsToAbstractValue> interproceduralAnalysisData, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    [CompilerGeneratedAttribute]
public PointsToAnalysisKind get_PointsToAnalysisKind();
    internal static PointsToAnalysisContext Create(AbstractValueDomain`1<PointsToAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, PointsToAnalysisKind pointsToAnalysisKind, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, Func`2<PointsToAnalysisContext, PointsToAnalysisResult> tryGetOrComputeAnalysisResult, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    public virtual PointsToAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<PointsToAnalysisData, PointsToAnalysisContext, PointsToAbstractValue> interproceduralAnalysisData);
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<PointsToAnalysisData, PointsToAnalysisContext, PointsToAnalysisResult, PointsToAbstractValue> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisData : AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ITypeSymbol, bool> _isDisposable;
    protected AbstractValueDomain`1<PointsToAbstractValue> ValueDomain { get; }
    internal PointsToAnalysisData(Func`2<ITypeSymbol, bool> isDisposable);
    internal PointsToAnalysisData(IDictionary`2<AnalysisEntity, PointsToAbstractValue> fromData, Func`2<ITypeSymbol, bool> isDisposable);
    internal PointsToAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, PointsToAbstractValue> mergedCoreAnalysisData, PredicatedAnalysisData`2<AnalysisEntity, PointsToAbstractValue> predicatedData1, PredicatedAnalysisData`2<AnalysisEntity, PointsToAbstractValue> predicatedData2, bool isReachableData, MapAbstractDomain`2<AnalysisEntity, PointsToAbstractValue> coreDataAnalysisDomain, Func`2<ITypeSymbol, bool> isDisposable);
    private PointsToAnalysisData(PointsToAnalysisData fromData);
    private PointsToAnalysisData(PointsToAnalysisData data1, PointsToAnalysisData data2, MapAbstractDomain`2<AnalysisEntity, PointsToAbstractValue> coreDataAnalysisDomain);
    protected virtual AbstractValueDomain`1<PointsToAbstractValue> get_ValueDomain();
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> Clone();
    public virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> other, MapAbstractDomain`2<AnalysisEntity, PointsToAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> data, MapAbstractDomain`2<AnalysisEntity, PointsToAbstractValue> coreDataAnalysisDomain);
    public virtual void SetAbstractValue(AnalysisEntity key, PointsToAbstractValue value);
    public virtual void Reset(Func`3<AnalysisEntity, PointsToAbstractValue, PointsToAbstractValue> getResetValue);
    [ConditionalAttribute("DEBUG")]
internal void AssertNoFlowCaptureEntitiesTracked();
    [ConditionalAttribute("DEBUG")]
private static void AssertNoFlowCaptureEntitiesTracked(DictionaryAnalysisData`2<AnalysisEntity, PointsToAbstractValue> map);
    [ConditionalAttribute("DEBUG")]
internal void AssertValidPointsToAnalysisData();
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidPointsToAnalysisData(IDictionary`2<AnalysisEntity, PointsToAbstractValue> map, Func`2<ITypeSymbol, bool> isDisposable);
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidPointsToAnalysisKeyValuePair(AnalysisEntity key, PointsToAbstractValue value, Func`2<ITypeSymbol, bool> isDisposable);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisKind : Enum {
    public int value__;
    public static PointsToAnalysisKind None;
    public static PointsToAnalysisKind PartialWithoutTrackingFieldsAndProperties;
    public static PointsToAnalysisKind Complete;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisResult : DataFlowAnalysisResult`2<PointsToBlockAnalysisResult, PointsToAbstractValue> {
    private ImmutableDictionary`2<IOperation, ImmutableHashSet`1<AbstractLocation>> _escapedLocationsThroughOperationsMap;
    private ImmutableDictionary`2<IOperation, ImmutableHashSet`1<AbstractLocation>> _escapedLocationsThroughReturnValuesMap;
    private ImmutableDictionary`2<AnalysisEntity, ImmutableHashSet`1<AbstractLocation>> _escapedLocationsThroughEntitiesMap;
    private ImmutableHashSet`1<AnalysisEntity> _trackedEntities;
    private ImmutableHashSet`1<PointsToAbstractValue> _trackedPointsToValues;
    [CompilerGeneratedAttribute]
private PointsToAnalysisKind <PointsToAnalysisKind>k__BackingField;
    public PointsToAnalysisKind PointsToAnalysisKind { get; }
    internal PointsToAnalysisResult(DataFlowAnalysisResult`2<PointsToBlockAnalysisResult, PointsToAbstractValue> corePointsToAnalysisResult, ImmutableDictionary`2<IOperation, ImmutableHashSet`1<AbstractLocation>> escapedLocationsThroughOperationsMap, ImmutableDictionary`2<IOperation, ImmutableHashSet`1<AbstractLocation>> escapedLocationsThroughReturnValuesMap, ImmutableDictionary`2<AnalysisEntity, ImmutableHashSet`1<AbstractLocation>> escapedLocationsThroughEntitiesMap, TrackedEntitiesBuilder trackedEntitiesBuilder);
    [CompilerGeneratedAttribute]
public PointsToAnalysisKind get_PointsToAnalysisKind();
    public ImmutableHashSet`1<AbstractLocation> GetEscapedAbstractLocations(IOperation operation);
    public ImmutableHashSet`1<AbstractLocation> GetEscapedAbstractLocations(AnalysisEntity analysisEntity);
    private static ImmutableHashSet`1<AbstractLocation> GetEscapedAbstractLocations(TKey key, ImmutableDictionary`2<TKey, ImmutableHashSet`1<AbstractLocation>> map);
    internal bool IsTrackedEntity(AnalysisEntity analysisEntity);
    internal bool IsTrackedPointsToValue(PointsToAbstractValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, PointsToAbstractValue> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReachable>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, PointsToAbstractValue> Data { get; }
    public bool IsReachable { get; }
    internal PointsToBlockAnalysisResult(BasicBlock basicBlock, PointsToAnalysisData blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, PointsToAbstractValue> get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.TrackedEntitiesBuilder : object {
    [CompilerGeneratedAttribute]
private PooledHashSet`1<AnalysisEntity> <AllEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private PooledHashSet`1<PointsToAbstractValue> <PointsToValues>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAnalysisKind <PointsToAnalysisKind>k__BackingField;
    private PooledHashSet`1<AnalysisEntity> AllEntities { get; }
    private PooledHashSet`1<PointsToAbstractValue> PointsToValues { get; }
    public PointsToAnalysisKind PointsToAnalysisKind { get; }
    public TrackedEntitiesBuilder(PointsToAnalysisKind pointsToAnalysisKind);
    [CompilerGeneratedAttribute]
private PooledHashSet`1<AnalysisEntity> get_AllEntities();
    [CompilerGeneratedAttribute]
private PooledHashSet`1<PointsToAbstractValue> get_PointsToValues();
    [CompilerGeneratedAttribute]
public PointsToAnalysisKind get_PointsToAnalysisKind();
    public sealed virtual void Dispose();
    public void AddEntityAndPointsToValue(AnalysisEntity analysisEntity, PointsToAbstractValue value);
    public void AddTrackedPointsToValue(PointsToAbstractValue value);
    public IEnumerable`1<AnalysisEntity> EnumerateEntities();
    public bool IsTrackedPointsToValue(PointsToAbstractValue value);
    public ValueTuple`2<ImmutableHashSet`1<AnalysisEntity>, ImmutableHashSet`1<PointsToAbstractValue>> ToImmutable();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicateAnalysisEntityDataFlowOperationVisitor`4 : AnalysisEntityDataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> {
    protected bool SupportsPredicateAnalysis { get; }
    protected PredicateAnalysisEntityDataFlowOperationVisitor`4(TAnalysisContext analysisContext);
    protected sealed virtual bool get_SupportsPredicateAnalysis();
    protected virtual void UpdateReachability(BasicBlock basicBlock, TAnalysisData analysisData, bool isReachable);
    protected virtual bool IsReachableBlockData(TAnalysisData analysisData);
    [NullableContextAttribute("2")]
protected sealed virtual void StartTrackingPredicatedData(AnalysisEntity predicatedEntity, TAnalysisData truePredicateData, TAnalysisData falsePredicateData);
    protected sealed virtual void StopTrackingPredicatedData(AnalysisEntity predicatedEntity);
    protected sealed virtual bool HasPredicatedDataForEntity(TAnalysisData analysisData, AnalysisEntity predicatedEntity);
    protected sealed virtual void TransferPredicatedData(AnalysisEntity fromEntity, AnalysisEntity toEntity);
    protected sealed virtual PredicateValueKind ApplyPredicatedDataForEntity(TAnalysisData analysisData, AnalysisEntity predicatedEntity, bool trueData);
    protected virtual void SetPredicateValueKind(IOperation operation, TAnalysisData analysisData, PredicateValueKind predicateValueKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2 : AbstractAnalysisData {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> _lazyPredicateDataMap;
    [CompilerGeneratedAttribute]
private bool <IsReachableBlockData>k__BackingField;
    public bool IsReachableBlockData { get; public set; }
    public bool HasPredicatedData { get; }
    protected PredicatedAnalysisData`2(PredicatedAnalysisData`2<TKey, TValue> fromData);
    protected PredicatedAnalysisData`2(PredicatedAnalysisData`2<TKey, TValue> predicatedData1, PredicatedAnalysisData`2<TKey, TValue> predicatedData2, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData1, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData2, bool isReachableData, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain);
    [CompilerGeneratedAttribute]
public bool get_IsReachableBlockData();
    [CompilerGeneratedAttribute]
public void set_IsReachableBlockData(bool value);
    public bool get_HasPredicatedData();
    [ConditionalAttribute("DEBUG")]
private void AssertValidAnalysisData();
    private void EnsurePredicatedData();
    protected void StartTrackingPredicatedData(AnalysisEntity predicatedEntity, DictionaryAnalysisData`2<TKey, TValue> truePredicatedData, DictionaryAnalysisData`2<TKey, TValue> falsePredicatedData);
    public void StopTrackingPredicatedData(AnalysisEntity predicatedEntity);
    public bool HasPredicatedDataForEntity(AnalysisEntity predicatedEntity);
    public void TransferPredicatedData(AnalysisEntity fromEntity, AnalysisEntity toEntity);
    protected PredicateValueKind ApplyPredicatedDataForEntity(DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData, AnalysisEntity predicatedEntity, bool trueData);
    protected virtual void ApplyPredicatedData(DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData, DictionaryAnalysisData`2<TKey, TValue> predicatedData);
    protected void RemoveEntriesInPredicatedData(TKey key);
    protected virtual void RemoveEntryInPredicatedData(TKey key, DictionaryAnalysisData`2<TKey, TValue> predicatedData);
    private static DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> Clone(DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> fromData);
    private static DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> Merge(DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData1, DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData2, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData1, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData2, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain, Action`2<DictionaryAnalysisData`2<TKey, TValue>, DictionaryAnalysisData`2<TKey, TValue>> applyPredicatedData);
    private static DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> MergeForPredicatedDataInOneBranch(DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisDataForOtherBranch, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain);
    private static DictionaryAnalysisData`2<TKey, TValue> MergeForPredicatedDataInOneBranch(DictionaryAnalysisData`2<TKey, TValue> predicatedData, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisDataForOtherBranch, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain);
    private static DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> MergeForPredicatedDataInBothBranches(DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData1, DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData2, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData1, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData2, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain, Action`2<DictionaryAnalysisData`2<TKey, TValue>, DictionaryAnalysisData`2<TKey, TValue>> applyPredicatedData);
    private static DictionaryAnalysisData`2<TKey, TValue> Merge(DictionaryAnalysisData`2<TKey, TValue> predicateTrueOrFalseData1, DictionaryAnalysisData`2<TKey, TValue> predicateTrueOrFalseData2, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData1, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData2, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain, Action`2<DictionaryAnalysisData`2<TKey, TValue>, DictionaryAnalysisData`2<TKey, TValue>> applyPredicatedData);
    private static DictionaryAnalysisData`2<TKey, TValue> CloneAndApplyPredicatedData(DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData, DictionaryAnalysisData`2<TKey, TValue> predicateTrueOrFalseData, Action`2<DictionaryAnalysisData`2<TKey, TValue>, DictionaryAnalysisData`2<TKey, TValue>> applyPredicatedData);
    protected int BaseCompareHelper(PredicatedAnalysisData`2<TKey, TValue> newData);
    protected bool Equals(PredicatedAnalysisData`2<TKey, TValue> other);
    protected static bool EqualsHelper(DictionaryAnalysisData`2<TKey, TValue> dict1, DictionaryAnalysisData`2<TKey, TValue> dict2);
    protected void ResetPredicatedData();
    [ConditionalAttribute("DEBUG")]
protected void AssertValidPredicatedAnalysisData(Action`1<DictionaryAnalysisData`2<TKey, TValue>> assertValidAnalysisData);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisDataDomain`2 : AbstractAnalysisDomain`1<TAnalysisData> {
    [CompilerGeneratedAttribute]
private MapAbstractDomain`2<AnalysisEntity, TValue> <CoreDataAnalysisDomain>k__BackingField;
    protected MapAbstractDomain`2<AnalysisEntity, TValue> CoreDataAnalysisDomain { get; }
    public PredicatedAnalysisDataDomain`2(MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    [CompilerGeneratedAttribute]
protected MapAbstractDomain`2<AnalysisEntity, TValue> get_CoreDataAnalysisDomain();
    public virtual TAnalysisData Clone(TAnalysisData value);
    public virtual int Compare(TAnalysisData oldValue, TAnalysisData newValue);
    public virtual bool Equals(TAnalysisData value1, TAnalysisData value2);
    public virtual TAnalysisData Merge(TAnalysisData value1, TAnalysisData value2);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicateValueKind : Enum {
    public int value__;
    public static PredicateValueKind AlwaysTrue;
    public static PredicateValueKind AlwaysFalse;
    public static PredicateValueKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.SetAbstractDomain`1 : AbstractDomain`1<ImmutableHashSet`1<T>> {
    [CompilerGeneratedAttribute]
private static SetAbstractDomain`1<T> <Default>k__BackingField;
    public static SetAbstractDomain`1<T> Default { get; }
    public ImmutableHashSet`1<T> Bottom { get; }
    private static SetAbstractDomain`1();
    [CompilerGeneratedAttribute]
public static SetAbstractDomain`1<T> get_Default();
    public virtual ImmutableHashSet`1<T> get_Bottom();
    public virtual int Compare(ImmutableHashSet`1<T> oldValue, ImmutableHashSet`1<T> newValue, bool assertMonotonicity);
    public virtual ImmutableHashSet`1<T> Merge(ImmutableHashSet`1<T> value1, ImmutableHashSet`1<T> value2);
    public ImmutableHashSet`1<T> Intersect(ImmutableHashSet`1<T> value1, ImmutableHashSet`1<T> value2);
    private static ImmutableHashSet`1<T> MergeOrIntersect(ImmutableHashSet`1<T> value1, ImmutableHashSet`1<T> value2, bool merge);
}
internal static class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.StackGuard : object {
    public static int MaxUncheckedRecursionDepth;
    public static void EnsureSufficientExecutionStack(int recursionDepth);
    [NullableContextAttribute("1")]
public static bool IsInsufficientExecutionStackException(Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ThrownExceptionInfo : object {
    [CompilerGeneratedAttribute]
private int <BasicBlockOrdinal>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ControlFlowRegion <HandlingCatchRegion>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ControlFlowRegion <ContainingFinallyRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableStack`1<IOperation> <InterproceduralCallStack>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultExceptionForExceptionsPathAnalysis>k__BackingField;
    internal int BasicBlockOrdinal { get; }
    [NullableAttribute("2")]
internal ControlFlowRegion HandlingCatchRegion { get; }
    [NullableAttribute("2")]
internal ControlFlowRegion ContainingFinallyRegion { get; }
    internal INamedTypeSymbol ExceptionType { get; }
    internal ImmutableStack`1<IOperation> InterproceduralCallStack { get; }
    internal bool IsDefaultExceptionForExceptionsPathAnalysis { get; }
    private ThrownExceptionInfo(BasicBlock block, INamedTypeSymbol exceptionType, ImmutableStack`1<IOperation> interproceduralCallStack, bool isDefaultExceptionForExceptionsPathAnalysis);
    internal static ThrownExceptionInfo Create(BasicBlock block, INamedTypeSymbol exceptionType, ImmutableStack`1<IOperation> interproceduralCallStack);
    internal static ThrownExceptionInfo CreateDefaultInfoForExceptionsPathAnalysis(BasicBlock block, WellKnownTypeProvider wellKnownTypeProvider, ImmutableStack`1<IOperation> interproceduralCallStack);
    private static ControlFlowRegion GetHandlerRegion(BasicBlock block, INamedTypeSymbol exceptionType);
    internal ThrownExceptionInfo With(BasicBlock block, ImmutableStack`1<IOperation> interproceduralCallStack);
    [CompilerGeneratedAttribute]
internal int get_BasicBlockOrdinal();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ControlFlowRegion get_HandlingCatchRegion();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ControlFlowRegion get_ContainingFinallyRegion();
    [CompilerGeneratedAttribute]
internal INamedTypeSymbol get_ExceptionType();
    [CompilerGeneratedAttribute]
internal ImmutableStack`1<IOperation> get_InterproceduralCallStack();
    [CompilerGeneratedAttribute]
internal bool get_IsDefaultExceptionForExceptionsPathAnalysis();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ThrownExceptionInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContainsNonLiteralState : Enum {
    public int value__;
    public static ValueContainsNonLiteralState Invalid;
    public static ValueContainsNonLiteralState Undefined;
    public static ValueContainsNonLiteralState No;
    public static ValueContainsNonLiteralState Maybe;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue : CacheBasedEquatable`1<ValueContentAbstractValue> {
    private static int LiteralsBound;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <UndefinedState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <InvalidState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <MayBeContainsNonLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <DoesNotContainLiteralOrNonLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsNullLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsEmptyStringLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsZeroIntergralLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsOneIntergralLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsTrueLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsFalseLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueContainsNonLiteralState <NonLiteralState>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<object> <LiteralValues>k__BackingField;
    public static ValueContentAbstractValue UndefinedState { get; }
    public static ValueContentAbstractValue InvalidState { get; }
    public static ValueContentAbstractValue MayBeContainsNonLiteralState { get; }
    public static ValueContentAbstractValue DoesNotContainLiteralOrNonLiteralState { get; }
    public static ValueContentAbstractValue ContainsNullLiteralState { get; }
    public static ValueContentAbstractValue ContainsEmptyStringLiteralState { get; }
    public static ValueContentAbstractValue ContainsZeroIntergralLiteralState { get; }
    public static ValueContentAbstractValue ContainsOneIntergralLiteralState { get; }
    private static ValueContentAbstractValue ContainsTrueLiteralState { get; }
    private static ValueContentAbstractValue ContainsFalseLiteralState { get; }
    public ValueContainsNonLiteralState NonLiteralState { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableHashSet`1<object> LiteralValues { get; }
    public bool IsLiteralState { get; }
    private ValueContentAbstractValue(ImmutableHashSet`1<object> literalValues, ValueContainsNonLiteralState nonLiteralState);
    private static ValueContentAbstractValue();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_UndefinedState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_InvalidState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_MayBeContainsNonLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_DoesNotContainLiteralOrNonLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_ContainsNullLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_ContainsEmptyStringLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_ContainsZeroIntergralLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_ContainsOneIntergralLiteralState();
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue get_ContainsTrueLiteralState();
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue get_ContainsFalseLiteralState();
    internal static ValueContentAbstractValue Create(object literal, ITypeSymbol type);
    private static ValueContentAbstractValue Create(ImmutableHashSet`1<object> literalValues, ValueContainsNonLiteralState nonLiteralState);
    internal static bool IsSupportedType(ITypeSymbol type, ITypeSymbol& valueTypeSymbol);
    [CompilerGeneratedAttribute]
public ValueContainsNonLiteralState get_NonLiteralState();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<object> get_LiteralValues();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<ValueContentAbstractValue> obj);
    internal ValueContentAbstractValue Merge(ValueContentAbstractValue otherState);
    private static ValueContainsNonLiteralState Merge(ValueContainsNonLiteralState value1, ValueContainsNonLiteralState value2);
    public bool get_IsLiteralState();
    public bool TryGetSingleNonNullLiteral(T& literalValue);
    internal ValueContentAbstractValue IntersectLiteralValues(ValueContentAbstractValue value2);
    [NullableContextAttribute("2")]
internal ValueContentAbstractValue MergeBinaryOperation(ValueContentAbstractValue otherState, BinaryOperatorKind binaryOperatorKind, ITypeSymbol leftType, ITypeSymbol rightType, ITypeSymbol resultType);
    public virtual string ToString();
    [NullableContextAttribute("2")]
private static bool TryMerge(object value1, object value2, BinaryOperatorKind binaryOperatorKind, ITypeSymbol type1, ITypeSymbol type2, ITypeSymbol resultType, Object& result);
    [NullableContextAttribute("2")]
private static bool TryMerge(char value1, char value2, BinaryOperatorKind binaryOperatorKind, Object& result);
    private static bool TryMerge(string value1, string value2, BinaryOperatorKind binaryOperatorKind, Object& result);
    [NullableContextAttribute("2")]
private static bool TryMerge(bool value1, bool value2, BinaryOperatorKind binaryOperatorKind, Object& result);
    private static bool TryMerge(ulong value1, ulong value2, BinaryOperatorKind binaryOperatorKind, UInt64& result);
    private static bool TryMerge(double value1, double value2, BinaryOperatorKind binaryOperatorKind, Double& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis : ForwardDataFlowAnalysis`5<ValueContentAnalysisData, ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>, ValueContentBlockAnalysisResult, ValueContentAbstractValue> {
    internal static AbstractValueDomain`1<ValueContentAbstractValue> ValueDomainInstance;
    private ValueContentAnalysis(ValueContentAnalysisDomain analysisDomain, ValueContentDataFlowOperationVisitor operationVisitor);
    private static ValueContentAnalysis();
    public static DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, PointsToAnalysisKind defaultPointsToAnalysisKind, InterproceduralAnalysisKind interproceduralAnalysisKind, bool pessimisticAnalysis);
    public static DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, PointsToAnalysisKind defaultPointsToAnalysisKind, DataFlowAnalysisResult`2& copyAnalysisResult, PointsToAnalysisResult& pointsToAnalysisResult, InterproceduralAnalysisKind interproceduralAnalysisKind, bool pessimisticAnalysis, bool performCopyAnalysisIfNotUserConfigured, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, ImmutableArray`1<INamedTypeSymbol> additionalSupportedValueTypes, Func`2<IOperation, ValueContentAbstractValue> getValueContentValueForAdditionalSupportedValueTypeOperation);
    internal static DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, PointsToAnalysisKind pointsToAnalysisKind, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, DataFlowAnalysisResult`2& copyAnalysisResult, PointsToAnalysisResult& pointsToAnalysisResult, bool pessimisticAnalysis, bool performCopyAnalysis, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate, ImmutableArray`1<INamedTypeSymbol> additionalSupportedValueTypes, Func`2<IOperation, ValueContentAbstractValue> getValueContentValueForAdditionalSupportedValueTypeOperation);
    private static DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> TryGetOrComputeResultForAnalysisContext(ValueContentAnalysisContext analysisContext);
    protected virtual DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> ToResult(ValueContentAnalysisContext analysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> dataFlowAnalysisResult);
    protected virtual ValueContentBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, ValueContentAnalysisData blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysisContext : AbstractDataFlowAnalysisContext`4<ValueContentAnalysisData, ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>, ValueContentAbstractValue> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<INamedTypeSymbol> <AdditionalSupportedValueTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<IOperation, ValueContentAbstractValue> <GetValueForAdditionalSupportedValueTypeOperation>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<INamedTypeSymbol> AdditionalSupportedValueTypes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<IOperation, ValueContentAbstractValue> GetValueForAdditionalSupportedValueTypeOperation { get; }
    private ValueContentAnalysisContext(AbstractValueDomain`1<ValueContentAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, PointsToAnalysisResult pointsToAnalysisResult, Func`2<ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>> tryGetOrComputeAnalysisResult, ImmutableArray`1<INamedTypeSymbol> additionalSupportedValueTypes, Func`2<IOperation, ValueContentAbstractValue> getValueForAdditionalSupportedValueTypeOperation, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<ValueContentAnalysisData, ValueContentAnalysisContext, ValueContentAbstractValue> interproceduralAnalysisData, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<INamedTypeSymbol> get_AdditionalSupportedValueTypes();
    [CompilerGeneratedAttribute]
public Func`2<IOperation, ValueContentAbstractValue> get_GetValueForAdditionalSupportedValueTypeOperation();
    internal static ValueContentAnalysisContext Create(AbstractValueDomain`1<ValueContentAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, PointsToAnalysisResult pointsToAnalysisResult, Func`2<ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>> tryGetOrComputeAnalysisResult, ImmutableArray`1<INamedTypeSymbol> additionalSupportedValueTypes, Func`2<IOperation, ValueContentAbstractValue> getValueContentValueForAdditionalSupportedValueTypeOperation, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    public virtual ValueContentAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<ValueContentAnalysisData, ValueContentAnalysisContext, ValueContentAbstractValue> interproceduralAnalysisData);
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<ValueContentAnalysisData, ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>, ValueContentAbstractValue> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysisData : AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> {
    protected AbstractValueDomain`1<ValueContentAbstractValue> ValueDomain { get; }
    internal ValueContentAnalysisData(IDictionary`2<AnalysisEntity, ValueContentAbstractValue> fromData);
    private ValueContentAnalysisData(ValueContentAnalysisData fromData);
    private ValueContentAnalysisData(ValueContentAnalysisData data1, ValueContentAnalysisData data2, MapAbstractDomain`2<AnalysisEntity, ValueContentAbstractValue> coreDataAnalysisDomain);
    internal ValueContentAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, ValueContentAbstractValue> mergedCoreAnalysisData, PredicatedAnalysisData`2<AnalysisEntity, ValueContentAbstractValue> predicatedData1, PredicatedAnalysisData`2<AnalysisEntity, ValueContentAbstractValue> predicatedData2, bool isReachableData, MapAbstractDomain`2<AnalysisEntity, ValueContentAbstractValue> coreDataAnalysisDomain);
    protected virtual AbstractValueDomain`1<ValueContentAbstractValue> get_ValueDomain();
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> Clone();
    public virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> other, MapAbstractDomain`2<AnalysisEntity, ValueContentAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> data, MapAbstractDomain`2<AnalysisEntity, ValueContentAbstractValue> coreDataAnalysisDomain);
    internal void Reset(ValueContentAbstractValue resetValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, ValueContentAbstractValue> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReachable>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, ValueContentAbstractValue> Data { get; }
    public bool IsReachable { get; }
    internal ValueContentBlockAnalysisResult(BasicBlock basicBlock, ValueContentAnalysisData blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, ValueContentAbstractValue> get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.NetAnalyzers.AbstractGlobalizationDiagnosticAnalyzer : DiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private GeneratedCodeAnalysisFlags <GeneratedCodeAnalysisFlags>k__BackingField;
    protected GeneratedCodeAnalysisFlags GeneratedCodeAnalysisFlags { get; }
    [CompilerGeneratedAttribute]
protected virtual GeneratedCodeAnalysisFlags get_GeneratedCodeAnalysisFlags();
    public sealed virtual void Initialize(AnalysisContext context);
    protected abstract virtual void InitializeWorker(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__3_0(CompilationStartAnalysisContext context);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ReportDiagnosticExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToAnalyzerConfigString(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static Nullable`1<DiagnosticSeverity> ToDiagnosticSeverity(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static bool IsLessSevereThan(ReportDiagnostic current, ReportDiagnostic other);
}
internal enum Microsoft.CodeAnalysis.RuleLevel : Enum {
    public int value__;
    public static RuleLevel BuildError;
    public static RuleLevel BuildWarning;
    public static RuleLevel BuildWarningCandidate;
    public static RuleLevel IdeSuggestion;
    public static RuleLevel IdeHidden_BulkConfigurable;
    public static RuleLevel Disabled;
    public static RuleLevel CandidateForRemoval;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter : object {
    private static string RuleSetNodeName;
    private static string RuleSetNameAttributeName;
    private static string RuleSetDescriptionAttributeName;
    private static string RulesNodeName;
    private static string RuleNodeName;
    private static string RuleIdAttributeName;
    public static void GenerateEditorconfig(string rulesetFilePath, string editorconfigFilePath);
    public static string GetEditorconfig(string rulesetFilePath);
    [CompilerGeneratedAttribute]
internal static XElement <GetEditorconfig>g__GetTopLevelRulesetNode|7_0(string rulesetFilePath);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__ProcessComments|7_1(RuleSet ruleset, HashSet`1<string> processedRulesetPaths, Dictionary`2<string, string> ruleIdToComments);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__PopulateRuleIdToComments|7_2(string rulesetFilePath, Dictionary`2<string, string> ruleIdToComments);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__AppendComment|7_5(XComment comment, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__UpdateCurrentRuleIdPostCommentAndResetState|7_6(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__AppendComment|7_3(StringBuilder builder, string comment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.WellKnownDiagnosticTagsExtensions : object {
    public static string EnabledRuleInAggressiveMode;
    public static string Dataflow;
    public static string CompilationEnd;
    public static String[] DataflowAndTelemetry;
    public static String[] DataflowAndTelemetryEnabledInAggressiveMode;
    public static String[] Telemetry;
    public static String[] TelemetryEnabledInAggressiveMode;
    public static String[] CompilationEndAndTelemetry;
    private static WellKnownDiagnosticTagsExtensions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.AbstractTypesShouldNotHaveConstructorsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AbstractTypesShouldNotHaveConstructorsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.AbstractTypesShouldNotHaveConstructorsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.AbstractTypesShouldNotHaveConstructorsFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static SyntaxNode GetDeclaration(ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.AbstractTypesShouldNotHaveConstructorsFixer/<ChangeAccessibilityCodeFixAsync>d__5")]
private static Task`1<Document> ChangeAccessibilityCodeFixAsync(Document document, SyntaxNode root, SyntaxNode nodeToFix, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.AvoidEmptyInterfacesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidEmptyInterfacesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInterface(SymbolAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.AvoidEmptyInterfacesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.AvoidExcessiveParametersOnGenericTypes : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static int MaximumNumberOfTypeParameters;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidExcessiveParametersOnGenericTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.AvoidOutParameters : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidOutParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.CancellationTokenParametersMustComeLastAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CancellationTokenParametersMustComeLastAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.CollectionPropertiesShouldBeReadOnlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CollectionPropertiesShouldBeReadOnlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, KnownTypes knownTypes);
    private static bool Inherits(ITypeSymbol symbol, ITypeSymbol baseType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.CollectionsShouldImplementGenericInterfaceAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor Rule;
    internal static DiagnosticDescriptor RuleMultiple;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CollectionsShouldImplementGenericInterfaceAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, ImmutableArray`1<KeyValuePair`2<INamedTypeSymbol, ImmutableArray`1<INamedTypeSymbol>>> interfacePairs);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeSymbol>g__ReportDiagnostic|9_0(INamedTypeSymbol interface, INamedTypeSymbol genericInterface, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static void <AnalyzeSymbol>g__ReportDiagnosticAlt|9_1(INamedTypeSymbol interface, IEnumerable`1<INamedTypeSymbol> genericInterfaces, <>c__DisplayClass9_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.CollectionsShouldImplementGenericInterfaceFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DeclareTypesInNamespacesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DeclareTypesInNamespacesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DeclareTypesInNamespacesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DefineAccessorsForAttributeArgumentsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string AddAccessorCase;
    internal static string MakePublicCase;
    internal static string RemoveSetterCase;
    private static LocalizableString s_localizableTitle;
    internal static DiagnosticDescriptor DefaultRule;
    internal static DiagnosticDescriptor IncreaseVisibilityRule;
    internal static DiagnosticDescriptor RemoveSetterRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DefineAccessorsForAttributeArgumentsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(INamedTypeSymbol symbol, INamedTypeSymbol attributeType, Compilation compilation, Action`1<Diagnostic> addDiagnostic);
    [IteratorStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DefineAccessorsForAttributeArgumentsAnalyzer/<GetAllPublicConstructorParameters>d__13")]
private static IEnumerable`1<IParameterSymbol> GetAllPublicConstructorParameters(INamedTypeSymbol attributeType);
    private static IDictionary`2<string, IPropertySymbol> GetAllPropertiesInTypeChain(INamedTypeSymbol attributeType);
    private static void AnalyzeParameters(Compilation compilation, IEnumerable`1<IParameterSymbol> parameters, IDictionary`2<string, IPropertySymbol> propertiesMap, INamedTypeSymbol attributeType, Action`1<Diagnostic> addDiagnostic);
    private static Diagnostic GetDefaultDiagnostic(IParameterSymbol parameter, INamedTypeSymbol attributeType);
    private static Diagnostic GetIncreaseVisibilityDiagnostic(IParameterSymbol parameter, IPropertySymbol property);
    private static Diagnostic GetRemoveSetterDiagnostic(IParameterSymbol parameter, IPropertySymbol property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DefineAccessorsForAttributeArgumentsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DefineAccessorsForAttributeArgumentsFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DefineAccessorsForAttributeArgumentsFixer/<AddAccessorAsync>d__4")]
private static Task`1<Document> AddAccessorAsync(Document document, SyntaxNode parameter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DefineAccessorsForAttributeArgumentsFixer/<MakePublicAsync>d__5")]
private static Task`1<Document> MakePublicAsync(Document document, SyntaxNode getMethod, SyntaxNode property, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DefineAccessorsForAttributeArgumentsFixer/<RemoveSetterAsync>d__6")]
private static Task`1<Document> RemoveSetterAsync(Document document, SyntaxNode setMethod, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotCatchGeneralExceptionTypesAnalyzer : DoNotCatchGeneralUnlessRethrownAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCatchGeneralExceptionTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual Diagnostic CreateDiagnostic(IMethodSymbol containingMethod, SyntaxToken catchKeyword);
    protected virtual bool IsConfiguredDisallowedExceptionType(INamedTypeSymbol namedTypeSymbol, IMethodSymbol containingMethod, Compilation compilation, AnalyzerOptions analyzerOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotDeclareProtectedMembersInSealedTypes : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDeclareProtectedMembersInSealedTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsAnyProtectedVariant(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotDeclareStaticMembersOnGenericTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDeclareStaticMembersOnGenericTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotDeclareVisibleInstanceFieldsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDeclareVisibleInstanceFieldsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotDirectlyAwaitATaskAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    public static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDirectlyAwaitATaskAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeAwaitOperation(OperationAnalysisContext context, ImmutableArray`1<INamedTypeSymbol> taskTypes);
    private static void AnalyzeUsingOperation(OperationAnalysisContext context, INamedTypeSymbol configuredAsyncDisposable);
    private static void AnalyzeUsingDeclarationOperation(OperationAnalysisContext context, INamedTypeSymbol configuredAsyncDisposable);
    private static bool TryGetTaskTypes(Compilation compilation, ImmutableArray`1& taskTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotDirectlyAwaitATaskFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotDirectlyAwaitATaskFixer/<RegisterCodeFixesAsync>d__3")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotDirectlyAwaitATaskFixer/<GetFixAsync>d__4")]
private static Task`1<Document> GetFixAsync(Document document, SyntaxNode expression, bool argument, CancellationToken cancellationToken);
    private static void FixDiagnostic(DocumentEditor editor, SyntaxNode expression, bool argument);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotExposeGenericLists : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotExposeGenericLists();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotHideBaseClassMethodsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    public static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotHideBaseClassMethodsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void SymbolAnalyzer(SymbolAnalysisContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotHideBaseClassMethodsAnalyzer/<GetMethodsHiddenByMethod>d__7")]
private static IEnumerable`1<IMethodSymbol> GetMethodsHiddenByMethod(IMethodSymbol method, INamedTypeSymbol baseType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotHideBaseClassMethodsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotNameEnumValuesReserved : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> reservedWords;
    public static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotNameEnumValuesReserved();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotOverloadOperatorEqualsOnReferenceTypes : DiagnosticAnalyzer {
    internal static string RuleId;
    public static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotOverloadOperatorEqualsOnReferenceTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotPassTypesByReference : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotPassTypesByReference();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotPrefixEnumValuesWithTypeNameAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static int PercentValuesPrefixedThreshold;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotPrefixEnumValuesWithTypeNameAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedType(SymbolAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.DoNotRaiseExceptionsInUnexpectedLocationsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor PropertyGetterRule;
    internal static DiagnosticDescriptor HasAllowedExceptionsRule;
    internal static DiagnosticDescriptor NoAllowedExceptionsRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotRaiseExceptionsInUnexpectedLocationsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static List`1<MethodCategory> GetMethodCategories(Compilation compilation);
    private static bool IsPropertyGetter(IMethodSymbol method, Compilation compilation);
    private static bool IsIndexerGetter(IMethodSymbol method, Compilation compilation);
    private static bool IsEventAccessor(IMethodSymbol method, Compilation compilation);
    private static bool IsEqualsOverrideOrInterfaceImplementation(IMethodSymbol method, Compilation compilation);
    private static bool IsEqualsInterfaceImplementation(IMethodSymbol method, Compilation compilation);
    private static bool IsGetHashCodeInterfaceImplementation(IMethodSymbol method, Compilation compilation);
    private static bool IsGetHashCodeOverride(IMethodSymbol method, Compilation compilation);
    private static bool IsToString(IMethodSymbol method, Compilation compilation);
    private static bool IsStaticConstructor(IMethodSymbol method, Compilation compilation);
    private static bool IsFinalizer(IMethodSymbol method, Compilation compilation);
    private static bool IsComparisonOperator(IMethodSymbol method, Compilation compilation);
    private static bool IsImplicitCastOperator(IMethodSymbol method, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumShouldNotHaveDuplicatedValues : DiagnosticAnalyzer {
    public static string RuleId;
    private static LocalizableString s_localizableTitle;
    internal static DiagnosticDescriptor RuleDuplicatedValue;
    internal static DiagnosticDescriptor RuleDuplicatedBitwiseValuePart;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EnumShouldNotHaveDuplicatedValues();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__visitEnumSymbol|7_0(SymbolStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__visitInitializerValue|7_3(IOperation operation, <>c__DisplayClass7_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumsShouldHaveZeroValueAnalyzer : DiagnosticAnalyzer {
    public static string RuleId;
    public static string RuleRenameCustomTag;
    public static string RuleMultipleZeroCustomTag;
    public static string RuleNoZeroCustomTag;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor RuleRename;
    internal static DiagnosticDescriptor RuleMultipleZero;
    internal static DiagnosticDescriptor RuleNoZero;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EnumsShouldHaveZeroValueAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol flagsAttribute);
    private static void CheckFlags(INamedTypeSymbol namedType, ImmutableArray`1<IFieldSymbol> zeroValuedFields, SymbolAnalysisContext context);
    private static void CheckNonFlags(INamedTypeSymbol namedType, ImmutableArray`1<IFieldSymbol> zeroValuedFields, Action`1<Diagnostic> addDiagnostic);
    [IteratorStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumsShouldHaveZeroValueAnalyzer/<GetZeroValuedFields>d__16")]
internal static IEnumerable`1<IFieldSymbol> GetZeroValuedFields(INamedTypeSymbol enumType);
    [NullableContextAttribute("2")]
private static bool IsZeroValueConstant(object value, SpecialType specialType);
    public static bool IsMemberNamedNone(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumsShouldHaveZeroValueFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumsShouldHaveZeroValueFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    private static SyntaxNode GetExplicitlyAssignedField(IFieldSymbol originalField, SyntaxNode declaration, SyntaxGenerator generator);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumsShouldHaveZeroValueFixer/<GetUpdatedDocumentForRuleNameRenameAsync>d__6")]
private static Task`1<Document> GetUpdatedDocumentForRuleNameRenameAsync(Document document, IFieldSymbol field, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumsShouldHaveZeroValueFixer/<ApplyRuleNameMultipleZeroAsync>d__7")]
private static Task`1<Document> ApplyRuleNameMultipleZeroAsync(Document document, INamedTypeSymbol enumType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumsShouldHaveZeroValueFixer/<ApplyRuleNameNoZeroValueAsync>d__8")]
private static Task`1<Document> ApplyRuleNameNoZeroValueAsync(Document document, INamedTypeSymbol enumType, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetParentNodeOrSelfToFix(SyntaxNode nodeToFix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumStorageShouldBeInt32Analyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EnumStorageShouldBeInt32Analyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol flagsAttribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumStorageShouldBeInt32Fixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual SyntaxNode GetTargetNode(SyntaxNode node);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumStorageShouldBeInt32Fixer/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumStorageShouldBeInt32Fixer/<ChangeEnumTypeToInt32Async>d__6")]
private Task`1<Document> ChangeEnumTypeToInt32Async(Document document, Diagnostic diagnostic, SyntaxNode root, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumWithFlagsAttributeAnalyzer : DiagnosticAnalyzer {
    internal static string RuleIdMarkEnumsWithFlags;
    internal static string RuleIdDoNotMarkEnumsWithFlags;
    internal static string RuleNameForExportAttribute;
    internal static DiagnosticDescriptor Rule1027;
    internal static DiagnosticDescriptor Rule2217;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EnumWithFlagsAttributeAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext symbolContext, INamedTypeSymbol flagsAttributeType);
    private static bool IsContiguous(IList`1<ulong> list);
    private static bool ShouldBeFlags(IList`1<ulong> enumValues, IEnumerable`1& missingValues);
    private static bool ShouldBeFlags(IList`1<ulong> enumValues);
    private static ulong GetMissingBitsInBinaryForm(IList`1<ulong> values);
    [IteratorStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumWithFlagsAttributeAnalyzer/<GetIndividualBits>d__14")]
private static IEnumerable`1<ulong> GetIndividualBits(ulong value);
    private static bool IsPowerOfTwo(ulong number);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumWithFlagsAttributeFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumWithFlagsAttributeFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EnumWithFlagsAttributeFixer/<AddOrRemoveFlagsAttributeAsync>d__4")]
private static Task`1<Document> AddOrRemoveFlagsAttributeAsync(Document document, TextSpan span, string diagnosticId, INamedTypeSymbol flagsAttributeType, CancellationToken cancellationToken);
    private static SyntaxNode AddFlagsAttribute(SyntaxGenerator generator, SyntaxNode enumTypeSyntax, INamedTypeSymbol flagsAttributeType);
    private static SyntaxNode RemoveFlagsAttribute(SyntaxGenerator generator, SemanticModel model, SyntaxNode enumTypeSyntax, INamedTypeSymbol flagsAttributeType, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EquatableAnalyzer : DiagnosticAnalyzer {
    internal static string ImplementIEquatableRuleId;
    internal static string OverrideObjectEqualsRuleId;
    internal static DiagnosticDescriptor ImplementIEquatableDescriptor;
    internal static DiagnosticDescriptor OverridesObjectEqualsDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EquatableAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol equatableType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EquatableFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EquatableFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool TypeImplementsEquatable(INamedTypeSymbol type, INamedTypeSymbol equatableType);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EquatableFixer/<ImplementEquatableInStructAsync>d__6")]
private static Task`1<Document> ImplementEquatableInStructAsync(Document document, SyntaxNode declaration, INamedTypeSymbol typeSymbol, Compilation compilation, INamedTypeSymbol equatableType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EquatableFixer/<OverrideObjectEqualsAsync>d__7")]
private static Task`1<Document> OverrideObjectEqualsAsync(Document document, SyntaxNode declaration, INamedTypeSymbol typeSymbol, INamedTypeSymbol equatableType, CancellationToken cancellationToken);
    private static bool HasExplicitEqualsImplementation(INamedTypeSymbol typeSymbol, INamedTypeSymbol equatableType);
    private static SyntaxNode GetReturnStatementForExplicitClass(SyntaxGenerator generator, INamedTypeSymbol typeSymbol, SyntaxNode argumentName, INamedTypeSymbol equatableType);
    private static SyntaxNode GetReturnStatementForExplicitStruct(SyntaxGenerator generator, INamedTypeSymbol typeSymbol, SyntaxNode argumentName, INamedTypeSymbol equatableType);
    private static SyntaxNode GetReturnStatementForImplicitClass(SyntaxGenerator generator, INamedTypeSymbol typeSymbol, SyntaxNode argumentName);
    private static SyntaxNode GetReturnStatementForImplicitStruct(SyntaxGenerator generator, INamedTypeSymbol typeSymbol, SyntaxNode argumentName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.EventsShouldNotHaveBeforeOrAfterPrefix : DiagnosticAnalyzer {
    internal static string RuleId;
    private static string AfterKeyword;
    private static string BeforeKeyword;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableHashSet`1<string> s_invalidPrefixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static EventsShouldNotHaveBeforeOrAfterPrefix();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ExceptionsShouldBePublicAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static List`1<string> s_exceptionTypeNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ExceptionsShouldBePublicAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext csContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ExceptionsShouldBePublicFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ExceptionsShouldBePublicFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ExceptionsShouldBePublicFixer/<MakePublicAsync>d__5")]
private static Task`1<Document> MakePublicAsync(Document document, SyntaxNode classDecl, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.Helpers.EnumHelpers : object {
    [NullableContextAttribute("2")]
internal static bool TryConvertToUInt64(object value, SpecialType specialType, UInt64& convertedValue);
    [NullableContextAttribute("1")]
internal static bool TryGetEnumMemberValues(INamedTypeSymbol enumType, IList`1& values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldDifferByMoreThanCaseAnalyzer : DiagnosticAnalyzer {
    public static string RuleId;
    public static string Namespace;
    public static string Type;
    public static string Member;
    public static string Parameter;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IdentifiersShouldDifferByMoreThanCaseAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilation(CompilationAnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context);
    private static void CheckNamespaceMembers(IEnumerable`1<INamespaceSymbol> namespaces, CompilationAnalysisContext context);
    private static void CheckTypeMembers(IEnumerable`1<ISymbol> members, Action`1<Diagnostic> addDiagnostic);
    private static void CheckParameterMembers(IEnumerable`1<ISymbol> members, Action`1<Diagnostic> addDiagnostic);
    private static bool HasViolatingParameters(ISymbol symbol);
    private static void CheckTypeNames(IEnumerable`1<INamedTypeSymbol> types, CompilationAnalysisContext context);
    private static void CheckNamespaceNames(IEnumerable`1<INamespaceSymbol> namespaces, CompilationAnalysisContext context);
    private static string GetSymbolDisplayString(PooledHashSet`1<ISymbol> group);
    public static bool MatchesConfiguredVisibility(ISymbol symbol, AnalyzerOptions options, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static bool <CheckParameterMembers>g__IsViolatingMember|14_0(ISymbol member);
    [CompilerGeneratedAttribute]
internal static bool <CheckParameterMembers>g__IsViolatingDelegate|14_1(ISymbol member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldHaveCorrectPrefixAnalyzer : DiagnosticAnalyzer {
    public static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    public static DiagnosticDescriptor InterfaceRule;
    public static DiagnosticDescriptor TypeParameterRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IdentifiersShouldHaveCorrectPrefixAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeNamedTypeSymbol(INamedTypeSymbol symbol, bool allowSingleLetterTypeParameters, Action`2<TContext, Diagnostic> addDiagnostic, TContext context);
    private static void AnalyzeMethodSymbol(IMethodSymbol symbol, bool allowSingleLetterTypeParameters, Action`2<TContext, Diagnostic> addDiagnostic, TContext context);
    private static void AnalyzeTypeParameters(ImmutableArray`1<ITypeParameterSymbol> typeParameters, bool allowSingleLetterTypeParameters, Action`2<TContext, Diagnostic> addDiagnostic, TContext context);
    private static bool HasCorrectPrefix(ISymbol symbol, char prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldHaveCorrectPrefixFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldHaveCorrectSuffixAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static string CollectionSuffix;
    private static string DictionarySuffix;
    private static string SetSuffix;
    private static string QueueSuffix;
    private static string StackSuffix;
    private static string EventHandlerString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_setCollectionSuffixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_queueCollectionSuffixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_stackCollectionSuffixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_dictionaryCollectionSuffixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_collectionDictionarySetStackQueueSuffixes;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessageDefault;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor OneSuffixRule;
    internal static DiagnosticDescriptor MultipleSuffixesRule;
    internal static DiagnosticDescriptor UserSuffixRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, ImmutableArray`1<string>>> s_baseTypesAndTheirSuffix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IdentifiersShouldHaveCorrectSuffixAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static bool TryGetTypeSuffix(IEnumerable`1<INamedTypeSymbol> typeSymbols, ImmutableDictionary`2<INamedTypeSymbol, ImmutableArray`1<string>> hardcodedMap, SymbolNamesWithValueOption`1<string> userMap, ImmutableArray`1& suffixes, DiagnosticDescriptor& rule);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldHaveCorrectSuffixFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldNotContainTypeNames : DiagnosticAnalyzer {
    internal static string RuleId;
    private static ImmutableHashSet`1<string> s_typeNames;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IdentifiersShouldNotContainTypeNames();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(ISymbol symbol, SymbolAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldNotContainUnderscoresAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static IImmutableSet`1<string> s_GlobalAsaxSpecialMethodNames;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor AssemblyRule;
    internal static DiagnosticDescriptor NamespaceRule;
    internal static DiagnosticDescriptor TypeRule;
    internal static DiagnosticDescriptor MemberRule;
    internal static DiagnosticDescriptor TypeTypeParameterRule;
    internal static DiagnosticDescriptor MethodTypeParameterRule;
    internal static DiagnosticDescriptor MemberParameterRule;
    internal static DiagnosticDescriptor DelegateParameterRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IdentifiersShouldNotContainUnderscoresAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsInvalidSymbol(ISymbol symbol, SymbolAnalysisContext context);
    private static void AnalyzeParameters(SymbolAnalysisContext symbolAnalysisContext, IEnumerable`1<IParameterSymbol> parameters);
    private static void AnalyzeTypeParameters(SymbolAnalysisContext symbolAnalysisContext, IEnumerable`1<ITypeParameterSymbol> typeParameters);
    [NullableContextAttribute("2")]
private static bool ContainsUnderScore(string identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldNotContainUnderscoresFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual string GetNewName(string name);
    protected abstract virtual SyntaxNode GetDeclarationNode(SyntaxNode node);
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldNotContainUnderscoresFixer/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected static string RemoveUnderscores(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldNotHaveIncorrectSuffixAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor TypeNoAlternateRule;
    internal static DiagnosticDescriptor MemberNewerVersionRule;
    internal static DiagnosticDescriptor TypeNewerVersionRule;
    internal static DiagnosticDescriptor MemberWithAlternateRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    internal static string AttributeSuffix;
    internal static string CollectionSuffix;
    internal static string DictionarySuffix;
    internal static string EventArgsSuffix;
    internal static string EventHandlerSuffix;
    internal static string ExSuffix;
    internal static string ExceptionSuffix;
    internal static string NewSuffix;
    internal static string PermissionSuffix;
    internal static string StreamSuffix;
    internal static string DelegateSuffix;
    internal static string EnumSuffix;
    internal static string ImplSuffix;
    internal static string CoreSuffix;
    internal static string QueueSuffix;
    internal static string StackSuffix;
    internal static string FlagSuffix;
    internal static string FlagsSuffix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, ImmutableArray`1<string>> s_suffixToBaseTypeNamesDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, ImmutableArray`1<string>> s_suffixToAllowedTypesDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IdentifiersShouldNotHaveIncorrectSuffixAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool MemberNameExistsInHierarchy(string memberName, INamedTypeSymbol containingType, SymbolKind kind);
    private static bool IsNotChildOfAnyButHasSuffix(INamedTypeSymbol namedTypeSymbol, ImmutableArray`1<INamedTypeSymbol> parentTypes, string suffix, ImmutableHashSet`1<string> allowedSuffixes);
    private static bool IsInvalidSuffix(string name, string suffix, ImmutableHashSet`1<string> allowedSuffixes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldNotHaveIncorrectSuffixFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldNotMatchKeywordsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor MemberParameterRule;
    internal static DiagnosticDescriptor MemberRule;
    internal static DiagnosticDescriptor TypeRule;
    internal static DiagnosticDescriptor NamespaceRule;
    private static SymbolDisplayFormat s_namespaceDisplayFormat;
    private static ImmutableHashSet`1<SymbolKind> s_defaultAnalyzedSymbolKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableHashSet`1<string> s_caseSensitiveKeywords;
    private static ImmutableDictionary`2<string, string> s_caseInsensitiveKeywords;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static IdentifiersShouldNotMatchKeywordsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool ShouldAnalyze(SymbolAnalysisContext context, DiagnosticDescriptor rule);
    private static ImmutableHashSet`1<SymbolKind> GetSymbolKindsToAnalyze(SymbolAnalysisContext context, DiagnosticDescriptor rule);
    private static void AnalyzeTypeRule(SymbolAnalysisContext context);
    private static void AnalyzeMemberRule(SymbolAnalysisContext context);
    private static void AnalyzeMemberParameterRule(SymbolAnalysisContext context);
    private static bool IsKeyword(string name, String& keyword);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.IdentifiersShouldNotMatchKeywordsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ImplementIDisposableCorrectlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static string DisposeMethodName;
    private static string GarbageCollectorTypeName;
    private static string SuppressFinalizeMethodName;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor IDisposableReimplementationRule;
    internal static DiagnosticDescriptor FinalizeOverrideRule;
    internal static DiagnosticDescriptor DisposeOverrideRule;
    internal static DiagnosticDescriptor DisposeSignatureRule;
    internal static DiagnosticDescriptor RenameDisposeRule;
    internal static DiagnosticDescriptor DisposeBoolSignatureRule;
    internal static DiagnosticDescriptor DisposeImplementationRule;
    internal static DiagnosticDescriptor FinalizeImplementationRule;
    internal static DiagnosticDescriptor ProvideDisposeBoolRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ImplementIDisposableCorrectlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsDisposeBoolCall(IInvocationOperation invocationExpression, INamedTypeSymbol type, bool expectedValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ImplementIDisposableCorrectlyFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ImplementStandardExceptionConstructorsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor MissingConstructorRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ImplementStandardExceptionConstructorsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual string GetConstructorSignatureNoParameter(ISymbol symbol);
    protected abstract virtual string GetConstructorSignatureStringTypeParameter(ISymbol symbol);
    protected abstract virtual string GetConstructorSignatureStringAndExceptionTypeParameter(ISymbol symbol);
    private void AnalyzeCompilationSymbol(CompilationStartAnalysisContext context);
    private static void ReportDiagnostic(SymbolAnalysisContext context, INamedTypeSymbol namedTypeSymbol, MissingCtorSignature missingCtorSignature, string constructorSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ImplementStandardExceptionConstructorsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ImplementStandardExceptionConstructorsFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ImplementStandardExceptionConstructorsFixer/<AddConstructorsAsync>d__5")]
private static Task`1<Document> AddConstructorsAsync(Document document, IEnumerable`1<Diagnostic> diagnostics, SyntaxNode root, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.InterfaceMethodsShouldBeCallableByChildTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    public static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InterfaceMethodsShouldBeCallableByChildTypesAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private static bool ShouldExcludeOperationBlock(ImmutableArray`1<IOperation> operationBlocks);
    private static void AnalyzeOperationBlock(OperationBlockAnalysisContext context, INamedTypeSymbol iDisposableTypeSymbol);
    private static bool HasVisibleAlternate(INamedTypeSymbol namedType, IMethodSymbol interfaceMethod, INamedTypeSymbol iDisposableTypeSymbol);
    private static void ReportDiagnostic(OperationBlockAnalysisContext context, Object[] messageArgs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.InterfaceMethodsShouldBeCallableByChildTypesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.InterfaceMethodsShouldBeCallableByChildTypesFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static IMethodSymbol GetExistingNonVisibleAlternate(IMethodSymbol methodSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.InterfaceMethodsShouldBeCallableByChildTypesFixer/<MakeProtectedAsync>d__6")]
private static Task`1<Document> MakeProtectedAsync(Document document, ISymbol symbolToChange, bool checkSetter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.InterfaceMethodsShouldBeCallableByChildTypesFixer/<ChangeToPublicInterfaceImplementationAsync>d__7")]
private static Task`1<Document> ChangeToPublicInterfaceImplementationAsync(Document document, ISymbol symbolToChange, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static IEnumerable`1<ISymbol> GetExplicitImplementations(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.InterfaceMethodsShouldBeCallableByChildTypesFixer/<MakeContainingTypeSealedAsync>d__9")]
private static Task`1<Document> MakeContainingTypeSealedAsync(Document document, IMethodSymbol methodSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAssembliesWithAssemblyVersionFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAssembliesWithAttributesDiagnosticAnalyzer : DiagnosticAnalyzer {
    internal static string CA1016RuleId;
    internal static string CA1014RuleId;
    internal static DiagnosticDescriptor CA1016Rule;
    internal static DiagnosticDescriptor CA1014Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MarkAssembliesWithAttributesDiagnosticAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilation(CompilationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAssembliesWithClsCompliantFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAssembliesWithComVisibleAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor RuleChangeComVisible;
    internal static DiagnosticDescriptor RuleAddComVisible;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MarkAssembliesWithComVisibleAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilation(CompilationAnalysisContext context);
    private static bool AssemblyHasPublicTypes(IAssemblySymbol assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAssembliesWithComVisibleFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAttributesWithAttributeUsageAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MarkAttributesWithAttributeUsageAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(INamedTypeSymbol symbol, INamedTypeSymbol attributeType, INamedTypeSymbol attributeUsageAttributeType, Action`2<TContext, Diagnostic> addDiagnostic, TContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAttributesWithAttributeUsageFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAttributesWithAttributeUsageFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MarkAttributesWithAttributeUsageFixer/<AddAttributeUsageAttributeAsync>d__5")]
private static Task`1<Document> AddAttributeUsageAttributeAsync(Document document, SyntaxNode nodeToFix, INamedTypeSymbol attributeUsageAttributeType, INamedTypeSymbol attributeTargetsType, string attributeTargetValue, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MovePInvokesToNativeMethodsClassAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    private static string NativeMethodsText;
    private static string SafeNativeMethodsText;
    private static string UnsafeNativeMethodsText;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MovePInvokesToNativeMethodsClassAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(INamedTypeSymbol symbol, Action`2<TContext, Diagnostic> addDiagnostic, TContext context);
    private static bool IsDllImport(ISymbol symbol);
    private static bool IsTypeNamedCorrectly(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.MovePInvokesToNativeMethodsClassFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.NestedTypesShouldNotBeVisibleAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor DefaultRule;
    internal static DiagnosticDescriptor VisualBasicModuleRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NestedTypesShouldNotBeVisibleAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [NullableContextAttribute("2")]
private static bool IsDataSetSpecialCase(INamedTypeSymbol containingType, INamedTypeSymbol nestedType, INamedTypeSymbol dataSetType, INamedTypeSymbol dataTableType, INamedTypeSymbol dataRowType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.NonConstantFieldsShouldNotBeVisibleAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NonConstantFieldsShouldNotBeVisibleAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.NonConstantFieldsShouldNotBeVisibleFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OperatorOverloadsHaveNamedAlternatesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string DiagnosticKindText;
    internal static string AddAlternateText;
    internal static string FixVisibilityText;
    internal static string IsTrueText;
    private static string OpTrueText;
    private static string OpFalseText;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor DefaultRule;
    internal static DiagnosticDescriptor PropertyRule;
    internal static DiagnosticDescriptor MultipleRule;
    internal static DiagnosticDescriptor VisibilityRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OperatorOverloadsHaveNamedAlternatesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethod(IMethodSymbol methodSymbol, SymbolAnalysisContext symbolContext);
    private static Location GetSymbolLocation(ISymbol symbol);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, Location location, string kind, String[] messageArgs);
    internal static bool IsPropertyExpected(string operatorName);
    internal static ExpectedAlternateMethodGroup GetExpectedAlternateMethodGroup(string operatorName, ITypeSymbol returnType, ITypeSymbol parameterType);
    [CompilerGeneratedAttribute]
internal static ExpectedAlternateMethodGroup <GetExpectedAlternateMethodGroup>g__createSingle|21_0(string methodName);
    [CompilerGeneratedAttribute]
internal static string <GetExpectedAlternateMethodGroup>g__GetTypeName|21_1(ITypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OperatorOverloadsHaveNamedAlternatesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OperatorOverloadsHaveNamedAlternatesFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OperatorOverloadsHaveNamedAlternatesFixer/<FixAsync>d__5")]
private static Task`1<Document> FixAsync(CodeFixContext context, CancellationToken cancellationToken);
    private static ExpectedMethodSignature GetExpectedMethodSignature(IMethodSymbol operatorOverloadSymbol, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OperatorsShouldHaveSymmetricalOverloadsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OperatorsShouldHaveSymmetricalOverloadsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void CheckOperators(SymbolAnalysisContext analysisContext, INamedTypeSymbol namedType, string memberName1, string memberName2, string opName1, string opName2);
    private static void CheckOperators(SymbolAnalysisContext analysisContext, INamedTypeSymbol namedType, ImmutableArray`1<ISymbol> operators1, ImmutableArray`1<ISymbol> operators2, string opName1, string opName2);
    private static bool HasSymmetricOperator(ISymbol operator1, ImmutableArray`1<ISymbol> operators2);
    private static bool HasSameParameterTypes(ISymbol operator1, ISymbol operator2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OperatorsShouldHaveSymmetricalOverloadsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OperatorsShouldHaveSymmetricalOverloadsFixer/<CreateChangedDocumentAsync>d__5")]
private static Task`1<Document> CreateChangedDocumentAsync(CodeFixContext context, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OperatorsShouldHaveSymmetricalOverloadsFixer/<GetInvertedStatements>d__6")]
private static IEnumerable`1<SyntaxNode> GetInvertedStatements(SyntaxGenerator generator, IMethodSymbol containingOperator, Compilation compilation);
    private static SyntaxNode GetInvertedStatement(SyntaxGenerator generator, IMethodSymbol containingOperator, Compilation compilation);
    private static OperatorKind GetInvertedOperatorKind(IMethodSymbol containingOperator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverloadOperatorEqualsOnOverridingValueTypeEqualsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OverloadOperatorEqualsOnOverridingValueTypeEqualsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverloadOperatorEqualsOnOverridingValueTypeEqualsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverloadOperatorEqualsOnOverridingValueTypeEqualsFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverloadOperatorEqualsOnOverridingValueTypeEqualsFixer/<ImplementOperatorEqualsAsync>d__4")]
private static Task`1<Document> ImplementOperatorEqualsAsync(Document document, SyntaxNode declaration, INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideEqualsAndOperatorEqualsOnValueTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor EqualsRule;
    internal static DiagnosticDescriptor OpEqualityRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OverrideEqualsAndOperatorEqualsOnValueTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideEqualsAndOperatorEqualsOnValueTypesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideEqualsAndOperatorEqualsOnValueTypesFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideEqualsAndOperatorEqualsOnValueTypesFixer/<ImplementMissingMembersAsync>d__5")]
private static Task`1<Document> ImplementMissingMembersAsync(SyntaxNode declaration, INamedTypeSymbol typeSymbol, Document document, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideEqualsOnOverloadingOperatorEqualsFixer : CodeFixProvider {
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideEqualsOnOverloadingOperatorEqualsFixer/<RegisterCodeFixesAsync>d__1")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideEqualsOnOverloadingOperatorEqualsFixer/<OverrideObjectEqualsAsync>d__2")]
private static Task`1<Document> OverrideObjectEqualsAsync(Document document, SyntaxNode typeDeclaration, INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideGetHashCodeOnOverridingEqualsFixer : CodeFixProvider {
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideGetHashCodeOnOverridingEqualsFixer/<RegisterCodeFixesAsync>d__1")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideGetHashCodeOnOverridingEqualsFixer/<OverrideObjectGetHashCodeAsync>d__2")]
private static Task`1<Document> OverrideObjectGetHashCodeAsync(Document document, SyntaxNode typeDeclaration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideMethodsOnComparableTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor RuleEquals;
    internal static DiagnosticDescriptor RuleOperator;
    internal static DiagnosticDescriptor RuleBoth;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static OverrideMethodsOnComparableTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [NullableContextAttribute("2")]
private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol comparableType, INamedTypeSymbol genericComparableType);
    [NullableContextAttribute("2")]
private static bool IsComparableWithBaseNotComparable(INamedTypeSymbol namedTypeSymbol, INamedTypeSymbol comparableType, INamedTypeSymbol genericComparableType);
    [NullableContextAttribute("2")]
private static bool IsComparableCore(INamedTypeSymbol namedTypeSymbol, INamedTypeSymbol comparableType, INamedTypeSymbol genericComparableType);
    private static string GetNeededComparisonOperators(INamedTypeSymbol symbol);
    [CompilerGeneratedAttribute]
internal static void <GetNeededComparisonOperators>g__Append|13_0(string operator, <>c__DisplayClass13_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideMethodsOnComparableTypesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideMethodsOnComparableTypesFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.OverrideMethodsOnComparableTypesFixer/<ImplementComparableAsync>d__4")]
private static Task`1<Document> ImplementComparableAsync(Document document, SyntaxNode declaration, INamedTypeSymbol typeSymbol, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ParameterNamesShouldMatchBaseDeclarationAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string NewNamePropertyName;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ParameterNamesShouldMatchBaseDeclarationAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodSymbol(SymbolAnalysisContext analysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ParameterNamesShouldMatchBaseDeclarationFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ParameterNamesShouldMatchBaseDeclarationFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ParameterNamesShouldMatchBaseDeclarationFixer/<GetUpdatedDocumentForParameterRenameAsync>d__5")]
private static Task`1<Document> GetUpdatedDocumentForParameterRenameAsync(Document document, ISymbol parameter, string newName, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.PassSystemUriObjectsInsteadOfStringsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PassSystemUriObjectsInsteadOfStringsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual SyntaxNode GetInvocationExpression(SyntaxNode invocationNode);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(CompilationStartAnalysisContext c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.PropertiesShouldNotBeWriteOnlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor AddGetterRule;
    internal static DiagnosticDescriptor MakeMoreAccessibleRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PropertiesShouldNotBeWriteOnlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.PropertiesShouldNotBeWriteOnlyFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.PropertiesShouldNotReturnArraysAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PropertiesShouldNotReturnArraysAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.PropertyNamesShouldNotMatchGetMethodsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static string Get;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PropertyNamesShouldNotMatchGetMethodsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [NullableContextAttribute("2")]
private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol obsoleteAttributeType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.PropertyNamesShouldNotMatchGetMethodsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.ProvideObsoleteAttributeMessageAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ProvideObsoleteAttributeMessageAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol obsoleteAttributeType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.StaticHolderTypesAnalyzer : DiagnosticAnalyzer {
    public static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static StaticHolderTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeSymbol>g__IsSealedAndVisualBasic|6_0(INamedTypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.TypeNamesShouldNotMatchNamespacesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor DefaultRule;
    internal static DiagnosticDescriptor SystemRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static object s_lock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_wellKnownSystemNamespaceTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ImmutableDictionary`2<string, string> WellKnownSystemNamespaceTable { get; }
    private static TypeNamesShouldNotMatchNamespacesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static ImmutableDictionary`2<string, string> get_WellKnownSystemNamespaceTable();
    public virtual void Initialize(AnalysisContext context);
    private static bool AddNamespacesFromCompilation(ConcurrentBag`1<string> namespaceNamesInCompilation, INamespaceSymbol namespace);
    private static void InitializeWellKnownSystemNamespaceTable();
    private static void UpdateNamespaceTable(Dictionary`2<string, string> namespaceTable, IList`1<string> namespaces);
    private static void UpdateNamespaceTable(Dictionary`2<string, string> namespaceTable, string namespaceName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.TypeNamesShouldNotMatchNamespacesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.TypesThatOwnDisposableFieldsShouldBeDisposableAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string Dispose;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TypesThatOwnDisposableFieldsShouldBeDisposableAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbolStart(SymbolStartAnalysisContext ctx, DisposeAnalysisHelper disposeAnalysisHelper);
    private static void AnalyzeOperation(OperationAnalysisContext ctx, INamedTypeSymbol parent, ISet`1<IFieldSymbol> disposableFields, TemporarySet`1& disposableFieldNamesBuilder);
    private static void AnalyzeSymbolEnd(SymbolAnalysisContext ctx, TemporarySet`1& disposableFieldNamesBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.TypesThatOwnDisposableFieldsShouldBeDisposableFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.TypesThatOwnDisposableFieldsShouldBeDisposableFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.TypesThatOwnDisposableFieldsShouldBeDisposableFixer/<ImplementIDisposableAsync>d__4")]
private static Task`1<Document> ImplementIDisposableAsync(Document document, SyntaxNode declaration, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UriParametersShouldNotBeStringsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UriParametersShouldNotBeStringsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UriParametersShouldNotBeStringsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UriParametersShouldNotBeStringsFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UriParametersShouldNotBeStringsFixer/<AddMethodAsync>d__5")]
private static Task`1<Document> AddMethodAsync(Document document, TextSpan span, SyntaxNode methodNode, SyntaxNode targetNode, INamedTypeSymbol uriType, CancellationToken cancellationToken);
    private static SyntaxNode CreateNewMethod(SyntaxGenerator generator, IMethodSymbol methodSymbol, int parameterIndex, Compilation compilation, INamedTypeSymbol uriType);
    private static int GetParameterIndex(IMethodSymbol methodSymbol, SyntaxTree tree, TextSpan span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UriPropertiesShouldNotBeStringsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UriPropertiesShouldNotBeStringsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UriReturnValuesShouldNotBeStringsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UriReturnValuesShouldNotBeStringsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UseEventsWhereAppropriateAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseEventsWhereAppropriateAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsEventLikeNameCandidate(string name);
    private static bool HasEventLikeName(IMethodSymbol method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UseEventsWhereAppropriateFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UseGenericEventHandlerInstancesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    internal static DiagnosticDescriptor RuleForDelegates;
    internal static DiagnosticDescriptor RuleForEvents;
    internal static DiagnosticDescriptor RuleForEvents2;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseGenericEventHandlerInstancesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsDelegateTypeWithInvokeMethod|8_1(INamedTypeSymbol namedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UseIntegralOrStringArgumentForIndexersAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_allowedSpecialTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseIntegralOrStringArgumentForIndexersAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, ImmutableHashSet`1<INamedTypeSymbol> allowedTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UsePreferredTermsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UsePreferredTermsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UsePropertiesWhereAppropriateAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    private static string GetHashCodeName;
    private static string GetEnumeratorName;
    private static string GetPinnableReferenceName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UsePropertiesWhereAppropriateAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsPropertyLikeName(string methodName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiDesignGuidelines.UsePropertiesWhereAppropriateFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiReview.AvoidCallingProblematicMethodsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.ApiReview.AvoidCallingProblematicMethodsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.Documentation.AvoidUsingCrefTagsWithAPrefixAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidUsingCrefTagsWithAPrefixAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected static void ProcessAttribute(SyntaxNodeAnalysisContext context, SyntaxTokenList textTokens);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.Documentation.AvoidUsingCrefTagsWithAPrefixFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.Maintainability.AvoidDeadConditionalCode : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    internal static DiagnosticDescriptor AlwaysTrueFalseOrNullRule;
    internal static DiagnosticDescriptor NeverNullRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidDeadConditionalCode();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual bool IsSwitchArmExpressionWithWhenClause(SyntaxNode node);
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(CompilationStartAnalysisContext compilationContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_1(OperationBlockAnalysisContext operationBlockContext);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__ShouldAnalyze|8_2(IOperation op);
    [CompilerGeneratedAttribute]
internal static PredicateValueKind <Initialize>g__GetPredicateKind|8_3(IOperation operation, <>c__DisplayClass8_1& );
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__ReportAlwaysTrueFalseOrNullDiagnostic|8_4(IOperation operation, PredicateValueKind predicateKind, <>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.Maintainability.AvoidUninstantiatedInternalClassesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidUninstantiatedInternalClassesAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public abstract virtual void RegisterLanguageSpecificChecks(CompilationStartAnalysisContext context, ConcurrentDictionary`2<INamedTypeSymbol, object> instantiatedTypes);
    public sealed virtual void Initialize(AnalysisContext context);
    private bool HasInstantiatedNestedType(INamedTypeSymbol type, IEnumerable`1<INamedTypeSymbol> instantiatedTypes);
    [NullableContextAttribute("2")]
private static bool IsOkToBeUninstantiated(INamedTypeSymbol type, INamedTypeSymbol entryPointContainingType, INamedTypeSymbol systemAttributeSymbol, INamedTypeSymbol iConfigurationSectionHandlerSymbol, INamedTypeSymbol configurationSectionSymbol, INamedTypeSymbol safeHandleSymbol, INamedTypeSymbol traceListenerSymbol, INamedTypeSymbol mef1ExportAttributeSymbol, INamedTypeSymbol mef2ExportAttributeSymbol);
    [NullableContextAttribute("2")]
public static bool IsMefExported(INamedTypeSymbol type, INamedTypeSymbol mef1ExportAttributeSymbol, INamedTypeSymbol mef2ExportAttributeSymbol);
    protected void ProcessGenericTypes(IEnumerable`1<ValueTuple`2<ITypeParameterSymbol, ITypeSymbol>> generics, ConcurrentDictionary`2<INamedTypeSymbol, object> instantiatedTypes);
    private static bool IsTypeInCurrentAssembly(string typeName, Compilation compilation, INamedTypeSymbol& namedType);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext startContext);
    [CompilerGeneratedAttribute]
private void <ProcessGenericTypes>g__ProcessNamedTypeParamConstraint|10_0(INamedTypeSymbol namedTypeArg, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<INamedTypeSymbol> <ProcessGenericTypes>g__GetAllNamedTypeConstraints|10_2(ITypeParameterSymbol t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.Maintainability.AvoidUninstantiatedInternalClassesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.Maintainability.AvoidUnusedPrivateFieldsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidUnusedPrivateFieldsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static ImmutableHashSet`1<INamedTypeSymbol> GetSpecialAttributes(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.Maintainability.AvoidUnusedPrivateFieldsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.Maintainability.AvoidUnusedPrivateFieldsFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.Maintainability.AvoidUnusedPrivateFieldsFixer/<RemoveFieldAsync>d__5")]
private static Task`1<Document> RemoveFieldAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.Maintainability.CodeMetrics.CodeMetricsAnalyzer : DiagnosticAnalyzer {
    internal static string CA1501RuleId;
    internal static string CA1502RuleId;
    internal static string CA1505RuleId;
    internal static string CA1506RuleId;
    private static string CodeMetricsConfigurationFile;
    internal static string CA1509RuleId;
    internal static DiagnosticDescriptor CA1501Rule;
    internal static DiagnosticDescriptor CA1502Rule;
    internal static DiagnosticDescriptor CA1505Rule;
    internal static DiagnosticDescriptor CA1506Rule;
    internal static DiagnosticDescriptor InvalidEntryInCodeMetricsConfigFileRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CodeMetricsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [NullableContextAttribute("2")]
private static bool TryGetRuleIdToThresholdMap(ImmutableArray`1<AdditionalText> additionalFiles, CancellationToken cancellationToken, AdditionalText& additionalText, ImmutableDictionary`2& ruleIdToThresholdMap, List`1& invalidFileDiagnostics);
    [NullableContextAttribute("2")]
private static AdditionalText TryGetCodeMetricsConfigurationFile(ImmutableArray`1<AdditionalText> additionalFiles, CancellationToken cancellationToken);
    private static bool TryParseCodeMetricsConfigurationFile(AdditionalText additionalText, CancellationToken cancellationToken, ImmutableDictionary`2& ruleIdToThresholdMap, List`1& invalidFileDiagnostics);
    private static int GetDistinctContainingNamespacesCount(IEnumerable`1<INamedTypeSymbol> namedTypes);
    private static bool IsConfiguredToSkipFromInheritanceCount(ISymbol symbol, CompilationAnalysisContext context, SyntaxTree tree);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__isApplicableByDefault|14_4(string ruleId, SymbolKind symbolKind);
    [CompilerGeneratedAttribute]
internal static Nullable`1<UInt32> <Initialize>g__getDefaultThreshold|14_5(string ruleId, SymbolKind symbolKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.Maintainability.DoNotIgnoreMethodResultsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static ImmutableHashSet`1<string> s_stringMethodNames;
    private static ImmutableHashSet`1<string> s_nUnitMethodNames;
    private static ImmutableHashSet`1<string> s_xUnitMethodNames;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor ObjectCreationRule;
    internal static DiagnosticDescriptor StringCreationRule;
    internal static DiagnosticDescriptor HResultOrErrorCodeRule;
    internal static DiagnosticDescriptor PureMethodRule;
    internal static DiagnosticDescriptor TryParseRule;
    internal static DiagnosticDescriptor LinqMethodRule;
    internal static DiagnosticDescriptor UserDefinedMethodRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotIgnoreMethodResultsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [NullableContextAttribute("2")]
private static bool ShouldSkipAnalyzing(OperationAnalysisContext operationContext, INamedTypeSymbol expectedExceptionType, INamedTypeSymbol xunitAssertType, INamedTypeSymbol nunitAssertType);
    private static bool IsStringCreatingMethod(IMethodSymbol method);
    private static bool IsTryParseMethod(IMethodSymbol method);
    private static bool IsHResultOrErrorCodeReturningMethod(IMethodSymbol method);
    private static bool IsPureMethod(IMethodSymbol method, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static bool <ShouldSkipAnalyzing>g__IsThrowsArgument|17_0(IParameterSymbol parameterSymbol, string argumentName, ImmutableHashSet`1<string> methodNames, INamedTypeSymbol assertSymbol);
    [CompilerGeneratedAttribute]
internal static bool <ShouldSkipAnalyzing>g__IsNUnitThrowsArgument|17_1(IParameterSymbol parameterSymbol, <>c__DisplayClass17_0& );
    [CompilerGeneratedAttribute]
internal static bool <ShouldSkipAnalyzing>g__IsXunitThrowsArgument|17_2(IParameterSymbol parameterSymbol, <>c__DisplayClass17_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.Maintainability.UseNameofInPlaceOfStringAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static string ParamName;
    private static string PropertyName;
    internal static string StringText;
    internal static DiagnosticDescriptor RuleWithSuggestion;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseNameofInPlaceOfStringAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual bool IsApplicableToLanguageVersion(ParseOptions options);
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeArgument(OperationAnalysisContext context);
    private static bool HasAnyPropertyMatchInScope(OperationAnalysisContext context, string stringText);
    private static bool HasAnyParameterMatchInScope(OperationAnalysisContext context, string stringText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.Maintainability.UseNameOfInPlaceOfStringFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.Maintainability.UseNameOfInPlaceOfStringFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.Maintainability.UseNameOfInPlaceOfStringFixer/<ReplaceWithNameOfAsync>d__5")]
private static Task`1<Document> ReplaceWithNameOfAsync(Document document, SyntaxNode nodeToReplace, string stringText, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.Maintainability.VariableNamesShouldNotMatchFieldNamesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.Maintainability.VariableNamesShouldNotMatchFieldNamesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
internal static class Microsoft.CodeQuality.Analyzers.MicrosoftCodeQualityAnalyzersResources : object {
    [NullableAttribute("1")]
private static Type s_resourcesType;
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string TypesThatOwnDisposableFieldsShouldBeDisposableTitle { get; }
    internal static string TypesThatOwnDisposableFieldsShouldBeDisposableDescription { get; }
    internal static string TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking { get; }
    internal static string UseGenericEventHandlerInstancesTitle { get; }
    internal static string UseGenericEventHandlerInstancesForDelegateMessage { get; }
    internal static string UseGenericEventHandlerInstancesForDelegateDescription { get; }
    internal static string UseGenericEventHandlerInstancesForEventMessage { get; }
    internal static string UseGenericEventHandlerInstancesForEventDescription { get; }
    internal static string UseGenericEventHandlerInstancesForEvent2Message { get; }
    internal static string UseGenericEventHandlerInstancesForEvent2Description { get; }
    internal static string EnumsShouldHaveZeroValueTitle { get; }
    internal static string EnumsShouldHaveZeroValueDescription { get; }
    internal static string EnumsShouldHaveZeroValueMessageFlagsRename { get; }
    internal static string EnumsShouldHaveZeroValueMessageFlagsMultipleZeros { get; }
    internal static string EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue { get; }
    internal static string AbstractTypesShouldNotHaveConstructorsTitle { get; }
    internal static string AbstractTypesShouldNotHaveConstructorsDescription { get; }
    internal static string AbstractTypesShouldNotHaveConstructorsMessage { get; }
    internal static string LoggerMessageDiagnosticNumericsInFormatStringTitle { get; }
    internal static string LoggerMessageDiagnosticNumericsInFormatStringMessage { get; }
    internal static string LoggerMessageDiagnosticNumericsInFormatStringDescription { get; }
    internal static string LoggerMessageDiagnosticFormatParameterCountMismatchTitle { get; }
    internal static string LoggerMessageDiagnosticFormatParameterCountMismatchMessage { get; }
    internal static string LoggerMessageDiagnosticFormatParameterCountMismatchDescription { get; }
    internal static string LoggerMessageDiagnosticUseCompiledLogMessagesTitle { get; }
    internal static string LoggerMessageDiagnosticUseCompiledLogMessagesMessage { get; }
    internal static string LoggerMessageDiagnosticUseCompiledLogMessagesDescription { get; }
    internal static string LoggerMessageDiagnosticConcatenationInFormatStringTitle { get; }
    internal static string LoggerMessageDiagnosticConcatenationInFormatStringMessage { get; }
    internal static string LoggerMessageDiagnosticConcatenationInFormatStringDescription { get; }
    internal static string LoggerMessageDiagnosticUsePascalCasedLogMessageTokensTitle { get; }
    internal static string LoggerMessageDiagnosticUsePascalCasedLogMessageTokensMessage { get; }
    internal static string LoggerMessageDiagnosticUsePascalCasedLogMessageTokensDescription { get; }
    internal static string MarkAssembliesWithClsCompliantTitle { get; }
    internal static string MarkAssembliesWithClsCompliantDescription { get; }
    internal static string MarkAssembliesWithClsCompliantMessage { get; }
    internal static string MarkAssembliesWithAssemblyVersionTitle { get; }
    internal static string MarkAssembliesWithAssemblyVersionDescription { get; }
    internal static string MarkAssembliesWithAssemblyVersionMessage { get; }
    internal static string MarkAssembliesWithComVisibleTitle { get; }
    internal static string MarkAssembliesWithComVisibleDescription { get; }
    internal static string MarkAttributesWithAttributeUsageTitle { get; }
    internal static string MarkAttributesWithAttributeUsageMessageDefault { get; }
    internal static string DefineAccessorsForAttributeArgumentsTitle { get; }
    internal static string DefineAccessorsForAttributeArgumentsMessageDefault { get; }
    internal static string DefineAccessorsForAttributeArgumentsMessageRemoveSetter { get; }
    internal static string DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility { get; }
    internal static string UsePropertiesWhereAppropriateTitle { get; }
    internal static string UsePropertiesWhereAppropriateDescription { get; }
    internal static string UsePropertiesWhereAppropriateMessage { get; }
    internal static string MarkEnumsWithFlagsTitle { get; }
    internal static string MarkEnumsWithFlagsDescription { get; }
    internal static string MarkEnumsWithFlagsMessage { get; }
    internal static string InterfaceMethodsShouldBeCallableByChildTypesTitle { get; }
    internal static string InterfaceMethodsShouldBeCallableByChildTypesDescription { get; }
    internal static string InterfaceMethodsShouldBeCallableByChildTypesMessage { get; }
    internal static string OverrideMethodsOnComparableTypesTitle { get; }
    internal static string OverrideMethodsOnComparableTypesDescription { get; }
    internal static string OverrideMethodsOnComparableTypesMessageEquals { get; }
    internal static string OverrideMethodsOnComparableTypesMessageOperator { get; }
    internal static string MovePInvokesToNativeMethodsClassTitle { get; }
    internal static string MovePInvokesToNativeMethodsClassDescription { get; }
    internal static string MovePInvokesToNativeMethodsClassMessage { get; }
    internal static string IdentifiersShouldDifferByMoreThanCaseTitle { get; }
    internal static string IdentifiersShouldDifferByMoreThanCaseDescription { get; }
    internal static string IdentifiersShouldDifferByMoreThanCaseMessage { get; }
    internal static string IdentifiersShouldHaveCorrectPrefixTitle { get; }
    internal static string IdentifiersShouldHaveCorrectPrefixDescription { get; }
    internal static string IdentifiersShouldHaveCorrectPrefixMessageInterface { get; }
    internal static string IdentifiersShouldHaveCorrectPrefixMessageTypeParameter { get; }
    internal static string NonConstantFieldsShouldNotBeVisibleTitle { get; }
    internal static string NonConstantFieldsShouldNotBeVisibleDescription { get; }
    internal static string NonConstantFieldsShouldNotBeVisibleMessage { get; }
    internal static string DoNotMarkEnumsWithFlagsTitle { get; }
    internal static string DoNotMarkEnumsWithFlagsDescription { get; }
    internal static string DoNotMarkEnumsWithFlagsMessage { get; }
    internal static string OperatorOverloadsHaveNamedAlternatesTitle { get; }
    internal static string OperatorOverloadsHaveNamedAlternatesDescription { get; }
    internal static string OperatorOverloadsHaveNamedAlternatesMessageDefault { get; }
    internal static string OperatorOverloadsHaveNamedAlternatesMessageProperty { get; }
    internal static string OperatorOverloadsHaveNamedAlternatesMessageMultiple { get; }
    internal static string OperatorOverloadsHaveNamedAlternatesMessageVisibility { get; }
    internal static string OperatorsShouldHaveSymmetricalOverloadsTitle { get; }
    internal static string OperatorsShouldHaveSymmetricalOverloadsDescription { get; }
    internal static string CollectionPropertiesShouldBeReadOnlyTitle { get; }
    internal static string CollectionPropertiesShouldBeReadOnlyDescription { get; }
    internal static string CollectionPropertiesShouldBeReadOnlyMessage { get; }
    internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle { get; }
    internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription { get; }
    internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage { get; }
    internal static string PassSystemUriObjectsInsteadOfStringsTitle { get; }
    internal static string PassSystemUriObjectsInsteadOfStringsDescription { get; }
    internal static string PassSystemUriObjectsInsteadOfStringsMessage { get; }
    internal static string ImplementIEquatableWhenOverridingObjectEqualsMessage { get; }
    internal static string ImplementIEquatableWhenOverridingObjectEqualsTitle { get; }
    internal static string CancellationTokenParametersMustComeLastTitle { get; }
    internal static string CancellationTokenParametersMustComeLastMessage { get; }
    internal static string IdentifiersShouldNotContainTypeNamesTitle { get; }
    internal static string IdentifiersShouldNotContainTypeNamesDescription { get; }
    internal static string IdentifiersShouldNotContainTypeNamesMessage { get; }
    internal static string CreatePropertyAccessorForParameter { get; }
    internal static string MakeGetterPublic { get; }
    internal static string MakeSetterNonPublic { get; }
    internal static string AddAssemblyLevelComVisibleFalse { get; }
    internal static string ChangeAssemblyLevelComVisibleToFalse { get; }
    internal static string ImplementComparable { get; }
    internal static string ImplementEquatable { get; }
    internal static string ImplementIDisposableInterface { get; }
    internal static string DoNotMarkEnumsWithFlagsCodeFix { get; }
    internal static string MarkEnumsWithFlagsCodeFix { get; }
    internal static string EnumsShouldZeroValueFlagsMultipleZeroCodeFix { get; }
    internal static string EnumsShouldZeroValueFlagsRenameCodeFix { get; }
    internal static string EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix { get; }
    internal static string AbstractTypesShouldNotHavePublicConstructorsCodeFix { get; }
    internal static string DoNotDeclareStaticMembersOnGenericTypesTitle { get; }
    internal static string DoNotDeclareStaticMembersOnGenericTypesDescription { get; }
    internal static string DoNotDeclareStaticMembersOnGenericTypesMessage { get; }
    internal static string CollectionsShouldImplementGenericInterfaceTitle { get; }
    internal static string CollectionsShouldImplementGenericInterfaceDescription { get; }
    internal static string CollectionsShouldImplementGenericInterfaceMessage { get; }
    internal static string EnumStorageShouldBeInt32Title { get; }
    internal static string EnumStorageShouldBeInt32Description { get; }
    internal static string EnumStorageShouldBeInt32Message { get; }
    internal static string UseEventsWhereAppropriateTitle { get; }
    internal static string UseEventsWhereAppropriateDescription { get; }
    internal static string UseEventsWhereAppropriateMessage { get; }
    internal static string ImplementStandardExceptionConstructorsTitle { get; }
    internal static string ImplementStandardExceptionConstructorsDescription { get; }
    internal static string ImplementStandardExceptionConstructorsMessageMissingConstructor { get; }
    internal static string NestedTypesShouldNotBeVisibleTitle { get; }
    internal static string NestedTypesShouldNotBeVisibleDescription { get; }
    internal static string NestedTypesShouldNotBeVisibleMessageDefault { get; }
    internal static string NestedTypesShouldNotBeVisibleMessageVisualBasicModule { get; }
    internal static string AvoidEmptyInterfacesTitle { get; }
    internal static string AvoidEmptyInterfacesDescription { get; }
    internal static string AvoidEmptyInterfacesMessage { get; }
    internal static string ProvideObsoleteAttributeMessageTitle { get; }
    internal static string ProvideObsoleteAttributeMessageDescription { get; }
    internal static string ProvideObsoleteAttributeMessageMessage { get; }
    internal static string PropertiesShouldNotBeWriteOnlyTitle { get; }
    internal static string PropertiesShouldNotBeWriteOnlyDescription { get; }
    internal static string PropertiesShouldNotBeWriteOnlyMessageAddGetter { get; }
    internal static string PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible { get; }
    internal static string DeclareTypesInNamespacesTitle { get; }
    internal static string DeclareTypesInNamespacesDescription { get; }
    internal static string DeclareTypesInNamespacesMessage { get; }
    internal static string DoNotDeclareVisibleInstanceFieldsTitle { get; }
    internal static string DoNotDeclareVisibleInstanceFieldsDescription { get; }
    internal static string DoNotDeclareVisibleInstanceFieldsMessage { get; }
    internal static string UriParametersShouldNotBeStringsTitle { get; }
    internal static string UriParametersShouldNotBeStringsDescription { get; }
    internal static string UriParametersShouldNotBeStringsMessage { get; }
    internal static string UriReturnValuesShouldNotBeStringsTitle { get; }
    internal static string UriReturnValuesShouldNotBeStringsDescription { get; }
    internal static string UriReturnValuesShouldNotBeStringsMessage { get; }
    internal static string UriPropertiesShouldNotBeStringsTitle { get; }
    internal static string UriPropertiesShouldNotBeStringsDescription { get; }
    internal static string UriPropertiesShouldNotBeStringsMessage { get; }
    internal static string ImplementIDisposableCorrectlyTitle { get; }
    internal static string ImplementIDisposableCorrectlyDescription { get; }
    internal static string ImplementIDisposableCorrectlyMessageIDisposableReimplementation { get; }
    internal static string ImplementIDisposableCorrectlyMessageFinalizeOverride { get; }
    internal static string ImplementIDisposableCorrectlyMessageDisposeOverride { get; }
    internal static string ImplementIDisposableCorrectlyMessageDisposeSignature { get; }
    internal static string ImplementIDisposableCorrectlyMessageRenameDispose { get; }
    internal static string ImplementIDisposableCorrectlyMessageDisposeBoolSignature { get; }
    internal static string ImplementIDisposableCorrectlyMessageDisposeImplementation { get; }
    internal static string ImplementIDisposableCorrectlyMessageFinalizeImplementation { get; }
    internal static string ImplementIDisposableCorrectlyMessageProvideDisposeBool { get; }
    internal static string ExceptionsShouldBePublicTitle { get; }
    internal static string ExceptionsShouldBePublicDescription { get; }
    internal static string ExceptionsShouldBePublicMessage { get; }
    internal static string DoNotRaiseExceptionsInUnexpectedLocationsTitle { get; }
    internal static string DoNotRaiseExceptionsInUnexpectedLocationsDescription { get; }
    internal static string DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter { get; }
    internal static string DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions { get; }
    internal static string DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions { get; }
    internal static string IdentifiersShouldNotContainUnderscoresTitle { get; }
    internal static string IdentifiersShouldNotContainUnderscoresDescription { get; }
    internal static string IdentifiersShouldNotContainUnderscoresMessageAssembly { get; }
    internal static string IdentifiersShouldNotContainUnderscoresMessageNamespace { get; }
    internal static string IdentifiersShouldNotContainUnderscoresMessageType { get; }
    internal static string IdentifiersShouldNotContainUnderscoresMessageMember { get; }
    internal static string IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter { get; }
    internal static string IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter { get; }
    internal static string IdentifiersShouldNotContainUnderscoresMessageMemberParameter { get; }
    internal static string IdentifiersShouldNotContainUnderscoresMessageDelegateParameter { get; }
    internal static string IdentifiersShouldHaveCorrectSuffixTitle { get; }
    internal static string IdentifiersShouldHaveCorrectSuffixDescription { get; }
    internal static string IdentifiersShouldHaveCorrectSuffixMessageDefault { get; }
    internal static string IdentifiersShouldHaveCorrectSuffixMessageMultiple { get; }
    internal static string IdentifiersShouldNotHaveIncorrectSuffixTitle { get; }
    internal static string IdentifiersShouldNotHaveIncorrectSuffixDescription { get; }
    internal static string IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate { get; }
    internal static string IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion { get; }
    internal static string IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion { get; }
    internal static string IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate { get; }
    internal static string IdentifiersShouldNotMatchKeywordsTitle { get; }
    internal static string IdentifiersShouldNotMatchKeywordsDescription { get; }
    internal static string IdentifiersShouldNotMatchKeywordsMessageMemberParameter { get; }
    internal static string IdentifiersShouldNotMatchKeywordsMessageMember { get; }
    internal static string IdentifiersShouldNotMatchKeywordsMessageType { get; }
    internal static string IdentifiersShouldNotMatchKeywordsMessageNamespace { get; }
    internal static string PropertyNamesShouldNotMatchGetMethodsTitle { get; }
    internal static string PropertyNamesShouldNotMatchGetMethodsDescription { get; }
    internal static string PropertyNamesShouldNotMatchGetMethodsMessage { get; }
    internal static string TypeNamesShouldNotMatchNamespacesTitle { get; }
    internal static string TypeNamesShouldNotMatchNamespacesDescription { get; }
    internal static string TypeNamesShouldNotMatchNamespacesMessageDefault { get; }
    internal static string TypeNamesShouldNotMatchNamespacesMessageSystem { get; }
    internal static string ParameterNamesShouldMatchBaseDeclarationTitle { get; }
    internal static string ParameterNamesShouldMatchBaseDeclarationDescription { get; }
    internal static string ParameterNamesShouldMatchBaseDeclarationMessage { get; }
    internal static string OverrideEqualsAndOperatorEqualsOnValueTypesTitle { get; }
    internal static string OverrideEqualsAndOperatorEqualsOnValueTypesDescription { get; }
    internal static string OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals { get; }
    internal static string OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality { get; }
    internal static string PropertiesShouldNotReturnArraysTitle { get; }
    internal static string PropertiesShouldNotReturnArraysDescription { get; }
    internal static string PropertiesShouldNotReturnArraysMessage { get; }
    internal static string OverrideGetHashCodeOnOverridingEqualsTitle { get; }
    internal static string OverrideGetHashCodeOnOverridingEqualsDescription { get; }
    internal static string OverrideGetHashCodeOnOverridingEqualsMessage { get; }
    internal static string OverrideEqualsOnOverloadingOperatorEqualsTitle { get; }
    internal static string OverrideEqualsOnOverloadingOperatorEqualsDescription { get; }
    internal static string OverrideEqualsOnOverloadingOperatorEqualsMessage { get; }
    internal static string Since_0_redefines_operator_1_it_should_also_redefine_operator_2 { get; }
    internal static string Generate_missing_operators { get; }
    internal static string OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle { get; }
    internal static string OverrideEqualsOnImplementingIEquatableCodeActionTitle { get; }
    internal static string OverrideGetHashCodeOnOverridingEqualsCodeActionTitle { get; }
    internal static string MakeExceptionPublic { get; }
    internal static string InterfaceMethodsShouldBeCallableByChildTypesFix1 { get; }
    internal static string InterfaceMethodsShouldBeCallableByChildTypesFix2 { get; }
    internal static string InterfaceMethodsShouldBeCallableByChildTypesFix3 { get; }
    internal static string StaticHolderTypeIsNotStatic { get; }
    internal static string StaticHolderTypesShouldBeStaticOrNotInheritable { get; }
    internal static string MakeClassStatic { get; }
    internal static string OverrideObjectEqualsMessage { get; }
    internal static string OverrideObjectEqualsTitle { get; }
    internal static string UseIntegralOrStringArgumentForIndexersDescription { get; }
    internal static string UseIntegralOrStringArgumentForIndexersMessage { get; }
    internal static string UseIntegralOrStringArgumentForIndexersTitle { get; }
    internal static string DoNotDirectlyAwaitATaskDescription { get; }
    internal static string DoNotDirectlyAwaitATaskMessage { get; }
    internal static string DoNotDirectlyAwaitATaskTitle { get; }
    internal static string AppendConfigureAwaitFalse { get; }
    internal static string AppendConfigureAwaitTrue { get; }
    internal static string ImplementIEquatableWhenOverridingObjectEqualsDescription { get; }
    internal static string OverrideObjectEqualsDescription { get; }
    internal static string RenameToTitle { get; }
    internal static string DoNotHideBaseClassMethodsDescription { get; }
    internal static string DoNotHideBaseClassMethodsMessage { get; }
    internal static string DoNotHideBaseClassMethodsTitle { get; }
    internal static string OverrideMethodsOnComparableTypesMessageBoth { get; }
    internal static string DoNotCatchGeneralExceptionTypesDescription { get; }
    internal static string DoNotCatchGeneralExceptionTypesMessage { get; }
    internal static string DoNotCatchGeneralExceptionTypesTitle { get; }
    internal static string DoNotPrefixEnumValuesWithTypeNameDescription { get; }
    internal static string DoNotPrefixEnumValuesWithTypeNameMessage { get; }
    internal static string DoNotPrefixEnumValuesWithTypeNameTitle { get; }
    internal static string AvoidUsingCrefTagsWithAPrefixTitle { get; }
    internal static string AvoidUsingCrefTagsWithAPrefixDescription { get; }
    internal static string AvoidUsingCrefTagsWithAPrefixMessage { get; }
    internal static string DoNotIgnoreMethodResultsTitle { get; }
    internal static string DoNotIgnoreMethodResultsDescription { get; }
    internal static string DoNotIgnoreMethodResultsMessageObjectCreation { get; }
    internal static string DoNotIgnoreMethodResultsMessageStringCreation { get; }
    internal static string DoNotIgnoreMethodResultsMessageHResultOrErrorCode { get; }
    internal static string DoNotIgnoreMethodResultsMessageTryParse { get; }
    internal static string AvoidUninstantiatedInternalClassesTitle { get; }
    internal static string AvoidUninstantiatedInternalClassesDescription { get; }
    internal static string AvoidUninstantiatedInternalClassesMessage { get; }
    internal static string AvoidUnusedPrivateFieldsTitle { get; }
    internal static string AvoidUnusedPrivateFieldsDescription { get; }
    internal static string AvoidUnusedPrivateFieldsMessage { get; }
    internal static string DoNotIgnoreMethodResultsMessagePureMethod { get; }
    internal static string UseNameOfInPlaceOfStringDescription { get; }
    internal static string UseNameOfInPlaceOfStringMessage { get; }
    internal static string UseNameOfInPlaceOfStringTitle { get; }
    internal static string AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage { get; }
    internal static string AvoidDeadConditionalCodeNeverNullMessage { get; }
    internal static string AvoidDeadConditionalCodeTitle { get; }
    internal static string AvoidExcessiveClassCouplingDescription { get; }
    internal static string AvoidExcessiveClassCouplingMessage { get; }
    internal static string AvoidExcessiveClassCouplingTitle { get; }
    internal static string AvoidExcessiveComplexityDescription { get; }
    internal static string AvoidExcessiveComplexityMessage { get; }
    internal static string AvoidExcessiveComplexityTitle { get; }
    internal static string AvoidExcessiveInheritanceDescription { get; }
    internal static string AvoidExcessiveInheritanceMessage { get; }
    internal static string AvoidExcessiveInheritanceTitle { get; }
    internal static string AvoidUnmantainableCodeDescription { get; }
    internal static string AvoidUnmantainableCodeMessage { get; }
    internal static string AvoidUnmantainableCodeTitle { get; }
    internal static string InvalidEntryInCodeMetricsConfigFileDescription { get; }
    internal static string InvalidEntryInCodeMetricsConfigFileMessage { get; }
    internal static string InvalidEntryInCodeMetricsConfigFileTitle { get; }
    internal static string UseLiteralsWhereAppropriateTitle { get; }
    internal static string UseLiteralsWhereAppropriateDescription { get; }
    internal static string UseLiteralsWhereAppropriateMessageDefault { get; }
    internal static string UseLiteralsWhereAppropriateMessageEmptyString { get; }
    internal static string DoNotInitializeUnnecessarilyTitle { get; }
    internal static string DoNotInitializeUnnecessarilyDescription { get; }
    internal static string DoNotInitializeUnnecessarilyMessage { get; }
    internal static string DoNotInitializeUnnecessarilyFix { get; }
    internal static string PreferJaggedArraysOverMultidimensionalTitle { get; }
    internal static string PreferJaggedArraysOverMultidimensionalDescription { get; }
    internal static string PreferJaggedArraysOverMultidimensionalMessageDefault { get; }
    internal static string PreferJaggedArraysOverMultidimensionalMessageReturn { get; }
    internal static string PreferJaggedArraysOverMultidimensionalMessageBody { get; }
    internal static string MarkMembersAsStaticTitle { get; }
    internal static string MarkMembersAsStaticDescription { get; }
    internal static string MarkMembersAsStaticMessage { get; }
    internal static string SealMethodsThatSatisfyPrivateInterfacesTitle { get; }
    internal static string SealMethodsThatSatisfyPrivateInterfacesDescription { get; }
    internal static string SealMethodsThatSatisfyPrivateInterfacesMessage { get; }
    internal static string RemoveEmptyFinalizers { get; }
    internal static string RemoveEmptyFinalizersDescription { get; }
    internal static string DoNotCallOverridableMethodsInConstructors { get; }
    internal static string DoNotCallOverridableMethodsInConstructorsDescription { get; }
    internal static string RethrowToPreserveStackDetailsMessage { get; }
    internal static string RethrowToPreserveStackDetailsTitle { get; }
    internal static string MakeDeclaringTypeInternal { get; }
    internal static string MakeDeclaringTypeSealed { get; }
    internal static string MakeMemberNotOverridable { get; }
    internal static string DoNotRaiseExceptionsInExceptionClausesDescription { get; }
    internal static string DoNotRaiseExceptionsInExceptionClausesMessageFinally { get; }
    internal static string DoNotRaiseExceptionsInExceptionClausesTitle { get; }
    internal static string UseLiteralsWhereAppropriateCodeActionTitle { get; }
    internal static string AvoidDuplicateElementInitializationDescription { get; }
    internal static string AvoidDuplicateElementInitializationMessage { get; }
    internal static string AvoidDuplicateElementInitializationTitle { get; }
    internal static string RemoveRedundantElementInitializationCodeFixTitle { get; }
    internal static string ValidateArgumentsOfPublicMethodsDescription { get; }
    internal static string ValidateArgumentsOfPublicMethodsMessage { get; }
    internal static string ValidateArgumentsOfPublicMethodsTitle { get; }
    internal static string MarkMembersAsStaticCodeFix { get; }
    internal static string MarkMembersAsStaticCodeFix_WarningAnnotation { get; }
    internal static string AvoidPropertySelfAssignmentTitle { get; }
    internal static string AvoidPropertySelfAssignmentMessage { get; }
    internal static string AssigningSymbolAndItsMemberInSameStatementDescription { get; }
    internal static string AssigningSymbolAndItsMemberInSameStatementMessage { get; }
    internal static string AssigningSymbolAndItsMemberInSameStatementTitle { get; }
    internal static string AvoidInfiniteRecursionMessageSure { get; }
    internal static string AvoidInfiniteRecursionTitle { get; }
    internal static string AvoidInfiniteRecursionMessageMaybe { get; }
    internal static string AvoidOutParametersDescription { get; }
    internal static string AvoidOutParametersMessage { get; }
    internal static string AvoidOutParametersTitle { get; }
    internal static string EnumShouldNotHaveDuplicatedValuesMessageDuplicatedBitwiseValuePart { get; }
    internal static string EnumShouldNotHaveDuplicatedValuesMessageDuplicatedValue { get; }
    internal static string EnumShouldNotHaveDuplicatedValuesTitle { get; }
    internal static string DoNotDeclareProtectedMembersInSealedTypesDescription { get; }
    internal static string DoNotDeclareProtectedMembersInSealedTypesMessage { get; }
    internal static string DoNotDeclareProtectedMembersInSealedTypesTitle { get; }
    internal static string AvoidExcessiveParametersOnGenericTypesDescription { get; }
    internal static string AvoidExcessiveParametersOnGenericTypesMessage { get; }
    internal static string AvoidExcessiveParametersOnGenericTypesTitle { get; }
    internal static string DoNotIgnoreMethodResultsMessageLinqMethod { get; }
    internal static string DoNotNameEnumValuesReservedDescription { get; }
    internal static string DoNotNameEnumValuesReservedMessage { get; }
    internal static string DoNotNameEnumValuesReservedTitle { get; }
    internal static string DoNotExposeGenericListsDescription { get; }
    internal static string DoNotExposeGenericListsMessage { get; }
    internal static string DoNotExposeGenericListsTitle { get; }
    internal static string DoNotDeclareEventFieldsAsVirtualDescription { get; }
    internal static string DoNotDeclareEventFieldsAsVirtualMessage { get; }
    internal static string DoNotDeclareEventFieldsAsVirtualTitle { get; }
    internal static string DoNotOverloadOperatorEqualsOnReferenceTypesDescription { get; }
    internal static string DoNotOverloadOperatorEqualsOnReferenceTypesMessage { get; }
    internal static string DoNotOverloadOperatorEqualsOnReferenceTypesTitle { get; }
    internal static string DoNotPassTypesByReferenceMessage { get; }
    internal static string DoNotPassTypesByReferenceTitle { get; }
    internal static string DoNotPassTypesByReferenceDescription { get; }
    internal static string EventsShouldNotHaveBeforeOrAfterPrefixDescription { get; }
    internal static string EventsShouldNotHaveBeforeOrAfterPrefixMessage { get; }
    internal static string EventsShouldNotHaveBeforeOrAfterPrefixTitle { get; }
    internal static string DoNotIgnoreMethodResultsMessageUserDefinedMethod { get; }
    internal static string IdentifiersShouldNotContainUnderscoresCodeFixTitle { get; }
    internal static string MarkAttributesWithAttributeUsageCodeFix { get; }
    internal static string UriParametersShouldNotBeStringsCodeFixTitle { get; }
    internal static string OperatorOverloadsHaveNamedAlternatesCodeFixTitle { get; }
    internal static string AvoidMultipleEnumerationsMessage { get; }
    internal static string AvoidMultipleEnumerationsTitle { get; }
    internal static string CollectionsShouldImplementGenericInterfaceMultipleMessage { get; }
    private static MicrosoftCodeQualityAnalyzersResources();
    [NullableContextAttribute("1")]
public static LocalizableResourceString CreateLocalizableResourceString(string nameOfLocalizableResource);
    [NullableContextAttribute("1")]
public static LocalizableResourceString CreateLocalizableResourceString(string nameOfLocalizableResource, String[] formatArguments);
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_TypesThatOwnDisposableFieldsShouldBeDisposableTitle();
    internal static string get_TypesThatOwnDisposableFieldsShouldBeDisposableDescription();
    internal static string get_TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking();
    internal static string get_UseGenericEventHandlerInstancesTitle();
    internal static string get_UseGenericEventHandlerInstancesForDelegateMessage();
    internal static string get_UseGenericEventHandlerInstancesForDelegateDescription();
    internal static string get_UseGenericEventHandlerInstancesForEventMessage();
    internal static string get_UseGenericEventHandlerInstancesForEventDescription();
    internal static string get_UseGenericEventHandlerInstancesForEvent2Message();
    internal static string get_UseGenericEventHandlerInstancesForEvent2Description();
    internal static string get_EnumsShouldHaveZeroValueTitle();
    internal static string get_EnumsShouldHaveZeroValueDescription();
    internal static string get_EnumsShouldHaveZeroValueMessageFlagsRename();
    internal static string get_EnumsShouldHaveZeroValueMessageFlagsMultipleZeros();
    internal static string get_EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue();
    internal static string get_AbstractTypesShouldNotHaveConstructorsTitle();
    internal static string get_AbstractTypesShouldNotHaveConstructorsDescription();
    internal static string get_AbstractTypesShouldNotHaveConstructorsMessage();
    internal static string get_LoggerMessageDiagnosticNumericsInFormatStringTitle();
    internal static string get_LoggerMessageDiagnosticNumericsInFormatStringMessage();
    internal static string get_LoggerMessageDiagnosticNumericsInFormatStringDescription();
    internal static string get_LoggerMessageDiagnosticFormatParameterCountMismatchTitle();
    internal static string get_LoggerMessageDiagnosticFormatParameterCountMismatchMessage();
    internal static string get_LoggerMessageDiagnosticFormatParameterCountMismatchDescription();
    internal static string get_LoggerMessageDiagnosticUseCompiledLogMessagesTitle();
    internal static string get_LoggerMessageDiagnosticUseCompiledLogMessagesMessage();
    internal static string get_LoggerMessageDiagnosticUseCompiledLogMessagesDescription();
    internal static string get_LoggerMessageDiagnosticConcatenationInFormatStringTitle();
    internal static string get_LoggerMessageDiagnosticConcatenationInFormatStringMessage();
    internal static string get_LoggerMessageDiagnosticConcatenationInFormatStringDescription();
    internal static string get_LoggerMessageDiagnosticUsePascalCasedLogMessageTokensTitle();
    internal static string get_LoggerMessageDiagnosticUsePascalCasedLogMessageTokensMessage();
    internal static string get_LoggerMessageDiagnosticUsePascalCasedLogMessageTokensDescription();
    internal static string get_MarkAssembliesWithClsCompliantTitle();
    internal static string get_MarkAssembliesWithClsCompliantDescription();
    internal static string get_MarkAssembliesWithClsCompliantMessage();
    internal static string get_MarkAssembliesWithAssemblyVersionTitle();
    internal static string get_MarkAssembliesWithAssemblyVersionDescription();
    internal static string get_MarkAssembliesWithAssemblyVersionMessage();
    internal static string get_MarkAssembliesWithComVisibleTitle();
    internal static string get_MarkAssembliesWithComVisibleDescription();
    internal static string get_MarkAttributesWithAttributeUsageTitle();
    internal static string get_MarkAttributesWithAttributeUsageMessageDefault();
    internal static string get_DefineAccessorsForAttributeArgumentsTitle();
    internal static string get_DefineAccessorsForAttributeArgumentsMessageDefault();
    internal static string get_DefineAccessorsForAttributeArgumentsMessageRemoveSetter();
    internal static string get_DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility();
    internal static string get_UsePropertiesWhereAppropriateTitle();
    internal static string get_UsePropertiesWhereAppropriateDescription();
    internal static string get_UsePropertiesWhereAppropriateMessage();
    internal static string get_MarkEnumsWithFlagsTitle();
    internal static string get_MarkEnumsWithFlagsDescription();
    internal static string get_MarkEnumsWithFlagsMessage();
    internal static string get_InterfaceMethodsShouldBeCallableByChildTypesTitle();
    internal static string get_InterfaceMethodsShouldBeCallableByChildTypesDescription();
    internal static string get_InterfaceMethodsShouldBeCallableByChildTypesMessage();
    internal static string get_OverrideMethodsOnComparableTypesTitle();
    internal static string get_OverrideMethodsOnComparableTypesDescription();
    internal static string get_OverrideMethodsOnComparableTypesMessageEquals();
    internal static string get_OverrideMethodsOnComparableTypesMessageOperator();
    internal static string get_MovePInvokesToNativeMethodsClassTitle();
    internal static string get_MovePInvokesToNativeMethodsClassDescription();
    internal static string get_MovePInvokesToNativeMethodsClassMessage();
    internal static string get_IdentifiersShouldDifferByMoreThanCaseTitle();
    internal static string get_IdentifiersShouldDifferByMoreThanCaseDescription();
    internal static string get_IdentifiersShouldDifferByMoreThanCaseMessage();
    internal static string get_IdentifiersShouldHaveCorrectPrefixTitle();
    internal static string get_IdentifiersShouldHaveCorrectPrefixDescription();
    internal static string get_IdentifiersShouldHaveCorrectPrefixMessageInterface();
    internal static string get_IdentifiersShouldHaveCorrectPrefixMessageTypeParameter();
    internal static string get_NonConstantFieldsShouldNotBeVisibleTitle();
    internal static string get_NonConstantFieldsShouldNotBeVisibleDescription();
    internal static string get_NonConstantFieldsShouldNotBeVisibleMessage();
    internal static string get_DoNotMarkEnumsWithFlagsTitle();
    internal static string get_DoNotMarkEnumsWithFlagsDescription();
    internal static string get_DoNotMarkEnumsWithFlagsMessage();
    internal static string get_OperatorOverloadsHaveNamedAlternatesTitle();
    internal static string get_OperatorOverloadsHaveNamedAlternatesDescription();
    internal static string get_OperatorOverloadsHaveNamedAlternatesMessageDefault();
    internal static string get_OperatorOverloadsHaveNamedAlternatesMessageProperty();
    internal static string get_OperatorOverloadsHaveNamedAlternatesMessageMultiple();
    internal static string get_OperatorOverloadsHaveNamedAlternatesMessageVisibility();
    internal static string get_OperatorsShouldHaveSymmetricalOverloadsTitle();
    internal static string get_OperatorsShouldHaveSymmetricalOverloadsDescription();
    internal static string get_CollectionPropertiesShouldBeReadOnlyTitle();
    internal static string get_CollectionPropertiesShouldBeReadOnlyDescription();
    internal static string get_CollectionPropertiesShouldBeReadOnlyMessage();
    internal static string get_OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle();
    internal static string get_OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription();
    internal static string get_OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage();
    internal static string get_PassSystemUriObjectsInsteadOfStringsTitle();
    internal static string get_PassSystemUriObjectsInsteadOfStringsDescription();
    internal static string get_PassSystemUriObjectsInsteadOfStringsMessage();
    internal static string get_ImplementIEquatableWhenOverridingObjectEqualsMessage();
    internal static string get_ImplementIEquatableWhenOverridingObjectEqualsTitle();
    internal static string get_CancellationTokenParametersMustComeLastTitle();
    internal static string get_CancellationTokenParametersMustComeLastMessage();
    internal static string get_IdentifiersShouldNotContainTypeNamesTitle();
    internal static string get_IdentifiersShouldNotContainTypeNamesDescription();
    internal static string get_IdentifiersShouldNotContainTypeNamesMessage();
    internal static string get_CreatePropertyAccessorForParameter();
    internal static string get_MakeGetterPublic();
    internal static string get_MakeSetterNonPublic();
    internal static string get_AddAssemblyLevelComVisibleFalse();
    internal static string get_ChangeAssemblyLevelComVisibleToFalse();
    internal static string get_ImplementComparable();
    internal static string get_ImplementEquatable();
    internal static string get_ImplementIDisposableInterface();
    internal static string get_DoNotMarkEnumsWithFlagsCodeFix();
    internal static string get_MarkEnumsWithFlagsCodeFix();
    internal static string get_EnumsShouldZeroValueFlagsMultipleZeroCodeFix();
    internal static string get_EnumsShouldZeroValueFlagsRenameCodeFix();
    internal static string get_EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix();
    internal static string get_AbstractTypesShouldNotHavePublicConstructorsCodeFix();
    internal static string get_DoNotDeclareStaticMembersOnGenericTypesTitle();
    internal static string get_DoNotDeclareStaticMembersOnGenericTypesDescription();
    internal static string get_DoNotDeclareStaticMembersOnGenericTypesMessage();
    internal static string get_CollectionsShouldImplementGenericInterfaceTitle();
    internal static string get_CollectionsShouldImplementGenericInterfaceDescription();
    internal static string get_CollectionsShouldImplementGenericInterfaceMessage();
    internal static string get_EnumStorageShouldBeInt32Title();
    internal static string get_EnumStorageShouldBeInt32Description();
    internal static string get_EnumStorageShouldBeInt32Message();
    internal static string get_UseEventsWhereAppropriateTitle();
    internal static string get_UseEventsWhereAppropriateDescription();
    internal static string get_UseEventsWhereAppropriateMessage();
    internal static string get_ImplementStandardExceptionConstructorsTitle();
    internal static string get_ImplementStandardExceptionConstructorsDescription();
    internal static string get_ImplementStandardExceptionConstructorsMessageMissingConstructor();
    internal static string get_NestedTypesShouldNotBeVisibleTitle();
    internal static string get_NestedTypesShouldNotBeVisibleDescription();
    internal static string get_NestedTypesShouldNotBeVisibleMessageDefault();
    internal static string get_NestedTypesShouldNotBeVisibleMessageVisualBasicModule();
    internal static string get_AvoidEmptyInterfacesTitle();
    internal static string get_AvoidEmptyInterfacesDescription();
    internal static string get_AvoidEmptyInterfacesMessage();
    internal static string get_ProvideObsoleteAttributeMessageTitle();
    internal static string get_ProvideObsoleteAttributeMessageDescription();
    internal static string get_ProvideObsoleteAttributeMessageMessage();
    internal static string get_PropertiesShouldNotBeWriteOnlyTitle();
    internal static string get_PropertiesShouldNotBeWriteOnlyDescription();
    internal static string get_PropertiesShouldNotBeWriteOnlyMessageAddGetter();
    internal static string get_PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible();
    internal static string get_DeclareTypesInNamespacesTitle();
    internal static string get_DeclareTypesInNamespacesDescription();
    internal static string get_DeclareTypesInNamespacesMessage();
    internal static string get_DoNotDeclareVisibleInstanceFieldsTitle();
    internal static string get_DoNotDeclareVisibleInstanceFieldsDescription();
    internal static string get_DoNotDeclareVisibleInstanceFieldsMessage();
    internal static string get_UriParametersShouldNotBeStringsTitle();
    internal static string get_UriParametersShouldNotBeStringsDescription();
    internal static string get_UriParametersShouldNotBeStringsMessage();
    internal static string get_UriReturnValuesShouldNotBeStringsTitle();
    internal static string get_UriReturnValuesShouldNotBeStringsDescription();
    internal static string get_UriReturnValuesShouldNotBeStringsMessage();
    internal static string get_UriPropertiesShouldNotBeStringsTitle();
    internal static string get_UriPropertiesShouldNotBeStringsDescription();
    internal static string get_UriPropertiesShouldNotBeStringsMessage();
    internal static string get_ImplementIDisposableCorrectlyTitle();
    internal static string get_ImplementIDisposableCorrectlyDescription();
    internal static string get_ImplementIDisposableCorrectlyMessageIDisposableReimplementation();
    internal static string get_ImplementIDisposableCorrectlyMessageFinalizeOverride();
    internal static string get_ImplementIDisposableCorrectlyMessageDisposeOverride();
    internal static string get_ImplementIDisposableCorrectlyMessageDisposeSignature();
    internal static string get_ImplementIDisposableCorrectlyMessageRenameDispose();
    internal static string get_ImplementIDisposableCorrectlyMessageDisposeBoolSignature();
    internal static string get_ImplementIDisposableCorrectlyMessageDisposeImplementation();
    internal static string get_ImplementIDisposableCorrectlyMessageFinalizeImplementation();
    internal static string get_ImplementIDisposableCorrectlyMessageProvideDisposeBool();
    internal static string get_ExceptionsShouldBePublicTitle();
    internal static string get_ExceptionsShouldBePublicDescription();
    internal static string get_ExceptionsShouldBePublicMessage();
    internal static string get_DoNotRaiseExceptionsInUnexpectedLocationsTitle();
    internal static string get_DoNotRaiseExceptionsInUnexpectedLocationsDescription();
    internal static string get_DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter();
    internal static string get_DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions();
    internal static string get_DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions();
    internal static string get_IdentifiersShouldNotContainUnderscoresTitle();
    internal static string get_IdentifiersShouldNotContainUnderscoresDescription();
    internal static string get_IdentifiersShouldNotContainUnderscoresMessageAssembly();
    internal static string get_IdentifiersShouldNotContainUnderscoresMessageNamespace();
    internal static string get_IdentifiersShouldNotContainUnderscoresMessageType();
    internal static string get_IdentifiersShouldNotContainUnderscoresMessageMember();
    internal static string get_IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter();
    internal static string get_IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter();
    internal static string get_IdentifiersShouldNotContainUnderscoresMessageMemberParameter();
    internal static string get_IdentifiersShouldNotContainUnderscoresMessageDelegateParameter();
    internal static string get_IdentifiersShouldHaveCorrectSuffixTitle();
    internal static string get_IdentifiersShouldHaveCorrectSuffixDescription();
    internal static string get_IdentifiersShouldHaveCorrectSuffixMessageDefault();
    internal static string get_IdentifiersShouldHaveCorrectSuffixMessageMultiple();
    internal static string get_IdentifiersShouldNotHaveIncorrectSuffixTitle();
    internal static string get_IdentifiersShouldNotHaveIncorrectSuffixDescription();
    internal static string get_IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate();
    internal static string get_IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion();
    internal static string get_IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion();
    internal static string get_IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate();
    internal static string get_IdentifiersShouldNotMatchKeywordsTitle();
    internal static string get_IdentifiersShouldNotMatchKeywordsDescription();
    internal static string get_IdentifiersShouldNotMatchKeywordsMessageMemberParameter();
    internal static string get_IdentifiersShouldNotMatchKeywordsMessageMember();
    internal static string get_IdentifiersShouldNotMatchKeywordsMessageType();
    internal static string get_IdentifiersShouldNotMatchKeywordsMessageNamespace();
    internal static string get_PropertyNamesShouldNotMatchGetMethodsTitle();
    internal static string get_PropertyNamesShouldNotMatchGetMethodsDescription();
    internal static string get_PropertyNamesShouldNotMatchGetMethodsMessage();
    internal static string get_TypeNamesShouldNotMatchNamespacesTitle();
    internal static string get_TypeNamesShouldNotMatchNamespacesDescription();
    internal static string get_TypeNamesShouldNotMatchNamespacesMessageDefault();
    internal static string get_TypeNamesShouldNotMatchNamespacesMessageSystem();
    internal static string get_ParameterNamesShouldMatchBaseDeclarationTitle();
    internal static string get_ParameterNamesShouldMatchBaseDeclarationDescription();
    internal static string get_ParameterNamesShouldMatchBaseDeclarationMessage();
    internal static string get_OverrideEqualsAndOperatorEqualsOnValueTypesTitle();
    internal static string get_OverrideEqualsAndOperatorEqualsOnValueTypesDescription();
    internal static string get_OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals();
    internal static string get_OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality();
    internal static string get_PropertiesShouldNotReturnArraysTitle();
    internal static string get_PropertiesShouldNotReturnArraysDescription();
    internal static string get_PropertiesShouldNotReturnArraysMessage();
    internal static string get_OverrideGetHashCodeOnOverridingEqualsTitle();
    internal static string get_OverrideGetHashCodeOnOverridingEqualsDescription();
    internal static string get_OverrideGetHashCodeOnOverridingEqualsMessage();
    internal static string get_OverrideEqualsOnOverloadingOperatorEqualsTitle();
    internal static string get_OverrideEqualsOnOverloadingOperatorEqualsDescription();
    internal static string get_OverrideEqualsOnOverloadingOperatorEqualsMessage();
    internal static string get_Since_0_redefines_operator_1_it_should_also_redefine_operator_2();
    internal static string get_Generate_missing_operators();
    internal static string get_OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle();
    internal static string get_OverrideEqualsOnImplementingIEquatableCodeActionTitle();
    internal static string get_OverrideGetHashCodeOnOverridingEqualsCodeActionTitle();
    internal static string get_MakeExceptionPublic();
    internal static string get_InterfaceMethodsShouldBeCallableByChildTypesFix1();
    internal static string get_InterfaceMethodsShouldBeCallableByChildTypesFix2();
    internal static string get_InterfaceMethodsShouldBeCallableByChildTypesFix3();
    internal static string get_StaticHolderTypeIsNotStatic();
    internal static string get_StaticHolderTypesShouldBeStaticOrNotInheritable();
    internal static string get_MakeClassStatic();
    internal static string get_OverrideObjectEqualsMessage();
    internal static string get_OverrideObjectEqualsTitle();
    internal static string get_UseIntegralOrStringArgumentForIndexersDescription();
    internal static string get_UseIntegralOrStringArgumentForIndexersMessage();
    internal static string get_UseIntegralOrStringArgumentForIndexersTitle();
    internal static string get_DoNotDirectlyAwaitATaskDescription();
    internal static string get_DoNotDirectlyAwaitATaskMessage();
    internal static string get_DoNotDirectlyAwaitATaskTitle();
    internal static string get_AppendConfigureAwaitFalse();
    internal static string get_AppendConfigureAwaitTrue();
    internal static string get_ImplementIEquatableWhenOverridingObjectEqualsDescription();
    internal static string get_OverrideObjectEqualsDescription();
    internal static string get_RenameToTitle();
    internal static string get_DoNotHideBaseClassMethodsDescription();
    internal static string get_DoNotHideBaseClassMethodsMessage();
    internal static string get_DoNotHideBaseClassMethodsTitle();
    internal static string get_OverrideMethodsOnComparableTypesMessageBoth();
    internal static string get_DoNotCatchGeneralExceptionTypesDescription();
    internal static string get_DoNotCatchGeneralExceptionTypesMessage();
    internal static string get_DoNotCatchGeneralExceptionTypesTitle();
    internal static string get_DoNotPrefixEnumValuesWithTypeNameDescription();
    internal static string get_DoNotPrefixEnumValuesWithTypeNameMessage();
    internal static string get_DoNotPrefixEnumValuesWithTypeNameTitle();
    internal static string get_AvoidUsingCrefTagsWithAPrefixTitle();
    internal static string get_AvoidUsingCrefTagsWithAPrefixDescription();
    internal static string get_AvoidUsingCrefTagsWithAPrefixMessage();
    internal static string get_DoNotIgnoreMethodResultsTitle();
    internal static string get_DoNotIgnoreMethodResultsDescription();
    internal static string get_DoNotIgnoreMethodResultsMessageObjectCreation();
    internal static string get_DoNotIgnoreMethodResultsMessageStringCreation();
    internal static string get_DoNotIgnoreMethodResultsMessageHResultOrErrorCode();
    internal static string get_DoNotIgnoreMethodResultsMessageTryParse();
    internal static string get_AvoidUninstantiatedInternalClassesTitle();
    internal static string get_AvoidUninstantiatedInternalClassesDescription();
    internal static string get_AvoidUninstantiatedInternalClassesMessage();
    internal static string get_AvoidUnusedPrivateFieldsTitle();
    internal static string get_AvoidUnusedPrivateFieldsDescription();
    internal static string get_AvoidUnusedPrivateFieldsMessage();
    internal static string get_DoNotIgnoreMethodResultsMessagePureMethod();
    internal static string get_UseNameOfInPlaceOfStringDescription();
    internal static string get_UseNameOfInPlaceOfStringMessage();
    internal static string get_UseNameOfInPlaceOfStringTitle();
    internal static string get_AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage();
    internal static string get_AvoidDeadConditionalCodeNeverNullMessage();
    internal static string get_AvoidDeadConditionalCodeTitle();
    internal static string get_AvoidExcessiveClassCouplingDescription();
    internal static string get_AvoidExcessiveClassCouplingMessage();
    internal static string get_AvoidExcessiveClassCouplingTitle();
    internal static string get_AvoidExcessiveComplexityDescription();
    internal static string get_AvoidExcessiveComplexityMessage();
    internal static string get_AvoidExcessiveComplexityTitle();
    internal static string get_AvoidExcessiveInheritanceDescription();
    internal static string get_AvoidExcessiveInheritanceMessage();
    internal static string get_AvoidExcessiveInheritanceTitle();
    internal static string get_AvoidUnmantainableCodeDescription();
    internal static string get_AvoidUnmantainableCodeMessage();
    internal static string get_AvoidUnmantainableCodeTitle();
    internal static string get_InvalidEntryInCodeMetricsConfigFileDescription();
    internal static string get_InvalidEntryInCodeMetricsConfigFileMessage();
    internal static string get_InvalidEntryInCodeMetricsConfigFileTitle();
    internal static string get_UseLiteralsWhereAppropriateTitle();
    internal static string get_UseLiteralsWhereAppropriateDescription();
    internal static string get_UseLiteralsWhereAppropriateMessageDefault();
    internal static string get_UseLiteralsWhereAppropriateMessageEmptyString();
    internal static string get_DoNotInitializeUnnecessarilyTitle();
    internal static string get_DoNotInitializeUnnecessarilyDescription();
    internal static string get_DoNotInitializeUnnecessarilyMessage();
    internal static string get_DoNotInitializeUnnecessarilyFix();
    internal static string get_PreferJaggedArraysOverMultidimensionalTitle();
    internal static string get_PreferJaggedArraysOverMultidimensionalDescription();
    internal static string get_PreferJaggedArraysOverMultidimensionalMessageDefault();
    internal static string get_PreferJaggedArraysOverMultidimensionalMessageReturn();
    internal static string get_PreferJaggedArraysOverMultidimensionalMessageBody();
    internal static string get_MarkMembersAsStaticTitle();
    internal static string get_MarkMembersAsStaticDescription();
    internal static string get_MarkMembersAsStaticMessage();
    internal static string get_SealMethodsThatSatisfyPrivateInterfacesTitle();
    internal static string get_SealMethodsThatSatisfyPrivateInterfacesDescription();
    internal static string get_SealMethodsThatSatisfyPrivateInterfacesMessage();
    internal static string get_RemoveEmptyFinalizers();
    internal static string get_RemoveEmptyFinalizersDescription();
    internal static string get_DoNotCallOverridableMethodsInConstructors();
    internal static string get_DoNotCallOverridableMethodsInConstructorsDescription();
    internal static string get_RethrowToPreserveStackDetailsMessage();
    internal static string get_RethrowToPreserveStackDetailsTitle();
    internal static string get_MakeDeclaringTypeInternal();
    internal static string get_MakeDeclaringTypeSealed();
    internal static string get_MakeMemberNotOverridable();
    internal static string get_DoNotRaiseExceptionsInExceptionClausesDescription();
    internal static string get_DoNotRaiseExceptionsInExceptionClausesMessageFinally();
    internal static string get_DoNotRaiseExceptionsInExceptionClausesTitle();
    internal static string get_UseLiteralsWhereAppropriateCodeActionTitle();
    internal static string get_AvoidDuplicateElementInitializationDescription();
    internal static string get_AvoidDuplicateElementInitializationMessage();
    internal static string get_AvoidDuplicateElementInitializationTitle();
    internal static string get_RemoveRedundantElementInitializationCodeFixTitle();
    internal static string get_ValidateArgumentsOfPublicMethodsDescription();
    internal static string get_ValidateArgumentsOfPublicMethodsMessage();
    internal static string get_ValidateArgumentsOfPublicMethodsTitle();
    internal static string get_MarkMembersAsStaticCodeFix();
    internal static string get_MarkMembersAsStaticCodeFix_WarningAnnotation();
    internal static string get_AvoidPropertySelfAssignmentTitle();
    internal static string get_AvoidPropertySelfAssignmentMessage();
    internal static string get_AssigningSymbolAndItsMemberInSameStatementDescription();
    internal static string get_AssigningSymbolAndItsMemberInSameStatementMessage();
    internal static string get_AssigningSymbolAndItsMemberInSameStatementTitle();
    internal static string get_AvoidInfiniteRecursionMessageSure();
    internal static string get_AvoidInfiniteRecursionTitle();
    internal static string get_AvoidInfiniteRecursionMessageMaybe();
    internal static string get_AvoidOutParametersDescription();
    internal static string get_AvoidOutParametersMessage();
    internal static string get_AvoidOutParametersTitle();
    internal static string get_EnumShouldNotHaveDuplicatedValuesMessageDuplicatedBitwiseValuePart();
    internal static string get_EnumShouldNotHaveDuplicatedValuesMessageDuplicatedValue();
    internal static string get_EnumShouldNotHaveDuplicatedValuesTitle();
    internal static string get_DoNotDeclareProtectedMembersInSealedTypesDescription();
    internal static string get_DoNotDeclareProtectedMembersInSealedTypesMessage();
    internal static string get_DoNotDeclareProtectedMembersInSealedTypesTitle();
    internal static string get_AvoidExcessiveParametersOnGenericTypesDescription();
    internal static string get_AvoidExcessiveParametersOnGenericTypesMessage();
    internal static string get_AvoidExcessiveParametersOnGenericTypesTitle();
    internal static string get_DoNotIgnoreMethodResultsMessageLinqMethod();
    internal static string get_DoNotNameEnumValuesReservedDescription();
    internal static string get_DoNotNameEnumValuesReservedMessage();
    internal static string get_DoNotNameEnumValuesReservedTitle();
    internal static string get_DoNotExposeGenericListsDescription();
    internal static string get_DoNotExposeGenericListsMessage();
    internal static string get_DoNotExposeGenericListsTitle();
    internal static string get_DoNotDeclareEventFieldsAsVirtualDescription();
    internal static string get_DoNotDeclareEventFieldsAsVirtualMessage();
    internal static string get_DoNotDeclareEventFieldsAsVirtualTitle();
    internal static string get_DoNotOverloadOperatorEqualsOnReferenceTypesDescription();
    internal static string get_DoNotOverloadOperatorEqualsOnReferenceTypesMessage();
    internal static string get_DoNotOverloadOperatorEqualsOnReferenceTypesTitle();
    internal static string get_DoNotPassTypesByReferenceMessage();
    internal static string get_DoNotPassTypesByReferenceTitle();
    internal static string get_DoNotPassTypesByReferenceDescription();
    internal static string get_EventsShouldNotHaveBeforeOrAfterPrefixDescription();
    internal static string get_EventsShouldNotHaveBeforeOrAfterPrefixMessage();
    internal static string get_EventsShouldNotHaveBeforeOrAfterPrefixTitle();
    internal static string get_DoNotIgnoreMethodResultsMessageUserDefinedMethod();
    internal static string get_IdentifiersShouldNotContainUnderscoresCodeFixTitle();
    internal static string get_MarkAttributesWithAttributeUsageCodeFix();
    internal static string get_UriParametersShouldNotBeStringsCodeFixTitle();
    internal static string get_OperatorOverloadsHaveNamedAlternatesCodeFixTitle();
    internal static string get_AvoidMultipleEnumerationsMessage();
    internal static string get_AvoidMultipleEnumerationsTitle();
    internal static string get_CollectionsShouldImplementGenericInterfaceMultipleMessage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AssigningSymbolAndItsMemberInSameStatement : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AssigningSymbolAndItsMemberInSameStatement();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeAssignment(OperationAnalysisContext context);
    private static bool AnalyzeAssignmentToMember(ISimpleAssignmentOperation assignmentOperation, T instance, Func`3<T, T, bool> equalityComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidDuplicateElementInitialization : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidDuplicateElementInitialization();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeOperation(OperationAnalysisContext context);
    private static ImmutableArray`1<object> GetConstantArgumentValues(ImmutableArray`1<IArgumentOperation> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidInfiniteRecursion : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    internal static DiagnosticDescriptor MaybeRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidInfiniteRecursion();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.AvoidMultipleEnumerations : DiagnosticAnalyzer {
    private static string RuleId;
    private static DiagnosticDescriptor MultipleEnumerableDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_additionalDeferredTypes;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, string>> s_immutableCollectionsTypeNamesAndConvensionMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_constructorsEnumeratedParameterTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_enumeratedParametersLinqMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_linqChainMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_noEffectLinqChainMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_noEnumerationLinqMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidMultipleEnumerations();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual bool IsExpressionOfForEachStatement(SyntaxNode syntax);
    public virtual void Initialize(AnalysisContext context);
    private void CompilationStartAction(CompilationStartAnalysisContext context);
    private void OnOperationBlockStart(ImmutableArray`1<IMethodSymbol> linqChainMethods, ImmutableArray`1<IMethodSymbol> noEnumerationMethods, ImmutableArray`1<IMethodSymbol> enumeratedMethods, ImmutableArray`1<IMethodSymbol> noEffectLinqChainMethods, ImmutableArray`1<ITypeSymbol> additionalDeferredTypes, ImmutableArray`1<IMethodSymbol> getEnumeratorSymbols, OperationBlockStartAnalysisContext context);
    private static void CollectPotentialDiagnosticOperations(OperationAnalysisContext context, WellKnownSymbolsInfo wellKnownSymbolsInfo, PooledHashSet`1<IOperation> builder);
    private static bool IsEnumerated(IOperation operation, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    private void Analyze(OperationBlockAnalysisContext context, WellKnownTypeProvider wellKnownTypeProvider, WellKnownSymbolsInfo wellKnownSymbolsInfo, PooledHashSet`1<IOperation> potentialDiagnosticOperations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.AvoidMultipleEnumerationsHelpers : object {
    public static ValueTuple`2<IOperation, EnumerationCount> SkipLinqChainAndConversionMethod(IOperation operation, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    [NullableContextAttribute("2")]
public static bool IsValidImplicitConversion(IOperation operation, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    public static bool IsOperationEnumeratedByForEachLoop(IOperation operation, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    private static bool IsInstanceOfLinqChainInvocation(IOperation operation, WellKnownSymbolsInfo wellKnownSymbolsInfo, Boolean& enumerateInstance);
    public static bool IsOperationEnumeratedByInvocation(IOperation operation, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    private static IParameterSymbol GetReducedFromParameter(IMethodSymbol methodSymbol, IParameterSymbol parameterSymbol);
    private static bool IsInvocationCausingEnumerationOverInvocationInstance(IInvocationOperation invocationOperation, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    private static bool IsInvocationCausingEnumerationOverArgument(IInvocationOperation invocationOperation, IArgumentOperation argumentOperationToCheck, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    private static bool IsObjectCreationOperationCausingEnumerationOverArgument(IObjectCreationOperation objectCreationOperation, IArgumentOperation argumentOperation, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    private static bool IsInvokingMethodEnumeratedOverArgument(IMethodSymbol invokingMethod, IArgumentOperation argumentOperation, WellKnownSymbolsInfo wellKnownSymbolsInfo);
    [NullableContextAttribute("2")]
private static bool IsOperationIsArgumentOfLinqChainInvocation(IOperation operation, WellKnownSymbolsInfo wellKnownSymbolsInfo, Boolean& enumerateArgument);
    public static bool IsLinqChainInvocation(IInvocationOperation invocationOperation, IArgumentOperation argumentOperationToCheck, WellKnownSymbolsInfo wellKnownSymbolsInfo, Boolean& enumerateArgument);
    public static bool IsLinqChainInvocation(IInvocationOperation invocationOperation, WellKnownSymbolsInfo wellKnownSymbolsInfo, Boolean& enumerateInstance);
    public static ImmutableArray`1<IMethodSymbol> GetEnumeratedMethods(WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<ValueTuple`2<string, string>> typeAndMethodNames, ImmutableArray`1<string> linqMethodNames, ImmutableArray`1<string> constructorTypeNames);
    public static void GetConstructors(WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<string> typeNames, ArrayBuilder`1<IMethodSymbol> builder);
    private static void GetImmutableCollectionConversionMethods(WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<ValueTuple`2<string, string>> typeAndMethodNames, ArrayBuilder`1<IMethodSymbol> builder);
    public static ImmutableArray`1<IMethodSymbol> GetGetEnumeratorMethods(WellKnownTypeProvider wellKnownTypeProvider);
    private static bool IsConstraintTypesHasDeferredType(ITypeParameterSymbol typeParameterSymbol, ImmutableArray`1<ITypeSymbol> additionalTypesToCheck);
    [NullableContextAttribute("2")]
public static bool IsDeferredType(ITypeSymbol type, ImmutableArray`1<ITypeSymbol> additionalTypesToCheck);
    public static ImmutableArray`1<ITypeSymbol> GetTypes(Compilation compilation, ImmutableArray`1<string> typeNames);
    public static ImmutableArray`1<IMethodSymbol> GetLinqMethods(WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<string> methodNames);
    private static void GetWellKnownMethods(WellKnownTypeProvider wellKnownTypeProvider, string typeName, ImmutableArray`1<string> methodNames, ArrayBuilder`1<IMethodSymbol> builder);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IOperation, EnumerationCount> <SkipLinqChainAndConversionMethod>g__VisitLinqChainAndCoversionMethod|0_0(IOperation operation, EnumerationCount enumerationCount, WellKnownSymbolsInfo wellKnownSymbolsInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.DeferredTypeCreationEntity : CacheBasedEquatable`1<DeferredTypeCreationEntity> {
    [CompilerGeneratedAttribute]
private IOperation <CreationOperation>k__BackingField;
    public IOperation CreationOperation { get; }
    public DeferredTypeCreationEntity(IOperation creationOperation);
    [CompilerGeneratedAttribute]
public IOperation get_CreationOperation();
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<DeferredTypeCreationEntity> obj);
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.DeferredTypeEntitySet : CacheBasedEquatable`1<DeferredTypeEntitySet> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<AbstractLocation> <DeferredTypeLocations>k__BackingField;
    public ImmutableHashSet`1<AbstractLocation> DeferredTypeLocations { get; }
    public DeferredTypeEntitySet(ImmutableHashSet`1<AbstractLocation> deferredTypeEntities);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<AbstractLocation> get_DeferredTypeLocations();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<DeferredTypeEntitySet> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.DeferredTypeSymbolEntity : CacheBasedEquatable`1<DeferredTypeSymbolEntity> {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    public ISymbol Symbol { get; }
    public DeferredTypeSymbolEntity(ISymbol symbol);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<DeferredTypeSymbolEntity> obj);
}
internal enum Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.EnumerationCount : Enum {
    public int value__;
    public static EnumerationCount None;
    public static EnumerationCount Zero;
    public static EnumerationCount One;
    public static EnumerationCount TwoOrMoreTime;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.GlobalFlowStateDictionaryAnalysis : ForwardDataFlowAnalysis`5<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue> {
    public static MapAbstractDomain`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> Domain;
    public GlobalFlowStateDictionaryAnalysis(AbstractAnalysisDomain`1<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue>> analysisDomain, DataFlowOperationVisitor`4<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisValue> operationVisitor);
    private static GlobalFlowStateDictionaryAnalysis();
    public static DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, Func`2<GlobalFlowStateDictionaryAnalysisContext, GlobalFlowStateDictionaryFlowOperationVisitor> createOperationVisitor, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, bool pessimisticAnalysis, InterproceduralAnalysisKind interproceduralAnalysisKind, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    private static DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue> TryGetOrComputeAnalysisResult(GlobalFlowStateDictionaryAnalysisContext analysisContext, Func`2<GlobalFlowStateDictionaryAnalysisContext, GlobalFlowStateDictionaryFlowOperationVisitor> createOperationVisitor);
    protected virtual DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue> ToResult(GlobalFlowStateDictionaryAnalysisContext analysisContext, DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue> dataFlowAnalysisResult);
    protected virtual GlobalFlowStateDictionaryBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.GlobalFlowStateDictionaryAnalysisContext : AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisValue> {
    public GlobalFlowStateDictionaryAnalysisContext(AbstractValueDomain`1<GlobalFlowStateDictionaryAnalysisValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool predicateAnalysis, bool exceptionPathsAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Func`2<GlobalFlowStateDictionaryAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue>> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraph, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisContext, GlobalFlowStateDictionaryAnalysisValue> interproceduralAnalysisData, InterproceduralAnalysisPredicate interproceduralAnalysisPredicate);
    public virtual GlobalFlowStateDictionaryAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, PointsToAnalysisResult pointsToAnalysisResult, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResult, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisContext, GlobalFlowStateDictionaryAnalysisValue> interproceduralAnalysisData);
    protected virtual bool ComputeEqualsByHashCodeParts(AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisValue> obj);
    protected virtual void ComputeHashCodePartsSpecific(RoslynHashCode& hashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.GlobalFlowStateDictionaryAnalysisValue : CacheBasedEquatable`1<GlobalFlowStateDictionaryAnalysisValue> {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<IDeferredTypeEntity, TrackingEnumerationSet> <TrackedEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private GlobalFlowStateDictionaryAnalysisValueKind <Kind>k__BackingField;
    public static GlobalFlowStateDictionaryAnalysisValue Empty;
    public static GlobalFlowStateDictionaryAnalysisValue Unknown;
    public ImmutableDictionary`2<IDeferredTypeEntity, TrackingEnumerationSet> TrackedEntities { get; }
    public GlobalFlowStateDictionaryAnalysisValueKind Kind { get; }
    public GlobalFlowStateDictionaryAnalysisValue(ImmutableDictionary`2<IDeferredTypeEntity, TrackingEnumerationSet> trackedEntities, GlobalFlowStateDictionaryAnalysisValueKind kind);
    private static GlobalFlowStateDictionaryAnalysisValue();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<IDeferredTypeEntity, TrackingEnumerationSet> get_TrackedEntities();
    [CompilerGeneratedAttribute]
public GlobalFlowStateDictionaryAnalysisValueKind get_Kind();
    public static GlobalFlowStateDictionaryAnalysisValue Merge(GlobalFlowStateDictionaryAnalysisValue value1, GlobalFlowStateDictionaryAnalysisValue value2, bool intersectValueInCommonKeys);
    public static GlobalFlowStateDictionaryAnalysisValue Intersect(GlobalFlowStateDictionaryAnalysisValue value1, GlobalFlowStateDictionaryAnalysisValue value2);
    public GlobalFlowStateDictionaryAnalysisValue RemoveTrackedDeferredTypeEntity(IDeferredTypeEntity entity);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<GlobalFlowStateDictionaryAnalysisValue> obj);
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.GlobalFlowStateDictionaryAnalysisValueDomain : AbstractValueDomain`1<GlobalFlowStateDictionaryAnalysisValue> {
    public static GlobalFlowStateDictionaryAnalysisValueDomain Instance;
    public GlobalFlowStateDictionaryAnalysisValue UnknownOrMayBeValue { get; }
    public GlobalFlowStateDictionaryAnalysisValue Bottom { get; }
    private static GlobalFlowStateDictionaryAnalysisValueDomain();
    public virtual GlobalFlowStateDictionaryAnalysisValue get_UnknownOrMayBeValue();
    public virtual GlobalFlowStateDictionaryAnalysisValue get_Bottom();
    public virtual int Compare(GlobalFlowStateDictionaryAnalysisValue oldValue, GlobalFlowStateDictionaryAnalysisValue newValue, bool assertMonotonicity);
    public virtual GlobalFlowStateDictionaryAnalysisValue Merge(GlobalFlowStateDictionaryAnalysisValue value1, GlobalFlowStateDictionaryAnalysisValue value2);
    public static GlobalFlowStateDictionaryAnalysisValue Intersect(GlobalFlowStateDictionaryAnalysisValue value1, GlobalFlowStateDictionaryAnalysisValue value2);
}
internal enum Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.GlobalFlowStateDictionaryAnalysisValueKind : Enum {
    public int value__;
    public static GlobalFlowStateDictionaryAnalysisValueKind Empty;
    public static GlobalFlowStateDictionaryAnalysisValueKind Known;
    public static GlobalFlowStateDictionaryAnalysisValueKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.GlobalFlowStateDictionaryBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> <Data>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> Data { get; }
    public GlobalFlowStateDictionaryBlockAnalysisResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> data);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.GlobalFlowStateDictionaryFlowOperationVisitor : GlobalFlowStateDataFlowOperationVisitor`3<GlobalFlowStateDictionaryAnalysisContext, DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue>, GlobalFlowStateDictionaryAnalysisValue> {
    protected GlobalFlowStateDictionaryFlowOperationVisitor(GlobalFlowStateDictionaryAnalysisContext analysisContext);
    protected virtual bool Equals(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> value1, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> value2);
    protected virtual GlobalFlowStateDictionaryAnalysisValue GetAbstractDefaultValue(ITypeSymbol type);
    protected virtual DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> GetExitBlockOutputData(DataFlowAnalysisResult`2<GlobalFlowStateDictionaryBlockAnalysisResult, GlobalFlowStateDictionaryAnalysisValue> analysisResult);
    protected virtual DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> MergeAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> value1, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> value2);
    protected sealed virtual DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> MergeAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> value1, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> value2, BasicBlock forBlock);
    protected virtual DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> MergeAnalysisDataForBackEdge(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> value1, DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> value2, BasicBlock forBlock);
    protected sealed virtual void SetAbstractValue(DictionaryAnalysisData`2<AnalysisEntity, GlobalFlowStateDictionaryAnalysisValue> analysisData, AnalysisEntity analysisEntity, GlobalFlowStateDictionaryAnalysisValue value);
}
internal interface Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.IDeferredTypeEntity {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.InvocationSetHelpers : object {
    public static TrackingEnumerationSet Merge(TrackingEnumerationSet set1, TrackingEnumerationSet set2);
    public static TrackingEnumerationSet Intersect(TrackingEnumerationSet set1, TrackingEnumerationSet set2);
    private static EnumerationCount Min(EnumerationCount count1, EnumerationCount count2);
    public static EnumerationCount AddInvocationCount(EnumerationCount count1, EnumerationCount count2);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.FlowAnalysis.TrackingEnumerationSet : CacheBasedEquatable`1<TrackingEnumerationSet> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IOperation> <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private EnumerationCount <EnumerationCount>k__BackingField;
    public static TrackingEnumerationSet Empty;
    public ImmutableHashSet`1<IOperation> Operations { get; }
    public EnumerationCount EnumerationCount { get; }
    public TrackingEnumerationSet(ImmutableHashSet`1<IOperation> operations, EnumerationCount enumerationCount);
    private static TrackingEnumerationSet();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IOperation> get_Operations();
    [CompilerGeneratedAttribute]
public EnumerationCount get_EnumerationCount();
    protected virtual void ComputeHashCodeParts(RoslynHashCode& hashCode);
    protected virtual bool ComputeEqualsByHashCodeParts(CacheBasedEquatable`1<TrackingEnumerationSet> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidMultipleEnumerations.WellKnownSymbolsInfo : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <LinqChainMethods>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <NoEnumerationMethods>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <EnumeratedMethods>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <NoEffectLinqChainMethods>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <AdditionalDeferredTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <GetEnumeratorMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolNamesWithValueOption`1<Unit> <CustomizedEumerationMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolNamesWithValueOption`1<Unit> <CustomizedLinqChainMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssumeMethodEnumeratesParameters>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IMethodSymbol> LinqChainMethods { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IMethodSymbol> NoEnumerationMethods { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IMethodSymbol> EnumeratedMethods { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IMethodSymbol> NoEffectLinqChainMethods { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ITypeSymbol> AdditionalDeferredTypes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IMethodSymbol> GetEnumeratorMethods { get; }
    public SymbolNamesWithValueOption`1<Unit> CustomizedEumerationMethods { get; }
    public SymbolNamesWithValueOption`1<Unit> CustomizedLinqChainMethods { get; }
    public bool AssumeMethodEnumeratesParameters { get; }
    public WellKnownSymbolsInfo(ImmutableArray`1<IMethodSymbol> linqChainMethods, ImmutableArray`1<IMethodSymbol> noEnumerationMethods, ImmutableArray`1<IMethodSymbol> enumeratedMethods, ImmutableArray`1<IMethodSymbol> noEffectLinqChainMethods, ImmutableArray`1<ITypeSymbol> additionalDeferredTypes, ImmutableArray`1<IMethodSymbol> getEnumeratorMethods, SymbolNamesWithValueOption`1<Unit> customizedEumerationMethods, SymbolNamesWithValueOption`1<Unit> customizedLinqChainMethods, bool assumeMethodEnumeratesParameters);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_LinqChainMethods();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_NoEnumerationMethods();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_EnumeratedMethods();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_NoEffectLinqChainMethods();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ITypeSymbol> get_AdditionalDeferredTypes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_GetEnumeratorMethods();
    [CompilerGeneratedAttribute]
public SymbolNamesWithValueOption`1<Unit> get_CustomizedEumerationMethods();
    [CompilerGeneratedAttribute]
public SymbolNamesWithValueOption`1<Unit> get_CustomizedLinqChainMethods();
    [CompilerGeneratedAttribute]
public bool get_AssumeMethodEnumeratesParameters();
    public bool IsCustomizedEnumerationMethods(IMethodSymbol methodSymbol);
    public bool IsCustomizedLinqChainMethods(IMethodSymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.AvoidPropertySelfAssignment : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidPropertySelfAssignment();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsArgumentValueEqual|5_1(IOperation targetArg, IOperation valueArg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.DoNotCallOverridableMethodsInConstructorsAnalyzer : DiagnosticAnalyzer {
    public static string RuleId;
    private static LocalizableString s_localizableMessageAndTitle;
    public static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCallOverridableMethodsInConstructorsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeOperation(OperationAnalysisContext context, INamedTypeSymbol containingType);
    [NullableContextAttribute("2")]
private static bool ShouldOmitThisDiagnostic(ISymbol symbol, INamedTypeSymbol webUiControlType, INamedTypeSymbol componentModelComponentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.DoNotDeclareEventFieldsAsVirtual : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDeclareEventFieldsAsVirtual();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.QualityGuidelines.DoNotInitializeUnnecessarilyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor DefaultRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotInitializeUnnecessarilyAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual bool IsNullSuppressed(IOperation op);
    public sealed virtual void Initialize(AnalysisContext context);
    private bool UsesKnownDefaultValue(IOperation value, ITypeSymbol type);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(OperationAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_1(OperationAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.DoNotRaiseExceptionsInExceptionClausesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotRaiseExceptionsInExceptionClausesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.MarkMembersAsStaticAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MarkMembersAsStaticAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool ShouldAnalyze(IMethodSymbol methodSymbol, WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<INamedTypeSymbol> skippedAttributes, bool isWebProject, OperationBlockStartAnalysisContext context);
    private static bool IsExplicitlyVisibleFromCom(IMethodSymbol methodSymbol, WellKnownTypeProvider wellKnownTypeProvider);
    private static ImmutableArray`1<INamedTypeSymbol> GetSkippedAttributes(WellKnownTypeProvider wellKnownTypeProvider);
    private static bool IsOnObsoleteMemberChain(ISymbol symbol, WellKnownTypeProvider wellKnownTypeProvider);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__OnSymbolStart|5_1(SymbolStartAnalysisContext context, WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<INamedTypeSymbol> skippedAttributes, bool isWebProject);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <GetSkippedAttributes>g__Add|8_0(INamedTypeSymbol symbol, <>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.QualityGuidelines.MarkMembersAsStaticFixer : CodeFixProvider {
    private static SyntaxAnnotation s_annotationForFixedDeclaration;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static MarkMembersAsStaticFixer();
    protected abstract virtual IEnumerable`1<SyntaxNode> GetTypeArguments(SyntaxNode node);
    protected abstract virtual SyntaxNode GetExpressionOfInvocation(SyntaxNode invocation);
    protected virtual SyntaxNode GetSyntaxNodeToReplace(IMemberReferenceOperation memberReference);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.MarkMembersAsStaticFixer/<RegisterCodeFixesAsync>d__8")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.MarkMembersAsStaticFixer/<MakeStaticAsync>d__9")]
private Task`1<Solution> MakeStaticAsync(Document document, SyntaxNode root, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.MarkMembersAsStaticFixer/<UpdateReferencesAsync>d__10")]
private Task`1<ValueTuple`2<Solution, bool>> UpdateReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.MarkMembersAsStaticFixer/<AddWarningAnnotationAsync>d__11")]
private static Task`1<Document> AddWarningAnnotationAsync(Document document, ISymbol symbolFromEarlierSnapshot, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <UpdateReferencesAsync>g__IsReplacableOperation|10_1(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.PreferJaggedArraysOverMultidimensionalAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor DefaultRule;
    internal static DiagnosticDescriptor ReturnRule;
    internal static DiagnosticDescriptor BodyRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferJaggedArraysOverMultidimensionalAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeField(SymbolAnalysisContext context);
    private static void AnalyzeProperty(SymbolAnalysisContext context);
    private static void AnalyzeMethod(SymbolAnalysisContext context);
    private static void AnalyzeObjectCreation(OperationAnalysisContext context);
    private static void AnalyzeParameters(SymbolAnalysisContext context, ISymbol containingSymbol, ImmutableArray`1<IParameterSymbol> parameters);
    [NullableContextAttribute("2")]
private static bool IsMultiDimensionalArray(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.QualityGuidelines.PreferJaggedArraysOverMultidimensionalFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.RemoveEmptyFinalizersAnalyzer : DiagnosticAnalyzer {
    public static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RemoveEmptyFinalizersAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool CanDescendIntoOperation(IOperation operation, INamedTypeSymbol conditionalAttributeType, bool isMethodSurroundedWithDirective);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.RemoveEmptyFinalizersFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.RemoveEmptyFinalizersFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.RemoveEmptyFinalizersFixer/<RemoveFinalizerAsync>d__4")]
private static Task`1<Document> RemoveFinalizerAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.RethrowToPreserveStackDetailsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RethrowToPreserveStackDetailsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsReassignedInCatch(ICatchClauseOperation catchClause, ILocalReferenceOperation localReference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.RethrowToPreserveStackDetailsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.RethrowToPreserveStackDetailsFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.RethrowToPreserveStackDetailsFixer/<MakeThrowAsync>d__5")]
private static Task`1<Document> MakeThrowAsync(Document document, SyntaxNode nodeToReplace, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.SealMethodsThatSatisfyPrivateInterfacesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SealMethodsThatSatisfyPrivateInterfacesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void CheckTypes(SymbolAnalysisContext context);
    private static bool CanBeOverridden(ISymbol member);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.SealMethodsThatSatisfyPrivateInterfacesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
public sealed virtual FixAllProvider GetFixAllProvider();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.SealMethodsThatSatisfyPrivateInterfacesFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.QualityGuidelines.UseLiteralsWhereAppropriateAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor DefaultRule;
    internal static DiagnosticDescriptor EmptyStringRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseLiteralsWhereAppropriateAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual bool IsConstantInterpolatedStringSupported(ParseOptions compilation);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeQuality.Analyzers.QualityGuidelines.UseLiteralsWhereAppropriateFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.UseLiteralsWhereAppropriateFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeQuality.Analyzers.QualityGuidelines.UseLiteralsWhereAppropriateFixer/<ToConstantDeclarationAsync>d__5")]
private Task`1<Document> ToConstantDeclarationAsync(Document document, SyntaxNode fieldDeclaration, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetFieldDeclaration(SyntaxNode syntaxNode);
    protected abstract virtual bool IsStaticKeyword(SyntaxToken syntaxToken);
    protected abstract virtual bool IsReadonlyKeyword(SyntaxToken syntaxToken);
    protected abstract virtual SyntaxToken GetConstKeywordToken();
    protected abstract virtual SyntaxTokenList GetModifiers(SyntaxNode fieldSyntax);
    protected abstract virtual SyntaxNode WithModifiers(SyntaxNode fieldSyntax, SyntaxTokenList modifiers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeQuality.Analyzers.QualityGuidelines.ValidateArgumentsOfPublicMethods : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ValidateArgumentsOfPublicMethods();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Logging.LogValuesFormatter : object {
    private static string NullValue;
    private static Object[] EmptyArray;
    private static Char[] FormatDelimiters;
    private string _format;
    [CompilerGeneratedAttribute]
private string <OriginalFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ValueNames>k__BackingField;
    public string OriginalFormat { get; private set; }
    public List`1<string> ValueNames { get; }
    public LogValuesFormatter(string format);
    private static LogValuesFormatter();
    [CompilerGeneratedAttribute]
public string get_OriginalFormat();
    [CompilerGeneratedAttribute]
private void set_OriginalFormat(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ValueNames();
    private static int FindBraceIndex(string format, char brace, int startIndex, int endIndex);
    private static int FindIndexOfAny(string format, Char[] chars, int startIndex, int endIndex);
    public string Format(Object[] values);
    internal string Format();
    internal string Format(object arg0);
    internal string Format(object arg0, object arg1);
    internal string Format(object arg0, object arg1, object arg2);
    public KeyValuePair`2<string, object> GetValue(Object[] values, int index);
    public IEnumerable`1<KeyValuePair`2<string, object>> GetValues(Object[] values);
    private static object FormatArgument(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Data.ReviewSqlQueriesForSecurityVulnerabilities : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ReviewSqlQueriesForSecurityVulnerabilities();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodCall(OperationAnalysisContext operationContext, IMethodSymbol constructorSymbol, ISymbol containingSymbol, ImmutableArray`1<IArgumentOperation> arguments, SyntaxNode invocationSyntax, bool isInDbCommandConstructor, bool isInDataAdapterConstructor, INamedTypeSymbol iDbCommandType, INamedTypeSymbol iDataAdapterType);
    private static bool IsParameterSymbolVulnerable(IParameterSymbol parameter);
    private static bool ReportDiagnosticIfNecessary(OperationAnalysisContext operationContext, IOperation argumentValue, SyntaxNode syntax, ISymbol invokedSymbol, ISymbol containingMethod);
    private static void CheckForDbCommandAndDataAdapterImplementation(INamedTypeSymbol containingType, INamedTypeSymbol iDbCommandType, INamedTypeSymbol iDataAdapterType, Boolean& implementsDbCommand, Boolean& implementsDataCommand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.ImmutableCollections.DoNotCallToImmutableCollectionOnAnImmutableCollectionValueAnalyzer : DiagnosticAnalyzer {
    private static string ImmutableArrayMetadataName;
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    private static ImmutableDictionary`2<string, string> ImmutableCollectionMetadataNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static ImmutableArray`1<string> <ToImmutableMethodNames>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<string> ToImmutableMethodNames { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCallToImmutableCollectionOnAnImmutableCollectionValueAnalyzer();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<string> get_ToImmutableMethodNames();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.ImmutableCollections.DoNotCallToImmutableCollectionOnAnImmutableCollectionValueFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.ImmutableCollections.DoNotCallToImmutableCollectionOnAnImmutableCollectionValueFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> RemoveRedundantCallAsync(Document document, SyntaxNode root, SyntaxNode invocationNode, IInvocationOperation invocationOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.InteropServices.AvoidStringBuilderPInvokeParametersAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidStringBuilderPInvokeParametersAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol stringBuilderType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.InteropServices.DisableRuntimeMarshallingAnalyzer : DiagnosticAnalyzer {
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledId;
    private static DiagnosticDescriptor FeatureUnsupportedWhenRuntimeMarshallingDisabledSetLastErrorTrue;
    private static DiagnosticDescriptor FeatureUnsupportedWhenRuntimeMarshallingDisabledHResultSwapping;
    private static DiagnosticDescriptor FeatureUnsupportedWhenRuntimeMarshallingDisabledUsingLCIDConversionAttribute;
    private static DiagnosticDescriptor FeatureUnsupportedWhenRuntimeMarshallingDisabledVarargPInvokes;
    private static DiagnosticDescriptor FeatureUnsupportedWhenRuntimeMarshallingDisabledByRefParameters;
    private static DiagnosticDescriptor FeatureUnsupportedWhenRuntimeMarshallingDisabledManagedParameterOrReturnTypes;
    private static DiagnosticDescriptor FeatureUnsupportedWhenRuntimeMarshallingDisabledAutoLayoutTypes;
    private static DiagnosticDescriptor FeatureUnsupportedWhenRuntimeMarshallingDisabledDelegateUsage;
    internal static string MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledId;
    private static DiagnosticDescriptor MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabled;
    public static string CanConvertToDisabledMarshallingEquivalentKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisableRuntimeMarshallingAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeMethodSignature(AutoLayoutTypeCache autoLayoutCache, Action`1<Diagnostic> reportDiagnostic, IMethodSymbol method, ImmutableArray`1<Location> locationsOverride, DiagnosticDescriptor descriptorOverride);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeMethodSignature>g__AnalyzeSignatureType|16_0(ImmutableArray`1<Location> locations, ITypeSymbol type, <>c__DisplayClass16_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.InteropServices.DoNotUseOutAttributeStringPInvokeParametersAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseOutAttributeStringPInvokeParametersAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol outAttributeType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.InteropServices.DynamicInterfaceCastableImplementationAnalyzer : DiagnosticAnalyzer {
    internal static string DynamicInterfaceCastableImplementationUnsupportedRuleId;
    private static DiagnosticDescriptor DynamicInterfaceCastableImplementationUnsupported;
    internal static string InterfaceMembersMissingImplementationRuleId;
    private static DiagnosticDescriptor InterfaceMembersMissingImplementation;
    internal static string MembersDeclaredOnImplementationTypeMustBeStaticRuleId;
    private static DiagnosticDescriptor MembersDeclaredOnImplementationTypeMustBeStatic;
    internal static string NonStaticMemberIsMethodKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DynamicInterfaceCastableImplementationAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeType(SymbolAnalysisContext context, INamedTypeSymbol dynamicInterfaceCastableImplementationAttribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.InteropServices.DynamicInterfaceCastableImplementationFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.InteropServices.DynamicInterfaceCastableImplementationFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected static SyntaxAnnotation CreatePossibleInvalidCodeWarning();
    protected abstract virtual bool CodeFixSupportsDeclaration(SyntaxNode declaration);
    protected abstract virtual Task`1<Document> ImplementInterfacesOnDynamicCastableImplementationAsync(SyntaxNode root, SyntaxNode declaration, Document document, SyntaxGenerator generator, CancellationToken cancellationToken);
    protected abstract virtual Task`1<Document> MakeMemberDeclaredOnImplementationTypeStaticAsync(SyntaxNode declaration, Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.InteropServices.MarkBooleanPInvokeArgumentsWithMarshalAsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.InteropServices.MarkBooleanPInvokeArgumentsWithMarshalAsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.InteropServices.PInvokeDiagnosticAnalyzer : DiagnosticAnalyzer {
    public static string RuleCA1401Id;
    public static string RuleCA2101Id;
    internal static DiagnosticDescriptor RuleCA1401;
    private static LocalizableString s_localizableMessageAndTitleCA2101;
    internal static DiagnosticDescriptor RuleCA2101;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PInvokeDiagnosticAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.InteropServices.PlatformCompatibilityAnalyzer : DiagnosticAnalyzer {
    internal static string SupportRuleId;
    internal static string ObsoletedRuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_osPlatformAttributes;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    private static string ObsoletedOSPlatformAttribute;
    private static string SupportedOSPlatformAttribute;
    private static string UnsupportedOSPlatformAttribute;
    private static string UnsupportedOSPlatformGuardAttribute;
    private static string SupportedOSPlatformGuardAttribute;
    private static string IsOSPlatform;
    private static string IsPrefix;
    private static string OptionalSuffix;
    private static string Net;
    private static string macOS;
    private static string OSX;
    private static string MacSlashOSX;
    private static Version EmptyVersion;
    internal static DiagnosticDescriptor OnlySupportedCsReachable;
    internal static DiagnosticDescriptor OnlySupportedCsUnreachable;
    internal static DiagnosticDescriptor OnlySupportedCsAllPlatforms;
    internal static DiagnosticDescriptor SupportedCsAllPlatforms;
    internal static DiagnosticDescriptor SupportedCsReachable;
    internal static DiagnosticDescriptor UnsupportedCsAllPlatforms;
    internal static DiagnosticDescriptor UnsupportedCsReachable;
    internal static DiagnosticDescriptor ObsoletedCsAllPlatforms;
    internal static DiagnosticDescriptor ObsoletedCsReachable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PlatformCompatibilityAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool TryExtractPlatformName(string methodName, String& platformName);
    private static bool PlatformAnalysisAllowed(AnalyzerOptions options, Compilation compilation);
    private static bool LowerTargetsEnabled(AnalyzerOptions options, Compilation compilation);
    [NullableContextAttribute("2")]
private void AnalyzeOperationBlock(OperationBlockStartAnalysisContext context, ImmutableArray`1<IMethodSymbol> guardMethods, IMethodSymbol runtimeIsOSPlatformMethod, IMethodSymbol osPlatformCreateMethod, bool crossPlatform, INamedTypeSymbol osPlatformType, INamedTypeSymbol stringType, ConcurrentDictionary`2<ISymbol, PlatformAttributes> platformSpecificMembers, ImmutableArray`1<string> msBuildPlatforms, ITypeSymbol notSupportedExceptionType, SmallDictionary`2<string, ValueTuple`2<string, bool>> relatedPlatforms);
    private static bool HasGuardedLambdaOrLocalFunctionResult(IOperation platformSpecificOperation, SmallDictionary`2<string, Versions> attributes, SmallDictionary`2& csAttributes, DataFlowAnalysisResult`2<GlobalFlowStateBlockAnalysisResult, GlobalFlowStateAnalysisValueSet> analysisResult, SmallDictionary`2<string, Versions> originalCsAttributes);
    [NullableContextAttribute("2")]
private static bool ComputeNeedsValueContentAnalysis(IOperation operationBlock, ImmutableArray`1<IMethodSymbol> guardMethods, IMethodSymbol runtimeIsOSPlatformMethod, INamedTypeSymbol osPlatformType);
    private static bool IsKnownValueGuarded(SmallDictionary`2<string, Versions> attributes, SmallDictionary`2& csAttributes, GlobalFlowStateAnalysisValueSet value, SmallDictionary`2<string, Versions> originalCsAttributes);
    private static bool IsEmptyVersion(Version version);
    private static void ReportDiagnostics(KeyValuePair`2<IOperation, ISymbol> operationToSymbol, SmallDictionary`2<string, Versions> attributes, SmallDictionary`2<string, Versions> csAttributes, OperationBlockAnalysisContext context, ConcurrentDictionary`2<ISymbol, PlatformAttributes> platformSpecificMembers);
    private static ISymbol GetOperationSymbol(IOperation operation);
    [IteratorStateMachineAttribute("Microsoft.NetCore.Analyzers.InteropServices.PlatformCompatibilityAnalyzer/<GetPropertyAccessors>d__42")]
private static IEnumerable`1<ISymbol> GetPropertyAccessors(IPropertySymbol property, IOperation operation);
    private static ISymbol GetEventAccessor(IEventSymbol iEvent, IOperation operation);
    private static void AnalyzeOperation(IOperation operation, OperationAnalysisContext context, PooledConcurrentDictionary`2<KeyValuePair`2<IOperation, ISymbol>, ValueTuple`2<SmallDictionary`2<string, Versions>, SmallDictionary`2<string, Versions>>> platformSpecificOperations, ConcurrentDictionary`2<ISymbol, PlatformAttributes> platformSpecificMembers, ImmutableArray`1<string> msBuildPlatforms, ITypeSymbol notSupportedExceptionType, bool crossPlatform, SmallDictionary`2<string, ValueTuple`2<string, bool>> relatedPlatforms);
    private static bool UsedInCreatingNotSupportedException(IArgumentOperation operation, ITypeSymbol notSupportedExceptionType);
    private static bool TryCopyAttributesNotSuppressedByMsBuild(SmallDictionary`2<string, Versions> operationAttributes, ImmutableArray`1<string> msBuildPlatforms, SmallDictionary`2& copiedAttributes);
    private static PlatformAttributes CopyAttributes(PlatformAttributes copyAttributes);
    private static SmallDictionary`2<string, Versions> CopyAttributes(SmallDictionary`2<string, Versions> copyAttributes);
    private static bool IsNotSuppressedByCallSite(SmallDictionary`2<string, Versions> operationAttributes, SmallDictionary`2<string, Versions> callSiteAttributes, ImmutableArray`1<string> msBuildPlatforms, SmallDictionary`2& notSuppressedAttributes, bool crossPlatform);
    private static Versions CopyAllAttributes(Versions copyTo, Versions copyFrom);
    private static bool IsWithinConditionalOperation(IFieldReferenceOperation pOperation);
    private static bool TryGetOrCreatePlatformAttributes(ISymbol symbol, bool checkParents, bool crossPlatform, ConcurrentDictionary`2<ISymbol, PlatformAttributes> platformSpecificMembers, SmallDictionary`2<string, ValueTuple`2<string, bool>> relatedPlatforms, PlatformAttributes& attributes);
    private static bool TryAddValidAttribute(SmallDictionary`2& attributes, AttributeData attribute, SmallDictionary`2<string, ValueTuple`2<string, bool>> relatedPlatforms);
    private static bool TryParsePlatformNameAndVersion(AttributeData attribute, String& platformName, Version& version);
    private static bool HasNonEmptyStringArgument(AttributeData attribute, String& stringArgument);
    private static bool TryParsePlatformNameAndVersion(string osString, String& osPlatformName, Version& version);
    private static string GetNameAsMacOsWhenOSX(string platformName);
    private static bool AddAttribute(AttributeData attribute, Version version, Versions attributes);
    private static string PopulateMessage(AttributeData attribute);
    private static string PopulateUrl(AttributeData attribute);
    private static bool AllowList(Versions attributes);
    private static bool DenyList(Versions attributes);
    [NullableContextAttribute("2")]
private static bool TryDecodeOSVersion(ImmutableArray`1<IArgumentOperation> arguments, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Version& osVersion, int skip);
    [CompilerGeneratedAttribute]
private void <Initialize>b__30_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static List`1<IMethodSymbol> <Initialize>g__GetOperatingSystemGuardMethods|30_1(IMethodSymbol runtimeIsOSPlatformMethod, INamedTypeSymbol operatingSystemType, SmallDictionary`2& relatedPlatforms);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<IMethodSymbol> <Initialize>g__FilterPlatformCheckMethods|30_2(INamedTypeSymbol symbol, SmallDictionary`2<string, ValueTuple`2<string, bool>> relatedPlatforms);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__CheckDependentPlatforms|30_3(IMethodSymbol method, SmallDictionary`2<string, ValueTuple`2<string, bool>> relatedPlatforms);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<string> <Initialize>g__GetSupportedPlatforms|30_4(AnalyzerOptions options, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__NameAndParametersValid|30_5(IMethodSymbol method);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__HasCrossPlatformProperty|30_6(AnalyzerOptions options, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static bool <IsKnownValueGuarded>g__IsKnownValueGuarded|37_0(SmallDictionary`2<string, Versions> attributes, SmallDictionary`2& csAttributes, GlobalFlowStateAnalysisValueSet value, PooledDictionary`2<string, Version> capturedVersions, SmallDictionary`2<string, Versions> originalCsAttributes);
    [CompilerGeneratedAttribute]
internal static bool <IsKnownValueGuarded>g__IsOnlySupportNeedsGuard|37_1(string platformName, SmallDictionary`2<string, Versions> attributes, SmallDictionary`2<string, Versions> csAttributes);
    [CompilerGeneratedAttribute]
internal static bool <IsKnownValueGuarded>g__IsNegationOfCallsiteAttributes|37_2(SmallDictionary`2<string, Versions> csAttributes, ImmutableHashSet`1<IAbstractAnalysisValue> parentValues);
    [CompilerGeneratedAttribute]
internal static bool <IsKnownValueGuarded>g__IsNegationOfParentValues|37_3(GlobalFlowStateAnalysisValueSet value, Enumerator<IAbstractAnalysisValue> parentEnumerator);
    [CompilerGeneratedAttribute]
internal static SmallDictionary`2<string, Versions> <IsKnownValueGuarded>g__SetCallSiteSupportedAttribute|37_4(SmallDictionary`2<string, Versions> csAttributes, PlatformMethodValue info, Version unsupportedVersion);
    [CompilerGeneratedAttribute]
internal static SmallDictionary`2<string, Versions> <IsKnownValueGuarded>g__SetCallSiteUnsupportedAttribute|37_5(SmallDictionary`2<string, Versions> csAttributes, PlatformMethodValue info);
    [CompilerGeneratedAttribute]
internal static void <IsKnownValueGuarded>g__RemoveUnsupportsOnDifferentPlatforms|37_6(SmallDictionary`2<string, Versions> attributes, string platformName);
    [CompilerGeneratedAttribute]
internal static void <IsKnownValueGuarded>g__RemoveUnsupportedWithLessVersion|37_7(Version supportedVersion, Versions attribute);
    [CompilerGeneratedAttribute]
internal static void <IsKnownValueGuarded>g__RemoveOtherSupportsOnDifferentPlatforms|37_8(SmallDictionary`2<string, Versions> attributes, string platformName);
    [CompilerGeneratedAttribute]
internal static void <ReportDiagnostics>g__ReportSupportedDiagnostic|39_0(IOperation operation, OperationBlockAnalysisContext context, string operationName, SmallDictionary`2<string, Versions> attributes, SmallDictionary`2<string, Versions> callsiteAttributes);
    [CompilerGeneratedAttribute]
internal static DiagnosticDescriptor <ReportDiagnostics>g__SwitchSupportedRule|39_15(Callsite callsite);
    [CompilerGeneratedAttribute]
internal static bool <ReportDiagnostics>g__IsDenyList|39_16(SmallDictionary`2<string, Versions> callsiteAttributes);
    [CompilerGeneratedAttribute]
internal static bool <ReportDiagnostics>g__GetSupportedPlatforms|39_17(SmallDictionary`2<string, Versions> attributes, SmallDictionary`2<string, Versions> csAttributes, ImmutableArray`1& platformNames, ImmutableArray`1& obsoletedPlatforms);
    [CompilerGeneratedAttribute]
internal static DiagnosticDescriptor <ReportDiagnostics>g__SwitchObsoletedRule|39_1(Callsite callsite);
    [CompilerGeneratedAttribute]
internal static DiagnosticDescriptor <ReportDiagnostics>g__SwitchRule|39_2(Callsite callsite, bool unsupported);
    [CompilerGeneratedAttribute]
internal static string <ReportDiagnostics>g__AppendMessage|39_3(Versions attribute, string message);
    [CompilerGeneratedAttribute]
internal static string <ReportDiagnostics>g__AppendMessageAndUrl|39_4(Versions attribute, string message);
    [CompilerGeneratedAttribute]
internal static void <ReportDiagnostics>g__ReportUnsupportedDiagnostic|39_5(IOperation operation, OperationBlockAnalysisContext context, string operationName, SmallDictionary`2<string, Versions> attributes, SmallDictionary`2<string, Versions> callsiteAttributes);
    [CompilerGeneratedAttribute]
internal static bool <ReportDiagnostics>g__GetPlatformNames|39_19(SmallDictionary`2<string, Versions> attributes, SmallDictionary`2<string, Versions> csAttributes, ImmutableArray`1& platformNames, ImmutableArray`1& obsoletedPlatforms);
    [CompilerGeneratedAttribute]
internal static void <ReportDiagnostics>g__AddObsoleted|39_6(SmallDictionary`2<string, Versions> csAttributes, ArrayBuilder`1<string> obsoletedBuilder, string pName, Versions pAttribute);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<string> <ReportDiagnostics>g__GetCallsitePlatforms|39_7(SmallDictionary`2<string, Versions> attributes, SmallDictionary`2<string, Versions> callsiteAttributes, Callsite& callsite, bool supported);
    [CompilerGeneratedAttribute]
internal static string <ReportDiagnostics>g__GetFormattedString|39_8(string resource, string platformName, object arg1, object arg2);
    [CompilerGeneratedAttribute]
internal static string <ReportDiagnostics>g__AddOsxIfMacOS|39_9(string platformName);
    [CompilerGeneratedAttribute]
internal static string <ReportDiagnostics>g__EncloseWithQuotes|39_10(string pName);
    [CompilerGeneratedAttribute]
internal static string <ReportDiagnostics>g__JoinNames|39_11(ImmutableArray`1<string> platformNames);
    [CompilerGeneratedAttribute]
internal static SymbolDisplayFormat <ReportDiagnostics>g__GetLanguageSpecificFormat|39_12(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <ReportDiagnostics>g__HasSameVersionedPlatformSupport|39_13(SmallDictionary`2<string, Versions> attributes, string pName, bool checkSupport);
    [CompilerGeneratedAttribute]
internal static bool <ReportDiagnostics>g__HasVersionedCallsite|39_14(SmallDictionary`2<string, Versions> csAttributes, string pName);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeOperation>g__CheckTypeArguments|44_0(ImmutableArray`1<ITypeSymbol> typeArguments, <>c__DisplayClass44_0& );
    [CompilerGeneratedAttribute]
internal static void <AnalyzeOperation>g__CheckTypeArgumentsCore|44_1(ImmutableArray`1<ITypeSymbol> typeArguments, PooledHashSet`1<ITypeSymbol> workingSet, <>c__DisplayClass44_0& );
    [CompilerGeneratedAttribute]
internal static void <AnalyzeOperation>g__CheckOperationAttributes|44_2(ISymbol symbol, bool checkParents, <>c__DisplayClass44_0& );
    [CompilerGeneratedAttribute]
internal static void <IsNotSuppressedByCallSite>g__AddOrUpdatedDiagnostic|49_0(Versions operationAttributes, SmallDictionary`2<string, Versions> notSuppressedAttributes, string name);
    [CompilerGeneratedAttribute]
internal static bool <IsNotSuppressedByCallSite>g__UnsupportedSecondSuppressed|49_1(Versions attribute, Versions callSiteAttribute);
    [CompilerGeneratedAttribute]
internal static bool <IsNotSuppressedByCallSite>g__SuppressedByCallSiteUnsupported|49_2(Versions callSiteAttribute, Version unsupporteAttribute);
    [CompilerGeneratedAttribute]
internal static bool <IsNotSuppressedByCallSite>g__SuppressedByCallSiteSupported|49_3(Versions attribute, Version callSiteSupportedFirst);
    [CompilerGeneratedAttribute]
internal static bool <IsNotSuppressedByCallSite>g__UnsupportedFirstSuppressed|49_4(Versions attribute, Versions callSiteAttribute);
    [CompilerGeneratedAttribute]
internal static bool <IsNotSuppressedByCallSite>g__OptionalOsSupportSuppressed|49_5(Versions callSiteAttribute, Versions attribute);
    [CompilerGeneratedAttribute]
internal static bool <IsNotSuppressedByCallSite>g__MandatoryOsVersionsSuppressed|49_6(Versions callSitePlatforms, Version checkingVersion);
    [CompilerGeneratedAttribute]
internal static void <TryGetOrCreatePlatformAttributes>g__MergePlatformAttributes|52_0(ImmutableArray`1<AttributeData> immediateAttributes, PlatformAttributes& parentAttributes, bool crossPlatform, SmallDictionary`2<string, ValueTuple`2<string, bool>> relatedPlatforms);
    [CompilerGeneratedAttribute]
internal static void <TryGetOrCreatePlatformAttributes>g__CheckAttributesConsistency|52_1(SmallDictionary`2<string, Versions> childAttributes);
    [CompilerGeneratedAttribute]
internal static Versions <TryGetOrCreatePlatformAttributes>g__NormalizeAttribute|52_2(Versions attributes);
    [CompilerGeneratedAttribute]
internal static void <AddAttribute>g__AddOrUpdateObsoletedAttribute|58_0(AttributeData attribute, Versions attributes, Version version);
    [CompilerGeneratedAttribute]
internal static void <AddAttribute>g__AddOrUpdateUnsupportedAttribute|58_1(AttributeData attribute, Versions attributes, Version version);
    [CompilerGeneratedAttribute]
internal static void <AddAttribute>g__AddOrUpdateSupportedAttribute|58_2(Versions attributes, Version version);
    [CompilerGeneratedAttribute]
internal static bool <TryDecodeOSVersion>g__TryDecodeOSVersionPart|67_0(IArgumentOperation argument, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResult, Int32& osVersionPart);
    [CompilerGeneratedAttribute]
internal static Version <TryDecodeOSVersion>g__CreateVersion|67_1(ArrayBuilder`1<int> versionBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.InteropServices.ProvidePublicParameterlessSafeHandleConstructorAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ProvidePublicParameterlessSafeHandleConstructorAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol safeHandleType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.InteropServices.ProvidePublicParameterlessSafeHandleConstructorFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.InteropServices.ProvidePublicParameterlessSafeHandleConstructorFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.InteropServices.ProvidePublicParameterlessSafeHandleConstructorFixer/<MakeParameterlessConstructorPublicAsync>d__5")]
private static Task`1<Document> MakeParameterlessConstructorPublicAsync(SyntaxNode declaration, Document document, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.InteropServices.SpecifyMarshalingForPInvokeStringArgumentsFixer : CodeFixProvider {
    protected static string CharSetText;
    protected static string LPWStrText;
    protected static string UnicodeText;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.InteropServices.SpecifyMarshalingForPInvokeStringArgumentsFixer/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual bool IsAttribute(SyntaxNode node);
    protected abstract virtual bool IsDeclareStatement(SyntaxNode node);
    protected abstract virtual Task`1<Document> FixDeclareStatementAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode FindNamedArgument(IReadOnlyList`1<SyntaxNode> arguments, string argumentName);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.InteropServices.SpecifyMarshalingForPInvokeStringArgumentsFixer/<FixAttributeArgumentsAsync>d__11")]
private Task`1<Document> FixAttributeArgumentsAsync(Document document, SyntaxNode attributeDeclaration, INamedTypeSymbol charSetType, INamedTypeSymbol dllImportType, INamedTypeSymbol marshalAsType, INamedTypeSymbol unmanagedType, CancellationToken cancellationToken);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.InteropServices.UseManagedEquivalentsOfWin32ApiAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.InteropServices.UseManagedEquivalentsOfWin32ApiFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.InteropServices.UseValidPlatformString : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKind> s_symbols;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> methodNames;
    private static string IsPrefix;
    private static string VersionSuffix;
    private static string macOS;
    private static string Browser;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor UnknownPlatform;
    internal static DiagnosticDescriptor InvalidVersion;
    internal static DiagnosticDescriptor NoVersion;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseValidPlatformString();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeOperation(IOperation operation, OperationAnalysisContext context, PooledDictionary`2<string, int> knownPlatforms);
    private static void AnalyzeSymbol(Action`2<TContext, Diagnostic> reportDiagnostic, TContext context, ISymbol symbol, INamedTypeSymbol supportedAttribute, INamedTypeSymbol unsupportedAttribute, PooledDictionary`2<string, int> knownPlatforms, CancellationToken token);
    private static void AnalyzeAttribute(Action`2<TContext, Diagnostic> reportDiagnostic, TContext context, AttributeData attributeData, PooledDictionary`2<string, int> knownPlatforms, CancellationToken token);
    private static bool IsNotKnownPlatform(PooledDictionary`2<string, int> knownPlatforms, string platformName);
    private static bool TryParsePlatformNameAndVersion(string osString, String& osPlatformName, String& versionPart, Int32& versionCount);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__AddPlatformsAndVersionCountFromGuardMethods|15_1(INamedTypeSymbol operatingSystemType, PooledDictionary`2<string, int> knownPlatforms);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__AddPlatformsFromMsBuildOptions|15_2(PooledDictionary`2<string, int> knownPlatforms, ImmutableArray`1<string> msBuildPlatforms);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<string, int> <Initialize>g__ExtractPlatformAndVersionCount|15_3(IMethodSymbol method);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__NameAndParametersValid|15_4(IMethodSymbol method);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeAttribute>g__AnalyzeStringParameter|18_0(Action`2<TContext, Diagnostic> reportDiagnostic, TContext context, SyntaxNode syntax, PooledDictionary`2<string, int> knownPlatforms, string value);
}
internal static class Microsoft.NetCore.Analyzers.MicrosoftNetCoreAnalyzersResources : object {
    [NullableAttribute("1")]
private static Type s_resourcesType;
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string ReviewSQLQueriesForSecurityVulnerabilitiesDescription { get; }
    internal static string ReviewSQLQueriesForSecurityVulnerabilitiesMessageNoNonLiterals { get; }
    internal static string ReviewSQLQueriesForSecurityVulnerabilitiesTitle { get; }
    internal static string DoNotCallToImmutableCollectionOnAnImmutableCollectionValueTitle { get; }
    internal static string DoNotCallToImmutableCollectionOnAnImmutableCollectionValueMessage { get; }
    internal static string RemoveRedundantCall { get; }
    internal static string PInvokesShouldNotBeVisibleTitle { get; }
    internal static string PInvokesShouldNotBeVisibleDescription { get; }
    internal static string PInvokesShouldNotBeVisibleMessage { get; }
    internal static string SpecifyMarshalingForPInvokeStringArgumentsTitle { get; }
    internal static string SpecifyMarshalingForPInvokeStringArgumentsDescription { get; }
    internal static string UseManagedEquivalentsOfWin32ApiTitle { get; }
    internal static string UseManagedEquivalentsOfWin32ApiDescription { get; }
    internal static string UseManagedEquivalentsOfWin32ApiMessage { get; }
    internal static string MarkBooleanPInvokeArgumentsWithMarshalAsTitle { get; }
    internal static string MarkBooleanPInvokeArgumentsWithMarshalAsDescription { get; }
    internal static string MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault { get; }
    internal static string MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn { get; }
    internal static string MarkAssembliesWithNeutralResourcesLanguageTitle { get; }
    internal static string MarkAssembliesWithNeutralResourcesLanguageDescription { get; }
    internal static string MarkAssembliesWithNeutralResourcesLanguageMessage { get; }
    internal static string UseOrdinalStringComparisonTitle { get; }
    internal static string UseOrdinalStringComparisonDescription { get; }
    internal static string DoNotUseCountWhenAnyCanBeUsedDescription { get; }
    internal static string DoNotUseCountWhenAnyCanBeUsedMessage { get; }
    internal static string DoNotUseCountWhenAnyCanBeUsedTitle { get; }
    internal static string DoNotUseTimersThatPreventPowerStateChangesTitle { get; }
    internal static string DoNotUseTimersThatPreventPowerStateChangesDescription { get; }
    internal static string DoNotUseTimersThatPreventPowerStateChangesMessage { get; }
    internal static string AvoidUnsealedAttributesTitle { get; }
    internal static string AvoidUnsealedAttributesDescription { get; }
    internal static string AvoidUnsealedAttributesMessage { get; }
    internal static string AvoidConstArraysTitle { get; }
    internal static string AvoidConstArraysCodeFixTitle { get; }
    internal static string AvoidConstArraysDescription { get; }
    internal static string AvoidConstArraysMessage { get; }
    internal static string TestForEmptyStringsUsingStringLengthTitle { get; }
    internal static string TestForEmptyStringsUsingStringLengthDescription { get; }
    internal static string TestForEmptyStringsUsingStringLengthMessage { get; }
    internal static string DoNotLockOnObjectsWithWeakIdentityTitle { get; }
    internal static string DoNotLockOnObjectsWithWeakIdentityDescription { get; }
    internal static string DoNotLockOnObjectsWithWeakIdentityMessage { get; }
    internal static string DoNotRaiseReservedExceptionTypesTitle { get; }
    internal static string DoNotRaiseReservedExceptionTypesDescription { get; }
    internal static string DoNotRaiseReservedExceptionTypesMessageTooGeneric { get; }
    internal static string DoNotRaiseReservedExceptionTypesMessageReserved { get; }
    internal static string InitializeValueTypeStaticFieldsInlineTitle { get; }
    internal static string InitializeReferenceTypeStaticFieldsInlineTitle { get; }
    internal static string InitializeValueTypeStaticFieldsInlineDescription { get; }
    internal static string InitializeReferenceTypeStaticFieldsInlineDescription { get; }
    internal static string InitializeStaticFieldsInlineMessage { get; }
    internal static string DisposableTypesShouldDeclareFinalizerTitle { get; }
    internal static string DisposableTypesShouldDeclareFinalizerDescription { get; }
    internal static string DisposableTypesShouldDeclareFinalizerMessage { get; }
    internal static string ProvideCorrectArgumentsToFormattingMethodsTitle { get; }
    internal static string ProvideCorrectArgumentsToFormattingMethodsDescription { get; }
    internal static string ProvideCorrectArgumentsToFormattingMethodsMessage { get; }
    internal static string ProvideCorrectArgumentsToFormattingMethodsInvalidFormatMessage { get; }
    internal static string TestForNaNCorrectlyTitle { get; }
    internal static string TestForNaNCorrectlyDescription { get; }
    internal static string TestForNaNCorrectlyMessage { get; }
    internal static string AttributeStringLiteralsShouldParseCorrectlyTitle { get; }
    internal static string AttributeStringLiteralsShouldParseCorrectlyDescription { get; }
    internal static string AttributeStringLiteralsShouldParseCorrectlyMessageDefault { get; }
    internal static string AttributeStringLiteralsShouldParseCorrectlyMessageEmpty { get; }
    internal static string AvoidZeroLengthArrayAllocationsTitle { get; }
    internal static string AvoidZeroLengthArrayAllocationsMessage { get; }
    internal static string DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle { get; }
    internal static string DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription { get; }
    internal static string DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage { get; }
    internal static string SpecifyCultureInfoTitle { get; }
    internal static string SpecifyCultureInfoDescription { get; }
    internal static string SpecifyCultureInfoMessage { get; }
    internal static string SpecifyIFormatProviderTitle { get; }
    internal static string SpecifyIFormatProviderDescription { get; }
    internal static string SpecifyIFormatProviderMessageIFormatProviderAlternateString { get; }
    internal static string SpecifyIFormatProviderMessageIFormatProviderAlternate { get; }
    internal static string SpecifyIFormatProviderMessageUICultureString { get; }
    internal static string SpecifyIFormatProviderMessageUICulture { get; }
    internal static string SpecifyStringComparisonCA1307Title { get; }
    internal static string SpecifyStringComparisonCA1307Description { get; }
    internal static string SpecifyStringComparisonCA1307Message { get; }
    internal static string SpecifyStringComparisonCA1310Title { get; }
    internal static string SpecifyStringComparisonCA1310Description { get; }
    internal static string SpecifyStringComparisonCA1310Message { get; }
    internal static string NormalizeStringsToUppercaseTitle { get; }
    internal static string NormalizeStringsToUppercaseDescription { get; }
    internal static string NormalizeStringsToUppercaseMessageToUpper { get; }
    internal static string CallGCSuppressFinalizeCorrectlyTitle { get; }
    internal static string CallGCSuppressFinalizeCorrectlyDescription { get; }
    internal static string CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer { get; }
    internal static string CallGCSuppressFinalizeCorrectlyMessageNotCalled { get; }
    internal static string CallGCSuppressFinalizeCorrectlyMessageNotPassedThis { get; }
    internal static string CallGCSuppressFinalizeCorrectlyMessageOutsideDispose { get; }
    internal static string InstantiateArgumentExceptionsCorrectlyTitle { get; }
    internal static string InstantiateArgumentExceptionsCorrectlyDescription { get; }
    internal static string InstantiateArgumentExceptionsCorrectlyMessageNoArguments { get; }
    internal static string InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage { get; }
    internal static string InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName { get; }
    internal static string UseArrayEmpty { get; }
    internal static string UseIndexer { get; }
    internal static string DisposableFieldsShouldBeDisposedDescription { get; }
    internal static string DisposableFieldsShouldBeDisposedMessage { get; }
    internal static string DisposableFieldsShouldBeDisposedTitle { get; }
    internal static string DisposeMethodsShouldCallBaseClassDisposeDescription { get; }
    internal static string DisposeMethodsShouldCallBaseClassDisposeMessage { get; }
    internal static string DisposeMethodsShouldCallBaseClassDisposeTitle { get; }
    internal static string DisposeObjectsBeforeLosingScopeDescription { get; }
    internal static string DisposeObjectsBeforeLosingScopeNotDisposedMessage { get; }
    internal static string DisposeObjectsBeforeLosingScopeMayBeDisposedMessage { get; }
    internal static string DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage { get; }
    internal static string DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage { get; }
    internal static string DisposeObjectsBeforeLosingScopeTitle { get; }
    internal static string DoNotPassLiteralsAsLocalizedParametersDescription { get; }
    internal static string DoNotPassLiteralsAsLocalizedParametersMessage { get; }
    internal static string DoNotPassLiteralsAsLocalizedParametersTitle { get; }
    internal static string AddNonSerializedAttributeCodeActionTitle { get; }
    internal static string AddSerializableAttributeCodeActionTitle { get; }
    internal static string MarkAllNonSerializableFieldsDescription { get; }
    internal static string MarkAllNonSerializableFieldsMessage { get; }
    internal static string MarkAllNonSerializableFieldsTitle { get; }
    internal static string MarkISerializableTypesWithSerializableDescription { get; }
    internal static string MarkISerializableTypesWithSerializableMessage { get; }
    internal static string MarkISerializableTypesWithSerializableTitle { get; }
    internal static string ReviewCodeForSqlInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForSqlInjectionVulnerabilitiesTitle { get; }
    internal static string BinaryFormatterDeserializeMaybeWithoutBinderSetMessage { get; }
    internal static string BinaryFormatterDeserializeMaybeWithoutBinderSetTitle { get; }
    internal static string BinaryFormatterDeserializeWithoutBinderSetMessage { get; }
    internal static string BinaryFormatterDeserializeWithoutBinderSetTitle { get; }
    internal static string BinaryFormatterMethodUsedDescription { get; }
    internal static string BinaryFormatterMethodUsedMessage { get; }
    internal static string BinaryFormatterMethodUsedTitle { get; }
    internal static string LosFormatterMethodUsedMessage { get; }
    internal static string LosFormatterMethodUsedTitle { get; }
    internal static string ReviewCodeForDllInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForDllInjectionVulnerabilitiesTitle { get; }
    internal static string ReviewCodeForInformationDisclosureVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForInformationDisclosureVulnerabilitiesTitle { get; }
    internal static string ReviewCodeForFilePathInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForFilePathInjectionVulnerabilitiesTitle { get; }
    internal static string ReviewCodeForProcessCommandInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForProcessCommandInjectionVulnerabilitiesTitle { get; }
    internal static string ReviewCodeForRegexInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForRegexInjectionVulnerabilitiesTitle { get; }
    internal static string NetDataContractSerializerDeserializeMaybeWithoutBinderSetMessage { get; }
    internal static string NetDataContractSerializerDeserializeMaybeWithoutBinderSetTitle { get; }
    internal static string NetDataContractSerializerDeserializeWithoutBinderSetMessage { get; }
    internal static string NetDataContractSerializerDeserializeWithoutBinderSetTitle { get; }
    internal static string NetDataContractSerializerMethodUsedDescription { get; }
    internal static string NetDataContractSerializerMethodUsedMessage { get; }
    internal static string NetDataContractSerializerMethodUsedTitle { get; }
    internal static string ObjectStateFormatterMethodUsedMessage { get; }
    internal static string ObjectStateFormatterMethodUsedTitle { get; }
    internal static string ReviewCodeForXssVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForXssVulnerabilitiesTitle { get; }
    internal static string ReviewCodeForLdapInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForLdapInjectionVulnerabilitiesTitle { get; }
    internal static string JavaScriptSerializerMaybeWithSimpleTypeResolverMessage { get; }
    internal static string JavaScriptSerializerMaybeWithSimpleTypeResolverTitle { get; }
    internal static string JavaScriptSerializerWithSimpleTypeResolverMessage { get; }
    internal static string JavaScriptSerializerWithSimpleTypeResolverTitle { get; }
    internal static string ReviewCodeForOpenRedirectVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForOpenRedirectVulnerabilitiesTitle { get; }
    internal static string ReviewCodeForXPathInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForXPathInjectionVulnerabilitiesTitle { get; }
    internal static string ReviewCodeForXmlInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForXmlInjectionVulnerabilitiesTitle { get; }
    internal static string ReviewCodeForXamlInjectionVulnerabilitiesMessage { get; }
    internal static string ReviewCodeForXamlInjectionVulnerabilitiesTitle { get; }
    internal static string JsonNetInsecureSettingsMessage { get; }
    internal static string JsonNetInsecureSettingsTitle { get; }
    internal static string JsonNetMaybeInsecureSettingsMessage { get; }
    internal static string JsonNetMaybeInsecureSettingsTitle { get; }
    internal static string DoNotDisableUsingServicePointManagerSecurityProtocolsMessage { get; }
    internal static string DoNotDisableUsingServicePointManagerSecurityProtocolsTitle { get; }
    internal static string JsonNetTypeNameHandlingDescription { get; }
    internal static string JsonNetTypeNameHandlingMessage { get; }
    internal static string JsonNetTypeNameHandlingTitle { get; }
    internal static string ApprovedCipherMode { get; }
    internal static string ApprovedCipherModeDescription { get; }
    internal static string ApprovedCipherModeMessage { get; }
    internal static string DefinitelyInstallRootCert { get; }
    internal static string DefinitelyInstallRootCertMessage { get; }
    internal static string DefinitelyUseSecureCookiesASPNetCore { get; }
    internal static string DefinitelyUseSecureCookiesASPNetCoreMessage { get; }
    internal static string DoNotAddSchemaByURL { get; }
    internal static string DoNotAddSchemaByURLDescription { get; }
    internal static string DoNotAddSchemaByURLMessage { get; }
    internal static string DoNotCallDangerousMethodsInDeserializationTitle { get; }
    internal static string DoNotCallDangerousMethodsInDeserializationDescription { get; }
    internal static string DoNotCallDangerousMethodsInDeserializationMessage { get; }
    internal static string DoNotDisableCertificateValidation { get; }
    internal static string DoNotDisableCertificateValidationDescription { get; }
    internal static string DoNotDisableCertificateValidationMessage { get; }
    internal static string DoNotDisableHTTPHeaderChecking { get; }
    internal static string DoNotDisableHTTPHeaderCheckingDescription { get; }
    internal static string DoNotDisableHTTPHeaderCheckingMessage { get; }
    internal static string DoNotDisableRequestValidation { get; }
    internal static string DoNotDisableRequestValidationDescription { get; }
    internal static string DoNotDisableRequestValidationMessage { get; }
    internal static string DoNotDisableSchUseStrongCrypto { get; }
    internal static string DoNotDisableSchUseStrongCryptoDescription { get; }
    internal static string DoNotDisableSchUseStrongCryptoMessage { get; }
    internal static string DoNotHardCodeEncryptionKey { get; }
    internal static string DoNotHardCodeEncryptionKeyDescription { get; }
    internal static string DoNotHardCodeEncryptionKeyMessage { get; }
    internal static string DoNotInstallRootCertDescription { get; }
    internal static string PotentialReferenceCycleInDeserializedObjectGraphTitle { get; }
    internal static string PotentialReferenceCycleInDeserializedObjectGraphDescription { get; }
    internal static string PotentialReferenceCycleInDeserializedObjectGraphMessage { get; }
    internal static string DoNotSerializeTypesWithPointerFields { get; }
    internal static string DoNotSerializeTypesWithPointerFieldsDescription { get; }
    internal static string DoNotSerializeTypesWithPointerFieldsMessage { get; }
    internal static string DoNotUseAccountSAS { get; }
    internal static string DoNotUseAccountSASDescription { get; }
    internal static string DoNotUseAccountSASMessage { get; }
    internal static string DoNotUseBrokenCryptographicAlgorithms { get; }
    internal static string DoNotUseBrokenCryptographicAlgorithmsDescription { get; }
    internal static string DoNotUseBrokenCryptographicAlgorithmsMessage { get; }
    internal static string DoNotUseDeprecatedSecurityProtocols { get; }
    internal static string DoNotUseDeprecatedSecurityProtocolsDescription { get; }
    internal static string DoNotUseDeprecatedSecurityProtocolsMessage { get; }
    internal static string DoNotUseDSA { get; }
    internal static string DoNotUseDSADescription { get; }
    internal static string DoNotUseDSAMessage { get; }
    internal static string DoNotUseObsoleteKDFAlgorithm { get; }
    internal static string DoNotUseObsoleteKDFAlgorithmDescription { get; }
    internal static string DoNotUseObsoleteKDFAlgorithmMessage { get; }
    internal static string DoNotUseReferenceEqualsWithValueTypesDescription { get; }
    internal static string DoNotUseReferenceEqualsWithValueTypesComparerMessage { get; }
    internal static string DoNotUseReferenceEqualsWithValueTypesMethodMessage { get; }
    internal static string DoNotUseReferenceEqualsWithValueTypesTitle { get; }
    internal static string DoNotUseWeakCryptographicAlgorithms { get; }
    internal static string DoNotUseWeakCryptographicAlgorithmsDescription { get; }
    internal static string DoNotUseWeakCryptographicAlgorithmsMessage { get; }
    internal static string DoNotUseWeakKDFAlgorithm { get; }
    internal static string DoNotUseWeakKDFAlgorithmDescription { get; }
    internal static string DoNotUseWeakKDFAlgorithmMessage { get; }
    internal static string DoNotUseXslTransform { get; }
    internal static string DoNotUseXslTransformMessage { get; }
    internal static string HardCodedSecurityProtocolMessage { get; }
    internal static string HardCodedSecurityProtocolTitle { get; }
    internal static string MaybeInstallRootCert { get; }
    internal static string MaybeInstallRootCertMessage { get; }
    internal static string MaybeUseSecureCookiesASPNetCore { get; }
    internal static string MaybeUseSecureCookiesASPNetCoreMessage { get; }
    internal static string SetViewStateUserKey { get; }
    internal static string SetViewStateUserKeyDescription { get; }
    internal static string SetViewStateUserKeyMessage { get; }
    internal static string UseAsSpanInsteadOfArrayRangeIndexerDescription { get; }
    internal static string UseAsSpanInsteadOfStringRangeIndexerDescription { get; }
    internal static string UseAsSpanInsteadOfRangeIndexerMessage { get; }
    internal static string UseAsSpanInsteadOfRangeIndexerTitle { get; }
    internal static string UseAsSpanReadOnlyInsteadOfArrayRangeIndexerDescription { get; }
    internal static string UseContainerLevelAccessPolicy { get; }
    internal static string UseContainerLevelAccessPolicyDescription { get; }
    internal static string UseContainerLevelAccessPolicyMessage { get; }
    internal static string UseSecureCookiesASPNetCoreDescription { get; }
    internal static string UseSharedAccessProtocolHttpsOnly { get; }
    internal static string UseSharedAccessProtocolHttpsOnlyDescription { get; }
    internal static string UseSharedAccessProtocolHttpsOnlyMessage { get; }
    internal static string UseXmlReaderDescription { get; }
    internal static string UseXmlReaderForDataSetReadXml { get; }
    internal static string UseXmlReaderForDeserialize { get; }
    internal static string UseXmlReaderForSchemaRead { get; }
    internal static string UseXmlReaderForValidatingReader { get; }
    internal static string UseXmlReaderForXPathDocument { get; }
    internal static string UseXmlReaderMessage { get; }
    internal static string UseRSAWithSufficientKeySize { get; }
    internal static string UseRSAWithSufficientKeySizeDescription { get; }
    internal static string UseRSAWithSufficientKeySizeMessage { get; }
    internal static string DefinitelyUseWeakKDFInsufficientIterationCount { get; }
    internal static string DefinitelyUseWeakKDFInsufficientIterationCountMessage { get; }
    internal static string DoNotUseWeakKDFInsufficientIterationCountDescription { get; }
    internal static string MaybeUseWeakKDFInsufficientIterationCount { get; }
    internal static string MaybeUseWeakKDFInsufficientIterationCountMessage { get; }
    internal static string DoNotAddArchiveItemPathToTheTargetFileSystemPath { get; }
    internal static string DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription { get; }
    internal static string DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage { get; }
    internal static string DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesTitle { get; }
    internal static string DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageOfType { get; }
    internal static string DoNotCreateTasksWithoutPassingATaskSchedulerTitle { get; }
    internal static string DoNotCreateTasksWithoutPassingATaskSchedulerDescription { get; }
    internal static string DoNotCreateTasksWithoutPassingATaskSchedulerMessage { get; }
    internal static string DoNotDefineFinalizersForTypesDerivedFromMemoryManagerDescription { get; }
    internal static string DoNotDefineFinalizersForTypesDerivedFromMemoryManagerMessage { get; }
    internal static string DoNotDefineFinalizersForTypesDerivedFromMemoryManagerTitle { get; }
    internal static string UseValueTasksCorrectlyTitle { get; }
    internal static string UseValueTasksCorrectlyDescription { get; }
    internal static string UseValueTasksCorrectlyMessage_General { get; }
    internal static string UseValueTasksCorrectlyMessage_Unconsumed { get; }
    internal static string UseValueTasksCorrectlyMessage_DoubleConsumption { get; }
    internal static string UseValueTasksCorrectlyMessage_AccessingIncompleteResult { get; }
    internal static string DoNotUseConfigureAwaitWithSuppressThrowingTitle { get; }
    internal static string DoNotUseConfigureAwaitWithSuppressThrowingMessage { get; }
    internal static string DoNotUseConfigureAwaitWithSuppressThrowingDescription { get; }
    internal static string DoNotCreateTaskCompletionSourceWithWrongArgumentsTitle { get; }
    internal static string DoNotCreateTaskCompletionSourceWithWrongArgumentsDescription { get; }
    internal static string DoNotCreateTaskCompletionSourceWithWrongArgumentsMessage { get; }
    internal static string DoNotCreateTaskCompletionSourceWithWrongArgumentsFix { get; }
    internal static string JsonNetInsecureSerializerMessage { get; }
    internal static string JsonNetInsecureSerializerTitle { get; }
    internal static string JsonNetMaybeInsecureSerializerMessage { get; }
    internal static string JsonNetMaybeInsecureSerializerTitle { get; }
    internal static string UseDefaultDllImportSearchPathsAttribute { get; }
    internal static string UseDefaultDllImportSearchPathsAttributeDescription { get; }
    internal static string UseDefaultDllImportSearchPathsAttributeMessage { get; }
    internal static string DoNotUseUnsafeDllImportSearchPath { get; }
    internal static string DoNotUseUnsafeDllImportSearchPathDescription { get; }
    internal static string DoNotUseUnsafeDllImportSearchPathMessage { get; }
    internal static string UseAutoValidateAntiforgeryToken { get; }
    internal static string UseAutoValidateAntiforgeryTokenDescription { get; }
    internal static string UseAutoValidateAntiforgeryTokenMessage { get; }
    internal static string MissHttpVerbAttribute { get; }
    internal static string MissHttpVerbAttributeMessage { get; }
    internal static string DoNotUseInsecureRandomness { get; }
    internal static string DoNotUseInsecureRandomnessMessage { get; }
    internal static string DoNotUseInsecureRandomnessDescription { get; }
    internal static string DoNotUseCountAsyncWhenAnyAsyncCanBeUsedDescription { get; }
    internal static string DoNotUseCountAsyncWhenAnyAsyncCanBeUsedMessage { get; }
    internal static string DoNotUseCountAsyncWhenAnyAsyncCanBeUsedTitle { get; }
    internal static string UsePropertyInsteadOfCountMethodWhenAvailableDescription { get; }
    internal static string UsePropertyInsteadOfCountMethodWhenAvailableMessage { get; }
    internal static string UsePropertyInsteadOfCountMethodWhenAvailableTitle { get; }
    internal static string SetHttpOnlyForHttpCookie { get; }
    internal static string SetHttpOnlyForHttpCookieDescription { get; }
    internal static string SetHttpOnlyForHttpCookieMessage { get; }
    internal static string DeprecatedSslProtocolsDescription { get; }
    internal static string DeprecatedSslProtocolsMessage { get; }
    internal static string DeprecatedSslProtocolsTitle { get; }
    internal static string HardcodedSslProtocolsDescription { get; }
    internal static string HardcodedSslProtocolsMessage { get; }
    internal static string HardcodedSslProtocolsTitle { get; }
    internal static string MissHttpVerbAttributeDescription { get; }
    internal static string DefinitelyDisableHttpClientCRLCheck { get; }
    internal static string DefinitelyDisableHttpClientCRLCheckMessage { get; }
    internal static string DoNotDisableHttpClientCRLCheckDescription { get; }
    internal static string MaybeDisableHttpClientCRLCheck { get; }
    internal static string MaybeDisableHttpClientCRLCheckMessage { get; }
    internal static string DoNotHardCodeCertificate { get; }
    internal static string DoNotHardCodeCertificateDescription { get; }
    internal static string DoNotHardCodeCertificateMessage { get; }
    internal static string DefinitelyUseCreateEncryptorWithNonDefaultIV { get; }
    internal static string DefinitelyUseCreateEncryptorWithNonDefaultIVMessage { get; }
    internal static string MaybeUseCreateEncryptorWithNonDefaultIV { get; }
    internal static string MaybeUseCreateEncryptorWithNonDefaultIVMessage { get; }
    internal static string DoNotUseCreateEncryptorWithNonDefaultIVDescription { get; }
    internal static string DataTableReadXmlMessage { get; }
    internal static string DataTableReadXmlTitle { get; }
    internal static string DataSetDataTableInSerializableTypeMessage { get; }
    internal static string DataSetDataTableInWebDeserializableObjectGraphMessage { get; }
    internal static string DataSetDataTableInWebDeserializableObjectGraphTitle { get; }
    internal static string DataSetReadXmlMessage { get; }
    internal static string DataSetReadXmlTitle { get; }
    internal static string DataSetDataTableInRceSerializableTypeMessage { get; }
    internal static string DataSetDataTableInDeserializableObjectGraphMessage { get; }
    internal static string DataSetDataTableInDeserializableObjectGraphTitle { get; }
    internal static string DataSetDataTableInRceDeserializableObjectGraphMessage { get; }
    internal static string DataSetDataTableInRceDeserializableObjectGraphTitle { get; }
    internal static string DataSetDataTableInRceAutogeneratedSerializableTypeMessage { get; }
    internal static string DataSetDataTableInRceAutogeneratedSerializableTypeTitle { get; }
    internal static string DataSetDataTableInRceSerializableTypeTitle { get; }
    internal static string DataSetDataTableInSerializableTypeTitle { get; }
    internal static string DataSetReadXmlAutogeneratedMessage { get; }
    internal static string DataSetReadXmlAutogeneratedTitle { get; }
    internal static string DoNotUseStackallocInLoopsTitle { get; }
    internal static string DoNotUseStackallocInLoopsDescription { get; }
    internal static string DoNotUseStackallocInLoopsMessage { get; }
    internal static string PreferStreamAsyncMemoryOverloadsTitle { get; }
    internal static string PreferStreamAsyncMemoryOverloadsDescription { get; }
    internal static string PreferStreamAsyncMemoryOverloadsMessage { get; }
    internal static string ForwardCancellationTokenToInvocationsDescription { get; }
    internal static string ForwardCancellationTokenToInvocationsMessage { get; }
    internal static string ForwardCancellationTokenToInvocationsTitle { get; }
    internal static string InstantiateArgumentExceptionsCorrectlyChangeToTwoArgumentCodeFixTitle { get; }
    internal static string InstantiateArgumentExceptionsCorrectlyFlipArgumentOrderCodeFixTitle { get; }
    internal static string PreferTypedStringBuilderAppendOverloadsTitle { get; }
    internal static string PreferTypedStringBuilderAppendOverloadsDescription { get; }
    internal static string PreferTypedStringBuilderAppendOverloadsMessage { get; }
    internal static string PreferTypedStringBuilderAppendOverloadsRemoveToString { get; }
    internal static string PreferStringContainsOverIndexOfDescription { get; }
    internal static string PreferStringContainsOverIndexOfMessage { get; }
    internal static string PreferStringContainsOverIndexOfTitle { get; }
    internal static string PreferConstCharOverConstUnitStringInStringBuilderDescription { get; }
    internal static string PreferConstCharOverConstUnitStringInStringBuilderMessage { get; }
    internal static string PreferConstCharOverConstUnitStringInStringBuilderTitle { get; }
    internal static string ProvideCorrectArgumentToEnumHasFlagDescription { get; }
    internal static string ProvideCorrectArgumentToEnumHasFlagMessageDifferentType { get; }
    internal static string ProvideCorrectArgumentToEnumHasFlagTitle { get; }
    internal static string PreferIsEmptyOverCountDescription { get; }
    internal static string PreferIsEmptyOverCountMessage { get; }
    internal static string PreferIsEmptyOverCountTitle { get; }
    internal static string UseEnvironmentProcessIdDescription { get; }
    internal static string UseEnvironmentProcessIdMessage { get; }
    internal static string UseEnvironmentProcessIdTitle { get; }
    internal static string UseEnvironmentProcessIdFix { get; }
    internal static string UseEnvironmentProcessPathDescription { get; }
    internal static string UseEnvironmentProcessPathMessage { get; }
    internal static string UseEnvironmentProcessPathTitle { get; }
    internal static string UseEnvironmentProcessPathFix { get; }
    internal static string UseEnvironmentCurrentManagedThreadIdDescription { get; }
    internal static string UseEnvironmentCurrentManagedThreadIdMessage { get; }
    internal static string UseEnvironmentCurrentManagedThreadIdTitle { get; }
    internal static string UseEnvironmentCurrentManagedThreadIdFix { get; }
    internal static string ThreadStaticOnNonStaticFieldDescription { get; }
    internal static string ThreadStaticOnNonStaticFieldMessage { get; }
    internal static string ThreadStaticOnNonStaticFieldTitle { get; }
    internal static string ThreadStaticInitializedInlineDescription { get; }
    internal static string ThreadStaticInitializedInlineMessage { get; }
    internal static string ThreadStaticInitializedInlineTitle { get; }
    internal static string UseAsSpanInsteadOfRangeIndexerOnAStringCodeFixTitle { get; }
    internal static string UseAsSpanInsteadOfRangeIndexerOnAnArrayCodeFixTitle { get; }
    internal static string PlatformCompatibilityTitle { get; }
    internal static string PlatformCompatibilityDescription { get; }
    internal static string PlatformCompatibilityOnlySupportedCsUnreachableMessage { get; }
    internal static string PlatformCompatibilityUnsupportedCsAllPlatformMessage { get; }
    internal static string DoNotUseOutAttributeStringPInvokeParametersDescription { get; }
    internal static string DoNotUseOutAttributeStringPInvokeParametersMessage { get; }
    internal static string DoNotUseOutAttributeStringPInvokeParametersTitle { get; }
    internal static string AvoidStringBuilderPInvokeParametersDescription { get; }
    internal static string AvoidStringBuilderPInvokeParametersMessage { get; }
    internal static string AvoidStringBuilderPInvokeParametersTitle { get; }
    internal static string PlatformCompatibilityOnlySupportedCsReachableMessage { get; }
    internal static string PlatformCompatibilityOnlySupportedCsAllPlatformMessage { get; }
    internal static string PreferStringContainsOverIndexOfCodeFixTitle { get; }
    internal static string CommaSeparator { get; }
    internal static string PlatformCompatibilityFromVersionToVersion { get; }
    internal static string PlatformCompatibilitySupportedCsAllPlatformMessage { get; }
    internal static string PlatformCompatibilitySupportedCsReachableMessage { get; }
    internal static string PlatformCompatibilityUnsupportedCsReachableMessage { get; }
    internal static string PlatformCompatibilityVersionAndBefore { get; }
    internal static string PlatformCompatibilityVersionAndLater { get; }
    internal static string PlatformCompatibilityAllVersions { get; }
    internal static string PlatformCompatibilityAllPlatforms { get; }
    internal static string DoNotGuardDictionaryRemoveByContainsKeyDescription { get; }
    internal static string DoNotGuardDictionaryRemoveByContainsKeyMessage { get; }
    internal static string DoNotGuardDictionaryRemoveByContainsKeyTitle { get; }
    internal static string DoNotGuardSetAddOrRemoveByContainsDescription { get; }
    internal static string DoNotGuardSetAddOrRemoveByContainsMessage { get; }
    internal static string DoNotGuardSetAddOrRemoveByContainsTitle { get; }
    internal static string RemoveRedundantGuardCallCodeFixTitle { get; }
    internal static string BufferBlockCopyLengthMessage { get; }
    internal static string BufferBlockCopyLengthTitle { get; }
    internal static string BufferBlockCopyDescription { get; }
    internal static string PreferAsSpanOverSubstringDescription { get; }
    internal static string PreferAsSpanOverSubstringMessage { get; }
    internal static string PreferAsSpanOverSubstringTitle { get; }
    internal static string PreferAsSpanOverSubstringCodefixTitle { get; }
    internal static string UseCancellationTokenThrowIfCancellationRequestedDescription { get; }
    internal static string UseCancellationTokenThrowIfCancellationRequestedMessage { get; }
    internal static string UseCancellationTokenThrowIfCancellationRequestedTitle { get; }
    internal static string UseCancellationTokenThrowIfCancellationRequestedCodeFixTitle { get; }
    internal static string ProvideStreamMemoryBasedAsyncOverridesDescription { get; }
    internal static string ProvideStreamMemoryBasedAsyncOverridesMessage { get; }
    internal static string ProvideStreamMemoryBasedAsyncOverridesTitle { get; }
    internal static string UseSpanBasedStringConcatDescription { get; }
    internal static string UseSpanBasedStringConcatMessage { get; }
    internal static string UseSpanBasedStringConcatTitle { get; }
    internal static string UseSpanBasedStringConcatCodeFixTitle { get; }
    internal static string PreferDictionaryContainsKeyCodeFixTitle { get; }
    internal static string PreferDictionaryContainsKeyDescription { get; }
    internal static string PreferDictionaryContainsKeyMessage { get; }
    internal static string PreferDictionaryContainsMethodsTitle { get; }
    internal static string PreferDictionaryContainsValueCodeFixTitle { get; }
    internal static string PreferDictionaryContainsValueDescription { get; }
    internal static string PreferDictionaryContainsValueMessage { get; }
    internal static string UseValidPlatformStringDescription { get; }
    internal static string UseValidPlatformStringTitle { get; }
    internal static string UseValidPlatformStringUnknownPlatform { get; }
    internal static string UseValidPlatformStringInvalidVersion { get; }
    internal static string UseValidPlatformStringNoVersion { get; }
    internal static string DoNotUseWaitAllWithSingleTaskDescription { get; }
    internal static string DoNotUseWaitAllWithSingleTaskTitle { get; }
    internal static string DoNotUseWhenAllWithSingleTaskDescription { get; }
    internal static string DoNotUseWhenAllWithSingleTaskTitle { get; }
    internal static string DoNotUseWaitAllWithSingleTaskFix { get; }
    internal static string DoNotUseWhenAllWithSingleTaskFix { get; }
    internal static string UseStringEqualsOverStringCompareCodeFixTitle { get; }
    internal static string UseStringEqualsOverStringCompareDescription { get; }
    internal static string UseStringEqualsOverStringCompareMessage { get; }
    internal static string UseStringEqualsOverStringCompareTitle { get; }
    internal static string ProvidePublicParameterlessSafeHandleConstructorDescription { get; }
    internal static string ProvidePublicParameterlessSafeHandleConstructorMessage { get; }
    internal static string ProvidePublicParameterlessSafeHandleConstructorTitle { get; }
    internal static string MakeParameterlessConstructorPublic { get; }
    internal static string DynamicInterfaceCastableImplementationUnsupportedDescription { get; }
    internal static string DynamicInterfaceCastableImplementationUnsupportedMessage { get; }
    internal static string DynamicInterfaceCastableImplementationUnsupportedTitle { get; }
    internal static string ImplementInterfacesOnDynamicCastableImplementation { get; }
    internal static string InterfaceMembersMissingImplementationDescription { get; }
    internal static string InterfaceMembersMissingImplementationMessage { get; }
    internal static string InterfaceMembersMissingImplementationTitle { get; }
    internal static string MembersDeclaredOnImplementationTypeMustBeStaticDescription { get; }
    internal static string MembersDeclaredOnImplementationTypeMustBeStaticMessage { get; }
    internal static string MembersDeclaredOnImplementationTypeMustBeStaticTitle { get; }
    internal static string MakeMethodDeclaredOnImplementationTypeStatic { get; }
    internal static string UseStringContainsCharOverloadWithSingleCharactersDescription { get; }
    internal static string UseStringContainsCharOverloadWithSingleCharactersMessage { get; }
    internal static string UseStringContainsCharOverloadWithSingleCharactersTitle { get; }
    internal static string ReplaceStringLiteralWithCharLiteralCodeActionTitle { get; }
    internal static string PreferHashDataOverComputeHashAnalyzerTitle { get; }
    internal static string PreferHashDataOverComputeHashAnalyzerDescription { get; }
    internal static string PreferHashDataOverComputeHashAnalyzerMessage { get; }
    internal static string PreferHashDataCodefixTitle { get; }
    internal static string DetectPreviewFeaturesDescription { get; }
    internal static string DetectPreviewFeaturesMessageWithCustomMessagePlaceholder { get; }
    internal static string DetectPreviewFeaturesTitle { get; }
    internal static string StaticAndAbstractRequiresPreviewFeatures { get; }
    internal static string MakeMethodDeclaredOnImplementationTypeStaticMayProduceInvalidCode { get; }
    internal static string DerivesFromPreviewClassMessageWithCustomMessagePlaceholder { get; }
    internal static string ImplementsPreviewInterfaceMessageWithCustomMessagePlaceholder { get; }
    internal static string ImplementsPreviewMethodMessageWithCustomMessagePlaceholder { get; }
    internal static string MethodReturnsPreviewTypeMessageWithCustomMessagePlaceholder { get; }
    internal static string MethodUsesPreviewTypeAsParameterMessageWithCustomMessagePlaceholder { get; }
    internal static string OverridesPreviewMethodMessageWithCustomMessagePlaceholder { get; }
    internal static string UsesPreviewTypeParameterMessageWithCustomMessagePlaceholder { get; }
    internal static string FieldIsPreviewTypeMessageWithCustomMessagePlaceholder { get; }
    internal static string ModuleInitializerAttributeShouldNotBeUsedInLibrariesDescription { get; }
    internal static string ModuleInitializerAttributeShouldNotBeUsedInLibrariesMessage { get; }
    internal static string ModuleInitializerAttributeShouldNotBeUsedInLibrariesTitle { get; }
    internal static string DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesDescription { get; }
    internal static string DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageCast { get; }
    internal static string UseAsyncMethodInAsyncContextMessage { get; }
    internal static string UseAsyncMethodInAsyncContextTitle { get; }
    internal static string UseAsyncMethodInAsyncContextMessage_NoAlternative { get; }
    internal static string UseAsyncMethodInAsyncContextDescription { get; }
    internal static string DoNotDisableTokenValidationChecksTitle { get; }
    internal static string DoNotDisableTokenValidationChecksDescription { get; }
    internal static string DoNotDisableTokenValidationChecksMessage { get; }
    internal static string DoNotAlwaysSkipTokenValidationInDelegatesTitle { get; }
    internal static string DoNotAlwaysSkipTokenValidationInDelegatesDescription { get; }
    internal static string DoNotAlwaysSkipTokenValidationInDelegatesMessage { get; }
    internal static string DerivesFromPreviewClassMessage { get; }
    internal static string DetectPreviewFeaturesMessage { get; }
    internal static string FieldIsPreviewTypeMessage { get; }
    internal static string ImplementsPreviewInterfaceMessage { get; }
    internal static string ImplementsPreviewMethodMessage { get; }
    internal static string MethodReturnsPreviewTypeMessage { get; }
    internal static string MethodUsesPreviewTypeAsParameterMessage { get; }
    internal static string OverridesPreviewMethodMessage { get; }
    internal static string UsesPreviewTypeParameterMessage { get; }
    internal static string ConstantExpectedApplicationTitle { get; }
    internal static string ConstantExpectedApplicationDescription { get; }
    internal static string ConstantExpectedUsageTitle { get; }
    internal static string ConstantExpectedUsageDescription { get; }
    internal static string ConstantExpectedNotSupportedMessage { get; }
    internal static string ConstantExpectedIncompatibleConstantTypeMessage { get; }
    internal static string ConstantExpectedInvalidBoundsMessage { get; }
    internal static string ConstantExpectedInvertedRangeMessage { get; }
    internal static string ConstantExpectedOutOfBoundsMessage { get; }
    internal static string ConstantExpectedInvalidMessage { get; }
    internal static string ConstantExpectedNotConstantMessage { get; }
    internal static string ConstantExpectedAttributExpectedMessage { get; }
    internal static string SpecifyCultureForToLowerAndToUpperTitle { get; }
    internal static string SpecifyCultureForToLowerAndToUpperDescription { get; }
    internal static string SpecifyCultureForToLowerAndToUpperMessage { get; }
    internal static string SpecifyCurrentCulture { get; }
    internal static string UseInvariantVersion { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledDescription { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledTitle { get; }
    internal static string MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledDescription { get; }
    internal static string MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledMessage { get; }
    internal static string MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledTitle { get; }
    internal static string UseDisabledMarshallingEquivalentCodeFix { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageAutoLayoutTypes { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageByRefParameters { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageHResultSwapping { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageLCIDConversionAttribute { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageManagedParameterOrReturnTypes { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageSetLastError { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageVarargPInvokes { get; }
    internal static string SealInternalTypesDescription { get; }
    internal static string SealInternalTypesMessage { get; }
    internal static string SealInternalTypesTitle { get; }
    internal static string SealInternalTypesCodeFixTitle { get; }
    internal static string FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageDelegateUsage { get; }
    internal static string PreferDictionaryTryGetValueCodeFixTitle { get; }
    internal static string PreferDictionaryTryGetValueTitle { get; }
    internal static string PreferDictionaryTryGetValueMessage { get; }
    internal static string PreferDictionaryTryGetValueDescription { get; }
    internal static string SpecifyIFormatProviderMessageIFormatProviderOptional { get; }
    internal static string PlatformCompatibilityObsoletedCsAllPlatformMessage { get; }
    internal static string PlatformCompatibilityObsoletedCsReachableMessage { get; }
    internal static string ParenthesisWithPlaceHolder { get; }
    internal static string ImplementGenericMathInterfacesCorrectlyDescription { get; }
    internal static string ImplementGenericMathInterfacesCorrectlyMessage { get; }
    internal static string ImplementGenericMathInterfacesCorrectlyTitle { get; }
    internal static string UseSpanClearInsteadOfFillCodeFixTitle { get; }
    internal static string UseSpanClearInsteadOfFillDescription { get; }
    internal static string UseSpanClearInsteadOfFillMessage { get; }
    internal static string UseSpanClearInsteadOfFillTitle { get; }
    internal static string UseSearchValuesTitle { get; }
    internal static string UseSearchValuesMessage { get; }
    internal static string UseSearchValuesDescription { get; }
    internal static string UseSearchValuesCodeFixTitle { get; }
    internal static string PreventNumericIntPtrUIntPtrBehavioralChangesDescription { get; }
    internal static string PreventNumericIntPtrUIntPtrBehavioralChangesConversionNotThrowMessage { get; }
    internal static string PreventNumericIntPtrUIntPtrBehavioralChangesOperatorThrowsMessage { get; }
    internal static string PreventNumericIntPtrUIntPtrBehavioralChangesTitle { get; }
    internal static string PreventNumericIntPtrUIntPtrBehavioralChangesConversionThrowsMessage { get; }
    internal static string UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFixTitle { get; }
    internal static string UseStartsWithInsteadOfIndexOfComparisonWithZeroDescription { get; }
    internal static string UseStartsWithInsteadOfIndexOfComparisonWithZeroMessage { get; }
    internal static string UseStartsWithInsteadOfIndexOfComparisonWithZeroTitle { get; }
    internal static string UseArgumentNullExceptionThrowHelperTitle { get; }
    internal static string UseArgumentExceptionThrowHelperTitle { get; }
    internal static string UseArgumentOutOfRangeExceptionThrowHelperTitle { get; }
    internal static string UseObjectDisposedExceptionThrowHelperTitle { get; }
    internal static string UseThrowHelperMessage { get; }
    internal static string UseThrowHelperDescription { get; }
    internal static string UseThrowHelperFix { get; }
    internal static string UseConcreteTypeDescription { get; }
    internal static string UseConcreteTypeForFieldMessage { get; }
    internal static string UseConcreteTypeTitle { get; }
    internal static string UseConcreteTypeForLocalMessage { get; }
    internal static string UseConcreteTypeForMethodReturnMessage { get; }
    internal static string UseConcreteTypeForPropertyMessage { get; }
    internal static string UseConcreteTypeForParameterMessage { get; }
    internal static string PreferLengthOverAnyCodeFixTitle { get; }
    internal static string PreferLengthOverAnyMessage { get; }
    internal static string PreferCountOverAnyCodeFixTitle { get; }
    internal static string PreferLengthCountIsEmptyOverAnyTitle { get; }
    internal static string PreferCountOverAnyMessage { get; }
    internal static string PreferLengthCountIsEmptyOverAnyDescription { get; }
    internal static string PreferIsEmptyOverAnyCodeFixTitle { get; }
    internal static string PreferIsEmptyOverAnyMessage { get; }
    internal static string RecommendCaseInsensitiveStringComparerStringComparisonCodeFixTitle { get; }
    internal static string RecommendCaseInsensitiveStringComparerDescription { get; }
    internal static string RecommendCaseInsensitiveStringComparerMessage { get; }
    internal static string RecommendCaseInsensitiveStringEqualsCodeFixTitle { get; }
    internal static string RecommendCaseInsensitiveStringEqualsDescription { get; }
    internal static string RecommendCaseInsensitiveStringEqualsMessage { get; }
    internal static string RecommendCaseInsensitiveStringComparisonTitle { get; }
    internal static string RecommendCaseInsensitiveStringComparisonDescription { get; }
    internal static string RecommendCaseInsensitiveStringComparisonMessage { get; }
    internal static string PreferDictionaryTryAddValueCodeFixTitle { get; }
    internal static string PreferDictionaryTryAddTitle { get; }
    internal static string PreferDictionaryTryAddMessage { get; }
    internal static string PreferDictionaryTryAddDescription { get; }
    internal static string UseCompositeFormatTitle { get; }
    internal static string UseCompositeFormatMessage { get; }
    internal static string UseCompositeFormatDescription { get; }
    internal static string UseStringMethodCharOverloadWithSingleCharactersDescription { get; }
    internal static string UseStringMethodCharOverloadWithSingleCharactersMessage { get; }
    internal static string UseStringMethodCharOverloadWithSingleCharactersTitle { get; }
    internal static string AvoidSingleUseOfLocalJsonSerializerOptionsMessage { get; }
    internal static string AvoidSingleUseOfLocalJsonSerializerOptionsDescription { get; }
    internal static string AvoidSingleUseOfLocalJsonSerializerOptionsTitle { get; }
    private static MicrosoftNetCoreAnalyzersResources();
    [NullableContextAttribute("1")]
public static LocalizableResourceString CreateLocalizableResourceString(string nameOfLocalizableResource);
    [NullableContextAttribute("1")]
public static LocalizableResourceString CreateLocalizableResourceString(string nameOfLocalizableResource, String[] formatArguments);
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_ReviewSQLQueriesForSecurityVulnerabilitiesDescription();
    internal static string get_ReviewSQLQueriesForSecurityVulnerabilitiesMessageNoNonLiterals();
    internal static string get_ReviewSQLQueriesForSecurityVulnerabilitiesTitle();
    internal static string get_DoNotCallToImmutableCollectionOnAnImmutableCollectionValueTitle();
    internal static string get_DoNotCallToImmutableCollectionOnAnImmutableCollectionValueMessage();
    internal static string get_RemoveRedundantCall();
    internal static string get_PInvokesShouldNotBeVisibleTitle();
    internal static string get_PInvokesShouldNotBeVisibleDescription();
    internal static string get_PInvokesShouldNotBeVisibleMessage();
    internal static string get_SpecifyMarshalingForPInvokeStringArgumentsTitle();
    internal static string get_SpecifyMarshalingForPInvokeStringArgumentsDescription();
    internal static string get_UseManagedEquivalentsOfWin32ApiTitle();
    internal static string get_UseManagedEquivalentsOfWin32ApiDescription();
    internal static string get_UseManagedEquivalentsOfWin32ApiMessage();
    internal static string get_MarkBooleanPInvokeArgumentsWithMarshalAsTitle();
    internal static string get_MarkBooleanPInvokeArgumentsWithMarshalAsDescription();
    internal static string get_MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault();
    internal static string get_MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn();
    internal static string get_MarkAssembliesWithNeutralResourcesLanguageTitle();
    internal static string get_MarkAssembliesWithNeutralResourcesLanguageDescription();
    internal static string get_MarkAssembliesWithNeutralResourcesLanguageMessage();
    internal static string get_UseOrdinalStringComparisonTitle();
    internal static string get_UseOrdinalStringComparisonDescription();
    internal static string get_DoNotUseCountWhenAnyCanBeUsedDescription();
    internal static string get_DoNotUseCountWhenAnyCanBeUsedMessage();
    internal static string get_DoNotUseCountWhenAnyCanBeUsedTitle();
    internal static string get_DoNotUseTimersThatPreventPowerStateChangesTitle();
    internal static string get_DoNotUseTimersThatPreventPowerStateChangesDescription();
    internal static string get_DoNotUseTimersThatPreventPowerStateChangesMessage();
    internal static string get_AvoidUnsealedAttributesTitle();
    internal static string get_AvoidUnsealedAttributesDescription();
    internal static string get_AvoidUnsealedAttributesMessage();
    internal static string get_AvoidConstArraysTitle();
    internal static string get_AvoidConstArraysCodeFixTitle();
    internal static string get_AvoidConstArraysDescription();
    internal static string get_AvoidConstArraysMessage();
    internal static string get_TestForEmptyStringsUsingStringLengthTitle();
    internal static string get_TestForEmptyStringsUsingStringLengthDescription();
    internal static string get_TestForEmptyStringsUsingStringLengthMessage();
    internal static string get_DoNotLockOnObjectsWithWeakIdentityTitle();
    internal static string get_DoNotLockOnObjectsWithWeakIdentityDescription();
    internal static string get_DoNotLockOnObjectsWithWeakIdentityMessage();
    internal static string get_DoNotRaiseReservedExceptionTypesTitle();
    internal static string get_DoNotRaiseReservedExceptionTypesDescription();
    internal static string get_DoNotRaiseReservedExceptionTypesMessageTooGeneric();
    internal static string get_DoNotRaiseReservedExceptionTypesMessageReserved();
    internal static string get_InitializeValueTypeStaticFieldsInlineTitle();
    internal static string get_InitializeReferenceTypeStaticFieldsInlineTitle();
    internal static string get_InitializeValueTypeStaticFieldsInlineDescription();
    internal static string get_InitializeReferenceTypeStaticFieldsInlineDescription();
    internal static string get_InitializeStaticFieldsInlineMessage();
    internal static string get_DisposableTypesShouldDeclareFinalizerTitle();
    internal static string get_DisposableTypesShouldDeclareFinalizerDescription();
    internal static string get_DisposableTypesShouldDeclareFinalizerMessage();
    internal static string get_ProvideCorrectArgumentsToFormattingMethodsTitle();
    internal static string get_ProvideCorrectArgumentsToFormattingMethodsDescription();
    internal static string get_ProvideCorrectArgumentsToFormattingMethodsMessage();
    internal static string get_ProvideCorrectArgumentsToFormattingMethodsInvalidFormatMessage();
    internal static string get_TestForNaNCorrectlyTitle();
    internal static string get_TestForNaNCorrectlyDescription();
    internal static string get_TestForNaNCorrectlyMessage();
    internal static string get_AttributeStringLiteralsShouldParseCorrectlyTitle();
    internal static string get_AttributeStringLiteralsShouldParseCorrectlyDescription();
    internal static string get_AttributeStringLiteralsShouldParseCorrectlyMessageDefault();
    internal static string get_AttributeStringLiteralsShouldParseCorrectlyMessageEmpty();
    internal static string get_AvoidZeroLengthArrayAllocationsTitle();
    internal static string get_AvoidZeroLengthArrayAllocationsMessage();
    internal static string get_DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle();
    internal static string get_DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription();
    internal static string get_DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage();
    internal static string get_SpecifyCultureInfoTitle();
    internal static string get_SpecifyCultureInfoDescription();
    internal static string get_SpecifyCultureInfoMessage();
    internal static string get_SpecifyIFormatProviderTitle();
    internal static string get_SpecifyIFormatProviderDescription();
    internal static string get_SpecifyIFormatProviderMessageIFormatProviderAlternateString();
    internal static string get_SpecifyIFormatProviderMessageIFormatProviderAlternate();
    internal static string get_SpecifyIFormatProviderMessageUICultureString();
    internal static string get_SpecifyIFormatProviderMessageUICulture();
    internal static string get_SpecifyStringComparisonCA1307Title();
    internal static string get_SpecifyStringComparisonCA1307Description();
    internal static string get_SpecifyStringComparisonCA1307Message();
    internal static string get_SpecifyStringComparisonCA1310Title();
    internal static string get_SpecifyStringComparisonCA1310Description();
    internal static string get_SpecifyStringComparisonCA1310Message();
    internal static string get_NormalizeStringsToUppercaseTitle();
    internal static string get_NormalizeStringsToUppercaseDescription();
    internal static string get_NormalizeStringsToUppercaseMessageToUpper();
    internal static string get_CallGCSuppressFinalizeCorrectlyTitle();
    internal static string get_CallGCSuppressFinalizeCorrectlyDescription();
    internal static string get_CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer();
    internal static string get_CallGCSuppressFinalizeCorrectlyMessageNotCalled();
    internal static string get_CallGCSuppressFinalizeCorrectlyMessageNotPassedThis();
    internal static string get_CallGCSuppressFinalizeCorrectlyMessageOutsideDispose();
    internal static string get_InstantiateArgumentExceptionsCorrectlyTitle();
    internal static string get_InstantiateArgumentExceptionsCorrectlyDescription();
    internal static string get_InstantiateArgumentExceptionsCorrectlyMessageNoArguments();
    internal static string get_InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage();
    internal static string get_InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName();
    internal static string get_UseArrayEmpty();
    internal static string get_UseIndexer();
    internal static string get_DisposableFieldsShouldBeDisposedDescription();
    internal static string get_DisposableFieldsShouldBeDisposedMessage();
    internal static string get_DisposableFieldsShouldBeDisposedTitle();
    internal static string get_DisposeMethodsShouldCallBaseClassDisposeDescription();
    internal static string get_DisposeMethodsShouldCallBaseClassDisposeMessage();
    internal static string get_DisposeMethodsShouldCallBaseClassDisposeTitle();
    internal static string get_DisposeObjectsBeforeLosingScopeDescription();
    internal static string get_DisposeObjectsBeforeLosingScopeNotDisposedMessage();
    internal static string get_DisposeObjectsBeforeLosingScopeMayBeDisposedMessage();
    internal static string get_DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage();
    internal static string get_DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage();
    internal static string get_DisposeObjectsBeforeLosingScopeTitle();
    internal static string get_DoNotPassLiteralsAsLocalizedParametersDescription();
    internal static string get_DoNotPassLiteralsAsLocalizedParametersMessage();
    internal static string get_DoNotPassLiteralsAsLocalizedParametersTitle();
    internal static string get_AddNonSerializedAttributeCodeActionTitle();
    internal static string get_AddSerializableAttributeCodeActionTitle();
    internal static string get_MarkAllNonSerializableFieldsDescription();
    internal static string get_MarkAllNonSerializableFieldsMessage();
    internal static string get_MarkAllNonSerializableFieldsTitle();
    internal static string get_MarkISerializableTypesWithSerializableDescription();
    internal static string get_MarkISerializableTypesWithSerializableMessage();
    internal static string get_MarkISerializableTypesWithSerializableTitle();
    internal static string get_ReviewCodeForSqlInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForSqlInjectionVulnerabilitiesTitle();
    internal static string get_BinaryFormatterDeserializeMaybeWithoutBinderSetMessage();
    internal static string get_BinaryFormatterDeserializeMaybeWithoutBinderSetTitle();
    internal static string get_BinaryFormatterDeserializeWithoutBinderSetMessage();
    internal static string get_BinaryFormatterDeserializeWithoutBinderSetTitle();
    internal static string get_BinaryFormatterMethodUsedDescription();
    internal static string get_BinaryFormatterMethodUsedMessage();
    internal static string get_BinaryFormatterMethodUsedTitle();
    internal static string get_LosFormatterMethodUsedMessage();
    internal static string get_LosFormatterMethodUsedTitle();
    internal static string get_ReviewCodeForDllInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForDllInjectionVulnerabilitiesTitle();
    internal static string get_ReviewCodeForInformationDisclosureVulnerabilitiesMessage();
    internal static string get_ReviewCodeForInformationDisclosureVulnerabilitiesTitle();
    internal static string get_ReviewCodeForFilePathInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForFilePathInjectionVulnerabilitiesTitle();
    internal static string get_ReviewCodeForProcessCommandInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForProcessCommandInjectionVulnerabilitiesTitle();
    internal static string get_ReviewCodeForRegexInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForRegexInjectionVulnerabilitiesTitle();
    internal static string get_NetDataContractSerializerDeserializeMaybeWithoutBinderSetMessage();
    internal static string get_NetDataContractSerializerDeserializeMaybeWithoutBinderSetTitle();
    internal static string get_NetDataContractSerializerDeserializeWithoutBinderSetMessage();
    internal static string get_NetDataContractSerializerDeserializeWithoutBinderSetTitle();
    internal static string get_NetDataContractSerializerMethodUsedDescription();
    internal static string get_NetDataContractSerializerMethodUsedMessage();
    internal static string get_NetDataContractSerializerMethodUsedTitle();
    internal static string get_ObjectStateFormatterMethodUsedMessage();
    internal static string get_ObjectStateFormatterMethodUsedTitle();
    internal static string get_ReviewCodeForXssVulnerabilitiesMessage();
    internal static string get_ReviewCodeForXssVulnerabilitiesTitle();
    internal static string get_ReviewCodeForLdapInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForLdapInjectionVulnerabilitiesTitle();
    internal static string get_JavaScriptSerializerMaybeWithSimpleTypeResolverMessage();
    internal static string get_JavaScriptSerializerMaybeWithSimpleTypeResolverTitle();
    internal static string get_JavaScriptSerializerWithSimpleTypeResolverMessage();
    internal static string get_JavaScriptSerializerWithSimpleTypeResolverTitle();
    internal static string get_ReviewCodeForOpenRedirectVulnerabilitiesMessage();
    internal static string get_ReviewCodeForOpenRedirectVulnerabilitiesTitle();
    internal static string get_ReviewCodeForXPathInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForXPathInjectionVulnerabilitiesTitle();
    internal static string get_ReviewCodeForXmlInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForXmlInjectionVulnerabilitiesTitle();
    internal static string get_ReviewCodeForXamlInjectionVulnerabilitiesMessage();
    internal static string get_ReviewCodeForXamlInjectionVulnerabilitiesTitle();
    internal static string get_JsonNetInsecureSettingsMessage();
    internal static string get_JsonNetInsecureSettingsTitle();
    internal static string get_JsonNetMaybeInsecureSettingsMessage();
    internal static string get_JsonNetMaybeInsecureSettingsTitle();
    internal static string get_DoNotDisableUsingServicePointManagerSecurityProtocolsMessage();
    internal static string get_DoNotDisableUsingServicePointManagerSecurityProtocolsTitle();
    internal static string get_JsonNetTypeNameHandlingDescription();
    internal static string get_JsonNetTypeNameHandlingMessage();
    internal static string get_JsonNetTypeNameHandlingTitle();
    internal static string get_ApprovedCipherMode();
    internal static string get_ApprovedCipherModeDescription();
    internal static string get_ApprovedCipherModeMessage();
    internal static string get_DefinitelyInstallRootCert();
    internal static string get_DefinitelyInstallRootCertMessage();
    internal static string get_DefinitelyUseSecureCookiesASPNetCore();
    internal static string get_DefinitelyUseSecureCookiesASPNetCoreMessage();
    internal static string get_DoNotAddSchemaByURL();
    internal static string get_DoNotAddSchemaByURLDescription();
    internal static string get_DoNotAddSchemaByURLMessage();
    internal static string get_DoNotCallDangerousMethodsInDeserializationTitle();
    internal static string get_DoNotCallDangerousMethodsInDeserializationDescription();
    internal static string get_DoNotCallDangerousMethodsInDeserializationMessage();
    internal static string get_DoNotDisableCertificateValidation();
    internal static string get_DoNotDisableCertificateValidationDescription();
    internal static string get_DoNotDisableCertificateValidationMessage();
    internal static string get_DoNotDisableHTTPHeaderChecking();
    internal static string get_DoNotDisableHTTPHeaderCheckingDescription();
    internal static string get_DoNotDisableHTTPHeaderCheckingMessage();
    internal static string get_DoNotDisableRequestValidation();
    internal static string get_DoNotDisableRequestValidationDescription();
    internal static string get_DoNotDisableRequestValidationMessage();
    internal static string get_DoNotDisableSchUseStrongCrypto();
    internal static string get_DoNotDisableSchUseStrongCryptoDescription();
    internal static string get_DoNotDisableSchUseStrongCryptoMessage();
    internal static string get_DoNotHardCodeEncryptionKey();
    internal static string get_DoNotHardCodeEncryptionKeyDescription();
    internal static string get_DoNotHardCodeEncryptionKeyMessage();
    internal static string get_DoNotInstallRootCertDescription();
    internal static string get_PotentialReferenceCycleInDeserializedObjectGraphTitle();
    internal static string get_PotentialReferenceCycleInDeserializedObjectGraphDescription();
    internal static string get_PotentialReferenceCycleInDeserializedObjectGraphMessage();
    internal static string get_DoNotSerializeTypesWithPointerFields();
    internal static string get_DoNotSerializeTypesWithPointerFieldsDescription();
    internal static string get_DoNotSerializeTypesWithPointerFieldsMessage();
    internal static string get_DoNotUseAccountSAS();
    internal static string get_DoNotUseAccountSASDescription();
    internal static string get_DoNotUseAccountSASMessage();
    internal static string get_DoNotUseBrokenCryptographicAlgorithms();
    internal static string get_DoNotUseBrokenCryptographicAlgorithmsDescription();
    internal static string get_DoNotUseBrokenCryptographicAlgorithmsMessage();
    internal static string get_DoNotUseDeprecatedSecurityProtocols();
    internal static string get_DoNotUseDeprecatedSecurityProtocolsDescription();
    internal static string get_DoNotUseDeprecatedSecurityProtocolsMessage();
    internal static string get_DoNotUseDSA();
    internal static string get_DoNotUseDSADescription();
    internal static string get_DoNotUseDSAMessage();
    internal static string get_DoNotUseObsoleteKDFAlgorithm();
    internal static string get_DoNotUseObsoleteKDFAlgorithmDescription();
    internal static string get_DoNotUseObsoleteKDFAlgorithmMessage();
    internal static string get_DoNotUseReferenceEqualsWithValueTypesDescription();
    internal static string get_DoNotUseReferenceEqualsWithValueTypesComparerMessage();
    internal static string get_DoNotUseReferenceEqualsWithValueTypesMethodMessage();
    internal static string get_DoNotUseReferenceEqualsWithValueTypesTitle();
    internal static string get_DoNotUseWeakCryptographicAlgorithms();
    internal static string get_DoNotUseWeakCryptographicAlgorithmsDescription();
    internal static string get_DoNotUseWeakCryptographicAlgorithmsMessage();
    internal static string get_DoNotUseWeakKDFAlgorithm();
    internal static string get_DoNotUseWeakKDFAlgorithmDescription();
    internal static string get_DoNotUseWeakKDFAlgorithmMessage();
    internal static string get_DoNotUseXslTransform();
    internal static string get_DoNotUseXslTransformMessage();
    internal static string get_HardCodedSecurityProtocolMessage();
    internal static string get_HardCodedSecurityProtocolTitle();
    internal static string get_MaybeInstallRootCert();
    internal static string get_MaybeInstallRootCertMessage();
    internal static string get_MaybeUseSecureCookiesASPNetCore();
    internal static string get_MaybeUseSecureCookiesASPNetCoreMessage();
    internal static string get_SetViewStateUserKey();
    internal static string get_SetViewStateUserKeyDescription();
    internal static string get_SetViewStateUserKeyMessage();
    internal static string get_UseAsSpanInsteadOfArrayRangeIndexerDescription();
    internal static string get_UseAsSpanInsteadOfStringRangeIndexerDescription();
    internal static string get_UseAsSpanInsteadOfRangeIndexerMessage();
    internal static string get_UseAsSpanInsteadOfRangeIndexerTitle();
    internal static string get_UseAsSpanReadOnlyInsteadOfArrayRangeIndexerDescription();
    internal static string get_UseContainerLevelAccessPolicy();
    internal static string get_UseContainerLevelAccessPolicyDescription();
    internal static string get_UseContainerLevelAccessPolicyMessage();
    internal static string get_UseSecureCookiesASPNetCoreDescription();
    internal static string get_UseSharedAccessProtocolHttpsOnly();
    internal static string get_UseSharedAccessProtocolHttpsOnlyDescription();
    internal static string get_UseSharedAccessProtocolHttpsOnlyMessage();
    internal static string get_UseXmlReaderDescription();
    internal static string get_UseXmlReaderForDataSetReadXml();
    internal static string get_UseXmlReaderForDeserialize();
    internal static string get_UseXmlReaderForSchemaRead();
    internal static string get_UseXmlReaderForValidatingReader();
    internal static string get_UseXmlReaderForXPathDocument();
    internal static string get_UseXmlReaderMessage();
    internal static string get_UseRSAWithSufficientKeySize();
    internal static string get_UseRSAWithSufficientKeySizeDescription();
    internal static string get_UseRSAWithSufficientKeySizeMessage();
    internal static string get_DefinitelyUseWeakKDFInsufficientIterationCount();
    internal static string get_DefinitelyUseWeakKDFInsufficientIterationCountMessage();
    internal static string get_DoNotUseWeakKDFInsufficientIterationCountDescription();
    internal static string get_MaybeUseWeakKDFInsufficientIterationCount();
    internal static string get_MaybeUseWeakKDFInsufficientIterationCountMessage();
    internal static string get_DoNotAddArchiveItemPathToTheTargetFileSystemPath();
    internal static string get_DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription();
    internal static string get_DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage();
    internal static string get_DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesTitle();
    internal static string get_DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageOfType();
    internal static string get_DoNotCreateTasksWithoutPassingATaskSchedulerTitle();
    internal static string get_DoNotCreateTasksWithoutPassingATaskSchedulerDescription();
    internal static string get_DoNotCreateTasksWithoutPassingATaskSchedulerMessage();
    internal static string get_DoNotDefineFinalizersForTypesDerivedFromMemoryManagerDescription();
    internal static string get_DoNotDefineFinalizersForTypesDerivedFromMemoryManagerMessage();
    internal static string get_DoNotDefineFinalizersForTypesDerivedFromMemoryManagerTitle();
    internal static string get_UseValueTasksCorrectlyTitle();
    internal static string get_UseValueTasksCorrectlyDescription();
    internal static string get_UseValueTasksCorrectlyMessage_General();
    internal static string get_UseValueTasksCorrectlyMessage_Unconsumed();
    internal static string get_UseValueTasksCorrectlyMessage_DoubleConsumption();
    internal static string get_UseValueTasksCorrectlyMessage_AccessingIncompleteResult();
    internal static string get_DoNotUseConfigureAwaitWithSuppressThrowingTitle();
    internal static string get_DoNotUseConfigureAwaitWithSuppressThrowingMessage();
    internal static string get_DoNotUseConfigureAwaitWithSuppressThrowingDescription();
    internal static string get_DoNotCreateTaskCompletionSourceWithWrongArgumentsTitle();
    internal static string get_DoNotCreateTaskCompletionSourceWithWrongArgumentsDescription();
    internal static string get_DoNotCreateTaskCompletionSourceWithWrongArgumentsMessage();
    internal static string get_DoNotCreateTaskCompletionSourceWithWrongArgumentsFix();
    internal static string get_JsonNetInsecureSerializerMessage();
    internal static string get_JsonNetInsecureSerializerTitle();
    internal static string get_JsonNetMaybeInsecureSerializerMessage();
    internal static string get_JsonNetMaybeInsecureSerializerTitle();
    internal static string get_UseDefaultDllImportSearchPathsAttribute();
    internal static string get_UseDefaultDllImportSearchPathsAttributeDescription();
    internal static string get_UseDefaultDllImportSearchPathsAttributeMessage();
    internal static string get_DoNotUseUnsafeDllImportSearchPath();
    internal static string get_DoNotUseUnsafeDllImportSearchPathDescription();
    internal static string get_DoNotUseUnsafeDllImportSearchPathMessage();
    internal static string get_UseAutoValidateAntiforgeryToken();
    internal static string get_UseAutoValidateAntiforgeryTokenDescription();
    internal static string get_UseAutoValidateAntiforgeryTokenMessage();
    internal static string get_MissHttpVerbAttribute();
    internal static string get_MissHttpVerbAttributeMessage();
    internal static string get_DoNotUseInsecureRandomness();
    internal static string get_DoNotUseInsecureRandomnessMessage();
    internal static string get_DoNotUseInsecureRandomnessDescription();
    internal static string get_DoNotUseCountAsyncWhenAnyAsyncCanBeUsedDescription();
    internal static string get_DoNotUseCountAsyncWhenAnyAsyncCanBeUsedMessage();
    internal static string get_DoNotUseCountAsyncWhenAnyAsyncCanBeUsedTitle();
    internal static string get_UsePropertyInsteadOfCountMethodWhenAvailableDescription();
    internal static string get_UsePropertyInsteadOfCountMethodWhenAvailableMessage();
    internal static string get_UsePropertyInsteadOfCountMethodWhenAvailableTitle();
    internal static string get_SetHttpOnlyForHttpCookie();
    internal static string get_SetHttpOnlyForHttpCookieDescription();
    internal static string get_SetHttpOnlyForHttpCookieMessage();
    internal static string get_DeprecatedSslProtocolsDescription();
    internal static string get_DeprecatedSslProtocolsMessage();
    internal static string get_DeprecatedSslProtocolsTitle();
    internal static string get_HardcodedSslProtocolsDescription();
    internal static string get_HardcodedSslProtocolsMessage();
    internal static string get_HardcodedSslProtocolsTitle();
    internal static string get_MissHttpVerbAttributeDescription();
    internal static string get_DefinitelyDisableHttpClientCRLCheck();
    internal static string get_DefinitelyDisableHttpClientCRLCheckMessage();
    internal static string get_DoNotDisableHttpClientCRLCheckDescription();
    internal static string get_MaybeDisableHttpClientCRLCheck();
    internal static string get_MaybeDisableHttpClientCRLCheckMessage();
    internal static string get_DoNotHardCodeCertificate();
    internal static string get_DoNotHardCodeCertificateDescription();
    internal static string get_DoNotHardCodeCertificateMessage();
    internal static string get_DefinitelyUseCreateEncryptorWithNonDefaultIV();
    internal static string get_DefinitelyUseCreateEncryptorWithNonDefaultIVMessage();
    internal static string get_MaybeUseCreateEncryptorWithNonDefaultIV();
    internal static string get_MaybeUseCreateEncryptorWithNonDefaultIVMessage();
    internal static string get_DoNotUseCreateEncryptorWithNonDefaultIVDescription();
    internal static string get_DataTableReadXmlMessage();
    internal static string get_DataTableReadXmlTitle();
    internal static string get_DataSetDataTableInSerializableTypeMessage();
    internal static string get_DataSetDataTableInWebDeserializableObjectGraphMessage();
    internal static string get_DataSetDataTableInWebDeserializableObjectGraphTitle();
    internal static string get_DataSetReadXmlMessage();
    internal static string get_DataSetReadXmlTitle();
    internal static string get_DataSetDataTableInRceSerializableTypeMessage();
    internal static string get_DataSetDataTableInDeserializableObjectGraphMessage();
    internal static string get_DataSetDataTableInDeserializableObjectGraphTitle();
    internal static string get_DataSetDataTableInRceDeserializableObjectGraphMessage();
    internal static string get_DataSetDataTableInRceDeserializableObjectGraphTitle();
    internal static string get_DataSetDataTableInRceAutogeneratedSerializableTypeMessage();
    internal static string get_DataSetDataTableInRceAutogeneratedSerializableTypeTitle();
    internal static string get_DataSetDataTableInRceSerializableTypeTitle();
    internal static string get_DataSetDataTableInSerializableTypeTitle();
    internal static string get_DataSetReadXmlAutogeneratedMessage();
    internal static string get_DataSetReadXmlAutogeneratedTitle();
    internal static string get_DoNotUseStackallocInLoopsTitle();
    internal static string get_DoNotUseStackallocInLoopsDescription();
    internal static string get_DoNotUseStackallocInLoopsMessage();
    internal static string get_PreferStreamAsyncMemoryOverloadsTitle();
    internal static string get_PreferStreamAsyncMemoryOverloadsDescription();
    internal static string get_PreferStreamAsyncMemoryOverloadsMessage();
    internal static string get_ForwardCancellationTokenToInvocationsDescription();
    internal static string get_ForwardCancellationTokenToInvocationsMessage();
    internal static string get_ForwardCancellationTokenToInvocationsTitle();
    internal static string get_InstantiateArgumentExceptionsCorrectlyChangeToTwoArgumentCodeFixTitle();
    internal static string get_InstantiateArgumentExceptionsCorrectlyFlipArgumentOrderCodeFixTitle();
    internal static string get_PreferTypedStringBuilderAppendOverloadsTitle();
    internal static string get_PreferTypedStringBuilderAppendOverloadsDescription();
    internal static string get_PreferTypedStringBuilderAppendOverloadsMessage();
    internal static string get_PreferTypedStringBuilderAppendOverloadsRemoveToString();
    internal static string get_PreferStringContainsOverIndexOfDescription();
    internal static string get_PreferStringContainsOverIndexOfMessage();
    internal static string get_PreferStringContainsOverIndexOfTitle();
    internal static string get_PreferConstCharOverConstUnitStringInStringBuilderDescription();
    internal static string get_PreferConstCharOverConstUnitStringInStringBuilderMessage();
    internal static string get_PreferConstCharOverConstUnitStringInStringBuilderTitle();
    internal static string get_ProvideCorrectArgumentToEnumHasFlagDescription();
    internal static string get_ProvideCorrectArgumentToEnumHasFlagMessageDifferentType();
    internal static string get_ProvideCorrectArgumentToEnumHasFlagTitle();
    internal static string get_PreferIsEmptyOverCountDescription();
    internal static string get_PreferIsEmptyOverCountMessage();
    internal static string get_PreferIsEmptyOverCountTitle();
    internal static string get_UseEnvironmentProcessIdDescription();
    internal static string get_UseEnvironmentProcessIdMessage();
    internal static string get_UseEnvironmentProcessIdTitle();
    internal static string get_UseEnvironmentProcessIdFix();
    internal static string get_UseEnvironmentProcessPathDescription();
    internal static string get_UseEnvironmentProcessPathMessage();
    internal static string get_UseEnvironmentProcessPathTitle();
    internal static string get_UseEnvironmentProcessPathFix();
    internal static string get_UseEnvironmentCurrentManagedThreadIdDescription();
    internal static string get_UseEnvironmentCurrentManagedThreadIdMessage();
    internal static string get_UseEnvironmentCurrentManagedThreadIdTitle();
    internal static string get_UseEnvironmentCurrentManagedThreadIdFix();
    internal static string get_ThreadStaticOnNonStaticFieldDescription();
    internal static string get_ThreadStaticOnNonStaticFieldMessage();
    internal static string get_ThreadStaticOnNonStaticFieldTitle();
    internal static string get_ThreadStaticInitializedInlineDescription();
    internal static string get_ThreadStaticInitializedInlineMessage();
    internal static string get_ThreadStaticInitializedInlineTitle();
    internal static string get_UseAsSpanInsteadOfRangeIndexerOnAStringCodeFixTitle();
    internal static string get_UseAsSpanInsteadOfRangeIndexerOnAnArrayCodeFixTitle();
    internal static string get_PlatformCompatibilityTitle();
    internal static string get_PlatformCompatibilityDescription();
    internal static string get_PlatformCompatibilityOnlySupportedCsUnreachableMessage();
    internal static string get_PlatformCompatibilityUnsupportedCsAllPlatformMessage();
    internal static string get_DoNotUseOutAttributeStringPInvokeParametersDescription();
    internal static string get_DoNotUseOutAttributeStringPInvokeParametersMessage();
    internal static string get_DoNotUseOutAttributeStringPInvokeParametersTitle();
    internal static string get_AvoidStringBuilderPInvokeParametersDescription();
    internal static string get_AvoidStringBuilderPInvokeParametersMessage();
    internal static string get_AvoidStringBuilderPInvokeParametersTitle();
    internal static string get_PlatformCompatibilityOnlySupportedCsReachableMessage();
    internal static string get_PlatformCompatibilityOnlySupportedCsAllPlatformMessage();
    internal static string get_PreferStringContainsOverIndexOfCodeFixTitle();
    internal static string get_CommaSeparator();
    internal static string get_PlatformCompatibilityFromVersionToVersion();
    internal static string get_PlatformCompatibilitySupportedCsAllPlatformMessage();
    internal static string get_PlatformCompatibilitySupportedCsReachableMessage();
    internal static string get_PlatformCompatibilityUnsupportedCsReachableMessage();
    internal static string get_PlatformCompatibilityVersionAndBefore();
    internal static string get_PlatformCompatibilityVersionAndLater();
    internal static string get_PlatformCompatibilityAllVersions();
    internal static string get_PlatformCompatibilityAllPlatforms();
    internal static string get_DoNotGuardDictionaryRemoveByContainsKeyDescription();
    internal static string get_DoNotGuardDictionaryRemoveByContainsKeyMessage();
    internal static string get_DoNotGuardDictionaryRemoveByContainsKeyTitle();
    internal static string get_DoNotGuardSetAddOrRemoveByContainsDescription();
    internal static string get_DoNotGuardSetAddOrRemoveByContainsMessage();
    internal static string get_DoNotGuardSetAddOrRemoveByContainsTitle();
    internal static string get_RemoveRedundantGuardCallCodeFixTitle();
    internal static string get_BufferBlockCopyLengthMessage();
    internal static string get_BufferBlockCopyLengthTitle();
    internal static string get_BufferBlockCopyDescription();
    internal static string get_PreferAsSpanOverSubstringDescription();
    internal static string get_PreferAsSpanOverSubstringMessage();
    internal static string get_PreferAsSpanOverSubstringTitle();
    internal static string get_PreferAsSpanOverSubstringCodefixTitle();
    internal static string get_UseCancellationTokenThrowIfCancellationRequestedDescription();
    internal static string get_UseCancellationTokenThrowIfCancellationRequestedMessage();
    internal static string get_UseCancellationTokenThrowIfCancellationRequestedTitle();
    internal static string get_UseCancellationTokenThrowIfCancellationRequestedCodeFixTitle();
    internal static string get_ProvideStreamMemoryBasedAsyncOverridesDescription();
    internal static string get_ProvideStreamMemoryBasedAsyncOverridesMessage();
    internal static string get_ProvideStreamMemoryBasedAsyncOverridesTitle();
    internal static string get_UseSpanBasedStringConcatDescription();
    internal static string get_UseSpanBasedStringConcatMessage();
    internal static string get_UseSpanBasedStringConcatTitle();
    internal static string get_UseSpanBasedStringConcatCodeFixTitle();
    internal static string get_PreferDictionaryContainsKeyCodeFixTitle();
    internal static string get_PreferDictionaryContainsKeyDescription();
    internal static string get_PreferDictionaryContainsKeyMessage();
    internal static string get_PreferDictionaryContainsMethodsTitle();
    internal static string get_PreferDictionaryContainsValueCodeFixTitle();
    internal static string get_PreferDictionaryContainsValueDescription();
    internal static string get_PreferDictionaryContainsValueMessage();
    internal static string get_UseValidPlatformStringDescription();
    internal static string get_UseValidPlatformStringTitle();
    internal static string get_UseValidPlatformStringUnknownPlatform();
    internal static string get_UseValidPlatformStringInvalidVersion();
    internal static string get_UseValidPlatformStringNoVersion();
    internal static string get_DoNotUseWaitAllWithSingleTaskDescription();
    internal static string get_DoNotUseWaitAllWithSingleTaskTitle();
    internal static string get_DoNotUseWhenAllWithSingleTaskDescription();
    internal static string get_DoNotUseWhenAllWithSingleTaskTitle();
    internal static string get_DoNotUseWaitAllWithSingleTaskFix();
    internal static string get_DoNotUseWhenAllWithSingleTaskFix();
    internal static string get_UseStringEqualsOverStringCompareCodeFixTitle();
    internal static string get_UseStringEqualsOverStringCompareDescription();
    internal static string get_UseStringEqualsOverStringCompareMessage();
    internal static string get_UseStringEqualsOverStringCompareTitle();
    internal static string get_ProvidePublicParameterlessSafeHandleConstructorDescription();
    internal static string get_ProvidePublicParameterlessSafeHandleConstructorMessage();
    internal static string get_ProvidePublicParameterlessSafeHandleConstructorTitle();
    internal static string get_MakeParameterlessConstructorPublic();
    internal static string get_DynamicInterfaceCastableImplementationUnsupportedDescription();
    internal static string get_DynamicInterfaceCastableImplementationUnsupportedMessage();
    internal static string get_DynamicInterfaceCastableImplementationUnsupportedTitle();
    internal static string get_ImplementInterfacesOnDynamicCastableImplementation();
    internal static string get_InterfaceMembersMissingImplementationDescription();
    internal static string get_InterfaceMembersMissingImplementationMessage();
    internal static string get_InterfaceMembersMissingImplementationTitle();
    internal static string get_MembersDeclaredOnImplementationTypeMustBeStaticDescription();
    internal static string get_MembersDeclaredOnImplementationTypeMustBeStaticMessage();
    internal static string get_MembersDeclaredOnImplementationTypeMustBeStaticTitle();
    internal static string get_MakeMethodDeclaredOnImplementationTypeStatic();
    internal static string get_UseStringContainsCharOverloadWithSingleCharactersDescription();
    internal static string get_UseStringContainsCharOverloadWithSingleCharactersMessage();
    internal static string get_UseStringContainsCharOverloadWithSingleCharactersTitle();
    internal static string get_ReplaceStringLiteralWithCharLiteralCodeActionTitle();
    internal static string get_PreferHashDataOverComputeHashAnalyzerTitle();
    internal static string get_PreferHashDataOverComputeHashAnalyzerDescription();
    internal static string get_PreferHashDataOverComputeHashAnalyzerMessage();
    internal static string get_PreferHashDataCodefixTitle();
    internal static string get_DetectPreviewFeaturesDescription();
    internal static string get_DetectPreviewFeaturesMessageWithCustomMessagePlaceholder();
    internal static string get_DetectPreviewFeaturesTitle();
    internal static string get_StaticAndAbstractRequiresPreviewFeatures();
    internal static string get_MakeMethodDeclaredOnImplementationTypeStaticMayProduceInvalidCode();
    internal static string get_DerivesFromPreviewClassMessageWithCustomMessagePlaceholder();
    internal static string get_ImplementsPreviewInterfaceMessageWithCustomMessagePlaceholder();
    internal static string get_ImplementsPreviewMethodMessageWithCustomMessagePlaceholder();
    internal static string get_MethodReturnsPreviewTypeMessageWithCustomMessagePlaceholder();
    internal static string get_MethodUsesPreviewTypeAsParameterMessageWithCustomMessagePlaceholder();
    internal static string get_OverridesPreviewMethodMessageWithCustomMessagePlaceholder();
    internal static string get_UsesPreviewTypeParameterMessageWithCustomMessagePlaceholder();
    internal static string get_FieldIsPreviewTypeMessageWithCustomMessagePlaceholder();
    internal static string get_ModuleInitializerAttributeShouldNotBeUsedInLibrariesDescription();
    internal static string get_ModuleInitializerAttributeShouldNotBeUsedInLibrariesMessage();
    internal static string get_ModuleInitializerAttributeShouldNotBeUsedInLibrariesTitle();
    internal static string get_DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesDescription();
    internal static string get_DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesMessageCast();
    internal static string get_UseAsyncMethodInAsyncContextMessage();
    internal static string get_UseAsyncMethodInAsyncContextTitle();
    internal static string get_UseAsyncMethodInAsyncContextMessage_NoAlternative();
    internal static string get_UseAsyncMethodInAsyncContextDescription();
    internal static string get_DoNotDisableTokenValidationChecksTitle();
    internal static string get_DoNotDisableTokenValidationChecksDescription();
    internal static string get_DoNotDisableTokenValidationChecksMessage();
    internal static string get_DoNotAlwaysSkipTokenValidationInDelegatesTitle();
    internal static string get_DoNotAlwaysSkipTokenValidationInDelegatesDescription();
    internal static string get_DoNotAlwaysSkipTokenValidationInDelegatesMessage();
    internal static string get_DerivesFromPreviewClassMessage();
    internal static string get_DetectPreviewFeaturesMessage();
    internal static string get_FieldIsPreviewTypeMessage();
    internal static string get_ImplementsPreviewInterfaceMessage();
    internal static string get_ImplementsPreviewMethodMessage();
    internal static string get_MethodReturnsPreviewTypeMessage();
    internal static string get_MethodUsesPreviewTypeAsParameterMessage();
    internal static string get_OverridesPreviewMethodMessage();
    internal static string get_UsesPreviewTypeParameterMessage();
    internal static string get_ConstantExpectedApplicationTitle();
    internal static string get_ConstantExpectedApplicationDescription();
    internal static string get_ConstantExpectedUsageTitle();
    internal static string get_ConstantExpectedUsageDescription();
    internal static string get_ConstantExpectedNotSupportedMessage();
    internal static string get_ConstantExpectedIncompatibleConstantTypeMessage();
    internal static string get_ConstantExpectedInvalidBoundsMessage();
    internal static string get_ConstantExpectedInvertedRangeMessage();
    internal static string get_ConstantExpectedOutOfBoundsMessage();
    internal static string get_ConstantExpectedInvalidMessage();
    internal static string get_ConstantExpectedNotConstantMessage();
    internal static string get_ConstantExpectedAttributExpectedMessage();
    internal static string get_SpecifyCultureForToLowerAndToUpperTitle();
    internal static string get_SpecifyCultureForToLowerAndToUpperDescription();
    internal static string get_SpecifyCultureForToLowerAndToUpperMessage();
    internal static string get_SpecifyCurrentCulture();
    internal static string get_UseInvariantVersion();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledDescription();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledTitle();
    internal static string get_MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledDescription();
    internal static string get_MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledMessage();
    internal static string get_MethodUsesRuntimeMarshallingEvenWhenMarshallingDisabledTitle();
    internal static string get_UseDisabledMarshallingEquivalentCodeFix();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageAutoLayoutTypes();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageByRefParameters();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageHResultSwapping();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageLCIDConversionAttribute();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageManagedParameterOrReturnTypes();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageSetLastError();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageVarargPInvokes();
    internal static string get_SealInternalTypesDescription();
    internal static string get_SealInternalTypesMessage();
    internal static string get_SealInternalTypesTitle();
    internal static string get_SealInternalTypesCodeFixTitle();
    internal static string get_FeatureUnsupportedWhenRuntimeMarshallingDisabledMessageDelegateUsage();
    internal static string get_PreferDictionaryTryGetValueCodeFixTitle();
    internal static string get_PreferDictionaryTryGetValueTitle();
    internal static string get_PreferDictionaryTryGetValueMessage();
    internal static string get_PreferDictionaryTryGetValueDescription();
    internal static string get_SpecifyIFormatProviderMessageIFormatProviderOptional();
    internal static string get_PlatformCompatibilityObsoletedCsAllPlatformMessage();
    internal static string get_PlatformCompatibilityObsoletedCsReachableMessage();
    internal static string get_ParenthesisWithPlaceHolder();
    internal static string get_ImplementGenericMathInterfacesCorrectlyDescription();
    internal static string get_ImplementGenericMathInterfacesCorrectlyMessage();
    internal static string get_ImplementGenericMathInterfacesCorrectlyTitle();
    internal static string get_UseSpanClearInsteadOfFillCodeFixTitle();
    internal static string get_UseSpanClearInsteadOfFillDescription();
    internal static string get_UseSpanClearInsteadOfFillMessage();
    internal static string get_UseSpanClearInsteadOfFillTitle();
    internal static string get_UseSearchValuesTitle();
    internal static string get_UseSearchValuesMessage();
    internal static string get_UseSearchValuesDescription();
    internal static string get_UseSearchValuesCodeFixTitle();
    internal static string get_PreventNumericIntPtrUIntPtrBehavioralChangesDescription();
    internal static string get_PreventNumericIntPtrUIntPtrBehavioralChangesConversionNotThrowMessage();
    internal static string get_PreventNumericIntPtrUIntPtrBehavioralChangesOperatorThrowsMessage();
    internal static string get_PreventNumericIntPtrUIntPtrBehavioralChangesTitle();
    internal static string get_PreventNumericIntPtrUIntPtrBehavioralChangesConversionThrowsMessage();
    internal static string get_UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFixTitle();
    internal static string get_UseStartsWithInsteadOfIndexOfComparisonWithZeroDescription();
    internal static string get_UseStartsWithInsteadOfIndexOfComparisonWithZeroMessage();
    internal static string get_UseStartsWithInsteadOfIndexOfComparisonWithZeroTitle();
    internal static string get_UseArgumentNullExceptionThrowHelperTitle();
    internal static string get_UseArgumentExceptionThrowHelperTitle();
    internal static string get_UseArgumentOutOfRangeExceptionThrowHelperTitle();
    internal static string get_UseObjectDisposedExceptionThrowHelperTitle();
    internal static string get_UseThrowHelperMessage();
    internal static string get_UseThrowHelperDescription();
    internal static string get_UseThrowHelperFix();
    internal static string get_UseConcreteTypeDescription();
    internal static string get_UseConcreteTypeForFieldMessage();
    internal static string get_UseConcreteTypeTitle();
    internal static string get_UseConcreteTypeForLocalMessage();
    internal static string get_UseConcreteTypeForMethodReturnMessage();
    internal static string get_UseConcreteTypeForPropertyMessage();
    internal static string get_UseConcreteTypeForParameterMessage();
    internal static string get_PreferLengthOverAnyCodeFixTitle();
    internal static string get_PreferLengthOverAnyMessage();
    internal static string get_PreferCountOverAnyCodeFixTitle();
    internal static string get_PreferLengthCountIsEmptyOverAnyTitle();
    internal static string get_PreferCountOverAnyMessage();
    internal static string get_PreferLengthCountIsEmptyOverAnyDescription();
    internal static string get_PreferIsEmptyOverAnyCodeFixTitle();
    internal static string get_PreferIsEmptyOverAnyMessage();
    internal static string get_RecommendCaseInsensitiveStringComparerStringComparisonCodeFixTitle();
    internal static string get_RecommendCaseInsensitiveStringComparerDescription();
    internal static string get_RecommendCaseInsensitiveStringComparerMessage();
    internal static string get_RecommendCaseInsensitiveStringEqualsCodeFixTitle();
    internal static string get_RecommendCaseInsensitiveStringEqualsDescription();
    internal static string get_RecommendCaseInsensitiveStringEqualsMessage();
    internal static string get_RecommendCaseInsensitiveStringComparisonTitle();
    internal static string get_RecommendCaseInsensitiveStringComparisonDescription();
    internal static string get_RecommendCaseInsensitiveStringComparisonMessage();
    internal static string get_PreferDictionaryTryAddValueCodeFixTitle();
    internal static string get_PreferDictionaryTryAddTitle();
    internal static string get_PreferDictionaryTryAddMessage();
    internal static string get_PreferDictionaryTryAddDescription();
    internal static string get_UseCompositeFormatTitle();
    internal static string get_UseCompositeFormatMessage();
    internal static string get_UseCompositeFormatDescription();
    internal static string get_UseStringMethodCharOverloadWithSingleCharactersDescription();
    internal static string get_UseStringMethodCharOverloadWithSingleCharactersMessage();
    internal static string get_UseStringMethodCharOverloadWithSingleCharactersTitle();
    internal static string get_AvoidSingleUseOfLocalJsonSerializerOptionsMessage();
    internal static string get_AvoidSingleUseOfLocalJsonSerializerOptionsDescription();
    internal static string get_AvoidSingleUseOfLocalJsonSerializerOptionsTitle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.AvoidSingleUseOfLocalJsonSerializerOptions : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor s_Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidSingleUseOfLocalJsonSerializerOptions();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    private static bool IsCtorUsedAsArgumentForJsonSerializer(IObjectCreationOperation objCreationOperation, INamedTypeSymbol jsonSerializerSymbol);
    private static bool IsArgumentForJsonSerializer(IArgumentOperation argumentOperation, INamedTypeSymbol jsonSerializerSymbol);
    private static bool IsLocalUsedAsArgumentForJsonSerializerOnly(IObjectCreationOperation objCreation, INamedTypeSymbol jsonSerializerSymbol, INamedTypeSymbol jsonSerializerOptionsSymbol);
    [NullableContextAttribute("2")]
private static IOperation WalkUpConditional(IOperation operation);
    private static bool IsLocalReferenceInsideChildLoop(ILocalReferenceOperation localRef, IBlockOperation symbolBlock);
    private static bool IsArgumentOfJsonSerializer(IOperation operation, INamedTypeSymbol jsonSerializerSymbol, Boolean& isArgumentOfInvocation);
    private static bool IsFieldOrPropertyAssignment(IOperation operation);
    private static bool IsTupleForDeconstructionTargetingFieldOrProperty(IOperation operation);
    private static bool IsClosureOnLambdaOrLocalFunction(IOperation operation, IBlockOperation localBlock);
    private static bool IsLocalAssignment(IOperation operation, INamedTypeSymbol jsonSerializerOptionsSymbol, List`1& localSymbols);
    private static ILocalSymbol GetLocalSymbolFromDeclaration(IVariableDeclarationOperation declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.ConstantExpectedAnalyzer : DiagnosticAnalyzer {
    protected static string ConstantExpectedAttribute;
    protected static string ConstantExpected;
    protected static string ConstantExpectedMin;
    protected static string ConstantExpectedMax;
    private static LocalizableString s_localizableApplicationTitle;
    private static LocalizableString s_localizableApplicationDescription;
    private static LocalizableString s_localizableUsageTitle;
    private static LocalizableString s_localizableUsageDescription;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected DiagnosticHelper Helper { get; }
    private static ConstantExpectedAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual DiagnosticHelper get_Helper();
    public virtual void Initialize(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    private static void OnMethodSymbol(SymbolAnalysisContext context, ConstantExpectedContext constantExpectedContext);
    private static void OnInvocation(OperationAnalysisContext context, ConstantExpectedContext constantExpectedContext);
    protected abstract virtual void RegisterAttributeSyntax(CompilationStartAnalysisContext context, ConstantExpectedContext constantExpectedContext);
    protected void OnParameterWithConstantExpectedAttribute(IParameterSymbol parameter, ConstantExpectedContext constantExpectedContext, Action`1<Diagnostic> reportAction);
    private static bool TryConvertSignedInteger(object constant, Int64& integer);
    private static bool CatchExceptionDuringConvert(Exception ex);
    private static bool TryConvertUnsignedInteger(object constant, UInt64& integer);
    private static bool TryTransformInt64(object constant, Int64& value, Boolean& isInvalid);
    private static bool TryTransformUInt64(object constant, UInt64& value, Boolean& isInvalid);
    private static bool TryTransformChar(object constant, Char& value, Boolean& isInvalid);
    private static bool TryTransformBoolean(object constant, Boolean& value, Boolean& isInvalid);
    private static bool TryTransformSingle(object constant, Single& value, Boolean& isInvalid);
    private static bool TryTransformDouble(object constant, Double& value, Boolean& isInvalid);
    [NullableContextAttribute("0")]
private static bool Invalid(T& value, Boolean& isInvalid);
    [CompilerGeneratedAttribute]
internal static void <OnMethodSymbol>g__CheckParameters|17_0(ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<IParameterSymbol> baseParameters, <>c__DisplayClass17_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.DoNotGuardDictionaryRemoveByContainsKey : DiagnosticAnalyzer {
    internal static string RuleId;
    private static string Remove;
    private static string ContainsKey;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotGuardDictionaryRemoveByContainsKey();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static void <OnCompilationStart>g__AnalyzeOperation|8_1(OperationAnalysisContext context, IMethodSymbol containsKeyMethod, IMethodSymbol remove1Param, IMethodSymbol remove2Param);
    [CompilerGeneratedAttribute]
internal static bool <OnCompilationStart>g__AreInvocationsOnSameInstance|8_2(IInvocationOperation invocationOp1, IInvocationOperation invocationOp2);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <OnCompilationStart>g__TryGetDictionaryTypeAndMethods|8_3(Compilation compilation, IMethodSymbol& containsKey, IMethodSymbol& remove1Param, IMethodSymbol& remove2Param);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.DoNotGuardDictionaryRemoveByContainsKeyFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.DoNotGuardDictionaryRemoveByContainsKeyFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual bool SyntaxSupportedByFixer(SyntaxNode conditionalSyntax);
    protected abstract virtual Document ReplaceConditionWithChild(Document document, SyntaxNode root, SyntaxNode conditionalOperationNode, SyntaxNode childOperationNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.DoNotGuardSetAddOrRemoveByContains : DiagnosticAnalyzer {
    internal static string RuleId;
    private static string Contains;
    private static string Add;
    private static string Remove;
    private static SymbolDisplayFormat s_symbolDisplayFormat;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotGuardSetAddOrRemoveByContains();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    private static bool AreInvocationsOnSameInstance(IInvocationOperation invocation1, IInvocationOperation invocation2);
    private static bool AreInvocationArgumentsEqual(IInvocationOperation invocation1, IInvocationOperation invocation2);
    private static bool IsArgumentValueEqual(IOperation targetArg, IOperation valueArg);
    [NullableContextAttribute("2")]
private static bool DoesImplementInterfaceMethod(IMethodSymbol method, IMethodSymbol interfaceMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.DoNotGuardSetAddOrRemoveByContainsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.DoNotGuardSetAddOrRemoveByContainsFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual bool SyntaxSupportedByFixer(SyntaxNode conditionalSyntax, SyntaxNode childStatementSyntax);
    protected abstract virtual Document ReplaceConditionWithChild(Document document, SyntaxNode root, SyntaxNode conditionalOperationNode, SyntaxNode childOperationNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.DoNotUseCountWhenAnyCanBeUsedFixer : CodeFixProvider {
    private static string AsyncMethodName;
    private static string SyncMethodName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.DoNotUseCountWhenAnyCanBeUsedFixer/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual bool TryGetFixer(SyntaxNode node, string operation, bool isAsync, SyntaxNode& expression, IEnumerable`1& arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.PreferDictionaryTryMethodsOverContainsKeyGuardAnalyzer : DiagnosticAnalyzer {
    internal static string PreferTryGetValueRuleId;
    internal static string PreferTryAddRuleId;
    internal static string Add;
    private static string TryAdd;
    private static string ContainsKey;
    private static string Remove;
    private static string Clear;
    internal static DiagnosticDescriptor PreferTryGetValueDiagnostic;
    private static DiagnosticDescriptor PreferTryAddDiagnostic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferDictionaryTryMethodsOverContainsKeyGuardAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    private static void OnInvocationOperation(INamedTypeSymbol iDictionaryType, IMethodSymbol containsKeySymbol, IMethodSymbol addSymbol, OperationAnalysisContext context);
    private static bool AddArgumentIsDeclaredInBlock(IInvocationOperation invocation);
    [NullableContextAttribute("2")]
private static bool TryGetDictionaryTypeAndMembers(Compilation compilation, INamedTypeSymbol& iDictionaryType, IMethodSymbol& containsKeySymbol, IMethodSymbol& addSymbol);
    private static bool IsContainsKeyMethod(IMethodSymbol suspectedContainsKeyMethod, IMethodSymbol containsKeyMethod);
    private static bool IsDictionaryType(ITypeSymbol suspectedDictionaryType, ISymbol iDictionaryType);
    private static bool DoesSignatureMatch(IMethodSymbol suspected, IMethodSymbol comparator);
    private static bool GetParentConditionalOperation(IOperation operation, DictionaryUsageContext& usageContext, SearchContext searchContext, IConditionalOperation& conditionalOperation, Boolean& guardsTruePath);
    private static bool FindUsages(IOperation operation, DictionaryUsageContext& usageContext, SearchContext searchContext);
    private static bool HasReturnOrSetsKeyInTruePath(IConditionalOperation conditionalOperation, DictionaryUsageContext& usageContext);
    private static void FindUsageInOperationsAfterConditionBlock(IOperation sourceOperation, DictionaryUsageContext& context, SearchContext searchContext);
    private static bool IsSameConstantOrReferenceOperation(IOperation sourceReference, IOperation targetReference);
    private static bool IsSameReferenceOperation(IOperation sourceReference, IOperation targetReference);
    private static bool IsAnySameReferenceOperation(IOperation source, ImmutableArray`1<IOperation> targets);
    [CompilerGeneratedAttribute]
internal static void <OnInvocationOperation>g__ReportGuardedDictionaryPattern|15_0(SearchContext searchContext, DiagnosticDescriptor diagnosticDescriptor, <>c__DisplayClass15_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.PreferDictionaryTryMethodsOverContainsKeyGuardFixer : CodeFixProvider {
    protected static string Value;
    protected static string TryGetValue;
    protected static string TryAdd;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected static string PreferDictionaryTryGetValueCodeFixTitle { get; }
    protected static string PreferDictionaryTryAddValueCodeFixTitle { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected static string get_PreferDictionaryTryGetValueCodeFixTitle();
    protected static string get_PreferDictionaryTryAddValueCodeFixTitle();
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.PreferHashDataOverComputeHashAnalyzer : DiagnosticAnalyzer {
    internal static string CA1850;
    internal static string TargetHashTypeDiagnosticPropertyKey;
    internal static string DeleteHashCreationPropertyKey;
    internal static string ComputeTypePropertyKey;
    internal static string HashCreationIndexPropertyKey;
    internal static string HashDataMethodName;
    internal static string TryHashDataMethodName;
    private static string ComputeHashMethodName;
    private static string DisposeMethodName;
    private static string TryComputeHashMethodName;
    private static string CreateMethodName;
    internal static DiagnosticDescriptor StringRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferHashDataOverComputeHashAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    [NullableContextAttribute("2")]
private static bool TryGetVariableInitializerOperation(IOperation symbol, IVariableInitializerOperation& variableInitializerOperation);
    private static Diagnostic CreateDiagnostics(IInvocationOperation computeHashMethod, INamedTypeSymbol staticHashMethodType, ComputeType computeType);
    private static Diagnostic CreateDiagnostics(IInvocationOperation computeHashMethod, INamedTypeSymbol staticHashMethodType, ImmutableArray`1<Location> fixerLocations, ComputeType computeType, bool isSingleLocalRef, int hashCreationLocationIndex);
    private static ImmutableArray`1<Location> GetFixerLocations(IVariableInitializerOperation variableInitializerOperation, ImmutableArray`1<IInvocationOperation> disposeArray, Int32& hashCreationLocationIndex);
    private static ImmutableArray`1<IInvocationOperation> GetValueOrEmpty(PooledDictionary`2<ILocalSymbol, ImmutableArray`1<IInvocationOperation>> dictionary, ILocalSymbol key);
    [CompilerGeneratedAttribute]
internal static void <OnCompilationStart>g__CaptureHashCreateInvocationOperation|16_1(DataCollector dataCollector, IInvocationOperation hashCreateInvocation);
    [CompilerGeneratedAttribute]
internal static void <OnCompilationStart>g__CaptureVariableDeclaratorOperation|16_2(DataCollector dataCollector, ITypeSymbol createdType, IVariableInitializerOperation variableInitializerOperation);
    [CompilerGeneratedAttribute]
internal static void <OnCompilationStart>g__CaptureOrReportComputeHashInvocationOperation|16_3(OperationAnalysisContext context, MethodHelper methodHelper, DataCollector dataCollector, IInvocationOperation computeHashInvocation, ComputeType computeType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <OnCompilationStart>g__ReportChainedComputeHashInvocationOperation|16_8(ITypeSymbol originalHashType, <>c__DisplayClass16_2& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.PreferHashDataOverComputeHashFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected PreferHashDataOverComputeHashFixHelper Helper { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public abstract virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual PreferHashDataOverComputeHashFixHelper get_Helper();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.PreferHashDataOverComputeHashFixer/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.PreferIsEmptyOverCountFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.PreferIsEmptyOverCountFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual SyntaxNode GetObjectExpressionFromOperation(SyntaxNode node, string operationKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.PreferLengthCountIsEmptyOverAnyAnalyzer : DiagnosticAnalyzer {
    private static string AnyText;
    internal static string IsEmptyText;
    internal static string LengthText;
    internal static string CountText;
    internal static string RuleId;
    internal static string DiagnosticPropertyKey;
    internal static DiagnosticDescriptor IsEmptyDescriptor;
    internal static DiagnosticDescriptor LengthDescriptor;
    internal static DiagnosticDescriptor CountDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferLengthCountIsEmptyOverAnyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnInvocationAnalysis(OperationAnalysisContext context, INamedTypeSymbol iEnumerable, INamedTypeSymbol iEnumerableOfT, IMethodSymbol anyMethod);
    private static bool HasEligibleIsEmptyProperty(ITypeSymbol typeSymbol);
    private static bool HasEligibleLengthProperty(ITypeSymbol typeSymbol);
    private static bool HasEligibleCountProperty(ITypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.PreferLengthCountIsEmptyOverAnyFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.PreferLengthCountIsEmptyOverAnyFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual SyntaxNode ReplaceAnyWithIsEmpty(SyntaxNode root, SyntaxNode node);
    protected abstract virtual SyntaxNode ReplaceAnyWithLength(SyntaxNode root, SyntaxNode node);
    protected abstract virtual SyntaxNode ReplaceAnyWithCount(SyntaxNode root, SyntaxNode node);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.RecommendCaseInsensitiveStringComparisonAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string StringComparisonInvariantCultureIgnoreCaseName;
    internal static string StringComparisonCurrentCultureIgnoreCaseName;
    internal static string StringToLowerMethodName;
    internal static string StringToUpperMethodName;
    internal static string StringToLowerInvariantMethodName;
    internal static string StringToUpperInvariantMethodName;
    internal static string StringContainsMethodName;
    internal static string StringIndexOfMethodName;
    internal static string StringStartsWithMethodName;
    internal static string StringCompareToMethodName;
    internal static string StringComparerCompareMethodName;
    internal static string StringEqualsMethodName;
    internal static string StringParameterName;
    internal static string StringComparisonParameterName;
    internal static string LeftOffendingMethodName;
    internal static string RightOffendingMethodName;
    internal static DiagnosticDescriptor RecommendCaseInsensitiveStringComparisonRule;
    internal static DiagnosticDescriptor RecommendCaseInsensitiveStringComparerRule;
    internal static DiagnosticDescriptor RecommendCaseInsensitiveStringEqualsRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static RecommendCaseInsensitiveStringComparisonAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeInvocation(OperationAnalysisContext context, IInvocationOperation invocation, INamedTypeSymbol stringType, IMethodSymbol containsStringMethod, IMethodSymbol startsWithStringMethod, IMethodSymbol compareToStringMethod, IMethodSymbol indexOfStringMethod, IMethodSymbol indexOfStringInt32Method, IMethodSymbol indexOfStringInt32Int32Method);
    private static void AnalyzeBinaryOperation(OperationAnalysisContext context, IBinaryOperation binaryOperation, INamedTypeSymbol stringType);
    [NullableContextAttribute("2")]
private static bool TryGetInvocationWithoutParentheses(IOperation operation, IInvocationOperation& diagnosableInvocation);
    private static bool IsOffendingMethod(IInvocationOperation invocation, ITypeSymbol stringType, String& offendingMethodName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.RecommendCaseInsensitiveStringComparisonFixer : CodeFixProvider {
    protected static string StringTypeName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual IEnumerable`1<SyntaxNode> GetNewArgumentsForInvocation(SyntaxGenerator generator, string caseChangingApproachValue, IInvocationOperation mainInvocationOperation, INamedTypeSymbol stringComparisonType, string leftOffendingMethod, string rightOffendingMethod, SyntaxNode& mainInvocationInstance);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetNewArgumentsForBinary(SyntaxGenerator generator, SyntaxNode rightNode, SyntaxNode typeMemberAccess);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.RecommendCaseInsensitiveStringComparisonFixer/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private Task`1<Document> FixInvocationAsync(SyntaxGenerator generator, Document doc, SyntaxNode root, IInvocationOperation mainInvocation, INamedTypeSymbol stringComparisonType, string diagnosableMethodName, string caseChangingApproachValue, string leftOffendingMethod, string rightOffendingMethod);
    private Task`1<Document> FixBinaryAsync(SyntaxGenerator generator, Document doc, SyntaxNode root, IBinaryOperation binaryOperation, INamedTypeSymbol stringComparisonType, string caseChangingApproachValue);
    protected static SyntaxNode GetNewStringComparisonArgument(SyntaxGenerator generator, INamedTypeSymbol stringComparisonType, string caseChangingApproachValue, bool isAnyArgumentNamed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.UseAsSpanInsteadOfRangeIndexerAnalyzer : DiagnosticAnalyzer {
    internal static string StringRuleId;
    internal static string ArrayReadOnlyRuleId;
    internal static string ArrayReadWriteRuleId;
    internal static string TargetMethodName;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    internal static DiagnosticDescriptor StringRule;
    internal static DiagnosticDescriptor ArrayReadOnlyRule;
    internal static DiagnosticDescriptor ArrayReadWriteRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseAsSpanInsteadOfRangeIndexerAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseAsSpanInsteadOfRangeIndexerFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UseAsSpanInsteadOfRangeIndexerFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual bool TrySplitExpression(SyntaxNode node, SyntaxNode& toReplace, SyntaxNode& target, IEnumerable`1& arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.UseCompositeFormatAnalyzer : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor UseCompositeFormatRule;
    internal static string StringIndexPropertyName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseCompositeFormatAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static Action`1<OperationAnalysisContext> CreateAnalysisAction(bool isStatic, ITypeSymbol containingType, string methodName, ITypeSymbol formatProviderType);
    private static bool IsStringLiteralOrStaticReference(IOperation operation, bool allowLiteral);
    private static bool HasAllCompositeFormatMethods(IMethodSymbol[] methods);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.UseConcreteTypeAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor UseConcreteTypeForMethodReturn;
    internal static DiagnosticDescriptor UseConcreteTypeForProperty;
    internal static DiagnosticDescriptor UseConcreteTypeForParameter;
    internal static DiagnosticDescriptor UseConcreteTypeForLocal;
    internal static DiagnosticDescriptor UseConcreteTypeForField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseConcreteTypeAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void Report(Action`1<Diagnostic> reportDiag, Collector coll, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static void <Report>g__Evaluate|10_0(ISymbol affectedSymbol, ITypeSymbol fromType, PooledConcurrentSet`1<ITypeSymbol> typesAssigned, PooledConcurrentSet`1<IMethodSymbol> targets, DiagnosticDescriptor desc, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <Report>g__HasEquivalentOrGreaterVisibilityToSymbol|10_1(Compilation compilation, ITypeSymbol type, ISymbol affectedSymbol);
    [CompilerGeneratedAttribute]
internal static bool <Report>g__CanUpgrade|10_2(IMethodSymbol methodSym, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static string <Report>g__GetTypeName|10_3(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.UseCountProperlyAnalyzer : DiagnosticAnalyzer {
    internal static string CA1827;
    internal static string CA1828;
    internal static string CA1829;
    internal static string CA1836;
    private static string Length;
    private static string Count;
    private static string LongCount;
    private static string CountAsync;
    private static string LongCountAsync;
    internal static string UseRightSideExpressionKey;
    internal static string ShouldNegateKey;
    internal static string IsEmpty;
    internal static string OperationEqualsInstance;
    internal static string OperationEqualsArgument;
    internal static string OperationBinaryLeft;
    internal static string OperationBinaryRight;
    internal static string OperationKey;
    internal static string IsAsyncKey;
    internal static string PropertyNameKey;
    internal static DiagnosticDescriptor s_rule_CA1827;
    internal static DiagnosticDescriptor s_rule_CA1828;
    internal static DiagnosticDescriptor s_rule_CA1829;
    internal static DiagnosticDescriptor s_rule_CA1836;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseCountProperlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    private static void AnalyzeInvocationOperation(OperationAnalysisContext context, INamedTypeSymbol linqExpressionType, ImmutableHashSet`1<IMethodSymbol> syncMethods, ImmutableHashSet`1<IMethodSymbol> asyncMethods, ImmutableHashSet`1<ITypeSymbol> allowedTypesForCA1836);
    private static void AnalyzePropertyReference(OperationAnalysisContext context, INamedTypeSymbol linqExpressionType, ImmutableHashSet`1<ITypeSymbol> allowedTypesForCA1836);
    [NullableContextAttribute("2")]
private static bool ShouldReplaceParent(IOperation& parentOperation, String& operationKey, Boolean& shouldNegateIsEmpty);
    private static bool AnalyzeParentBinaryOperation(IBinaryOperation parent, Boolean& useRightSide, Boolean& shouldNegate);
    private static bool AnalyzeParentInvocationOperation(IInvocationOperation parent, bool isInstance);
    private static void AnalyzeCountInvocationOperation(OperationAnalysisContext context, IInvocationOperation invocationOperation);
    private static void ReportCA1827(OperationAnalysisContext context, bool shouldNegate, string operationKey, string methodName, IOperation operation);
    private static void ReportCA1828(OperationAnalysisContext context, bool shouldNegate, string operationKey, string methodName, IOperation operation);
    private static void ReportCA1829(OperationAnalysisContext context, string propertyName, IOperation operation);
    private static void ReportCA1836(OperationAnalysisContext context, string operationKey, bool shouldNegate, IOperation operation);
    private static void DetermineReportForInvocationAnalysis(OperationAnalysisContext context, IInvocationOperation invocationOperation, IOperation parent, bool shouldReplaceParent, bool isAsync, bool shouldNegateIsEmpty, bool hasPredicate, bool isWithinExpressionTree, string methodName, string operationKey, ImmutableHashSet`1<ITypeSymbol> allowedTypesForCA1836);
    private static void DetermineReportForPropertyReference(OperationAnalysisContext context, IOperation operation, IOperation parent, string operationKey, bool shouldNegateIsEmpty, ImmutableHashSet`1<ITypeSymbol> allowedTypesForCA1836);
    private static bool IsIntEqualsMethod(IInvocationOperation invocationOperation);
    private static bool IsLeftCountComparison(IBinaryOperation binaryOperation, Boolean& shouldNegate);
    private static bool IsRightCountComparison(IBinaryOperation binaryOperation, Boolean& shouldNegate);
    private static bool TypeContainsVisibleProperty(OperationAnalysisContext context, ITypeSymbol type, string propertyName, SpecialType propertyType, ISymbol& propertySymbol);
    private static bool TypeContainsVisibleProperty(OperationAnalysisContext context, ITypeSymbol type, string propertyName, SpecialType lowerBound, SpecialType upperBound, ISymbol& propertySymbol);
    [NullableContextAttribute("2")]
private static bool TryGetZeroOrOneConstant(IOperation operation, Int32& constant);
    private static bool IsPropertyGetOfIsEmptyUsingThisInstance(OperationAnalysisContext context, IOperation operation, ISymbol isEmptyPropertySymbol);
    private static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    [CompilerGeneratedAttribute]
internal static void <OnCompilationStart>g__AddIfNotNull|27_10(Builder<IMethodSymbol> set, IEnumerable`1<IMethodSymbol> others);
    [CompilerGeneratedAttribute]
internal static bool <TypeContainsVisibleProperty>g__TypeContainsMember|44_0(OperationAnalysisContext context, ITypeSymbol type, string propertyName, SpecialType lowerBound, SpecialType upperBound, Boolean& isPropertyValidAndVisible, ISymbol& propertySymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UsePropertyInsteadOfCountMethodWhenAvailableFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UsePropertyInsteadOfCountMethodWhenAvailableFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("2")]
protected abstract virtual bool TryGetExpression(SyntaxNode invocationNode, SyntaxNode& memberAccessNode, SyntaxNode& nameNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseSearchValuesAnalyzer : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static int MinLengthWorthReplacing;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseSearchValuesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual bool IsConstantByteOrCharArrayVariableDeclaratorSyntax(SemanticModel semanticModel, SyntaxNode syntax, Int32& length);
    protected abstract virtual bool IsConstantByteOrCharReadOnlySpanPropertyDeclarationSyntax(SemanticModel semanticModel, SyntaxNode syntax, Int32& length);
    protected abstract virtual bool IsConstantByteOrCharArrayCreationSyntax(SemanticModel semanticModel, SyntaxNode syntax, Int32& length);
    protected abstract virtual bool ArrayFieldUsesAreLikelyReadOnly(SyntaxNode syntax);
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, ImmutableHashSet`1<IMethodSymbol> indexOfAnyMethodsToDetect, INamedTypeSymbol readOnlySpanType);
    private static ImmutableHashSet`1<IMethodSymbol> GetIndexOfAnyMethods(Compilation compilation);
    private bool AreConstantValuesWorthReplacingForStringIndexOfAny(IOperation argument);
    private bool AreConstantValuesWorthReplacing(IOperation argument, INamedTypeSymbol readOnlySpanType);
    private bool IsArrayCreationOrFieldReferenceOrToCharArrayInvocation(IOperation argument, Int32& length);
    [NullableContextAttribute("2")]
private static bool IsByteOrCharSZArray(ITypeSymbol type);
    private static bool IsByteOrCharReadOnlySpan(ISymbol symbol, INamedTypeSymbol readOnlySpanType);
    internal static bool IsConstantStringToCharArrayInvocation(IInvocationOperation invocation, String& value);
    private bool IsConstantByteOrCharSZArrayFieldReference(IFieldReferenceOperation fieldReference, Int32& length);
    private bool IsConstantByteOrCharSZArrayCreation(IArrayCreationOperation arrayCreation, Int32& length);
    private static bool IsConstantStringLiteralOrReference(IOperation operation, String& value);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseSearchValuesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UseSearchValuesFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual ValueTask`1<ValueTuple`3<SyntaxNode, INamedTypeSymbol, bool>> GetTypeSymbolAsync(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode ReplaceSearchValuesFieldName(SyntaxNode node);
    protected abstract virtual SyntaxNode GetDeclaratorInitializer(SyntaxNode syntax);
    protected abstract virtual SyntaxNode TryReplaceArrayCreationWithInlineLiteralExpression(IOperation operation);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UseSearchValuesFixer/<ConvertToSearchValuesAsync>d__9")]
private Task`1<Document> ConvertToSearchValuesAsync(Document document, SyntaxNode argumentNode, CancellationToken cancellationToken);
    private static void ImportSystemNamespaceIfNeeded(DocumentEditor editor, INamedTypeSymbol memoryExtensions, SyntaxNode node);
    private static IArgumentOperation GetArgumentOperationAncestorOrSelf(IOperation operation);
    [IteratorStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UseSearchValuesFixer/<GetAllMemberNamesInScope>d__12")]
private static IEnumerable`1<string> GetAllMemberNamesInScope(ITypeSymbol symbol);
    private static string GetSearchValuesFieldName(IOperation argument, bool isByte, bool removedOriginalMember);
    private SyntaxNode CreateSearchValuesCreateArgument(SyntaxNode originalSyntax, IOperation argument, SyntaxNode& memberToRemove, CancellationToken cancellationToken);
    private SyntaxNode CreateSearchValuesCreateArgumentCore(SyntaxNode originalSyntax, IOperation argument, SyntaxNode& memberToRemove, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetSearchValuesFieldName>g__TryGetNameFromLocalOrFieldReference|13_0(IOperation argument, String& name, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static string <GetSearchValuesFieldName>g__CreateFromExistingName|13_1(string name, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetSearchValuesFieldName>g__IsAsciiLetterUpper|13_2(char c);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private bool <CreateSearchValuesCreateArgumentCore>g__TryGetArgumentFromStringToCharArray|15_0(IOperation operation, SyntaxNode& createArgument, SyntaxNode& memberToRemove, <>c__DisplayClass15_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private bool <CreateSearchValuesCreateArgumentCore>g__TryGetArgumentFromLocalOrFieldReference|15_1(IOperation operation, SyntaxNode& createArgument, SyntaxNode& memberToRemove, <>c__DisplayClass15_0& );
    [CompilerGeneratedAttribute]
private SyntaxNode <CreateSearchValuesCreateArgumentCore>g__GetDeclarator|15_2(ISymbol symbol, <>c__DisplayClass15_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseSpanClearInsteadOfFillAnalyzer : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static string FillMethod;
    internal static string ClearMethod;
    internal static DiagnosticDescriptor s_Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseSpanClearInsteadOfFillAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    private static bool IsDefaultValue(IArgumentOperation argumentOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseSpanClearInsteadOfFillFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UseSpanClearInsteadOfFillFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual SyntaxNode GetInvocationTarget(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.UseStartsWithInsteadOfIndexOfComparisonWithZero : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string ShouldNegateKey;
    internal static string CompilationHasStartsWithCharOverloadKey;
    internal static string ExistingOverloadKey;
    internal static string OverloadString;
    internal static string OverloadString_StringComparison;
    internal static string OverloadChar;
    internal static string OverloadChar_StringComparison;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseStartsWithInsteadOfIndexOfComparisonWithZero();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsIndexOfComparedWithZero(IOperation left, IOperation right, ImmutableArray`1<ValueTuple`2<IMethodSymbol, string>> indexOfMethods, ImmutableArray`1& additionalLocations, ImmutableDictionary`2& properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFix : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UseStartsWithInsteadOfIndexOfComparisonWithZeroCodeFix/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual SyntaxNode HandleCharStringComparisonOverload(SyntaxGenerator generator, SyntaxNode instance, SyntaxNode[] arguments, bool shouldNegate);
    protected abstract virtual SyntaxNode AppendElasticMarker(SyntaxNode replacement);
    protected static SyntaxNode CreateStartsWithInvocationFromArguments(SyntaxGenerator generator, SyntaxNode instance, SyntaxNode[] arguments, bool shouldNegate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Performance.UseStringContainsCharOverloadWithSingleCharactersAnalyzer : DiagnosticAnalyzer {
    internal static string CA1847;
    internal static DiagnosticDescriptor s_rule_CA1847;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseStringContainsCharOverloadWithSingleCharactersAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void CheckIfRuleIsApplicableAndRegister(CompilationStartAnalysisContext context);
    private void AnalyseContainsUsage(OperationAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyseContainsUsage>g__ShouldAnalyzeInvocation|7_0(IInvocationOperation invocationOperation);
    [CompilerGeneratedAttribute]
internal static bool <AnalyseContainsUsage>g__CheckForViolation|7_1(IArgumentOperation primaryArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseStringContainsCharOverloadWithSingleCharactersCodeFix : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UseStringContainsCharOverloadWithSingleCharactersCodeFix/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual bool TryGetArgumentName(SyntaxNode violatingNode, String& argumentName);
    protected abstract virtual bool TryGetLiteralValueFromNode(SyntaxNode violatingNode, Char& charLiteral);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseStringMethodCharOverloadWithSingleCharacters : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor SafeTransformationRule;
    internal static DiagnosticDescriptor NoSpecifiedComparisonRule;
    internal static DiagnosticDescriptor AnyOtherSpecifiedComparisonRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> TargetMethods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseStringMethodCharOverloadWithSingleCharacters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    protected abstract virtual SyntaxNode GetArgumentList(SyntaxNode argumentNode);
    private void CheckIfRuleIsApplicableAndRegister(CompilationStartAnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context, INamedTypeSymbol stringComparisonType, INamedTypeSymbol cultureInfoType, ISymbol stringComparisonOrdinalSymbol, ISymbol stringComparisonInvariantCultureSymbol, ISymbol cultureInfoInvariantCultureSymbol);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeOperation>g__TryMatchTargetMethod|10_0(IInvocationOperation invocationOperation, String& method, Nullable`1& comparison, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeOperation>g__TryGetChar|10_1(IInvocationOperation invocationOperation, IArgumentOperation& stringArgument, Char& c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Performance.UseStringMethodCharOverloadWithSingleCharactersFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Performance.UseStringMethodCharOverloadWithSingleCharactersFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public virtual FixAllProvider GetFixAllProvider();
    protected abstract virtual bool TryGetChar(SemanticModel model, SyntaxNode argumentListNode, Char& c);
    protected abstract virtual CodeAction CreateCodeAction(Document document, SyntaxNode argumentListNode, char sourceCharLiteral);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Resources.MarkAssembliesWithNeutralResourcesLanguageAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    protected static string GeneratedCodeAttribute;
    protected static string StronglyTypedResourceBuilder;
    private static string Designer;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MarkAssembliesWithNeutralResourcesLanguageAnalyzer();
    protected abstract virtual void RegisterAttributeAnalyzer(CompilationStartAnalysisContext context, Action onResourceFound, INamedTypeSymbol generatedCode);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    protected static bool CheckDesignerFile(SyntaxTree tree);
    protected static bool CheckResxGeneratedFile(SemanticModel model, SyntaxNode attribute, SyntaxNode argument, INamedTypeSymbol generatedCode, CancellationToken cancellationToken);
    private static bool TryCheckNeutralResourcesLanguageAttribute(Compilation compilation, INamedTypeSymbol attribute, AttributeData& attributeData);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.AttributeStringLiteralsShouldParseCorrectlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor DefaultRule;
    internal static DiagnosticDescriptor EmptyRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static List`1<ValueValidator> s_tokensToValueValidator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AttributeStringLiteralsShouldParseCorrectlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static bool GuidValueValidator(string value);
    private static bool UrlValueValidator(string value);
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbols(Action`1<Diagnostic> reportDiagnostic, IEnumerable`1<ISymbol> symbols, CancellationToken cancellationToken);
    private static void AnalyzeSymbol(Action`1<Diagnostic> reportDiagnostic, ISymbol symbol, CancellationToken cancellationToken);
    private static void Analyze(Action`1<Diagnostic> reportDiagnostic, AttributeData attributeData, ISymbol symbol, CancellationToken cancellationToken);
    private static ValueValidator GetValueValidator(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.AvoidConstArraysAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidConstArraysAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsInitializingStaticOrReadOnlyFieldOrProperty(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.AvoidConstArraysFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_collectionMemberEndings;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static AvoidConstArraysFixer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.AvoidConstArraysFixer/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.AvoidConstArraysFixer/<ExtractConstArrayAsync>d__6")]
private static Task`1<Document> ExtractConstArrayAsync(Document document, SyntaxNode root, SyntaxNode node, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    private static IArrayCreationOperation GetArrayCreationOperation(SyntaxNode node, SemanticModel model, CancellationToken cancellationToken, Boolean& isInvoked);
    private static string GetExtractedMemberName(IEnumerable`1<string> memberNames, string parameterName);
    private static string GetMemberNameFromType(IArrayCreationOperation arrayCreationOperation);
    [NullableContextAttribute("2")]
private static Accessibility GetAccessibility(ISymbol methodSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.AvoidUnsealedAttributesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidUnsealedAttributesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(INamedTypeSymbol namedType, INamedTypeSymbol attributeType, Action`1<Diagnostic> addDiagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.AvoidUnsealedAttributesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.AvoidUnsealedAttributesFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> MakeSealedAsync(DocumentEditor editor, SyntaxNode declaration);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.AvoidZeroLengthArrayAllocationsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string ArrayEmptyMethodName;
    private static SymbolDisplayFormat ReportFormat;
    internal static DiagnosticDescriptor UseArrayEmptyDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static AvoidZeroLengthArrayAllocationsAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private void AnalyzeOperation(OperationAnalysisContext context, IMethodSymbol arrayEmptyMethodSymbol, INamedTypeSymbol linqExpressionType);
    private static void AnalyzeOperation(OperationAnalysisContext context, IMethodSymbol arrayEmptyMethodSymbol, INamedTypeSymbol linqExpressionType, Func`2<SyntaxNode, bool> isAttributeSyntax);
    private static bool IsCompilerGeneratedParamsArray(IArrayCreationOperation arrayCreationExpression, OperationAnalysisContext context);
    [NullableContextAttribute("2")]
private static bool AreEquivalentZeroLengthArrayCreations(IArrayCreationOperation first, IArrayCreationOperation second);
    protected abstract virtual bool IsAttributeSyntax(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.AvoidZeroLengthArrayAllocationsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.AvoidZeroLengthArrayAllocationsFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.AvoidZeroLengthArrayAllocationsFixer/<ConvertToArrayEmptyAsync>d__5")]
private static Task`1<Document> ConvertToArrayEmptyAsync(Document document, SyntaxNode nodeToFix, CancellationToken cancellationToken);
    private static ITypeSymbol GetArrayElementType(SyntaxNode arrayCreationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GenerateArrayEmptyInvocation(SyntaxGenerator generator, INamedTypeSymbol arrayTypeSymbol, ITypeSymbol elementType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.BufferBlockCopyLengthAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static BufferBlockCopyLengthAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__CheckArgumentArrayType|5_3(IArgumentOperation targetArgument, IPropertyReferenceOperation lengthPropertyArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.CallGCSuppressFinalizeCorrectlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor NotCalledWithFinalizerRule;
    internal static DiagnosticDescriptor NotCalledRule;
    internal static DiagnosticDescriptor NotPassedThisRule;
    internal static DiagnosticDescriptor OutsideDisposeRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CallGCSuppressFinalizeCorrectlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.CallGCSuppressFinalizeCorrectlyFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.DetectPreviewFeatureAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string DefaultURL;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKind> s_symbols;
    internal static DiagnosticDescriptor GeneralPreviewFeatureAttributeRule;
    internal static DiagnosticDescriptor GeneralPreviewFeatureAttributeRuleWithCustomMessage;
    internal static DiagnosticDescriptor ImplementsPreviewInterfaceRule;
    internal static DiagnosticDescriptor ImplementsPreviewInterfaceRuleWithCustomMessage;
    internal static DiagnosticDescriptor ImplementsPreviewMethodRule;
    internal static DiagnosticDescriptor ImplementsPreviewMethodRuleWithCustomMessage;
    internal static DiagnosticDescriptor OverridesPreviewMethodRule;
    internal static DiagnosticDescriptor OverridesPreviewMethodRuleWithCustomMessage;
    internal static DiagnosticDescriptor DerivesFromPreviewClassRule;
    internal static DiagnosticDescriptor DerivesFromPreviewClassRuleWithCustomMessage;
    internal static DiagnosticDescriptor UsesPreviewTypeParameterRule;
    internal static DiagnosticDescriptor UsesPreviewTypeParameterRuleWithCustomMessage;
    internal static DiagnosticDescriptor MethodReturnsPreviewTypeRule;
    internal static DiagnosticDescriptor MethodReturnsPreviewTypeRuleWithCustomMessage;
    internal static DiagnosticDescriptor MethodUsesPreviewTypeAsParameterRule;
    internal static DiagnosticDescriptor MethodUsesPreviewTypeAsParameterRuleWithCustomMessage;
    internal static DiagnosticDescriptor FieldOrEventIsPreviewTypeRule;
    internal static DiagnosticDescriptor FieldOrEventIsPreviewTypeRuleWithCustomMessage;
    internal static DiagnosticDescriptor StaticAbstractIsPreviewFeatureRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DetectPreviewFeatureAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual SyntaxNode GetPreviewInterfaceNodeForTypeImplementingPreviewInterface(ISymbol typeSymbol, ISymbol previewInterfaceSymbol);
    protected abstract virtual SyntaxNode GetConstraintSyntaxNodeForTypeConstrainedByPreviewTypes(ISymbol typeOrMethodSymbol, ISymbol previewInterfaceConstraintSymbol);
    protected abstract virtual SyntaxNode GetPreviewReturnTypeSyntaxNodeForMethodOrProperty(ISymbol methodOrPropertySymbol, ISymbol previewReturnTypeSymbol);
    protected abstract virtual SyntaxNode GetPreviewParameterSyntaxNodeForMethod(IMethodSymbol methodSymbol, ISymbol parameterSymbol);
    protected abstract virtual SyntaxNode GetPreviewSyntaxNodeForFieldsOrEvents(ISymbol fieldOrEventSymbol, ISymbol previewSymbol);
    protected abstract virtual SyntaxNode GetPreviewImplementsClauseSyntaxNodeForMethodOrProperty(ISymbol methodOrPropertySymbol, ISymbol previewSymbol);
    public virtual void Initialize(AnalysisContext context);
    private static ISymbol GetPreviewSymbolForGenericTypesFromTypeArguments(ImmutableArray`1<ITypeSymbol> typeArguments, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol);
    private void ProcessFieldSymbolAttributes(SymbolAnalysisContext context, IFieldSymbol symbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol);
    private void ProcessFieldOrEventSymbolAttributes(SymbolAnalysisContext context, ISymbol symbol, ISymbol symbolType, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol);
    private void ProcessEventSymbolAttributes(SymbolAnalysisContext context, IEventSymbol symbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol);
    private void ProcessTypeSymbolAttributes(SymbolAnalysisContext context, ITypeSymbol symbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol);
    private SyntaxNode GetPreviewSyntaxNodeFromSymbols(ISymbol symbol, ISymbol previewType);
    [NullableContextAttribute("2")]
private bool SymbolContainsGenericTypesWithPreviewAttributes(ISymbol symbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttribute, ISymbol& previewSymbol, SyntaxNode& previewSyntaxNode, bool checkTypeParametersForPreviewFeatures, ISymbol methodOrFieldOrEventSymbolForGenericParameterSyntaxNode);
    private static bool SymbolIsStaticAndAbstract(ISymbol symbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol);
    private void ProcessPropertyOrMethodAttributes(SymbolAnalysisContext context, ISymbol propertyOrMethodSymbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, IFieldSymbol virtualStaticsInInterfaces, INamedTypeSymbol previewFeatureAttributeSymbol);
    private void AnalyzeSymbol(SymbolAnalysisContext context, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, IFieldSymbol virtualStaticsInInterfaces, INamedTypeSymbol previewFeatureAttributeSymbol);
    private void BuildSymbolInformationFromOperations(OperationAnalysisContext context, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol);
    private bool SymbolIsAnnotatedOrUsesPreviewTypes(ISymbol symbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol, ISymbol& referencedPreviewSymbol);
    private bool OperationUsesPreviewFeatures(OperationAnalysisContext context, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttributeSymbol, ISymbol& referencedPreviewSymbol);
    private static ISymbol GetOperationSymbol(IOperation operation);
    private static ISymbol SymbolFromArrayCreationOperation(IArrayCreationOperation operation);
    private bool TypeParametersHavePreviewAttribute(ISymbol namedTypeSymbolOrMethodSymbol, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttribute, ISymbol& previewSymbol, SyntaxNode& previewSyntaxNode);
    [NullableContextAttribute("2")]
private static string GetMessageAndURLFromAttributeConstructor(AttributeData attribute, String& url);
    private static void ReportDiagnosticWithCustomMessageIfItExists(OperationAnalysisContext context, IOperation operation, ISymbol symbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, DiagnosticDescriptor diagnosticDescriptor, DiagnosticDescriptor diagnosticDescriptorWithPlaceholdersForCustomMessage, string diagnosticMessageArgument);
    private static void ReportDiagnosticWithCustomMessageIfItExists(SymbolAnalysisContext context, SyntaxNode node, ISymbol previewSymbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, DiagnosticDescriptor diagnosticDescriptor, DiagnosticDescriptor diagnosticDescriptorWithPlaceholdersForCustomMessage, string diagnosticMessageArgument0, string diagnosticMessageArgument1);
    private static void ReportDiagnosticWithCustomMessageIfItExists(SymbolAnalysisContext context, ISymbol previewSymbol, ISymbol symbolToRaiseDiagnosticOn, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, DiagnosticDescriptor diagnosticDescriptor, DiagnosticDescriptor diagnosticDescriptorWithPlaceholdersForCustomMessage, string diagnosticMessageArgument0, string diagnosticMessageArgument1);
    private static bool SymbolIsAnnotatedAsPreview(ISymbol symbol, ConcurrentDictionary`2<ISymbol, ValueTuple`3<bool, string, string>> requiresPreviewFeaturesSymbols, INamedTypeSymbol previewFeatureAttribute);
    [CompilerGeneratedAttribute]
private void <Initialize>b__33_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DisposableFieldsShouldBeDisposed : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposableFieldsShouldBeDisposed();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnSymbolStart(SymbolStartAnalysisContext symbolStartContext);
    [CompilerGeneratedAttribute]
internal static bool <OnSymbolStart>g__ShouldAnalyze|6_2(SymbolStartAnalysisContext symbolStartContext, DisposeAnalysisHelper disposeAnalysisHelper);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DisposableTypesShouldDeclareFinalizerAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposableTypesShouldDeclareFinalizerAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.DisposableTypesShouldDeclareFinalizerFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DisposeMethodsShouldCallBaseClassDispose : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposeMethodsShouldCallBaseClassDispose();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.DisposeMethodsShouldCallBaseClassDisposeFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DisposeObjectsBeforeLosingScope : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor NotDisposedRule;
    internal static DiagnosticDescriptor MayBeDisposedRule;
    internal static DiagnosticDescriptor NotDisposedOnExceptionPathsRule;
    internal static DiagnosticDescriptor MayBeDisposedOnExceptionPathsRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DisposeObjectsBeforeLosingScope();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void ComputeDiagnostics(ImmutableDictionary`2<AbstractLocation, DisposeAbstractValue> disposeData, ArrayBuilder`1<Diagnostic> notDisposedDiagnostics, ArrayBuilder`1<Diagnostic> mayBeNotDisposedDiagnostics, DisposeAnalysisResult disposeAnalysisResult, PointsToAnalysisResult pointsToAnalysisResult, DisposeAnalysisKind disposeAnalysisKind, bool isDisposeDataForExceptionPaths);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    private static LocalizableString s_localizableCastMessage;
    private static LocalizableString s_localizableOfTypeMessage;
    internal static DiagnosticDescriptor CastRule;
    internal static DiagnosticDescriptor OfTypeRule;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, DiagnosticDescriptor>> s_methodMetadataNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCallEnumerableCastOrOfTypeWithIncompatibleTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
internal static ITypeSymbol <Initialize>g__GetIEnumerableTParam|11_8(ITypeSymbol type);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static ITypeSymbol <Initialize>g__FindElementType|11_9(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__CastWillAlwaysFail|11_1(ITypeSymbol castFrom, ITypeSymbol castTo);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsUnconstrainedTypeParameter|11_10(ITypeParameterSymbol typeParameterSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DoNotDefineFinalizersForTypesDerivedFromMemoryManager : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDefineFinalizersForTypesDerivedFromMemoryManager();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeSymbol(INamedTypeSymbol namedTypeSymbol, INamedTypeSymbol memoryManager, Action`2<TContext, Diagnostic> addDiagnostic, TContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DoNotLockOnObjectsWithWeakIdentityAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotLockOnObjectsWithWeakIdentityAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void ReportOnWeakIdentityObject(IOperation operation, OperationAnalysisContext context);
    private static bool TypeHasWeakIdentity(ITypeSymbol type, Compilation compilation);
    public static bool IsPrimitiveType(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.DoNotLockOnObjectsWithWeakIdentityFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DoNotPassLiteralsAsLocalizedParameters : AbstractGlobalizationDiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotPassLiteralsAsLocalizedParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void InitializeWorker(CompilationStartAnalysisContext context);
    private static ImmutableHashSet`1<INamedTypeSymbol> GetTypesToIgnore(Compilation compilation);
    [NullableContextAttribute("2")]
private static bool ShouldBeLocalized(IParameterSymbol parameterSymbol, IPropertySymbol containingPropertySymbol, INamedTypeSymbol localizableStateAttributeSymbol, INamedTypeSymbol conditionalAttributeSymbol, INamedTypeSymbol systemConsoleSymbol, ImmutableHashSet`1<INamedTypeSymbol> typesToIgnore, bool useNamingHeuristic);
    private static LocalizableAttributeState GetLocalizableAttributeState(ISymbol symbol, INamedTypeSymbol localizableAttributeTypeSymbol);
    private static LocalizableAttributeState GetLocalizableAttributeStateCore(ImmutableArray`1<AttributeData> attributeList, INamedTypeSymbol localizableAttributeTypeSymbol);
    private static string FormatLiteralValues(IEnumerable`1<string> literalValues);
    private static bool LooksLikeXmlTag(string literal);
    private static bool LiteralValuesHaveNonControlCharacters(IEnumerable`1<string> literalValues);
    [CompilerGeneratedAttribute]
internal static bool <InitializeWorker>g__GetUseNamingHeuristicOption|5_4(OperationAnalysisContext operationContext);
    [CompilerGeneratedAttribute]
internal static bool <ShouldBeLocalized>g__IsLocalizableByNameHeuristic|7_0(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DoNotRaiseReservedExceptionTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_tooGenericExceptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_reservedExceptions;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor TooGenericRule;
    internal static DiagnosticDescriptor ReservedRule;
    private static SymbolDisplayFormat s_symbolDisplayFormat;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotRaiseReservedExceptionTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static ImmutableHashSet`1<INamedTypeSymbol> CreateSymbolSet(Compilation compilation, IEnumerable`1<string> exceptionNames);
    private static void AnalyzeObjectCreation(OperationAnalysisContext context, ImmutableHashSet`1<INamedTypeSymbol> tooGenericExceptionSymbols, ImmutableHashSet`1<INamedTypeSymbol> reservedExceptionSymbols);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string MethodPropertyKey;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    private static bool IsTypeWithInefficientLinqMethods(ITypeSymbol targetType, ITypeSymbol readonlyListType, ITypeSymbol listType);
    private static bool IsSingleParameterLinqMethod(IMethodSymbol methodSymbol, ITypeSymbol enumerableType);
    private static bool IsPossibleLinqInvocation(IInvocationOperation invocation, bool excludeOrDefaultMethods);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyFixer : CodeFixProvider {
    private static string FirstPropertyName;
    private static string LastPropertyName;
    private static string CountPropertyName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyFixer/<RegisterCodeFixesAsync>d__7")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private Task`1<Document> UseCollectionDirectlyAsync(Document document, SyntaxNode root, SyntaxNode invocationNode, SyntaxNode collectionSyntax, string methodName);
    private SyntaxNode GetReplacementNode(string methodName, SyntaxGenerator generator, SyntaxNode collectionSyntax);
    [NullableContextAttribute("2")]
private protected abstract virtual SyntaxNode AdjustSyntaxNode(SyntaxNode syntaxNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.DoNotUseReferenceEqualsWithValueTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor ComparerRule;
    internal static DiagnosticDescriptor MethodRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseReferenceEqualsWithValueTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.DoNotUseStackallocInLoopsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseStackallocInLoopsAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.DoNotUseTimersThatPreventPowerStateChangesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.DoNotUseTimersThatPreventPowerStateChangesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.ForwardCancellationTokenToInvocationsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor ForwardCancellationTokenToInvocationsRule;
    internal static string ShouldFix;
    internal static string ArgumentName;
    internal static string ParameterName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ForwardCancellationTokenToInvocationsAnalyzer();
    protected abstract virtual SyntaxNode GetInvocationMethodNameNode(SyntaxNode invocationNode);
    protected abstract virtual bool ArgumentsImplicitOrNamed(INamedTypeSymbol cancellationTokenType, ImmutableArray`1<IArgumentOperation> arguments);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private bool ShouldDiagnose(Compilation compilation, IInvocationOperation invocation, IMethodSymbol containingSymbol, INamedTypeSymbol cancellationTokenType, INamedTypeSymbol genericTask, INamedTypeSymbol genericValueTask, INamedTypeSymbol obsoleteAttribute, Int32& shouldFix, String& ancestorTokenParameterName, String& invocationTokenParameterName);
    private static bool TryGetClosestAncestorThatTakesAToken(IInvocationOperation invocation, IMethodSymbol containingSymbol, INamedTypeSymbol cancellationTokenType, Int32& shouldFix, IMethodSymbol& ancestor, String& cancellationTokenParameterName);
    private static bool TryGetTokenParamName(IMethodSymbol methodDeclaration, INamedTypeSymbol cancellationTokenType, String& cancellationTokenParameterName);
    private static bool InvocationMethodTakesAToken(IMethodSymbol method, ImmutableArray`1<IArgumentOperation> arguments, INamedTypeSymbol cancellationTokenType);
    private static bool AnyArgument(ImmutableArray`1<IArgumentOperation> arguments, Func`3<IArgumentOperation, TArg, bool> predicate, TArg arg);
    private static bool InvocationIgnoresOptionalCancellationToken(IParameterSymbol lastParameter, ImmutableArray`1<IArgumentOperation> arguments, INamedTypeSymbol cancellationTokenType);
    private static bool InvocationIsUsingParamsCancellationToken(IParameterSymbol lastParameter, ImmutableArray`1<IArgumentOperation> arguments, INamedTypeSymbol cancellationTokenType);
    private static bool MethodHasCancellationTokenOverload(Compilation compilation, IMethodSymbol method, ITypeSymbol cancellationTokenType, INamedTypeSymbol genericTask, INamedTypeSymbol genericValueTask, INamedTypeSymbol obsoleteAttribute, IMethodSymbol& overload);
    [CompilerGeneratedAttribute]
internal static bool <MethodHasCancellationTokenOverload>g__HasSameParametersPlusCancellationToken|19_1(Compilation compilation, ITypeSymbol cancellationTokenType, INamedTypeSymbol genericTask, INamedTypeSymbol genericValueTask, IMethodSymbol originalMethod, IMethodSymbol methodToCompare);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.ForwardCancellationTokenToInvocationsFixer`1 : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected abstract virtual bool TryGetInvocation(SemanticModel model, SyntaxNode node, CancellationToken ct, IInvocationOperation& invocation);
    protected abstract virtual bool TryGetExpressionAndArguments(SyntaxNode invocationNode, SyntaxNode& expression, ImmutableArray`1& arguments);
    protected abstract virtual bool IsArgumentNamed(IArgumentOperation argumentOperation);
    protected abstract virtual SyntaxNode GetConditionalOperationInvocationExpression(SyntaxNode invocationNode);
    protected abstract virtual SyntaxNode GetTypeSyntaxForArray(IArrayTypeSymbol type);
    protected abstract virtual IEnumerable`1<SyntaxNode> GetExpressions(ImmutableArray`1<TArgumentSyntax> newArguments);
    protected abstract virtual SyntaxNode GetArrayCreationExpression(SyntaxGenerator generator, SyntaxNode typeSyntax, IEnumerable`1<SyntaxNode> expressions);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.ForwardCancellationTokenToInvocationsFixer`1/<RegisterCodeFixesAsync>d__11")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private SyntaxNode TryGenerateNewDocumentRoot(Document doc, SyntaxNode root, IInvocationOperation invocation, string invocationTokenArgumentName, string ancestorTokenParameterName, SyntaxNode expression, ImmutableArray`1<TArgumentSyntax> currentArguments, IArrayTypeSymbol paramsArrayType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.InitializeStaticFieldsInlineAnalyzer : DiagnosticAnalyzer {
    internal static string CA1810RuleId;
    internal static string CA2207RuleId;
    private static LocalizableString s_localizableMessage;
    internal static DiagnosticDescriptor CA1810Rule;
    internal static DiagnosticDescriptor CA2207Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InitializeStaticFieldsInlineAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.InitializeStaticFieldsInlineFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.InstantiateArgumentExceptionsCorrectlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string MessagePosition;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor RuleNoArguments;
    internal static DiagnosticDescriptor RuleIncorrectMessage;
    internal static DiagnosticDescriptor RuleIncorrectParameterName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static InstantiateArgumentExceptionsCorrectlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeObjectCreation(OperationAnalysisContext context, ISymbol owningSymbol, ITypeSymbol argumentExceptionType);
    private static bool MatchesConfiguredVisibility(ISymbol owningSymbol, OperationAnalysisContext context);
    private static bool HasParameters(ISymbol owningSymbol);
    private static Diagnostic CheckArgument(ISymbol targetSymbol, IObjectCreationOperation creation, IParameterSymbol parameter, string stringArgument, OperationAnalysisContext context);
    private static bool IsMessage(IParameterSymbol parameter);
    private static bool IsParameterName(IParameterSymbol parameter);
    private static bool HasParameterNameConstructor(ITypeSymbol type);
    private static bool MatchesParameter(ISymbol symbol, IObjectCreationOperation creation, string stringArgumentValue);
    private static bool MatchesParameterCore(ISymbol symbol, string stringArgumentValue);
    private static bool MatchesAssociatedSymbol(ISymbol targetSymbol, string stringArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.InstantiateArgumentExceptionsCorrectlyFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.InstantiateArgumentExceptionsCorrectlyFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.InstantiateArgumentExceptionsCorrectlyFixer/<PopulateCodeFixAsync>d__5")]
private static Task PopulateCodeFixAsync(CodeFixContext context, Diagnostic diagnostic, string paramPositionString, SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.InstantiateArgumentExceptionsCorrectlyFixer/<SwapArgumentsOrderAsync>d__6")]
private static Task`1<Document> SwapArgumentsOrderAsync(Document document, IObjectCreationOperation creation, int paramPosition, int argumentCount, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.InstantiateArgumentExceptionsCorrectlyFixer/<AddNullMessageToArgumentListAsync>d__7")]
private static Task`1<Document> AddNullMessageToArgumentListAsync(Document document, IObjectCreationOperation creation, CancellationToken token);
    private static SyntaxNode AddNameOfIfLiteral(IOperation expression, SyntaxGenerator generator);
}
internal enum Microsoft.NetCore.Analyzers.Runtime.LocalizableAttributeState : Enum {
    public int value__;
    public static LocalizableAttributeState Undefined;
    public static LocalizableAttributeState True;
    public static LocalizableAttributeState False;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.LoggerMessageDefineAnalyzer : DiagnosticAnalyzer {
    internal static string CA1727RuleId;
    internal static string CA1848RuleId;
    internal static string CA2253RuleId;
    internal static string CA2254RuleId;
    internal static string CA2017RuleId;
    internal static DiagnosticDescriptor CA1727Rule;
    internal static DiagnosticDescriptor CA1848Rule;
    internal static DiagnosticDescriptor CA2253Rule;
    internal static DiagnosticDescriptor CA2254Rule;
    internal static DiagnosticDescriptor CA2017Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static LoggerMessageDefineAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, INamedTypeSymbol loggerType, INamedTypeSymbol loggerExtensionsType, INamedTypeSymbol loggerMessageType);
    private void AnalyzeFormatArgument(OperationAnalysisContext context, IOperation formatExpression, int paramsCount, bool argsIsArray, bool usingLoggerExtensionsTypes, IMethodSymbol methodSymbol);
    private static SymbolDisplayFormat GetLanguageSpecificFormat(IOperation operation);
    [NullableContextAttribute("2")]
private string TryGetFormatText(IOperation argumentExpression);
    [NullableContextAttribute("2")]
private static bool FindLogParameters(IMethodSymbol methodSymbol, IParameterSymbol& message, IParameterSymbol& arguments);
    [CompilerGeneratedAttribute]
private void <Initialize>b__13_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.MarkAllNonSerializableFieldsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected abstract virtual SyntaxNode GetFieldDeclarationNode(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.MarkAllNonSerializableFieldsFixer/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.MarkAllNonSerializableFieldsFixer/<AddNonSerializedAttributeAsync>d__5")]
private static Task`1<Document> AddNonSerializedAttributeAsync(Document document, SyntaxNode fieldNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.MarkAllNonSerializableFieldsFixer/<AddSerializableAttributeToTypeAsync>d__6")]
private static Task`1<Document> AddSerializableAttributeToTypeAsync(Document document, ITypeSymbol type, CancellationToken cancellationToken);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.MarkTypesWithSerializableFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.MarkTypesWithSerializableFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.MarkTypesWithSerializableFixer/<AddSerializableAttributeAsync>d__4")]
private static Task`1<Document> AddSerializableAttributeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.ModuleInitializerAttributeShouldNotBeUsedInLibraries : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ModuleInitializerAttributeShouldNotBeUsedInLibraries();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.NormalizeStringsToUppercaseAnalyzer : AbstractGlobalizationDiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor ToUpperRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static NormalizeStringsToUppercaseAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void InitializeWorker(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.NormalizeStringsToUppercaseFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.PreferAsSpanOverSubstring : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferAsSpanOverSubstring();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    internal static ImmutableArray`1<IMethodSymbol> GetBestSpanBasedOverloads(RequiredSymbols& symbols, IInvocationOperation invocation, CancellationToken cancellationToken);
    private static IEnumerable`1<IMethodSymbol> GetAllAccessibleOverloadsAtInvocationCallSite(IInvocationOperation invocation, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static int <GetBestSpanBasedOverloads>g__EvaluateCandidateQuality|7_0(RequiredSymbols& symbols, ReadOnlySpan`1<bool> isSubstringLookup, IInvocationOperation invocation, IMethodSymbol candidate);
    [CompilerGeneratedAttribute]
internal static INamedTypeSymbol <GetAllAccessibleOverloadsAtInvocationCallSite>g__GetEnclosingType|8_1(SemanticModel model, int location, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.PreferAsSpanOverSubstringFixer : CodeFixProvider {
    private static string SubstringStartIndexArgumentName;
    private static string AsSpanStartArgumentName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private protected abstract virtual void ReplaceNonConditionalInvocationMethodName(SyntaxEditor editor, SyntaxNode memberInvocation, string newName);
    private protected abstract virtual void ReplaceNamedArgumentName(SyntaxEditor editor, SyntaxNode invocation, string oldArgumentName, string newArgumentName);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.PreferAsSpanOverSubstringFixer/<RegisterCodeFixesAsync>d__7")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public sealed virtual FixAllProvider GetFixAllProvider();
    private static bool IsMemoryExtensionsInScope(RequiredSymbols& symbols, IInvocationOperation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.PreferConstCharOverConstUnitStringAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferConstCharOverConstUnitStringAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.PreferConstCharOverConstUnitStringFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.PreferConstCharOverConstUnitStringFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.PreferConstCharOverConstUnitStringFixer/<<RegisterCodeFixesAsync>g__HandleStringLiteral|4_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<Document> <RegisterCodeFixesAsync>g__HandleStringLiteral|4_1(ILiteralOperation argumentLiteral, Document doc, SyntaxNode root, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.PreferConstCharOverConstUnitStringFixer/<<RegisterCodeFixesAsync>g__HandleVariableDeclarator|4_2>d")]
[CompilerGeneratedAttribute]
internal static Task`1<Document> <RegisterCodeFixesAsync>g__HandleVariableDeclarator|4_2(IVariableDeclaratorOperation variableDeclaratorOperation, Document doc, SyntaxNode root, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.PreferDictionaryContainsMethods : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    internal static DiagnosticDescriptor ContainsKeyRule;
    internal static DiagnosticDescriptor ContainsValueRule;
    private static string ContainsMethodName;
    internal static string ContainsKeyMethodName;
    internal static string ContainsValueMethodName;
    internal static string KeysPropertyName;
    internal static string ValuesPropertyName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferDictionaryContainsMethods();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext compilationContext);
    private protected abstract virtual bool TryGetPropertyReferenceOperation(IInvocationOperation containsInvocation, IPropertySymbol& propertySymbol);
}
public abstract class Microsoft.NetCore.Analyzers.Runtime.PreferDictionaryContainsMethodsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
public sealed virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.PreferStreamAsyncMemoryOverloads : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableMessage;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor PreferStreamReadAsyncMemoryOverloadsRule;
    internal static DiagnosticDescriptor PreferStreamWriteAsyncMemoryOverloadsRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferStreamAsyncMemoryOverloads();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
    private static bool ShouldAnalyze(IAwaitOperation awaitOperation, IMethodSymbol configureAwaitMethod, IMethodSymbol genericConfigureAwaitMethod, INamedTypeSymbol streamType, IInvocationOperation& actualInvocation, IMethodSymbol& actualMethod);
    private static bool IsDefinedBy(IMethodSymbol method, INamedTypeSymbol baseType, IMethodSymbol& actualMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.PreferStreamAsyncMemoryOverloadsFixer : CodeFixProvider {
    private static SyntaxAnnotation s_asMemorySymbolAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static PreferStreamAsyncMemoryOverloadsFixer();
    protected abstract virtual SyntaxNode GetArgumentByPositionOrName(IInvocationOperation invocation, int index, string name, Boolean& isNamed);
    protected abstract virtual bool IsPassingZeroAndBufferLength(SemanticModel model, SyntaxNode bufferValueNode, SyntaxNode offsetValueNode, SyntaxNode countValueNode);
    protected abstract virtual SyntaxNode GetNodeWithNullability(IInvocationOperation invocation);
    protected abstract virtual SyntaxNode GetNamedArgument(SyntaxGenerator generator, SyntaxNode node, bool isNamed, string newName);
    protected abstract virtual SyntaxNode GetNamedMemberInvocation(SyntaxGenerator generator, SyntaxNode node, string memberName);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.PreferStreamAsyncMemoryOverloadsFixer/<RegisterCodeFixesAsync>d__10")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private Task`1<Document> FixInvocationAsync(SemanticModel model, Document doc, SyntaxNode root, IInvocationOperation invocation, string methodName, SyntaxNode bufferNode, bool isBufferNamed, SyntaxNode offsetNode, bool isOffsetNamed, SyntaxNode countNode, bool isCountNamed, SyntaxNode cancellationTokenNode, bool isCancellationTokenNamed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.PreferStringContainsOverIndexOfAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferStringContainsOverIndexOfAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__CheckOperatorKindAndOperand|5_6(IBinaryOperation binaryOperation, IOperation otherOperand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.PreferStringContainsOverIndexOfFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.PreferStringContainsOverIndexOfFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.PreferTypedStringBuilderAppendOverloads : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreferTypedStringBuilderAppendOverloads();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.PreferTypedStringBuilderAppendOverloadsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.PreferTypedStringBuilderAppendOverloadsFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.PreventNumericIntPtrUIntPtrBehavioralChanges : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableResourceString s_titleResource;
    private static LocalizableResourceString s_descriptionResource;
    internal static DiagnosticDescriptor OperatorThrowsRule;
    internal static DiagnosticDescriptor ConversionThrowsRule;
    internal static DiagnosticDescriptor ConversionNotThrowRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PreventNumericIntPtrUIntPtrBehavioralChanges();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual bool IsWithinCheckedContext(IOperation operation);
    [NullableContextAttribute("2")]
protected abstract virtual bool IsAliasUsed(ISymbol symbol);
    protected abstract virtual bool IsAliasUsed(SyntaxNode syntax);
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__12_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__12_9(OperationAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static string <Initialize>g__PopulateConversionString|12_1(ITypeSymbol type, ITypeSymbol operand);
    [CompilerGeneratedAttribute]
internal static ISymbol <Initialize>g__GetSymbol|12_2(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsConversionFromInt32|12_3(IOperation operation);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsIntPtrToOrFromPtrConversion|12_4(ITypeSymbol pointerType, ITypeSymbol intPtrType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsLongToIntPtrConversion|12_5(ITypeSymbol convertingType, ITypeSymbol operandType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsIntPtrToIntConversion|12_6(ITypeSymbol convertingType, ITypeSymbol operandType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsULongToUIntPtrConversion|12_7(ITypeSymbol convertingType, ITypeSymbol operandType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsUIntPtrToUIntConversion|12_8(ITypeSymbol convertingType, ITypeSymbol operandType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.ProvideCorrectArgumentsToFormattingMethodsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor ArgumentCountRule;
    internal static DiagnosticDescriptor InvalidFormatRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ProvideCorrectArgumentsToFormattingMethodsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static int GetFormattingArguments(string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.ProvideDeserializationMethodsForOptionalFieldsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.ProvideDeserializationMethodsForOptionalFieldsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.ProvideStreamMemoryBasedAsyncOverrides : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static string ReadAsyncName;
    private static string WriteAsyncName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ProvideStreamMemoryBasedAsyncOverrides();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    private static bool TryGetRequiredSymbols(Compilation compilation, RequiredSymbols& requiredSymbols);
    private static ImmutableArray`1<IMethodSymbol> GetOverloads(ITypeSymbol containingType, string methodName, ITypeSymbol[] argumentTypes);
    private static ImmutableArray`1<IMethodSymbol> GetOverridingMethodSymbols(ITypeSymbol derivedType, IMethodSymbol overriddenMethod);
    [CompilerGeneratedAttribute]
internal static Diagnostic <OnCompilationStart>g__CreateDiagnostic|8_1(INamedTypeSymbol violatingType, IMethodSymbol arrayBasedOverride, IMethodSymbol memoryBasedMethod);
    [CompilerGeneratedAttribute]
internal static bool <GetOverloads>g__IsMatch|10_1(IMethodSymbol method, ITypeSymbol[] argumentTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.SealInternalTypes : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SealInternalTypes();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.SealInternalTypesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.SealInternalTypesFixer/<<RegisterCodeFixesAsync>g__SealDeclarationAt|0_1>d")]
[CompilerGeneratedAttribute]
internal static Task <RegisterCodeFixesAsync>g__SealDeclarationAt|0_1(SolutionEditor solutionEditor, Location location, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.SerializationRulesDiagnosticAnalyzer : DiagnosticAnalyzer {
    internal static string RuleCA2237Id;
    internal static DiagnosticDescriptor RuleCA2237;
    internal static string RuleCA2235Id;
    internal static DiagnosticDescriptor RuleCA2235;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SerializationRulesDiagnosticAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.SpecifyCultureForToLowerAndToUpperAnalyzer : AbstractGlobalizationDiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    internal static string ToLowerMethodName;
    internal static string ToUpperMethodName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SpecifyCultureForToLowerAndToUpperAnalyzer();
    protected abstract virtual Location GetMethodNameLocation(SyntaxNode node);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void InitializeWorker(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.SpecifyCultureForToLowerAndToUpperFixerBase : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.SpecifyCultureForToLowerAndToUpperFixerBase/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual bool ShouldFix(SyntaxNode node);
    protected abstract virtual Task`1<Document> SpecifyCurrentCultureAsync(Document document, SyntaxGenerator generator, SyntaxNode root, SyntaxNode node, CancellationToken cancellationToken);
    protected static SyntaxNode CreateCurrentCultureMemberAccess(SyntaxGenerator generator, SemanticModel model);
    protected abstract virtual Task`1<Document> UseInvariantVersionAsync(Document document, SyntaxGenerator generator, SyntaxNode root, SyntaxNode node);
    protected static string GetReplacementMethodName(string currentMethodName);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.SpecifyCultureInfoAnalyzer : AbstractGlobalizationDiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SpecifyCultureInfoAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void InitializeWorker(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.SpecifyCultureInfoFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.SpecifyIFormatProviderAnalyzer : AbstractGlobalizationDiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor IFormatProviderAlternateStringRule;
    internal static DiagnosticDescriptor IFormatProviderAlternateRule;
    internal static DiagnosticDescriptor IFormatProviderOptionalRule;
    internal static DiagnosticDescriptor UICultureStringRule;
    internal static DiagnosticDescriptor UICultureRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_dateInvariantFormats;
    [NullableAttribute("0")]
private static ImmutableArray`1<SpecialType> s_numberTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SpecifyIFormatProviderAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void InitializeWorker(CompilationStartAnalysisContext context);
    [NullableContextAttribute("2")]
private static IMethodSymbol GetToStringWithFormatStringParameter(INamedTypeSymbol type);
    private static void AddValidToStringMethods(Builder<IMethodSymbol> validToStringMethodsBuilder, INamedTypeSymbol nullableT, INamedTypeSymbol type);
    private static IEnumerable`1<int> GetIndexesOfParameterType(IMethodSymbol targetMethod, INamedTypeSymbol formatProviderType);
    private static ParameterInfo GetParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
    [NullableContextAttribute("2")]
private static bool IsValidToStringCall(IInvocationOperation invocationOperation, ImmutableHashSet`1<IMethodSymbol> validToStringMethods, IMethodSymbol dateTimeToStringFormatMethod, IMethodSymbol dateTimeOffsetToStringFormatMethod, IMethodSymbol timeSpanToStringFormatMethod);
    private static bool IsValidParseCall(IInvocationOperation invocationOperation, ImmutableArray`1<ISymbol> guidParseMethods);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<IMethodSymbol> <AddValidToStringMethods>g__GetToStringMethods|15_0(INamedTypeSymbol namedTypeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.SpecifyIFormatProviderFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.SpecifyStringComparisonAnalyzer : AbstractGlobalizationDiagnosticAnalyzer {
    private static string RuleId_CA1307;
    private static string RuleId_CA1310;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_CA1310MethodNamesWithFirstStringParameter;
    internal static DiagnosticDescriptor Rule_CA1307;
    internal static DiagnosticDescriptor Rule_CA1310;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SpecifyStringComparisonAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void InitializeWorker(CompilationStartAnalysisContext context);
    private static void ReportDiagnostic(DiagnosticDescriptor rule, OperationAnalysisContext oaContext, IInvocationOperation invocationExpression, IMethodSymbol targetMethod, IMethodSymbol correctOverload);
    private static ParameterInfo GetParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<IMethodSymbol, IMethodSymbol> <InitializeWorker>g__GetWellKnownStringOverloads|8_1(Compilation compilation, INamedTypeSymbol stringType, INamedTypeSymbol stringComparisonType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.SpecifyStringComparisonFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[ExtensionAttribute]
internal static class Microsoft.NetCore.Analyzers.Runtime.SyntaxNodeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static SyntaxNode FormatForExtraction(SyntaxNode node, SyntaxNode previouslyContainingNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.TestForEmptyStringsUsingStringLengthAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static string StringEmptyFieldName;
    private static DiagnosticDescriptor s_rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestForEmptyStringsUsingStringLengthAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInvocationExpression(IInvocationOperation invocationOperation, INamedTypeSymbol linqExpressionTreeType, Action`2<TContext, Diagnostic> reportDiagnostic, TContext context);
    private static void AnalyzeBinaryExpression(IBinaryOperation binaryOperation, INamedTypeSymbol linqExpressionTreeType, Action`2<TContext, Diagnostic> reportDiagnostic, TContext context);
    private static bool IsStringEqualsMethod(IMethodSymbol methodSymbol);
    private static bool IsEmptyString(IOperation expression);
    private static bool HasAnEmptyStringArgument(IInvocationOperation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.TestForEmptyStringsUsingStringLengthFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.TestForEmptyStringsUsingStringLengthFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private FixResolution TryGetFixResolution(SyntaxNode expressionSyntax, SemanticModel model, CancellationToken cancellationToken);
    private static bool ContainsSystemStringEmpty(SyntaxNode expressionSyntax, SemanticModel model, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.TestForEmptyStringsUsingStringLengthFixer/<ConvertToMethodInvocationAsync>d__7")]
private static Task`1<Document> ConvertToMethodInvocationAsync(CodeFixContext context, FixResolution fixResolution);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.TestForEmptyStringsUsingStringLengthFixer/<ConvertToStringLengthComparisonAsync>d__8")]
private Task`1<Document> ConvertToStringLengthComparisonAsync(CodeFixContext context, FixResolution fixResolution);
    private static bool ContainsEmptyStringLiteral(SyntaxNode node, SemanticModel model, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetExpression(SyntaxNode node);
    protected abstract virtual bool IsFixableBinaryExpression(SyntaxNode node);
    protected abstract virtual bool IsFixableInvocationExpression(SyntaxNode node);
    protected abstract virtual bool IsEqualsOperator(SyntaxNode node);
    protected abstract virtual bool IsNotEqualsOperator(SyntaxNode node);
    protected abstract virtual SyntaxNode GetLeftOperand(SyntaxNode binaryExpressionSyntax);
    protected abstract virtual SyntaxNode GetRightOperand(SyntaxNode binaryExpressionSyntax);
    protected abstract virtual SyntaxNode GetInvocationTarget(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.TestForNaNCorrectlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private BinaryOperatorKind[] _comparisonOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TestForNaNCorrectlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsNan(IOperation expr);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(OperationAnalysisContext operationAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.TestForNaNCorrectlyFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.TestForNaNCorrectlyFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private FixResolution TryGetFixResolution(SyntaxNode binaryExpressionSyntax, SemanticModel model, CancellationToken cancellationToken);
    private static ITypeSymbol TryGetSystemTypeForNanConstantExpression(SyntaxNode expressionSyntax, SemanticModel model, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.TestForNaNCorrectlyFixer/<ConvertToMethodInvocationAsync>d__7")]
private static Task`1<Document> ConvertToMethodInvocationAsync(CodeFixContext context, FixResolution fixResolution);
    protected abstract virtual SyntaxNode GetBinaryExpression(SyntaxNode node);
    protected abstract virtual bool IsEqualsOperator(SyntaxNode node);
    protected abstract virtual bool IsNotEqualsOperator(SyntaxNode node);
    protected abstract virtual SyntaxNode GetLeftOperand(SyntaxNode binaryExpressionSyntax);
    protected abstract virtual SyntaxNode GetRightOperand(SyntaxNode binaryExpressionSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.UseAsyncMethodInAsyncContext : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static string MandatoryAsyncSuffix;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor Descriptor;
    internal static DiagnosticDescriptor DescriptorNoAlternativeMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseAsyncMethodInAsyncContext();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static SymbolDisplayFormat GetLanguageSpecificFormat(IOperation operation);
    private static void GetTypeAndAddToDictionary(string key, string typeName, ConcurrentDictionary`2<string, INamedTypeSymbol> syncBlockingTypes, WellKnownTypeProvider wellKnownTypeProvider);
    private static void GetSymbolAndAddToList(string symbolName, string metadataName, SymbolKind kind, List`1<SyncBlockingSymbol> syncBlockingSymbols, WellKnownTypeProvider wellKnownTypeProvider);
    private static ImmutableArray`1<IMethodSymbol> GetExcludedMethods(WellKnownTypeProvider wellKnownTypeProvider);
    private static bool HasSupersetOfParameterTypes(IMethodSymbol candidateMethod, IMethodSymbol baselineMethod);
    private static bool HasAsyncCompatibleReturnType(IMethodSymbol methodSymbol, ConcurrentDictionary`2<string, INamedTypeSymbol> syncBlockingTypes);
    [NullableContextAttribute("2")]
private static IMethodSymbol GetParentMethodOrDelegate(OperationAnalysisContext context);
    private static bool IsInTaskReturningMethodOrDelegate(OperationAnalysisContext context, ConcurrentDictionary`2<string, INamedTypeSymbol> syncBlockingTypes);
    private static bool InspectAndReportBlockingMemberAccess(OperationAnalysisContext context, ISymbol memberSymbol, List`1<SyncBlockingSymbol> syncBlockingSymbols, SymbolKind kind);
    [CompilerGeneratedAttribute]
internal static bool <HasAsyncCompatibleReturnType>g__CheckReturnTypeMatch|16_0(string targetType, ISymbol returnType, ConcurrentDictionary`2<string, INamedTypeSymbol> syncBlockingTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.UseCancellationTokenThrowIfCancellationRequested : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseCancellationTokenThrowIfCancellationRequested();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    [NullableContextAttribute("2")]
internal static IOperation GetSingleStatementOrDefault(IOperation singleOrBlock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.UseCancellationTokenThrowIfCancellationRequestedFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.UseCancellationTokenThrowIfCancellationRequestedFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public virtual FixAllProvider GetFixAllProvider();
    private static SyntaxNode CreateThrowIfCancellationRequestedExpressionStatement(DocumentEditor editor, IConditionalOperation conditional, IPropertyReferenceOperation isCancellationRequestedPropertyReference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.UseEnvironmentMembers : DiagnosticAnalyzer {
    internal static string EnvironmentProcessIdRuleId;
    internal static string EnvironmentProcessPathRuleId;
    internal static string EnvironmentCurrentManagedThreadIdRuleId;
    internal static DiagnosticDescriptor UseEnvironmentProcessIdRule;
    internal static DiagnosticDescriptor UseEnvironmentProcessPathRule;
    internal static DiagnosticDescriptor UseEnvironmentCurrentManagedThreadIdRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseEnvironmentMembers();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.UseEnvironmentMembersFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.UseEnvironmentMembersFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.UseExceptionThrowHelpers : DiagnosticAnalyzer {
    internal static string UseArgumentNullExceptionThrowIfNullRuleId;
    internal static string UseArgumentExceptionThrowIfNullOrEmptyRuleId;
    internal static string UseArgumentOutOfRangeExceptionThrowIfRuleId;
    internal static string UseObjectDisposedExceptionThrowIfRuleId;
    internal static string MethodNamePropertyKey;
    internal static DiagnosticDescriptor UseArgumentNullExceptionThrowIfNullRule;
    internal static DiagnosticDescriptor UseArgumentExceptionThrowIfNullOrEmptyRule;
    internal static DiagnosticDescriptor UseArgumentOutOfRangeExceptionThrowIfRule;
    internal static DiagnosticDescriptor UseObjectDisposedExceptionThrowIfRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseExceptionThrowHelpers();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsParameterNullCheck(IOperation condition, IParameterReferenceOperation& parameterReference);
    private static bool IsNullOrEmptyCheck(ISymbol stringIsNullOrEmpty, ISymbol stringLength, ISymbol stringEmpty, IOperation condition, IParameterReferenceOperation& parameterReference);
    private static bool IsArgEqualStringEmpty(ISymbol stringEmpty, IParameterSymbol arg, IOperation left, IOperation right);
    private static bool IsArgLengthEqual0(ISymbol stringLength, IParameterSymbol arg, IOperation left, IOperation right);
    [NullableContextAttribute("2")]
private static bool IsNegativeAndOrZeroComparison(IOperation condition, IParameterReferenceOperation& parameterReferenceOperation, String& methodName);
    [NullableContextAttribute("2")]
private static bool IsGreaterLessEqualThanComparison(IOperation condition, IParameterReferenceOperation& parameterReferenceOperation, String& methodName, SyntaxNode& other);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__AvoidComparing|12_4(IParameterReferenceOperation p);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__HasReplaceableArgumentName|12_2(IObjectCreationOperation creationOperation, int argumentIndex);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsNullOrEmptyMessage|12_5(IArgumentOperation arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.UseExceptionThrowHelpersFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.UseExceptionThrowHelpersFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("2")]
private static bool TryGetFixInfo(Document doc, SyntaxNode root, SemanticModel model, Diagnostic diagnostic, INamedTypeSymbol& typeSymbol, String& methodName, SyntaxNode& node, SyntaxNode& arg, SyntaxNode& other);
    private static void ApplyFix(INamedTypeSymbol typeSymbol, string methodName, SyntaxNode node, SyntaxNode arg, SyntaxNode other, SyntaxEditor editor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.UseOrdinalStringComparisonAnalyzer : AbstractGlobalizationDiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableMessageAndTitle;
    internal static DiagnosticDescriptor Rule;
    internal static string CompareMethodName;
    internal static string EqualsMethodName;
    internal static string OrdinalText;
    internal static string OrdinalIgnoreCaseText;
    internal static string StringComparisonTypeName;
    internal static string IgnoreCaseText;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseOrdinalStringComparisonAnalyzer();
    protected abstract virtual Location GetMethodNameLocation(SyntaxNode invocationNode);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual void InitializeWorker(CompilationStartAnalysisContext context);
    private static bool IsEqualsOrCompare(string methodName);
    private static bool IsAcceptableOverload(IMethodSymbol methodSymbol, INamedTypeSymbol stringComparisonType);
    private static bool IsAcceptableInstanceOverload(IMethodSymbol methodSymbol, INamedTypeSymbol stringComparisonType);
    private static bool IsAcceptableStaticOverload(IMethodSymbol methodSymbol, INamedTypeSymbol stringComparisonType);
    private static bool IsOrdinalOrOrdinalIgnoreCase(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.UseOrdinalStringComparisonFixerBase : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.UseOrdinalStringComparisonFixerBase/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual bool IsInArgumentContext(SyntaxNode node);
    protected abstract virtual Task`1<Document> FixArgumentAsync(Document document, SyntaxGenerator generator, SyntaxNode root, SyntaxNode argument);
    protected abstract virtual bool IsInIdentifierNameContext(SyntaxNode node);
    protected abstract virtual Task`1<Document> FixIdentifierNameAsync(Document document, SyntaxGenerator generator, SyntaxNode root, SyntaxNode identifier, CancellationToken cancellationToken);
    internal static SyntaxNode CreateOrdinalMemberAccess(SyntaxGenerator generator, SemanticModel model);
    protected static bool CanAddStringComparison(IMethodSymbol methodSymbol, SemanticModel model);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.UseSpanBasedStringConcat : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseSpanBasedStringConcat();
    private protected abstract virtual bool TryGetTopMostConcatOperation(IBinaryOperation binaryOperation, IBinaryOperation& rootBinaryOperation);
    private protected abstract virtual IOperation WalkDownBuiltInImplicitConversionOnConcatOperand(IOperation operand);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private void OnCompilationStart(CompilationStartAnalysisContext context);
    internal static ImmutableArray`1<IOperation> FlattenBinaryOperation(IBinaryOperation root);
    internal static IOperation CSharpWalkDownBuiltInImplicitConversionOnConcatOperand(IOperation operand);
    internal static IOperation BasicWalkDownBuiltInImplicitConversionOnConcatOperand(IOperation operand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Runtime.UseSpanBasedStringConcatFixer : CodeFixProvider {
    private protected static string AsSpanName;
    private protected static string AsSpanStartParameterName;
    private protected static string ToStringName;
    private static SyntaxAnnotation s_asSpanSymbolAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static UseSpanBasedStringConcatFixer();
    private protected abstract virtual SyntaxNode ReplaceInvocationMethodName(SyntaxGenerator generator, SyntaxNode invocationSyntax, string newName);
    private protected abstract virtual IOperation WalkDownBuiltInImplicitConversionOnConcatOperand(IOperation operand);
    private protected abstract virtual bool IsNamedArgument(IArgumentOperation argumentOperation);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.UseSpanBasedStringConcatFixer/<RegisterCodeFixesAsync>d__10")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public sealed virtual FixAllProvider GetFixAllProvider();
    private SyntaxNode ConvertOperandToArgument(RequiredSymbols& symbols, SyntaxGenerator generator, IOperation operand);
    [CompilerGeneratedAttribute]
private bool <ConvertOperandToArgument>g__TryGetNamedStartIndexArgument|12_0(RequiredSymbols& symbols, IInvocationOperation substringInvocation, IArgumentOperation& namedStartIndexArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.UseStringEqualsOverStringCompare : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<Func`3<IOperation, RequiredSymbols, bool>> CaseSelectors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseStringEqualsOverStringCompare();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void OnCompilationStart(CompilationStartAnalysisContext context);
    [NullableContextAttribute("2")]
internal static IInvocationOperation GetInvocationFromEqualityCheckWithLiteralZero(IBinaryOperation binaryOperation);
    [NullableContextAttribute("2")]
internal static IInvocationOperation GetInvocationFromEqualsCheckWithLiteralZero(IInvocationOperation invocation, IMethodSymbol int32Equals);
    internal static bool IsStringStringCase(IOperation operation, RequiredSymbols symbols);
    internal static bool IsStringStringBoolCase(IOperation operation, RequiredSymbols symbols);
    internal static bool IsStringStringStringComparisonCase(IOperation operation, RequiredSymbols symbols);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetInvocationFromEqualityCheckWithLiteralZero>g__IsLiteralZero|8_0(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Runtime.UseStringEqualsOverStringCompareFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Runtime.UseStringEqualsOverStringCompareFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public virtual FixAllProvider GetFixAllProvider();
    private static ImmutableArray`1<OperationReplacer> GetOperationReplacers(RequiredSymbols symbols);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Runtime.UseThreadStaticCorrectly : DiagnosticAnalyzer {
    internal static string ThreadStaticNonStaticFieldRuleId;
    internal static string ThreadStaticInitializedInlineRuleId;
    internal static DiagnosticDescriptor ThreadStaticOnNonStaticFieldRule;
    internal static DiagnosticDescriptor ThreadStaticInitializedInlineRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseThreadStaticCorrectly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.NetCore.Analyzers.Runtime.ValueValidator : object {
    private String[] _ignoredNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AcceptedTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, bool> <IsValidValue>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AcceptedTokens { get; }
    public string TypeName { get; }
    public Func`2<string, bool> IsValidValue { get; }
    public ValueValidator(ImmutableArray`1<string> acceptedTokens, string typeName, Func`2<string, bool> isValidValue, String[] ignoredNames);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_AcceptedTokens();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public Func`2<string, bool> get_IsValidValue();
    public bool IsIgnoredName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ApprovedCipherModeAnalyzer : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    internal static ImmutableHashSet`1<string> UnsafeCipherModes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ApprovedCipherModeAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Security.DataSetDataTableInIFormatterSerializableObjectGraphAnalyzer : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor ObjectGraphContainsDangerousTypeDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DataSetDataTableInIFormatterSerializableObjectGraphAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual string ToString(TypedConstant typedConstant);
    public sealed virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
    [CompilerGeneratedAttribute]
private string <Initialize>b__5_2(TypedConstant typedConstant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Security.DataSetDataTableInSerializableObjectGraphAnalyzer : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor ObjectGraphContainsDangerousTypeDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DataSetDataTableInSerializableObjectGraphAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual string ToString(TypedConstant typedConstant);
    public sealed virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
    [CompilerGeneratedAttribute]
private string <Initialize>b__5_11(TypedConstant typedConstant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Security.DataSetDataTableInSerializableTypeAnalyzer : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor RceSerializableContainsDangerousType;
    internal static DiagnosticDescriptor SerializableContainsDangerousType;
    internal static DiagnosticDescriptor RceAutogeneratedSerializableContainsDangerousType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DataSetDataTableInSerializableTypeAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual string ToString(TypedConstant typedConstant);
    public sealed virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
    [CompilerGeneratedAttribute]
private string <Initialize>b__7_4(TypedConstant typedConstant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Security.DataSetDataTableInWebSerializableObjectGraphAnalyzer : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor ObjectGraphContainsDangerousTypeDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DataSetDataTableInWebSerializableObjectGraphAnalyzer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected abstract virtual string ToString(TypedConstant typedConstant);
    public sealed virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
    [CompilerGeneratedAttribute]
private string <Initialize>b__5_2(TypedConstant typedConstant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotAddArchiveItemPathToTheTargetFileSystemPath : SourceTriggeredTaintedDataAnalyzerBase {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static DoNotAddArchiveItemPathToTheTargetFileSystemPath();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotAddSchemaByURL : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotAddSchemaByURL();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotAlwaysSkipTokenValidationInDelegates : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotAlwaysSkipTokenValidationInDelegates();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private static bool IsAudienceValidatorFunction(IMethodSymbol methodSymbol, INamedTypeSymbol iEnumerableString, INamedTypeSymbol securityToken, INamedTypeSymbol tokenValidationParameters);
    private static bool IsLifetimeValidatorFunction(IMethodSymbol methodSymbol, INamedTypeSymbol nullableDateTime, INamedTypeSymbol securityToken, INamedTypeSymbol tokenValidationParameters);
    private static bool AlwaysReturnTrue(IEnumerable`1<IOperation> operations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotCallDangerousMethodsInDeserialization : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ValueTuple`2<string, String[]>> DangerousCallable;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCallDangerousMethodsInDeserialization();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotDisableCertificateValidation : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDisableCertificateValidation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private static bool IsCertificateValidationFunction(IMethodSymbol methodSymbol, INamedTypeSymbol obj, INamedTypeSymbol x509Certificate, INamedTypeSymbol x509Chain, INamedTypeSymbol sslPolicyErrors);
    private static bool AlwaysReturnTrue(IEnumerable`1<IOperation> operations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.DoNotDisableHttpClientCRLCheck : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DefinitelyDisableHttpClientCRLCheckRule;
    internal static DiagnosticDescriptor MaybeDisableHttpClientCRLCheckRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static int CheckCertificateRevocationListIndex;
    private static int ServerCertificateValidationCallbackIndex;
    private static ConstructorMapper ConstructorMapper;
    private static PropertyMapperCollection PropertyMappers;
    private static HazardousUsageEvaluatorCollection HazardousUsageEvaluators;
    private static ImmutableHashSet`1<string> typeToTrackMetadataNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDisableHttpClientCRLCheck();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__11_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotDisableHTTPHeaderChecking : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDisableHTTPHeaderChecking();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotDisableRequestValidation : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDisableRequestValidation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotDisableTokenValidationChecks : DiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<string> PropertiesWhichShouldNotBeFalse;
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotDisableTokenValidationChecks();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotHardCodeCertificate : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static DoNotHardCodeCertificate();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotHardCodeEncryptionKey : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static DoNotHardCodeEncryptionKey();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotInstallRootCert : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DefinitelyInstallRootCertRule;
    internal static DiagnosticDescriptor MaybeInstallRootCertRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static PropertyMapperCollection PropertyMappers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotInstallRootCert();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static HazardousUsageEvaluationResult HazardousUsageCallback(IMethodSymbol methodSymbol, PropertySetAbstractValue propertySetAbstractValue);
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotSerializeTypeWithPointerFields : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotSerializeTypeWithPointerFields();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotSetSwitch : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DoNotDisableSchUseStrongCryptoRule;
    internal static DiagnosticDescriptor DoNotDisableSpmSecurityProtocolsRule;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableDictionary`2<string, ValueTuple`2<bool, DiagnosticDescriptor>> BadSwitches;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotSetSwitch();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool IsConfiguredToSkipAnalysis(DiagnosticDescriptor rule, OperationAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseAccountSAS : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseAccountSAS();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseCreateEncryptorWithNonDefaultIV : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DefinitelyUseCreateEncryptorWithNonDefaultIVRule;
    internal static DiagnosticDescriptor MaybeUseCreateEncryptorWithNonDefaultIVRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ConstructorMapper ConstructorMapper;
    private static PropertyMapperCollection PropertyMappers;
    private static HazardousUsageEvaluatorCollection HazardousUsageEvaluators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseCreateEncryptorWithNonDefaultIV();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.DoNotUseDataSetReadXml : DoNotUseInsecureDeserializerMethodsBase {
    internal static DiagnosticDescriptor RealMethodUsedDescriptor;
    internal static DiagnosticDescriptor RealMethodUsedInAutogeneratedDescriptor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected string DeserializerTypeMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor MethodUsedDescriptor { get; }
    private static DoNotUseDataSetReadXml();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual DiagnosticDescriptor ChooseDiagnosticDescriptor(OperationAnalysisContext operationAnalysisContext, WellKnownTypeProvider wellKnownTypeProvider);
    protected virtual string get_DeserializerTypeMetadataName();
    protected virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected virtual DiagnosticDescriptor get_MethodUsedDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.DoNotUseDataTableReadXml : DoNotUseInsecureDeserializerMethodsBase {
    internal static DiagnosticDescriptor RealMethodUsedDescriptor;
    protected string DeserializerTypeMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor MethodUsedDescriptor { get; }
    private static DoNotUseDataTableReadXml();
    protected virtual string get_DeserializerTypeMetadataName();
    protected virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected virtual DiagnosticDescriptor get_MethodUsedDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseDeprecatedSecurityProtocols : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DeprecatedRule;
    internal static DiagnosticDescriptor HardCodedRule;
    private ImmutableHashSet`1<string> HardCodedSafeProtocolMetadataNames;
    private static string SystemDefaultName;
    private static int UnsafeBits;
    private static int HardCodedBits;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseDeprecatedSecurityProtocols();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__9_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseDSA : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    private static ImmutableHashSet`1<string> s_DSAAlgorithmNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseDSA();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureCryptographicAlgorithmsAnalyzer : DiagnosticAnalyzer {
    internal static string DoNotUseWeakCryptographyRuleId;
    internal static string DoNotUseBrokenCryptographyRuleId;
    internal static DiagnosticDescriptor DoNotUseBrokenCryptographyRule;
    internal static DiagnosticDescriptor DoNotUseWeakCryptographyRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureCryptographicAlgorithmsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool ReferencesAnyTargetType(CompilationSecurityTypes types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerBinaryFormatterMethods : DoNotUseInsecureDeserializerMethodsBase {
    internal static DiagnosticDescriptor RealMethodUsedDescriptor;
    protected string DeserializerTypeMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor MethodUsedDescriptor { get; }
    private static DoNotUseInsecureDeserializerBinaryFormatterMethods();
    protected virtual string get_DeserializerTypeMetadataName();
    protected virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected virtual DiagnosticDescriptor get_MethodUsedDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerBinaryFormatterWithoutBinder : DoNotUseInsecureDeserializerWithoutBinderBase {
    internal static DiagnosticDescriptor RealBinderDefinitelyNotSetDescriptor;
    internal static DiagnosticDescriptor RealBinderMaybeNotSetDescriptor;
    protected string DeserializerTypeMetadataName { get; }
    protected string SerializationBinderPropertyMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor BinderDefinitelyNotSetDescriptor { get; }
    protected DiagnosticDescriptor BinderMaybeNotSetDescriptor { get; }
    private static DoNotUseInsecureDeserializerBinaryFormatterWithoutBinder();
    protected virtual string get_DeserializerTypeMetadataName();
    protected virtual string get_SerializationBinderPropertyMetadataName();
    protected virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected virtual DiagnosticDescriptor get_BinderDefinitelyNotSetDescriptor();
    protected virtual DiagnosticDescriptor get_BinderMaybeNotSetDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerJavaScriptSerializerWithSimpleTypeResolver : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DefinitelyWithSimpleTypeResolver;
    internal static DiagnosticDescriptor MaybeWithSimpleTypeResolver;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static PropertyMapperCollection PropertyMappers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureDeserializerJavaScriptSerializerWithSimpleTypeResolver();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static HazardousUsageEvaluationResult HazardousUsageCallback(IMethodSymbol methodSymbol, PropertySetAbstractValue propertySetAbstractValue);
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerJsonNetWithoutBinder : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DefinitelyInsecureSerializer;
    internal static DiagnosticDescriptor MaybeInsecureSerializer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static int TypeNameHandlingIndex;
    private static int SerializationBinderIndex;
    private static ConstructorMapper ConstructorMapper;
    private static PropertyMapperCollection PropertyMappers;
    private static HazardousUsageEvaluatorCollection HazardousUsageEvaluators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureDeserializerJsonNetWithoutBinder();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerLosFormatter : DoNotUseInsecureDeserializerMethodsBase {
    internal static DiagnosticDescriptor RealMethodUsedDescriptor;
    protected string DeserializerTypeMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor MethodUsedDescriptor { get; }
    private static DoNotUseInsecureDeserializerLosFormatter();
    protected virtual string get_DeserializerTypeMetadataName();
    protected virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected virtual DiagnosticDescriptor get_MethodUsedDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerMethodsBase : DiagnosticAnalyzer {
    protected string DeserializerTypeMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor MethodUsedDescriptor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual string get_DeserializerTypeMetadataName();
    protected abstract virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected abstract virtual DiagnosticDescriptor get_MethodUsedDescriptor();
    protected virtual DiagnosticDescriptor ChooseDiagnosticDescriptor(OperationAnalysisContext operationAnalysisContext, WellKnownTypeProvider wellKnownTypeProvider);
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerNetDataContractSerializerMethods : DoNotUseInsecureDeserializerMethodsBase {
    internal static DiagnosticDescriptor RealMethodUsedDescriptor;
    protected string DeserializerTypeMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor MethodUsedDescriptor { get; }
    private static DoNotUseInsecureDeserializerNetDataContractSerializerMethods();
    protected virtual string get_DeserializerTypeMetadataName();
    protected virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected virtual DiagnosticDescriptor get_MethodUsedDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerNetDataContractSerializerWithoutBinder : DoNotUseInsecureDeserializerWithoutBinderBase {
    internal static DiagnosticDescriptor RealBinderDefinitelyNotSetDescriptor;
    internal static DiagnosticDescriptor RealBinderMaybeNotSetDescriptor;
    protected string DeserializerTypeMetadataName { get; }
    protected string SerializationBinderPropertyMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor BinderDefinitelyNotSetDescriptor { get; }
    protected DiagnosticDescriptor BinderMaybeNotSetDescriptor { get; }
    private static DoNotUseInsecureDeserializerNetDataContractSerializerWithoutBinder();
    protected virtual string get_DeserializerTypeMetadataName();
    protected virtual string get_SerializationBinderPropertyMetadataName();
    protected virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected virtual DiagnosticDescriptor get_BinderDefinitelyNotSetDescriptor();
    protected virtual DiagnosticDescriptor get_BinderMaybeNotSetDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerObjectStateFormatter : DoNotUseInsecureDeserializerMethodsBase {
    internal static DiagnosticDescriptor RealMethodUsedDescriptor;
    protected string DeserializerTypeMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor MethodUsedDescriptor { get; }
    private static DoNotUseInsecureDeserializerObjectStateFormatter();
    protected virtual string get_DeserializerTypeMetadataName();
    protected virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected virtual DiagnosticDescriptor get_MethodUsedDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureDeserializerWithoutBinderBase : DiagnosticAnalyzer {
    private static ConstructorMapper ConstructorMapper;
    protected string DeserializerTypeMetadataName { get; }
    protected string SerializationBinderPropertyMetadataName { get; }
    protected ImmutableHashSet`1<string> DeserializationMethodNames { get; }
    protected DiagnosticDescriptor BinderDefinitelyNotSetDescriptor { get; }
    protected DiagnosticDescriptor BinderMaybeNotSetDescriptor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureDeserializerWithoutBinderBase();
    protected abstract virtual string get_DeserializerTypeMetadataName();
    protected abstract virtual string get_SerializationBinderPropertyMetadataName();
    protected abstract virtual ImmutableHashSet`1<string> get_DeserializationMethodNames();
    protected abstract virtual DiagnosticDescriptor get_BinderDefinitelyNotSetDescriptor();
    protected abstract virtual DiagnosticDescriptor get_BinderMaybeNotSetDescriptor();
    public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureRandomness : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureRandomness();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseInsecureSettingsForJsonNet : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DefinitelyInsecureSettings;
    internal static DiagnosticDescriptor MaybeInsecureSettings;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static int TypeNameHandlingIndex;
    private static int SerializationBinderIndex;
    private static ConstructorMapper ConstructorMapper;
    private static PropertyMapperCollection PropertyMappers;
    private static HazardousUsageEvaluatorCollection HazardousUsageEvaluators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureSettingsForJsonNet();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__10_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseObsoleteKDFAlgorithm : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseObsoleteKDFAlgorithm();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseWeakKDFAlgorithm : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableHashSet`1<string> s_WeakHashAlgorithmNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseWeakKDFAlgorithm();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseWeakKDFInsufficientIterationCount : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DefinitelyUseWeakKDFInsufficientIterationCountRule;
    internal static DiagnosticDescriptor MaybeUseWeakKDFInsufficientIterationCountRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static int DefaultIterationCount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseWeakKDFInsufficientIterationCount();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static HazardousUsageEvaluationResult HazardousUsageCallback(IMethodSymbol methodSymbol, PropertySetAbstractValue propertySetAbstractValue);
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.DoNotUseXslTransform : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseXslTransform();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.NetCore.Analyzers.Security.Helpers.CompilationSecurityTypes : object {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <MD5>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SHA1>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <HMACSHA1>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DES>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DSA>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DSASignatureFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <HMACMD5>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <RC2>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <TripleDES>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <RIPEMD160>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <HMACRIPEMD160>k__BackingField;
    public INamedTypeSymbol MD5 { get; private set; }
    public INamedTypeSymbol SHA1 { get; private set; }
    public INamedTypeSymbol HMACSHA1 { get; private set; }
    public INamedTypeSymbol DES { get; private set; }
    public INamedTypeSymbol DSA { get; private set; }
    public INamedTypeSymbol DSASignatureFormatter { get; private set; }
    public INamedTypeSymbol HMACMD5 { get; private set; }
    public INamedTypeSymbol RC2 { get; private set; }
    public INamedTypeSymbol TripleDES { get; private set; }
    public INamedTypeSymbol RIPEMD160 { get; private set; }
    public INamedTypeSymbol HMACRIPEMD160 { get; private set; }
    [NullableContextAttribute("1")]
public CompilationSecurityTypes(Compilation compilation);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_MD5();
    [CompilerGeneratedAttribute]
private void set_MD5(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SHA1();
    [CompilerGeneratedAttribute]
private void set_SHA1(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_HMACSHA1();
    [CompilerGeneratedAttribute]
private void set_HMACSHA1(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_DES();
    [CompilerGeneratedAttribute]
private void set_DES(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_DSA();
    [CompilerGeneratedAttribute]
private void set_DSA(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_DSASignatureFormatter();
    [CompilerGeneratedAttribute]
private void set_DSASignatureFormatter(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_HMACMD5();
    [CompilerGeneratedAttribute]
private void set_HMACMD5(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_RC2();
    [CompilerGeneratedAttribute]
private void set_RC2(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_TripleDES();
    [CompilerGeneratedAttribute]
private void set_TripleDES(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_RIPEMD160();
    [CompilerGeneratedAttribute]
private void set_RIPEMD160(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_HMACRIPEMD160();
    [CompilerGeneratedAttribute]
private void set_HMACRIPEMD160(INamedTypeSymbol value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.NetCore.Analyzers.Security.Helpers.InsecureDeserializationTypeDecider : object {
    [NullableAttribute("1")]
private static String[] InsecureTypeNames;
    [NullableAttribute("1")]
private static BoundedCacheWithFactory`2<Compilation, InsecureDeserializationTypeDecider> BoundedCache;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private SymbolByDisplayStringComparer <SymbolByDisplayStringComparer>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private WellKnownTypeProvider <WellKnownTypeProvider>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private HashSet`1<ITypeSymbol> <InsecureTypeSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <GeneratedCodeAttributeTypeSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SerializableAttributeTypeSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <NonSerializedAttributeTypeSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DataContractAttributeTypeSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DataMemberAttributeTypeSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <IgnoreDataMemberTypeSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <KnownTypeAttributeTypeSymbol>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private XmlSerializationAttributeTypes <XmlSerializationAttributeTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <JsonIgnoreAttributeTypeSymbol>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ITypeSymbol, ITypeSymbol> IsTypeInsecureCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`2<ITypeSymbol, ObjectGraphOptions>, ImmutableArray`1<InsecureObjectGraphResult>> IsObjectGraphInsecureCache;
    [NullableAttribute("1")]
public SymbolByDisplayStringComparer SymbolByDisplayStringComparer { get; }
    [NullableAttribute("1")]
private WellKnownTypeProvider WellKnownTypeProvider { get; }
    [NullableAttribute("1")]
private HashSet`1<ITypeSymbol> InsecureTypeSymbols { get; }
    private INamedTypeSymbol GeneratedCodeAttributeTypeSymbol { get; }
    private INamedTypeSymbol SerializableAttributeTypeSymbol { get; }
    private INamedTypeSymbol NonSerializedAttributeTypeSymbol { get; }
    private INamedTypeSymbol DataContractAttributeTypeSymbol { get; }
    private INamedTypeSymbol DataMemberAttributeTypeSymbol { get; }
    private INamedTypeSymbol IgnoreDataMemberTypeSymbol { get; }
    private INamedTypeSymbol KnownTypeAttributeTypeSymbol { get; }
    [NullableAttribute("1")]
private XmlSerializationAttributeTypes XmlSerializationAttributeTypes { get; }
    private INamedTypeSymbol JsonIgnoreAttributeTypeSymbol { get; }
    [NullableContextAttribute("1")]
private InsecureDeserializationTypeDecider(Compilation compilation);
    private static InsecureDeserializationTypeDecider();
    [NullableContextAttribute("1")]
public static InsecureDeserializationTypeDecider GetOrCreate(Compilation compilation);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public SymbolByDisplayStringComparer get_SymbolByDisplayStringComparer();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private WellKnownTypeProvider get_WellKnownTypeProvider();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private HashSet`1<ITypeSymbol> get_InsecureTypeSymbols();
    [CompilerGeneratedAttribute]
private INamedTypeSymbol get_GeneratedCodeAttributeTypeSymbol();
    [CompilerGeneratedAttribute]
private INamedTypeSymbol get_SerializableAttributeTypeSymbol();
    [CompilerGeneratedAttribute]
private INamedTypeSymbol get_NonSerializedAttributeTypeSymbol();
    [CompilerGeneratedAttribute]
private INamedTypeSymbol get_DataContractAttributeTypeSymbol();
    [CompilerGeneratedAttribute]
private INamedTypeSymbol get_DataMemberAttributeTypeSymbol();
    [CompilerGeneratedAttribute]
private INamedTypeSymbol get_IgnoreDataMemberTypeSymbol();
    [CompilerGeneratedAttribute]
private INamedTypeSymbol get_KnownTypeAttributeTypeSymbol();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private XmlSerializationAttributeTypes get_XmlSerializationAttributeTypes();
    [CompilerGeneratedAttribute]
private INamedTypeSymbol get_JsonIgnoreAttributeTypeSymbol();
    public bool IsTypeInsecure(ITypeSymbol typeSymbol, ITypeSymbol& insecureTypeSymbol);
    [NullableContextAttribute("1")]
public bool IsObjectGraphInsecure(ITypeSymbol rootType, ObjectGraphOptions options, ImmutableArray`1& results);
    [NullableContextAttribute("1")]
private static void GetAssociatedTypes(ITypeSymbol type, SortedSet`1<ITypeSymbol> results);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static InsecureDeserializationTypeDecider <GetOrCreate>g__Create|2_0(Compilation c);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private ITypeSymbol <IsTypeInsecure>g__Compute|42_0(ITypeSymbol typeSymbol);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.NetCore.Analyzers.Security.Helpers.InsecureObjectGraphResult : object {
    [CompilerGeneratedAttribute]
private ISymbol <InsecureSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeData <InsecureAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypedConstant> <InsecureAttributeTypedConstant>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ITypeSymbol <InsecureType>k__BackingField;
    public ISymbol InsecureSymbol { get; }
    public AttributeData InsecureAttribute { get; }
    public Nullable`1<TypedConstant> InsecureAttributeTypedConstant { get; }
    [NullableAttribute("1")]
public ITypeSymbol InsecureType { get; }
    public InsecureObjectGraphResult(ISymbol insecureSymbol, AttributeData insecureAttribute, Nullable`1<TypedConstant> insecureAttributeTypedConstant, ITypeSymbol insecureType);
    [CompilerGeneratedAttribute]
public ISymbol get_InsecureSymbol();
    [CompilerGeneratedAttribute]
public AttributeData get_InsecureAttribute();
    [CompilerGeneratedAttribute]
public Nullable`1<TypedConstant> get_InsecureAttributeTypedConstant();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ITypeSymbol get_InsecureType();
    [NullableContextAttribute("1")]
public Location GetLocation();
    [NullableContextAttribute("1")]
public string GetDisplayString(Func`2<TypedConstant, string> typedConstantToString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.NetCore.Analyzers.Security.Helpers.ObjectGraphOptions : object {
    [CompilerGeneratedAttribute]
private bool <Recurse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BinarySerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DataContractSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XmlSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <JavaScriptSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NewtonsoftJsonNetSerialization>k__BackingField;
    public static ObjectGraphOptions BinarySerializationOptions;
    public static ObjectGraphOptions DataContractOptions;
    public static ObjectGraphOptions XmlSerializerOptions;
    public static ObjectGraphOptions JavaScriptSerializerOptions;
    public static ObjectGraphOptions NewtonsoftJsonNetOptions;
    public bool Recurse { get; private set; }
    public bool BinarySerialization { get; private set; }
    public bool DataContractSerialization { get; private set; }
    public bool XmlSerialization { get; private set; }
    public bool JavaScriptSerializer { get; private set; }
    public bool NewtonsoftJsonNetSerialization { get; private set; }
    public ObjectGraphOptions(bool recurse, bool binarySerialization, bool dataContractSerialization, bool xmlSerialization, bool javaScriptSerializer, bool newtonsoftJsonNetSerialization);
    private static ObjectGraphOptions();
    [CompilerGeneratedAttribute]
public bool get_Recurse();
    [CompilerGeneratedAttribute]
private void set_Recurse(bool value);
    [CompilerGeneratedAttribute]
public bool get_BinarySerialization();
    [CompilerGeneratedAttribute]
private void set_BinarySerialization(bool value);
    [CompilerGeneratedAttribute]
public bool get_DataContractSerialization();
    [CompilerGeneratedAttribute]
private void set_DataContractSerialization(bool value);
    [CompilerGeneratedAttribute]
public bool get_XmlSerialization();
    [CompilerGeneratedAttribute]
private void set_XmlSerialization(bool value);
    [CompilerGeneratedAttribute]
public bool get_JavaScriptSerializer();
    [CompilerGeneratedAttribute]
private void set_JavaScriptSerializer(bool value);
    [CompilerGeneratedAttribute]
public bool get_NewtonsoftJsonNetSerialization();
    [CompilerGeneratedAttribute]
private void set_NewtonsoftJsonNetSerialization(bool value);
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public bool Equals(ObjectGraphOptions other);
    public virtual int GetHashCode();
    internal void ThrowIfInvalid(string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.NetCore.Analyzers.Security.Helpers.SecurityHelpers : object {
    public static ImmutableHashSet`1<string> BinaryFormatterDeserializationMethods;
    public static ImmutableHashSet`1<string> NetDataContractSerializerDeserializationMethods;
    public static ImmutableHashSet`1<string> JavaScriptSerializerDeserializationMethods;
    public static ImmutableHashSet`1<string> ObjectStateFormatterDeserializationMethods;
    public static ImmutableHashSet`1<string> SoapFormatterDeserializationMethods;
    public static ImmutableHashSet`1<string> JsonSerializerInstantiateWithSettingsMethods;
    public static ImmutableHashSet`1<string> JsonConvertWithSettingsMethods;
    public static ImmutableHashSet`1<string> JsonSerializerDeserializationMethods;
    public static ImmutableHashSet`1<string> DataTableDeserializationMethods;
    public static ImmutableHashSet`1<string> DataSetDeserializationMethods;
    private static SecurityHelpers();
    public static DiagnosticDescriptor CreateDiagnosticDescriptor(string id, string titleResourceStringName, string messageResourceStringName, RuleLevel ruleLevel, bool isPortedFxCopRule, bool isDataflowRule, bool isReportedAtCompilationEnd, string descriptionResourceStringName);
    public static bool IsOperationInsideAutogeneratedCodeForGuiApp(OperationAnalysisContext operationAnalysisContext, WellKnownTypeProvider wellKnownTypeProvider);
}
internal static class Microsoft.NetCore.Analyzers.Security.Helpers.SecurityMemberNames : object {
    [NullableAttribute("1")]
public static string CreateSignature;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.NetCore.Analyzers.Security.Helpers.XmlSerializationAttributeTypes : object {
    [CompilerGeneratedAttribute]
private bool <Any>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlAnyAttributeAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlAnyElementAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlArrayItemAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlAttributeAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlChoiceIdentifierAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlElementAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlEnumAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlIgnoreAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlIncludeAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlRootAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlTextAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlTypeAttribute>k__BackingField;
    public bool Any { get; private set; }
    public INamedTypeSymbol XmlAnyAttributeAttribute { get; private set; }
    public INamedTypeSymbol XmlAnyElementAttribute { get; private set; }
    public INamedTypeSymbol XmlArrayAttribute { get; private set; }
    public INamedTypeSymbol XmlArrayItemAttribute { get; private set; }
    public INamedTypeSymbol XmlAttributeAttribute { get; private set; }
    public INamedTypeSymbol XmlChoiceIdentifierAttribute { get; private set; }
    public INamedTypeSymbol XmlElementAttribute { get; private set; }
    public INamedTypeSymbol XmlEnumAttribute { get; private set; }
    public INamedTypeSymbol XmlIgnoreAttribute { get; private set; }
    public INamedTypeSymbol XmlIncludeAttribute { get; private set; }
    public INamedTypeSymbol XmlRootAttribute { get; private set; }
    public INamedTypeSymbol XmlTextAttribute { get; private set; }
    public INamedTypeSymbol XmlTypeAttribute { get; private set; }
    [NullableContextAttribute("1")]
public XmlSerializationAttributeTypes(WellKnownTypeProvider wellKnownTypeProvider);
    [CompilerGeneratedAttribute]
public bool get_Any();
    [CompilerGeneratedAttribute]
private void set_Any(bool value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlAnyAttributeAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlAnyAttributeAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlAnyElementAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlAnyElementAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlArrayAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlArrayAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlArrayItemAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlArrayItemAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlAttributeAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlAttributeAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlChoiceIdentifierAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlChoiceIdentifierAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlElementAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlElementAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlEnumAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlEnumAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlIgnoreAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlIgnoreAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlIncludeAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlIncludeAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlRootAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlRootAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlTextAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlTextAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlTypeAttribute();
    [CompilerGeneratedAttribute]
private void set_XmlTypeAttribute(INamedTypeSymbol value);
    [NullableContextAttribute("1")]
public bool HasAnyAttribute(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.JsonNetTypeNameHandling : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static JsonNetTypeNameHandling();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.PotentialReferenceCycleInDeserializedObjectGraph : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static PotentialReferenceCycleInDeserializedObjectGraph();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
internal static HashSet`1<ITypeSymbol> <Initialize>g__GetAssociatedTypes|5_4(ITypeSymbol type);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__AddLine|5_5(ISymbol from, ISymbol to, ConcurrentDictionary`2<ISymbol, int> degree, ConcurrentDictionary`2<ISymbol, ConcurrentDictionary`2<ISymbol, bool>> graph);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__AddPoint|5_6(ISymbol point, ConcurrentDictionary`2<ISymbol, int> degree, ConcurrentDictionary`2<ISymbol, ConcurrentDictionary`2<ISymbol, bool>> graph);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__ModifyDegree|5_9(ConcurrentDictionary`2<ISymbol, int> degree, ConcurrentDictionary`2<ISymbol, ConcurrentDictionary`2<ISymbol, bool>> graph);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForCommandExecutionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForCommandExecutionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForDllInjectionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForDllInjectionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForFilePathInjectionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForFilePathInjectionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForInformationDisclosureVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForInformationDisclosureVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForLdapInjectionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForLdapInjectionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForOpenRedirectVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForOpenRedirectVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForRegexInjectionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForRegexInjectionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForSqlInjectionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForSqlInjectionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForXamlInjectionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForXamlInjectionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForXmlInjectionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForXmlInjectionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForXPathInjectionVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForXPathInjectionVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.ReviewCodeForXssVulnerabilities : SourceTriggeredTaintedDataAnalyzerBase {
    internal static DiagnosticDescriptor Rule;
    protected SinkKind SinkKind { get; }
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    private static ReviewCodeForXssVulnerabilities();
    protected virtual SinkKind get_SinkKind();
    protected virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetCore.Analyzers.Security.SetHttpOnlyForHttpCookie : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ConstructorMapper ConstructorMapper;
    private static PropertyMapperCollection PropertyMappers;
    private static HazardousUsageEvaluatorCollection HazardousUsageEvaluators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SetHttpOnlyForHttpCookie();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__7_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.SetViewStateUserKey : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SetViewStateUserKey();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Security.SourceTriggeredTaintedDataAnalyzerBase : DiagnosticAnalyzer {
    protected DiagnosticDescriptor TaintedDataEnteringSinkDescriptor { get; }
    protected SinkKind SinkKind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected abstract virtual DiagnosticDescriptor get_TaintedDataEnteringSinkDescriptor();
    protected abstract virtual SinkKind get_SinkKind();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext compilationContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.SslProtocolsAnalyzer : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DeprecatedRule;
    internal static DiagnosticDescriptor HardcodedRule;
    private ImmutableHashSet`1<string> HardcodedSslProtocolsMetadataNames;
    private static int UnsafeBits;
    private static int HardcodedBits;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static SslProtocolsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__8_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseAutoValidateAntiforgeryToken : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor UseAutoValidateAntiforgeryTokenRule;
    internal static DiagnosticDescriptor MissHttpVerbAttributeRule;
    private static Regex s_AntiForgeryAttributeRegex;
    private static Regex s_AntiForgeryRegex;
    private static ImmutableHashSet`1<string> HttpVerbAttributesMarkingOnActionModifyingMethods;
    private static bool placeholder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseAutoValidateAntiforgeryToken();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseContainerLevelAccessPolicy : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<ValueTuple`2<string, string>> NamespaceAndPolicyIdentifierNamePairs;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseContainerLevelAccessPolicy();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseDefaultDllImportSearchPathsAttribute : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor UseDefaultDllImportSearchPathsAttributeRule;
    internal static DiagnosticDescriptor DoNotUseUnsafeDllImportSearchPathRule;
    private static int UnsafeBits;
    private static int LegacyBehavior;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseDefaultDllImportSearchPathsAttribute();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseRSAWithSufficientKeySize : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    private static ImmutableHashSet`1<string> s_RSAAlgorithmNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseRSAWithSufficientKeySize();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseSecureCookiesASPNetCore : DiagnosticAnalyzer {
    internal static DiagnosticDescriptor DefinitelyUseSecureCookiesASPNetCoreRule;
    internal static DiagnosticDescriptor MaybeUseSecureCookiesASPNetCoreRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ConstructorMapper constructorMapper;
    private static PropertyMapperCollection PropertyMappers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseSecureCookiesASPNetCore();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static HazardousUsageEvaluationResult HazardousUsageCallback(IMethodSymbol methodSymbol, PropertySetAbstractValue propertySetAbstractValue);
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseSharedAccessProtocolHttpsOnly : DiagnosticAnalyzer {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static int SharedAccessProtocolHttpsOnly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseSharedAccessProtocolHttpsOnly();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__6_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Security.UseXmlReaderBase : DiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private static LocalizableString <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private static LocalizableString <Message>k__BackingField;
    protected string TypeMetadataName { get; }
    protected string MethodMetadataName { get; }
    protected DiagnosticDescriptor Rule { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    protected static LocalizableString Description { get; }
    protected static LocalizableString Message { get; }
    private static UseXmlReaderBase();
    protected abstract virtual string get_TypeMetadataName();
    protected abstract virtual string get_MethodMetadataName();
    protected abstract virtual DiagnosticDescriptor get_Rule();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [CompilerGeneratedAttribute]
protected static LocalizableString get_Description();
    [CompilerGeneratedAttribute]
protected static LocalizableString get_Message();
    public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__14_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseXmlReaderForDataSetReadXml : UseXmlReaderBase {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor RealRule;
    protected string TypeMetadataName { get; }
    protected string MethodMetadataName { get; }
    protected DiagnosticDescriptor Rule { get; }
    private static UseXmlReaderForDataSetReadXml();
    protected virtual string get_TypeMetadataName();
    protected virtual string get_MethodMetadataName();
    protected virtual DiagnosticDescriptor get_Rule();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseXmlReaderForDeserialize : UseXmlReaderBase {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor RealRule;
    protected string TypeMetadataName { get; }
    protected string MethodMetadataName { get; }
    protected DiagnosticDescriptor Rule { get; }
    private static UseXmlReaderForDeserialize();
    protected virtual string get_TypeMetadataName();
    protected virtual string get_MethodMetadataName();
    protected virtual DiagnosticDescriptor get_Rule();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseXmlReaderForSchemaRead : UseXmlReaderBase {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor RealRule;
    protected string TypeMetadataName { get; }
    protected string MethodMetadataName { get; }
    protected DiagnosticDescriptor Rule { get; }
    private static UseXmlReaderForSchemaRead();
    protected virtual string get_TypeMetadataName();
    protected virtual string get_MethodMetadataName();
    protected virtual DiagnosticDescriptor get_Rule();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseXmlReaderForValidatingReader : UseXmlReaderBase {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor RealRule;
    protected string TypeMetadataName { get; }
    protected string MethodMetadataName { get; }
    protected DiagnosticDescriptor Rule { get; }
    private static UseXmlReaderForValidatingReader();
    protected virtual string get_TypeMetadataName();
    protected virtual string get_MethodMetadataName();
    protected virtual DiagnosticDescriptor get_Rule();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Security.UseXmlReaderForXPathDocument : UseXmlReaderBase {
    internal static string DiagnosticId;
    internal static DiagnosticDescriptor RealRule;
    protected string TypeMetadataName { get; }
    protected string MethodMetadataName { get; }
    protected DiagnosticDescriptor Rule { get; }
    private static UseXmlReaderForXPathDocument();
    protected virtual string get_TypeMetadataName();
    protected virtual string get_MethodMetadataName();
    protected virtual DiagnosticDescriptor get_Rule();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Tasks.DoNotCreateTaskCompletionSourceWithWrongArguments : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCreateTaskCompletionSourceWithWrongArguments();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Tasks.DoNotCreateTaskCompletionSourceWithWrongArgumentsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Tasks.DoNotCreateTaskCompletionSourceWithWrongArgumentsFixer/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<SyntaxNode, IFieldSymbol> <RegisterCodeFixesAsync>g__GetTaskCreationOptionsField|4_0(CodeFixContext context, SyntaxNode root, SemanticModel model, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Tasks.DoNotCreateTasksWithoutPassingATaskSchedulerAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCreateTasksWithoutPassingATaskSchedulerAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private static bool IsMethodOfInterest(IMethodSymbol methodSymbol, INamedTypeSymbol taskType, INamedTypeSymbol taskFactoryType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Tasks.DoNotCreateTasksWithoutPassingATaskSchedulerFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Tasks.DoNotUseConfigureAwaitWithSuppressThrowing : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseConfigureAwaitWithSuppressThrowing();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Tasks.DoNotUseWhenAllOrWaitAllWithSingleArgument : DiagnosticAnalyzer {
    internal static string WhenAllRuleId;
    internal static string WaitAllRuleId;
    internal static DiagnosticDescriptor WhenAllRule;
    internal static DiagnosticDescriptor WaitAllRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseWhenAllOrWaitAllWithSingleArgument();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private static bool IsWhenOrWaitAllMethod(IMethodSymbol targetMethod, INamedTypeSymbol taskType);
    private static bool IsSingleTaskArgument(IInvocationOperation invocation, INamedTypeSymbol taskType, INamedTypeSymbol genericTaskType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class Microsoft.NetCore.Analyzers.Tasks.DoNotUseWhenAllOrWaitAllWithSingleArgumentFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.NetCore.Analyzers.Tasks.DoNotUseWhenAllOrWaitAllWithSingleArgumentFixer/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool IsValueStored(IInvocationOperation operation);
    private static SyntaxNode GetSingleArgumentSyntax(IInvocationOperation operation);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Tasks.UseValueTasksCorrectlyAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    private static LocalizableString s_localizableDescription;
    internal static DiagnosticDescriptor GeneralRule;
    internal static DiagnosticDescriptor UnconsumedRule;
    internal static DiagnosticDescriptor DoubleConsumptionRule;
    internal static DiagnosticDescriptor AccessingIncompleteResultRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static UseValueTasksCorrectlyAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
    private static void HandleAtypicalValueTaskUsage(OperationAnalysisContext operationContext, INamedTypeSymbol debugType, IOperation operation, IInvocationOperation invocation);
    [NullableContextAttribute("2")]
private static bool TryGetLocalSymbolAssigned(IOperation operation, ISymbol& symbol, BasicBlock& startingBlock);
    private static int CountConsumptions(BasicBlock block, ISymbol valueTaskSymbol);
    private static int FindFirstAssertsCompletion(BasicBlock block, ISymbol valueTaskSymbol, INamedTypeSymbol debugType);
    private static int FindFirstDirectResultAccess(BasicBlock block, ISymbol valueTaskSymbol);
    private static Nullable`1<bool> OperationImpliesCompletion(ISymbol valueTaskSymbol, IOperation op);
    private static bool IsLocalOrParameterSymbolReference(IOperation op, ISymbol valueTaskSymbol);
    [CompilerGeneratedAttribute]
internal static void <HandleAtypicalValueTaskUsage>g__HandleSuccessor|11_0(BasicBlock successor, bool setKnownCompletion, <>c__DisplayClass11_0& , <>c__DisplayClass11_1& , <>c__DisplayClass11_2& );
    [CompilerGeneratedAttribute]
internal static bool <FindFirstDirectResultAccess>g__HasDirectResultAccess|16_0(IOperation op, <>c__DisplayClass16_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <OperationImpliesCompletion>g__IsCompletedReference|17_0(IPropertyReferenceOperation prop, <>c__DisplayClass17_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetCore.Analyzers.Usage.ImplementGenericMathInterfacesCorrectly : DiagnosticAnalyzer {
    private static string RuleId;
    internal static DiagnosticDescriptor GMIRule;
    private static ImmutableHashSet`1<string> s_knownInterfaces;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ImplementGenericMathInterfacesCorrectly();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private void AnalyzeSymbol(SymbolAnalysisContext context, INamedTypeSymbol symbol, INamespaceSymbol systemNS, INamespaceSymbol systemNumericsNS);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor GMIRule, SyntaxNode parameter, string genericDeclaration, string parameterName, INamedTypeSymbol symbol);
    protected abstract virtual SyntaxNode FindTheTypeArgumentOfTheInterfaceFromTypeDeclaration(ISymbol typeSymbol, ISymbol theInterfaceSymbol);
    private static bool IsKnownInterface(INamedTypeSymbol anInterface, INamespaceSymbol systemNS, INamespaceSymbol systemNumericsNS);
    private static bool FirstTypeParameterNameIsNotTheSymbolName(INamedTypeSymbol symbol, INamedTypeSymbol anInterface);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeSymbol>g__IsKnownInterfaceInTheChain|6_0(INamedTypeSymbol anInterface, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeSymbol>g__NotConstrainedToTheInterfaceOrSelf|6_1(INamedTypeSymbol anInterface, INamedTypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetCore.Analyzers.Usage.ProvideCorrectArgumentToEnumHasFlag : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor DifferentTypeRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static ProvideCorrectArgumentToEnumHasFlag();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static string GetArgumentTypeName(IConversionOperation conversion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.AvoidDuplicateAcceleratorsAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.AvoidDuplicateAcceleratorsFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.CallBaseClassMethodsOnISerializableTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.CallBaseClassMethodsOnISerializableTypesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.NetFramework.Analyzers.DoNotCatchCorruptedStateExceptionsAnalyzer : DoNotCatchGeneralUnlessRethrownAnalyzer {
    internal static string RuleId;
    private static string MethodAttributeTypeName;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotCatchCorruptedStateExceptionsAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    protected virtual Diagnostic CreateDiagnostic(IMethodSymbol containingMethod, SyntaxToken catchKeyword);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.DoNotMarkServicedComponentsWithWebMethodAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.DoNotMarkServicedComponentsWithWebMethodFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.Analyzers.DoNotUseInsecureDtdProcessingAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor RuleXmlDocumentWithNoSecureResolver;
    internal static DiagnosticDescriptor RuleXmlTextReaderConstructedWithNoSecureResolution;
    internal static DiagnosticDescriptor RuleDoNotUseDtdProcessingOverloads;
    internal static DiagnosticDescriptor RuleXmlReaderCreateWrongOverload;
    internal static DiagnosticDescriptor RuleXmlReaderCreateInsecureInput;
    internal static DiagnosticDescriptor RuleXmlReaderCreateInsecureConstructed;
    internal static DiagnosticDescriptor RuleXmlTextReaderSetInsecureResolution;
    internal static DiagnosticDescriptor RuleDoNotUseSetInnerXml;
    internal static DiagnosticDescriptor RuleReviewDtdProcessingProperties;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureDtdProcessingAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static void RegisterAnalyzer(OperationBlockStartAnalysisContext context, CompilationSecurityTypes types, Version frameworkVersion);
    public virtual void Initialize(AnalysisContext context);
    private static bool ReferencesAnyTargetType(CompilationSecurityTypes types);
    private static DiagnosticDescriptor CreateDiagnosticDescriptor(LocalizableResourceString messageFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.Analyzers.DoNotUseInsecureDtdProcessingInApiDesignAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor RuleDoNotUseInsecureDtdProcessingInApiDesign;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureDtdProcessingInApiDesignAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static bool ReferencesAnyTargetType(CompilationSecurityTypes types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.Analyzers.DoNotUseInsecureXSLTScriptExecutionAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor RuleDoNotUseInsecureXSLTScriptExecution;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static DoNotUseInsecureXSLTScriptExecutionAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.NetFramework.Analyzers.Helpers.CompilationSecurityTypes : object {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <HandleProcessCorruptedStateExceptionsAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SystemObject>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SystemException>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <SystemSystemException>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XPathDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DataSet>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DataTable>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlNode>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DataViewManager>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlTextReader>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlReader>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <DtdProcessing>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlReaderSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XslCompiledTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XmlSecureResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <XsltSettings>k__BackingField;
    public INamedTypeSymbol HandleProcessCorruptedStateExceptionsAttribute { get; private set; }
    public INamedTypeSymbol SystemObject { get; private set; }
    public INamedTypeSymbol SystemException { get; private set; }
    public INamedTypeSymbol SystemSystemException { get; private set; }
    public INamedTypeSymbol XmlDocument { get; private set; }
    public INamedTypeSymbol XPathDocument { get; private set; }
    public INamedTypeSymbol XmlSchema { get; private set; }
    public INamedTypeSymbol DataSet { get; private set; }
    public INamedTypeSymbol XmlSerializer { get; private set; }
    public INamedTypeSymbol DataTable { get; private set; }
    public INamedTypeSymbol XmlNode { get; private set; }
    public INamedTypeSymbol DataViewManager { get; private set; }
    public INamedTypeSymbol XmlTextReader { get; private set; }
    public INamedTypeSymbol XmlReader { get; private set; }
    public INamedTypeSymbol DtdProcessing { get; private set; }
    public INamedTypeSymbol XmlReaderSettings { get; private set; }
    public INamedTypeSymbol XslCompiledTransform { get; private set; }
    public INamedTypeSymbol XmlResolver { get; private set; }
    public INamedTypeSymbol XmlSecureResolver { get; private set; }
    public INamedTypeSymbol XsltSettings { get; private set; }
    [NullableContextAttribute("1")]
public CompilationSecurityTypes(Compilation compilation);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_HandleProcessCorruptedStateExceptionsAttribute();
    [CompilerGeneratedAttribute]
private void set_HandleProcessCorruptedStateExceptionsAttribute(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SystemObject();
    [CompilerGeneratedAttribute]
private void set_SystemObject(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SystemException();
    [CompilerGeneratedAttribute]
private void set_SystemException(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_SystemSystemException();
    [CompilerGeneratedAttribute]
private void set_SystemSystemException(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlDocument();
    [CompilerGeneratedAttribute]
private void set_XmlDocument(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XPathDocument();
    [CompilerGeneratedAttribute]
private void set_XPathDocument(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlSchema();
    [CompilerGeneratedAttribute]
private void set_XmlSchema(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_DataSet();
    [CompilerGeneratedAttribute]
private void set_DataSet(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlSerializer();
    [CompilerGeneratedAttribute]
private void set_XmlSerializer(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_DataTable();
    [CompilerGeneratedAttribute]
private void set_DataTable(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlNode();
    [CompilerGeneratedAttribute]
private void set_XmlNode(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_DataViewManager();
    [CompilerGeneratedAttribute]
private void set_DataViewManager(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlTextReader();
    [CompilerGeneratedAttribute]
private void set_XmlTextReader(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlReader();
    [CompilerGeneratedAttribute]
private void set_XmlReader(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_DtdProcessing();
    [CompilerGeneratedAttribute]
private void set_DtdProcessing(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlReaderSettings();
    [CompilerGeneratedAttribute]
private void set_XmlReaderSettings(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XslCompiledTransform();
    [CompilerGeneratedAttribute]
private void set_XslCompiledTransform(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlResolver();
    [CompilerGeneratedAttribute]
private void set_XmlResolver(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XmlSecureResolver();
    [CompilerGeneratedAttribute]
private void set_XmlSecureResolver(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_XsltSettings();
    [CompilerGeneratedAttribute]
private void set_XsltSettings(INamedTypeSymbol value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.NetFramework.Analyzers.Helpers.SecurityDiagnosticHelpers : object {
    [ExtensionAttribute]
public static bool IsXslCompiledTransformLoad(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXmlDocumentCtorDerived(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlDocumentXmlResolverProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXmlTextReaderCtorDerived(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlTextReaderXmlResolverPropertyDerived(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlTextReaderDtdProcessingPropertyDerived(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlTextReaderXmlResolverProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlTextReaderDtdProcessingProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXmlReaderSettingsCtor(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlReaderSettingsXmlResolverProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlReaderSettingsDtdProcessingProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlReaderSettingsMaxCharactersFromEntitiesProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXsltSettingsCtor(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXsltSettingsTrustedXsltProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXsltSettingsDefaultProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXsltSettingsEnableDocumentFunctionProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXsltSettingsEnableScriptProperty(IPropertySymbol symbol, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlResolverType(ITypeSymbol symbol, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static bool IsXmlSecureResolverType(ITypeSymbol symbol, CompilationSecurityTypes xmlTypes);
    public static bool IsXsltSettingsType(ITypeSymbol symbol, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlReaderSettingsType(ITypeSymbol symbol, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static int GetXmlResolverParameterIndex(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static int GetXsltSettingsParameterIndex(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    [ExtensionAttribute]
public static int GetXmlReaderSettingsParameterIndex(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    public static bool IsXmlReaderType(ITypeSymbol symbol, CompilationSecurityTypes xmlTypes);
    public static int HasXmlReaderParameter(IMethodSymbol method, CompilationSecurityTypes xmlTypes);
    [NullableContextAttribute("2")]
public static bool IsExpressionEqualsNull(IOperation operation);
    [NullableContextAttribute("2")]
public static bool IsExpressionEqualsDtdProcessingParse(IOperation operation);
    [NullableContextAttribute("2")]
public static bool IsExpressionEqualsIntZero(IOperation operation);
    [NullableContextAttribute("2")]
private static bool IsSpecifiedProperty(IPropertySymbol symbol, INamedTypeSymbol namedType, string propertyName);
    [NullableContextAttribute("2")]
private static bool IsSpecifiedPropertyDerived(IPropertySymbol symbol, INamedTypeSymbol namedType, string propertyName);
    private static int GetSpecifiedParameterIndex(IMethodSymbol method, CompilationSecurityTypes xmlTypes, Func`3<ITypeSymbol, CompilationSecurityTypes, bool> func);
    public static Nullable`1<bool> IsTypeDeclaredInExpectedAssembly(Compilation compilation, string typeName, string assemblyName);
    public static string GetNonEmptyParentName(SyntaxNode current, SemanticModel model, CancellationToken cancellationToken);
    public static string GetNonEmptyParentName(ISymbol symbol);
    [NullableContextAttribute("2")]
public static Version GetDotNetFrameworkVersion(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.Analyzers.MarkVerbHandlersWithValidateAntiforgeryTokenAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    private static LocalizableString s_localizableTitle;
    internal static DiagnosticDescriptor NoVerbsRule;
    internal static DiagnosticDescriptor NoVerbsNoTokenRule;
    internal static DiagnosticDescriptor GetAndTokenRule;
    internal static DiagnosticDescriptor GetAndOtherAndTokenRule;
    internal static DiagnosticDescriptor VerbsAndNoTokenRule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static MarkVerbHandlersWithValidateAntiforgeryTokenAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
internal static class Microsoft.NetFramework.Analyzers.MicrosoftNetFrameworkAnalyzersResources : object {
    [NullableAttribute("1")]
private static Type s_resourcesType;
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string AvoidDuplicateAcceleratorsTitle { get; }
    internal static string AvoidDuplicateAcceleratorsDescription { get; }
    internal static string AvoidDuplicateAcceleratorsMessage { get; }
    internal static string SetLocaleForDataTypesTitle { get; }
    internal static string SetLocaleForDataTypesDescription { get; }
    internal static string SetLocaleForDataTypesMessage { get; }
    internal static string DoNotMarkServicedComponentsWithWebMethodTitle { get; }
    internal static string DoNotMarkServicedComponentsWithWebMethodDescription { get; }
    internal static string DoNotMarkServicedComponentsWithWebMethodMessage { get; }
    internal static string CallBaseClassMethodsOnISerializableTypesTitle { get; }
    internal static string CallBaseClassMethodsOnISerializableTypesDescription { get; }
    internal static string CallBaseClassMethodsOnISerializableTypesMessage { get; }
    internal static string DoNotCatchCorruptedStateExceptions { get; }
    internal static string DoNotCatchCorruptedStateExceptionsDescription { get; }
    internal static string DoNotCatchCorruptedStateExceptionsMessage { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesTitle { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesDescription { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesMessageSystemXmlXmlDocument { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesMessageSystemApplicationException { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsCollectionBase { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsDictionaryBase { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsQueue { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsReadOnlyCollectionBase { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsSortedList { get; }
    internal static string TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsStack { get; }
    internal static string DoNotUseInsecureDtdProcessingDescription { get; }
    internal static string DoNotUseDtdProcessingOverloadsMessage { get; }
    internal static string DoNotUseSetInnerXmlMessage { get; }
    internal static string InsecureXmlDtdProcessing { get; }
    internal static string ReviewDtdProcessingPropertiesMessage { get; }
    internal static string XmlDocumentWithNoSecureResolverMessage { get; }
    internal static string XmlReaderCreateInsecureConstructedMessage { get; }
    internal static string XmlReaderCreateInsecureInputMessage { get; }
    internal static string XmlReaderCreateWrongOverloadMessage { get; }
    internal static string XmlTextReaderConstructedWithNoSecureResolutionMessage { get; }
    internal static string XmlTextReaderSetInsecureResolutionMessage { get; }
    internal static string DoNotUseInsecureDtdProcessingGenericMessage { get; }
    internal static string InsecureDtdProcessingInApiDesign { get; }
    internal static string DoNotUseInsecureDtdProcessingInApiDesignDescription { get; }
    internal static string XmlDocumentDerivedClassConstructorNoSecureXmlResolverMessage { get; }
    internal static string XmlDocumentDerivedClassNoConstructorMessage { get; }
    internal static string XmlDocumentDerivedClassSetInsecureXmlResolverInMethodMessage { get; }
    internal static string XmlTextReaderDerivedClassConstructorNoSecureSettingsMessage { get; }
    internal static string XmlTextReaderDerivedClassNoConstructorMessage { get; }
    internal static string XmlTextReaderDerivedClassSetInsecureSettingsInMethodMessage { get; }
    internal static string InsecureXsltScriptProcessingMessage { get; }
    internal static string DoNotUseInsecureXSLTScriptExecutionDescription { get; }
    internal static string XslCompiledTransformLoadInsecureConstructedMessage { get; }
    internal static string XslCompiledTransformLoadInsecureInputMessage { get; }
    internal static string MarkVerbHandlersWithValidateAntiforgeryTokenGetAndOtherAndTokenMessage { get; }
    internal static string MarkVerbHandlersWithValidateAntiforgeryTokenGetAndTokenMessage { get; }
    internal static string MarkVerbHandlersWithValidateAntiforgeryTokenNoVerbsMessage { get; }
    internal static string MarkVerbHandlersWithValidateAntiforgeryTokenNoVerbsNoTokenMessage { get; }
    internal static string MarkVerbHandlersWithValidateAntiforgeryTokenTitle { get; }
    internal static string MarkVerbHandlersWithValidateAntiforgeryTokenVerbsAndNoTokenMessage { get; }
    private static MicrosoftNetFrameworkAnalyzersResources();
    [NullableContextAttribute("1")]
public static LocalizableResourceString CreateLocalizableResourceString(string nameOfLocalizableResource);
    [NullableContextAttribute("1")]
public static LocalizableResourceString CreateLocalizableResourceString(string nameOfLocalizableResource, String[] formatArguments);
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_AvoidDuplicateAcceleratorsTitle();
    internal static string get_AvoidDuplicateAcceleratorsDescription();
    internal static string get_AvoidDuplicateAcceleratorsMessage();
    internal static string get_SetLocaleForDataTypesTitle();
    internal static string get_SetLocaleForDataTypesDescription();
    internal static string get_SetLocaleForDataTypesMessage();
    internal static string get_DoNotMarkServicedComponentsWithWebMethodTitle();
    internal static string get_DoNotMarkServicedComponentsWithWebMethodDescription();
    internal static string get_DoNotMarkServicedComponentsWithWebMethodMessage();
    internal static string get_CallBaseClassMethodsOnISerializableTypesTitle();
    internal static string get_CallBaseClassMethodsOnISerializableTypesDescription();
    internal static string get_CallBaseClassMethodsOnISerializableTypesMessage();
    internal static string get_DoNotCatchCorruptedStateExceptions();
    internal static string get_DoNotCatchCorruptedStateExceptionsDescription();
    internal static string get_DoNotCatchCorruptedStateExceptionsMessage();
    internal static string get_TypesShouldNotExtendCertainBaseTypesTitle();
    internal static string get_TypesShouldNotExtendCertainBaseTypesDescription();
    internal static string get_TypesShouldNotExtendCertainBaseTypesMessageSystemXmlXmlDocument();
    internal static string get_TypesShouldNotExtendCertainBaseTypesMessageSystemApplicationException();
    internal static string get_TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsCollectionBase();
    internal static string get_TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsDictionaryBase();
    internal static string get_TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsQueue();
    internal static string get_TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsReadOnlyCollectionBase();
    internal static string get_TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsSortedList();
    internal static string get_TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsStack();
    internal static string get_DoNotUseInsecureDtdProcessingDescription();
    internal static string get_DoNotUseDtdProcessingOverloadsMessage();
    internal static string get_DoNotUseSetInnerXmlMessage();
    internal static string get_InsecureXmlDtdProcessing();
    internal static string get_ReviewDtdProcessingPropertiesMessage();
    internal static string get_XmlDocumentWithNoSecureResolverMessage();
    internal static string get_XmlReaderCreateInsecureConstructedMessage();
    internal static string get_XmlReaderCreateInsecureInputMessage();
    internal static string get_XmlReaderCreateWrongOverloadMessage();
    internal static string get_XmlTextReaderConstructedWithNoSecureResolutionMessage();
    internal static string get_XmlTextReaderSetInsecureResolutionMessage();
    internal static string get_DoNotUseInsecureDtdProcessingGenericMessage();
    internal static string get_InsecureDtdProcessingInApiDesign();
    internal static string get_DoNotUseInsecureDtdProcessingInApiDesignDescription();
    internal static string get_XmlDocumentDerivedClassConstructorNoSecureXmlResolverMessage();
    internal static string get_XmlDocumentDerivedClassNoConstructorMessage();
    internal static string get_XmlDocumentDerivedClassSetInsecureXmlResolverInMethodMessage();
    internal static string get_XmlTextReaderDerivedClassConstructorNoSecureSettingsMessage();
    internal static string get_XmlTextReaderDerivedClassNoConstructorMessage();
    internal static string get_XmlTextReaderDerivedClassSetInsecureSettingsInMethodMessage();
    internal static string get_InsecureXsltScriptProcessingMessage();
    internal static string get_DoNotUseInsecureXSLTScriptExecutionDescription();
    internal static string get_XslCompiledTransformLoadInsecureConstructedMessage();
    internal static string get_XslCompiledTransformLoadInsecureInputMessage();
    internal static string get_MarkVerbHandlersWithValidateAntiforgeryTokenGetAndOtherAndTokenMessage();
    internal static string get_MarkVerbHandlersWithValidateAntiforgeryTokenGetAndTokenMessage();
    internal static string get_MarkVerbHandlersWithValidateAntiforgeryTokenNoVerbsMessage();
    internal static string get_MarkVerbHandlersWithValidateAntiforgeryTokenNoVerbsNoTokenMessage();
    internal static string get_MarkVerbHandlersWithValidateAntiforgeryTokenTitle();
    internal static string get_MarkVerbHandlersWithValidateAntiforgeryTokenVerbsAndNoTokenMessage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.NetFramework.Analyzers.SecurityMemberNames : object {
    public static string Create;
    public static string Load;
    public static string LoadXml;
    public static string Read;
    public static string ReadXml;
    public static string ReadXmlSchema;
    public static string Deserialize;
    public static string InnerXml;
    public static string DataViewSettingCollectionString;
    public static string DtdProcessing;
    public static string Parse;
    public static string XmlResolver;
    public static string TrustedXslt;
    public static string Default;
    public static string EnableDocumentFunction;
    public static string EnableScript;
    public static string MaxCharactersFromEntities;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.SetLocaleForDataTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.SetLocaleForDataTypesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.NetFramework.Analyzers.TypesShouldNotExtendCertainBaseTypesAnalyzer : DiagnosticAnalyzer {
    internal static string RuleId;
    internal static DiagnosticDescriptor Rule;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticDescriptor> <SupportedDiagnostics>k__BackingField;
    private static ImmutableDictionary`2<string, string> s_badBaseTypesToMessage;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static TypesShouldNotExtendCertainBaseTypesAnalyzer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeCompilationStart(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.NetFramework.Analyzers.TypesShouldNotExtendCertainBaseTypesFixer : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowImplicitBoxing { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitBoxing();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitBoxing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.ISetExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddRange(ISet`1<T> set, IEnumerable`1<T> values);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Immutable.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static int Count(ImmutableArray`1<TSource> source);
    [ExtensionAttribute]
public static bool HasExactly(ImmutableArray`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasMoreThan(ImmutableArray`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasFewerThan(ImmutableArray`1<TSource> source, int count);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Immutable.ImmutableHashSetExtensions : object {
    [ExtensionAttribute]
public static ImmutableHashSet`1<T> AddRange(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
    [ExtensionAttribute]
public static ImmutableHashSet`1<T> IntersectSet(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
    [ExtensionAttribute]
public static bool IsSubsetOfSet(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
    [ExtensionAttribute]
public static void AddIfNotNull(Builder<T> builder, T item);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[IsReadOnlyAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.StringCompatExtensions : object {
    [ExtensionAttribute]
public static bool Contains(string str, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static string Replace(string str, string oldValue, string newValue, StringComparison comparisonType);
}
