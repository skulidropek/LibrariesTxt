[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CodeStyle.VisualBasicFormattingAnalyzer : AbstractFormattingAnalyzer {
    protected ISyntaxFormatting SyntaxFormatting { get; }
    protected virtual ISyntaxFormatting get_SyntaxFormatting();
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeStyle.VisualBasicFormattingCodeFixProvider : AbstractFormattingCodeFixProvider {
    protected ISyntaxFormatting SyntaxFormatting { get; }
    protected virtual ISyntaxFormatting get_SyntaxFormatting();
}
internal class Microsoft.CodeAnalysis.Diagnostics.VisualBasicAnalyzerOptionsProvider : ValueType {
    private IOptionsReader _options;
    private IdeAnalyzerOptions _fallbackOptions;
    public CodeStyleOption2`1<string> PreferredModifierOrder { get; }
    public CodeStyleOption2`1<bool> PreferIsNotExpression { get; }
    public CodeStyleOption2`1<bool> PreferSimplifiedObjectCreation { get; }
    public CodeStyleOption2`1<UnusedValuePreference> UnusedValueExpressionStatement { get; }
    public CodeStyleOption2`1<UnusedValuePreference> UnusedValueAssignment { get; }
    private VisualBasicSimplifierOptions FallbackSimplifierOptions { get; }
    private VisualBasicIdeCodeStyleOptions FallbackCodeStyleOptions { get; }
    public VisualBasicAnalyzerOptionsProvider(IOptionsReader options, IdeAnalyzerOptions fallbackOptions);
    public VisualBasicAnalyzerOptionsProvider(IOptionsReader options, AnalyzerOptions fallbackOptions);
    public VisualBasicSimplifierOptions GetSimplifierOptions();
    public CodeStyleOption2`1<string> get_PreferredModifierOrder();
    public CodeStyleOption2`1<bool> get_PreferIsNotExpression();
    public CodeStyleOption2`1<bool> get_PreferSimplifiedObjectCreation();
    public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueExpressionStatement();
    public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueAssignment();
    private CodeStyleOption2`1<TValue> GetOption(Option2`1<CodeStyleOption2`1<TValue>> option, CodeStyleOption2`1<TValue> defaultValue);
    private VisualBasicSimplifierOptions get_FallbackSimplifierOptions();
    private VisualBasicIdeCodeStyleOptions get_FallbackCodeStyleOptions();
    public static VisualBasicAnalyzerOptionsProvider op_Explicit(AnalyzerOptionsProvider provider);
    public static AnalyzerOptionsProvider op_Implicit(VisualBasicAnalyzerOptionsProvider provider);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.VisualBasicAnalyzerOptionsProviders : object {
    [ExtensionAttribute]
public static VisualBasicAnalyzerOptionsProvider GetVisualBasicAnalyzerOptions(AnalyzerOptions options, SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static VisualBasicAnalyzerOptionsProvider GetVisualBasicAnalyzerOptions(SemanticModelAnalysisContext context);
    [ExtensionAttribute]
public static VisualBasicAnalyzerOptionsProvider GetVisualBasicAnalyzerOptions(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static VisualBasicAnalyzerOptionsProvider GetVisualBasicAnalyzerOptions(SyntaxTreeAnalysisContext context);
    [ExtensionAttribute]
public static VisualBasicAnalyzerOptionsProvider GetVisualBasicAnalyzerOptions(OperationAnalysisContext context);
    [ExtensionAttribute]
public static VisualBasicAnalyzerOptionsProvider GetVisualBasicAnalyzerOptions(CodeBlockAnalysisContext context);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.VisualBasic.KeywordHighlighting.PropertyBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportAttribute]
[SharedAttribute]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.IStructuralTypeDisplayService", "Visual Basic", "Default")]
internal class Microsoft.CodeAnalysis.Editor.VisualBasic.LanguageServices.VisualBasicStructuralTypeDisplayService : AbstractStructuralTypeDisplayService {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFactsService;
    protected ISyntaxFacts SyntaxFactsService { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFactsService();
    protected virtual ImmutableArray`1<SymbolDisplayPart> GetNormalAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
}
internal class Microsoft.CodeAnalysis.Editor.VisualBasic.LanguageServices.VisualBasicSymbolDisplayService : AbstractSymbolDisplayService {
    public VisualBasicSymbolDisplayService(LanguageServices provider);
    protected virtual AbstractSymbolDescriptionBuilder CreateDescriptionBuilder(SemanticModel semanticModel, int position, SymbolDescriptionOptions options, CancellationToken cancellationToken);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageService.ISymbolDisplayService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.VisualBasic.LanguageServices.VisualBasicSymbolDisplayServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LineSeparators.ILineSeparatorService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.VisualBasic.LineSeparators.VisualBasicLineSeparatorService : object {
    private static bool IsSeparableBlock(SyntaxNodeOrToken nodeOrToken);
    private bool IsSeparableContainer(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editor.VisualBasic.LineSeparators.VisualBasicLineSeparatorService/VB$StateMachine_3_GetLineSeparatorsAsync")]
public sealed virtual override Task`1<ImmutableArray`1<TextSpan>> GetLineSeparatorsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private static void ProcessNodeList(SyntaxList`1<T> children, ArrayBuilder`1<TextSpan> spans, CancellationToken token);
    private static void ProcessImports(SyntaxList`1<ImportsStatementSyntax> importsList, ArrayBuilder`1<TextSpan> spans);
    private static TextSpan GetLineSeparatorSpanForNode(SyntaxNode node);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.NavigationBar.INavigationBarItemService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.NavigationBar.VisualBasicNavigationBarItemService : AbstractNavigationBarItemService {
    private SymbolDisplayFormat _typeFormat;
    private SymbolDisplayFormat _memberFormat;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.NavigationBar.VisualBasicNavigationBarItemService/VB$StateMachine_3_GetItemsInCurrentProcessAsync")]
protected virtual Task`1<ImmutableArray`1<RoslynNavigationBarItem>> GetItemsInCurrentProcessAsync(Document document, bool workspaceSupportsDocumentChanges, CancellationToken cancellationToken);
    private static IEnumerable`1<Tuple`2<INamedTypeSymbol, SyntaxNode>> GetTypesAndDeclarationsInFile(SemanticModel semanticModel, CancellationToken cancellationToken);
    private ImmutableArray`1<RoslynNavigationBarItem> CreateItemsForType(Solution solution, INamedTypeSymbol type, int position, SemanticModel semanticModel, bool workspaceSupportsDocumentChanges, ISymbolDeclarationService symbolDeclarationService, CancellationToken cancellationToken);
    private static RoslynNavigationBarItem CreateItemForEnum(Solution solution, INamedTypeSymbol type, SyntaxTree tree, ISymbolDeclarationService symbolDeclarationService);
    private static SymbolItem CreateSymbolItem(Solution solution, ISymbol member, SyntaxTree tree, ISymbolDeclarationService symbolDeclarationService);
    private RoslynNavigationBarItem CreatePrimaryItemForType(Solution solution, INamedTypeSymbol type, SyntaxTree tree, bool workspaceSupportsDocumentChanges, ISymbolDeclarationService symbolDeclarationService, CancellationToken cancellationToken);
    private static bool IncludeMember(ISymbol symbol);
    private static RoslynNavigationBarItem CreateItemForEvents(Solution solution, INamedTypeSymbol containingType, int position, ITypeSymbol eventType, IPropertySymbol eventContainer, SemanticModel semanticModel, bool workspaceSupportsDocumentChanges, ISymbolDeclarationService symbolDeclarationService, CancellationToken cancellationToken);
    private IEnumerable`1<RoslynNavigationBarItem> CreateItemsForMemberGroup(Solution solution, IEnumerable`1<ISymbol> members, SyntaxTree tree, bool workspaceSupportsDocumentChanges, ISymbolDeclarationService symbolDeclarationService, CancellationToken cancellationToken);
    private static bool IsUnimplementedPartial(IMethodSymbol method);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Rename.IRenameIssuesService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Rename.VisualBasicRenameIssuesService : object {
    public sealed virtual override bool CheckLanguageSpecificIssues(SemanticModel semantic, ISymbol symbol, SyntaxToken triggerToken, String& langError);
}
internal class Microsoft.CodeAnalysis.VisualBasic.AddAccessibilityModifiers.VisualBasicAddAccessibilityModifiers : AbstractAddAccessibilityModifiers`1<StatementSyntax> {
    public static VisualBasicAddAccessibilityModifiers Instance;
    private static VisualBasicAddAccessibilityModifiers();
    public virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, StatementSyntax member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifiedAdded);
    private static bool MatchesDefaultAccessibility(Accessibility accessibility, StatementSyntax member);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddAccessibilityModifiers.VisualBasicAddAccessibilityModifiersCodeFixProvider : AbstractAddAccessibilityModifiersCodeFixProvider {
    protected virtual SyntaxNode MapToDeclarator(SyntaxNode declaration);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.AddAccessibilityModifiers.VisualBasicAddAccessibilityModifiersDiagnosticAnalyzer : AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1<CompilationUnitSyntax> {
    protected virtual void ProcessCompilationUnit(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, CompilationUnitSyntax compilationUnit);
    private void ProcessMembers(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, SyntaxList`1<StatementSyntax> members);
    private void ProcessMember(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, StatementSyntax member);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddAccessibilityModifiers.IAddAccessibilityModifiersService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddAccessibilityModifiers.VisualBasicAddAccessibilityModifiersService : VisualBasicAddAccessibilityModifiers {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddAnonymousTypeMemberName.VisualBasicAddAnonymousTypeMemberNameCodeFixProvider : AbstractAddAnonymousTypeMemberNameCodeFixProvider`3<ExpressionSyntax, ObjectMemberInitializerSyntax, FieldInitializerSyntax> {
    private static string BC36556;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool HasName(FieldInitializerSyntax declarator);
    protected virtual ExpressionSyntax GetExpression(FieldInitializerSyntax declarator);
    protected virtual FieldInitializerSyntax WithName(FieldInitializerSyntax declarator, SyntaxToken nameToken);
    protected virtual IEnumerable`1<string> GetAnonymousObjectMemberNames(ObjectMemberInitializerSyntax initializer);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddDebuggerDisplay.VisualBasicAddDebuggerDisplayCodeRefactoringProvider : AbstractAddDebuggerDisplayCodeRefactoringProvider`2<TypeBlockSyntax, MethodStatementSyntax> {
    [CompilerGeneratedAttribute]
private bool _CanNameofAccessNonPublicMembersFromAttributeArgument;
    protected bool CanNameofAccessNonPublicMembersFromAttributeArgument { get; }
    [CompilerGeneratedAttribute]
protected virtual bool get_CanNameofAccessNonPublicMembersFromAttributeArgument();
    protected virtual bool SupportsConstantInterpolatedStrings(Document document);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddFileBanner.VisualBasicAddFileBannerCodeRefactoringProvider : AbstractAddFileBannerCodeRefactoringProvider {
    protected virtual bool IsCommentStartCharacter(char ch);
    protected virtual SyntaxTrivia CreateTrivia(SyntaxTrivia trivia, string text);
}
[ExportNewDocumentFormattingProviderAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddFileBanner.VisualBasicAddFileBannerNewDocumentFormattingProvider : AbstractAddFileBannerNewDocumentFormattingProvider {
    [CompilerGeneratedAttribute]
private SyntaxGenerator _SyntaxGenerator;
    [CompilerGeneratedAttribute]
private SyntaxGeneratorInternal _SyntaxGeneratorInternal;
    [CompilerGeneratedAttribute]
private AbstractFileHeaderHelper _FileHeaderHelper;
    protected SyntaxGenerator SyntaxGenerator { get; }
    protected SyntaxGeneratorInternal SyntaxGeneratorInternal { get; }
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    [CompilerGeneratedAttribute]
protected virtual SyntaxGenerator get_SyntaxGenerator();
    [CompilerGeneratedAttribute]
protected virtual SyntaxGeneratorInternal get_SyntaxGeneratorInternal();
    [CompilerGeneratedAttribute]
protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddImport.AddImportDiagnosticIds : object {
    internal static string BC30002;
    internal static string BC30451;
    internal static string BC30456;
    internal static string BC32016;
    internal static string BC32042;
    internal static string BC36593;
    internal static string BC32045;
    internal static string BC30389;
    internal static string BC31504;
    internal static string BC36610;
    internal static string BC36719;
    internal static string BC30512;
    internal static string BC30390;
    internal static string BC42309;
    internal static string BC30182;
    internal static string BC36930;
    public static ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public static ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddImport.VisualBasicAddImportCodeFixProvider : AbstractAddImportCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal VisualBasicAddImportCodeFixProvider(IPackageInstallerService installerService, ISymbolSearchService searchService);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddImport.VisualBasicAddImportFeatureService : AbstractAddImportFeatureService`1<SimpleNameSyntax> {
    protected virtual bool CanAddImport(SyntaxNode node, bool allowInHiddenRegions, CancellationToken cancellationToken);
    protected virtual bool CanAddImportForMethod(string diagnosticId, ISyntaxFacts syntaxFacts, SyntaxNode node, SimpleNameSyntax& nameNode);
    protected virtual bool CanAddImportForNamespace(string diagnosticId, SyntaxNode node, SimpleNameSyntax& nameNode);
    protected virtual bool CanAddImportForDeconstruct(string diagnosticId, SyntaxNode node);
    protected virtual bool CanAddImportForGetAwaiter(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForGetEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForGetAsyncEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForQuery(string diagnosticId, SyntaxNode node);
    protected virtual bool CanAddImportForType(string diagnosticId, SyntaxNode node, SimpleNameSyntax& nameNode);
    private static bool CanAddImportForTypeOrNamespaceCore(SyntaxNode node, SimpleNameSyntax& nameNode);
    private static SimpleNameSyntax GetLeftMostSimpleName(QualifiedNameSyntax qn);
    protected virtual string GetDescription(IReadOnlyList`1<string> nameParts);
    protected virtual ValueTuple`2<string, bool> GetDescription(Document document, AddImportPlacementOptions options, INamespaceOrTypeSymbol symbol, SemanticModel semanticModel, SyntaxNode root, CancellationToken cancellationToken);
    private static ImportsStatementSyntax GetImportsStatement(INamespaceOrTypeSymbol symbol);
    private static ImportsStatementSyntax GetImportsStatement(NameSyntax nameSyntax);
    protected virtual ISet`1<INamespaceSymbol> GetImportNamespacesInScope(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetDeconstructInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetQueryClauseInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsValid(SymbolInfo info);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.AddImport.VisualBasicAddImportFeatureService/VB$StateMachine_20_AddImportAsync")]
protected virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, INamespaceOrTypeSymbol symbol, Document document, AddImportPlacementOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.AddImport.VisualBasicAddImportFeatureService/VB$StateMachine_21_AddImportAsync")]
private static Task`1<Document> AddImportAsync(SyntaxNode contextNode, Document document, ImportsStatementSyntax importsStatement, AddImportPlacementOptions options, CancellationToken cancellationToken);
    protected virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, IReadOnlyList`1<string> nameSpaceParts, Document document, AddImportPlacementOptions options, CancellationToken cancellationToken);
    private static NameSyntax CreateNameSyntax(IReadOnlyList`1<string> nameSpaceParts, int index);
    protected virtual bool IsViableExtensionMethod(IMethodSymbol method, SyntaxNode expression, SemanticModel semanticModel, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected virtual bool IsAddMethodContext(SyntaxNode node, SemanticModel semanticModel);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddMissingImports.VisualBasicAddMissingImportsFeatureService : AbstractAddMissingImportsFeatureService {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    protected ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ImmutableArray`1<AbstractFormattingRule> GetFormatRules(SourceText text);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddMissingReference.VisualBasicAddMissingReferenceCodeFixProvider : AbstractAddMissingReferenceCodeFixProvider {
    internal static string BC30005;
    internal static string BC30652;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddObsoleteAttribute.VisualBasicAddObsoleteAttributeCodeFixProvider : AbstractAddObsoleteAttributeCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddPackage.VisualBasicAddSpecificPackageCodeFixProvider : AbstractAddSpecificPackageCodeFixProvider {
    private static string BC37267;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetAssemblyName(string id);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddParameter.VisualBasicAddParameterCodeFixProvider : AbstractAddParameterCodeFixProvider`6<ArgumentSyntax, ArgumentSyntax, ArgumentListSyntax, ArgumentListSyntax, InvocationExpressionSyntax, ObjectCreationExpressionSyntax> {
    private static string BC30057;
    private static string BC30272;
    private static string BC30274;
    private static string BC30311;
    private static string BC30389;
    private static string BC30512;
    private static string BC32006;
    private static string BC30387;
    private static string BC30516;
    private static string BC36582;
    private static string BC36625;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _TooManyArgumentsDiagnosticIds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _CannotConvertDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected ImmutableArray`1<string> TooManyArgumentsDiagnosticIds { get; }
    protected ImmutableArray`1<string> CannotConvertDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<string> get_TooManyArgumentsDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<string> get_CannotConvertDiagnosticIds();
    protected virtual ITypeSymbol GetArgumentType(SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.AddRequiredParentheses.VisualBasicAddRequiredParenthesesForBinaryLikeExpressionDiagnosticAnalyzer : AbstractAddRequiredParenthesesDiagnosticAnalyzer`3<ExpressionSyntax, BinaryExpressionSyntax, SyntaxKind> {
    private static ImmutableArray`1<SyntaxKind> s_kinds;
    private static VisualBasicAddRequiredParenthesesForBinaryLikeExpressionDiagnosticAnalyzer();
    protected virtual ValueTuple`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> GetPartsOfBinaryLike(BinaryExpressionSyntax binaryLike);
    protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxNodeKinds();
    protected virtual int GetPrecedence(BinaryExpressionSyntax binary);
    protected virtual ExpressionSyntax TryGetAppropriateParent(BinaryExpressionSyntax binary);
    protected virtual bool IsBinaryLike(ExpressionSyntax node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AliasAmbiguousType.VisualBasicAliasAmbiguousTypeCodeFixProvider : AbstractAliasAmbiguousTypeCodeFixProvider {
    private static string BC30561;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetTextPreviewOfChange(string aliasName, ITypeSymbol typeSymbol);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.BraceCompletion.AbstractVisualBasicBraceCompletionService : AbstractBraceCompletionService {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
}
[ExportBraceCompletionServiceAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceCompletion.BracketBraceCompletionService : AbstractVisualBasicBraceCompletionService {
    [CompilerGeneratedAttribute]
private char _OpeningBrace;
    [CompilerGeneratedAttribute]
private char _ClosingBrace;
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    [CompilerGeneratedAttribute]
protected virtual char get_OpeningBrace();
    [CompilerGeneratedAttribute]
protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    private static bool IsBracketInCData(SyntaxToken token);
}
[ExportBraceCompletionServiceAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceCompletion.CurlyBraceCompletionService : AbstractVisualBasicBraceCompletionService {
    [CompilerGeneratedAttribute]
private char _OpeningBrace;
    [CompilerGeneratedAttribute]
private char _ClosingBrace;
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    [CompilerGeneratedAttribute]
protected virtual char get_OpeningBrace();
    [CompilerGeneratedAttribute]
protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
}
[ExportBraceCompletionServiceAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceCompletion.InterpolatedStringBraceCompletionService : AbstractVisualBasicBraceCompletionService {
    [CompilerGeneratedAttribute]
private char _OpeningBrace;
    [CompilerGeneratedAttribute]
private char _ClosingBrace;
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    [CompilerGeneratedAttribute]
protected virtual char get_OpeningBrace();
    [CompilerGeneratedAttribute]
protected virtual char get_ClosingBrace();
    protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    public static bool IsPositionInInterpolatedStringContext(ParsedDocument document, int position);
}
[ExportBraceCompletionServiceAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceCompletion.InterpolationBraceCompletionService : AbstractVisualBasicBraceCompletionService {
    [CompilerGeneratedAttribute]
private char _OpeningBrace;
    [CompilerGeneratedAttribute]
private char _ClosingBrace;
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    [CompilerGeneratedAttribute]
protected virtual char get_OpeningBrace();
    [CompilerGeneratedAttribute]
protected virtual char get_ClosingBrace();
    protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    public static bool IsPositionInInterpolationContext(ParsedDocument document, int position);
}
[ExportBraceCompletionServiceAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceCompletion.LessAndGreaterThanCompletionService : AbstractVisualBasicBraceCompletionService {
    [CompilerGeneratedAttribute]
private char _OpeningBrace;
    [CompilerGeneratedAttribute]
private char _ClosingBrace;
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    [CompilerGeneratedAttribute]
protected virtual char get_OpeningBrace();
    [CompilerGeneratedAttribute]
protected virtual char get_ClosingBrace();
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
}
[ExportBraceCompletionServiceAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceCompletion.ParenthesisBraceCompletionService : AbstractVisualBasicBraceCompletionService {
    [CompilerGeneratedAttribute]
private char _OpeningBrace;
    [CompilerGeneratedAttribute]
private char _ClosingBrace;
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    [CompilerGeneratedAttribute]
protected virtual char get_OpeningBrace();
    [CompilerGeneratedAttribute]
protected virtual char get_ClosingBrace();
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
}
[ExportBraceCompletionServiceAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceCompletion.StringLiteralBraceCompletionService : AbstractVisualBasicBraceCompletionService {
    [CompilerGeneratedAttribute]
private char _OpeningBrace;
    [CompilerGeneratedAttribute]
private char _ClosingBrace;
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    [CompilerGeneratedAttribute]
protected virtual char get_OpeningBrace();
    [CompilerGeneratedAttribute]
protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
}
internal class Microsoft.CodeAnalysis.VisualBasic.BraceMatching.AbstractVisualBasicBraceMatcher : AbstractBraceMatcher {
    protected AbstractVisualBasicBraceMatcher(SyntaxKind openBrace, SyntaxKind closeBrace);
}
[ExportBraceMatcherAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceMatching.InterpolatedStringBraceMatcher : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.BraceMatching.InterpolatedStringBraceMatcher/VB$StateMachine_1_FindBraces")]
public sealed virtual override Task`1<Nullable`1<BraceMatchingResult>> FindBraces(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
[ExportBraceMatcherAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceMatching.LessThanGreaterThanBraceMatcher : AbstractVisualBasicBraceMatcher {
    protected virtual bool AllowedForToken(SyntaxToken token);
}
[ExportBraceMatcherAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceMatching.OpenCloseBraceBraceMatcher : AbstractVisualBasicBraceMatcher {
}
[ExportBraceMatcherAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceMatching.OpenCloseParenBraceMatcher : AbstractVisualBasicBraceMatcher {
}
[ExportBraceMatcherAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceMatching.StringLiteralBraceMatcher : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.BraceMatching.StringLiteralBraceMatcher/VB$StateMachine_1_FindBraces")]
public sealed virtual override Task`1<Nullable`1<BraceMatchingResult>> FindBraces(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
[ExportBraceMatcherAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceMatching.VisualBasicDirectiveTriviaBraceMatcher : AbstractDirectiveTriviaBraceMatcher`7<DirectiveTriviaSyntax, IfDirectiveTriviaSyntax, IfDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax> {
    protected virtual ImmutableArray`1<DirectiveTriviaSyntax> GetMatchingConditionalDirectives(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    protected virtual DirectiveTriviaSyntax GetMatchingDirective(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    internal virtual TextSpan GetSpanForTagging(DirectiveTriviaSyntax directive);
}
[ExportBraceMatcherAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BraceMatching.VisualBasicEmbeddedLanguageBraceMatcher : AbstractEmbeddedLanguageBraceMatcher {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VisualBasicEmbeddedLanguageBraceMatcher(IEnumerable`1<Lazy`2<IEmbeddedLanguageBraceMatcher, EmbeddedLanguageMetadata>> services);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.BracePairs.IBracePairsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BracePairs.VisualBasicBracePairsService : AbstractBracePairsService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ChangeNamespace.VisualBasicChangeNamespaceService : AbstractChangeNamespaceService`3<NamespaceStatementSyntax, CompilationUnitSyntax, StatementSyntax> {
    public virtual bool TryGetReplacementReferenceSyntax(SyntaxNode reference, ImmutableArray`1<string> newNamespaceParts, ISyntaxFactsService syntaxFacts, SyntaxNode& old, SyntaxNode& new);
    protected virtual Task`1<ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>>> GetValidContainersFromAllLinkedDocumentsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    protected virtual CompilationUnitSyntax ChangeNamespaceDeclaration(CompilationUnitSyntax root, ImmutableArray`1<string> declaredNamespaceParts, ImmutableArray`1<string> targetNamespaceParts);
    protected virtual SyntaxList`1<StatementSyntax> GetMemberDeclarationsInContainer(SyntaxNode container);
    protected virtual Task`1<SyntaxNode> TryGetApplicableContainerFromSpanAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected virtual string GetDeclaredNamespace(SyntaxNode container);
    private static NameSyntax CreateNamespaceAsQualifiedName(ImmutableArray`1<string> namespaceParts, int index);
    private static ExpressionSyntax CreateNamespaceAsMemberAccess(ImmutableArray`1<string> namespaceParts, int index);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ChangeSignature.ChangeSignatureFormattingRule : BaseFormattingRule {
    public virtual void AddIndentBlockOperationsSlow(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
    private static void AddChangeSignatureIndentOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustNewLinesOperation& nextOperation);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ChangeSignature.UnifiedArgumentSyntax : object {
    private ArgumentSyntax _argument;
    private bool IsDefault { get; }
    private bool IsNamed { get; }
    private UnifiedArgumentSyntax(ArgumentSyntax argument);
    public static IUnifiedArgumentSyntax Create(ArgumentSyntax argument);
    private sealed virtual override bool get_IsDefault();
    private sealed virtual override bool get_IsNamed();
    public static ArgumentSyntax op_Implicit(UnifiedArgumentSyntax unified);
    public sealed virtual override string GetName();
    private sealed virtual override IUnifiedArgumentSyntax WithName(string name);
    public sealed virtual override IUnifiedArgumentSyntax WithAdditionalAnnotations(SyntaxAnnotation annotation);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ChangeSignature.VisualBasicChangeSignatureService : AbstractChangeSignatureService {
    private static ImmutableArray`1<SyntaxKind> _declarationKinds;
    private static ImmutableArray`1<SyntaxKind> _declarationAndInvocableKinds;
    private static ImmutableArray`1<SyntaxKind> _nodeKindsToIgnore;
    private static ImmutableArray`1<SyntaxKind> _updatableNodeKinds;
    private static ImmutableArray`1<SyntaxKind> _updatableAncestorKinds;
    private Func`2<AddedParameter, ParameterSyntax> s_createNewParameterSyntaxDelegate;
    private Func`2<AddedParameter, CrefSignaturePartSyntax> s_createNewCrefParameterSyntaxDelegate;
    protected SyntaxGenerator Generator { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    private static VisualBasicChangeSignatureService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ChangeSignature.VisualBasicChangeSignatureService/VB$StateMachine_9_GetInvocationSymbolAsync")]
public virtual Task`1<ValueTuple`2<ISymbol, int>> GetInvocationSymbolAsync(Document document, int position, bool restrictToDeclarations, CancellationToken cancellationToken);
    private static int TryGetSelectedIndexFromDeclaration(int position, SyntaxNode matchingNode);
    private static SyntaxNode GetMatchingNode(SyntaxNode node, bool restrictToDeclarations);
    private static bool IsInSymbolHeader(SyntaxNode matchingNode, int position);
    private static ISymbol TryGetDeclaredSymbol(SemanticModel semanticModel, SyntaxNode matchingNode, CancellationToken cancellationToken);
    public virtual SyntaxNode FindNodeToUpdate(Document document, SyntaxNode node);
    private static SyntaxNode GetNodeContainingTargetNode(SyntaxNode originalNode, SyntaxNode matchingNode);
    private static SyntaxNode GetUpdatableNode(SyntaxNode matchingNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ChangeSignature.VisualBasicChangeSignatureService/VB$StateMachine_17_ChangeSignatureAsync")]
public virtual Task`1<SyntaxNode> ChangeSignatureAsync(Document document, ISymbol declarationSymbol, SyntaxNode potentiallyUpdatedNode, SyntaxNode originalNode, SignatureChange updatedSignature, LineFormattingOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ChangeSignature.VisualBasicChangeSignatureService/VB$StateMachine_18_UpdateArgumentListAsync")]
private Task`1<ArgumentListSyntax> UpdateArgumentListAsync(ISymbol declarationSymbol, SignatureChange signaturePermutation, ArgumentListSyntax argumentList, bool isReducedExtensionMethod, bool isParamsArrayExpanded, bool generateAttributeArguments, Document document, int position, CancellationToken cancellationToken);
    private static bool IsParamsArrayExpanded(SemanticModel semanticModel, SyntaxNode node, SymbolInfo symbolInfo, CancellationToken cancellationToken);
    private static void GetArgumentListDetailsRegardingParamsArrays(ArgumentListSyntax argumentList, Int32& argumentCount, Boolean& lastArgumentIsNamed, ExpressionSyntax& lastArgumentExpression);
    private SeparatedSyntaxList`1<ArgumentSyntax> PermuteArgumentList(SeparatedSyntaxList`1<ArgumentSyntax> arguments, SignatureChange permutedSignature, ISymbol declarationSymbol, bool isReducedExtensionMethod);
    private SeparatedSyntaxList`1<T> UpdateDeclaration(SeparatedSyntaxList`1<T> parameterList, SignatureChange updatedSignature, Func`2<AddedParameter, T> createNewParameterMethod);
    private static ParameterSyntax CreateNewParameterSyntax(AddedParameter addedParameter);
    private static CrefSignaturePartSyntax CreateNewCrefParameterSyntax(AddedParameter addedParameter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ChangeSignature.VisualBasicChangeSignatureService/VB$StateMachine_25_UpdateParamNodesInLeadingTriviaAsync")]
private Task`1<ImmutableArray`1<SyntaxTrivia>> UpdateParamNodesInLeadingTriviaAsync(Document document, VisualBasicSyntaxNode node, ISymbol declarationSymbol, SignatureChange updatedSignature, LineFormattingOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private ImmutableArray`1<SyntaxNode> VerifyAndPermuteParamNodes(ImmutableArray`1<XmlElementSyntax> paramNodes, ISymbol declarationSymbol, SignatureChange updatedSignature);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ChangeSignature.VisualBasicChangeSignatureService/VB$StateMachine_27_DetermineCascadedSymbolsFromDelegateInvokeAsync")]
public virtual Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsFromDelegateInvokeAsync(IMethodSymbol method, Document document, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected virtual T TransferLeadingWhitespaceTrivia(T newArgument, SyntaxNode oldArgument);
    protected virtual SyntaxGenerator get_Generator();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual TArgumentSyntax CreateExplicitParamsArrayFromIndividualArguments(SeparatedSyntaxList`1<TArgumentSyntax> newArguments, int indexInExistingList, IParameterSymbol parameterSymbol);
    protected virtual TArgumentSyntax AddNameToArgument(TArgumentSyntax newArgument, string name);
    protected virtual bool SupportsOptionalAndParamsArrayParametersSimultaneously();
    protected virtual SyntaxToken CommaTokenWithElasticSpace();
    protected virtual bool TryGetRecordPrimaryConstructor(INamedTypeSymbol typeSymbol, IMethodSymbol& primaryConstructor);
    protected virtual ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol declarationSymbol);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Classification.IEmbeddedLanguageClassificationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.VisualBasicEmbeddedLanguageClassificationService : AbstractEmbeddedLanguageClassificationService {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VisualBasicEmbeddedLanguageClassificationService(IEnumerable`1<Lazy`2<IEmbeddedLanguageClassifier, EmbeddedLanguageMetadata>> classifiers);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.VisualBasicFallbackEmbeddedLanguageClassifier : AbstractFallbackEmbeddedLanguageClassifier {
    public static VisualBasicFallbackEmbeddedLanguageClassifier Instance;
    private static VisualBasicFallbackEmbeddedLanguageClassifier();
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeActions.RemoveStatementCodeAction : CodeAction {
    private Document _document;
    private SyntaxNode _node;
    private string _title;
    public string Title { get; }
    public RemoveStatementCodeAction(Document document, SyntaxNode node, string title);
    public virtual string get_Title();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeActions.RemoveStatementCodeAction/VB$StateMachine_6_GetChangedDocumentAsync")]
protected virtual Task`1<Document> GetChangedDocumentAsync(CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.AddExplicitCast.VisualBasicAddExplicitCastCodeFixProvider : AbstractAddExplicitCastCodeFixProvider`1<ExpressionSyntax> {
    internal static string BC30512;
    internal static string BC42016;
    internal static string BC30518;
    internal static string BC30519;
    private ArgumentFixer _fixer;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual void GetPartsOfCastOrConversionExpression(ExpressionSyntax expression, SyntaxNode& type, SyntaxNode& castedExpression);
    protected virtual ExpressionSyntax Cast(ExpressionSyntax expression, ITypeSymbol type);
    protected virtual bool TryGetTargetTypeInfo(Document document, SemanticModel semanticModel, SyntaxNode root, string diagnosticId, ExpressionSyntax spanNode, CancellationToken cancellationToken, ImmutableArray`1& potentialConversionTypes);
    private static ArgumentSyntax GetTargetArgument(Document document, SemanticModel SemanticModel, ImmutableArray`1<IParameterSymbol> parameters, SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    private ImmutableArray`1<ValueTuple`2<ExpressionSyntax, ITypeSymbol>> GetPotentialConversionTypesWithInvocationNode(Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode invocationNode, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.ConvertToAsync.VisualBasicConvertToAsyncFunctionCodeFixProvider : AbstractConvertToAsyncCodeFixProvider {
    internal static string BC37001;
    internal ImmutableArray`1<string> Ids;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.ConvertToAsync.VisualBasicConvertToAsyncFunctionCodeFixProvider/VB$StateMachine_5_GetDescriptionAsync")]
protected virtual Task`1<string> GetDescriptionAsync(Diagnostic diagnostic, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.ConvertToAsync.VisualBasicConvertToAsyncFunctionCodeFixProvider/VB$StateMachine_6_GetRootInOtherSyntaxTreeAsync")]
protected virtual Task`1<Tuple`2<SyntaxTree, SyntaxNode>> GetRootInOtherSyntaxTreeAsync(SyntaxNode node, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.ConvertToAsync.VisualBasicConvertToAsyncFunctionCodeFixProvider/VB$StateMachine_7_GetMethodFromExpressionAsync")]
private static Task`1<Tuple`2<SyntaxNode, MethodBlockSyntax>> GetMethodFromExpressionAsync(SyntaxNode oldNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static MethodBlockSyntax ConvertToAsyncFunction(MethodBlockSyntax methodBlock);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.CorrectNextControlVariable.CorrectNextControlVariableCodeFixProvider : CodeFixProvider {
    internal static string BC30070;
    internal static string BC30451;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.CorrectNextControlVariable.CorrectNextControlVariableCodeFixProvider/VB$StateMachine_7_RegisterCodeFixesAsync")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Nullable`1<SyntaxToken> FindControlVariable(NextStatementSyntax nextStatement, int nestingLevel);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.FullyQualify.VisualBasicFullyQualifyCodeFixProvider : AbstractFullyQualifyCodeFixProvider {
    private static string BC30002;
    private static string BC30451;
    private static string BC30561;
    private static string BC40056;
    private static string BC32045;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.IFullyQualifyService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.FullyQualify.VisualBasicFullyQualifyService : AbstractFullyQualifyService`1<SimpleNameSyntax> {
    protected virtual bool CanFullyQualify(SyntaxNode node, SimpleNameSyntax& simpleName);
    private static SimpleNameSyntax GetLeftMostSimpleName(QualifiedNameSyntax qn);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.FullyQualify.VisualBasicFullyQualifyService/VB$StateMachine_3_ReplaceNodeAsync")]
protected virtual Task`1<SyntaxNode> ReplaceNodeAsync(SimpleNameSyntax simpleName, string containerName, bool resultingSymbolIsType, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEndConstruct.GenerateEndConstructCodeFixProvider : CodeFixProvider {
    internal static string BC30025;
    internal static string BC30026;
    internal static string BC30027;
    internal static string BC30081;
    internal static string BC30082;
    internal static string BC30083;
    internal static string BC30084;
    internal static string BC30085;
    internal static string BC30185;
    internal static string BC30253;
    internal static string BC30384;
    internal static string BC30481;
    internal static string BC30624;
    internal static string BC30625;
    internal static string BC30626;
    internal static string BC30631;
    internal static string BC30633;
    internal static string BC30675;
    internal static string BC31114;
    internal static string BC31115;
    internal static string BC31116;
    internal static string BC31117;
    internal static string BC36008;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEndConstruct.GenerateEndConstructCodeFixProvider/VB$StateMachine_27_RegisterCodeFixesAsync")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool IsCandidate(SyntaxNode node);
    private static SyntaxNode GetBeginStatement(SyntaxNode node);
    private static SyntaxNode GetEndStatement(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEndConstruct.GenerateEndConstructCodeFixProvider/VB$StateMachine_31_GeneratePropertyEndConstructAsync")]
private static Task`1<Document> GeneratePropertyEndConstructAsync(Document document, PropertyBlockSyntax node, CancellationToken cancellationToken);
    public static string GetDescription(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEndConstruct.GenerateEndConstructCodeFixProvider/VB$StateMachine_33_GenerateEndConstructAsync")]
private static Task`1<Document> GenerateEndConstructAsync(Document document, SyntaxNode endStatement, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEndConstruct.GenerateEndConstructCodeFixProvider/VB$StateMachine_34_InsertEndConstructAsync")]
private static Task`1<Document> InsertEndConstructAsync(Document document, SyntaxNode endStatement, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEnumMember.GenerateEnumMemberCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    internal static string BC30456;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEvent.GenerateEventCodeFixProvider : CodeFixProvider {
    internal static string BC30401;
    internal static string BC30590;
    internal static string BC30456;
    internal static string BC30451;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEvent.GenerateEventCodeFixProvider/VB$StateMachine_9_RegisterCodeFixesAsync")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEvent.GenerateEventCodeFixProvider/VB$StateMachine_10_GenerateEventFromAddRemoveHandlerAsync")]
private static Task`1<CodeAction> GenerateEventFromAddRemoveHandlerAsync(Document document, AddRemoveHandlerStatementSyntax handlerStatement, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEvent.GenerateEventCodeFixProvider/VB$StateMachine_11_GenerateCodeActionAsync")]
private static Task`1<CodeAction> GenerateCodeActionAsync(Document document, SemanticModel semanticModel, IMethodSymbol delegateSymbol, string actualEventName, INamedTypeSymbol targetType, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ExpressionSyntax GetHandlerExpression(AddRemoveHandlerStatementSyntax handlerStatement);
    private static bool TryGetDelegateSymbol(ExpressionSyntax handlerExpression, SemanticModel semanticModel, IMethodSymbol& delegateSymbol, CancellationToken cancellationToken);
    private static bool ResolveTargetType(INamedTypeSymbol& targetType, SemanticModel semanticModel);
    private static bool TryGetNameAndTargetType(ExpressionSyntax eventExpression, INamedTypeSymbol containingSymbol, SemanticModel semanticModel, INamedTypeSymbol& targetType, String& actualEventName, CancellationToken cancellationToken);
    private static bool IsCandidate(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEvent.GenerateEventCodeFixProvider/VB$StateMachine_17_GenerateEventFromImplementsAsync")]
private static Task`1<CodeAction> GenerateEventFromImplementsAsync(Document document, QualifiedNameSyntax node, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateEvent.GenerateEventCodeFixProvider/VB$StateMachine_18_GenerateEventFromHandlesAsync")]
private static Task`1<CodeAction> GenerateEventFromHandlesAsync(Document document, HandlesClauseItemSyntax handlesClauseItem, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateMethod.GenerateConversionCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    internal static string BC30311;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateMethod.GenerateParameterizedMemberCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    internal static string BC30057;
    internal static string BC30518;
    internal static string BC30519;
    internal static string BC30520;
    internal static string BC30521;
    internal static string BC30112;
    internal static string BC30451;
    internal static string BC30455;
    internal static string BC30456;
    internal static string BC30401;
    internal static string BC30516;
    internal static string BC32016;
    internal static string BC32045;
    internal static string BC32087;
    internal static string BC36625;
    internal static string BC30107;
    internal static string BC30108;
    internal static string BC30109;
    internal static string BC30110;
    internal static string BC30111;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.GenerateType.GenerateTypeCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    internal static string BC30002;
    internal static string BC30182;
    internal static string BC30451;
    internal static string BC30456;
    internal static string BC32042;
    internal static string BC32043;
    internal static string BC32045;
    internal static string BC40056;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.IncorrectExitContinue.IncorrectExitContinueCodeFixProvider : CodeFixProvider {
    internal static string BC30781;
    internal static string BC30782;
    internal static string BC30783;
    internal static string BC30784;
    internal static string BC30240;
    internal static string BC30065;
    internal static string BC30066;
    internal static string BC30067;
    internal static string BC30089;
    internal static string BC30096;
    internal static string BC30097;
    internal static string BC30099;
    internal static string BC30393;
    internal static string BC30689;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.IncorrectExitContinue.IncorrectExitContinueCodeFixProvider/VB$StateMachine_21_RegisterCodeFixesAsync")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private void CreateContinueCodeActions(SemanticDocument document, SyntaxNode node, IEnumerable`1<SyntaxNode> enclosingblocks, List`1& codeActions, CancellationToken cancellationToken);
    private void CreateExitCodeActions(SemanticDocument document, SyntaxNode node, IEnumerable`1<SyntaxNode> enclosingblocks, List`1& codeActions, CancellationToken cancellationToken);
    private static IEnumerable`1<SyntaxKind> GetEnclosingBlockKinds(IEnumerable`1<SyntaxNode> enclosingblocks, ISymbol enclosingDeclaration);
    private static IEnumerable`1<SyntaxKind> GetEnclosingContinuableBlockKinds(IEnumerable`1<SyntaxNode> enclosingblocks);
    private StatementSyntax CreateExitStatement(SyntaxNode exitSyntax, SyntaxNode containingBlock, SyntaxKind createBlockKind, Document document, CancellationToken cancellationToken);
    private StatementSyntax CreateContinueStatement(SyntaxNode continueSyntax, SyntaxNode containingBlock, SyntaxKind createBlockKind, Document document, CancellationToken cancellationToken);
    private static bool KeywordAndBlockKindMatch(SyntaxKind blockKind, SyntaxKind keywordKind);
    private static SyntaxKind BlockKindToKeywordKind(SyntaxKind blockKind);
    private static SyntaxKind BlockKindToStatementKind(SyntaxKind blockKind);
    private static SyntaxKind BlockKindToContinuableStatementKind(SyntaxKind blockKind);
    private static void CreateAddKeywordActions(SyntaxNode node, Document document, SyntaxNode enclosingBlock, IEnumerable`1<SyntaxKind> blockKinds, Func`6<SyntaxNode, SyntaxNode, SyntaxKind, Document, CancellationToken, StatementSyntax> updateNode, IList`1<CodeAction> codeActions);
    private static void CreateReplaceKeywordActions(IEnumerable`1<SyntaxKind> blockKinds, SyntaxToken invalidToken, SyntaxNode node, SyntaxNode enclosingBlock, Document document, Func`6<SyntaxNode, SyntaxNode, SyntaxKind, Document, CancellationToken, StatementSyntax> updateNode, IList`1<CodeAction> codeActions);
    private static void CreateReplaceTokenKeywordActions(IEnumerable`1<SyntaxKind> blockKinds, SyntaxToken invalidToken, Document document, List`1<CodeAction> codeActions);
    private static string CreateDeleteString(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.IncorrectFunctionReturnType.IncorrectFunctionReturnTypeCodeFixProvider : CodeFixProvider {
    internal static string BC36938;
    internal static string BC36945;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.IncorrectFunctionReturnType.IncorrectFunctionReturnTypeCodeFixProvider/VB$StateMachine_6_RegisterCodeFixesAsync")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static T GetNodeToFix(SyntaxToken token, TextSpan span);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.IncorrectFunctionReturnType.IncorrectFunctionReturnTypeCodeFixProvider/VB$StateMachine_8_GetCodeActionsAsync")]
private static Task`1<IEnumerable`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, SyntaxNode rewrittenNode, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.Iterator.VisualBasicChangeToYieldCodeFixProvider : AbstractIteratorCodeFixProvider {
    internal static string BC36942;
    internal static ImmutableArray`1<string> Ids;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static VisualBasicChangeToYieldCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.Iterator.VisualBasicConvertToIteratorCodeFixProvider : AbstractIteratorCodeFixProvider {
    internal static string BC30451;
    internal static ImmutableArray`1<string> Ids;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static VisualBasicConvertToIteratorCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.Iterator.VisualBasicConvertToIteratorCodeFixProvider/VB$StateMachine_6_GetCodeFixAsync")]
protected virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    private static SyntaxNode AddIteratorKeywordToMethod(SyntaxNode root, MethodStatementSyntax methodStatementNode);
    private static SyntaxNode AddIteratorKeywordToLambda(SyntaxNode root, LambdaExpressionSyntax lambdaNode);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.MoveToTopOfFile.MoveToTopOfFileCodeFixProvider : CodeFixProvider {
    internal static string BC30465;
    internal static string BC30637;
    internal static string BC30627;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.MoveToTopOfFile.MoveToTopOfFileCodeFixProvider/VB$StateMachine_8_RegisterCodeFixesAsync")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool DeclarationsExistAfterImports(SyntaxNode node, CompilationUnitSyntax root);
    private static IEnumerable`1<CodeAction> CreateActionForImports(Document document, ImportsStatementSyntax node, CompilationUnitSyntax root, CancellationToken cancellationToken);
    private static IEnumerable`1<CodeAction> CreateActionForOptions(Document document, OptionStatementSyntax node, CompilationUnitSyntax root, CancellationToken cancellationToken);
    private static IEnumerable`1<CodeAction> CreateActionForAttribute(Document document, AttributesStatementSyntax node, CompilationUnitSyntax root, CancellationToken cancellationToken);
    private static int FindLastContiguousStatement(IEnumerable`1<SyntaxNode> nodes, IEnumerable`1<SyntaxTrivia> trivia);
    private static string MoveStatement(string kind, int line);
    private static string DeleteStatement(string kind);
    private static bool DestinationPositionIsHidden(CompilationUnitSyntax root, int destinationLine, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.OverloadBase.OverloadBaseCodeFixProvider : CodeFixProvider {
    internal static string BC40003;
    internal static string BC40004;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeFixes.OverloadBase.OverloadBaseCodeFixProvider/VB$StateMachine_7_RegisterCodeFixesAsync")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.SimplifyTypeNames.TypeSyntaxSimplifierWalker : VisualBasicSyntaxWalker {
    private static ImmutableHashSet`1<string> s_emptyAliasedNames;
    private static ImmutableHashSet`1<string> s_predefinedTypeMetadataNames;
    private VisualBasicSimplifyTypeNamesDiagnosticAnalyzer _analyzer;
    private SemanticModel _semanticModel;
    private VisualBasicSimplifierOptions _options;
    private AnalyzerOptions _analyzerOptions;
    private TextSpanMutableIntervalTree _ignoredSpans;
    private CancellationToken _cancellationToken;
    private Builder<Diagnostic> _diagnostics;
    private ImmutableHashSet`1<string> _aliasedNames;
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public Builder<Diagnostic> DiagnosticsBuilder { get; }
    private static TypeSyntaxSimplifierWalker();
    public TypeSyntaxSimplifierWalker(VisualBasicSimplifyTypeNamesDiagnosticAnalyzer analyzer, SemanticModel semanticModel, VisualBasicSimplifierOptions options, AnalyzerOptions analyzerOptions, TextSpanMutableIntervalTree ignoredSpans, CancellationToken cancellationToken);
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    public Builder<Diagnostic> get_DiagnosticsBuilder();
    private static ImmutableHashSet`1<string> GetAliasedNames(CompilationUnitSyntax compilationUnit);
    private static void AddAliasedName(ImmutableHashSet`1& aliasedNames, SimpleImportsClauseSyntax simpleImportsClause);
    public virtual void VisitQualifiedName(QualifiedNameSyntax node);
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    private bool CanReplaceIdentifierWithAlias(string identifier);
    private static bool CanReplaceIdentifierWithPredefinedType(string identifier);
    public virtual void VisitGenericName(GenericNameSyntax node);
    private bool TrySimplify(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.SimplifyTypeNames.VisualBasicSimplifyTypeNamesDiagnosticAnalyzer : SimplifyTypeNamesDiagnosticAnalyzerBase`2<SyntaxKind, VisualBasicSimplifierOptions> {
    private static ImmutableArray`1<SyntaxKind> s_kindsOfInterest;
    private static VisualBasicSimplifyTypeNamesDiagnosticAnalyzer();
    protected virtual bool IsIgnoredCodeBlock(SyntaxNode codeBlock);
    protected virtual ImmutableArray`1<Diagnostic> AnalyzeCodeBlock(CodeBlockAnalysisContext context, SyntaxNode root);
    protected virtual ImmutableArray`1<Diagnostic> AnalyzeSemanticModel(SemanticModelAnalysisContext context, SyntaxNode root, TextSpanMutableIntervalTree codeBlockIntervalTree);
    private static bool IsNodeKindInteresting(SyntaxNode node);
    internal virtual bool IsCandidate(SyntaxNode node);
    internal virtual bool CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, VisualBasicSimplifierOptions options, TextSpan& issueSpan, String& diagnosticId, Boolean& inDeclaration, CancellationToken cancellationToken);
}
[ExportConfigurationFixProviderAttribute("Suppression", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeFixes.Suppression.VisualBasicSuppressionCodeFixProvider : AbstractSuppressionCodeFixProvider {
    protected string DefaultFileExtension { get; }
    protected string SingleLineCommentStart { get; }
    protected virtual SyntaxTriviaList CreatePragmaRestoreDirectiveTrivia(Diagnostic diagnostic, Func`3<SyntaxNode, CancellationToken, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine, CancellationToken cancellationToken);
    protected virtual SyntaxTriviaList CreatePragmaDisableDirectiveTrivia(Diagnostic diagnostic, Func`3<SyntaxNode, CancellationToken, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine, CancellationToken cancellationToken);
    private static SeparatedSyntaxList`1<IdentifierNameSyntax> GetErrorCodes(Diagnostic diagnostic, Boolean& includeTitle);
    private static SyntaxTriviaList CreatePragmaDirectiveTrivia(StructuredTriviaSyntax enableOrDisablePragmaDirective, bool includeTitle, Diagnostic diagnostic, Func`3<SyntaxNode, CancellationToken, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetContainingStatement(SyntaxToken token);
    protected virtual bool TokenHasTrailingLineContinuationChar(SyntaxToken token);
    protected virtual string get_DefaultFileExtension();
    protected virtual string get_SingleLineCommentStart();
    protected virtual bool IsAttributeListWithAssemblyAttributes(SyntaxNode node);
    protected virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected virtual bool IsEndOfFileToken(SyntaxToken token);
    protected virtual SyntaxNode AddGlobalSuppressMessageAttribute(SyntaxNode newRoot, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic, SolutionServices services, SyntaxFormattingOptions options, IAddImportsService addImportsService, CancellationToken cancellationToken);
    protected virtual SyntaxNode AddLocalSuppressMessageAttribute(SyntaxNode targetNode, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic);
    private static AttributeListSyntax CreateAttributeList(ISymbol targetSymbol, NameSyntax attributeName, Diagnostic diagnostic, bool isAssemblyAttribute);
    private static ArgumentListSyntax CreateAttributeArguments(ISymbol targetSymbol, Diagnostic diagnostic, bool isAssemblyAttribute);
    protected virtual bool IsSingleAttributeInAttributeList(SyntaxNode attribute);
    protected virtual bool IsAnyPragmaDirectiveForId(SyntaxTrivia trivia, string id, Boolean& enableDirective, Boolean& hasMultipleIds);
    protected virtual SyntaxTrivia TogglePragmaDirective(SyntaxTrivia trivia);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeLens.ICodeLensMemberFinder", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeLens.VisualBasicCodeLensMemberFinder : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeLens.VisualBasicCodeLensMemberFinder/VB$StateMachine_1_GetCodeLensMembersAsync")]
public sealed virtual override Task`1<ImmutableArray`1<CodeLensMember>> GetCodeLensMembersAsync(Document document, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeLens.VisualBasicDisplayInfoService : object {
    private static SymbolDisplayFormat Format;
    private static VisualBasicDisplayInfoService();
    public sealed virtual override SyntaxNode GetDisplayNode(SyntaxNode node);
    private static string SymbolToDisplayString(ISymbol symbol);
    private static string FormatPropertyAccessor(SyntaxNode node, string symbolName);
    private static string FormatEventHandler(SyntaxNode node, string symbolName);
    private static bool IsAccessorForDefaultProperty(ISymbol symbol);
    private static string RemoveParameters(string symbolName);
    public sealed virtual override string GetDisplayName(SemanticModel semanticModel, SyntaxNode node);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.AddAwait.VisualBasicAddAwaitCodeRefactoringProvider : AbstractAddAwaitCodeRefactoringProvider`1<ExpressionSyntax> {
    protected virtual string GetTitle();
    protected virtual string GetTitleWithConfigureAwait();
    protected virtual bool IsInAsyncContext(SyntaxNode node);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineMethodRefactoringProvider")]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineMethodRefactoringProvider : AbstractInlineMethodRefactoringProvider`4<MethodBlockSyntax, ExecutableStatementSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual ExpressionSyntax GetRawInlineExpression(MethodBlockSyntax methodBlock);
    protected virtual SyntaxNode GenerateTypeSyntax(ITypeSymbol symbol, bool allowVar);
    protected virtual ExpressionSyntax GenerateLiteralExpression(ITypeSymbol typeSymbol, object value);
    protected virtual bool IsFieldDeclarationSyntax(SyntaxNode node);
    protected virtual bool IsValidExpressionUnderExpressionStatement(ExpressionSyntax expressionNode);
    protected virtual bool CanBeReplacedByThrowExpression(SyntaxNode syntaxNode);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineTemporaryCodeRefactoringProvider : AbstractInlineTemporaryCodeRefactoringProvider`2<IdentifierNameSyntax, ModifiedIdentifierSyntax> {
    private static SyntaxAnnotation s_definitionAnnotation;
    private static SyntaxAnnotation s_referenceAnnotation;
    private static SyntaxAnnotation s_initializerAnnotation;
    private static SyntaxAnnotation s_expressionToInlineAnnotation;
    private static VisualBasicInlineTemporaryCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineTemporaryCodeRefactoringProvider/VB$StateMachine_3_ComputeRefactoringsAsync")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool HasConflict(IdentifierNameSyntax identifier, ModifiedIdentifierSyntax definition, ExpressionSyntax expressionToInline, SemanticModel semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineTemporaryCodeRefactoringProvider/VB$StateMachine_9_InlineTemporaryAsync")]
private static Task`1<Document> InlineTemporaryAsync(Document document, ModifiedIdentifierSyntax modifiedIdentifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineTemporaryCodeRefactoringProvider/VB$StateMachine_10_FindDefinitionAsync")]
private static Task`1<ModifiedIdentifierSyntax> FindDefinitionAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineTemporaryCodeRefactoringProvider/VB$StateMachine_11_FindReferenceAnnotatedNodesAsync")]
private static Task`1<IEnumerable`1<IdentifierNameSyntax>> FindReferenceAnnotatedNodesAsync(Document document, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineTemporaryCodeRefactoringProvider/VB$StateMachine_12_FindReferenceAnnotatedNodes")]
private static IEnumerable`1<IdentifierNameSyntax> FindReferenceAnnotatedNodes(SyntaxNode root);
    private static SyntaxNode GetScope(ModifiedIdentifierSyntax modifiedIdentifier);
    private static LocalDeclarationStatementSyntax GetUpdatedDeclaration(ModifiedIdentifierSyntax modifiedIdentifier);
    private static SyntaxNode RemoveDefinition(ModifiedIdentifierSyntax modifiedIdentifier, SyntaxNode newBlock);
    private static ExpressionSyntax AddExplicitArgumentListIfNeeded(ExpressionSyntax expression, SemanticModel semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineTemporaryCodeRefactoringProvider/VB$StateMachine_17_CreateExpressionToInlineAsync")]
private static Task`1<ExpressionSyntax> CreateExpressionToInlineAsync(Document document, CancellationToken cancellationToken);
    private static StatementSyntax GetTopMostStatementForExpression(ExpressionSyntax expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.InlineTemporary.VisualBasicInlineTemporaryCodeRefactoringProvider/VB$StateMachine_19_DetectSemanticConflictsAsync")]
private static Task`1<Document> DetectSemanticConflictsAsync(Document inlinedDocument, SemanticModel newSemanticModelForInlinedDocument, SemanticModel semanticModelBeforeInline, SymbolInfo originalInitializerSymbolInfo, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.MoveStaticMembers.VisualBasicMoveStaticMembersRefactoringProvider : AbstractMoveStaticMembersRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.MoveStaticMembers.VisualBasicMoveStaticMembersRefactoringProvider/VB$StateMachine_1_GetSelectedNodesAsync")]
protected virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedNodesAsync(CodeRefactoringContext context);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.IMoveTypeService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.MoveType.VisualBasicMoveTypeService : AbstractMoveTypeService`5<VisualBasicMoveTypeService, TypeBlockSyntax, NamespaceBlockSyntax, MethodBaseSyntax, CompilationUnitSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.MoveType.VisualBasicMoveTypeService/VB$StateMachine_1_GetRelevantNodeAsync")]
protected virtual Task`1<TypeBlockSyntax> GetRelevantNodeAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.NodeSelectionHelpers : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.NodeSelectionHelpers/VB$StateMachine_0_GetSelectedMemberDeclarationAsync")]
internal static Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedMemberDeclarationAsync(CodeRefactoringContext context);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.IReplaceMethodWithPropertyService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.ReplaceMethodWithProperty.VisualBasicReplaceMethodWithPropertyService : AbstractReplaceMethodWithPropertyService`1<MethodStatementSyntax> {
    public sealed virtual override void RemoveSetMethod(SyntaxEditor editor, SyntaxNode setMethodDeclaration);
    public sealed virtual override void ReplaceGetMethodWithProperty(CodeGenerationOptions options, ParseOptions parseOptions, SyntaxEditor editor, SemanticModel semanticModel, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged, CancellationToken cancellationToken);
    private static DeclarationStatementSyntax GetParentIfBlock(MethodStatementSyntax declaration);
    private static DeclarationStatementSyntax ConvertMethodsToProperty(SyntaxEditor editor, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged);
    private static SyntaxToken GetPropertyName(SyntaxToken identifier, string propertyName, bool nameChanged);
    public sealed virtual override void ReplaceGetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public sealed virtual override void ReplaceSetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    private sealed virtual override Task`1<SyntaxNode> IReplaceMethodWithPropertyService_GetMethodDeclarationAsync(CodeRefactoringContext context);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.IReplacePropertyWithMethodsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.ReplaceMethodWithProperty.VisualBasicReplacePropertyWithMethods : AbstractReplacePropertyWithMethodsService`5<IdentifierNameSyntax, ExpressionSyntax, CrefReferenceSyntax, StatementSyntax, PropertyStatementSyntax> {
    public virtual Task`1<ImmutableArray`1<SyntaxNode>> GetReplacementMembersAsync(Document document, IPropertySymbol property, SyntaxNode propertyDeclarationNode, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxNode> ConvertPropertyToMembers(SyntaxGenerator generator, IPropertySymbol property, PropertyStatementSyntax propertyStatement, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    private static SyntaxNode GetGetMethod(SyntaxGenerator generator, IPropertySymbol property, PropertyStatementSyntax propertyStatement, IFieldSymbol propertyBackingField, IMethodSymbol getMethod, string desiredGetMethodName, CancellationToken cancellationToken);
    private static StatementSyntax WithFormattingAnnotation(StatementSyntax statement);
    private static SyntaxNode GetSetMethod(SyntaxGenerator generator, IPropertySymbol property, PropertyStatementSyntax propertyStatement, IFieldSymbol propertyBackingField, IMethodSymbol setMethod, string desiredSetMethodName, CancellationToken cancellationToken);
    private static IMethodSymbol UpdateExplicitInterfaceImplementations(IPropertySymbol property, IMethodSymbol method, string desiredName);
    private static IMethodSymbol UpdateExplicitInterfaceImplementation(IPropertySymbol property, IMethodSymbol explicitInterfaceImplMethod, string desiredName);
    private static SyntaxNode CopyLeadingTriviaOver(PropertyStatementSyntax propertyStatement, SyntaxNode methodDeclaration, VisualBasicSyntaxRewriter documentationCommentRewriter);
    private static SyntaxTrivia ConvertTrivia(SyntaxTrivia trivia, VisualBasicSyntaxRewriter documentationCommentRewriter);
    private static bool IsValueName(XmlNodeSyntax node);
    public virtual SyntaxNode GetPropertyNodeToReplace(SyntaxNode propertyDeclaration);
    protected virtual CrefReferenceSyntax TryGetCrefSyntax(IdentifierNameSyntax identifierName);
    protected virtual CrefReferenceSyntax CreateCrefSyntax(CrefReferenceSyntax originalCref, SyntaxToken identifierToken, SyntaxNode parameterType);
    protected virtual ExpressionSyntax UnwrapCompoundAssignment(SyntaxNode compoundAssignment, ExpressionSyntax readExpression);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.VisualBasicRefactoringHelpersService : AbstractRefactoringHelpersService`3<ExpressionSyntax, ArgumentSyntax, ExpressionStatementSyntax> {
    [CompilerGeneratedAttribute]
private IHeaderFacts _HeaderFacts;
    protected IHeaderFacts HeaderFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual IHeaderFacts get_HeaderFacts();
    public virtual bool IsBetweenTypeMembers(SourceText sourceText, SyntaxNode root, int position, SyntaxNode& typeDeclaration);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.CodeRefactorings.VisualBasicRefactoringHelpersService/VB$StateMachine_5_ExtractNodesSimple")]
protected virtual IEnumerable`1<SyntaxNode> ExtractNodesSimple(SyntaxNode node, ISyntaxFactsService syntaxFacts);
    public static bool IsIdentifierOfParameter(SyntaxNode node);
    [CompilerGeneratedAttribute]
[CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxNode> $VB$ClosureStub_ExtractNodesSimple_MyBase(SyntaxNode node, ISyntaxFactsService syntaxFacts);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CommentSelection.ICommentSelectionService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CommentSelection.VisualBasicCommentSelectionService : AbstractCommentSelectionService {
    [CompilerGeneratedAttribute]
private string _SingleLineCommentString;
    [CompilerGeneratedAttribute]
private bool _SupportsBlockComment;
    public string SingleLineCommentString { get; }
    public bool SupportsBlockComment { get; }
    public string BlockCommentEndString { get; }
    public string BlockCommentStartString { get; }
    [CompilerGeneratedAttribute]
public virtual string get_SingleLineCommentString();
    [CompilerGeneratedAttribute]
public virtual bool get_SupportsBlockComment();
    public virtual string get_BlockCommentEndString();
    public virtual string get_BlockCommentStartString();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.AbstractKeywordRecommender : object {
    public sealed virtual override ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    internal ImmutableArray`1<RecommendedKeyword> RecommendKeywords_Test(VisualBasicSyntaxContext context);
    protected abstract virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.ArrayStatements.EraseKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static EraseKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.ArrayStatements.PreserveKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static PreserveKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.ArrayStatements.ReDimKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ReDimKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.AliasKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static AliasKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.AsKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static AsKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.AsyncKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static AsyncKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.AttributeScopesKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static AttributeScopesKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.CharsetModifierKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static CharsetModifierKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ClassKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ClassKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ConstKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ConstKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.CovarianceModifiersKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static CovarianceModifiersKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.CustomEventKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static CustomEventKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.DeclareKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static DeclareKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.DelegateKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static DelegateKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.DelegateSubFunctionKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static DelegateSubFunctionKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.DimKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static DimKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.EndBlockKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static string GetToolTipForKeyword(string keyword);
    private static void EnsureAllIfAny(ICollection`1<string> collection, String[] completions);
    private static IEnumerable`1<SyntaxKind> GetUnclosedBlockKeywords(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.EnumKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static EnumKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.EventKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static EventKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ExternalSubFunctionKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ExternalSubFunctionKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.FunctionKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static FunctionKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.GenericConstraintsKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.GetSetKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ImplementsKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ImportsKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ImportsKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.InheritsKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static InheritsKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.InKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAfterCompleteAsClause(VisualBasicSyntaxContext context, Func`2<T, SimpleAsClauseSyntax> childGetter, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.InterfaceKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static InterfaceKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.IteratorKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static IteratorKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.LibKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static LibKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ModifierKeywordsRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ModuleKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ModuleKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.NamespaceKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static NamespaceKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.OfKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsPartiallyTypedGenericName(TypeSyntax type, SemanticModel semanticModel);
    private static bool IsGenericDelegateCreationExpression(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.OperatorKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.OverloadableOperatorRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static string GetToolTipForKeyword(string operator);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ParameterModifiersKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.PropertyKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static PropertyKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.StaticKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static StaticKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.StructureKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static StructureKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.SubKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Declarations.ToKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ToKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.EventHandling.AddHandlerKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static AddHandlerKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.EventHandling.HandlesKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static HandlesKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.EventHandling.RaiseEventKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.EventHandling.RemoveHandlerKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static RemoveHandlerKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.AddressOfKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static AddressOfKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.BinaryOperatorKeywordRecommender : AbstractKeywordRecommender {
    internal static ImmutableArray`1<RecommendedKeyword> KeywordList;
    private static BinaryOperatorKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsBinaryOperatorContext(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.CastOperatorsKeywordRecommender : AbstractKeywordRecommender {
    internal static SyntaxKind[] PredefinedKeywordList;
    private static CastOperatorsKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.FromKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static FromKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.GetTypeKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.GetXmlNamespaceKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.GlobalKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static GlobalKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.IfKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static IfKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.KeyKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static KeyKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.LambdaKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.MeKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.MyBaseKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static MyBaseKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.MyClassKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static MyClassKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.NameOfKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.NewKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static NewKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.NothingKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static NothingKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.NotKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static NotKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.TrueFalseKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static bool ShouldPreselect(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.TypeOfKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static TypeOfKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Expressions.WithKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static WithKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OnErrorStatements.ErrorKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OnErrorStatements.GoToDestinationsRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static GoToDestinationsRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OnErrorStatements.GoToKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static GoToKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OnErrorStatements.NextKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static NextKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OnErrorStatements.OnErrorKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static OnErrorKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OnErrorStatements.ResumeKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OptionStatements.CompareBinaryTextRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static CompareBinaryTextRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OptionStatements.ExplicitOptionsRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ExplicitOptionsRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OptionStatements.InferOptionsRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static InferOptionsRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OptionStatements.OptionKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static OptionKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OptionStatements.OptionNamesRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static OptionNamesRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.OptionStatements.StrictOptionsRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static StrictOptionsRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.ConstDirectiveKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ConstDirectiveKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.ElseDirectiveKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ElseDirectiveKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.ElseIfDirectiveKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ElseIfDirectiveKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.EndIfDirectiveKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static bool HasMatchingIfDirective(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.EndRegionDirectiveKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static bool HasUnmatchedRegionDirective(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.IfDirectiveKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static IfDirectiveKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.PreprocessorHelpers : object {
    [ExtensionAttribute]
public static Nullable`1<SyntaxKind> GetInnermostIfPreprocessorKind(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.ReferenceDirectiveKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ReferenceDirectiveKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.RegionDirectiveKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static RegionDirectiveKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.PreprocessorDirectives.WarningDirectiveKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.AggregateKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static AggregateKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.AscendingDescendingKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static AscendingDescendingKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.DistinctKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static DistinctKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.EqualsKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static EqualsKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.FromKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static FromKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.GroupByKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static GroupByKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.GroupJoinKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static GroupJoinKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.GroupKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.IntoKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static IntoKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.JoinKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static JoinKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.LetKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static LetKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.OnKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static OnKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.OrderByKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static OrderByKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.SelectKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static SelectKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.SkipKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static SkipKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.TakeKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static TakeKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.WhereKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static WhereKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Queries.WhileKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static WhileKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.RecommendationHelpers : object {
    internal static bool IsOnErrorStatement(SyntaxNode node);
    [ExtensionAttribute]
internal static SyntaxNode GetParentOrNull(SyntaxNode node);
    [ExtensionAttribute]
internal static bool IsFollowingCompleteAsNewClause(SyntaxToken token);
    [ExtensionAttribute]
private static bool IsLastTokenOfObjectCreation(SyntaxToken token, ObjectCreationExpressionSyntax objectCreation);
    [ExtensionAttribute]
internal static bool IsFollowingCompleteObjectCreationInitializer(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsFollowingCompleteObjectCreation(SyntaxToken token);
    [ExtensionAttribute]
internal static ExpressionSyntax LastJoinKey(SeparatedSyntaxList`1<JoinConditionSyntax> collection);
    [ExtensionAttribute]
internal static bool IsFromIdentifierNode(SyntaxToken token, IdentifierNameSyntax identifierSyntax);
    [ExtensionAttribute]
internal static bool IsFromIdentifierNode(SyntaxToken token, ModifiedIdentifierSyntax identifierSyntax);
    [ExtensionAttribute]
internal static bool IsFromIdentifierNode(SyntaxToken token, SyntaxNode node);
    [ExtensionAttribute]
internal static bool IsFromIdentifierNode(SyntaxToken token, Func`2<TParent, SyntaxNode> identifierNodeSelector);
    internal static RecommendedKeyword CreateRecommendedKeywordForIntrinsicOperator(SyntaxKind kind, string firstLine, Glyph glyph, AbstractIntrinsicOperatorDocumentation intrinsicOperator, SemanticModel semanticModel, int position);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.CallKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static CallKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.CaseKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.CatchKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static CatchKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ContinueKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ContinueKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.DoKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.EachKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static EachKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ElseIfKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ElseIfKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ElseKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsDirectlyInIfOrElseIf(VisualBasicSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.EndKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static EndKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ExitKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ExitKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.FinallyKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static FinallyKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInCatchOfTry(SyntaxToken targetToken, TryBlockSyntax tryBlock);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ForKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.GotoKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static GotoKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.IfKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.IsKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static IsKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.LoopKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.MidKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static MidKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.NextKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static NextKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ReturnKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ReturnKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.SelectKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.StepKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static StepKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.StopKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static StopKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.SyncLockKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static SyncLockKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ThenKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ThenKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ThrowKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ThrowKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.ToKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static ToKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.TryKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.UntilAndWhileKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.UsingKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static UsingKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.WhenKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static WhenKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.WhileLoopKeywordRecommender : AbstractKeywordRecommender {
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.WithKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static WithKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Statements.YieldKeywordRecommender : AbstractKeywordRecommender {
    private static ImmutableArray`1<RecommendedKeyword> s_keywords;
    private static YieldKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.KeywordRecommenders.Types.BuiltInTypesKeywordRecommender : AbstractKeywordRecommender {
    private static String[] s_intrinsicKeywordNames;
    private static SByte[] s_intrinsicSpecialTypes;
    private static BuiltInTypesKeywordRecommender();
    protected virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static ImmutableArray`1<RecommendedKeyword> GetIntrinsicTypeKeywords(VisualBasicSyntaxContext context);
    private static string GetDocumentationCommentText(VisualBasicSyntaxContext context, SpecialType type, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("AggregateEmbeddedLanguageCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.AggregateEmbeddedLanguageCompletionProvider : AbstractAggregateEmbeddedLanguageCompletionProvider {
    internal string Language { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public AggregateEmbeddedLanguageCompletionProvider(IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> languageServices);
    internal virtual string get_Language();
}
[ExportCompletionProviderAttribute("AwaitCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.AwaitCompletionProvider : AbstractAwaitCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual int GetSpanStart(SyntaxNode declaration);
    protected virtual SyntaxNode GetAsyncSupportingDeclaration(SyntaxToken token);
    protected virtual ITypeSymbol GetTypeSymbolOfExpression(SemanticModel semanticModel, SyntaxNode potentialAwaitableExpression, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetExpressionToPlaceAwaitInFrontOf(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual Nullable`1<SyntaxToken> GetDotTokenLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("CompletionListTagCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.CompletionListTagCompletionProvider : EnumCompletionProvider {
    protected virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, VisualBasicSyntaxContext syntaxContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    private static ITypeSymbol GetCompletionListType(ITypeSymbol inferredType, INamedTypeSymbol within, Compilation compilation, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, VisualBasicSyntaxContext context);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>> symbols, VisualBasicSyntaxContext context, SupportedPlatformData supportedPlatformData);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.CompletionUtilities : object {
    private static char UnicodeEllipsis;
    private static string OfSuffix;
    private static string GenericSuffix;
    internal static ImmutableHashSet`1<char> CommonTriggerChars;
    internal static ImmutableHashSet`1<char> CommonTriggerCharsAndParen;
    internal static ImmutableHashSet`1<char> SpaceTriggerChar;
    private static CompletionUtilities();
    public static TextSpan GetCompletionItemSpan(SourceText text, int position);
    public static bool IsWordStartCharacter(char ch);
    private static bool IsWordCharacter(char ch);
    private static bool IsCompletionItemStartCharacter(char ch);
    private static bool IsCompletionItemCharacter(char ch);
    public static bool IsDefaultTriggerCharacter(SourceText text, int characterPosition, CompletionOptions options);
    public static bool IsDefaultTriggerCharacterOrParen(SourceText text, int characterPosition, CompletionOptions options);
    public static bool IsTriggerAfterSpaceOrStartOfWordCharacter(SourceText text, int characterPosition, CompletionOptions options);
    private static bool IsStartingNewWord(SourceText text, int characterPosition, CompletionOptions options);
    public static ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, SyntaxContext context);
    private static string GetDisplayText(string name, ISymbol symbol);
    private static string GetSuffix(ISymbol symbol);
    private static string GetInsertionText(string name, ISymbol symbol, SyntaxContext context);
    public static string GetInsertionTextAtInsertionTime(CompletionItem item, char ch);
}
[ExportArgumentProviderAttribute("ContextVariableArgumentProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.ContextVariableArgumentProvider : AbstractContextVariableArgumentProvider {
    protected string ThisOrMeKeyword { get; }
    protected virtual string get_ThisOrMeKeyword();
    protected virtual bool IsInstanceContext(SyntaxTree syntaxTree, SyntaxToken targetToken, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("CrefCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.CrefCompletionProvider : AbstractCrefCompletionProvider {
    private static SymbolDisplayFormat s_crefFormat;
    private static SymbolDisplayFormat s_minimalParameterTypeFormat;
    private Action`1<SyntaxNode> _testSpeculativeNodeCallbackOpt;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    private static CharacterSetModificationRule s_WithoutOpenParen;
    private static CharacterSetModificationRule s_WithoutSpace;
    private static CompletionItemRules s_defaultRules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static CrefCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    internal virtual string get_Language();
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.CrefCompletionProvider/VB$StateMachine_11_ProvideCompletionsAsync")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.CrefCompletionProvider/VB$StateMachine_12_GetSymbolsAsync")]
protected virtual Task`1<ValueTuple`3<SyntaxToken, SemanticModel, ImmutableArray`1<ISymbol>>> GetSymbolsAsync(Document document, int position, CompletionOptions options, CancellationToken cancellationToken);
    private static bool IsCrefTypeParameterContext(SyntaxToken token);
    private static bool IsCrefStartContext(SyntaxToken token);
    private static bool IsCrefParameterListContext(SyntaxToken token);
    private static bool IsFirstCrefParameterContext(SyntaxToken& token);
    private static IEnumerable`1<ISymbol> GetSymbols(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.CrefCompletionProvider/VB$StateMachine_18_GetQualifiedSymbols")]
private static IEnumerable`1<ISymbol> GetQualifiedSymbols(QualifiedNameSyntax qualifiedName, SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.CrefCompletionProvider/VB$StateMachine_19_CreateCompletionItems")]
private static IEnumerable`1<CompletionItem> CreateCompletionItems(SemanticModel semanticModel, IEnumerable`1<ISymbol> symbols, int position);
    private static CompletionItem CreateCompletionItem(SemanticModel semanticModel, ISymbol symbol, int position, StringBuilder builder);
    private static CompletionItem CreateOfCompletionItem();
    private static CompletionItemRules GetRules(string displayText);
    internal TestAccessor GetTestAccessor();
}
[ExportArgumentProviderAttribute("DefaultArgumentProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.DefaultArgumentProvider : AbstractDefaultArgumentProvider {
    public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
[ExportCompletionProviderAttribute("EnumCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.EnumCompletionProvider : AbstractSymbolCompletionProvider`1<VisualBasicSyntaxContext> {
    private static CompletionItemRules s_enumMemberCompletionItemRules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    private object _gate;
    private INamedTypeSymbol _cachedDisplayAndInsertionTextContainingType;
    private VisualBasicSyntaxContext _cachedDisplayAndInsertionTextContext;
    private string _cachedDisplayAndInsertionTextContainingTypeText;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static EnumCompletionProvider();
    internal virtual string get_Language();
    protected virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, VisualBasicSyntaxContext syntaxContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    private static ITypeSymbol GetTypeFromSymbol(ISymbol symbol);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, VisualBasicSyntaxContext context);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>> symbols, VisualBasicSyntaxContext context, SupportedPlatformData supportedPlatformData);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
}
[ExportCompletionProviderAttribute("ExtensionMethodImportCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.ExtensionMethodImportCompletionProvider : AbstractExtensionMethodImportCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    protected string GenericSuffix { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    protected virtual string get_GenericSuffix();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsFinalSemicolonOfUsingOrExtern(SyntaxNode directive, SyntaxToken token);
    protected virtual Task`1<bool> ShouldProvideParenthesisCompletionAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
}
[ExportArgumentProviderAttribute("FirstBuiltInArgumentProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.FirstBuiltInArgumentProvider : ArgumentProvider {
    public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
[ExportCompletionProviderAttribute("FirstBuiltInCompletionProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.FirstBuiltInCompletionProvider : CompletionProvider {
    public virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[ExportCompletionProviderAttribute("HandlesClauseCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.HandlesClauseCompletionProvider : AbstractSymbolCompletionProvider`1<VisualBasicSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.HandlesClauseCompletionProvider/VB$StateMachine_3_GetSymbolsAsync")]
protected virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, VisualBasicSyntaxContext syntaxContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<ISymbol>> GetSymbolsAsync(VisualBasicSyntaxContext context, int position, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    private static ImmutableArray`1<ISymbol> GetTopLevelIdentifiers(VisualBasicSyntaxContext context, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> LookUpEvents(VisualBasicSyntaxContext context, SyntaxToken token, CancellationToken cancellationToken);
    private static bool IsWithEvents(ISymbol s);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, VisualBasicSyntaxContext context);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>> symbols, VisualBasicSyntaxContext context, SupportedPlatformData supportedPlatformData);
}
[ExportCompletionProviderAttribute("ImplementsClauseCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.ImplementsClauseCompletionProvider : AbstractSymbolCompletionProvider`1<VisualBasicSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    private static SymbolDisplayFormat MinimalFormatWithoutGenerics;
    private static string InsertionTextOnOpenParen;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal string Language { get; }
    private static ImplementsClauseCompletionProvider();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsExclusive();
    internal virtual string get_Language();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.ImplementsClauseCompletionProvider/VB$StateMachine_9_GetSymbolsAsync")]
protected virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, VisualBasicSyntaxContext syntaxContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<ISymbol>> GetSymbolsAsync(VisualBasicSyntaxContext context, int position, CancellationToken cancellationToken);
    private static bool MatchesMemberKind(ISymbol symbol, SyntaxKind memberKindKeyword);
    private static ImmutableArray`1<ISymbol> GetDottedMembers(int position, QualifiedNameSyntax qualifiedName, SemanticModel semanticModel, SyntaxKind memberKindKeyword, CancellationToken cancellationToken);
    private ImmutableArray`1<ISymbol> interfaceMemberGetter(ITypeSymbol interface, ISymbol within);
    private ImmutableArray`1<ISymbol> GetInterfacesAndContainers(int position, SyntaxNode node, SemanticModel semanticModel, SyntaxKind kind, CancellationToken cancellationToken);
    private static void AddAliasesAndContainers(ISymbol symbol, ICollection`1<ISymbol> interfacesAndContainers, SyntaxNode node, SemanticModel semanticModel);
    private static void AddAlias(ISymbol symbol, ICollection`1<ISymbol> interfacesAndContainers, SyntaxNode node, SemanticModel semanticModel);
    private static bool IsGlobal(ISymbol containingSymbol);
    private static ImmutableArray`1<ISymbol> TryAddGlobalTo(ImmutableArray`1<ISymbol> symbols);
    private static bool WalkUpQualifiedNames(SyntaxToken token);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, VisualBasicSyntaxContext context);
    private static bool IsGenericType(ISymbol symbol);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>> symbols, VisualBasicSyntaxContext context, SupportedPlatformData supportedPlatformData);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
}
[ExportCompletionProviderAttribute("InternalsVisibleToCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.InternalsVisibleToCompletionProvider : AbstractInternalsVisibleToCompletionProvider {
    internal string Language { get; }
    internal virtual string get_Language();
    protected virtual IImmutableList`1<SyntaxNode> GetAssemblyScopedAttributeSyntaxNodesOfDocument(SyntaxNode documentRoot);
    protected virtual SyntaxNode GetConstructorArgumentOfInternalsVisibleToAttribute(SyntaxNode internalsVisibleToAttribute);
    protected virtual bool ShouldTriggerAfterQuotes(SourceText text, int insertedCharacterPosition);
}
[ExportCompletionProviderAttribute("KeywordCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.KeywordCompletionProvider : AbstractKeywordCompletionProvider`1<VisualBasicSyntaxContext> {
    private static ImmutableArray`1<string> s_tags;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    private static CompletionItemRules s_tupleRules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static KeywordCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual CompletionItem CreateItem(RecommendedKeyword keyword, VisualBasicSyntaxContext context, CancellationToken cancellationToken);
}
[ExportArgumentProviderAttribute("LastBuiltInArgumentProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.LastBuiltInArgumentProvider : ArgumentProvider {
    public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
[ExportCompletionProviderAttribute("LastBuiltInCompletionProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.LastBuiltInCompletionProvider : CompletionProvider {
    public virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[ExportCompletionProviderAttribute("NamedParameterCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.NamedParameterCompletionProvider : LSPCompletionProvider {
    internal static string s_colonEquals;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    private static CompletionItemRules s_itemRules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static NamedParameterCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.NamedParameterCompletionProvider/VB$StateMachine_9_ProvideCompletionsAsync")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    private static bool IsValid(ImmutableArray`1<ISymbol> parameterList, ISet`1<string> existingNamedParameters);
    private static ISet`1<string> GetExistingNamedParameters(ArgumentListSyntax argumentList, int position);
    private static IEnumerable`1<ImmutableArray`1<ISymbol>> GetParameterLists(SemanticModel semanticModel, int position, SyntaxNode invocableNode, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<ISymbol>> GetObjectCreationExpressionParameterLists(SemanticModel semanticModel, int position, ObjectCreationExpressionSyntax objectCreationExpression, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<ISymbol>> GetAttributeParameterLists(SemanticModel semanticModel, int position, AttributeSyntax attribute, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<ISymbol>> GetInvocationExpressionParameterLists(SemanticModel semanticModel, int position, InvocationExpressionSyntax invocationExpression, CancellationToken cancellationToken);
    private static void GetInvocableNode(SyntaxToken token, SyntaxNode& invocableNode, ArgumentListSyntax& argumentList);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("ObjectCreationCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.ObjectCreationCompletionProvider : AbstractObjectCreationCompletionProvider`1<VisualBasicSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    private static CompletionItemRules s_rules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static ObjectCreationCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual SyntaxNode GetObjectCreationNewExpression(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>> symbols);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, VisualBasicSyntaxContext context);
}
[ExportCompletionProviderAttribute("ObjectInitializerCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.ObjectInitializerCompletionProvider : AbstractObjectInitializerCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    protected virtual HashSet`1<string> GetInitializedMembers(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected virtual Tuple`2<ITypeSymbol, Location> GetInitializedType(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual Task`1<bool> IsExclusiveAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual bool IsInitializable(ISymbol member, INamedTypeSymbol containingType);
    protected virtual string EscapeIdentifier(ISymbol symbol);
    private static bool IsValidProperty(ISymbol member);
}
[ExportCompletionProviderAttribute("OverrideCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.OverrideCompletionProvider : AbstractOverrideCompletionProvider {
    private bool _isFunction;
    private bool _isSub;
    private bool _isProperty;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    protected virtual SyntaxNode GetSyntax(SyntaxToken commonSyntaxToken);
    protected virtual SyntaxToken GetToken(CompletionItem completionItem, SyntaxTree syntaxTree, CancellationToken cancellationToken);
    public virtual SyntaxToken FindStartingToken(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool TryDetermineModifiers(SyntaxToken startToken, SourceText text, int startLine, Accessibility& seenAccessibility, DeclarationModifiers& modifiers);
    public virtual bool TryDetermineReturnType(SyntaxToken startToken, SemanticModel semanticModel, CancellationToken cancellationToken, ITypeSymbol& returnType, SyntaxToken& nextToken);
    public virtual ImmutableArray`1<ISymbol> FilterOverrides(ImmutableArray`1<ISymbol> members, ITypeSymbol returnType);
    private static bool OverridesObjectMethod(IMethodSymbol method);
    protected virtual int GetTargetCaretPosition(SyntaxNode caretTarget);
}
[ExportCompletionProviderAttribute("PartialTypeCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.PartialTypeCompletionProvider : AbstractPartialTypeCompletionProvider`1<VisualBasicSyntaxContext> {
    private static string InsertionTextOnOpenParen;
    private static SymbolDisplayFormat _insertionTextFormatWithGenerics;
    private static SymbolDisplayFormat _displayTextFormat;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static PartialTypeCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual SyntaxNode GetPartialTypeSyntaxNode(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(INamedTypeSymbol symbol, VisualBasicSyntaxContext context);
    protected virtual ImmutableArray`1<KeyValuePair`2<string, string>> GetProperties(INamedTypeSymbol symbol, VisualBasicSyntaxContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.PartialTypeCompletionProvider/VB$StateMachine_14_GetTextChangeAsync")]
public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[CompilerGeneratedAttribute]
private Task`1<Nullable`1<TextChange>> $VB$ClosureStub_GetTextChangeAsync_MyBase(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("PreprocessorCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.PreprocessorCompletionProvider : AbstractPreprocessorCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
[ExportCompletionProviderAttribute("SymbolCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.SymbolCompletionProvider : AbstractRecommendationServiceBasedCompletionProvider`1<VisualBasicSyntaxContext> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<ValueTuple`3<bool, bool, bool>, CompletionItemRules> s_cachedRules;
    [CompilerGeneratedAttribute]
private CompletionItemSelectionBehavior _PreselectedItemSelectionBehavior;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    protected CompletionItemSelectionBehavior PreselectedItemSelectionBehavior { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static SymbolCompletionProvider();
    private static CompletionItemRules MakeRule(ValueTuple`3<bool, bool, bool> context);
    internal virtual string get_Language();
    [CompilerGeneratedAttribute]
protected virtual CompletionItemSelectionBehavior get_PreselectedItemSelectionBehavior();
    protected virtual Task`1<bool> ShouldPreselectInferredTypesAsync(CompletionContext completionContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    protected virtual Task`1<bool> ShouldProvideAvailableSymbolsInCurrentContextAsync(CompletionContext completionContext, VisualBasicSyntaxContext syntaxContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsTriggerOnDot(SyntaxToken token, int characterPositoin);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, VisualBasicSyntaxContext context);
    protected virtual string GetFilterText(ISymbol symbol, string displayText, VisualBasicSyntaxContext context);
    protected virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<SymbolAndSelectionInfo<VisualBasicSyntaxContext>> symbols, VisualBasicSyntaxContext context);
    protected virtual bool IsInstrinsic(ISymbol s);
}
[ExportCompletionProviderAttribute("TypeImportCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.TypeImportCompletionProvider : AbstractTypeImportCompletionProvider`1<SimpleImportsClauseSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsFinalSemicolonOfUsingOrExtern(SyntaxNode directive, SyntaxToken token);
    protected virtual Task`1<bool> ShouldProvideParenthesisCompletionAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Completion.Providers.ITypeImportCompletionService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.TypeImportCompletionServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportCompletionProviderAttribute("VisualBasicSuggestionModeCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.VisualBasicSuggestionModeCompletionProvider : AbstractSuggestionModeCompletionProvider {
    internal string Language { get; }
    internal virtual string get_Language();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.VisualBasicSuggestionModeCompletionProvider/VB$StateMachine_3_GetSuggestionModeItemAsync")]
protected virtual Task`1<CompletionItem> GetSuggestionModeItemAsync(Document document, int position, TextSpan itemSpan, CompletionTrigger trigger, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("XmlDocCommentCompletionProvider", "Visual Basic")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.XmlDocCommentCompletionProvider : AbstractDocCommentCompletionProvider`1<DocumentationCommentTriviaSyntax> {
    private static ImmutableArray`1<string> s_keywordNames;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> _TriggerCharacters;
    private static CompletionItemRules s_defaultRules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static XmlDocCommentCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public static SyntaxToken GetPreviousTokenIfTouchingText(SyntaxToken token, int position);
    private static bool IsText(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Completion.Providers.XmlDocCommentCompletionProvider/VB$StateMachine_11_GetItemsWorkerAsync")]
protected virtual Task`1<IEnumerable`1<CompletionItem>> GetItemsWorkerAsync(Document document, int position, CompletionTrigger trigger, CancellationToken cancellationToken);
    private void AddXmlElementItems(List`1<CompletionItem> items, SyntaxNode xmlElement);
    private IEnumerable`1<CompletionItem> GetCloseTagItem(SyntaxToken token);
    private static string GetStartTagName(SyntaxNode element);
    private void TryGetAttributes(SyntaxToken token, int position, List`1<CompletionItem> items, ISymbol symbol);
    protected virtual ImmutableArray`1<string> GetKeywordNames();
    protected virtual IEnumerable`1<string> GetExistingTopLevelElementNames(DocumentationCommentTriviaSyntax parentTrivia);
    protected virtual IEnumerable`1<string> GetExistingTopLevelAttributeValues(DocumentationCommentTriviaSyntax syntax, string elementName, string attributeName);
    private static ValueTuple`2<string, SyntaxList`1<XmlNodeSyntax>> GetElementNameAndAttributes(XmlNodeSyntax node);
    private string GetAttributeValue(XmlNodeSyntax attribute);
    private IEnumerable`1<CompletionItem> GetAttributes(SyntaxToken token, string tagName, SyntaxList`1<XmlNodeSyntax> attributes);
    private static string GetAttributeName(XmlNodeSyntax node);
    protected virtual ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Completion.VisualBasicCompletionService : CommonCompletionService {
    private CompletionRules _latestRules;
    public string Language { get; }
    private VisualBasicCompletionService(SolutionServices services, IAsynchronousOperationListenerProvider listenerProvider);
    public virtual string get_Language();
    internal virtual CompletionRules GetRules(CompletionOptions options);
    protected virtual CompletionItem GetBetterItem(CompletionItem item, CompletionItem existingItem);
    protected virtual bool ItemsMatch(CompletionItem item, CompletionItem existingItem);
    private string GetChangeText(CompletionItem item);
    public virtual TextSpan GetDefaultCompletionListSpan(SourceText text, int caretPosition);
    internal virtual bool SupportsTriggerOnDeletion(CompletionOptions options);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConflictMarkerResolution.VisualBasicResolveConflictMarkerCodeFixProvider : AbstractResolveConflictMarkerCodeFixProvider {
    private static string BC37284;
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertAnonymousType.VisualBasicConvertAnonymousTypeToClassCodeRefactoringProvider : AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6<ExpressionSyntax, NameSyntax, IdentifierNameSyntax, ObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, NamespaceBlockSyntax> {
    protected virtual ObjectCreationExpressionSyntax CreateObjectCreationExpression(NameSyntax nameNode, AnonymousObjectCreationExpressionSyntax anonymousObject);
    private ArgumentListSyntax CreateArgumentList(ObjectMemberInitializerSyntax initializer);
    private SeparatedSyntaxList`1<ArgumentSyntax> CreateArguments(SeparatedSyntaxList`1<FieldInitializerSyntax> initializers);
    private SyntaxNodeOrTokenList CreateArguments(SyntaxNodeOrTokenList list);
    private SyntaxNodeOrToken CreateArgumentOrComma(SyntaxNodeOrToken declOrComma);
    private static ArgumentSyntax CreateArgument(FieldInitializerSyntax initializer);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertAnonymousTypeToTuple.VisualBasicConvertAnonymousTypeToTupleCodeRefactoringProvider : AbstractConvertAnonymousTypeToTupleCodeRefactoringProvider`3<ExpressionSyntax, TupleExpressionSyntax, AnonymousObjectCreationExpressionSyntax> {
    protected virtual int GetInitializerCount(AnonymousObjectCreationExpressionSyntax anonymousType);
    protected virtual TupleExpressionSyntax ConvertToTuple(AnonymousObjectCreationExpressionSyntax anonCreation);
    private SeparatedSyntaxList`1<SimpleArgumentSyntax> ConvertInitializers(SeparatedSyntaxList`1<FieldInitializerSyntax> initializers);
    private SimpleArgumentSyntax ConvertInitializer(FieldInitializerSyntax field);
    private static NameColonEqualsSyntax GetNameEquals(FieldInitializerSyntax field);
    private static ExpressionSyntax GetExpression(FieldInitializerSyntax field);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertAutoPropertyToFullProperty.VisualBasicConvertAutoPropertyToFullPropertyCodeRefactoringProvider : AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`3<PropertyStatementSyntax, TypeBlockSyntax, VisualBasicCodeGenerationContextInfo> {
    private static string Underscore;
    protected virtual Task`1<string> GetFieldNameAsync(Document document, IPropertySymbol propertySymbol, NamingStylePreferencesProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetNewAccessors(VisualBasicCodeGenerationContextInfo info, SyntaxNode propertyNode, string fieldName, SyntaxGenerator generator, CancellationToken cancellationToken);
    private static bool IsReadOnly(PropertyStatementSyntax propertySyntax);
    protected virtual SyntaxNode GetPropertyWithoutInitializer(SyntaxNode propertyNode);
    protected virtual SyntaxNode GetInitializerValue(SyntaxNode propertyNode);
    protected virtual SyntaxNode ConvertPropertyToExpressionBodyIfDesired(VisualBasicCodeGenerationContextInfo info, SyntaxNode propertyNode);
    protected virtual SyntaxNode GetTypeBlock(SyntaxNode syntaxNode);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertCast.VisualBasicConvertDirectCastToTryCastCodeRefactoringProvider : AbstractConvertCastCodeRefactoringProvider`3<TypeSyntax, DirectCastExpressionSyntax, TryCastExpressionSyntax> {
    [CompilerGeneratedAttribute]
private int _FromKind;
    protected int FromKind { get; }
    protected virtual string GetTitle();
    [CompilerGeneratedAttribute]
protected virtual int get_FromKind();
    protected virtual TypeSyntax GetTypeNode(DirectCastExpressionSyntax from);
    protected virtual TryCastExpressionSyntax ConvertExpression(DirectCastExpressionSyntax fromExpression, NullableContext nullableContext, bool isReferenceType);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertConversionOperators.VisualBasicConvertTryCastToDirectCastCodeRefactoringProvider : AbstractConvertCastCodeRefactoringProvider`3<TypeSyntax, TryCastExpressionSyntax, DirectCastExpressionSyntax> {
    [CompilerGeneratedAttribute]
private int _FromKind;
    protected int FromKind { get; }
    protected virtual string GetTitle();
    [CompilerGeneratedAttribute]
protected virtual int get_FromKind();
    protected virtual TypeSyntax GetTypeNode(TryCastExpressionSyntax from);
    protected virtual DirectCastExpressionSyntax ConvertExpression(TryCastExpressionSyntax fromExpression, NullableContext nullableContext, bool isReferenceType);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertForEachToFor.VisualBasicConvertForEachToForCodeRefactoringProvider : AbstractConvertForEachToForCodeRefactoringProvider`2<StatementSyntax, ForEachBlockSyntax> {
    [CompilerGeneratedAttribute]
private string _Title;
    protected string Title { get; }
    [CompilerGeneratedAttribute]
protected virtual string get_Title();
    protected virtual bool IsValid(ForEachBlockSyntax foreachNode);
    protected virtual bool ValidLocation(ForEachInfo<StatementSyntax, ForEachBlockSyntax> foreachInfo);
    protected virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetForEachBody(ForEachBlockSyntax foreachBlock);
    protected virtual void ConvertToForStatement(SemanticModel model, ForEachInfo<StatementSyntax, ForEachBlockSyntax> foreachInfo, SyntaxEditor editor, CancellationToken cancellationToken);
    private SyntaxList`1<StatementSyntax> GetForLoopBody(SyntaxGenerator generator, ForEachInfo<StatementSyntax, ForEachBlockSyntax> foreachInfo, SyntaxNode collectionVariableName, SyntaxToken indexVariable);
    private static void GetVariableNameAndType(ForEachStatementSyntax forEachStatement, SyntaxNode& foreachVariable, SyntaxNode& type);
    protected virtual bool IsSupported(ILocalSymbol foreachVariable, IForEachLoopOperation foreachOperation, ForEachBlockSyntax foreachStatement);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertForToForEach.VisualBasicConvertForToForEachCodeRefactoringProvider : AbstractConvertForToForEachCodeRefactoringProvider`6<StatementSyntax, ForBlockSyntax, ExpressionSyntax, MemberAccessExpressionSyntax, TypeSyntax, VariableDeclaratorSyntax> {
    protected virtual string GetTitle();
    protected virtual SyntaxList`1<StatementSyntax> GetBodyStatements(ForBlockSyntax forStatement);
    protected virtual bool IsValidVariableDeclarator(VariableDeclaratorSyntax firstVariable);
    protected virtual bool TryGetForStatementComponents(ForBlockSyntax forBlock, SyntaxToken& iterationVariable, ExpressionSyntax& initializer, MemberAccessExpressionSyntax& memberAccess, ExpressionSyntax& stepValueExpressionOpt, CancellationToken cancellationToken);
    protected virtual SyntaxNode ConvertForNode(ForBlockSyntax currentFor, TypeSyntax typeNode, SyntaxToken foreachIdentifier, ExpressionSyntax collectionExpression, ITypeSymbol iterationVariableType);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertIfToSwitch.VisualBasicConvertIfToSwitchCodeRefactoringProvider : AbstractConvertIfToSwitchCodeRefactoringProvider`4<ExecutableStatementSyntax, ExpressionSyntax, SyntaxNode, SyntaxNode> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<BinaryOperatorKind, ValueTuple`2<SyntaxKind, SyntaxKind>> s_operatorMap;
    private static VisualBasicConvertIfToSwitchCodeRefactoringProvider();
    public virtual SyntaxNode CreateSwitchExpressionStatement(SyntaxNode target, ImmutableArray`1<AnalyzedSwitchSection<ExecutableStatementSyntax, ExpressionSyntax, SyntaxNode, SyntaxNode>> sections, Feature<ExecutableStatementSyntax, ExpressionSyntax, SyntaxNode, SyntaxNode> feature);
    public virtual SyntaxNode CreateSwitchStatement(ExecutableStatementSyntax ifStatement, SyntaxNode expression, IEnumerable`1<SyntaxNode> sectionList);
    public virtual IEnumerable`1<SyntaxNode> AsSwitchSectionStatements(IOperation operation);
    public virtual SyntaxNode AsSwitchLabelSyntax(AnalyzedSwitchLabel<ExecutableStatementSyntax, ExpressionSyntax, SyntaxNode, SyntaxNode> label, Feature<ExecutableStatementSyntax, ExpressionSyntax, SyntaxNode, SyntaxNode> feature);
    private static CaseClauseSyntax AsCaseClauseSyntax(AnalyzedPattern<ExecutableStatementSyntax, ExpressionSyntax, SyntaxNode, SyntaxNode> pattern);
    public virtual string GetTitle(bool forSwitchExpression);
    public virtual Analyzer<ExecutableStatementSyntax, ExpressionSyntax, SyntaxNode, SyntaxNode> CreateAnalyzer(ISyntaxFacts syntaxFacts, ParseOptions options);
    protected virtual SyntaxTriviaList GetLeadingTriviaToTransfer(SyntaxNode syntaxToRemove);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertNumericLiteral.VisualBasicConvertNumericLiteralCodeRefactoringProvider : AbstractConvertNumericLiteralCodeRefactoringProvider`1<LiteralExpressionSyntax> {
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertToInterpolatedString.VisualBasicConvertConcatenationToInterpolatedStringRefactoringProvider : AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1<ExpressionSyntax> {
    protected virtual bool SupportsInterpolatedStringHandler(Compilation compilation);
    protected virtual string GetTextWithoutQuotes(string text, bool isVerbatim, bool isCharacterLiteral);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertToInterpolatedString.VisualBasicConvertPlaceholderToInterpolatedStringRefactoringProvider : AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`7<ExpressionSyntax, LiteralExpressionSyntax, InvocationExpressionSyntax, InterpolatedStringExpressionSyntax, ArgumentSyntax, ArgumentListSyntax, InterpolationSyntax> {
    protected virtual ExpressionSyntax ParseExpression(string text);
}
[ExtensionOrderAttribute]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.IConvertTupleToStructCodeRefactoringProvider", "Visual Basic", "Default")]
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertTupleToStruct.VisualBasicConvertTupleToStructCodeRefactoringProvider : AbstractConvertTupleToStructCodeRefactoringProvider`10<ExpressionSyntax, NameSyntax, IdentifierNameSyntax, LiteralExpressionSyntax, ObjectCreationExpressionSyntax, TupleExpressionSyntax, ArgumentSyntax, TupleTypeSyntax, TypeBlockSyntax, NamespaceBlockSyntax> {
    protected virtual ArgumentSyntax GetArgumentWithChangedName(ArgumentSyntax argument, string name);
    private static NameColonEqualsSyntax ChangeName(NameColonEqualsSyntax nameColonEquals, string name);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertTypeOfToNameOf.VisualBasicConvertGetTypeToNameOfCodeFixProvider : AbstractConvertTypeOfToNameOfCodeFixProvider`1<MemberAccessExpressionSyntax> {
    protected virtual string GetCodeFixTitle();
    protected virtual SyntaxNode GetSymbolTypeExpression(SemanticModel semanticModel, MemberAccessExpressionSyntax node, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.ConvertTypeOfToNameOf.VisualBasicConvertTypeOfToNameOfDiagnosticAnalyzer : AbstractConvertTypeOfToNameOfDiagnosticAnalyzer {
    private static string s_title;
    private static VisualBasicConvertTypeOfToNameOfDiagnosticAnalyzer();
    protected virtual bool IsValidTypeofAction(OperationAnalysisContext context);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Debugging.BreakpointResolver : AbstractBreakpointResolver {
    private static IEqualityComparer`1<string> s_identifierComparer;
    private static BreakpointResolver();
    public BreakpointResolver(Solution solution, string text);
    protected virtual IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol type, string name);
    protected virtual bool HasMethodBody(IMethodSymbol method, CancellationToken cancellationToken);
    protected virtual void ParseText(IList`1& nameParts, Nullable`1& parameterCount);
    private static ParameterListSyntax ParseParameterList(string text, int offset);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Debugging.DataTipInfoGetter.DataTipInfoGetterModule : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Debugging.DataTipInfoGetter.DataTipInfoGetterModule/VB$StateMachine_0_GetInfoAsync")]
internal static Task`1<DebugDataTipInfo> GetInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Debugging.LocationInfoGetter.LocationInfoGetterModule : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Debugging.LocationInfoGetter.LocationInfoGetterModule/VB$StateMachine_0_GetInfoAsync")]
internal static Task`1<DebugLocationInfo> GetInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.IBreakpointResolutionService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Debugging.VisualBasicBreakpointResolutionService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Debugging.VisualBasicBreakpointResolutionService/VB$StateMachine_1_GetBreakpointAsync")]
internal static Task`1<BreakpointResolutionResult> GetBreakpointAsync(Document document, int position, int length, CancellationToken cancellationToken);
    public sealed virtual override Task`1<BreakpointResolutionResult> ResolveBreakpointAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public sealed virtual override Task`1<IEnumerable`1<BreakpointResolutionResult>> ResolveBreakpointsAsync(Solution solution, string name, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.ILanguageDebugInfoService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Debugging.VisualBasicLanguageDebugInfoService : object {
    public sealed virtual override Task`1<DebugLocationInfo> GetLocationInfoAsync(Document document, int position, CancellationToken cancellationToken);
    public sealed virtual override Task`1<DebugDataTipInfo> GetDataTipInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.IProximityExpressionsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Debugging.VisualBasicProximityExpressionsService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Debugging.VisualBasicProximityExpressionsService/VB$StateMachine_2_GetProximityExpressionsAsync")]
public sealed virtual override Task`1<IList`1<string>> GetProximityExpressionsAsync(Document document, int position, CancellationToken cancellationToken);
    internal static IList`1<string> Do(SyntaxTree syntaxTree, int position);
    private static IList`1<string> Do(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static void AddRelevantExpressions(StatementSyntax statement, IList`1<ExpressionSyntax> expressions, bool includeDeclarations);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Debugging.VisualBasicProximityExpressionsService/VB$StateMachine_6_IsValidAsync")]
public sealed virtual override Task`1<bool> IsValidAsync(Document document, int position, string expressionValue, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.Diagnostics.Analyzers.VisualBasicNamingStyleDiagnosticAnalyzer : NamingStyleDiagnosticAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> _SupportedSyntaxKinds;
    protected ImmutableArray`1<SyntaxKind> SupportedSyntaxKinds { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SupportedSyntaxKinds();
    protected virtual bool ShouldIgnore(ISymbol symbol);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.Diagnostics.Analyzers.VisualBasicPreferFrameworkTypeDiagnosticAnalyzer : PreferFrameworkTypeDiagnosticAnalyzerBase`5<SyntaxKind, ExpressionSyntax, TypeSyntax, IdentifierNameSyntax, PredefinedTypeSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> _SyntaxKindsOfInterest;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual bool IsInMemberAccessOrCrefReferenceContext(ExpressionSyntax node);
    protected virtual bool IsIdentifierNameReplaceableWithFrameworkType(SemanticModel semanticModel, IdentifierNameSyntax node);
    protected virtual bool IsPredefinedTypeReplaceableWithFrameworkType(PredefinedTypeSyntax node);
    private static bool KeywordMatchesTypeName(SyntaxKind kind);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Diagnostics.IAnalyzerDriverService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Diagnostics.VisualBasicAnalyzerDriverService : object {
    public sealed virtual override void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.Diagnostics.VisualBasicUnboundIdentifiersDiagnosticAnalyzer : UnboundIdentifiersDiagnosticAnalyzerBase`4<SyntaxKind, SimpleNameSyntax, QualifiedNameSyntax, IncompleteMemberSyntax> {
    private LocalizableString _messageFormat;
    private static ImmutableArray`1<SyntaxKind> s_kindsOfInterest;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> _SyntaxKindsOfInterest;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    protected DiagnosticDescriptor DiagnosticDescriptor { get; }
    private static VisualBasicUnboundIdentifiersDiagnosticAnalyzer();
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual DiagnosticDescriptor get_DiagnosticDescriptor();
    protected virtual bool IsNameOf(SyntaxNode node);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentFormattingService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentationComments.VisualBasicDocumentationCommentFormattingService : AbstractDocumentationCommentFormattingService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentationComments.VisualBasicDocumentationCommentSnippetService : AbstractDocumentationCommentSnippetService`2<DocumentationCommentTriviaSyntax, DeclarationStatementSyntax> {
    [CompilerGeneratedAttribute]
private string _DocumentationCommentCharacter;
    [CompilerGeneratedAttribute]
private string _ExteriorTriviaText;
    [CompilerGeneratedAttribute]
private bool _AddIndent;
    public string DocumentationCommentCharacter { get; }
    protected string ExteriorTriviaText { get; }
    protected bool AddIndent { get; }
    [CompilerGeneratedAttribute]
public virtual string get_DocumentationCommentCharacter();
    [CompilerGeneratedAttribute]
protected virtual string get_ExteriorTriviaText();
    [CompilerGeneratedAttribute]
protected virtual bool get_AddIndent();
    protected virtual DeclarationStatementSyntax GetContainingMember(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual bool SupportsDocumentationComments(DeclarationStatementSyntax member);
    protected virtual bool HasDocumentationComment(DeclarationStatementSyntax member);
    private static bool SupportsDocumentationCommentReturnsClause(DeclarationStatementSyntax member);
    protected virtual int GetPrecedingDocumentationCommentCount(DeclarationStatementSyntax member);
    protected virtual List`1<string> GetDocumentationCommentStubLines(DeclarationStatementSyntax member, string existingCommentText);
    protected virtual bool IsSingleExteriorTrivia(DocumentationCommentTriviaSyntax documentationComment, String& existingCommentText);
    private static IList`1<SyntaxToken> GetTextTokensFollowingExteriorTrivia(XmlTextSyntax xmlText);
    protected virtual bool EndsWithSingleExteriorTrivia(DocumentationCommentTriviaSyntax documentationComment);
    protected virtual bool IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment);
    protected virtual SyntaxToken GetTokenToRight(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual SyntaxToken GetTokenToLeft(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual bool IsDocCommentNewLine(SyntaxToken token);
    protected virtual bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    protected virtual bool HasSkippedTrailingTrivia(SyntaxToken token);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentationComments.VisualBasicRemoveDocCommentNodeCodeFixProvider : AbstractRemoveDocCommentNodeCodeFixProvider`2<XmlElementSyntax, XmlTextSyntax> {
    private static string BC42305;
    private static string BC42306;
    private static string BC42307;
    private static string BC42313;
    private static string BC42315;
    private static string BC42317;
    internal ImmutableArray`1<string> Id;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string DocCommentSignifierToken { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string get_DocCommentSignifierToken();
    protected virtual SyntaxTriviaList GetRevisedDocCommentTrivia(string docCommentText);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextSyntax xmlText);
    protected virtual bool IsXmlWhitespaceToken(SyntaxToken token);
    protected virtual bool IsXmlNewLineToken(SyntaxToken token);
    private static bool IsWhitespace(string text);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.DocumentHighlighting.VisualBasicDocumentHighlightsService : AbstractDocumentHighlightsService {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VisualBasicDocumentHighlightsService(IEnumerable`1<Lazy`2<IEmbeddedLanguageDocumentHighlighter, EmbeddedLanguageMetadata>> services);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.BreakpointSpans : object {
    internal static bool TryGetBreakpointSpan(SyntaxTree tree, int position, CancellationToken cancellationToken, TextSpan& breakpointSpan);
    private static bool IsBlank(TextLine line);
    public static bool TryGetClosestBreakpointSpan(SyntaxNode root, int position, int minLength, TextSpan& span);
    private static TextSpan CreateSpan(SyntaxNode node);
    private static Nullable`1<TextSpan> TryCreateSpan(SeparatedSyntaxList`1<TNode> list);
    private static Nullable`1<TextSpan> TryCreateSpanForNode(SyntaxNode node, int position);
    private static TextSpan CreateSpanForMethodBase(MethodBaseSyntax methodBase);
    private static Nullable`1<TextSpan> TryCreateSpanForPropertyStatement(PropertyStatementSyntax node);
    private static Nullable`1<TextSpan> TryCreateSpanForVariableDeclaration(SyntaxTokenList modifiers, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators, int position);
    private static ModifiedIdentifierSyntax FindClosestNameWithInitializer(SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators, int position);
    private static TResult FindClosestNode(SeparatedSyntaxList`1<TListNode> nodes, int position, Func`2<TListNode, TResult> predicate);
    private static int GetItemIndexByPosition(SeparatedSyntaxList`1<TNode> list, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForFromClause(FromClauseSyntax fromClause, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForFunctionAggregation(FunctionAggregationSyntax functionAggregation);
    private static Nullable`1<TextSpan> TryCreateSpanForOrderByClause(OrderByClauseSyntax orderByClause, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForOrderingSyntax(OrderingSyntax orderingSyntax);
    private static Nullable`1<TextSpan> TryCreateSpanForPartitionWhileClauseSyntax(PartitionWhileClauseSyntax partitionWhileClause);
    private static Nullable`1<TextSpan> TryCreateSpanForCollectionRangeVariable(CollectionRangeVariableSyntax collectionRangeVariable);
    private static Nullable`1<TextSpan> TryCreateSpanForWhereClause(WhereClauseSyntax clause);
    private static Nullable`1<TextSpan> TryCreateSpanForGroupByClause(GroupByClauseSyntax clause, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForSelectClause(SelectClauseSyntax clause);
    private static Nullable`1<TextSpan> TryCreateSpanForLetClause(LetClauseSyntax clause, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForExpression(ExpressionSyntax expression);
    private static bool IsBreakableExpression(ExpressionSyntax expression);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.FieldOrPropertyDeclarationBody : MemberBody {
    public SyntaxNode InitializerActiveStatement { get; }
    public SyntaxNode OtherActiveStatementContainer { get; }
    public SyntaxTree SyntaxTree { get; }
    public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public SyntaxNode EncompassingAncestor { get; }
    public TextSpan Envelope { get; }
    public abstract virtual SyntaxNode get_InitializerActiveStatement();
    public abstract virtual SyntaxNode get_OtherActiveStatementContainer();
    public sealed virtual SyntaxTree get_SyntaxTree();
    public sealed virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    public sealed virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public sealed virtual SyntaxNode FindStatementAndPartner(TextSpan span, MemberBody partnerDeclarationBody, SyntaxNode& partnerStatement, Int32& statementPart);
    public virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
    public virtual SyntaxNode get_EncompassingAncestor();
    public virtual TextSpan get_Envelope();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public sealed virtual StateMachineInfo GetStateMachineInfo();
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.FieldWithInitializerDeclarationBody : FieldOrPropertyDeclarationBody {
    private VariableDeclaratorSyntax _variableDeclarator;
    public ModifiedIdentifierSyntax Name { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    public SyntaxNode OtherActiveStatementContainer { get; }
    public FieldWithInitializerDeclarationBody(VariableDeclaratorSyntax variableDeclarator);
    public ModifiedIdentifierSyntax get_Name();
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual SyntaxNode get_OtherActiveStatementContainer();
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.FieldWithMultipleArrayBoundsDeclarationBody : FieldOrPropertyDeclarationBody {
    private ModifiedIdentifierSyntax _identifier;
    public SyntaxNode InitializerActiveStatement { get; }
    public SyntaxNode OtherActiveStatementContainer { get; }
    public FieldWithMultipleArrayBoundsDeclarationBody(ModifiedIdentifierSyntax identifier);
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual SyntaxNode get_OtherActiveStatementContainer();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.FieldWithMultipleAsNewClauseDeclarationBody : FieldOrPropertyDeclarationBody {
    private ModifiedIdentifierSyntax _modifedIdentifier;
    public SyntaxNode InitializerActiveStatement { get; }
    public SyntaxNode OtherActiveStatementContainer { get; }
    public TextSpan Envelope { get; }
    public SyntaxNode EncompassingAncestor { get; }
    public FieldWithMultipleAsNewClauseDeclarationBody(ModifiedIdentifierSyntax modifiedIdentifier);
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual SyntaxNode get_OtherActiveStatementContainer();
    public virtual TextSpan get_Envelope();
    public virtual bool IsExcludedActiveStatementSpanWithinEnvelope(TextSpan span);
    public virtual SyntaxNode get_EncompassingAncestor();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.FieldWithSingleArrayBoundsDeclarationBody : FieldOrPropertyDeclarationBody {
    private VariableDeclaratorSyntax _variableDeclarator;
    public ModifiedIdentifierSyntax Name { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    public SyntaxNode OtherActiveStatementContainer { get; }
    public FieldWithSingleArrayBoundsDeclarationBody(VariableDeclaratorSyntax variableDeclarator);
    public ModifiedIdentifierSyntax get_Name();
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual SyntaxNode get_OtherActiveStatementContainer();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.FieldWithSingleAsNewClauseDeclarationBody : FieldOrPropertyDeclarationBody {
    private VariableDeclaratorSyntax _variableDeclarator;
    public SyntaxNode InitializerActiveStatement { get; }
    public SyntaxNode OtherActiveStatementContainer { get; }
    public FieldWithSingleAsNewClauseDeclarationBody(VariableDeclaratorSyntax variableDeclarator);
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual SyntaxNode get_OtherActiveStatementContainer();
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.MethodBody : AbstractSimpleMemberBody {
    public MethodBody(MethodBlockBaseSyntax node);
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual StateMachineInfo GetStateMachineInfo();
    public virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public virtual SyntaxNode FindStatementAndPartner(TextSpan span, MemberBody partnerDeclarationBody, SyntaxNode& partnerStatement, Int32& statementPart);
    public virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.PropertyWithInitializerDeclarationBody : FieldOrPropertyDeclarationBody {
    [CompilerGeneratedAttribute]
private PropertyStatementSyntax _PropertyStatement;
    public PropertyStatementSyntax PropertyStatement { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    public SyntaxNode OtherActiveStatementContainer { get; }
    public TextSpan Envelope { get; }
    public PropertyWithInitializerDeclarationBody(PropertyStatementSyntax propertyStatement);
    [CompilerGeneratedAttribute]
public PropertyStatementSyntax get_PropertyStatement();
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual SyntaxNode get_OtherActiveStatementContainer();
    public virtual TextSpan get_Envelope();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.PropertyWithNewClauseDeclarationBody : FieldOrPropertyDeclarationBody {
    [CompilerGeneratedAttribute]
private PropertyStatementSyntax _PropertyStatement;
    public PropertyStatementSyntax PropertyStatement { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    public SyntaxNode OtherActiveStatementContainer { get; }
    public TextSpan Envelope { get; }
    public PropertyWithNewClauseDeclarationBody(PropertyStatementSyntax propertyStatement);
    [CompilerGeneratedAttribute]
public PropertyStatementSyntax get_PropertyStatement();
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual SyntaxNode get_OtherActiveStatementContainer();
    public virtual TextSpan get_Envelope();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.SyntaxComparer : AbstractSyntaxComparer {
    internal static SyntaxComparer TopLevel;
    internal static SyntaxComparer Statement;
    private bool _matchingLambdas;
    protected int LabelCount { get; }
    private static SyntaxComparer();
    public SyntaxComparer(SyntaxNode oldRoot, SyntaxNode newRoot, IEnumerable`1<SyntaxNode> oldRootChildren, IEnumerable`1<SyntaxNode> newRootChildren, bool matchingLambdas, bool compareStatementSyntax);
    protected virtual bool IsLambdaBodyStatementOrExpression(SyntaxNode node);
    private static int TiedToAncestor(Label label);
    internal virtual int Classify(int kind, SyntaxNode node, Boolean& isLeaf);
    internal Label Classify(SyntaxKind kind, SyntaxNode nodeOpt, Boolean& isLeaf, bool ignoreVariableDeclarations);
    internal static Label ClassifyStatementSyntax(SyntaxKind kind, SyntaxNode nodeOpt, Boolean& isLeaf);
    private static Label ClassifyTopSyntax(SyntaxKind kind, SyntaxNode nodeOpt, Boolean& isLeaf, bool ignoreVariableDeclarations);
    protected virtual int GetLabel(SyntaxNode node);
    internal Label GetLabelImpl(SyntaxNode node);
    internal bool HasLabel(SyntaxKind kind, bool ignoreVariableDeclarations);
    protected virtual int get_LabelCount();
    protected virtual int TiedToAncestor(int label);
    public virtual bool ValuesEqual(SyntaxNode left, SyntaxNode right);
    protected virtual bool TryComputeWeightedDistance(SyntaxNode leftNode, SyntaxNode rightNode, Double& distance);
    private static double ComputeWeightedDistanceOfLambdas(LambdaHeaderSyntax leftHeader, LambdaHeaderSyntax rightHeader, IEnumerable`1<SyntaxToken> leftBody, IEnumerable`1<SyntaxToken> rightBody);
    private static double ComputeWeightedDistance(SyntaxNode leftHeader, SyntaxList`1<StatementSyntax> leftStatements, SyntaxNode rightHeader, SyntaxList`1<StatementSyntax> rightStatements);
    private static double ComputeWeightedDistance(SyntaxNode leftControlVariable, SyntaxNode leftHeader, SyntaxList`1<StatementSyntax> leftStatements, SyntaxNode rightControlVariable, SyntaxNode rightHeader, SyntaxList`1<StatementSyntax> rightStatements);
    private static bool TryComputeLocalsDistance(SyntaxList`1<StatementSyntax> left, SyntaxList`1<StatementSyntax> right, Double& distance);
    private static void GetLocalNames(SyntaxList`1<StatementSyntax> statements, List`1& result);
    private static void GetLocalNames(VariableDeclaratorSyntax localDecl, List`1& result);
    private static Nullable`1<SyntaxNodeOrToken> TryGetName(SyntaxNode node);
    public virtual double GetDistance(SyntaxNode oldNode, SyntaxNode newNode);
    internal static double ComputeValueDistance(SyntaxNode leftNode, SyntaxNode rightNode);
    internal static double ComputeDistance(SyntaxNodeOrToken oldNodeOrToken, SyntaxNodeOrToken newNodeOrToken);
    internal static double ComputeDistance(SyntaxList`1<TSyntaxNode> oldList, SyntaxList`1<TSyntaxNode> newList);
    internal static double ComputeDistance(SeparatedSyntaxList`1<TSyntaxNode> oldList, SeparatedSyntaxList`1<TSyntaxNode> newList);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.SyntaxComparer/VB$StateMachine_32_GetDescendantTokensIgnoringSeparators`1")]
internal static IEnumerable`1<SyntaxToken> GetDescendantTokensIgnoringSeparators(SyntaxList`1<TSyntaxNode> list);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.SyntaxComparer/VB$StateMachine_33_GetDescendantTokensIgnoringSeparators`1")]
private static IEnumerable`1<SyntaxToken> GetDescendantTokensIgnoringSeparators(SeparatedSyntaxList`1<TSyntaxNode> list);
    public static double ComputeDistance(SyntaxNode oldNode, SyntaxNode newNode);
    public static double ComputeDistance(SyntaxToken oldToken, SyntaxToken newToken);
    private static ImmutableArray`1<T> CreateArrayForDistanceCalculation(IEnumerable`1<T> enumerable);
    public static double ComputeDistance(IEnumerable`1<SyntaxToken> oldTokens, IEnumerable`1<SyntaxToken> newTokens);
    public static double ComputeDistance(IEnumerable`1<SyntaxNode> oldTokens, IEnumerable`1<SyntaxNode> newTokens);
    public static IEnumerable`1<SequenceEdit> GetSequenceEdits(IEnumerable`1<SyntaxNode> oldNodes, IEnumerable`1<SyntaxNode> newNodes);
    public static IEnumerable`1<SequenceEdit> GetSequenceEdits(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    public static IEnumerable`1<SequenceEdit> GetSequenceEdits(IEnumerable`1<SyntaxToken> oldTokens, IEnumerable`1<SyntaxToken> newTokens);
    public static IEnumerable`1<SequenceEdit> GetSequenceEdits(ImmutableArray`1<SyntaxToken> oldTokens, ImmutableArray`1<SyntaxToken> newTokens);
    [CompilerGeneratedAttribute]
private bool _Lambda$__18-0(SyntaxKind childKind);
    [CompilerGeneratedAttribute]
private bool _Lambda$__18-2(SyntaxKind childKind);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.SyntaxUtilities : object {
    public static LambdaBody CreateLambdaBody(SyntaxNode node);
    public static MemberBody TryGetDeclarationBody(SyntaxNode node);
    public static bool HasAsNewClause(VariableDeclaratorSyntax variableDeclarator);
    public static bool HasAsNewClause(PropertyStatementSyntax propertyStatement);
    internal static bool IsFieldDeclaration(ModifiedIdentifierSyntax node);
    internal static bool IsFieldDeclaration(VariableDeclaratorSyntax node);
    internal static ImmutableArray`1<ISymbol> GetArrayBoundsCapturedVariables(SemanticModel model, ArgumentListSyntax arrayBounds);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.SyntaxUtilities/VB$StateMachine_8_GetArgumentExpressions")]
private static IEnumerable`1<ExpressionSyntax> GetArgumentExpressions(ArgumentSyntax argument);
    [ConditionalAttribute("DEBUG")]
public static void AssertIsBody(SyntaxNode syntax, bool allowLambda);
    public static SyntaxList`1<SyntaxNode> GetBody(LambdaExpressionSyntax node);
    public static bool IsParameterlessConstructor(SyntaxNode declaration);
    public static bool HasBackingField(SyntaxNode propertyDeclaration);
    public static bool IsAsyncMethodOrLambda(SyntaxNode declarationOrBody);
    public static bool IsIteratorMethodOrLambda(SyntaxNode declaration);
    public static ImmutableArray`1<SyntaxNode> GetAwaitExpressions(SyntaxNode body);
    public static ImmutableArray`1<SyntaxNode> GetYieldStatements(SyntaxNode body);
    public static SyntaxTokenList GetModifiers(SyntaxNode declarationOrBody);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.VisualBasicEditAndContinueAnalyzer : AbstractEditAndContinueAnalyzer {
    protected string LineDirectiveKeyword { get; }
    protected ushort LineDirectiveSyntaxKind { get; }
    internal SyntaxNode EmptyCompilationUnit { get; }
    internal Func`2<SyntaxNode, bool> IsLambda { get; }
    internal Func`2<SyntaxNode, bool> IsNotLambda { get; }
    protected SymbolDisplayFormat ErrorDisplayFormat { get; }
    public VisualBasicEditAndContinueAnalyzer(Action`1<SyntaxNode> testFaultInjector);
    internal virtual bool TryFindMemberDeclaration(SyntaxNode rootOpt, SyntaxNode node, TextSpan activeSpan, OneOrMany`1& declarations);
    internal virtual MemberBody TryGetDeclarationBody(SyntaxNode node, ISymbol symbol);
    internal virtual bool IsDeclarationWithSharedBody(SyntaxNode declaration, ISymbol member);
    protected virtual IEnumerable`1<SyntaxNode> GetVariableUseSites(IEnumerable`1<SyntaxNode> roots, ISymbol localOrParameter, SemanticModel model, CancellationToken cancellationToken);
    internal static SyntaxNode FindStatementAndPartner(TextSpan span, SyntaxNode body, SyntaxNode partnerBody, SyntaxNode& partnerStatement, Int32& statementPart);
    internal virtual bool IsClosureScope(SyntaxNode node);
    internal virtual SyntaxNode GetCapturedParameterScope(SyntaxNode methodOrLambda);
    protected virtual LambdaBody FindEnclosingLambdaBody(SyntaxNode encompassingAncestor, SyntaxNode node);
    protected virtual Match`1<SyntaxNode> ComputeTopLevelMatch(SyntaxNode oldCompilationUnit, SyntaxNode newCompilationUnit);
    protected virtual Nullable`1<BidirectionalMap`1<SyntaxNode>> ComputeParameterMap(SyntaxNode oldDeclaration, SyntaxNode newDeclaration);
    private static Match`1<SyntaxNode> GetTopLevelMatch(SyntaxNode oldNode, SyntaxNode newNode);
    private static ValueTuple`2<SyntaxNode, SyntaxNode> GetDeclarationParameterLists(SyntaxNode declaration);
    protected virtual bool IsNamespaceDeclaration(SyntaxNode node);
    private static bool IsTypeDeclaration(SyntaxNode node);
    protected virtual bool IsCompilationUnitWithGlobalStatements(SyntaxNode node);
    protected virtual bool IsGlobalStatement(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.VisualBasicEditAndContinueAnalyzer/VB$StateMachine_18_GetTopLevelTypeDeclarations")]
protected virtual IEnumerable`1<SyntaxNode> GetTopLevelTypeDeclarations(SyntaxNode compilationUnit);
    protected virtual string get_LineDirectiveKeyword();
    protected virtual ushort get_LineDirectiveSyntaxKind();
    protected virtual IEnumerable`1<SequenceEdit> GetSyntaxSequenceEdits(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    internal virtual SyntaxNode get_EmptyCompilationUnit();
    internal virtual bool ExperimentalFeaturesEnabled(SyntaxTree tree);
    protected virtual bool StatementLabelEquals(SyntaxNode node1, SyntaxNode node2);
    private static bool ChildrenCompiledInBody(SyntaxNode node);
    protected virtual bool TryGetEnclosingBreakpointSpan(SyntaxToken token, TextSpan& span);
    protected virtual bool TryGetActiveSpan(SyntaxNode node, int statementPart, int minLength, TextSpan& span);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.VisualBasicEditAndContinueAnalyzer/VB$StateMachine_31_EnumerateNearStatements")]
protected virtual IEnumerable`1<ValueTuple`2<SyntaxNode, int>> EnumerateNearStatements(SyntaxNode statement);
    private static Nullable`1<SyntaxTokenList> GetFieldOrPropertyModifiers(SyntaxNode node);
    private static bool AreEquivalentIgnoringLambdaBodies(SyntaxNode left, SyntaxNode right);
    protected virtual bool AreEquivalentActiveStatements(SyntaxNode oldStatement, SyntaxNode newStatement, int statementPart);
    private static bool HasMultiInitializer(SyntaxNode modifiedIdentifier);
    protected virtual bool AreEquivalentImpl(SyntaxToken oldToken, SyntaxToken newToken);
    internal virtual bool IsInterfaceDeclaration(SyntaxNode node);
    internal virtual bool IsRecordDeclaration(SyntaxNode node);
    internal virtual SyntaxNode TryGetContainingTypeDeclaration(SyntaxNode node);
    internal virtual bool IsDeclarationWithInitializer(SyntaxNode declaration);
    internal virtual bool IsPrimaryConstructorDeclaration(SyntaxNode declaration);
    private static ExpressionSyntax GetInitializerExpression(EqualsValueSyntax equalsValue, AsClauseSyntax asClause);
    protected virtual SyntaxNode GetSymbolDeclarationSyntax(ISymbol symbol, Func`2<ImmutableArray`1<SyntaxReference>, SyntaxReference> selector, CancellationToken cancellationToken);
    protected virtual ISymbol GetDeclaredSymbol(SemanticModel model, SyntaxNode declaration, CancellationToken cancellationToken);
    internal virtual bool IsConstructorWithMemberInitializers(ISymbol symbol, CancellationToken cancellationToken);
    internal virtual bool IsPartial(INamedTypeSymbol type);
    protected virtual OneOrMany`1<ValueTuple`2<ISymbol, ISymbol>> GetEditedSymbols(EditKind editKind, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel oldModel, SemanticModel newModel, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.VisualBasicEditAndContinueAnalyzer/VB$StateMachine_48_PairSymbols")]
private static IEnumerable`1<ValueTuple`2<ISymbol, ISymbol>> PairSymbols(OneOrMany`1<ISymbol> oldSymbols, OneOrMany`1<ISymbol> newSymbols);
    protected virtual void AddSymbolEdits(TemporaryArray`1& result, EditKind editKind, SyntaxNode oldNode, ISymbol oldSymbol, SyntaxNode newNode, ISymbol newSymbol, SemanticModel oldModel, SemanticModel newModel, Match`1<SyntaxNode> topMatch, IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, SymbolInfoCache symbolCache, CancellationToken cancellationToken);
    private bool TryGetSyntaxNodesForEdit(EditKind editKind, SyntaxNode node, SemanticModel model, OneOrMany`1& symbols, CancellationToken cancellationToken);
    private ISymbol GetParameterContainingMemberOrType(SyntaxNode node, SyntaxNode otherNode, SemanticModel model, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> fromOtherMap, CancellationToken cancellationToken);
    private static SyntaxNode GetContainingDeclaration(SyntaxNode node);
    internal virtual Func`2<SyntaxNode, bool> get_IsLambda();
    internal virtual Func`2<SyntaxNode, bool> get_IsNotLambda();
    internal virtual bool IsNestedFunction(SyntaxNode node);
    internal virtual bool IsLocalFunction(SyntaxNode node);
    internal virtual bool IsGenericLocalFunction(SyntaxNode node);
    internal virtual bool TryGetLambdaBodies(SyntaxNode node, LambdaBody& body1, LambdaBody& body2);
    internal virtual IMethodSymbol GetLambdaExpressionSymbol(SemanticModel model, SyntaxNode lambdaExpression, CancellationToken cancellationToken);
    internal virtual SyntaxNode GetContainingQueryExpression(SyntaxNode node);
    internal virtual bool QueryClauseLambdasTypeEquivalent(SemanticModel oldModel, SyntaxNode oldNode, SemanticModel newModel, SyntaxNode newNode, CancellationToken cancellationToken);
    protected virtual SymbolDisplayFormat get_ErrorDisplayFormat();
    protected virtual Nullable`1<TextSpan> TryGetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    protected static TextSpan GetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    private static Nullable`1<TextSpan> TryGetDiagnosticSpanImpl(SyntaxNode node, EditKind editKind);
    protected virtual TextSpan GetBodyDiagnosticSpan(SyntaxNode node, EditKind editKind);
    internal static Nullable`1<TextSpan> TryGetDiagnosticSpanImpl(SyntaxKind kind, SyntaxNode node, EditKind editKind);
    private static TextSpan GetDiagnosticSpan(SyntaxToken ifKeyword, SyntaxNode condition, SyntaxToken thenKeywordOpt);
    private static TextSpan GetDiagnosticSpan(NamespaceStatementSyntax node);
    private static TextSpan GetDiagnosticSpan(TypeStatementSyntax node);
    private static TextSpan GetDiagnosticSpan(SyntaxTokenList modifiers, SyntaxNodeOrToken start, SyntaxNodeOrToken endNode);
    private static TextSpan GetDiagnosticSpan(MethodBaseSyntax header);
    private static TextSpan GetDiagnosticSpan(LambdaHeaderSyntax lambda);
    internal virtual TextSpan GetLambdaParameterDiagnosticSpan(SyntaxNode lambda, int ordinal);
    internal virtual string GetDisplayName(INamedTypeSymbol symbol);
    internal virtual string GetDisplayName(IMethodSymbol symbol);
    internal virtual string GetDisplayName(IPropertySymbol symbol);
    protected virtual string TryGetDisplayName(SyntaxNode node, EditKind editKind);
    protected static string GetDisplayName(SyntaxNode node, EditKind editKind);
    protected virtual string GetBodyDisplayName(SyntaxNode node, EditKind editKind);
    private static string TryGetDisplayNameImpl(SyntaxNode node, EditKind editKind);
    internal virtual void ReportTopLevelSyntacticRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, Edit`1<SyntaxNode> edit, Dictionary`2<SyntaxNode, EditKind> editMap);
    internal virtual bool HasUnsupportedOperation(IEnumerable`1<SyntaxNode> nodes, SyntaxNode& unsupportedNode, RudeEditKind& rudeEdit);
    protected virtual bool AreHandledEventsEqual(IMethodSymbol oldMethod, IMethodSymbol newMethod);
    internal virtual void ReportInsertedMemberSymbolRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, ISymbol newSymbol, SyntaxNode newNode, bool insertingIntoExistingContainingType);
    private static RudeEditKind GetInsertedMemberSymbolRudeEditKind(ISymbol newSymbol, bool insertingIntoExistingContainingType);
    protected virtual List`1<SyntaxNode> GetExceptionHandlingAncestors(SyntaxNode node, SyntaxNode root, bool isNonLeaf);
    internal virtual void ReportEnclosingExceptionHandlingRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IEnumerable`1<Edit`1<SyntaxNode>> exceptionHandlingEdits, SyntaxNode oldStatement, TextSpan newStatementSpan);
    private static bool AreExceptionHandlingPartsEquivalent(SyntaxNode oldNode, SyntaxNode newNode);
    protected virtual TextSpan GetExceptionHandlingRegion(SyntaxNode node, Boolean& coversAllChildren);
    internal virtual bool IsStateMachineMethod(SyntaxNode declaration);
    internal static StateMachineInfo GetStateMachineInfo(SyntaxNode body);
    internal virtual void ReportStateMachineSuspensionPointRudeEdits(DiagnosticContext diagnosticContext, SyntaxNode oldNode, SyntaxNode newNode);
    private static SyntaxNode FindContainingStatementPart(SyntaxNode node);
    private static bool HasNoSpilledState(SyntaxNode awaitExpression, SyntaxNode containingStatementPart);
    private static ExpressionSyntax GetExpressionFromStatementPart(SyntaxNode statement);
    private static bool IsSimpleAwaitAssignment(SyntaxNode node, SyntaxNode awaitExpression);
    internal virtual void ReportOtherRudeEditsAroundActiveStatement(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode oldActiveStatement, DeclarationBody oldBody, SyntaxNode newActiveStatement, DeclarationBody newBody, bool isNonLeaf);
    private static SyntaxNode FindOnErrorOrResumeStatement(DeclarationBody newBody);
    private void ReportRudeEditsForAncestorsDeclaringInterStatementTemps(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> forwardMap, SyntaxNode oldActiveStatement, SyntaxNode oldEncompassingAncestor, SyntaxNode newActiveStatement, SyntaxNode newEncompassingAncestor);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EditAndContinue.VisualBasicLambdaBody : LambdaBody {
    private SyntaxNode _node;
    public SyntaxTree SyntaxTree { get; }
    public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public SyntaxNode EncompassingAncestor { get; }
    public VisualBasicLambdaBody(SyntaxNode node);
    public virtual SyntaxTree get_SyntaxTree();
    public virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    public virtual SyntaxNode get_EncompassingAncestor();
    public virtual StateMachineInfo GetStateMachineInfo();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual LambdaBody TryGetPartnerLambdaBody(SyntaxNode newLambda);
    public virtual IEnumerable`1<SyntaxNode> GetExpressionsAndStatements();
    public virtual SyntaxNode GetLambda();
    public virtual bool IsSyntaxEquivalentTo(LambdaBody other);
    public virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguagesProvider", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.EmbeddedLanguages.LanguageServices.VisualBasicEmbeddedLanguagesProvider : AbstractEmbeddedLanguagesProvider {
    public static EmbeddedLanguageInfo Info;
    private static VisualBasicEmbeddedLanguagesProvider();
    public virtual string EscapeText(string text, SyntaxToken token);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.EncapsulateField.VisualBasicEncapsulateFieldService : AbstractEncapsulateFieldService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.EncapsulateField.VisualBasicEncapsulateFieldService/VB$StateMachine_1_RewriteFieldNameAndAccessibilityAsync")]
protected virtual Task`1<SyntaxNode> RewriteFieldNameAndAccessibilityAsync(string originalFieldName, bool makePrivate, Document document, SyntaxAnnotation declarationAnnotation, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.EncapsulateField.VisualBasicEncapsulateFieldService/VB$StateMachine_2_GetFieldsAsync")]
protected virtual Task`1<ImmutableArray`1<IFieldSymbol>> GetFieldsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    private static bool CanEncapsulate(FieldDeclarationSyntax field);
    protected static string MakeUnique(string baseName, string originalFieldName, INamedTypeSymbol containingType, bool willChangeFieldName);
    protected virtual ValueTuple`2<string, string> GenerateFieldAndPropertyNames(IFieldSymbol field);
    private static bool IsShadows(IFieldSymbol field);
    private static string MakeUnique(string propertyName, IFieldSymbol field);
    protected virtual IEnumerable`1<SyntaxNode> GetConstructorNodes(INamedTypeSymbol containingType);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ExtractInterface.VisualBasicExtractInterfaceService : AbstractExtractInterfaceService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ExtractInterface.VisualBasicExtractInterfaceService/VB$StateMachine_1_GetTypeDeclarationAsync")]
protected virtual Task`1<SyntaxNode> GetTypeDeclarationAsync(Document document, int position, TypeDiscoveryRule typeDiscoveryRule, CancellationToken cancellationToken);
    internal virtual string GetContainingNamespaceDisplay(INamedTypeSymbol typeSymbol, CompilationOptions compilationOptions);
    private static ImplementsClauseSyntax GetUpdatedImplementsClause(ImplementsClauseSyntax implementsClause, QualifiedNameSyntax qualifiedName);
    private static Solution CreateFinalSolution(Solution solutionWithInterfaceDocument, IEnumerable`1<DocumentId> documentIds, Dictionary`2<DocumentId, CompilationUnitSyntax> docToRootMap);
    internal virtual bool ShouldIncludeAccessibilityModifier(SyntaxNode typeNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ExtractInterface.VisualBasicExtractInterfaceService/VB$StateMachine_6_UpdateMembersWithExplicitImplementationsAsync")]
protected virtual Task`1<Solution> UpdateMembersWithExplicitImplementationsAsync(Solution unformattedSolution, IReadOnlyList`1<DocumentId> documentIds, INamedTypeSymbol extractedInterfaceSymbol, INamedTypeSymbol typeToExtractFrom, IEnumerable`1<ISymbol> includedMembers, ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationAnnotationMap, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.Extensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GetUnparenthesizedExpression(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetStatementContainer(SyntaxNode node);
    [ExtensionAttribute]
public static ExecutableStatementSyntax GetStatementUnderContainer(SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainStatement(SyntaxNode node, StatementSyntax statement);
    [ExtensionAttribute]
public static SyntaxNode GetOutermostNodeWithSameSpan(SyntaxNode initialNode, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static bool PartOfConstantInitializerExpression(SyntaxNode node);
    [ExtensionAttribute]
private static bool PartOfConstantInitializerExpression(SyntaxNode node, Func`2<T, SyntaxTokenList> modifiersGetter);
    [ExtensionAttribute]
public static bool IsArgumentForByRefParameter(SyntaxNode node, SemanticModel model, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainArgumentlessThrowWithoutEnclosingCatch(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan);
    [ExtensionAttribute]
public static bool ContainPreprocessorCrossOver(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllTrivia(IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
public static bool ContainsFieldInitializer(SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsDotMemberAccess(SyntaxNode node);
    [ExtensionAttribute]
public static bool UnderWithBlockContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool UnderObjectMemberInitializerContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool UnderValidContext(SyntaxToken token);
    [ExtensionAttribute]
public static bool ContainedInValidType(SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsInMethodBlockBody(MethodBlockBaseSyntax block, TextSpan textSpan);
    [ExtensionAttribute]
public static bool UnderValidContext(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsReturnableConstruct(SyntaxNode node);
    [ExtensionAttribute]
public static bool HasSyntaxAnnotation(HashSet`1<SyntaxAnnotation> set, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsFunctionValue(ISymbol symbol);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<T> ToSeparatedList(IEnumerable`1<Tuple`2<T, SyntaxToken>> nodes);
    [ExtensionAttribute]
public static ExecutableStatementSyntax CreateAssignmentExpressionStatementWithValue(SyntaxToken identifier, ExpressionSyntax rvalue);
    [ExtensionAttribute]
public static bool ProcessLocalDeclarationStatement(HashSet`1<SyntaxAnnotation> variableToRemoveMap, LocalDeclarationStatementSyntax declarationStatement, List`1<StatementSyntax> expressionStatements, List`1<VariableDeclaratorSyntax> variableDeclarators, List`1<SyntaxTrivia> triviaList);
    [ExtensionAttribute]
public static bool IsExpressionInCast(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsErrorType(ITypeSymbol type);
    [ExtensionAttribute]
public static bool IsObjectType(ITypeSymbol type);
}
[ExportAttribute("Microsoft.CodeAnalysis.ExtractMethod.IExtractMethodService")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ExtractMethod.IExtractMethodService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicExtractMethodService : AbstractExtractMethodService`5<VisualBasicSelectionValidator, VisualBasicMethodExtractor, VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax> {
    protected virtual VisualBasicSelectionValidator CreateSelectionValidator(SemanticDocument document, TextSpan textSpan, ExtractMethodOptions options, bool localFunction);
    protected virtual VisualBasicMethodExtractor CreateMethodExtractor(VisualBasicSelectionResult selectionResult, ExtractMethodGenerationOptions options, bool localFunction);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicMethodExtractor : MethodExtractor`3<VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax> {
    public VisualBasicMethodExtractor(VisualBasicSelectionResult result, ExtractMethodGenerationOptions options);
    protected virtual CodeGenerator<VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax> CreateCodeGenerator(AnalyzerResult<VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax> analyzerResult);
    protected virtual AnalyzerResult<VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax> Analyze(VisualBasicSelectionResult selectionResult, bool localFunction, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetInsertionPointNode(AnalyzerResult<VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax> analyzerResult, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicMethodExtractor/VB$StateMachine_7_PreserveTriviaAsync")]
protected virtual Task`1<TriviaResult<VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax>> PreserveTriviaAsync(VisualBasicSelectionResult selectionResult, CancellationToken cancellationToken);
    protected virtual Task`1<GeneratedCode<VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax>> GenerateCodeAsync(InsertionPoint insertionPoint, VisualBasicSelectionResult selectionResult, AnalyzerResult<VisualBasicSelectionResult, ExecutableStatementSyntax, ExpressionSyntax> analyzeResult, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected virtual AbstractFormattingRule GetCustomFormattingRule(Document document);
    protected virtual Nullable`1<SyntaxToken> GetInvocationNameToken(IEnumerable`1<SyntaxToken> methodNames);
    protected virtual SyntaxNode ParseTypeName(string name);
    protected virtual Task`1<ValueTuple`2<Document, Nullable`1<SyntaxToken>>> InsertNewLineBeforeLocalFunctionIfNecessaryAsync(Document document, Nullable`1<SyntaxToken> invocationNameToken, SyntaxNode methodDefinition, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicSelectionResult : SelectionResult`1<ExecutableStatementSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    private VisualBasicSelectionResult(TextSpan originalSpan, TextSpan finalSpan, ExtractMethodOptions options, bool selectionInExpression, SemanticDocument document, SyntaxAnnotation firstTokenAnnotation, SyntaxAnnotation lastTokenAnnotation, bool selectionChanged);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicSelectionResult/VB$StateMachine_0_CreateResultAsync")]
public static Task`1<VisualBasicSelectionResult> CreateResultAsync(TextSpan originalSpan, TextSpan finalSpan, ExtractMethodOptions options, bool selectionInExpression, SemanticDocument document, SyntaxToken firstToken, SyntaxToken lastToken, bool selectionChanged, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual bool UnderAnonymousOrLocalMethod(SyntaxToken token, SyntaxToken firstToken, SyntaxToken lastToken);
    public virtual SyntaxNode GetOutermostCallSiteContainerToProcess(CancellationToken cancellationToken);
    public virtual bool ContainingScopeHasAsyncKeyword();
    public virtual SyntaxNode GetContainingScope();
    public virtual ValueTuple`2<ITypeSymbol, bool> GetReturnType();
    private ITypeSymbol GetReturnTypeWorker();
    private static bool IsCoClassImplicitConversion(TypeInfo info, Conversion conversion, ISymbol coclassSymbol);
    public virtual ExecutableStatementSyntax GetFirstStatementUnderContainer();
    public virtual ExecutableStatementSyntax GetLastStatementUnderContainer();
    public SyntaxNode InnermostStatementContainer();
    public bool IsUnderModuleBlock();
    public bool ContainsInstanceExpression();
}
internal class Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicSelectionValidator : SelectionValidator`2<VisualBasicSelectionResult, ExecutableStatementSyntax> {
    public VisualBasicSelectionValidator(SemanticDocument document, TextSpan textSpan, ExtractMethodOptions options);
    public static bool Check(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool CheckExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static bool CheckStatement(StatementSyntax statement);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicSelectionValidator/VB$StateMachine_4_GetValidSelectionAsync")]
public virtual Task`1<ValueTuple`2<VisualBasicSelectionResult, OperationStatus>> GetValidSelectionAsync(CancellationToken cancellationToken);
    private static TextSpan GetControlFlowSpan(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selectionInfo);
    private static SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> CheckErrorCasesAndAppendDescriptions(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selectionInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool SelectionChanged(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selectionInfo);
    private static bool ContainsAllStaticLocalUsagesDefinedInSelectionIfExist(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selectionInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetFinalTokenCommonRoot(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selection);
    private static SyntaxNode GetCommonRoot(SyntaxToken token1, SyntaxToken token2);
    private static SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> FixUpFinalTokensAndAssignFinalSpan(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selectionInfo, SyntaxNode root, CancellationToken cancellationToken);
    private static SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> AdjustFinalTokensIfNextStatement(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selectionInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> AdjustFinalTokensBasedOnContext(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selectionInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> AssignInitialFinalTokens(SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> selectionInfo, SyntaxNode root, CancellationToken cancellationToken);
    private SelectionInfo<VisualBasicSelectionResult, ExecutableStatementSyntax> GetInitialSelectionInfo(SyntaxNode root);
    public virtual bool ContainsNonReturnExitPointsStatements(IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    public virtual IEnumerable`1<SyntaxNode> GetOuterReturnStatements(SyntaxNode commonRoot, IEnumerable`1<SyntaxNode> jumpsOutOfRegionStatements);
    public virtual bool IsFinalSpanSemanticallyValidSpan(SyntaxNode root, TextSpan textSpan, IEnumerable`1<SyntaxNode> returnStatements, CancellationToken cancellationToken);
    private static TextSpan GetAdjustedSpan(SyntaxNode root, TextSpan textSpan);
}
internal class Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicSyntaxTriviaService : AbstractSyntaxTriviaService {
    public static VisualBasicSyntaxTriviaService Instance;
    private static VisualBasicSyntaxTriviaService();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ExtractMethod.VisualBasicSyntaxTriviaServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Features.EmbeddedLanguages.EmbeddedLanguageUtilities : object {
    internal static void AddComment(SyntaxEditor editor, SyntaxToken stringLiteral, string commentContents);
    public static string EscapeText(string text);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.Features.EmbeddedLanguages.VisualBasicJsonDetectionAnalyzer : AbstractJsonDetectionAnalyzer {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Features.EmbeddedLanguages.VisualBasicJsonDetectionCodeFixProvider : AbstractJsonDetectionCodeFixProvider {
    protected virtual void AddComment(SyntaxEditor editor, SyntaxToken stringLiteral, string commentContents);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.Features.EmbeddedLanguages.VisualBasicJsonDiagnosticAnalyzer : AbstractJsonDiagnosticAnalyzer {
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.Features.EmbeddedLanguages.VisualBasicRegexDiagnosticAnalyzer : AbstractRegexDiagnosticAnalyzer {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.FileHeaders.VisualBasicFileHeaderCodeFixProvider : AbstractFileHeaderCodeFixProvider {
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.FileHeaders.VisualBasicFileHeaderDiagnosticAnalyzer : AbstractFileHeaderDiagnosticAnalyzer {
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
internal class Microsoft.CodeAnalysis.VisualBasic.FileHeaders.VisualBasicFileHeaderHelper : AbstractFileHeaderHelper {
    public static VisualBasicFileHeaderHelper Instance;
    public string CommentPrefix { get; }
    private static VisualBasicFileHeaderHelper();
    public virtual string get_CommentPrefix();
    protected virtual ReadOnlyMemory`1<char> GetTextContextOfComment(SyntaxTrivia commentTrivia);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.FindUsages.IFindUsagesLSPService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.FindUsages.VisualBasicFindUsagesLSPService : AbstractFindUsagesService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.FindUsages.IFindUsagesService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.FindUsages.VisualBasicFindUsagesService : AbstractFindUsagesService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Formatting.INewDocumentFormattingService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicNewDocumentFormattingService : AbstractNewDocumentFormattingService {
    [CompilerGeneratedAttribute]
private string _Language;
    protected string Language { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VisualBasicNewDocumentFormattingService(IEnumerable`1<Lazy`2<INewDocumentFormattingProvider, LanguageMetadata>> providers);
    [CompilerGeneratedAttribute]
protected virtual string get_Language();
}
[ExportNewDocumentFormattingProviderAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicOrganizeUsingsNewDocumentFormattingProvider : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicOrganizeUsingsNewDocumentFormattingProvider/VB$StateMachine_1_FormatNewDocumentAsync")]
public sealed virtual override Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateConstructor.GenerateConstructorCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateConstructor.GenerateConstructorDiagnosticIds : object {
    internal static string BC30057;
    internal static string BC30272;
    internal static string BC30274;
    internal static string BC30311;
    internal static string BC30389;
    internal static string BC30455;
    internal static string BC30512;
    internal static string BC32006;
    internal static string BC30387;
    internal static string BC30516;
    internal static string BC36625;
    internal static ImmutableArray`1<string> AllDiagnosticIds;
    internal static ImmutableArray`1<string> TooManyArgumentsDiagnosticIds;
    internal static ImmutableArray`1<string> CannotConvertDiagnosticIds;
    private static GenerateConstructorDiagnosticIds();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.IGenerateConstructorService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateConstructor.VisualBasicGenerateConstructorService : AbstractGenerateConstructorService`2<VisualBasicGenerateConstructorService, ExpressionSyntax> {
    protected virtual bool IsImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool TryInitializeImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual string GenerateNameForExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetArgumentType(SemanticModel semanticModel, Argument<VisualBasicGenerateConstructorService, ExpressionSyntax> argument, CancellationToken cancellationToken);
    protected virtual bool IsConstructorInitializerGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool TryInitializeConstructorInitializerGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool IsSimpleNameGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool TryInitializeSimpleNameGenerationState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeSimpleAttributeNameGenerationState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    private static ImmutableArray`1<Argument<VisualBasicGenerateConstructorService, ExpressionSyntax>> GetArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    protected virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected virtual IMethodSymbol GetCurrentConstructor(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    protected virtual IMethodSymbol GetDelegatedConstructor(SemanticModel semanticModel, IMethodSymbol constructor, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateConstructorFromMembers.VisualBasicGenerateConstructorFromMembersCodeRefactoringProvider : AbstractGenerateConstructorFromMembersCodeRefactoringProvider {
    internal VisualBasicGenerateConstructorFromMembersCodeRefactoringProvider(IPickMembersService pickMembersService_forTesting);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual string ToDisplayString(IParameterSymbol parameter, SymbolDisplayFormat format);
    protected virtual ValueTask`1<bool> PrefersThrowExpressionAsync(Document document, SimplifierOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual IFieldSymbol TryMapToWritableInstanceField(IPropertySymbol property, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateDefaultConstructors.VisualBasicGenerateDefaultConstructorsCodeFixProvider : AbstractGenerateDefaultConstructorCodeFixProvider {
    private static string BC30387;
    private static string BC40056;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Nullable`1<SyntaxToken> TryGetTypeName(SyntaxNode typeDeclaration);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateDefaultConstructors.IGenerateDefaultConstructorsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateDefaultConstructors.VisualBasicGenerateDefaultConstructorsService : AbstractGenerateDefaultConstructorsService`1<VisualBasicGenerateDefaultConstructorsService> {
    protected virtual bool TryInitializeState(SemanticDocument semanticDocument, TextSpan textSpan, CancellationToken cancellationToken, INamedTypeSymbol& classType);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateEqualsAndGetHashCodeFromMembers.VisualBasicGenericEqualsAndGetHashCodeService : AbstractGenerateEqualsAndGetHashCodeService {
    protected virtual bool TryWrapWithUnchecked(ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1& wrappedStatements);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.IGenerateEnumMemberService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateMember.GenerateEnumMember.VisualBasicGenerateEnumMemberService : AbstractGenerateEnumMemberService`3<VisualBasicGenerateEnumMemberService, SimpleNameSyntax, ExpressionSyntax> {
    protected virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected virtual bool TryInitializeIdentifierNameState(SemanticDocument document, SimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression);
}
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateMember.GenerateMethod.VisualBasicCommonGenerationServiceMethods : object {
    public static bool AreSpecialOptionsActive(SemanticModel semanticModel);
    public static bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateConversionService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateMember.GenerateMethod.VisualBasicGenerateConversionService : AbstractGenerateConversionService`4<VisualBasicGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual AbstractInvocationInfo<VisualBasicGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<VisualBasicGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> abstractState);
    protected virtual bool IsExplicitConversionGeneration(SyntaxNode node);
    protected virtual bool IsImplicitConversionGeneration(SyntaxNode node);
    private static bool IsInImplementsClause(SyntaxNode node);
    private static bool IsInMemberAccessExpression(SyntaxNode node);
    protected virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    protected virtual bool TryInitializeExplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeImplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool TryGetConversionMethodAndTypeToGenerateIn(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool IsCastExpression(SyntaxNode node);
    private static bool TryGetExplicitConversionMethodAndTypeToGenerateIn(SemanticDocument document, CastExpressionSyntax castExpression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool TryGetImplicitConversionMethodAndTypeToGenerateIn(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static IMethodSymbol GenerateMethodSymbol(INamedTypeSymbol typeToGenerateIn, INamedTypeSymbol parameterSymbol);
    protected virtual string GetExplicitConversionDisplayText(State<VisualBasicGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual string GetImplicitConversionDisplayText(State<VisualBasicGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateParameterizedMemberService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateMember.GenerateMethod.VisualBasicGenerateMethodService : AbstractGenerateMethodService`4<VisualBasicGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected virtual bool IsSimpleNameGeneration(SyntaxNode node);
    protected virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    protected virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeSimpleNameState(SemanticDocument document, SimpleNameSyntax simpleName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression, InvocationExpressionSyntax& invocationExpressionOpt, Boolean& isInConditionalAccessExpression);
    private static bool IsLegal(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual AbstractInvocationInfo<VisualBasicGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<VisualBasicGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual ITypeSymbol DetermineReturnTypeForSimpleNameOrMemberAccessExpression(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.GenerateMember.GenerateMethod.VisualBasicGenerateParameterizedMemberService`1 : AbstractGenerateParameterizedMemberService`4<TService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.IGenerateVariableService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateMember.GenerateVariable.VisualBasicGenerateVariableService : AbstractGenerateVariableService`3<VisualBasicGenerateVariableService, SimpleNameSyntax, ExpressionSyntax> {
    protected virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IPropertySymbol& propertySymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeIdentifierNameState(SemanticDocument document, SimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression, Boolean& isInExecutableBlock, Boolean& isConditionalAccessExpression);
    private static bool IsLegal(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual bool TryConvertToLocalDeclaration(ITypeSymbol type, SyntaxToken identifierToken, SemanticModel semanticModel, CancellationToken cancellationToken, SyntaxNode& newRoot);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateType.IGenerateTypeService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateType.VisualBasicGenerateTypeService : AbstractGenerateTypeService`6<VisualBasicGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeBlockSyntax, ArgumentSyntax> {
    protected string DefaultFileExtension { get; }
    protected virtual string get_DefaultFileExtension();
    protected virtual IList`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IList`1<ArgumentSyntax> arguments, CancellationToken cancellationToken);
    protected virtual ExpressionSyntax GetLeftSideOfDot(SimpleNameSyntax simpleName);
    protected virtual bool IsArrayElementType(ExpressionSyntax expression);
    protected virtual bool IsInCatchDeclaration(ExpressionSyntax expression);
    protected virtual bool IsInInterfaceList(ExpressionSyntax expression);
    protected virtual bool IsInValueTypeConstraintContext(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual bool TryGetArgumentList(ObjectCreationExpressionSyntax objectCreationExpression, IList`1& argumentList);
    protected virtual bool TryGetNameParts(ExpressionSyntax expression, IList`1& nameParts);
    protected virtual bool TryInitializeState(SemanticDocument document, SimpleNameSyntax simpleName, CancellationToken cancellationToken, GenerateTypeServiceStateOptions& generateTypeServiceStateOptions);
    private static IMethodSymbol GetMemberGroupIfPresent(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    public virtual string GetRootNamespace(CompilationOptions options);
    protected virtual ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(State<VisualBasicGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeBlockSyntax, ArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool IsInVariableTypeContext(ExpressionSyntax expression);
    protected virtual INamedTypeSymbol DetermineTypeToGenerateIn(SemanticModel semanticModel, SimpleNameSyntax simpleName, CancellationToken cancellationToken);
    protected virtual Accessibility GetAccessibility(State<VisualBasicGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeBlockSyntax, ArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    protected virtual ITypeSymbol DetermineArgumentType(SemanticModel semanticModel, ArgumentSyntax argument, CancellationToken cancellationToken);
    protected virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.GenerateType.VisualBasicGenerateTypeService/VB$StateMachine_20_GetOrGenerateEnclosingNamespaceSymbolAsync")]
public virtual Task`1<ValueTuple`3<INamespaceSymbol, INamespaceOrTypeSymbol, Location>> GetOrGenerateEnclosingNamespaceSymbolAsync(INamedTypeSymbol namedTypeSymbol, String[] containers, Document selectedDocument, SyntaxNode selectedDocumentRoot, CancellationToken cancellationToken);
    private static NamespaceStatementSyntax GetDeclaringNamespace(List`1<string> containers, int indexDone, CompilationUnitSyntax compilationUnit);
    private static NamespaceStatementSyntax GetDeclaringNamespace(List`1<string> containers, int indexDone, SyntaxNode localRoot);
    private static int MatchingNamesFromNamespaceName(List`1<string> containers, int indexDone, NamespaceStatementSyntax namespaceStatementSyntax);
    private static bool IdentifierMatches(int indexDone, List`1<string> namespaceContainers, List`1<string> containers);
    private static void GetNamespaceContainers(NameSyntax name, List`1<string> namespaceContainers);
    internal virtual bool TryGetBaseList(ExpressionSyntax expression, TypeKindOptions& typeKindValue);
    internal virtual bool IsPublicOnlyAccessibility(ExpressionSyntax expression, Project project);
    private static bool IsAllContainingTypeBlocksPublic(SyntaxNode node);
    internal virtual bool IsGenericName(SimpleNameSyntax expression);
    internal virtual bool IsSimpleName(ExpressionSyntax expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.GenerateType.VisualBasicGenerateTypeService/VB$StateMachine_31_TryAddUsingsOrImportToDocumentAsync")]
internal virtual Task`1<Solution> TryAddUsingsOrImportToDocumentAsync(Solution updatedSolution, SyntaxNode modifiedRoot, Document document, SimpleNameSyntax simpleName, string includeUsingsOrImports, AddImportPlacementOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ITypeSymbol GetPropertyType(SimpleNameSyntax propIdentifierName, SemanticModel semanticModel, ITypeInferenceService typeInference, CancellationToken cancellationToken);
    private static IPropertySymbol GenerateProperty(SimpleNameSyntax propertyName, ITypeSymbol typeSymbol);
    internal virtual bool TryGenerateProperty(SimpleNameSyntax propertyName, SemanticModel semanticModel, ITypeInferenceService typeInferenceService, CancellationToken cancellationToken, IPropertySymbol& propertySymbol);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GenerateVariable.VisualBasicGenerateVariableCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    internal static string BC30456;
    internal static string BC30401;
    internal static string BC30451;
    internal static string BC36610;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GoToDefinition.IGoToDefinitionSymbolService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GoToDefinition.VisualBasicGoToDefinitionSymbolService : AbstractGoToDefinitionSymbolService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.GoToDefinition.VisualBasicGoToDefinitionSymbolService/VB$StateMachine_1_FindRelatedExplicitlyDeclaredSymbolAsync")]
protected virtual Task`1<ISymbol> FindRelatedExplicitlyDeclaredSymbolAsync(Project project, ISymbol symbol, CancellationToken cancellationToken);
    protected virtual Nullable`1<int> GetTargetPositionIfControlFlow(SemanticModel semanticModel, SyntaxToken token);
    private static SyntaxNode TryGetExitTarget(SyntaxNode node);
    private static SyntaxNode TryGetContinueTarget(SyntaxNode node);
    private static SyntaxNode FindContainingSelect(SyntaxNode node);
    private static SyntaxNode FindContainingWhile(SyntaxNode node);
    private static SyntaxNode FindContainingFor(SyntaxNode node);
    private static SyntaxNode FindContainingDoLoop(SyntaxNode node);
    private static SyntaxNode FindContainingTry(SyntaxNode node);
    private static SyntaxNode FindContainingReturnableConstruct(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ImplementAbstractClass.VisualBasicImplementAbstractClassCodeFixProvider : AbstractImplementAbstractClassCodeFixProvider`1<ClassBlockSyntax> {
    internal static string BC30610;
    protected virtual SyntaxToken GetClassIdentifier(ClassBlockSyntax classNode);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ImplementInterface.VisualBasicImplementInterfaceCodeFixProvider : CodeFixProvider {
    internal static string BC30149;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.ImplementInterface.VisualBasicImplementInterfaceCodeFixProvider/VB$StateMachine_5_RegisterCodeFixesAsync")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ImplementInterface.IImplementInterfaceService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ImplementInterface.VisualBasicImplementInterfaceService : AbstractImplementInterfaceService {
    protected bool CanImplementImplicitly { get; }
    protected bool HasHiddenExplicitImplementation { get; }
    protected virtual string ToDisplayString(IMethodSymbol disposeImplMethod, SymbolDisplayFormat format);
    protected virtual bool get_CanImplementImplicitly();
    protected virtual bool get_HasHiddenExplicitImplementation();
    protected virtual bool AllowDelegateAndEnumConstraints(ParseOptions options);
    protected virtual bool TryInitializeState(Document document, SemanticModel model, SyntaxNode node, CancellationToken cancellationToken, SyntaxNode& classOrStructDecl, INamedTypeSymbol& classOrStructType, IEnumerable`1& interfaceTypes);
    private static INamedTypeSymbol GetInterfaceType(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual SyntaxNode AddCommentInsideIfStatement(SyntaxNode ifStatement, SyntaxTriviaList trivia);
    protected virtual SyntaxNode CreateFinalizer(SyntaxGenerator g, INamedTypeSymbol classType, string disposeMethodDisplayString);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InheritanceMargin.IInheritanceMarginService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InheritanceMarginService.VisualBasicInheritanceMarginService : AbstractInheritanceMarginService {
    [CompilerGeneratedAttribute]
private string _GlobalImportsTitle;
    protected string GlobalImportsTitle { get; }
    [CompilerGeneratedAttribute]
protected virtual string get_GlobalImportsTitle();
    protected virtual ImmutableArray`1<SyntaxNode> GetMembers(IEnumerable`1<SyntaxNode> nodesToSearch);
    protected virtual SyntaxToken GetDeclarationToken(SyntaxNode declarationNode);
}
internal class Microsoft.CodeAnalysis.VisualBasic.InitializeParameter.InitializeParameterHelpers : object {
    public static bool IsFunctionDeclaration(SyntaxNode node);
    public static SyntaxNode GetBody(SyntaxNode node);
    private static SyntaxList`1<StatementSyntax> GetStatements(SyntaxNode functionDeclaration);
    public static bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    public static SyntaxNode TryGetLastStatement(IBlockOperation blockStatementOpt);
    public static void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, SyntaxNode statementToAddAfterOpt, StatementSyntax statement);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InitializeParameter.VisualBasicAddParameterCheckCodeRefactoringProvider : AbstractAddParameterCheckCodeRefactoringProvider`6<TypeBlockSyntax, ParameterSyntax, StatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, VisualBasicSimplifierOptions> {
    protected virtual bool IsFunctionDeclaration(SyntaxNode node);
    protected virtual SyntaxNode GetBody(SyntaxNode functionDeclaration);
    protected virtual void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfterOpt, StatementSyntax statement);
    protected virtual bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    protected virtual bool CanOffer(SyntaxNode body);
    protected virtual bool PrefersThrowExpression(VisualBasicSimplifierOptions options);
    protected virtual string EscapeResourceString(string input);
    protected virtual StatementSyntax CreateParameterCheckIfStatement(ExpressionSyntax condition, StatementSyntax ifTrueStatement, VisualBasicSimplifierOptions options);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InitializeParameter.VisualBasicInitializeMemberFromParameterCodeRefactoringProvider : AbstractInitializeMemberFromParameterCodeRefactoringProvider`4<TypeBlockSyntax, ParameterSyntax, StatementSyntax, ExpressionSyntax> {
    protected virtual bool IsFunctionDeclaration(SyntaxNode node);
    protected virtual SyntaxNode TryGetLastStatement(IBlockOperation blockStatement);
    protected virtual bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    protected virtual void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfterOpt, StatementSyntax statement);
    protected virtual Accessibility DetermineDefaultFieldAccessibility(INamedTypeSymbol containingType);
    protected virtual Accessibility DetermineDefaultPropertyAccessibility();
    protected virtual SyntaxNode GetBody(SyntaxNode functionDeclaration);
    protected virtual SyntaxNode GetAccessorBody(IMethodSymbol accessor, CancellationToken cancellationToken);
    protected virtual SyntaxNode RemoveThrowNotImplemented(SyntaxNode propertySyntax);
    private static AccessorBlockSyntax RemoveThrowNotImplemented(AccessorBlockSyntax accessorBlock);
    protected virtual bool TryUpdateTupleAssignment(IBlockOperation blockStatement, IParameterSymbol parameter, ISymbol fieldOrProperty, SyntaxEditor editor);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InlineHints.IInlineHintsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InlineHints.VisualBasicInlineHintsService : AbstractInlineHintsService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InlineHints.IInlineParameterNameHintsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InlineHints.VisualBasicInlineParameterNameHintsService : AbstractInlineParameterNameHintsService {
    protected virtual void AddAllParameterNameHintLocations(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, ArrayBuilder`1<ValueTuple`4<int, string, IParameterSymbol, HintKind>> buffer, CancellationToken cancellationToken);
    private static HintKind GetKind(ExpressionSyntax arg);
    protected virtual bool IsIndexer(SyntaxNode node, IParameterSymbol parameter);
    protected virtual string GetReplacementText(string parameterName);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.IntroduceParameter.VisualBasicIntroduceParameterCodeRefactoringProvider : AbstractIntroduceParameterCodeRefactoringProvider`5<ExpressionSyntax, InvocationExpressionSyntax, ObjectCreationExpressionSyntax, IdentifierNameSyntax, ArgumentSyntax> {
    protected virtual SyntaxNode GenerateExpressionFromOptionalParameter(IParameterSymbol parameterSymbol);
    protected virtual SyntaxNode GetLocalDeclarationFromDeclarator(SyntaxNode variableDecl);
    protected virtual SyntaxNode UpdateArgumentListSyntax(SyntaxNode node, SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    protected virtual bool IsDestructor(IMethodSymbol methodSymbol);
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.IntroduceUsingStatement.VisualBasicIntroduceUsingStatementCodeRefactoringProvider : AbstractIntroduceUsingStatementCodeRefactoringProvider`3<StatementSyntax, LocalDeclarationStatementSyntax, TryBlockSyntax> {
    [CompilerGeneratedAttribute]
private string _CodeActionTitle;
    protected string CodeActionTitle { get; }
    [CompilerGeneratedAttribute]
protected virtual string get_CodeActionTitle();
    protected virtual bool HasCatchBlocks(TryBlockSyntax tryStatement);
    protected virtual ValueTuple`2<SyntaxList`1<StatementSyntax>, SyntaxList`1<StatementSyntax>> GetTryFinallyStatements(TryBlockSyntax tryStatement);
    protected virtual bool CanRefactorToContainBlockStatements(SyntaxNode parent);
    protected virtual SyntaxList`1<StatementSyntax> GetSurroundingStatements(LocalDeclarationStatementSyntax declarationStatement);
    protected virtual SyntaxNode WithStatements(SyntaxNode parentOfStatementsToSurround, SyntaxList`1<StatementSyntax> statements);
    protected virtual StatementSyntax CreateUsingStatement(LocalDeclarationStatementSyntax declarationStatement, SyntaxList`1<StatementSyntax> statementsToSurround);
    protected virtual bool TryCreateUsingLocalDeclaration(ParseOptions options, LocalDeclarationStatementSyntax declarationStatement, LocalDeclarationStatementSyntax& usingDeclarationStatement);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.IntroduceVariable.VisualBasicIntroduceLocalForExpressionCodeRefactoringProvider : AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4<ExpressionSyntax, StatementSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax> {
    protected virtual bool IsValid(ExpressionStatementSyntax expressionStatement, TextSpan span);
    protected virtual LocalDeclarationStatementSyntax FixupLocalDeclaration(ExpressionStatementSyntax expressionStatement, LocalDeclarationStatementSyntax localDeclaration);
    protected virtual ExpressionStatementSyntax FixupDeconstruction(ExpressionStatementSyntax expressionStatement, ExpressionStatementSyntax localDeclaration);
    protected virtual Task`1<ExpressionStatementSyntax> CreateTupleDeconstructionAsync(Document document, CodeActionOptionsProvider optionsProvider, INamedTypeSymbol tupleType, ExpressionSyntax expression, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.IntroduceVariable.IIntroduceVariableService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.IntroduceVariable.VisualBasicIntroduceVariableService : AbstractIntroduceVariableService`6<VisualBasicIntroduceVariableService, ExpressionSyntax, TypeSyntax, TypeBlockSyntax, QueryExpressionSyntax, NameSyntax> {
    protected virtual IEnumerable`1<SyntaxNode> GetContainingExecutableBlocks(ExpressionSyntax expression);
    protected virtual IList`1<bool> GetInsertionIndices(TypeBlockSyntax destination, CancellationToken cancellationToken);
    protected virtual bool IsInAttributeArgumentInitializer(ExpressionSyntax expression);
    protected virtual bool IsInConstructorInitializer(ExpressionSyntax expression);
    protected virtual bool CanIntroduceVariableFor(ExpressionSyntax expression);
    protected virtual bool IsInFieldInitializer(ExpressionSyntax expression);
    protected virtual bool IsInNonFirstQueryClause(ExpressionSyntax expression);
    protected virtual bool IsInParameterInitializer(ExpressionSyntax expression);
    protected virtual bool IsInAutoPropertyInitializer(ExpressionSyntax expression);
    protected virtual bool IsInExpressionBodiedMember(ExpressionSyntax expression);
    protected virtual bool CanReplace(ExpressionSyntax expression);
    protected virtual bool IsExpressionInStaticLocalFunction(ExpressionSyntax expression);
    protected virtual TNode RewriteCore(TNode node, SyntaxNode replacementNode, ISet`1<ExpressionSyntax> matches);
    protected virtual bool BlockOverlapsHiddenPosition(SyntaxNode block, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.IntroduceVariable.VisualBasicIntroduceVariableService/VB$StateMachine_16_IntroduceFieldAsync")]
protected virtual Task`1<Document> IntroduceFieldAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.IntroduceVariable.VisualBasicIntroduceVariableService/VB$StateMachine_17_IntroduceFieldIntoTypeAsync")]
private Task`1<Document> IntroduceFieldIntoTypeAsync(SemanticDocument document, ExpressionSyntax expression, MemberAccessExpressionSyntax newQualifiedName, TypeBlockSyntax oldTypeBlock, INamedTypeSymbol oldType, SyntaxToken newNameToken, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    protected virtual int DetermineConstantInsertPosition(TypeBlockSyntax oldDeclaration, TypeBlockSyntax newDeclaration);
    protected static int DetermineConstantInsertPosition(SyntaxList`1<StatementSyntax> oldMembers, SyntaxList`1<StatementSyntax> newMembers);
    protected virtual int DetermineFieldInsertPosition(TypeBlockSyntax oldDeclaration, TypeBlockSyntax newDeclaration);
    protected static int DetermineFieldInsertPosition(SyntaxList`1<StatementSyntax> oldMembers, SyntaxList`1<StatementSyntax> newMembers);
    private static bool IsConstantField(StatementSyntax member);
    protected static int DetermineFirstChange(SyntaxList`1<StatementSyntax> oldMembers, SyntaxList`1<StatementSyntax> newMembers);
    private FieldDeclarationSyntax CreateFieldDeclaration(SemanticDocument document, TypeBlockSyntax oldTypeDeclaration, SyntaxToken newNameToken, ExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    private static SyntaxTokenList MakeFieldModifiers(IEnumerable`1<ExpressionSyntax> expressions, bool isConstant, bool inScript, bool inModule);
    protected static TypeBlockSyntax InsertMember(TypeBlockSyntax typeDeclaration, StatementSyntax memberDeclaration, int index);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.IntroduceVariable.VisualBasicIntroduceVariableService/VB$StateMachine_27_IntroduceLocalAsync")]
protected virtual Task`1<Document> IntroduceLocalAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    private static SyntaxNode GetContainerToGenerateInfo(SemanticDocument document, ExpressionSyntax expression, CancellationToken cancellationToken);
    private Document IntroduceLocalDeclarationIntoLambda(SemanticDocument document, SingleLineLambdaExpressionSyntax oldLambda, ExpressionSyntax expression, IdentifierNameSyntax newLocalName, StatementSyntax declarationStatement, bool allOccurrences, CancellationToken cancellationToken);
    private static SingleLineLambdaExpressionSyntax GetParentLambda(ExpressionSyntax expression, ISet`1<SingleLineLambdaExpressionSyntax> lambdas);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.IntroduceVariable.VisualBasicIntroduceVariableService/VB$StateMachine_31_IntroduceLocalDeclarationIntoBlockAsync")]
private Task`1<Document> IntroduceLocalDeclarationIntoBlockAsync(SemanticDocument document, SyntaxNode container, ExpressionSyntax expression, NameSyntax newLocalName, LocalDeclarationStatementSyntax declarationStatement, bool allOccurrences, CancellationToken cancellationToken);
    private Document IntroduceLocalForSingleOccurrenceIntoBlock(SemanticDocument semanticDocument, ExpressionSyntax expression, NameSyntax localName, LocalDeclarationStatementSyntax localDeclaration, bool allOccurrences, CancellationToken cancellationToken);
    protected virtual Task`1<Document> IntroduceQueryLocalAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, CancellationToken cancellationToken);
    private Document IntroduceQueryLocalForSingleOccurrence(SemanticDocument document, ExpressionSyntax expression, NameSyntax newLocalName, LetClauseSyntax letClause, bool allOccurrences, CancellationToken cancellationToken);
    private static QueryExpressionSyntax GetNewQuery(QueryExpressionSyntax oldQuery, QueryClauseSyntax oldClause, QueryClauseSyntax newClause, LetClauseSyntax letClause);
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InvertConditional.VisualBasicInvertConditionalCodeRefactoringProvider : AbstractInvertConditionalCodeRefactoringProvider`1<TernaryConditionalExpressionSyntax> {
    protected virtual bool ShouldOffer(TernaryConditionalExpressionSyntax conditional);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.InvertIf.VisualBasicInvertIfCodeRefactoringProvider`1 : AbstractInvertIfCodeRefactoringProvider`4<SyntaxKind, StatementSyntax, TIfStatementSyntax, SyntaxList`1<StatementSyntax>> {
    protected sealed virtual string GetTitle();
    protected sealed virtual StatementRange<SyntaxKind, StatementSyntax, TIfStatementSyntax, SyntaxList`1<StatementSyntax>> GetIfBodyStatementRange(TIfStatementSyntax ifNode);
    protected sealed virtual bool CanControlFlowOut(SyntaxNode node);
    protected sealed virtual Nullable`1<SyntaxKind> GetJumpStatementKind(SyntaxNode node);
    protected sealed virtual bool IsStatementContainer(SyntaxNode node);
    protected sealed virtual SyntaxList`1<StatementSyntax> GetStatements(SyntaxNode node);
    protected sealed virtual StatementSyntax GetNextStatement(StatementSyntax node);
    protected sealed virtual StatementSyntax GetJumpStatement(SyntaxKind kind);
    protected sealed virtual bool IsNoOpSyntaxNode(SyntaxNode node);
    protected sealed virtual bool IsExecutableStatement(SyntaxNode node);
    protected sealed virtual IEnumerable`1<StatementSyntax> UnwrapBlock(SyntaxList`1<StatementSyntax> ifBody);
    protected sealed virtual SyntaxList`1<StatementSyntax> GetEmptyEmbeddedStatement();
    protected sealed virtual SyntaxList`1<StatementSyntax> AsEmbeddedStatement(IEnumerable`1<StatementSyntax> statements, SyntaxList`1<StatementSyntax> original);
    protected sealed virtual SyntaxNode WithStatements(SyntaxNode node, IEnumerable`1<StatementSyntax> statements);
    protected sealed virtual bool IsSingleStatementStatementRange(StatementRange<SyntaxKind, StatementSyntax, TIfStatementSyntax, SyntaxList`1<StatementSyntax>> statementRange);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InvertIf.VisualBasicInvertMultiLineIfCodeRefactoringProvider : VisualBasicInvertIfCodeRefactoringProvider`1<MultiLineIfBlockSyntax> {
    protected virtual bool IsElseless(MultiLineIfBlockSyntax ifNode);
    protected virtual bool CanInvert(MultiLineIfBlockSyntax ifNode);
    protected virtual SyntaxNode GetCondition(MultiLineIfBlockSyntax ifNode);
    protected virtual SyntaxList`1<StatementSyntax> GetIfBody(MultiLineIfBlockSyntax ifNode);
    protected virtual SyntaxList`1<StatementSyntax> GetElseBody(MultiLineIfBlockSyntax ifNode);
    protected virtual MultiLineIfBlockSyntax UpdateIf(SourceText sourceText, MultiLineIfBlockSyntax ifNode, SyntaxNode condition, SyntaxList`1<StatementSyntax> trueStatement, SyntaxList`1<StatementSyntax> falseStatementOpt);
    private static bool HasComment(ElseBlockSyntax elseBlock);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InvertIf.VisualBasicInvertSingleLineIfCodeRefactoringProvider : VisualBasicInvertIfCodeRefactoringProvider`1<SingleLineIfStatementSyntax> {
    protected virtual bool IsElseless(SingleLineIfStatementSyntax ifNode);
    protected virtual bool CanInvert(SingleLineIfStatementSyntax ifNode);
    protected virtual SyntaxNode GetCondition(SingleLineIfStatementSyntax ifNode);
    protected virtual SyntaxList`1<StatementSyntax> GetIfBody(SingleLineIfStatementSyntax ifNode);
    protected virtual SyntaxList`1<StatementSyntax> GetElseBody(SingleLineIfStatementSyntax ifNode);
    protected virtual SingleLineIfStatementSyntax UpdateIf(SourceText sourceText, SingleLineIfStatementSyntax ifNode, SyntaxNode condition, SyntaxList`1<StatementSyntax> trueStatements, SyntaxList`1<StatementSyntax> falseStatements);
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.InvertLogical.VisualBasicInvertLogicalCodeRefactoringProvider : AbstractInvertLogicalCodeRefactoringProvider`3<SyntaxKind, ExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual string GetOperatorText(SyntaxKind binaryExprKind);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.AccessorDeclarationHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.ConditionalPreprocessorHighlighter : AbstractKeywordHighlighter`1<DirectiveTriviaSyntax> {
    protected virtual void AddHighlights(DirectiveTriviaSyntax directive, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.ConstructorDeclarationHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.DoLoopBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.EnumBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.EventBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.EventDeclarationHighlighter : AbstractKeywordHighlighter`1<EventStatementSyntax> {
    protected virtual void AddHighlights(EventStatementSyntax eventDeclaration, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.ForLoopBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
    private static ForOrForEachBlockSyntax GetForBlockFromNode(SyntaxNode node);
    private static NextStatementSyntax GetNextStatementMatchingForBlock(ForOrForEachBlockSyntax forBlock);
    private static IEnumerable`1<ForOrForEachBlockSyntax> GetForBlocksMatchingNextStatement(NextStatementSyntax nextStatement);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.KeywordHighlightingHelpers : object {
    private static void HighlightRelatedStatements(SyntaxNode node, List`1<TextSpan> highlights, SyntaxKind blockKind, bool checkReturns);
    [ExtensionAttribute]
internal static IEnumerable`1<TextSpan> GetRelatedStatementHighlights(T node, SyntaxKind blockKind, bool checkReturns);
    [ExtensionAttribute]
internal static bool IsIncorrectContinueStatement(SyntaxNode node, SyntaxKind expectedKind);
    [ExtensionAttribute]
internal static bool IsIncorrectExitStatement(SyntaxNode node, SyntaxKind expectedKind);
    [ExtensionAttribute]
internal static void HighlightRelatedAwaits(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
    private static void HighlightRelatedYieldStatements(SyntaxNode node, List`1<TextSpan> highlights);
    [ExtensionAttribute]
internal static IEnumerable`1<TextSpan> GetRelatedYieldStatementHighlights(T node);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.MethodDeclarationHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.MultiLineIfBlockHighlighter : AbstractKeywordHighlighter`1<MultiLineIfBlockSyntax> {
    protected virtual void AddHighlights(MultiLineIfBlockSyntax ifBlock, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.MultiLineLambdaExpressionHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.NamespaceBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.OperatorDeclarationHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.PropertyDeclarationHighlighter : AbstractKeywordHighlighter`1<PropertyStatementSyntax> {
    protected virtual void AddHighlights(PropertyStatementSyntax propertyDeclaration, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.RegionHighlighter : AbstractKeywordHighlighter`1<DirectiveTriviaSyntax> {
    protected virtual void AddHighlights(DirectiveTriviaSyntax directive, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.SelectBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.SingleLineIfBlockHighlighter : AbstractKeywordHighlighter`1<SingleLineIfStatementSyntax> {
    protected virtual void AddHighlights(SingleLineIfStatementSyntax ifStatement, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.SyncLockBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.TryBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
    private static void HighlightRelatedStatements(SyntaxNode node, List`1<TextSpan> highlights);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.TypeBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.UsingBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.WhileBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.WithBlockHighlighter : AbstractKeywordHighlighter`1<SyntaxNode> {
    protected virtual void AddHighlights(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.XmlCDataHighlighter : AbstractKeywordHighlighter`1<XmlCDataSectionSyntax> {
    protected virtual void AddHighlights(XmlCDataSectionSyntax xmlComment, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.XmlCommentHighlighter : AbstractKeywordHighlighter`1<XmlCommentSyntax> {
    protected virtual void AddHighlights(XmlCommentSyntax xmlComment, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.XmlDeclarationHighlighter : AbstractKeywordHighlighter`1<XmlDeclarationSyntax> {
    protected virtual void AddHighlights(XmlDeclarationSyntax xmlDocumentPrologue, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.XmlElementHighlighter : AbstractKeywordHighlighter`1<XmlNodeSyntax> {
    protected virtual void AddHighlights(XmlNodeSyntax node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.XmlEmbeddedExpressionHighlighter : AbstractKeywordHighlighter`1<XmlEmbeddedExpressionSyntax> {
    protected virtual void AddHighlights(XmlEmbeddedExpressionSyntax xmlEmbeddExpression, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.KeywordHighlighting.XmlProcessingInstructionHighlighter : AbstractKeywordHighlighter`1<XmlProcessingInstructionSyntax> {
    protected virtual void AddHighlights(XmlProcessingInstructionSyntax xmlProcessingInstruction, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities : object {
    public static bool IsLambda(SyntaxNode node);
    public static bool IsNotLambda(SyntaxNode node);
    public static SyntaxNode GetLambda(SyntaxNode lambdaBody);
    public static SyntaxNode GetCorrespondingLambdaBody(SyntaxNode oldBody, SyntaxNode newLambdaOrPeer);
    public static bool IsLambdaBody(SyntaxNode node);
    public static bool IsLambdaBodyStatementOrExpression(SyntaxNode node, SyntaxNode& lambdaBody);
    private static bool IsJoinClause(SyntaxNode node);
    internal static VisualBasicSyntaxNode GetLambdaExpressionLambdaBody(LambdaExpressionSyntax lambda);
    internal static VisualBasicSyntaxNode GetFromOrAggregateVariableLambdaBody(CollectionRangeVariableSyntax rangeVariable);
    internal static VisualBasicSyntaxNode GetOrderingLambdaBody(OrderingSyntax ordering);
    internal static VisualBasicSyntaxNode GetAggregationLambdaBody(FunctionAggregationSyntax aggregation);
    internal static VisualBasicSyntaxNode GetLetVariableLambdaBody(ExpressionRangeVariableSyntax rangeVariable);
    internal static VisualBasicSyntaxNode GetSelectLambdaBody(SelectClauseSyntax selectClause);
    internal static VisualBasicSyntaxNode GetAggregateLambdaBody(AggregateClauseSyntax aggregateClause);
    internal static VisualBasicSyntaxNode GetGroupByItemsLambdaBody(GroupByClauseSyntax groupByClause);
    internal static VisualBasicSyntaxNode GetGroupByKeysLambdaBody(GroupByClauseSyntax groupByClause);
    internal static VisualBasicSyntaxNode GetJoinLeftLambdaBody(JoinClauseSyntax joinClause);
    internal static VisualBasicSyntaxNode GetJoinRightLambdaBody(JoinClauseSyntax joinClause);
    private static SyntaxNode GetExpressionRangeVariableLambdaBody(ExpressionRangeVariableSyntax rangeVariable);
    public static bool TryGetLambdaBodies(SyntaxNode node, SyntaxNode& lambdaBody1, SyntaxNode& lambdaBody2);
    internal static IEnumerable`1<SyntaxNode> GetLambdaBodyExpressionsAndStatements(SyntaxNode lambdaBody);
    private static IEnumerable`1<SyntaxNode> GetAggregateLambdaBodyExpressions(AggregateClauseSyntax clause);
    private static void AddFirstJoinVariableRecursive(ArrayBuilder`1<SyntaxNode> result, JoinClauseSyntax joinClause);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities/VB$StateMachine_24_EnumerateExpressions")]
private static IEnumerable`1<SyntaxNode> EnumerateExpressions(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> variables);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities/VB$StateMachine_25_EnumerateJoinClauseLeftExpressions")]
private static IEnumerable`1<SyntaxNode> EnumerateJoinClauseLeftExpressions(JoinClauseSyntax clause);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.LambdaUtilities/VB$StateMachine_26_EnumerateJoinClauseRightExpressions")]
private static IEnumerable`1<SyntaxNode> EnumerateJoinClauseRightExpressions(JoinClauseSyntax clause);
    private static bool TryGetSimpleLambdaBody(SyntaxNode node, SyntaxNode& lambdaBody);
    internal static bool IsLambdaExpressionRangeVariable(SyntaxNode expressionRangeVariable);
    internal static bool IsLambdaCollectionRangeVariable(SyntaxNode collectionRangeVariable);
    private static bool IsQueryStartingClause(SyntaxNode clause);
    private static SeparatedSyntaxList`1<CollectionRangeVariableSyntax> GetCollectionRangeVariables(SyntaxNode clause);
    internal static bool IsLambdaJoinCondition(SyntaxNode joinCondition);
    public static bool AreEquivalentIgnoringLambdaBodies(SyntaxNode oldNode, SyntaxNode newNode);
    internal static bool IsNonUserCodeQueryLambda(SyntaxNode syntax);
    internal static bool IsClosureScope(SyntaxNode node);
}
[LspBuildOnlyDiagnosticsAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServer.VisualBasicLspBuildOnlyDiagnostics : object {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.MakeFieldReadonly.VisualBasicMakeFieldReadonlyCodeFixProvider : AbstractMakeFieldReadonlyCodeFixProvider`2<ModifiedIdentifierSyntax, FieldDeclarationSyntax> {
    protected virtual ImmutableList`1<ModifiedIdentifierSyntax> GetVariableDeclarators(FieldDeclarationSyntax declaration);
    protected virtual SyntaxNode GetInitializerNode(ModifiedIdentifierSyntax declaration);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.MakeFieldReadonly.VisualBasicMakeFieldReadonlyDiagnosticAnalyzer : AbstractMakeFieldReadonlyDiagnosticAnalyzer`2<SyntaxKind, MeExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxKinds _SyntaxKinds;
    protected ISyntaxKinds SyntaxKinds { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxKinds get_SyntaxKinds();
    protected virtual bool IsWrittenTo(SemanticModel semanticModel, MeExpressionSyntax expression, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.MakeMethodAsynchronous.VisualBasicMakeMethodAsynchronousCodeFixProvider : AbstractMakeMethodAsynchronousCodeFixProvider {
    internal static string BC36937;
    internal static string BC37057;
    internal static string BC37058;
    internal static string BC37059;
    private static ImmutableArray`1<string> s_diagnosticIds;
    private static SyntaxToken s_asyncToken;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static VisualBasicMakeMethodAsynchronousCodeFixProvider();
    protected virtual bool IsSupportedDiagnostic(Diagnostic diagnostic, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetMakeAsyncTaskFunctionResource();
    protected virtual string GetMakeAsyncVoidFunctionResource();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual bool IsAsyncReturnType(ITypeSymbol type, KnownTaskTypes knownTypes);
    protected virtual SyntaxNode AddAsyncTokenAndFixReturnType(bool keepVoid, IMethodSymbol methodSymbolOpt, SyntaxNode node, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static SyntaxNode FixFunctionBlock(IMethodSymbol methodSymbol, MethodBlockSyntax node, KnownTaskTypes knownTypes);
    private static SyntaxNode FixSubBlock(bool keepVoid, MethodBlockSyntax node, INamedTypeSymbol taskType);
    private static MethodStatementSyntax AddAsyncKeyword(MethodStatementSyntax subOrFunctionStatement);
    private static SyntaxNode FixMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    private static SingleLineLambdaExpressionSyntax FixSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    private static LambdaHeaderSyntax GetNewHeader(LambdaExpressionSyntax node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.MakeMethodSynchronous.VisualBasicMakeMethodSynchronousCodeFixProvider : AbstractMakeMethodSynchronousCodeFixProvider {
    private static string BC42356;
    private static ImmutableArray`1<string> s_diagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static VisualBasicMakeMethodSynchronousCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual SyntaxNode RemoveAsyncTokenAndFixReturnType(IMethodSymbol methodSymbolOpt, SyntaxNode node, KnownTaskTypes knownTypes);
    private static SyntaxNode FixFunctionBlock(IMethodSymbol methodSymbol, MethodBlockSyntax node, KnownTaskTypes knownTypes);
    private static SyntaxNode FixSubBlock(MethodBlockSyntax node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.MakeTypeAbstract.VisualBasicMakeTypeAbstractCodeFixProvider : AbstractMakeTypeAbstractCodeFixProvider`1<ClassBlockSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsValidRefactoringContext(SyntaxNode node, ClassBlockSyntax& typeDeclaration);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.MakeTypePartial.VisualBasicMakeTypePartialCodeFixProvider : AbstractMakeTypePartialCodeFixProvider {
    private static string BC40046;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
internal class Microsoft.CodeAnalysis.VisualBasic.MetadataAsSource.VisualBasicMetadataAsSourceService : AbstractMetadataAsSourceService {
    private AbstractFormattingRule _memberSeparationRule;
    public static VisualBasicMetadataAsSourceService Instance;
    private static VisualBasicMetadataAsSourceService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.MetadataAsSource.VisualBasicMetadataAsSourceService/VB$StateMachine_4_AddAssemblyInfoRegionAsync")]
protected virtual Task`1<Document> AddAssemblyInfoRegionAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CancellationToken cancellationToken);
    protected virtual Task`1<Document> AddNullableRegionsAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.MetadataAsSource.VisualBasicMetadataAsSourceService/VB$StateMachine_6_ConvertDocCommentsToRegularCommentsAsync")]
protected virtual Task`1<Document> ConvertDocCommentsToRegularCommentsAsync(Document document, IDocumentationCommentFormattingService docCommentFormattingService, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected virtual ImmutableArray`1<AbstractReducer> GetReducers();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.MetadataAsSource.VisualBasicMetadataAsSourceServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.MoveDeclarationNearReference.VisualBasicMoveDeclarationNearReferenceCodeRefactoringProvider : AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1<LocalDeclarationStatementSyntax> {
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.NameTupleElement.VisualBasicNameTupleElementCodeRefactoringProvider : AbstractNameTupleElementCodeRefactoringProvider`2<SimpleArgumentSyntax, TupleExpressionSyntax> {
    protected virtual SimpleArgumentSyntax WithName(SimpleArgumentSyntax argument, string name);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.NavigateTo.VisualBasicNavigateToSearchService : AbstractNavigateToSearchService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Navigation.INavigableItemsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Navigation.VisualBasicFindDefinitionService : AbstractNavigableItemsService {
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.NewLines.ConsecutiveStatementPlacement.VisualBasicConsecutiveStatementPlacementDiagnosticAnalyzer : AbstractConsecutiveStatementPlacementDiagnosticAnalyzer`1<ExecutableStatementSyntax> {
    protected virtual bool IsBlockLikeStatement(SyntaxNode node);
    protected virtual Location GetDiagnosticLocation(SyntaxNode block);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.NewLines.MultipleBlankLines.VisualBasicMultipleBlankLinesDiagnosticAnalyzer : AbstractMultipleBlankLinesDiagnosticAnalyzer {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.OrderModifiers.VisualBasicOrderModifiersCodeFixProvider : AbstractOrderModifiersCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableCompilerErrorIds;
    protected ImmutableArray`1<string> FixableCompilerErrorIds { get; }
    protected virtual CodeStyleOption2`1<string> GetCodeStyleOption(AnalyzerOptionsProvider options);
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<string> get_FixableCompilerErrorIds();
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.OrderModifiers.VisualBasicOrderModifiersDiagnosticAnalyzer : AbstractOrderModifiersDiagnosticAnalyzer {
    protected virtual CodeStyleOption2`1<string> GetPreferredOrderStyle(SyntaxTreeAnalysisContext context);
    protected virtual void Recurse(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, NotificationOption2 notificationOption, SyntaxNode root);
    private static bool ShouldCheck(DeclarationStatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.OrderModifiers.VisualBasicOrderModifiersHelper : AbstractOrderModifiersHelpers {
    public static VisualBasicOrderModifiersHelper Instance;
    private static VisualBasicOrderModifiersHelper();
    protected virtual int GetKeywordKind(string trimmed);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Organizing.Organizers.MemberDeclarationsOrganizer : object {
    public static SyntaxList`1<StatementSyntax> Organize(SyntaxList`1<StatementSyntax> members, CancellationToken cancellationToken);
    private static void TransferTrivia(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static void FixupOriginalFirstNode(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static void CopyBanner(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static IList`1<StatementSyntax> OrganizeMemberGroup(IList`1<StatementSyntax> members);
}
[ExportSyntaxNodeOrganizerAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Organizing.Organizers.TypeBlockOrganizer : AbstractSyntaxNodeOrganizer`1<TypeBlockSyntax> {
    protected virtual TypeBlockSyntax Organize(TypeBlockSyntax typeBlock, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Organizing.IOrganizingService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Organizing.VisualBasicOrganizingService : AbstractOrganizingService {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VisualBasicOrganizingService(IEnumerable`1<Lazy`2<ISyntaxOrganizer, LanguageMetadata>> organizers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Organizing.VisualBasicOrganizingService/VB$StateMachine_2_ProcessAsync")]
protected virtual Task`1<Document> ProcessAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.PopulateSwitch.VisualBasicPopulateSwitchStatementCodeFixProvider : AbstractPopulateSwitchStatementCodeFixProvider`3<SelectBlockSyntax, CaseBlockSyntax, MemberAccessExpressionSyntax> {
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.PopulateSwitch.VisualBasicPopulateSwitchStatementDiagnosticAnalyzer : AbstractPopulateSwitchStatementDiagnosticAnalyzer`1<SelectBlockSyntax> {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.QualifyMemberAccess.VisualBasicQualifyMemberAccessCodeFixProvider : AbstractQualifyMemberAccessCodeFixprovider`2<SimpleNameSyntax, InvocationExpressionSyntax> {
    protected virtual string GetTitle();
    protected virtual SimpleNameSyntax GetNode(Diagnostic diagnostic, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.QualifyMemberAccess.VisualBasicQualifyMemberAccessDiagnosticAnalyzer : AbstractQualifyMemberAccessDiagnosticAnalyzer`3<SyntaxKind, ExpressionSyntax, SimpleNameSyntax> {
    protected ISimplification Simplification { get; }
    protected virtual ISimplification get_Simplification();
    protected virtual bool IsAlreadyQualifiedMemberAccess(ExpressionSyntax node);
    protected virtual bool CanMemberAccessBeQualified(ISymbol containingSymbol, SyntaxNode node);
    protected virtual Location GetLocation(IOperation operation);
}
[ExportQuickInfoProviderAttribute("EmbeddedLanguages", "Visual Basic")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.QuickInfo.VisualBasicEmbeddedLanguageQuickInfoProvider : AbstractEmbeddedLanguageQuickInfoProvider {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public VisualBasicEmbeddedLanguageQuickInfoProvider(IEnumerable`1<Lazy`2<IEmbeddedLanguageQuickInfoProvider, EmbeddedLanguageMetadata>> services);
}
internal class Microsoft.CodeAnalysis.VisualBasic.QuickInfo.VisualBasicQuickInfoService : QuickInfoServiceWithProviders {
    public VisualBasicQuickInfoService(LanguageServices services);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.QuickInfo.QuickInfoService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.QuickInfo.VisualBasicQuickInfoServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportQuickInfoProviderAttribute("Semantic", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.QuickInfo.VisualBasicSemanticQuickInfoProvider : CommonSemanticQuickInfoProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.QuickInfo.VisualBasicSemanticQuickInfoProvider/VB$StateMachine_1_BuildQuickInfoAsync")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(QuickInfoContext context, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.QuickInfo.VisualBasicSemanticQuickInfoProvider/VB$StateMachine_2_BuildQuickInfoAsync")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(CommonQuickInfoContext context, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.QuickInfo.VisualBasicSemanticQuickInfoProvider/VB$StateMachine_3_BuildQuickInfoAsync")]
private static Task`1<QuickInfoItem> BuildQuickInfoAsync(SolutionServices services, SemanticModel semanticModel, SyntaxToken token, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    protected virtual bool GetBindableNodeForTokenIndicatingLambda(SyntaxToken token, SyntaxNode& found);
    protected virtual bool GetBindableNodeForTokenIndicatingPossibleIndexerAccess(SyntaxToken token, SyntaxNode& found);
    protected virtual bool GetBindableNodeForTokenIndicatingMemberAccess(SyntaxToken token, SyntaxToken& found);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.QuickInfo.VisualBasicSemanticQuickInfoProvider/VB$StateMachine_7_BuildContentAsync")]
private static Task`1<QuickInfoItem> BuildContentAsync(SolutionServices services, SemanticModel semanticModel, SyntaxToken token, SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    private static QuickInfoItem BuildContentForIntrinsicOperator(SemanticModel semanticModel, SyntaxToken token, SyntaxNode expression, AbstractIntrinsicOperatorDocumentation documentation, Glyph glyph, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[CompilerGeneratedAttribute]
private Task`1<QuickInfoItem> $VB$ClosureStub_BuildQuickInfoAsync_MyBase(QuickInfoContext context, SyntaxToken token);
    [CompilerGeneratedAttribute]
[CompilerGeneratedAttribute]
private Task`1<QuickInfoItem> $VB$ClosureStub_BuildQuickInfoAsync_MyBase(CommonQuickInfoContext context, SyntaxToken token);
}
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveAsyncModifier.RemoveAsyncModifierHelpers : object {
    internal static MethodStatementSyntax RemoveAsyncKeyword(MethodStatementSyntax subOrFunctionStatement);
    internal static SyntaxNode FixMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    internal static SingleLineLambdaExpressionSyntax FixSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    private static LambdaHeaderSyntax GetNewHeader(LambdaExpressionSyntax node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveAsyncModifier.VisualBasicRemoveAsyncModifierCodeFixProvider : AbstractRemoveAsyncModifierCodeFixProvider`2<ReturnStatementSyntax, ExpressionSyntax> {
    private static string BC42356;
    private static ImmutableArray`1<string> s_diagnosticIds;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static VisualBasicRemoveAsyncModifierCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual SyntaxNode RemoveAsyncModifier(SyntaxGenerator generator, SyntaxNode methodLikeNode);
    protected virtual SyntaxNode ConvertToBlockBody(SyntaxNode node, ExpressionSyntax expressionBody);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveRedundantEquality.VisualBasicRemoveRedundantEqualityDiagnosticAnalyzer : AbstractRemoveRedundantEqualityDiagnosticAnalyzer {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveSharedFromModuleMembers.VisualBasicRemoveSharedFromModuleMembersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string BC30433;
    private static string BC30434;
    private static string BC30503;
    private static string BC30593;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SyntaxNode GetReplacement(Document document, SyntaxNode node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryByVal.VisualBasicRemoveUnnecessaryByValCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryByVal.VisualBasicRemoveUnnecessaryByValCodeFixProvider/VB$StateMachine_5_FixAllAsync")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryByVal.VisualBasicRemoveUnnecessaryByValDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
private void _Lambda$__1-0(SyntaxNodeAnalysisContext syntaxContext);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryCast.VisualBasicRemoveUnnecessaryCastCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static bool IsUnnecessaryCast(ExpressionSyntax node, SemanticModel model, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryCast.VisualBasicRemoveUnnecessaryCastCodeFixProvider/VB$StateMachine_6_FixAllAsync")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryCast.VisualBasicRemoveUnnecessaryCastCodeFixProvider/VB$StateMachine_7_RemoveCastsAsync")]
private static Task`1<SyntaxNode> RemoveCastsAsync(Document document, ImmutableArray`1<ExpressionSyntax> originalCastNodes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryCast.VisualBasicRemoveUnnecessaryCastCodeFixProvider/VB$StateMachine_8_ExpandSurroundingStatementsAsync")]
private static Task`1<SyntaxNode> ExpandSurroundingStatementsAsync(Document document, ImmutableArray`1<ExpressionSyntax> originalNodes, CancellationToken cancellationToken);
    private static ExpressionSyntax Uncast(ExpressionSyntax old);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryCast.VisualBasicRemoveUnnecessaryCastDiagnosticAnalyzer : AbstractRemoveUnnecessaryCastDiagnosticAnalyzer`2<SyntaxKind, ExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> _SyntaxKindsOfInterest;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual bool IsUnnecessaryCast(SemanticModel model, ExpressionSyntax node, CancellationToken cancellationToken);
    protected virtual TextSpan GetFadeSpan(ExpressionSyntax node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryImports.VisualBasicRemoveUnnecessaryImportsCodeFixProvider : AbstractRemoveUnnecessaryImportsCodeFixProvider {
    protected virtual string GetTitle();
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryImports.VisualBasicRemoveUnnecessaryImportsDiagnosticAnalyzer : AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1<ImportsClauseSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    [CompilerGeneratedAttribute]
private IUnnecessaryImportsProvider`1<ImportsClauseSyntax> _UnnecessaryImportsProvider;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IUnnecessaryImportsProvider`1<ImportsClauseSyntax> UnnecessaryImportsProvider { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    [CompilerGeneratedAttribute]
protected virtual IUnnecessaryImportsProvider`1<ImportsClauseSyntax> get_UnnecessaryImportsProvider();
    protected virtual bool IsRegularCommentOrDocComment(SyntaxTrivia trivia);
    protected virtual ImmutableArray`1<SyntaxNode> MergeImports(ImmutableArray`1<ImportsClauseSyntax> unnecessaryImports);
    protected virtual IEnumerable`1<TextSpan> GetFixableDiagnosticSpans(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
    protected virtual Nullable`1<SyntaxToken> TryGetLastToken(SyntaxNode node);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryParentheses.VisualBasicRemoveUnnecessaryParenthesesCodeFixProvider : AbstractRemoveUnnecessaryParenthesesCodeFixProvider`1<ParenthesizedExpressionSyntax> {
    protected virtual bool CanRemoveParentheses(ParenthesizedExpressionSyntax current, SemanticModel semanticModel, CancellationToken cancellationtoken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryParentheses.VisualBasicRemoveUnnecessaryParenthesesDiagnosticAnalyzer : AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2<SyntaxKind, ParenthesizedExpressionSyntax> {
    protected virtual SyntaxKind GetSyntaxKind();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool CanRemoveParentheses(ParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    public static bool CanRemoveParenthesesHelper(ParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessarySuppressions.VisualBasicRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer : AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer {
    protected virtual void RegisterAttributeSyntaxAction(CompilationStartAnalysisContext context, CompilationAnalyzer compilationAnalyzer);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessarySuppressions.VisualBasicRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer : AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private string _CompilerErrorCodePrefix;
    [CompilerGeneratedAttribute]
private int _CompilerErrorCodeDigitCount;
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    [CompilerGeneratedAttribute]
private ISemanticFacts _SemanticFacts;
    protected string CompilerErrorCodePrefix { get; }
    protected int CompilerErrorCodeDigitCount { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual string get_CompilerErrorCodePrefix();
    [CompilerGeneratedAttribute]
protected virtual int get_CompilerErrorCodeDigitCount();
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    [CompilerGeneratedAttribute]
protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual ValueTuple`2<Assembly, string> GetCompilerDiagnosticAnalyzerInfo();
    protected virtual bool ContainsPragmaDirective(SyntaxNode root);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnusedMembers.VisualBasicRemoveUnusedMembersCodeFixProvider : AbstractRemoveUnusedMembersCodeFixProvider`1<FieldDeclarationSyntax> {
    protected virtual void AdjustAndAddAppropriateDeclaratorsToRemove(HashSet`1<FieldDeclarationSyntax> fieldDeclarators, HashSet`1<SyntaxNode> declarators);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnusedMembers.VisualBasicRemoveUnusedMembersDiagnosticAnalyzer : AbstractRemoveUnusedMembersDiagnosticAnalyzer`4<DocumentationCommentTriviaSyntax, IdentifierNameSyntax, TypeBlockSyntax, StatementSyntax> {
    protected virtual void HandleNamedTypeSymbolStart(SymbolStartAnalysisContext context, Action`2<ISymbol, ValueUsageInfo> onSymbolUsageFound);
    private static void AnalyzeHandlesClause(SyntaxNodeAnalysisContext context, Action`2<ISymbol, ValueUsageInfo> onSymbolUsageFound);
    protected virtual IEnumerable`1<TypeBlockSyntax> GetTypeDeclarations(INamedTypeSymbol namedType, CancellationToken cancellationToken);
    protected virtual SyntaxList`1<StatementSyntax> GetMembers(TypeBlockSyntax typeDeclaration);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnusedParametersAndValues.VisualBasicRemoveUnusedParametersAndValuesDiagnosticAnalyzer : AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueExpressionStatementOption(AnalyzerOptionsProvider provider);
    protected virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueAssignmentOption(AnalyzerOptionsProvider provider);
    protected virtual bool SupportsDiscard(SyntaxTree tree);
    protected virtual bool MethodHasHandlesClause(IMethodSymbol method);
    protected virtual bool IsIfConditionalDirective(SyntaxNode node);
    protected virtual bool IsCallStatement(IExpressionStatementOperation expressionStatement);
    protected virtual bool ReturnsThrow(SyntaxNode node);
    protected virtual bool IsExpressionOfExpressionBody(IExpressionStatementOperation expressionStatementOperation);
    protected virtual Location GetDefinitionLocationToFade(IOperation unusedDefinition);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnusedParametersAndValues.VisualBasicRemoveUnusedValuesCodeFixProvider : AbstractRemoveUnusedValuesCodeFixProvider`11<ExpressionSyntax, StatementSyntax, StatementSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, ForEachBlockSyntax, CaseBlockSyntax, CaseClauseSyntax, CatchStatementSyntax, CatchBlockSyntax> {
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
    protected virtual StatementSyntax WrapWithBlockIfNecessary(IEnumerable`1<StatementSyntax> statements);
    protected virtual void InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(CaseBlockSyntax switchCaseBlock, SyntaxEditor editor, LocalDeclarationStatementSyntax declarationStatement);
    protected virtual SyntaxNode TryUpdateNameForFlaggedNode(SyntaxNode node, SyntaxToken newName);
    protected virtual SyntaxToken GetForEachStatementIdentifier(ForEachBlockSyntax node);
    protected virtual SyntaxNode GetReplacementNodeForCompoundAssignment(SyntaxNode originalCompoundAssignment, SyntaxNode newAssignmentTarget, SyntaxEditor editor, ISyntaxFactsService syntaxFacts);
    protected virtual SyntaxNode GetReplacementNodeForVarPattern(SyntaxNode originalVarPattern, SyntaxNode newNameNode);
    protected virtual SyntaxNode ComputeReplacementNode(SyntaxNode originalOldNode, SyntaxNode changedOldNode, SyntaxNode proposedReplacementNode);
    protected virtual LocalDeclarationStatementSyntax GetCandidateLocalDeclarationForRemoval(VariableDeclaratorSyntax declarator);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnusedVariable.VisualBasicRemoveUnusedVariableCodeFixProvider : AbstractRemoveUnusedVariableCodeFixProvider`3<LocalDeclarationStatementSyntax, ModifiedIdentifierSyntax, VariableDeclaratorSyntax> {
    public static string BC42024;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCatchDeclarationIdentifier(SyntaxToken token);
    protected virtual SyntaxNode GetNodeToRemoveOrReplace(SyntaxNode node);
    protected virtual void RemoveOrReplaceNode(SyntaxEditor editor, SyntaxNode node, IBlockFactsService blockFacts);
    protected virtual SeparatedSyntaxList`1<SyntaxNode> GetVariables(LocalDeclarationStatementSyntax localDeclarationStatement);
    protected virtual bool ShouldOfferFixForLocalDeclaration(IBlockFactsService blockFacts, SyntaxNode node);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ReplaceConditionalWithStatements.VisualBasicReplaceConditionalWithStatementsCodeRefactoringProvider : AbstractReplaceConditionalWithStatementsCodeRefactoringProvider`9<ExpressionSyntax, TernaryConditionalExpressionSyntax, StatementSyntax, LocalDeclarationStatementSyntax, ArgumentSyntax, ArgumentListSyntax, ModifiedIdentifierSyntax, VariableDeclaratorSyntax, EqualsValueSyntax> {
    protected virtual bool CanRewriteLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement);
    protected virtual bool HasSingleVariable(LocalDeclarationStatementSyntax localDeclarationStatement, ModifiedIdentifierSyntax& variable);
    protected virtual LocalDeclarationStatementSyntax GetUpdatedLocalDeclarationStatement(SyntaxGenerator generator, LocalDeclarationStatementSyntax localDeclarationStatement, ILocalSymbol symbol);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ReplaceDocCommentTextWithTag.VisualBasicReplaceDocCommentTextWithTagCodeRefactoringProvider : AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider {
    protected virtual bool IsXmlTextToken(SyntaxToken token);
    protected virtual bool IsInXMLAttribute(SyntaxToken token);
    protected virtual bool IsKeyword(string text);
    protected virtual SyntaxNode ParseExpression(string text);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.AbstractIntrinsicOperatorSignatureHelpProvider`1 : AbstractVisualBasicSignatureHelpProvider {
    protected abstract virtual bool IsTriggerToken(SyntaxToken token);
    protected abstract virtual bool IsArgumentListToken(TSyntaxNode node, SyntaxToken token);
    protected abstract virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(TSyntaxNode node, Document document, CancellationToken cancellationToken);
    private bool TryGetSyntaxNode(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, TSyntaxNode& node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.AbstractIntrinsicOperatorSignatureHelpProvider`1/VB$StateMachine_5_GetItemsWorkerAsync")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    internal static SignatureHelpItem GetSignatureHelpItemForIntrinsicOperator(Document document, SemanticModel semanticModel, int position, AbstractIntrinsicOperatorDocumentation documentation, CancellationToken cancellationToken);
    protected virtual SignatureHelpState GetCurrentArgumentStateWorker(SyntaxNode node, int position);
    private SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.AbstractOrdinaryMethodSignatureHelpProvider : AbstractVisualBasicSignatureHelpProvider {
    protected static SignatureHelpItem ConvertMemberGroupMember(Document document, ISymbol member, int position, SemanticModel semanticModel);
    private static IList`1<SymbolDisplayPart> GetMemberGroupPreambleParts(ISymbol symbol, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetMemberGroupPostambleParts(ISymbol symbol, SemanticModel semanticModel, int position);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.AbstractVisualBasicSignatureHelpProvider : AbstractSignatureHelpProvider {
    protected static SymbolDisplayPart SynthesizedParameter(string s);
    protected static SymbolDisplayPart Keyword(SyntaxKind kind);
    protected static SymbolDisplayPart Punctuation(SyntaxKind kind);
    protected static SymbolDisplayPart Text(string _text);
    protected static SymbolDisplayPart Space();
    protected static SymbolDisplayPart NewLine();
    protected static IList`1<SymbolDisplayPart> GetSeparatorParts();
    protected static SignatureHelpSymbolParameter Convert(IParameterSymbol parameter, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService documentationCommentFormattingService);
    protected static void AddExtensionPreamble(ISymbol symbol, IList`1<SymbolDisplayPart> result);
}
[ExportSignatureHelpProviderAttribute("AddRemoveHandlerSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.AddRemoveHandlerSignatureHelpProvider : AbstractIntrinsicOperatorSignatureHelpProvider`1<AddRemoveHandlerStatementSyntax> {
    protected virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(AddRemoveHandlerStatementSyntax node, Document document, CancellationToken cancellationToken);
    protected virtual bool IsTriggerToken(SyntaxToken token);
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool IsArgumentListToken(AddRemoveHandlerStatementSyntax node, SyntaxToken token);
}
[ExportSignatureHelpProviderAttribute("AttributeSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.AttributeSignatureHelpProvider : AbstractVisualBasicSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetAttributeExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, AttributeSyntax& attribute);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(AttributeSyntax node, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.AttributeSignatureHelpProvider/VB$StateMachine_6_GetItemsWorkerAsync")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IMethodSymbol constructor, ISymbol within, AttributeSyntax attribute, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SignatureHelpSymbolParameter> GetParameters(IMethodSymbol constructor, SemanticModel semanticModel, int position, List`1<ISymbol> namedParameters, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static List`1<SymbolDisplayPart> GetParameterPrefixDisplayParts(int i);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[ExportSignatureHelpProviderAttribute("BinaryConditionalExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.BinaryConditionalExpressionSignatureHelpProvider : ConditionalExpressionSignatureHelpProvider`1<BinaryConditionalExpressionSyntax> {
    protected SyntaxKind Kind { get; }
    protected virtual SyntaxKind get_Kind();
}
[ExportSignatureHelpProviderAttribute("CastExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.CastExpressionSignatureHelpProvider : AbstractIntrinsicOperatorSignatureHelpProvider`1<CastExpressionSyntax> {
    protected virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(CastExpressionSyntax node, Document document, CancellationToken cancellationToken);
    protected virtual bool IsTriggerToken(SyntaxToken token);
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool IsArgumentListToken(CastExpressionSyntax node, SyntaxToken token);
}
[ExportSignatureHelpProviderAttribute("CollectionInitializerSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.CollectionInitializerSignatureHelpProvider : AbstractOrdinaryMethodSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetInitializerExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, CollectionInitializerSyntax& expression);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsInitializerExpressionToken(CollectionInitializerSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.CollectionInitializerSignatureHelpProvider/VB$StateMachine_6_GetItemsWorkerAsync")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.ConditionalExpressionSignatureHelpProvider`1 : AbstractIntrinsicOperatorSignatureHelpProvider`1<T> {
    protected SyntaxKind Kind { get; }
    protected abstract virtual SyntaxKind get_Kind();
    protected virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(T node, Document document, CancellationToken cancellationToken);
    protected virtual bool IsTriggerToken(SyntaxToken token);
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool IsArgumentListToken(T node, SyntaxToken token);
}
[ExportSignatureHelpProviderAttribute("FunctionAggregationSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.FunctionAggregationSignatureHelpProvider : AbstractVisualBasicSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private static SignatureHelpState GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static bool TryGetFunctionAggregation(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, FunctionAggregationSyntax& functionAggregation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.FunctionAggregationSignatureHelpProvider/VB$StateMachine_5_GetItemsWorkerAsync")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IMethodSymbol method, FunctionAggregationSyntax functionAggregation, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method);
    private static IList`1<SymbolDisplayPart> GetPostambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SignatureHelpSymbolParameter> GetParameterParts(IMethodSymbol method, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService documentationCommentFormattingService);
}
[ExportSignatureHelpProviderAttribute("GenericNameSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.GenericNameSignatureHelpProvider : AbstractVisualBasicSignatureHelpProvider {
    private static SymbolDisplayFormat s_minimallyQualifiedFormat;
    private static GenericNameSignatureHelpProvider();
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static ITypeSymbol GetContainingType(IMethodSymbol method);
    private static IList`1<SymbolDisplayPart> GetPostambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(INamedTypeSymbol namedType, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private static Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static bool TryGetGenericName(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, GenericNameSyntax& genericName);
    private static bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(GenericNameSyntax node, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.GenericNameSignatureHelpProvider/VB$StateMachine_13_GetItemsWorkerAsync")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(ISymbol symbol, GenericNameSyntax genericName, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static SignatureHelpSymbolParameter Convert(ITypeParameterSymbol parameter, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> AddConstraints(ITypeParameterSymbol typeParam, List`1<SymbolDisplayPart> parts, SemanticModel semanticModel, int position);
    private static int TypeParameterSpecialConstraintCount(ITypeParameterSymbol typeParam);
}
[ExportSignatureHelpProviderAttribute("GetTypeExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.GetTypeExpressionSignatureHelpProvider : AbstractIntrinsicOperatorSignatureHelpProvider`1<GetTypeExpressionSyntax> {
    protected virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(GetTypeExpressionSyntax node, Document document, CancellationToken cancellationToken);
    protected virtual bool IsTriggerToken(SyntaxToken token);
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool IsArgumentListToken(GetTypeExpressionSyntax node, SyntaxToken token);
}
[ExportSignatureHelpProviderAttribute("GetXmlNamespaceExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.GetXmlNamespaceExpressionSignatureHelpProvider : AbstractIntrinsicOperatorSignatureHelpProvider`1<GetXmlNamespaceExpressionSyntax> {
    protected virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(GetXmlNamespaceExpressionSyntax node, Document document, CancellationToken cancellationToken);
    protected virtual bool IsTriggerToken(SyntaxToken token);
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool IsArgumentListToken(GetXmlNamespaceExpressionSyntax node, SyntaxToken token);
}
[ExportSignatureHelpProviderAttribute("InvocationExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.InvocationExpressionSignatureHelpProvider : AbstractOrdinaryMethodSignatureHelpProvider {
    private static IEnumerable`1<SignatureHelpItem> GetDelegateInvokeItems(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService, INamedTypeSymbol delegateType, CancellationToken cancellationToken);
    private static IList`1<SymbolDisplayPart> GetDelegateInvokePreambleParts(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SignatureHelpSymbolParameter> GetDelegateInvokeParameters(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService documentationCommentFormattingService, CancellationToken cancellationToken);
    private static IList`1<SymbolDisplayPart> GetDelegateInvokePostambleParts(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IEnumerable`1<SignatureHelpItem> GetElementAccessItems(ExpressionSyntax leftExpression, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService, ISymbol within, IList`1<IPropertySymbol> defaultProperties, CancellationToken cancellationToken);
    private static SignatureHelpItem ConvertIndexer(IPropertySymbol indexer, int position, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetIndexerPreambleParts(IPropertySymbol symbol, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetIndexerPostambleParts(IPropertySymbol symbol, SemanticModel semanticModel, int position);
    private static ImmutableArray`1<ISymbol> GetAccessibleMembers(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, ISymbol within, IEnumerable`1<ISymbol> memberGroup, CancellationToken cancellationToken);
    private static IEnumerable`1<SignatureHelpItem> GetMemberGroupItems(ImmutableArray`1<ISymbol> accessibleMembers, Document document, InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel);
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private static Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static bool TryGetInvocationExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, InvocationExpressionSyntax& expression);
    private static bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(InvocationExpressionSyntax node, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.InvocationExpressionSignatureHelpProvider/VB$StateMachine_17_GetItemsWorkerAsync")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
}
[ExportSignatureHelpProviderAttribute("MidAssignmentSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.MidAssignmentSignatureHelpProvider : AbstractIntrinsicOperatorSignatureHelpProvider`1<AssignmentStatementSyntax> {
    protected virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(AssignmentStatementSyntax node, Document document, CancellationToken cancellationToken);
    protected virtual bool IsTriggerToken(SyntaxToken token);
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool IsArgumentListToken(AssignmentStatementSyntax node, SyntaxToken token);
    protected virtual SignatureHelpState GetCurrentArgumentStateWorker(SyntaxNode node, int position);
}
[ExportSignatureHelpProviderAttribute("NameOfExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.NameOfExpressionSignatureHelpProvider : AbstractIntrinsicOperatorSignatureHelpProvider`1<NameOfExpressionSyntax> {
    public virtual bool IsRetriggerCharacter(char ch);
    public virtual bool IsTriggerCharacter(char ch);
    protected virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(NameOfExpressionSyntax node, Document document, CancellationToken cancellationToken);
    protected virtual bool IsArgumentListToken(NameOfExpressionSyntax node, SyntaxToken token);
    protected virtual bool IsTriggerToken(SyntaxToken token);
}
[ExportSignatureHelpProviderAttribute("ObjectCreationExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider : AbstractVisualBasicSignatureHelpProvider {
    private static ValueTuple`2<IList`1<SignatureHelpItem>, Nullable`1<int>> GetDelegateTypeConstructors(ObjectCreationExpressionSyntax objectCreationExpression, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService, INamedTypeSymbol delegateType);
    private static IList`1<SymbolDisplayPart> GetDelegateTypePreambleParts(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SignatureHelpSymbolParameter> GetDelegateTypeParameters(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetDelegateTypePostambleParts();
    private static ValueTuple`2<IList`1<SignatureHelpItem>, Nullable`1<int>> GetNormalTypeConstructors(Document document, ObjectCreationExpressionSyntax objectCreationExpression, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, INamedTypeSymbol normalType, ISymbol within, SignatureHelpOptions options, CancellationToken cancellationToken);
    private static SignatureHelpItem ConvertNormalTypeConstructor(IMethodSymbol constructor, ObjectCreationExpressionSyntax objectCreationExpression, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetNormalTypePreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetNormalTypePostambleParts();
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private static Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static bool TryGetObjectCreationExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, ObjectCreationExpressionSyntax& expression);
    private static bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(ObjectCreationExpressionSyntax node, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider/VB$StateMachine_15_GetItemsWorkerAsync")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
}
[ExportSignatureHelpProviderAttribute("PredefinedCastExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.PredefinedCastExpressionSignatureHelpProvider : AbstractIntrinsicOperatorSignatureHelpProvider`1<PredefinedCastExpressionSyntax> {
    protected virtual ValueTask`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationAsync(PredefinedCastExpressionSyntax node, Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.PredefinedCastExpressionSignatureHelpProvider/VB$StateMachine_2_GetIntrinsicOperatorDocumentationImplAsync")]
private static Task`1<IEnumerable`1<AbstractIntrinsicOperatorDocumentation>> GetIntrinsicOperatorDocumentationImplAsync(PredefinedCastExpressionSyntax node, Document document, CancellationToken cancellationToken);
    protected virtual bool IsTriggerToken(SyntaxToken token);
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool IsArgumentListToken(PredefinedCastExpressionSyntax node, SyntaxToken token);
}
[ExportSignatureHelpProviderAttribute("RaiseEventSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.RaiseEventStatementSignatureHelpProvider : AbstractVisualBasicSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private static Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static bool TryGetRaiseEventStatement(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, RaiseEventStatementSyntax& statement);
    private static bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(RaiseEventStatementSyntax statement, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.RaiseEventStatementSignatureHelpProvider/VB$StateMachine_7_GetItemsWorkerAsync")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IEventSymbol eventSymbol, RaiseEventStatementSyntax raiseEventStatement, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IEventSymbol eventSymbol, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.SignatureHelpUtilities : object {
    private static Func`2<ArgumentListSyntax, SyntaxToken> s_getArgumentListOpenToken;
    private static Func`2<TypeArgumentListSyntax, SyntaxToken> s_getTypeArgumentListOpenToken;
    private static Func`2<CollectionInitializerSyntax, SyntaxToken> s_getCollectionInitializerOpenToken;
    private static Func`2<ArgumentListSyntax, SyntaxToken> s_getArgumentListCloseToken;
    private static Func`2<TypeArgumentListSyntax, SyntaxToken> s_getTypeArgumentListCloseToken;
    private static Func`2<CollectionInitializerSyntax, SyntaxToken> s_getCollectionInitializerCloseToken;
    private static Func`2<ArgumentListSyntax, SyntaxNodeOrTokenList> s_getArgumentListArgumentsWithSeparators;
    private static Func`2<TypeArgumentListSyntax, SyntaxNodeOrTokenList> s_getTypeArgumentListArgumentsWithSeparators;
    private static Func`2<CollectionInitializerSyntax, SyntaxNodeOrTokenList> s_getCollectionInitializerArgumentsWithSeparators;
    private static Func`2<ArgumentListSyntax, IEnumerable`1<string>> s_getArgumentListNames;
    private static Func`2<TypeArgumentListSyntax, IEnumerable`1<string>> s_getTypeArgumentListNames;
    private static Func`2<CollectionInitializerSyntax, IEnumerable`1<string>> s_getCollectionInitializerNames;
    private static SignatureHelpUtilities();
    internal static TextSpan GetSignatureHelpSpan(ArgumentListSyntax argumentList);
    internal static TextSpan GetSignatureHelpSpan(ArgumentListSyntax argumentList, int start);
    internal static TextSpan GetSignatureHelpSpan(TypeArgumentListSyntax argumentList);
    internal static TextSpan GetSignatureHelpSpan(CollectionInitializerSyntax initializer);
    internal static Nullable`1<SignatureHelpState> GetSignatureHelpState(ArgumentListSyntax argumentList, int position);
    internal static Nullable`1<SignatureHelpState> GetSignatureHelpState(TypeArgumentListSyntax typeArgumentList, int position);
    internal static Nullable`1<SignatureHelpState> GetSignatureHelpState(CollectionInitializerSyntax initializer, int position);
}
[ExportSignatureHelpProviderAttribute("TernaryConditionalExpressionSignatureHelpProvider", "Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SignatureHelp.TernaryConditionalExpressionSignatureHelpProvider : ConditionalExpressionSignatureHelpProvider`1<TernaryConditionalExpressionSyntax> {
    protected SyntaxKind Kind { get; }
    protected virtual SyntaxKind get_Kind();
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyBooleanExpression.VisualBasicSimplifyConditionalDiagnosticAnalyzer : AbstractSimplifyConditionalDiagnosticAnalyzer`3<SyntaxKind, ExpressionSyntax, TernaryConditionalExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual CommonConversion GetConversion(SemanticModel semanticModel, ExpressionSyntax node, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyInterpolation.VisualBasicSimplifyInterpolationCodeFixProvider : AbstractSimplifyInterpolationCodeFixProvider`5<InterpolationSyntax, ExpressionSyntax, InterpolationAlignmentClauseSyntax, InterpolationFormatClauseSyntax, InterpolatedStringExpressionSyntax> {
    protected virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    protected virtual InterpolationSyntax WithExpression(InterpolationSyntax interpolation, ExpressionSyntax expression);
    protected virtual InterpolationSyntax WithAlignmentClause(InterpolationSyntax interpolation, InterpolationAlignmentClauseSyntax alignmentClause);
    protected virtual InterpolationSyntax WithFormatClause(InterpolationSyntax interpolation, InterpolationFormatClauseSyntax formatClause);
    protected virtual string Escape(InterpolatedStringExpressionSyntax interpolatedString, string formatString);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyInterpolation.VisualBasicSimplifyInterpolationDiagnosticAnalyzer : AbstractSimplifyInterpolationDiagnosticAnalyzer`2<InterpolationSyntax, ExpressionSyntax> {
    protected virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    protected virtual IVirtualCharService GetVirtualCharService();
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyInterpolation.VisualBasicSimplifyInterpolationHelpers : AbstractSimplifyInterpolationHelpers {
    [CompilerGeneratedAttribute]
private static VisualBasicSimplifyInterpolationHelpers _Instance;
    [CompilerGeneratedAttribute]
private bool _PermitNonLiteralAlignmentComponents;
    public static VisualBasicSimplifyInterpolationHelpers Instance { get; }
    protected bool PermitNonLiteralAlignmentComponents { get; }
    private static VisualBasicSimplifyInterpolationHelpers();
    [CompilerGeneratedAttribute]
public static VisualBasicSimplifyInterpolationHelpers get_Instance();
    [CompilerGeneratedAttribute]
protected virtual bool get_PermitNonLiteralAlignmentComponents();
    protected virtual SyntaxNode GetPreservedInterpolationExpressionSyntax(IOperation operation);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyLinqExpression.VisualBasicSimplifyLinqExpressionCodeFixProvider : AbstractSimplifyLinqExpressionCodeFixProvider`3<InvocationExpressionSyntax, SimpleNameSyntax, ExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyLinqExpression.VisualBasicSimplifyLinqExpressionDiagnosticAnalyzer : AbstractSimplifyLinqExpressionDiagnosticAnalyzer`2<InvocationExpressionSyntax, MemberAccessExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IInvocationOperation TryGetNextInvocationInChain(IInvocationOperation invocation);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyObjectCreation.VisualBasicSimplifyObjectCreationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SimplifyObjectCreation.VisualBasicSimplifyObjectCreationCodeFixProvider/VB$StateMachine_5_FixAllAsync")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyObjectCreation.VisualBasicSimplifyObjectCreationDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    private void AnalyzeVariableDeclarator(SyntaxNodeAnalysisContext context);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyThisOrMe.VisualBasicSimplifyThisOrMeCodeFixProvider : AbstractSimplifyThisOrMeCodeFixProvider`1<MemberAccessExpressionSyntax> {
    protected virtual string GetTitle();
    protected virtual SyntaxNode Rewrite(SyntaxNode root, ISet`1<MemberAccessExpressionSyntax> memberAccessNodes);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyThisOrMe.VisualBasicSimplifyThisOrMeDiagnosticAnalyzer : AbstractSimplifyThisOrMeDiagnosticAnalyzer`4<SyntaxKind, ExpressionSyntax, MeExpressionSyntax, MemberAccessExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxKinds _SyntaxKinds;
    [CompilerGeneratedAttribute]
private AbstractMemberAccessExpressionSimplifier`3<ExpressionSyntax, MemberAccessExpressionSyntax, MeExpressionSyntax> _Simplifier;
    protected ISyntaxKinds SyntaxKinds { get; }
    protected ISimplification Simplification { get; }
    protected AbstractMemberAccessExpressionSimplifier`3<ExpressionSyntax, MemberAccessExpressionSyntax, MeExpressionSyntax> Simplifier { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxKinds get_SyntaxKinds();
    protected virtual ISimplification get_Simplification();
    [CompilerGeneratedAttribute]
protected virtual AbstractMemberAccessExpressionSimplifier`3<ExpressionSyntax, MemberAccessExpressionSyntax, MeExpressionSyntax> get_Simplifier();
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SimplifyTypeNames.SimplifyTypeNamesCodeFixProvider : AbstractSimplifyTypeNamesCodeFixProvider`2<SyntaxKind, VisualBasicSimplifierOptions> {
    protected virtual string GetTitle(string simplifyDiagnosticId, string nodeText);
    protected virtual SyntaxNode AddSimplificationAnnotationTo(SyntaxNode expression);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SolutionCrawler.IDocumentDifferenceService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SolutionCrawler.VisualBasicDocumentDifferenceService : AbstractDocumentDifferenceService {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SpellCheck.VisualBasicSpellCheckCodeFixProvider : AbstractSpellCheckCodeFixProvider`1<SimpleNameSyntax> {
    internal static string BC30002;
    internal static string BC30451;
    internal static string BC30456;
    internal static string BC32045;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool ShouldSpellCheck(SimpleNameSyntax name);
    protected virtual bool DescendIntoChildren(SyntaxNode arg);
    protected virtual bool IsGeneric(SyntaxToken nameToken);
    protected virtual bool IsGeneric(SimpleNameSyntax nameNode);
    protected virtual bool IsGeneric(CompletionItem completionItem);
    protected virtual SyntaxToken CreateIdentifier(SyntaxToken nameToken, string newName);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SpellCheck.ISpellCheckSpanService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SpellCheck.VisualBasicSpellCheckSpanService : AbstractSpellCheckSpanService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SplitOrMergeIfStatements.VisualBasicIfLikeStatementGenerator : object {
    public sealed virtual override bool IsIfOrElseIf(SyntaxNode node);
    public sealed virtual override bool IsCondition(SyntaxNode expression, SyntaxNode& ifOrElseIf);
    public sealed virtual override bool IsElseIfClause(SyntaxNode node, SyntaxNode& parentIfOrElseIf);
    public sealed virtual override bool HasElseIfClause(SyntaxNode ifOrElseIf, SyntaxNode& elseIfClause);
    public sealed virtual override SyntaxNode GetCondition(SyntaxNode ifOrElseIf);
    public sealed virtual override SyntaxNode GetRootIfStatement(SyntaxNode ifOrElseIf);
    public sealed virtual override ImmutableArray`1<SyntaxNode> GetElseIfAndElseClauses(SyntaxNode ifOrElseIf);
    private static SyntaxList`1<SyntaxNode> AddIfNotNull(SyntaxList`1<SyntaxNode> list, SyntaxNode node);
    public sealed virtual override SyntaxNode WithCondition(SyntaxNode ifOrElseIf, SyntaxNode condition);
    public sealed virtual override SyntaxNode WithStatementInBlock(SyntaxNode ifOrElseIf, SyntaxNode statement);
    public sealed virtual override SyntaxNode WithStatementsOf(SyntaxNode ifOrElseIf, SyntaxNode otherIfOrElseIf);
    public sealed virtual override SyntaxNode WithElseIfAndElseClausesOf(SyntaxNode ifStatement, SyntaxNode otherIfStatement);
    public sealed virtual override SyntaxNode ToIfStatement(SyntaxNode ifOrElseIf);
    public sealed virtual override SyntaxNode ToElseIfClause(SyntaxNode ifOrElseIf);
    public sealed virtual override void InsertElseIfClause(SyntaxEditor editor, SyntaxNode afterIfOrElseIf, SyntaxNode elseIfClause);
    public sealed virtual override void RemoveElseIfClause(SyntaxEditor editor, SyntaxNode elseIfClause);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SplitOrMergeIfStatements.VisualBasicMergeConsecutiveIfStatementsCodeRefactoringProvider : AbstractMergeConsecutiveIfStatementsCodeRefactoringProvider {
    protected virtual bool IsApplicableSpan(SyntaxNode node, TextSpan span, SyntaxNode& ifOrElseIf);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SplitOrMergeIfStatements.VisualBasicMergeNestedIfStatementsCodeRefactoringProvider : AbstractMergeNestedIfStatementsCodeRefactoringProvider {
    protected virtual bool IsApplicableSpan(SyntaxNode node, TextSpan span, SyntaxNode& ifOrElseIf);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SplitOrMergeIfStatements.VisualBasicSplitIntoConsecutiveIfStatementsCodeRefactoringProvider : AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider {
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SplitOrMergeIfStatements.VisualBasicSplitIntoNestedIfStatementsCodeRefactoringProvider : AbstractSplitIntoNestedIfStatementsCodeRefactoringProvider {
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.AccessorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<AccessorStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, AccessorStatementSyntax accessorDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.CollectionInitializerStructureProvider : AbstractSyntaxNodeStructureProvider`1<CollectionInitializerSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, CollectionInitializerSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.CompilationUnitStructureProvider : AbstractSyntaxNodeStructureProvider`1<CompilationUnitSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, CompilationUnitSyntax compilationUnit, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.ConstructorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<SubNewStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, SubNewStatementSyntax constructorDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.DelegateDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<DelegateStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, DelegateStatementSyntax delegateDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.DisabledTextTriviaStructureProvider : AbstractSyntaxTriviaStructureProvider {
    public virtual void CollectBlockSpans(SyntaxTrivia trivia, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.DocumentationCommentStructureProvider : AbstractSyntaxNodeStructureProvider`1<DocumentationCommentTriviaSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, DocumentationCommentTriviaSyntax documentationComment, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.DoLoopBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<DoLoopBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, DoLoopBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.EnumDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EnumStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, EnumStatementSyntax enumDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.EnumMemberDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EnumMemberDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, EnumMemberDeclarationSyntax enumMemberDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.EventDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EventStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, EventStatementSyntax eventDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.ExternalMethodDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<DeclareStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, DeclareStatementSyntax externalMethodDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.FieldDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<FieldDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, FieldDeclarationSyntax fieldDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.ForBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<ForBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, ForBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.ForEachBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<ForEachBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, ForEachBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.InterpolatedStringExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<InterpolatedStringExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, InterpolatedStringExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.MethodDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<MethodStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, MethodStatementSyntax methodDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.MultiLineIfBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<MultiLineIfBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, MultiLineIfBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.MultilineLambdaStructureProvider : AbstractSyntaxNodeStructureProvider`1<MultiLineLambdaExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, MultiLineLambdaExpressionSyntax lambdaExpression, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.NamespaceDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<NamespaceStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, NamespaceStatementSyntax namespaceDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.ObjectCreationInitializerStructureProvider : AbstractSyntaxNodeStructureProvider`1<ObjectCreationInitializerSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, ObjectCreationInitializerSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.OperatorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<OperatorStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, OperatorStatementSyntax operatorDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.PropertyDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<PropertyStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, PropertyStatementSyntax propertyDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.RegionDirectiveStructureProvider : AbstractSyntaxNodeStructureProvider`1<RegionDirectiveTriviaSyntax> {
    private static string GetBannerText(RegionDirectiveTriviaSyntax regionDirective);
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, RegionDirectiveTriviaSyntax regionDirective, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken CancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.SelectBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<SelectBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, SelectBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.StringLiteralExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<LiteralExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, LiteralExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.SyncLockBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<SyncLockBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, SyncLockBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.TryBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<TryBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, TryBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.TypeDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<TypeStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, TypeStatementSyntax typeDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.UsingBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<UsingBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, UsingBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.VisualBasicBlockStructureProvider : AbstractBlockStructureProvider {
    public static ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> CreateDefaultNodeStructureProviderMap();
    public static ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> CreateDefaultTriviaStructureProviderMap();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.VisualBasicBlockStructureService : BlockStructureServiceWithProviders {
    public string Language { get; }
    internal VisualBasicBlockStructureService(SolutionServices services);
    public virtual string get_Language();
    protected virtual ImmutableArray`1<BlockStructureProvider> GetBuiltInProviders();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Structure.BlockStructureService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.VisualBasicBlockStructureServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.VisualBasicOutliningHelpers : object {
    public static string Ellipsis;
    public static string SpaceEllipsis;
    public static int MaxXmlDocCommentBannerLength;
    private static string GetNodeBannerText(SyntaxNode node);
    private static string GetCommentBannerText(SyntaxTrivia comment);
    private static Nullable`1<BlockSpan> CreateCommentsRegion(SyntaxTrivia startComment, SyntaxTrivia endComment);
    internal static ImmutableArray`1<BlockSpan> CreateCommentsRegions(SyntaxTriviaList triviaList);
    internal static void CollectCommentsRegions(SyntaxTriviaList triviaList, TemporaryArray`1& spans);
    internal static void CollectCommentsRegions(SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptions options);
    private static bool TryGetLeadingCollapsibleSpan(SyntaxNode node, BlockSpan& span);
    private static SyntaxToken GetEndToken(SyntaxNode node);
    private static SyntaxToken GetHintTextEndToken(SyntaxNode node);
    internal static Nullable`1<BlockSpan> CreateBlockSpan(TextSpan span, TextSpan hintSpan, string bannerText, bool autoCollapse, string type, bool isCollapsible, bool isDefaultCollapsed);
    internal static Nullable`1<BlockSpan> CreateBlockSpanFromBlock(SyntaxNode blockNode, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    internal static Nullable`1<BlockSpan> CreateBlockSpanFromBlock(SyntaxNode blockNode, SyntaxNode bannerNode, bool autoCollapse, string type, bool isCollapsible);
    private static TextSpan GetHintSpan(SyntaxNode blockNode);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.WhileBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<WhileBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, WhileBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.WithBlockStructureProvider : AbstractSyntaxNodeStructureProvider`1<WithBlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, WithBlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Structure.XmlExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<XmlNodeSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, XmlNodeSyntax xmlExpression, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.TaskList.ITaskListService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.TaskList.VisualBasicTaskListService : AbstractTaskListService {
    private static char s_DWCH_SQ;
    private static char s_DWCH_LSMART_Q;
    private static char s_DWCH_RSMART_Q;
    protected virtual void AppendTaskListItems(ImmutableArray`1<TaskListItemDescriptor> commentDescriptors, SyntacticDocument document, SyntaxTrivia trivia, ArrayBuilder`1<TaskListItem> items);
    protected virtual string GetNormalizedText(string message);
    protected virtual bool IsIdentifierCharacter(char ch);
    protected virtual int GetCommentStartingIndex(string message);
    private static int GetFirstCharacterIndex(string message, int start);
    private static int GetFirstNonWhitespace(string message, int start);
    protected virtual bool IsMultilineComment(SyntaxTrivia trivia);
    protected virtual bool IsSingleLineComment(SyntaxTrivia trivia);
    protected virtual bool PreprocessorHasComment(SyntaxTrivia trivia);
    private static bool IsSingleQuote(char c);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UnsealClass.VisualBasicUnsealClassCodeFixProvider : AbstractUnsealClassCodeFixProvider {
    private static string BC30299;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    [CompilerGeneratedAttribute]
private string _TitleFormat;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string TitleFormat { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual string get_TitleFormat();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseAutoProperty.Utilities : object {
    internal static SyntaxNode GetNodeToRemove(ModifiedIdentifierSyntax identifier);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseAutoProperty.VisualBasicUseAutoPropertyAnalyzer : AbstractUseAutoPropertyAnalyzer`7<SyntaxKind, PropertyBlockSyntax, ConstructorBlockSyntax, FieldDeclarationSyntax, ModifiedIdentifierSyntax, ExpressionSyntax, IdentifierNameSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind _PropertyDeclarationKind;
    [CompilerGeneratedAttribute]
private ISemanticFacts _SemanticFacts;
    protected SyntaxKind PropertyDeclarationKind { get; }
    protected ISemanticFacts SemanticFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind get_PropertyDeclarationKind();
    [CompilerGeneratedAttribute]
protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual bool SupportsReadOnlyProperties(Compilation compilation);
    protected virtual bool SupportsPropertyInitializer(Compilation compilation);
    protected virtual bool CanExplicitInterfaceImplementationsBeFixed();
    protected virtual void RegisterIneligibleFieldsAction(HashSet`1<string> fieldNames, ConcurrentSet`1<IFieldSymbol> ineligibleFields, SemanticModel semanticModel, SyntaxNode codeBlock, CancellationToken cancellationToken);
    protected virtual bool CanConvert(IPropertySymbol prop);
    protected virtual ExpressionSyntax GetFieldInitializer(ModifiedIdentifierSyntax variable, CancellationToken cancellationToken);
    private static bool CheckExpressionSyntactically(ExpressionSyntax expression);
    protected virtual ExpressionSyntax GetGetterExpression(IMethodSymbol getMethod, CancellationToken cancellationToken);
    protected virtual ExpressionSyntax GetSetterExpression(IMethodSymbol setMethod, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetFieldNode(FieldDeclarationSyntax fieldDeclaration, ModifiedIdentifierSyntax identifier);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseAutoProperty.VisualBasicUseAutoPropertyCodeFixProvider : AbstractUseAutoPropertyCodeFixProvider`5<TypeBlockSyntax, PropertyBlockSyntax, ModifiedIdentifierSyntax, ConstructorBlockSyntax, ExpressionSyntax> {
    protected virtual PropertyBlockSyntax GetPropertyDeclaration(SyntaxNode node);
    protected virtual SyntaxNode GetNodeToRemove(ModifiedIdentifierSyntax identifier);
    protected virtual ImmutableArray`1<AbstractFormattingRule> GetFormattingRules(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.UseAutoProperty.VisualBasicUseAutoPropertyCodeFixProvider/VB$StateMachine_4_UpdatePropertyAsync")]
protected virtual Task`1<SyntaxNode> UpdatePropertyAsync(Document propertyDocument, Compilation compilation, IFieldSymbol fieldSymbol, IPropertySymbol propertySymbol, PropertyBlockSyntax propertyDeclaration, bool isWrittenToOutsideOfConstructor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.UseAutoProperty.VisualBasicUseAutoPropertyCodeFixProvider/VB$StateMachine_5_GetFieldInitializerAsync")]
private static Task`1<ValueTuple`3<EqualsValueSyntax, AsNewClauseSyntax, ArgumentListSyntax>> GetFieldInitializerAsync(IFieldSymbol fieldSymbol, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCoalesceExpression.VisualBasicUseCoalesceExpressionForIfNullStatementCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForIfNullStatementCheckDiagnosticAnalyzer`5<SyntaxKind, ExpressionSyntax, StatementSyntax, VariableDeclaratorSyntax, MultiLineIfBlockSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind _IfStatementKind;
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected SyntaxKind IfStatementKind { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind get_IfStatementKind();
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual bool IsSingle(VariableDeclaratorSyntax declarator);
    protected virtual SyntaxNode GetDeclarationNode(VariableDeclaratorSyntax declarator);
    protected virtual ExpressionSyntax GetConditionOfIfStatement(MultiLineIfBlockSyntax ifBlock);
    protected virtual bool IsNullCheck(ExpressionSyntax condition, ExpressionSyntax& checkedExpression);
    protected virtual bool TryGetEmbeddedStatement(MultiLineIfBlockSyntax ifBlock, StatementSyntax& whenTrueStatement);
    protected virtual bool HasElseBlock(MultiLineIfBlockSyntax ifBlock);
    protected virtual StatementSyntax TryGetPreviousStatement(MultiLineIfBlockSyntax ifBlock);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCoalesceExpression.VisualBasicUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer`6<SyntaxKind, ExpressionSyntax, TernaryConditionalExpressionSyntax, BinaryExpressionSyntax, MemberAccessExpressionSyntax, UnaryExpressionSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsTargetTyped(SemanticModel semanticModel, TernaryConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCoalesceExpression.VisualBasicUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer`4<SyntaxKind, ExpressionSyntax, TernaryConditionalExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsTargetTyped(SemanticModel semanticModel, TernaryConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.UseCollectionInitializer.VisualBasicCollectionInitializerAnalyzer : AbstractUseCollectionInitializerAnalyzer`9<ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, VisualBasicCollectionInitializerAnalyzer> {
    [CompilerGeneratedAttribute]
private IUpdateExpressionSyntaxHelper`2<ExpressionSyntax, StatementSyntax> _SyntaxHelper;
    protected IUpdateExpressionSyntaxHelper`2<ExpressionSyntax, StatementSyntax> SyntaxHelper { get; }
    [CompilerGeneratedAttribute]
protected virtual IUpdateExpressionSyntaxHelper`2<ExpressionSyntax, StatementSyntax> get_SyntaxHelper();
    protected virtual bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, ObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
    protected virtual bool IsComplexElementInitializer(SyntaxNode expression);
    protected virtual bool HasExistingInvalidInitializerForCollection();
    protected virtual bool ValidateMatchesForCollectionExpression(ArrayBuilder`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCollectionInitializer.VisualBasicObjectCreationHelpers : object {
    public static bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, ObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
}
internal class Microsoft.CodeAnalysis.VisualBasic.UseCollectionInitializer.VisualBasicUpdateExpressionSyntaxHelper : object {
    public static VisualBasicUpdateExpressionSyntaxHelper Instance;
    private static VisualBasicUpdateExpressionSyntaxHelper();
    public sealed virtual override void GetPartsOfForeachStatement(StatementSyntax statement, SyntaxToken& awaitKeyword, SyntaxToken& identifier, ExpressionSyntax& expression, IEnumerable`1& statements);
    public sealed virtual override void GetPartsOfIfStatement(StatementSyntax statement, ExpressionSyntax& condition, IEnumerable`1& whenTrueStatements, IEnumerable`1& whenFalseStatements);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCollectionInitializer.VisualBasicUseCollectionInitializerCodeFixProvider : AbstractUseCollectionInitializerCodeFixProvider`10<SyntaxKind, ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, VisualBasicCollectionInitializerAnalyzer> {
    protected virtual VisualBasicCollectionInitializerAnalyzer GetAnalyzer();
    protected virtual Task`1<ValueTuple`2<SyntaxNode, SyntaxNode>> GetReplacementNodesAsync(Document document, CodeActionOptionsProvider options, ObjectCreationExpressionSyntax objectCreation, bool useCollectionExpression, ImmutableArray`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
    private static ObjectCreationExpressionSyntax GetNewObjectCreation(ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`1<StatementSyntax>> matches);
    private static CollectionInitializerSyntax CreateCollectionInitializer(ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`1<StatementSyntax>> matches);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCollectionInitializer.VisualBasicUseCollectionInitializerDiagnosticAnalyzer : AbstractUseCollectionInitializerDiagnosticAnalyzer`10<SyntaxKind, ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, VisualBasicCollectionInitializerAnalyzer> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual VisualBasicCollectionInitializerAnalyzer GetAnalyzer();
    protected virtual bool AreCollectionInitializersSupported(Compilation compilation);
    protected virtual bool AreCollectionExpressionsSupported(Compilation compilation);
    protected virtual bool CanUseCollectionExpression(SemanticModel semanticModel, ObjectCreationExpressionSyntax objectCreationExpression, INamedTypeSymbol expressionType, bool allowSemanticsChange, CancellationToken cancellationToken, Boolean& changesSemantics);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCompoundAssignment.Utilities : object {
    public static ImmutableArray`1<ValueTuple`3<SyntaxKind, SyntaxKind, SyntaxKind>> Kinds;
    private static Utilities();
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCompoundAssignment.VisualBasicUseCompoundAssignmentCodeFixProvider : AbstractUseCompoundAssignmentCodeFixProvider`3<SyntaxKind, AssignmentStatementSyntax, ExpressionSyntax> {
    protected virtual SyntaxToken Token(SyntaxKind kind);
    protected virtual AssignmentStatementSyntax Assignment(SyntaxKind assignmentOpKind, ExpressionSyntax left, SyntaxToken syntaxToken, ExpressionSyntax right);
    protected virtual ExpressionSyntax Increment(ExpressionSyntax left, bool postfix);
    protected virtual ExpressionSyntax Decrement(ExpressionSyntax left, bool postfix);
    protected virtual SyntaxTriviaList PrepareRightExpressionLeadingTrivia(SyntaxTriviaList initialTrivia);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseCompoundAssignment.VisualBasicUseCompoundAssignmentDiagnosticAnalyzer : AbstractUseCompoundAssignmentDiagnosticAnalyzer`3<SyntaxKind, AssignmentStatementSyntax, BinaryExpressionSyntax> {
    protected virtual SyntaxKind GetAnalysisKind();
    protected virtual bool IsSupported(SyntaxKind assignmentKind, ParseOptions options);
    protected virtual int TryGetIncrementOrDecrement(SyntaxKind opKind, object constantValue);
}
internal class Microsoft.CodeAnalysis.VisualBasic.UseConditionalExpression.MultiLineConditionalExpressionFormattingRule : CompatAbstractFormattingRule {
    public static MultiLineConditionalExpressionFormattingRule Instance;
    private static MultiLineConditionalExpressionFormattingRule();
    private static bool IsCommaOfNewConditional(SyntaxToken token);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustNewLinesOperation& nextOperation);
    public virtual void AddIndentBlockOperationsSlow(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseConditionalExpression.VisualBasicUseConditionalExpressionForAssignmentCodeFixProvider : AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6<StatementSyntax, MultiLineIfBlockSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, ExpressionSyntax, TernaryConditionalExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected virtual VariableDeclaratorSyntax WithInitializer(VariableDeclaratorSyntax variable, ExpressionSyntax value);
    protected virtual VariableDeclaratorSyntax GetDeclaratorSyntax(IVariableDeclaratorOperation declarator);
    protected virtual LocalDeclarationStatementSyntax AddSimplificationToType(LocalDeclarationStatementSyntax statement);
    protected virtual StatementSyntax WrapWithBlockIfAppropriate(MultiLineIfBlockSyntax ifStatement, StatementSyntax statement);
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseConditionalExpression.VisualBasicUseConditionalExpressionForAssignmentDiagnosticAnalyzer : AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1<MultiLineIfBlockSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseConditionalExpression.VisualBasicUseConditionalExpressionForReturnCodeFixProvider : AbstractUseConditionalExpressionForReturnCodeFixProvider`4<StatementSyntax, MultiLineIfBlockSyntax, ExpressionSyntax, TernaryConditionalExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    protected virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected virtual StatementSyntax WrapWithBlockIfAppropriate(MultiLineIfBlockSyntax ifStatement, StatementSyntax statement);
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseConditionalExpression.VisualBasicUseConditionalExpressionForReturnDiagnosticAnalyzer : AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1<MultiLineIfBlockSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseInferredMemberName.VisualBasicUseInferredMemberNameCodeFixProvider : AbstractUseInferredMemberNameCodeFixProvider {
    protected virtual void LanguageSpecificRemoveSuggestedNode(SyntaxEditor editor, SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseInferredMemberName.VisualBasicUseInferredMemberNameDiagnosticAnalyzer : AbstractUseInferredMemberNameDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    protected virtual void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private void ReportDiagnosticsIfNeeded(NameColonEqualsSyntax nameColonEquals, SyntaxNodeAnalysisContext context);
    private void ReportDiagnosticsIfNeeded(NamedFieldInitializerSyntax fieldInitializer, SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
private void _Lambda$__1-0(SyntaxNodeAnalysisContext c);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseIsNotExpression.VisualBasicUseIsNotExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> _FixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void ProcessDiagnostic(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseIsNotExpression.VisualBasicUseIsNotExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseIsNullCheck.VisualBasicUseIsNullCheckForReferenceEqualsCodeFixProvider : AbstractUseIsNullCheckForReferenceEqualsCodeFixProvider`1<ExpressionSyntax> {
    protected virtual string GetTitle(bool negate, ParseOptions options);
    protected virtual SyntaxNode CreateNullCheck(ExpressionSyntax argument, bool isUnconstrainedGeneric);
    protected virtual SyntaxNode CreateNotNullCheck(ExpressionSyntax argument);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseIsNullCheck.VisualBasicUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer : AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1<SyntaxKind> {
    protected virtual bool IsLanguageVersionSupported(Compilation compilation);
    protected virtual bool IsUnconstrainedGenericSupported(Compilation compilation);
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseNamedArguments.VisualBasicUseNamedArgumentsCodeRefactoringProvider : AbstractUseNamedArgumentsCodeRefactoringProvider {
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseNullPropagation.VisualBasicUseNullPropagationCodeFixProvider : AbstractUseNullPropagationCodeFixProvider`13<SyntaxKind, ExpressionSyntax, ExecutableStatementSyntax, TernaryConditionalExpressionSyntax, BinaryExpressionSyntax, InvocationExpressionSyntax, ConditionalAccessExpressionSyntax, InvocationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, MultiLineIfBlockSyntax, ExpressionStatementSyntax, ArgumentListSyntax> {
    protected virtual bool TryGetBlock(SyntaxNode node, ExecutableStatementSyntax& block);
    protected virtual ExecutableStatementSyntax ReplaceBlockStatements(ExecutableStatementSyntax block, ExecutableStatementSyntax newInnerStatement);
    protected virtual SyntaxNode PostProcessElseIf(MultiLineIfBlockSyntax ifStatement, ExecutableStatementSyntax newWhenTrueStatement);
    protected virtual InvocationExpressionSyntax ElementBindingExpression(ArgumentListSyntax argumentList);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseNullPropagation.VisualBasicUseNullPropagationDiagnosticAnalyzer : AbstractUseNullPropagationDiagnosticAnalyzer`11<SyntaxKind, ExpressionSyntax, ExecutableStatementSyntax, TernaryConditionalExpressionSyntax, BinaryExpressionSyntax, InvocationExpressionSyntax, ConditionalAccessExpressionSyntax, InvocationExpressionSyntax, MemberAccessExpressionSyntax, MultiLineIfBlockSyntax, ExpressionStatementSyntax> {
    [CompilerGeneratedAttribute]
private SyntaxKind _IfStatementSyntaxKind;
    [CompilerGeneratedAttribute]
private ISemanticFacts _SemanticFacts;
    protected SyntaxKind IfStatementSyntaxKind { get; }
    protected ISemanticFacts SemanticFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual SyntaxKind get_IfStatementSyntaxKind();
    [CompilerGeneratedAttribute]
protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual bool ShouldAnalyze(Compilation compilation);
    protected virtual bool TryAnalyzePatternCondition(ISyntaxFacts syntaxFacts, ExpressionSyntax conditionNode, ExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    protected virtual bool TryGetPartsOfIfStatement(MultiLineIfBlockSyntax ifStatement, ExpressionSyntax& condition, ExecutableStatementSyntax& trueStatement);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseObjectInitializer.UseInitializerHelpers : object {
    public static ObjectCreationExpressionSyntax GetNewObjectCreation(ObjectCreationExpressionSyntax objectCreation, ObjectCreationInitializerSyntax initializer);
    public static void AddExistingItems(ObjectCreationExpressionSyntax objectCreation, ArrayBuilder`1<SyntaxNodeOrToken> nodesAndTokens);
}
internal class Microsoft.CodeAnalysis.VisualBasic.UseObjectInitializer.VisualBasicUseNamedMemberInitializerAnalyzer : AbstractUseNamedMemberInitializerAnalyzer`8<ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, AssignmentStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, VisualBasicUseNamedMemberInitializerAnalyzer> {
    protected virtual bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, ObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
}
[ExportCodeFixProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.UseObjectInitializer.VisualBasicUseObjectInitializerCodeFixProvider : AbstractUseObjectInitializerCodeFixProvider`9<SyntaxKind, ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, AssignmentStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, VisualBasicUseNamedMemberInitializerAnalyzer> {
    protected virtual VisualBasicUseNamedMemberInitializerAnalyzer GetAnalyzer();
    protected virtual StatementSyntax GetNewStatement(StatementSyntax statement, ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, AssignmentStatementSyntax>> matches);
    private static ObjectCreationExpressionSyntax GetNewObjectCreation(ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, AssignmentStatementSyntax>> matches);
    private static SeparatedSyntaxList`1<FieldInitializerSyntax> CreateFieldInitializers(ObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, AssignmentStatementSyntax>> matches);
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.UseObjectInitializer.VisualBasicUseObjectInitializerDiagnosticAnalyzer : AbstractUseObjectInitializerDiagnosticAnalyzer`9<SyntaxKind, ExpressionSyntax, StatementSyntax, ObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, AssignmentStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, VisualBasicUseNamedMemberInitializerAnalyzer> {
    [CompilerGeneratedAttribute]
private bool _FadeOutOperatorToken;
    protected bool FadeOutOperatorToken { get; }
    [CompilerGeneratedAttribute]
protected virtual bool get_FadeOutOperatorToken();
    protected virtual bool AreObjectInitializersSupported(Compilation compilation);
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsValidContainingStatement(StatementSyntax node);
    protected virtual VisualBasicUseNamedMemberInitializerAnalyzer GetAnalyzer();
}
[DiagnosticAnalyzerAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.VisualBasic.ValidateFormatString.VisualBasicValidateFormatStringDiagnosticAnalyzer : AbstractValidateFormatStringDiagnosticAnalyzer`1<SyntaxKind> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual SyntaxNode TryGetMatchingNamedArgument(SeparatedSyntaxList`1<SyntaxNode> arguments, string searchArgumentName);
    protected virtual SyntaxNode GetArgumentExpression(SyntaxNode syntaxNode);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VBFeaturesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo _Culture;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Insert_0 { get; }
    internal static string Delete_the_0_statement1 { get; }
    internal static string Create_event_0_in_1 { get; }
    internal static string Insert_the_missing_End_Property_statement { get; }
    internal static string Insert_the_missing_0 { get; }
    internal static string Conflict_s_detected { get; }
    internal static string Invert_If { get; }
    internal static string Add_Await { get; }
    internal static string Add_Await_and_ConfigureAwaitFalse { get; }
    internal static string Move_the_0_statement_to_line_1 { get; }
    internal static string Delete_the_0_statement2 { get; }
    internal static string Type_a_name_here_to_declare_a_new_field { get; }
    internal static string Note_colon_Space_completion_is_disabled_to_avoid_potential_interference_To_insert_a_name_from_the_list_use_tab { get; }
    internal static string new_field { get; }
    internal static string Type_a_name_here_to_declare_a_parameter_If_no_preceding_keyword_is_used_ByVal_will_be_assumed_and_the_argument_will_be_passed_by_value { get; }
    internal static string parameter_name { get; }
    internal static string Type_a_new_name_for_the_column_followed_by_Otherwise_the_original_column_name_with_be_used { get; }
    internal static string Note_colon_Use_tab_for_automatic_completion_space_completion_is_disabled_to_avoid_interfering_with_a_new_name { get; }
    internal static string result_alias { get; }
    internal static string Type_a_new_variable_name { get; }
    internal static string Note_colon_Space_and_completion_are_disabled_to_avoid_potential_interference_To_insert_a_name_from_the_list_use_tab { get; }
    internal static string new_resource { get; }
    internal static string AddHandler_statement { get; }
    internal static string RemoveHandler_statement { get; }
    internal static string _0_function { get; }
    internal static string CType_function { get; }
    internal static string DirectCast_function { get; }
    internal static string TryCast_function { get; }
    internal static string GetType_function { get; }
    internal static string GetXmlNamespace_function { get; }
    internal static string Mid_statement { get; }
    internal static string Fix_Incorrect_Function_Return_Type { get; }
    internal static string Simplify_name_0 { get; }
    internal static string Simplify_member_access_0 { get; }
    internal static string Remove_Me_qualification { get; }
    internal static string can_t_determine_valid_range_of_statements_to_extract_out { get; }
    internal static string Not_all_code_paths_return { get; }
    internal static string contains_invalid_selection { get; }
    internal static string the_selection_contains_syntactic_errors { get; }
    internal static string Selection_can_t_be_crossed_over_preprocessors { get; }
    internal static string Selection_can_t_contain_throw_without_enclosing_catch_block { get; }
    internal static string Selection_can_t_be_parts_of_constant_initializer_expression { get; }
    internal static string Argument_used_for_ByRef_parameter_can_t_be_extracted_out { get; }
    internal static string all_static_local_usages_defined_in_the_selection_must_be_included_in_the_selection { get; }
    internal static string Implicit_member_access_can_t_be_included_in_the_selection_without_containing_statement { get; }
    internal static string Selection_must_be_part_of_executable_statements { get; }
    internal static string next_statement_control_variable_doesn_t_have_matching_declaration_statement { get; }
    internal static string Selection_doesn_t_contain_any_valid_node { get; }
    internal static string no_valid_statement_range_to_extract_out { get; }
    internal static string Deprecated { get; }
    internal static string Extension { get; }
    internal static string Awaitable { get; }
    internal static string Awaitable_Extension { get; }
    internal static string new_variable { get; }
    internal static string Creates_a_delegate_procedure_instance_that_references_the_specified_procedure_AddressOf_procedureName { get; }
    internal static string Indicates_that_an_external_procedure_has_another_name_in_its_DLL { get; }
    internal static string Performs_a_short_circuit_logical_conjunction_on_two_expressions_Returns_True_if_both_operands_evaluate_to_True_If_the_first_expression_evaluates_to_False_the_second_is_not_evaluated_result_expression1_AndAlso_expression2 { get; }
    internal static string Performs_a_logical_conjunction_on_two_Boolean_expressions_or_a_bitwise_conjunction_on_two_numeric_expressions_For_Boolean_expressions_returns_True_if_both_operands_evaluate_to_True_Both_expressions_are_always_evaluated_result_expression1_And_expression2 { get; }
    internal static string Used_in_a_Declare_statement_The_Ansi_modifier_specifies_that_Visual_Basic_should_marshal_all_strings_to_ANSI_values_and_should_look_up_the_procedure_without_modifying_its_name_during_the_search_If_no_character_set_is_specified_ANSI_is_the_default { get; }
    internal static string Specifies_a_data_type_in_a_declaration_statement { get; }
    internal static string Specifies_that_an_attribute_at_the_beginning_of_a_source_file_applies_to_the_entire_assembly_Otherwise_the_attribute_will_apply_only_to_an_individual_programming_element_such_as_a_class_or_property { get; }
    internal static string Indicates_an_asynchronous_method_that_can_use_the_Await_operator { get; }
    internal static string Used_in_a_Declare_statement_The_Auto_modifier_specifies_that_Visual_Basic_should_marshal_strings_according_to_NET_Framework_rules_and_should_determine_the_base_character_set_of_the_run_time_platform_and_possibly_modify_the_external_procedure_name_if_the_initial_search_fails { get; }
    internal static string Specifies_that_an_argument_is_passed_in_such_a_way_that_the_called_procedure_can_change_the_underlying_value_of_the_argument_in_the_calling_code { get; }
    internal static string Specifies_that_an_argument_is_passed_in_such_a_way_that_the_called_procedure_or_property_cannot_change_the_underlying_value_of_the_argument_in_the_calling_code { get; }
    internal static string Declares_the_name_of_a_class_and_introduces_the_definitions_of_the_variables_properties_and_methods_that_make_up_the_class { get; }
    internal static string Generates_a_string_concatenation_of_two_expressions { get; }
    internal static string Declares_and_defines_one_or_more_constants { get; }
    internal static string Use_In_for_a_type_that_will_only_be_used_for_ByVal_arguments_to_functions { get; }
    internal static string Use_Out_for_a_type_that_will_only_be_used_as_a_return_from_functions { get; }
    internal static string Returns_the_result_of_explicitly_converting_an_expression_to_a_specified_data_type_object_structure_class_or_interface_CType_Object_As_Expression_Object_As_Type_As_Type { get; }
    internal static string Specifies_that_an_event_has_additional_specialized_code_for_adding_handlers_removing_handlers_and_raising_events { get; }
    internal static string Declares_a_reference_to_a_procedure_implemented_in_an_external_file { get; }
    internal static string Identifies_a_property_as_the_default_property_of_its_class_structure_or_interface { get; }
    internal static string Used_to_declare_a_delegate_A_delegate_is_a_reference_type_that_refers_to_a_shared_method_of_a_type_or_to_an_instance_method_of_an_object_Any_procedure_that_is_convertible_or_that_has_matching_parameter_types_and_return_type_may_be_used_to_create_an_instance_of_this_delegate_class { get; }
    internal static string Declares_and_allocates_storage_space_for_one_or_more_variables_Dim_var_bracket_As_bracket_New_bracket_dataType_bracket_boundList_bracket_bracket_bracket_initializer_bracket_bracket_var2_bracket { get; }
    internal static string Divides_two_numbers_and_returns_a_floating_point_result { get; }
    internal static string Terminates_a_0_block { get; }
    internal static string Terminates_an_0_block { get; }
    internal static string Terminates_the_definition_of_a_0_statement { get; }
    internal static string Terminates_the_definition_of_an_0_statement { get; }
    internal static string Declares_an_enumeration_and_defines_the_values_of_its_members { get; }
    internal static string Compares_two_expressions_and_returns_True_if_they_are_equal_Otherwise_returns_False { get; }
    internal static string Used_to_release_array_variables_and_deallocate_the_memory_used_for_their_elements { get; }
    internal static string Declares_a_user_defined_event { get; }
    internal static string Exits_a_Sub_procedure_and_transfers_execution_immediately_to_the_statement_following_the_call_to_the_Sub_procedure { get; }
    internal static string Raises_a_number_to_the_power_of_another_number { get; }
    internal static string Specifies_that_the_external_procedure_being_referenced_in_the_Declare_statement_is_a_Function { get; }
    internal static string Specifies_that_the_external_procedure_being_referenced_in_the_Declare_statement_is_a_Sub { get; }
    internal static string Specifies_that_one_or_more_declared_programming_elements_are_accessible_only_from_within_the_assembly_that_contains_their_declaration { get; }
    internal static string Specifies_a_collection_and_a_range_variable_to_use_in_a_query { get; }
    internal static string Declares_the_name_parameters_and_code_that_define_a_Function_procedure_that_is_a_procedure_that_returns_a_value_to_the_calling_code { get; }
    internal static string Constrains_a_generic_type_parameter_to_require_that_any_type_argument_passed_to_it_be_a_reference_type { get; }
    internal static string Specifies_a_constructor_constraint_on_a_generic_type_parameter { get; }
    internal static string Constrains_a_generic_type_parameter_to_require_that_any_type_argument_passed_to_it_be_a_value_type { get; }
    internal static string Declares_a_Get_property_procedure_that_is_used_to_return_the_current_value_of_a_property { get; }
    internal static string Compares_two_expressions_and_returns_True_if_the_first_is_greater_than_the_second_Otherwise_returns_False { get; }
    internal static string Compares_two_expressions_and_returns_True_if_the_first_is_greater_than_or_equal_to_the_second_Otherwise_returns_False { get; }
    internal static string Declares_that_a_procedure_handles_a_specified_event { get; }
    internal static string Indicates_that_a_class_or_structure_member_is_providing_the_implementation_for_a_member_defined_in_an_interface { get; }
    internal static string Specifies_one_or_more_interfaces_or_interface_members_that_must_be_implemented_in_the_class_or_structure_definition_in_which_the_Implements_statement_appears { get; }
    internal static string Imports_all_or_specified_elements_of_a_namespace_into_a_file { get; }
    internal static string Specifies_the_group_that_the_loop_variable_in_a_For_Each_statement_is_to_traverse { get; }
    internal static string Causes_the_current_class_or_interface_to_inherit_the_attributes_variables_properties_procedures_and_events_from_another_class_or_set_of_interfaces { get; }
    internal static string Specifies_the_group_that_the_range_variable_is_to_traverse_in_a_query { get; }
    internal static string Divides_two_numbers_and_returns_an_integer_result { get; }
    internal static string Declares_the_name_of_an_interface_and_the_definitions_of_the_members_of_the_interface { get; }
    internal static string Determines_whether_an_expression_is_false_If_instances_of_any_class_or_structure_will_be_used_in_an_OrElse_clause_you_must_define_IsFalse_on_that_class_or_structure { get; }
    internal static string Compares_two_object_reference_variables_and_returns_True_if_the_objects_are_equal_result_object1_Is_object2 { get; }
    internal static string Compares_two_object_reference_variables_and_returns_True_if_the_objects_are_not_equal_result_object1_IsNot_object2 { get; }
    internal static string Determines_whether_an_expression_is_true_If_instances_of_any_class_or_structure_will_be_used_in_an_OrElse_clause_you_must_define_IsTrue_on_that_class_or_structure { get; }
    internal static string Indicates_an_iterator_method_that_can_use_the_Yield_statement { get; }
    internal static string Defines_an_iterator_lambda_expression_that_can_use_the_Yield_statement_Iterator_Function_parameterList_As_IEnumerable_Of_T { get; }
    internal static string Performs_an_arithmetic_left_shift_on_a_bit_pattern { get; }
    internal static string Compares_two_expressions_and_returns_True_if_the_first_is_less_than_the_second_Otherwise_returns_False { get; }
    internal static string Compares_two_expressions_and_returns_True_if_the_first_is_less_than_or_equal_to_the_second_Otherwise_returns_False { get; }
    internal static string Introduces_a_clause_that_identifies_the_external_file_DLL_or_code_resource_containing_an_external_procedure { get; }
    internal static string Compares_a_string_against_a_pattern_Wildcards_available_include_to_match_1_character_and_to_match_0_or_more_characters_result_string_Like_pattern { get; }
    internal static string Returns_the_difference_between_two_numeric_expressions_or_the_negative_value_of_a_numeric_expression { get; }
    internal static string Divides_two_numbers_and_returns_only_the_remainder_number1_Mod_number2 { get; }
    internal static string Specifies_that_an_attribute_at_the_beginning_of_a_source_file_applies_to_the_entire_module_Otherwise_the_attribute_will_apply_only_to_an_individual_programming_element_such_as_a_class_or_property { get; }
    internal static string Multiplies_two_numbers_and_returns_the_product { get; }
    internal static string Specifies_that_a_class_can_be_used_only_as_a_base_class_and_that_you_cannot_create_an_object_directly_from_it { get; }
    internal static string Specifies_that_a_property_or_procedure_is_not_implemented_in_the_class_and_must_be_overridden_in_a_derived_class_before_it_can_be_used { get; }
    internal static string Declares_the_name_of_a_namespace_and_causes_the_source_code_following_the_declaration_to_be_compiled_within_that_namespace { get; }
    internal static string Indicates_that_a_conversion_operator_CType_converts_a_class_or_structure_to_a_type_that_might_not_be_able_to_hold_some_of_the_possible_values_of_the_original_class_or_structure { get; }
    internal static string Compares_two_expressions_and_returns_True_if_they_are_not_equal_Otherwise_returns_False { get; }
    internal static string Specifies_that_a_class_cannot_be_used_as_a_base_class { get; }
    internal static string Performs_logical_negation_on_a_Boolean_expression_or_bitwise_negation_on_a_numeric_expression_result_Not_expression { get; }
    internal static string Specifies_that_a_property_or_procedure_cannot_be_overridden_in_a_derived_class { get; }
    internal static string Identifies_a_type_parameter_on_a_generic_class_structure_interface_delegate_or_procedure { get; }
    internal static string Declares_the_operator_symbol_operands_and_code_that_define_an_operator_procedure_on_a_class_or_structure { get; }
    internal static string Specifies_that_a_procedure_argument_can_be_omitted_when_the_procedure_is_called { get; }
    internal static string Introduces_a_statement_that_specifies_a_compiler_option_that_applies_to_the_entire_source_file { get; }
    internal static string Performs_short_circuit_inclusive_logical_disjunction_on_two_expressions_Returns_True_if_either_operand_evaluates_to_True_If_the_first_expression_evaluates_to_True_the_second_expression_is_not_evaluated_result_expression1_OrElse_expression2 { get; }
    internal static string Performs_an_inclusive_logical_disjunction_on_two_Boolean_expressions_or_a_bitwise_disjunction_on_two_numeric_expressions_For_Boolean_expressions_returns_True_if_at_least_one_operand_evaluates_to_True_Both_expressions_are_always_evaluated_result_expression1_Or_expression2 { get; }
    internal static string Specifies_that_a_property_or_procedure_re_declares_one_or_more_existing_properties_or_procedures_with_the_same_name { get; }
    internal static string Specifies_that_a_property_or_procedure_can_be_overridden_by_an_identically_named_property_or_procedure_in_a_derived_class { get; }
    internal static string Specifies_that_a_property_or_procedure_overrides_an_identically_named_property_or_procedure_inherited_from_a_base_class { get; }
    internal static string Specifies_that_a_procedure_parameter_takes_an_optional_array_of_elements_of_the_specified_type { get; }
    internal static string Indicates_that_a_method_class_or_structure_declaration_is_a_partial_definition_of_the_method_class_or_structure { get; }
    internal static string Returns_the_sum_of_two_numbers_or_the_positive_value_of_a_numeric_expression { get; }
    internal static string Prevents_the_contents_of_an_array_from_being_cleared_when_the_dimensions_of_the_array_are_changed { get; }
    internal static string Specifies_that_one_or_more_declared_programming_elements_are_accessible_only_from_within_their_module_class_or_structure { get; }
    internal static string Declares_the_name_of_a_property_and_the_property_procedures_used_to_store_and_retrieve_the_value_of_the_property { get; }
    internal static string Specifies_that_one_or_more_declared_members_of_a_class_are_accessible_from_anywhere_in_the_same_assembly_their_own_classes_and_derived_classes { get; }
    internal static string Specifies_that_one_or_more_declared_programming_elements_are_accessible_only_from_within_their_own_class_or_from_a_derived_class { get; }
    internal static string Specifies_that_one_or_more_declared_programming_elements_have_no_access_restrictions { get; }
    internal static string Specifies_that_a_variable_or_property_can_be_read_but_not_written_to { get; }
    internal static string Reallocates_storage_space_for_an_array_variable { get; }
    internal static string Performs_an_arithmetic_right_shift_on_a_bit_pattern { get; }
    internal static string Declares_a_Set_property_procedure_that_is_used_to_assign_a_value_to_a_property { get; }
    internal static string Specifies_that_a_declared_programming_element_redeclares_and_hides_an_identically_named_element_in_a_base_class { get; }
    internal static string Specifies_that_one_or_more_declared_programming_elements_are_associated_with_all_instances_of_a_class_or_structure { get; }
    internal static string Specifies_that_one_or_more_declared_local_variables_are_to_remain_in_existence_and_retain_their_latest_values_after_the_procedure_in_which_they_are_declared_terminates { get; }
    internal static string Declares_the_name_of_a_structure_and_introduces_the_definition_of_the_variables_properties_events_and_procedures_that_make_up_the_structure { get; }
    internal static string Declares_the_name_parameters_and_code_that_define_a_Sub_procedure_that_is_a_procedure_that_does_not_return_a_value_to_the_calling_code { get; }
    internal static string Separates_the_beginning_and_ending_values_of_a_loop_counter_or_array_bounds_or_that_of_a_value_match_range { get; }
    internal static string Determines_the_run_time_type_of_an_object_reference_variable_and_compares_it_to_a_data_type_Returns_True_or_False_depending_on_whether_the_two_types_are_compatible_result_TypeOf_objectExpression_Is_typeName { get; }
    internal static string Used_in_a_Declare_statement_Specifies_that_Visual_Basic_should_marshal_all_strings_to_Unicode_values_in_a_call_into_an_external_procedure_and_should_look_up_the_procedure_without_modifying_its_name { get; }
    internal static string Indicates_that_a_conversion_operator_CType_converts_a_class_or_structure_to_a_type_that_can_hold_all_possible_values_of_the_original_class_or_structure { get; }
    internal static string Specifies_that_one_or_more_declared_member_variables_refer_to_an_instance_of_a_class_that_can_raise_events { get; }
    internal static string Specifies_that_a_property_can_be_written_to_but_not_read { get; }
    internal static string Performs_a_logical_exclusion_on_two_Boolean_expressions_or_a_bitwise_exclusion_on_two_numeric_expressions_For_Boolean_expressions_returns_True_if_exactly_one_of_the_expressions_evaluates_to_True_Both_expressions_are_always_evaluated_result_expression1_Xor_expression2 { get; }
    internal static string Applies_an_aggregation_function_such_as_Sum_Average_or_Count_to_a_sequence { get; }
    internal static string Specifies_the_sort_order_for_an_Order_By_clause_in_a_query_The_smallest_element_will_appear_first { get; }
    internal static string Sets_the_string_comparison_method_specified_in_Option_Compare_to_a_strict_binary_sort_order { get; }
    internal static string Specifies_the_element_keys_used_for_grouping_in_Group_By_or_sort_order_in_Order_By { get; }
    internal static string Transfers_execution_to_a_Function_Sub_or_dynamic_link_library_DLL_procedure_bracket_Call_bracket_procedureName_bracket_argumentList_bracket { get; }
    internal static string Introduces_the_statements_to_run_if_none_of_the_previous_cases_in_the_Select_Case_statement_returns_True { get; }
    internal static string Followed_by_a_comparison_operator_and_then_an_expression_Case_Is_introduces_the_statements_to_run_if_the_Select_Case_expression_combined_with_the_Case_Is_expression_evaluates_to_True { get; }
    internal static string Introduces_a_value_or_set_of_values_against_which_the_value_of_an_expression_in_a_Select_Case_statement_is_to_be_tested_Case_expression_expression1_To_expression2_bracket_Is_bracket_comparisonOperator_expression { get; }
    internal static string Introduces_a_statement_block_to_be_run_if_the_specified_exception_occurs_inside_a_Try_block { get; }
    internal static string Sets_the_default_comparison_method_to_use_when_comparing_string_data_When_set_to_Text_uses_a_text_sort_order_that_is_not_case_sensitive_When_set_to_Binary_uses_a_strict_binary_sort_order_Option_Compare_Binary_Text { get; }
    internal static string Defines_a_conditional_compiler_constant_Conditional_compiler_constants_are_always_private_to_the_file_in_which_they_appear_The_expressions_used_to_initialize_them_can_contain_only_conditional_compiler_constants_and_literals { get; }
    internal static string Transfers_execution_immediately_to_the_next_iteration_of_the_Do_loop { get; }
    internal static string Transfers_execution_immediately_to_the_next_iteration_of_the_For_loop { get; }
    internal static string Transfers_execution_immediately_to_the_next_iteration_of_the_loop_Can_be_used_in_a_Do_loop_a_For_loop_or_a_While_loop { get; }
    internal static string Transfers_execution_immediately_to_the_next_iteration_of_the_While_loop { get; }
    internal static string Specifies_the_sort_order_for_an_Order_By_clause_in_a_query_The_largest_element_will_appear_first { get; }
    internal static string Restricts_the_values_of_a_query_result_to_eliminate_duplicate_values { get; }
    internal static string Repeats_a_block_of_statements_while_a_Boolean_condition_is_true_or_until_the_condition_becomes_true_Do_Loop_While_Until_condition { get; }
    internal static string Repeats_a_block_of_statements_until_a_Boolean_condition_becomes_true_Do_Until_condition_Loop { get; }
    internal static string Repeats_a_block_of_statements_while_a_Boolean_condition_is_true_Do_While_condition_Loop { get; }
    internal static string Introduces_a_group_of_statements_in_an_SharpIf_statement_that_is_compiled_if_no_previous_condition_evaluates_to_True { get; }
    internal static string Introduces_a_condition_in_an_SharpIf_statement_that_is_tested_if_the_previous_conditional_test_evaluates_to_False { get; }
    internal static string Introduces_a_condition_in_an_If_statement_that_is_to_be_tested_if_the_previous_conditional_test_fails { get; }
    internal static string Introduces_a_group_of_statements_in_an_If_statement_that_is_executed_if_no_previous_condition_evaluates_to_True { get; }
    internal static string Terminates_the_definition_of_an_SharpIf_block { get; }
    internal static string Stops_execution_immediately { get; }
    internal static string Terminates_a_SharpRegion_block { get; }
    internal static string Specifies_the_relationship_between_element_keys_to_use_as_the_basis_of_a_join_operation { get; }
    internal static string Simulates_the_occurrence_of_an_error { get; }
    internal static string Exits_a_Do_loop_and_transfers_execution_immediately_to_the_statement_following_the_Loop_statement { get; }
    internal static string Exits_a_For_loop_and_transfers_execution_immediately_to_the_statement_following_the_Next_statement { get; }
    internal static string Exits_a_procedure_or_block_and_transfers_execution_immediately_to_the_statement_following_the_procedure_call_or_block_definition_Exit_Do_For_Function_Property_Select_Sub_Try_While { get; }
    internal static string Exits_a_Select_block_and_transfers_execution_immediately_to_the_statement_following_the_End_Select_statement { get; }
    internal static string Exits_a_Try_block_and_transfers_execution_immediately_to_the_statement_following_the_End_Try_statement { get; }
    internal static string Exits_a_While_loop_and_transfers_execution_immediately_to_the_statement_following_the_End_While_statement { get; }
    internal static string When_set_to_On_requires_explicit_declaration_of_all_variables_using_a_Dim_Private_Public_or_ReDim_statement_Option_Explicit_On_Off { get; }
    internal static string Represents_a_Boolean_value_that_fails_a_conditional_test { get; }
    internal static string Introduces_a_statement_block_to_be_run_before_exiting_a_Try_structure { get; }
    internal static string Introduces_a_loop_that_is_repeated_for_each_element_in_a_collection { get; }
    internal static string Introduces_a_loop_that_is_iterated_a_specified_number_of_times { get; }
    internal static string Identifies_a_list_of_values_as_a_collection_initializer { get; }
    internal static string Branches_unconditionally_to_a_specified_line_in_a_procedure { get; }
    internal static string Groups_elements_that_have_a_common_key { get; }
    internal static string Combines_the_elements_of_two_sequences_and_groups_the_results_The_join_operation_is_based_on_matching_keys { get; }
    internal static string Use_Group_to_specify_that_a_group_named_0_should_be_created { get; }
    internal static string Use_Group_to_specify_that_a_group_named_Group_should_be_created { get; }
    internal static string Conditionally_compiles_selected_blocks_of_code_depending_on_the_value_of_an_expression { get; }
    internal static string Conditionally_executes_a_group_of_statements_depending_on_the_value_of_an_expression { get; }
    internal static string When_set_to_On_allows_the_use_of_local_type_inference_in_declaring_variables_Option_Infer_On_Off { get; }
    internal static string Specifies_an_identifier_that_can_serve_as_a_reference_to_the_results_of_a_join_or_grouping_subexpression { get; }
    internal static string Combines_the_elements_of_two_sequences_The_join_operation_is_based_on_matching_keys { get; }
    internal static string Identifies_a_key_field_in_an_anonymous_type_definition { get; }
    internal static string Computes_a_value_for_each_item_in_the_query_and_assigns_the_value_to_a_new_range_variable { get; }
    internal static string Terminates_a_loop_that_is_introduced_with_a_Do_statement { get; }
    internal static string Repeats_a_block_of_statements_until_a_Boolean_condition_becomes_true_Do_Loop_Until_condition { get; }
    internal static string Repeats_a_block_of_statements_while_a_Boolean_condition_is_true_Do_Loop_While_condition { get; }
    internal static string Provides_a_way_to_refer_to_the_current_instance_of_a_class_or_structure_that_is_the_instance_in_which_the_code_is_running { get; }
    internal static string Provides_a_way_to_refer_to_the_base_class_of_the_current_class_instance_You_cannot_use_MyBase_to_call_MustOverride_base_methods { get; }
    internal static string Provides_a_way_to_refer_to_the_class_instance_members_as_originally_implemented_ignoring_any_derived_class_overrides { get; }
    internal static string Creates_a_new_object_instance { get; }
    internal static string Terminates_a_loop_that_iterates_through_the_values_of_a_loop_variable { get; }
    internal static string Represents_the_default_value_of_any_data_type { get; }
    internal static string Turns_a_compiler_option_off { get; }
    internal static string Enables_the_error_handling_routine_that_starts_at_the_line_specified_in_the_line_argument_The_specified_line_must_be_in_the_same_procedure_as_the_On_Error_statement_On_Error_GoTo_bracket_label_0_1_bracket { get; }
    internal static string When_a_run_time_error_occurs_execution_transfers_to_the_statement_following_the_statement_or_procedure_call_that_resulted_in_the_error { get; }
    internal static string Turns_a_compiler_option_on { get; }
    internal static string Specifies_the_element_keys_used_to_correlate_sequences_for_a_join_operation { get; }
    internal static string Specifies_the_sort_order_for_columns_in_a_query_Can_be_followed_by_either_the_Ascending_or_the_Descending_keyword_If_neither_is_specified_Ascending_is_used { get; }
    internal static string Specifies_the_statements_to_run_when_the_event_is_raised_by_the_RaiseEvent_statement_RaiseEvent_delegateSignature_End_RaiseEvent { get; }
    internal static string Triggers_an_event_declared_at_module_level_within_a_class_form_or_document_RaiseEvent_eventName_bracket_argumentList_bracket { get; }
    internal static string Collapses_and_hides_sections_of_code_in_Visual_Basic_files { get; }
    internal static string Returns_execution_to_the_code_that_called_the_Function_Sub_Get_Set_or_Operator_procedure_Return_or_Return_expression { get; }
    internal static string Runs_one_of_several_groups_of_statements_depending_on_the_value_of_an_expression { get; }
    internal static string Specifies_which_columns_to_include_in_the_result_of_a_query { get; }
    internal static string Skips_elements_up_to_a_specified_position_in_the_collection { get; }
    internal static string Specifies_how_much_to_increment_between_each_loop_iteration { get; }
    internal static string Suspends_program_execution { get; }
    internal static string When_set_to_On_restricts_implicit_data_type_conversions_to_only_widening_conversions_Option_Strict_On_Off { get; }
    internal static string Ensures_that_multiple_threads_do_not_execute_the_statement_block_at_the_same_time_SyncLock_object_End_Synclock { get; }
    internal static string Includes_elements_up_to_a_specified_position_in_the_collection { get; }
    internal static string Sets_the_string_comparison_method_specified_in_Option_Compare_to_a_text_sort_order_that_is_not_case_sensitive { get; }
    internal static string Introduces_a_statement_block_to_be_compiled_or_executed_if_a_tested_condition_is_true { get; }
    internal static string Throws_an_exception_within_a_procedure_so_that_you_can_handle_it_with_structured_or_unstructured_exception_handling_code { get; }
    internal static string Represents_a_Boolean_value_that_passes_a_conditional_test { get; }
    internal static string Provides_a_way_to_handle_some_or_all_possible_errors_that_might_occur_in_a_given_block_of_code_while_still_running_the_code_Try_bracket_Catch_bracket_Catch_Finally_End_Try { get; }
    internal static string A_Using_block_does_three_things_colon_it_creates_and_initializes_variables_in_the_resource_list_it_runs_the_code_in_the_block_and_it_disposes_of_the_variables_before_exiting_Resources_used_in_the_Using_block_must_implement_System_IDisposable_Using_resource1_bracket_resource2_bracket_End_Using { get; }
    internal static string Adds_a_conditional_test_to_a_Catch_statement_Exceptions_are_caught_by_that_Catch_statement_only_when_the_conditional_test_that_follows_the_When_keyword_evaluates_to_True { get; }
    internal static string Specifies_the_filtering_condition_for_a_range_variable_in_a_query { get; }
    internal static string Runs_a_series_of_statements_as_long_as_a_given_condition_is_true { get; }
    internal static string Specifies_a_condition_for_Skip_and_Take_operations_Elements_will_be_bypassed_or_included_as_long_as_the_condition_is_true { get; }
    internal static string Specifies_the_declaration_of_property_initializations_in_an_object_initializer_New_typeName_With_bracket_property_expression_bracket_bracket_bracket { get; }
    internal static string Runs_a_series_of_statements_that_refer_to_a_single_object_or_structure_With_object_End_With { get; }
    internal static string Produces_an_element_of_an_IEnumerable_or_IEnumerator { get; }
    internal static string Defines_an_asynchronous_lambda_expression_that_can_use_the_Await_operator_Can_be_used_wherever_a_delegate_type_is_expected_Async_Sub_Function_parameterList_expression { get; }
    internal static string Defines_a_lambda_expression_that_calculates_and_returns_a_single_value_Can_be_used_wherever_a_delegate_type_is_expected_Function_parameterList_expression { get; }
    internal static string Defines_a_lambda_expression_that_can_execute_statements_and_does_not_return_a_value_Can_be_used_wherever_a_delegate_type_is_expected_Sub_parameterList_statement { get; }
    internal static string Disables_reporting_of_specified_warnings_in_the_portion_of_the_source_file_below_the_current_line { get; }
    internal static string Enables_reporting_of_specified_warnings_in_the_portion_of_the_source_file_below_the_current_line { get; }
    internal static string Use_the_correct_control_variable { get; }
    internal static string NameOf_function { get; }
    internal static string Generate_narrowing_conversion_in_0 { get; }
    internal static string Generate_widening_conversion_in_0 { get; }
    internal static string Try_block { get; }
    internal static string Catch_clause { get; }
    internal static string Finally_clause { get; }
    internal static string Using_statement { get; }
    internal static string Using_block { get; }
    internal static string With_statement { get; }
    internal static string With_block { get; }
    internal static string SyncLock_statement { get; }
    internal static string SyncLock_block { get; }
    internal static string For_Each_statement { get; }
    internal static string For_Each_block { get; }
    internal static string On_Error_statement { get; }
    internal static string Resume_statement { get; }
    internal static string Yield_statement { get; }
    internal static string Await_expression { get; }
    internal static string Lambda { get; }
    internal static string Where_clause { get; }
    internal static string Select_clause { get; }
    internal static string From_clause { get; }
    internal static string Aggregate_clause { get; }
    internal static string Let_clause { get; }
    internal static string Join_clause { get; }
    internal static string Group_Join_clause { get; }
    internal static string Group_By_clause { get; }
    internal static string Function_aggregation { get; }
    internal static string Take_While_clause { get; }
    internal static string Skip_While_clause { get; }
    internal static string Ordering_clause { get; }
    internal static string Join_condition { get; }
    internal static string option_ { get; }
    internal static string import { get; }
    internal static string structure_ { get; }
    internal static string module_ { get; }
    internal static string WithEvents_field { get; }
    internal static string as_clause { get; }
    internal static string type_parameters { get; }
    internal static string parameters { get; }
    internal static string attributes { get; }
    internal static string Type_0_is_not_defined { get; }
    internal static string Add_Overloads { get; }
    internal static string Add_a_metadata_reference_to_specified_assembly_and_all_its_dependencies_e_g_Sharpr_myLib_dll { get; }
    internal static string Properties { get; }
    internal static string namespace_name { get; }
    internal static string Type_a_name_here_to_declare_a_namespace { get; }
    internal static string Type_a_name_here_to_declare_a_partial_class { get; }
    internal static string class_name { get; }
    internal static string interface_name { get; }
    internal static string module_name { get; }
    internal static string structure_name { get; }
    internal static string Type_a_name_here_to_declare_a_partial_interface { get; }
    internal static string Type_a_name_here_to_declare_a_partial_module { get; }
    internal static string Type_a_name_here_to_declare_a_partial_structure { get; }
    internal static string Event_add_handler_name { get; }
    internal static string Event_remove_handler_name { get; }
    internal static string Property_getter_name { get; }
    internal static string Property_setter_name { get; }
    internal static string Multiple_Types { get; }
    internal static string Convert_to_Select_Case { get; }
    internal static string Convert_to_For_Each { get; }
    internal static string Convert_to_For { get; }
    internal static string Add_missing_Imports { get; }
    internal static string Add_Shadows { get; }
    internal static string Introduce_Using_statement { get; }
    internal static string Organize_Imports { get; }
    internal static string Change_to_DirectCast { get; }
    internal static string Change_to_TryCast { get; }
    internal static string Remove_shared_keyword_from_module_member { get; }
    internal static string _0_Events { get; }
    internal static string Shared_constructor { get; }
    internal static string Apply_isnot_preferences { get; }
    internal static string Apply_object_creation_preferences { get; }
    internal static string Project_level_Imports { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo AutoPropertyValue);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Insert_0();
    internal static string get_Delete_the_0_statement1();
    internal static string get_Create_event_0_in_1();
    internal static string get_Insert_the_missing_End_Property_statement();
    internal static string get_Insert_the_missing_0();
    internal static string get_Conflict_s_detected();
    internal static string get_Invert_If();
    internal static string get_Add_Await();
    internal static string get_Add_Await_and_ConfigureAwaitFalse();
    internal static string get_Move_the_0_statement_to_line_1();
    internal static string get_Delete_the_0_statement2();
    internal static string get_Type_a_name_here_to_declare_a_new_field();
    internal static string get_Note_colon_Space_completion_is_disabled_to_avoid_potential_interference_To_insert_a_name_from_the_list_use_tab();
    internal static string get_new_field();
    internal static string get_Type_a_name_here_to_declare_a_parameter_If_no_preceding_keyword_is_used_ByVal_will_be_assumed_and_the_argument_will_be_passed_by_value();
    internal static string get_parameter_name();
    internal static string get_Type_a_new_name_for_the_column_followed_by_Otherwise_the_original_column_name_with_be_used();
    internal static string get_Note_colon_Use_tab_for_automatic_completion_space_completion_is_disabled_to_avoid_interfering_with_a_new_name();
    internal static string get_result_alias();
    internal static string get_Type_a_new_variable_name();
    internal static string get_Note_colon_Space_and_completion_are_disabled_to_avoid_potential_interference_To_insert_a_name_from_the_list_use_tab();
    internal static string get_new_resource();
    internal static string get_AddHandler_statement();
    internal static string get_RemoveHandler_statement();
    internal static string get__0_function();
    internal static string get_CType_function();
    internal static string get_DirectCast_function();
    internal static string get_TryCast_function();
    internal static string get_GetType_function();
    internal static string get_GetXmlNamespace_function();
    internal static string get_Mid_statement();
    internal static string get_Fix_Incorrect_Function_Return_Type();
    internal static string get_Simplify_name_0();
    internal static string get_Simplify_member_access_0();
    internal static string get_Remove_Me_qualification();
    internal static string get_can_t_determine_valid_range_of_statements_to_extract_out();
    internal static string get_Not_all_code_paths_return();
    internal static string get_contains_invalid_selection();
    internal static string get_the_selection_contains_syntactic_errors();
    internal static string get_Selection_can_t_be_crossed_over_preprocessors();
    internal static string get_Selection_can_t_contain_throw_without_enclosing_catch_block();
    internal static string get_Selection_can_t_be_parts_of_constant_initializer_expression();
    internal static string get_Argument_used_for_ByRef_parameter_can_t_be_extracted_out();
    internal static string get_all_static_local_usages_defined_in_the_selection_must_be_included_in_the_selection();
    internal static string get_Implicit_member_access_can_t_be_included_in_the_selection_without_containing_statement();
    internal static string get_Selection_must_be_part_of_executable_statements();
    internal static string get_next_statement_control_variable_doesn_t_have_matching_declaration_statement();
    internal static string get_Selection_doesn_t_contain_any_valid_node();
    internal static string get_no_valid_statement_range_to_extract_out();
    internal static string get_Deprecated();
    internal static string get_Extension();
    internal static string get_Awaitable();
    internal static string get_Awaitable_Extension();
    internal static string get_new_variable();
    internal static string get_Creates_a_delegate_procedure_instance_that_references_the_specified_procedure_AddressOf_procedureName();
    internal static string get_Indicates_that_an_external_procedure_has_another_name_in_its_DLL();
    internal static string get_Performs_a_short_circuit_logical_conjunction_on_two_expressions_Returns_True_if_both_operands_evaluate_to_True_If_the_first_expression_evaluates_to_False_the_second_is_not_evaluated_result_expression1_AndAlso_expression2();
    internal static string get_Performs_a_logical_conjunction_on_two_Boolean_expressions_or_a_bitwise_conjunction_on_two_numeric_expressions_For_Boolean_expressions_returns_True_if_both_operands_evaluate_to_True_Both_expressions_are_always_evaluated_result_expression1_And_expression2();
    internal static string get_Used_in_a_Declare_statement_The_Ansi_modifier_specifies_that_Visual_Basic_should_marshal_all_strings_to_ANSI_values_and_should_look_up_the_procedure_without_modifying_its_name_during_the_search_If_no_character_set_is_specified_ANSI_is_the_default();
    internal static string get_Specifies_a_data_type_in_a_declaration_statement();
    internal static string get_Specifies_that_an_attribute_at_the_beginning_of_a_source_file_applies_to_the_entire_assembly_Otherwise_the_attribute_will_apply_only_to_an_individual_programming_element_such_as_a_class_or_property();
    internal static string get_Indicates_an_asynchronous_method_that_can_use_the_Await_operator();
    internal static string get_Used_in_a_Declare_statement_The_Auto_modifier_specifies_that_Visual_Basic_should_marshal_strings_according_to_NET_Framework_rules_and_should_determine_the_base_character_set_of_the_run_time_platform_and_possibly_modify_the_external_procedure_name_if_the_initial_search_fails();
    internal static string get_Specifies_that_an_argument_is_passed_in_such_a_way_that_the_called_procedure_can_change_the_underlying_value_of_the_argument_in_the_calling_code();
    internal static string get_Specifies_that_an_argument_is_passed_in_such_a_way_that_the_called_procedure_or_property_cannot_change_the_underlying_value_of_the_argument_in_the_calling_code();
    internal static string get_Declares_the_name_of_a_class_and_introduces_the_definitions_of_the_variables_properties_and_methods_that_make_up_the_class();
    internal static string get_Generates_a_string_concatenation_of_two_expressions();
    internal static string get_Declares_and_defines_one_or_more_constants();
    internal static string get_Use_In_for_a_type_that_will_only_be_used_for_ByVal_arguments_to_functions();
    internal static string get_Use_Out_for_a_type_that_will_only_be_used_as_a_return_from_functions();
    internal static string get_Returns_the_result_of_explicitly_converting_an_expression_to_a_specified_data_type_object_structure_class_or_interface_CType_Object_As_Expression_Object_As_Type_As_Type();
    internal static string get_Specifies_that_an_event_has_additional_specialized_code_for_adding_handlers_removing_handlers_and_raising_events();
    internal static string get_Declares_a_reference_to_a_procedure_implemented_in_an_external_file();
    internal static string get_Identifies_a_property_as_the_default_property_of_its_class_structure_or_interface();
    internal static string get_Used_to_declare_a_delegate_A_delegate_is_a_reference_type_that_refers_to_a_shared_method_of_a_type_or_to_an_instance_method_of_an_object_Any_procedure_that_is_convertible_or_that_has_matching_parameter_types_and_return_type_may_be_used_to_create_an_instance_of_this_delegate_class();
    internal static string get_Declares_and_allocates_storage_space_for_one_or_more_variables_Dim_var_bracket_As_bracket_New_bracket_dataType_bracket_boundList_bracket_bracket_bracket_initializer_bracket_bracket_var2_bracket();
    internal static string get_Divides_two_numbers_and_returns_a_floating_point_result();
    internal static string get_Terminates_a_0_block();
    internal static string get_Terminates_an_0_block();
    internal static string get_Terminates_the_definition_of_a_0_statement();
    internal static string get_Terminates_the_definition_of_an_0_statement();
    internal static string get_Declares_an_enumeration_and_defines_the_values_of_its_members();
    internal static string get_Compares_two_expressions_and_returns_True_if_they_are_equal_Otherwise_returns_False();
    internal static string get_Used_to_release_array_variables_and_deallocate_the_memory_used_for_their_elements();
    internal static string get_Declares_a_user_defined_event();
    internal static string get_Exits_a_Sub_procedure_and_transfers_execution_immediately_to_the_statement_following_the_call_to_the_Sub_procedure();
    internal static string get_Raises_a_number_to_the_power_of_another_number();
    internal static string get_Specifies_that_the_external_procedure_being_referenced_in_the_Declare_statement_is_a_Function();
    internal static string get_Specifies_that_the_external_procedure_being_referenced_in_the_Declare_statement_is_a_Sub();
    internal static string get_Specifies_that_one_or_more_declared_programming_elements_are_accessible_only_from_within_the_assembly_that_contains_their_declaration();
    internal static string get_Specifies_a_collection_and_a_range_variable_to_use_in_a_query();
    internal static string get_Declares_the_name_parameters_and_code_that_define_a_Function_procedure_that_is_a_procedure_that_returns_a_value_to_the_calling_code();
    internal static string get_Constrains_a_generic_type_parameter_to_require_that_any_type_argument_passed_to_it_be_a_reference_type();
    internal static string get_Specifies_a_constructor_constraint_on_a_generic_type_parameter();
    internal static string get_Constrains_a_generic_type_parameter_to_require_that_any_type_argument_passed_to_it_be_a_value_type();
    internal static string get_Declares_a_Get_property_procedure_that_is_used_to_return_the_current_value_of_a_property();
    internal static string get_Compares_two_expressions_and_returns_True_if_the_first_is_greater_than_the_second_Otherwise_returns_False();
    internal static string get_Compares_two_expressions_and_returns_True_if_the_first_is_greater_than_or_equal_to_the_second_Otherwise_returns_False();
    internal static string get_Declares_that_a_procedure_handles_a_specified_event();
    internal static string get_Indicates_that_a_class_or_structure_member_is_providing_the_implementation_for_a_member_defined_in_an_interface();
    internal static string get_Specifies_one_or_more_interfaces_or_interface_members_that_must_be_implemented_in_the_class_or_structure_definition_in_which_the_Implements_statement_appears();
    internal static string get_Imports_all_or_specified_elements_of_a_namespace_into_a_file();
    internal static string get_Specifies_the_group_that_the_loop_variable_in_a_For_Each_statement_is_to_traverse();
    internal static string get_Causes_the_current_class_or_interface_to_inherit_the_attributes_variables_properties_procedures_and_events_from_another_class_or_set_of_interfaces();
    internal static string get_Specifies_the_group_that_the_range_variable_is_to_traverse_in_a_query();
    internal static string get_Divides_two_numbers_and_returns_an_integer_result();
    internal static string get_Declares_the_name_of_an_interface_and_the_definitions_of_the_members_of_the_interface();
    internal static string get_Determines_whether_an_expression_is_false_If_instances_of_any_class_or_structure_will_be_used_in_an_OrElse_clause_you_must_define_IsFalse_on_that_class_or_structure();
    internal static string get_Compares_two_object_reference_variables_and_returns_True_if_the_objects_are_equal_result_object1_Is_object2();
    internal static string get_Compares_two_object_reference_variables_and_returns_True_if_the_objects_are_not_equal_result_object1_IsNot_object2();
    internal static string get_Determines_whether_an_expression_is_true_If_instances_of_any_class_or_structure_will_be_used_in_an_OrElse_clause_you_must_define_IsTrue_on_that_class_or_structure();
    internal static string get_Indicates_an_iterator_method_that_can_use_the_Yield_statement();
    internal static string get_Defines_an_iterator_lambda_expression_that_can_use_the_Yield_statement_Iterator_Function_parameterList_As_IEnumerable_Of_T();
    internal static string get_Performs_an_arithmetic_left_shift_on_a_bit_pattern();
    internal static string get_Compares_two_expressions_and_returns_True_if_the_first_is_less_than_the_second_Otherwise_returns_False();
    internal static string get_Compares_two_expressions_and_returns_True_if_the_first_is_less_than_or_equal_to_the_second_Otherwise_returns_False();
    internal static string get_Introduces_a_clause_that_identifies_the_external_file_DLL_or_code_resource_containing_an_external_procedure();
    internal static string get_Compares_a_string_against_a_pattern_Wildcards_available_include_to_match_1_character_and_to_match_0_or_more_characters_result_string_Like_pattern();
    internal static string get_Returns_the_difference_between_two_numeric_expressions_or_the_negative_value_of_a_numeric_expression();
    internal static string get_Divides_two_numbers_and_returns_only_the_remainder_number1_Mod_number2();
    internal static string get_Specifies_that_an_attribute_at_the_beginning_of_a_source_file_applies_to_the_entire_module_Otherwise_the_attribute_will_apply_only_to_an_individual_programming_element_such_as_a_class_or_property();
    internal static string get_Multiplies_two_numbers_and_returns_the_product();
    internal static string get_Specifies_that_a_class_can_be_used_only_as_a_base_class_and_that_you_cannot_create_an_object_directly_from_it();
    internal static string get_Specifies_that_a_property_or_procedure_is_not_implemented_in_the_class_and_must_be_overridden_in_a_derived_class_before_it_can_be_used();
    internal static string get_Declares_the_name_of_a_namespace_and_causes_the_source_code_following_the_declaration_to_be_compiled_within_that_namespace();
    internal static string get_Indicates_that_a_conversion_operator_CType_converts_a_class_or_structure_to_a_type_that_might_not_be_able_to_hold_some_of_the_possible_values_of_the_original_class_or_structure();
    internal static string get_Compares_two_expressions_and_returns_True_if_they_are_not_equal_Otherwise_returns_False();
    internal static string get_Specifies_that_a_class_cannot_be_used_as_a_base_class();
    internal static string get_Performs_logical_negation_on_a_Boolean_expression_or_bitwise_negation_on_a_numeric_expression_result_Not_expression();
    internal static string get_Specifies_that_a_property_or_procedure_cannot_be_overridden_in_a_derived_class();
    internal static string get_Identifies_a_type_parameter_on_a_generic_class_structure_interface_delegate_or_procedure();
    internal static string get_Declares_the_operator_symbol_operands_and_code_that_define_an_operator_procedure_on_a_class_or_structure();
    internal static string get_Specifies_that_a_procedure_argument_can_be_omitted_when_the_procedure_is_called();
    internal static string get_Introduces_a_statement_that_specifies_a_compiler_option_that_applies_to_the_entire_source_file();
    internal static string get_Performs_short_circuit_inclusive_logical_disjunction_on_two_expressions_Returns_True_if_either_operand_evaluates_to_True_If_the_first_expression_evaluates_to_True_the_second_expression_is_not_evaluated_result_expression1_OrElse_expression2();
    internal static string get_Performs_an_inclusive_logical_disjunction_on_two_Boolean_expressions_or_a_bitwise_disjunction_on_two_numeric_expressions_For_Boolean_expressions_returns_True_if_at_least_one_operand_evaluates_to_True_Both_expressions_are_always_evaluated_result_expression1_Or_expression2();
    internal static string get_Specifies_that_a_property_or_procedure_re_declares_one_or_more_existing_properties_or_procedures_with_the_same_name();
    internal static string get_Specifies_that_a_property_or_procedure_can_be_overridden_by_an_identically_named_property_or_procedure_in_a_derived_class();
    internal static string get_Specifies_that_a_property_or_procedure_overrides_an_identically_named_property_or_procedure_inherited_from_a_base_class();
    internal static string get_Specifies_that_a_procedure_parameter_takes_an_optional_array_of_elements_of_the_specified_type();
    internal static string get_Indicates_that_a_method_class_or_structure_declaration_is_a_partial_definition_of_the_method_class_or_structure();
    internal static string get_Returns_the_sum_of_two_numbers_or_the_positive_value_of_a_numeric_expression();
    internal static string get_Prevents_the_contents_of_an_array_from_being_cleared_when_the_dimensions_of_the_array_are_changed();
    internal static string get_Specifies_that_one_or_more_declared_programming_elements_are_accessible_only_from_within_their_module_class_or_structure();
    internal static string get_Declares_the_name_of_a_property_and_the_property_procedures_used_to_store_and_retrieve_the_value_of_the_property();
    internal static string get_Specifies_that_one_or_more_declared_members_of_a_class_are_accessible_from_anywhere_in_the_same_assembly_their_own_classes_and_derived_classes();
    internal static string get_Specifies_that_one_or_more_declared_programming_elements_are_accessible_only_from_within_their_own_class_or_from_a_derived_class();
    internal static string get_Specifies_that_one_or_more_declared_programming_elements_have_no_access_restrictions();
    internal static string get_Specifies_that_a_variable_or_property_can_be_read_but_not_written_to();
    internal static string get_Reallocates_storage_space_for_an_array_variable();
    internal static string get_Performs_an_arithmetic_right_shift_on_a_bit_pattern();
    internal static string get_Declares_a_Set_property_procedure_that_is_used_to_assign_a_value_to_a_property();
    internal static string get_Specifies_that_a_declared_programming_element_redeclares_and_hides_an_identically_named_element_in_a_base_class();
    internal static string get_Specifies_that_one_or_more_declared_programming_elements_are_associated_with_all_instances_of_a_class_or_structure();
    internal static string get_Specifies_that_one_or_more_declared_local_variables_are_to_remain_in_existence_and_retain_their_latest_values_after_the_procedure_in_which_they_are_declared_terminates();
    internal static string get_Declares_the_name_of_a_structure_and_introduces_the_definition_of_the_variables_properties_events_and_procedures_that_make_up_the_structure();
    internal static string get_Declares_the_name_parameters_and_code_that_define_a_Sub_procedure_that_is_a_procedure_that_does_not_return_a_value_to_the_calling_code();
    internal static string get_Separates_the_beginning_and_ending_values_of_a_loop_counter_or_array_bounds_or_that_of_a_value_match_range();
    internal static string get_Determines_the_run_time_type_of_an_object_reference_variable_and_compares_it_to_a_data_type_Returns_True_or_False_depending_on_whether_the_two_types_are_compatible_result_TypeOf_objectExpression_Is_typeName();
    internal static string get_Used_in_a_Declare_statement_Specifies_that_Visual_Basic_should_marshal_all_strings_to_Unicode_values_in_a_call_into_an_external_procedure_and_should_look_up_the_procedure_without_modifying_its_name();
    internal static string get_Indicates_that_a_conversion_operator_CType_converts_a_class_or_structure_to_a_type_that_can_hold_all_possible_values_of_the_original_class_or_structure();
    internal static string get_Specifies_that_one_or_more_declared_member_variables_refer_to_an_instance_of_a_class_that_can_raise_events();
    internal static string get_Specifies_that_a_property_can_be_written_to_but_not_read();
    internal static string get_Performs_a_logical_exclusion_on_two_Boolean_expressions_or_a_bitwise_exclusion_on_two_numeric_expressions_For_Boolean_expressions_returns_True_if_exactly_one_of_the_expressions_evaluates_to_True_Both_expressions_are_always_evaluated_result_expression1_Xor_expression2();
    internal static string get_Applies_an_aggregation_function_such_as_Sum_Average_or_Count_to_a_sequence();
    internal static string get_Specifies_the_sort_order_for_an_Order_By_clause_in_a_query_The_smallest_element_will_appear_first();
    internal static string get_Sets_the_string_comparison_method_specified_in_Option_Compare_to_a_strict_binary_sort_order();
    internal static string get_Specifies_the_element_keys_used_for_grouping_in_Group_By_or_sort_order_in_Order_By();
    internal static string get_Transfers_execution_to_a_Function_Sub_or_dynamic_link_library_DLL_procedure_bracket_Call_bracket_procedureName_bracket_argumentList_bracket();
    internal static string get_Introduces_the_statements_to_run_if_none_of_the_previous_cases_in_the_Select_Case_statement_returns_True();
    internal static string get_Followed_by_a_comparison_operator_and_then_an_expression_Case_Is_introduces_the_statements_to_run_if_the_Select_Case_expression_combined_with_the_Case_Is_expression_evaluates_to_True();
    internal static string get_Introduces_a_value_or_set_of_values_against_which_the_value_of_an_expression_in_a_Select_Case_statement_is_to_be_tested_Case_expression_expression1_To_expression2_bracket_Is_bracket_comparisonOperator_expression();
    internal static string get_Introduces_a_statement_block_to_be_run_if_the_specified_exception_occurs_inside_a_Try_block();
    internal static string get_Sets_the_default_comparison_method_to_use_when_comparing_string_data_When_set_to_Text_uses_a_text_sort_order_that_is_not_case_sensitive_When_set_to_Binary_uses_a_strict_binary_sort_order_Option_Compare_Binary_Text();
    internal static string get_Defines_a_conditional_compiler_constant_Conditional_compiler_constants_are_always_private_to_the_file_in_which_they_appear_The_expressions_used_to_initialize_them_can_contain_only_conditional_compiler_constants_and_literals();
    internal static string get_Transfers_execution_immediately_to_the_next_iteration_of_the_Do_loop();
    internal static string get_Transfers_execution_immediately_to_the_next_iteration_of_the_For_loop();
    internal static string get_Transfers_execution_immediately_to_the_next_iteration_of_the_loop_Can_be_used_in_a_Do_loop_a_For_loop_or_a_While_loop();
    internal static string get_Transfers_execution_immediately_to_the_next_iteration_of_the_While_loop();
    internal static string get_Specifies_the_sort_order_for_an_Order_By_clause_in_a_query_The_largest_element_will_appear_first();
    internal static string get_Restricts_the_values_of_a_query_result_to_eliminate_duplicate_values();
    internal static string get_Repeats_a_block_of_statements_while_a_Boolean_condition_is_true_or_until_the_condition_becomes_true_Do_Loop_While_Until_condition();
    internal static string get_Repeats_a_block_of_statements_until_a_Boolean_condition_becomes_true_Do_Until_condition_Loop();
    internal static string get_Repeats_a_block_of_statements_while_a_Boolean_condition_is_true_Do_While_condition_Loop();
    internal static string get_Introduces_a_group_of_statements_in_an_SharpIf_statement_that_is_compiled_if_no_previous_condition_evaluates_to_True();
    internal static string get_Introduces_a_condition_in_an_SharpIf_statement_that_is_tested_if_the_previous_conditional_test_evaluates_to_False();
    internal static string get_Introduces_a_condition_in_an_If_statement_that_is_to_be_tested_if_the_previous_conditional_test_fails();
    internal static string get_Introduces_a_group_of_statements_in_an_If_statement_that_is_executed_if_no_previous_condition_evaluates_to_True();
    internal static string get_Terminates_the_definition_of_an_SharpIf_block();
    internal static string get_Stops_execution_immediately();
    internal static string get_Terminates_a_SharpRegion_block();
    internal static string get_Specifies_the_relationship_between_element_keys_to_use_as_the_basis_of_a_join_operation();
    internal static string get_Simulates_the_occurrence_of_an_error();
    internal static string get_Exits_a_Do_loop_and_transfers_execution_immediately_to_the_statement_following_the_Loop_statement();
    internal static string get_Exits_a_For_loop_and_transfers_execution_immediately_to_the_statement_following_the_Next_statement();
    internal static string get_Exits_a_procedure_or_block_and_transfers_execution_immediately_to_the_statement_following_the_procedure_call_or_block_definition_Exit_Do_For_Function_Property_Select_Sub_Try_While();
    internal static string get_Exits_a_Select_block_and_transfers_execution_immediately_to_the_statement_following_the_End_Select_statement();
    internal static string get_Exits_a_Try_block_and_transfers_execution_immediately_to_the_statement_following_the_End_Try_statement();
    internal static string get_Exits_a_While_loop_and_transfers_execution_immediately_to_the_statement_following_the_End_While_statement();
    internal static string get_When_set_to_On_requires_explicit_declaration_of_all_variables_using_a_Dim_Private_Public_or_ReDim_statement_Option_Explicit_On_Off();
    internal static string get_Represents_a_Boolean_value_that_fails_a_conditional_test();
    internal static string get_Introduces_a_statement_block_to_be_run_before_exiting_a_Try_structure();
    internal static string get_Introduces_a_loop_that_is_repeated_for_each_element_in_a_collection();
    internal static string get_Introduces_a_loop_that_is_iterated_a_specified_number_of_times();
    internal static string get_Identifies_a_list_of_values_as_a_collection_initializer();
    internal static string get_Branches_unconditionally_to_a_specified_line_in_a_procedure();
    internal static string get_Groups_elements_that_have_a_common_key();
    internal static string get_Combines_the_elements_of_two_sequences_and_groups_the_results_The_join_operation_is_based_on_matching_keys();
    internal static string get_Use_Group_to_specify_that_a_group_named_0_should_be_created();
    internal static string get_Use_Group_to_specify_that_a_group_named_Group_should_be_created();
    internal static string get_Conditionally_compiles_selected_blocks_of_code_depending_on_the_value_of_an_expression();
    internal static string get_Conditionally_executes_a_group_of_statements_depending_on_the_value_of_an_expression();
    internal static string get_When_set_to_On_allows_the_use_of_local_type_inference_in_declaring_variables_Option_Infer_On_Off();
    internal static string get_Specifies_an_identifier_that_can_serve_as_a_reference_to_the_results_of_a_join_or_grouping_subexpression();
    internal static string get_Combines_the_elements_of_two_sequences_The_join_operation_is_based_on_matching_keys();
    internal static string get_Identifies_a_key_field_in_an_anonymous_type_definition();
    internal static string get_Computes_a_value_for_each_item_in_the_query_and_assigns_the_value_to_a_new_range_variable();
    internal static string get_Terminates_a_loop_that_is_introduced_with_a_Do_statement();
    internal static string get_Repeats_a_block_of_statements_until_a_Boolean_condition_becomes_true_Do_Loop_Until_condition();
    internal static string get_Repeats_a_block_of_statements_while_a_Boolean_condition_is_true_Do_Loop_While_condition();
    internal static string get_Provides_a_way_to_refer_to_the_current_instance_of_a_class_or_structure_that_is_the_instance_in_which_the_code_is_running();
    internal static string get_Provides_a_way_to_refer_to_the_base_class_of_the_current_class_instance_You_cannot_use_MyBase_to_call_MustOverride_base_methods();
    internal static string get_Provides_a_way_to_refer_to_the_class_instance_members_as_originally_implemented_ignoring_any_derived_class_overrides();
    internal static string get_Creates_a_new_object_instance();
    internal static string get_Terminates_a_loop_that_iterates_through_the_values_of_a_loop_variable();
    internal static string get_Represents_the_default_value_of_any_data_type();
    internal static string get_Turns_a_compiler_option_off();
    internal static string get_Enables_the_error_handling_routine_that_starts_at_the_line_specified_in_the_line_argument_The_specified_line_must_be_in_the_same_procedure_as_the_On_Error_statement_On_Error_GoTo_bracket_label_0_1_bracket();
    internal static string get_When_a_run_time_error_occurs_execution_transfers_to_the_statement_following_the_statement_or_procedure_call_that_resulted_in_the_error();
    internal static string get_Turns_a_compiler_option_on();
    internal static string get_Specifies_the_element_keys_used_to_correlate_sequences_for_a_join_operation();
    internal static string get_Specifies_the_sort_order_for_columns_in_a_query_Can_be_followed_by_either_the_Ascending_or_the_Descending_keyword_If_neither_is_specified_Ascending_is_used();
    internal static string get_Specifies_the_statements_to_run_when_the_event_is_raised_by_the_RaiseEvent_statement_RaiseEvent_delegateSignature_End_RaiseEvent();
    internal static string get_Triggers_an_event_declared_at_module_level_within_a_class_form_or_document_RaiseEvent_eventName_bracket_argumentList_bracket();
    internal static string get_Collapses_and_hides_sections_of_code_in_Visual_Basic_files();
    internal static string get_Returns_execution_to_the_code_that_called_the_Function_Sub_Get_Set_or_Operator_procedure_Return_or_Return_expression();
    internal static string get_Runs_one_of_several_groups_of_statements_depending_on_the_value_of_an_expression();
    internal static string get_Specifies_which_columns_to_include_in_the_result_of_a_query();
    internal static string get_Skips_elements_up_to_a_specified_position_in_the_collection();
    internal static string get_Specifies_how_much_to_increment_between_each_loop_iteration();
    internal static string get_Suspends_program_execution();
    internal static string get_When_set_to_On_restricts_implicit_data_type_conversions_to_only_widening_conversions_Option_Strict_On_Off();
    internal static string get_Ensures_that_multiple_threads_do_not_execute_the_statement_block_at_the_same_time_SyncLock_object_End_Synclock();
    internal static string get_Includes_elements_up_to_a_specified_position_in_the_collection();
    internal static string get_Sets_the_string_comparison_method_specified_in_Option_Compare_to_a_text_sort_order_that_is_not_case_sensitive();
    internal static string get_Introduces_a_statement_block_to_be_compiled_or_executed_if_a_tested_condition_is_true();
    internal static string get_Throws_an_exception_within_a_procedure_so_that_you_can_handle_it_with_structured_or_unstructured_exception_handling_code();
    internal static string get_Represents_a_Boolean_value_that_passes_a_conditional_test();
    internal static string get_Provides_a_way_to_handle_some_or_all_possible_errors_that_might_occur_in_a_given_block_of_code_while_still_running_the_code_Try_bracket_Catch_bracket_Catch_Finally_End_Try();
    internal static string get_A_Using_block_does_three_things_colon_it_creates_and_initializes_variables_in_the_resource_list_it_runs_the_code_in_the_block_and_it_disposes_of_the_variables_before_exiting_Resources_used_in_the_Using_block_must_implement_System_IDisposable_Using_resource1_bracket_resource2_bracket_End_Using();
    internal static string get_Adds_a_conditional_test_to_a_Catch_statement_Exceptions_are_caught_by_that_Catch_statement_only_when_the_conditional_test_that_follows_the_When_keyword_evaluates_to_True();
    internal static string get_Specifies_the_filtering_condition_for_a_range_variable_in_a_query();
    internal static string get_Runs_a_series_of_statements_as_long_as_a_given_condition_is_true();
    internal static string get_Specifies_a_condition_for_Skip_and_Take_operations_Elements_will_be_bypassed_or_included_as_long_as_the_condition_is_true();
    internal static string get_Specifies_the_declaration_of_property_initializations_in_an_object_initializer_New_typeName_With_bracket_property_expression_bracket_bracket_bracket();
    internal static string get_Runs_a_series_of_statements_that_refer_to_a_single_object_or_structure_With_object_End_With();
    internal static string get_Produces_an_element_of_an_IEnumerable_or_IEnumerator();
    internal static string get_Defines_an_asynchronous_lambda_expression_that_can_use_the_Await_operator_Can_be_used_wherever_a_delegate_type_is_expected_Async_Sub_Function_parameterList_expression();
    internal static string get_Defines_a_lambda_expression_that_calculates_and_returns_a_single_value_Can_be_used_wherever_a_delegate_type_is_expected_Function_parameterList_expression();
    internal static string get_Defines_a_lambda_expression_that_can_execute_statements_and_does_not_return_a_value_Can_be_used_wherever_a_delegate_type_is_expected_Sub_parameterList_statement();
    internal static string get_Disables_reporting_of_specified_warnings_in_the_portion_of_the_source_file_below_the_current_line();
    internal static string get_Enables_reporting_of_specified_warnings_in_the_portion_of_the_source_file_below_the_current_line();
    internal static string get_Use_the_correct_control_variable();
    internal static string get_NameOf_function();
    internal static string get_Generate_narrowing_conversion_in_0();
    internal static string get_Generate_widening_conversion_in_0();
    internal static string get_Try_block();
    internal static string get_Catch_clause();
    internal static string get_Finally_clause();
    internal static string get_Using_statement();
    internal static string get_Using_block();
    internal static string get_With_statement();
    internal static string get_With_block();
    internal static string get_SyncLock_statement();
    internal static string get_SyncLock_block();
    internal static string get_For_Each_statement();
    internal static string get_For_Each_block();
    internal static string get_On_Error_statement();
    internal static string get_Resume_statement();
    internal static string get_Yield_statement();
    internal static string get_Await_expression();
    internal static string get_Lambda();
    internal static string get_Where_clause();
    internal static string get_Select_clause();
    internal static string get_From_clause();
    internal static string get_Aggregate_clause();
    internal static string get_Let_clause();
    internal static string get_Join_clause();
    internal static string get_Group_Join_clause();
    internal static string get_Group_By_clause();
    internal static string get_Function_aggregation();
    internal static string get_Take_While_clause();
    internal static string get_Skip_While_clause();
    internal static string get_Ordering_clause();
    internal static string get_Join_condition();
    internal static string get_option_();
    internal static string get_import();
    internal static string get_structure_();
    internal static string get_module_();
    internal static string get_WithEvents_field();
    internal static string get_as_clause();
    internal static string get_type_parameters();
    internal static string get_parameters();
    internal static string get_attributes();
    internal static string get_Type_0_is_not_defined();
    internal static string get_Add_Overloads();
    internal static string get_Add_a_metadata_reference_to_specified_assembly_and_all_its_dependencies_e_g_Sharpr_myLib_dll();
    internal static string get_Properties();
    internal static string get_namespace_name();
    internal static string get_Type_a_name_here_to_declare_a_namespace();
    internal static string get_Type_a_name_here_to_declare_a_partial_class();
    internal static string get_class_name();
    internal static string get_interface_name();
    internal static string get_module_name();
    internal static string get_structure_name();
    internal static string get_Type_a_name_here_to_declare_a_partial_interface();
    internal static string get_Type_a_name_here_to_declare_a_partial_module();
    internal static string get_Type_a_name_here_to_declare_a_partial_structure();
    internal static string get_Event_add_handler_name();
    internal static string get_Event_remove_handler_name();
    internal static string get_Property_getter_name();
    internal static string get_Property_setter_name();
    internal static string get_Multiple_Types();
    internal static string get_Convert_to_Select_Case();
    internal static string get_Convert_to_For_Each();
    internal static string get_Convert_to_For();
    internal static string get_Add_missing_Imports();
    internal static string get_Add_Shadows();
    internal static string get_Introduce_Using_statement();
    internal static string get_Organize_Imports();
    internal static string get_Change_to_DirectCast();
    internal static string get_Change_to_TryCast();
    internal static string get_Remove_shared_keyword_from_module_member();
    internal static string get__0_Events();
    internal static string get_Shared_constructor();
    internal static string get_Apply_isnot_preferences();
    internal static string get_Apply_object_creation_preferences();
    internal static string get_Project_level_Imports();
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicDeclarationComputer : DeclarationComputer {
    public static void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    public static void ComputeDeclarationsInNode(SemanticModel model, SyntaxNode node, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    private static bool InvalidLevel(Nullable`1<int> level);
    private static Nullable`1<int> DecrementLevel(Nullable`1<int> level);
    private static void ComputeDeclarationsCore(SemanticModel model, SyntaxNode node, Func`3<SyntaxNode, Nullable`1<int>, bool> shouldSkip, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, Nullable`1<int> levelsToCompute, CancellationToken cancellationToken);
    private static IEnumerable`1<SyntaxNode> GetAttributes(SyntaxList`1<AttributesStatementSyntax> attributeStatements);
    private static IEnumerable`1<SyntaxNode> GetPropertyStatementCodeBlocks(PropertyStatementSyntax propertyStatement);
    private static IEnumerable`1<SyntaxNode> GetMethodBaseCodeBlocks(MethodBaseSyntax methodBase);
    private static AsClauseSyntax GetAsClause(MethodBaseSyntax methodBase);
    private static IEnumerable`1<SyntaxNode> GetReturnTypeAttributes(AsClauseSyntax asClause);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.VisualBasicDeclarationComputer/VB$StateMachine_11_GetAttributes")]
private static IEnumerable`1<SyntaxNode> GetAttributes(SyntaxList`1<AttributeListSyntax> attributeLists);
    private static IEnumerable`1<SyntaxNode> GetParameterListInitializersAndAttributes(ParameterListSyntax parameterList);
    private static IEnumerable`1<SyntaxNode> GetParameterInitializersAndAttributes(ParameterSyntax parameter);
    private static SyntaxNode GetInitializerNode(VariableDeclaratorSyntax variableDeclarator);
    private static SyntaxNode GetAsNewClauseInitializer(AsClauseSyntax asClause);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SnippetFunctionService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSnippetFunctionService : SnippetFunctionService {
    public string SwitchCaseFormat { get; }
    public string SwitchDefaultCaseForm { get; }
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.VisualBasicSnippetFunctionService/VB$StateMachine_1_GetContainingClassNameAsync")]
public virtual Task`1<string> GetContainingClassNameAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.VisualBasicSnippetFunctionService/VB$StateMachine_2_GetEnumSymbolAsync")]
protected virtual Task`1<ITypeSymbol> GetEnumSymbolAsync(Document document, TextSpan switchExpressionSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.VisualBasicSnippetFunctionService/VB$StateMachine_3_GetDocumentWithEnumCaseAsync")]
protected virtual Task`1<ValueTuple`2<Document, TextSpan>> GetDocumentWithEnumCaseAsync(Document document, string fullyQualifiedTypeName, string firstEnumMemberName, TextSpan caseGenerationLocation, CancellationToken cancellationToken);
    public virtual string get_SwitchCaseFormat();
    public virtual string get_SwitchDefaultCaseForm();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Wrapping.BinaryExpression.VisualBasicBinaryExpressionWrapper : AbstractBinaryExpressionWrapper`1<BinaryExpressionSyntax> {
    protected virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Wrapping.ChainedExpression.VisualBasicChainedExpressionWrapper : AbstractChainedExpressionWrapper`2<NameSyntax, ArgumentListSyntax> {
    protected virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Wrapping.SeparatedSyntaxList.AbstractVisualBasicSeparatedSyntaxListWrapper`2 : AbstractSeparatedSyntaxListWrapper`2<TListSyntax, TListItemSyntax> {
    protected sealed virtual bool ShouldMoveOpenBraceToNewLine(SyntaxWrappingOptions options);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Wrapping.SeparatedSyntaxList.VisualBasicArgumentWrapper : AbstractVisualBasicSeparatedSyntaxListWrapper`2<ArgumentListSyntax, ArgumentSyntax> {
    [CompilerGeneratedAttribute]
private string _Align_wrapped_items;
    [CompilerGeneratedAttribute]
private string _Indent_all_items;
    [CompilerGeneratedAttribute]
private string _Indent_wrapped_items;
    [CompilerGeneratedAttribute]
private string _Unwrap_all_items;
    [CompilerGeneratedAttribute]
private string _Unwrap_and_indent_all_items;
    [CompilerGeneratedAttribute]
private string _Unwrap_list;
    [CompilerGeneratedAttribute]
private string _Wrap_every_item;
    [CompilerGeneratedAttribute]
private string _Wrap_long_list;
    [CompilerGeneratedAttribute]
private bool _Supports_UnwrapGroup_WrapFirst_IndentRest;
    [CompilerGeneratedAttribute]
private bool _Supports_WrapEveryGroup_UnwrapFirst;
    [CompilerGeneratedAttribute]
private bool _Supports_WrapLongGroup_UnwrapFirst;
    [CompilerGeneratedAttribute]
private bool _ShouldMoveCloseBraceToNewLine;
    protected string Align_wrapped_items { get; }
    protected string Indent_all_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    public bool Supports_UnwrapGroup_WrapFirst_IndentRest { get; }
    public bool Supports_WrapEveryGroup_UnwrapFirst { get; }
    public bool Supports_WrapLongGroup_UnwrapFirst { get; }
    protected bool ShouldMoveCloseBraceToNewLine { get; }
    [CompilerGeneratedAttribute]
protected virtual string get_Align_wrapped_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Indent_all_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Indent_wrapped_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Unwrap_all_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Unwrap_and_indent_all_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Unwrap_list();
    [CompilerGeneratedAttribute]
protected virtual string get_Wrap_every_item();
    [CompilerGeneratedAttribute]
protected virtual string get_Wrap_long_list();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_UnwrapGroup_WrapFirst_IndentRest();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_WrapEveryGroup_UnwrapFirst();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_WrapLongGroup_UnwrapFirst();
    [CompilerGeneratedAttribute]
protected virtual bool get_ShouldMoveCloseBraceToNewLine();
    protected virtual SyntaxToken FirstToken(ArgumentListSyntax listSyntax);
    protected virtual SyntaxToken LastToken(ArgumentListSyntax listSyntax);
    protected virtual SeparatedSyntaxList`1<ArgumentSyntax> GetListItems(ArgumentListSyntax listSyntax);
    protected virtual ArgumentListSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, bool containsSyntaxError, ArgumentListSyntax listSyntax);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Wrapping.SeparatedSyntaxList.VisualBasicCollectionCreationExpressionWrapper : AbstractVisualBasicSeparatedSyntaxListWrapper`2<CollectionInitializerSyntax, ExpressionSyntax> {
    [CompilerGeneratedAttribute]
private string _Indent_all_items;
    [CompilerGeneratedAttribute]
private string _Unwrap_all_items;
    [CompilerGeneratedAttribute]
private string _Unwrap_list;
    [CompilerGeneratedAttribute]
private string _Wrap_every_item;
    [CompilerGeneratedAttribute]
private string _Wrap_long_list;
    [CompilerGeneratedAttribute]
private bool _Supports_UnwrapGroup_WrapFirst_IndentRest;
    [CompilerGeneratedAttribute]
private bool _Supports_WrapEveryGroup_UnwrapFirst;
    [CompilerGeneratedAttribute]
private bool _Supports_WrapLongGroup_UnwrapFirst;
    [CompilerGeneratedAttribute]
private bool _ShouldMoveCloseBraceToNewLine;
    protected string Indent_all_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    public bool Supports_UnwrapGroup_WrapFirst_IndentRest { get; }
    public bool Supports_WrapEveryGroup_UnwrapFirst { get; }
    public bool Supports_WrapLongGroup_UnwrapFirst { get; }
    protected string Align_wrapped_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected bool ShouldMoveCloseBraceToNewLine { get; }
    [CompilerGeneratedAttribute]
protected virtual string get_Indent_all_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Unwrap_all_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Unwrap_list();
    [CompilerGeneratedAttribute]
protected virtual string get_Wrap_every_item();
    [CompilerGeneratedAttribute]
protected virtual string get_Wrap_long_list();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_UnwrapGroup_WrapFirst_IndentRest();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_WrapEveryGroup_UnwrapFirst();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_WrapLongGroup_UnwrapFirst();
    protected virtual string get_Align_wrapped_items();
    protected virtual string get_Indent_wrapped_items();
    protected virtual string get_Unwrap_and_indent_all_items();
    [CompilerGeneratedAttribute]
protected virtual bool get_ShouldMoveCloseBraceToNewLine();
    protected virtual SyntaxToken FirstToken(CollectionInitializerSyntax listSyntax);
    protected virtual SyntaxToken LastToken(CollectionInitializerSyntax listSyntax);
    protected virtual SeparatedSyntaxList`1<ExpressionSyntax> GetListItems(CollectionInitializerSyntax listSyntax);
    protected virtual CollectionInitializerSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, bool containsSyntaxError, CollectionInitializerSyntax listSyntax);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Wrapping.SeparatedSyntaxList.VisualBasicParameterWrapper : AbstractVisualBasicSeparatedSyntaxListWrapper`2<ParameterListSyntax, ParameterSyntax> {
    [CompilerGeneratedAttribute]
private string _Align_wrapped_items;
    [CompilerGeneratedAttribute]
private string _Indent_all_items;
    [CompilerGeneratedAttribute]
private string _Indent_wrapped_items;
    [CompilerGeneratedAttribute]
private string _Unwrap_all_items;
    [CompilerGeneratedAttribute]
private string _Unwrap_and_indent_all_items;
    [CompilerGeneratedAttribute]
private string _Unwrap_list;
    [CompilerGeneratedAttribute]
private string _Wrap_every_item;
    [CompilerGeneratedAttribute]
private string _Wrap_long_list;
    [CompilerGeneratedAttribute]
private bool _Supports_UnwrapGroup_WrapFirst_IndentRest;
    [CompilerGeneratedAttribute]
private bool _Supports_WrapEveryGroup_UnwrapFirst;
    [CompilerGeneratedAttribute]
private bool _Supports_WrapLongGroup_UnwrapFirst;
    [CompilerGeneratedAttribute]
private bool _ShouldMoveCloseBraceToNewLine;
    protected string Align_wrapped_items { get; }
    protected string Indent_all_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    public bool Supports_UnwrapGroup_WrapFirst_IndentRest { get; }
    public bool Supports_WrapEveryGroup_UnwrapFirst { get; }
    public bool Supports_WrapLongGroup_UnwrapFirst { get; }
    protected bool ShouldMoveCloseBraceToNewLine { get; }
    [CompilerGeneratedAttribute]
protected virtual string get_Align_wrapped_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Indent_all_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Indent_wrapped_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Unwrap_all_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Unwrap_and_indent_all_items();
    [CompilerGeneratedAttribute]
protected virtual string get_Unwrap_list();
    [CompilerGeneratedAttribute]
protected virtual string get_Wrap_every_item();
    [CompilerGeneratedAttribute]
protected virtual string get_Wrap_long_list();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_UnwrapGroup_WrapFirst_IndentRest();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_WrapEveryGroup_UnwrapFirst();
    [CompilerGeneratedAttribute]
public virtual bool get_Supports_WrapLongGroup_UnwrapFirst();
    [CompilerGeneratedAttribute]
protected virtual bool get_ShouldMoveCloseBraceToNewLine();
    protected virtual SyntaxToken FirstToken(ParameterListSyntax listSyntax);
    protected virtual SyntaxToken LastToken(ParameterListSyntax listSyntax);
    protected virtual SeparatedSyntaxList`1<ParameterSyntax> GetListItems(ParameterListSyntax listSyntax);
    protected virtual ParameterListSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, bool containsSyntaxError, ParameterListSyntax listSyntax);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Wrapping.VisualBasicSyntaxWrappingOptions : SyntaxWrappingOptions {
    public VisualBasicSyntaxWrappingOptions(VisualBasicSyntaxFormattingOptions formattingOptions, OperatorPlacementWhenWrappingPreference operatorPlacement);
    public static VisualBasicSyntaxWrappingOptions Create(IOptionsReader options, CodeActionOptions fallbackOptions);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Wrapping.VisualBasicWrappingCodeRefactoringProvider : AbstractWrappingCodeRefactoringProvider {
    private static ImmutableArray`1<ISyntaxWrapper> s_wrappers;
    private static VisualBasicWrappingCodeRefactoringProvider();
    protected virtual SyntaxWrappingOptions GetWrappingOptions(IOptionsReader options, CodeActionOptions ideOptions);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.Conversions : object {
    private static object GetEnumValue(object Value);
    public static int ToInteger(string Value);
    public static int ToInteger(object Value);
    private static NumberFormatInfo GetNormalizedNumberFormat(NumberFormatInfo InNumberFormat);
    private static double ParseDouble(string Value);
    public static string ToString(char Value);
    internal static CultureInfo GetCultureInfo();
    internal static string ToHalfwidthNumbers(string s, CultureInfo culture);
    internal static bool IsHexOrOctValue(string Value, Int64& i64Value);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.EmbeddedOperators : object {
    public static int CompareString(string Left, string Right, bool TextCompare);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.ProjectData : object {
    public static void SetProjectError(Exception ex);
    public static void ClearProjectError();
}
[Embedded]
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute : Attribute {
}
[Embedded]
[AttributeUsageAttribute("7")]
[EditorBrowsableAttribute("1")]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualBasic.Embedded : Attribute {
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_0`3 : MulticastDelegate {
    public VB$AnonymousDelegate_0`3(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(TArg0 oldNode, TArg1 newNode, AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual TResult EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual TResult Invoke(TArg0 oldNode, TArg1 newNode);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_1`2 : MulticastDelegate {
    public VB$AnonymousDelegate_1`2(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(TArg0 forEachStatement, AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual TResult EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual TResult Invoke(TArg0 forEachStatement);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_2`1 : MulticastDelegate {
    public VB$AnonymousDelegate_2`1(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(TArg0 parts, AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual void EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual void Invoke(TArg0 parts);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_3`2 : MulticastDelegate {
    public VB$AnonymousDelegate_3`2(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(TArg0 node, AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual TResult EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual TResult Invoke(TArg0 node);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_4`2 : MulticastDelegate {
    public VB$AnonymousDelegate_4`2(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(TArg0 n, AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual TResult EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual TResult Invoke(TArg0 n);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_5`1 : MulticastDelegate {
    public VB$AnonymousDelegate_5`1(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual TResult EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual TResult Invoke();
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_6`2 : MulticastDelegate {
    public VB$AnonymousDelegate_6`2(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(TArg0 t, AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual TResult EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual TResult Invoke(TArg0 t);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("<generated method>")]
internal class VB$AnonymousDelegate_7`1 : MulticastDelegate {
    public VB$AnonymousDelegate_7`1(object TargetObject, IntPtr TargetMethod);
    public virtual IAsyncResult BeginInvoke(TArg0 elseIfBlock, AsyncCallback DelegateCallback, object DelegateAsyncState);
    public virtual void EndInvoke(IAsyncResult DelegateAsyncResult);
    public virtual void Invoke(TArg0 elseIfBlock);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("interface={interface}, members={members}")]
internal class VB$AnonymousType_0`2 : object {
    private T0 $interface;
    private T1 $members;
    public T0 interface { get; public set; }
    public T1 members { get; public set; }
    public VB$AnonymousType_0`2(T0 interface, T1 members);
    public T0 get_interface();
    public void set_interface(T0 Value);
    public T1 get_members();
    public void set_members(T1 Value);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("Begin={Begin}, Statements={Statements}")]
internal class VB$AnonymousType_1`2 : object {
    private T0 $Begin;
    private T1 $Statements;
    public T0 Begin { get; public set; }
    public T1 Statements { get; public set; }
    public VB$AnonymousType_1`2(T0 Begin, T1 Statements);
    public T0 get_Begin();
    public void set_Begin(T0 Value);
    public T1 get_Statements();
    public void set_Statements(T1 Value);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("Condition={Condition}, Statements={Statements}")]
internal class VB$AnonymousType_2`2 : object {
    private T0 $Condition;
    private T1 $Statements;
    public T0 Condition { get; public set; }
    public T1 Statements { get; public set; }
    public VB$AnonymousType_2`2(T0 Condition, T1 Statements);
    public T0 get_Condition();
    public void set_Condition(T0 Value);
    public T1 get_Statements();
    public void set_Statements(T1 Value);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("SubOrFunctionHeader={SubOrFunctionHeader}, Body={Body}")]
internal class VB$AnonymousType_3`2 : object {
    private T0 $SubOrFunctionHeader;
    private T1 $Body;
    public T0 SubOrFunctionHeader { get; public set; }
    public T1 Body { get; public set; }
    public VB$AnonymousType_3`2(T0 SubOrFunctionHeader, T1 Body);
    public T0 get_SubOrFunctionHeader();
    public void set_SubOrFunctionHeader(T0 Value);
    public T1 get_Body();
    public void set_Body(T1 Value);
    public virtual string ToString();
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("root={root}, node={node}")]
internal class VB$AnonymousType_4`2 : object {
    private T0 $root;
    private T1 $node;
    public T0 root { get; }
    public T1 node { get; }
    public VB$AnonymousType_4`2(T0 root, T1 node);
    public T0 get_root();
    public T1 get_node();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_4`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("$VB$It={$VB$It}, identifier={identifier}")]
internal class VB$AnonymousType_5`2 : object {
    private T0 $$VB$It;
    private T1 $identifier;
    public T0 $VB$It { get; }
    public T1 identifier { get; }
    public VB$AnonymousType_5`2(T0 $VB$It, T1 identifier);
    public T0 get_$VB$It();
    public T1 get_identifier();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_5`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[ExportCodeRefactoringProviderAttribute("Visual Basic", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class VisualBasicAddMissingImportsRefactoringProvider : AbstractAddMissingImportsRefactoringProvider {
    [CompilerGeneratedAttribute]
private string _CodeActionTitle;
    protected string CodeActionTitle { get; }
    [CompilerGeneratedAttribute]
protected virtual string get_CodeActionTitle();
}
internal class VisualBasicAnalyzersResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo _Culture;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Imports_statement_is_unnecessary { get; }
    internal static string Use_Is_Nothing_check { get; }
    internal static string Use_IsNot_Nothing_check { get; }
    internal static string If_statement_can_be_simplified { get; }
    internal static string Remove_ByVal { get; }
    internal static string GetType_can_be_converted_to_NameOf { get; }
    internal static string Use_IsNot_expression { get; }
    internal static string Object_creation_can_be_simplified { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo AutoPropertyValue);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Imports_statement_is_unnecessary();
    internal static string get_Use_Is_Nothing_check();
    internal static string get_Use_IsNot_Nothing_check();
    internal static string get_If_statement_can_be_simplified();
    internal static string get_Remove_ByVal();
    internal static string get_GetType_can_be_converted_to_NameOf();
    internal static string get_Use_IsNot_expression();
    internal static string get_Object_creation_can_be_simplified();
}
internal class VisualBasicCodeFixesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo _Culture;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Remove_unnecessary_imports { get; }
    internal static string Add_Me { get; }
    internal static string Convert_GetType_to_NameOf { get; }
    internal static string Simplify_object_creation { get; }
    internal static string Add_Obsolete { get; }
    internal static string Convert_0_to_Iterator { get; }
    internal static string Make_0_inheritable { get; }
    internal static string Replace_Return_with_Yield { get; }
    internal static string Make_0_an_Async_Function { get; }
    internal static string Make_Async_Function { get; }
    internal static string Make_Async_Sub { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo AutoPropertyValue);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Remove_unnecessary_imports();
    internal static string get_Add_Me();
    internal static string get_Convert_GetType_to_NameOf();
    internal static string get_Simplify_object_creation();
    internal static string get_Add_Obsolete();
    internal static string get_Convert_0_to_Iterator();
    internal static string get_Make_0_inheritable();
    internal static string get_Replace_Return_with_Yield();
    internal static string get_Make_0_an_Async_Function();
    internal static string get_Make_Async_Function();
    internal static string get_Make_Async_Sub();
}
