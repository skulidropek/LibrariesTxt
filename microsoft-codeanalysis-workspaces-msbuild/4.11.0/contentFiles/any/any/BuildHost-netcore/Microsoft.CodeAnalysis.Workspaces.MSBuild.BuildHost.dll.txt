[NullableContextAttribute("1")]
[NullableAttribute("0")]
[NonCopyableAttribute]
internal class FixedSizeArrayBuilder`1 : ValueType {
    private T[] _values;
    private int _index;
    public FixedSizeArrayBuilder`1(int capacity);
    public void Add(T value);
    public void AddRange(ImmutableArray`1<T> values);
    public void AddRange(List`1<T> values);
    public void AddRange(HashSet`1<T> values);
    public void AddRange(ArrayBuilder`1<T> values);
    public void AddRange(IEnumerable`1<T> values);
    [IsReadOnlyAttribute]
public void Sort();
    [IsReadOnlyAttribute]
public void Sort(IComparer`1<T> comparer);
    public ImmutableArray`1<T> MoveToImmutable();
    public T[] MoveToArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`3<T, A, bool> predicate, A arg);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`3<T, A, bool> predicate, A arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArrayWithIndex(ArrayBuilder`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static void AddOptional(ArrayBuilder`1<T> builder, T item);
    [ExtensionAttribute]
public static void Push(ArrayBuilder`1<T> builder, T e);
    [ExtensionAttribute]
public static T Pop(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static bool TryPop(ArrayBuilder`1<T> builder, T& result);
    [ExtensionAttribute]
public static T Peek(ArrayBuilder`1<T> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableOrEmptyAndFree(ArrayBuilder`1<T> builder);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, Nullable`1<T> value);
    [ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, T value);
    [ExtensionAttribute]
public static void FreeAll(ArrayBuilder`1<T> builder, Func`2<T, ArrayBuilder`1<T>> getNested);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CaseInsensitiveComparison : object {
    private static TextInfo s_unicodeCultureTextInfo;
    private static OneToOneUnicodeComparer s_comparer;
    public static StringComparer Comparer { get; }
    private static CaseInsensitiveComparison();
    private static CultureInfo GetUnicodeCulture();
    public static char ToLower(char c);
    private static char ToLowerNonAscii(char c);
    public static StringComparer get_Comparer();
    public static bool Equals(string left, string right);
    [NullableContextAttribute("0")]
public static bool Equals(ReadOnlySpan`1<char> left, ReadOnlySpan`1<char> right);
    public static bool EndsWith(string value, string possibleEnd);
    public static bool StartsWith(string value, string possibleStart);
    public static int Compare(string left, string right);
    [NullableContextAttribute("0")]
public static int Compare(ReadOnlySpan`1<char> left, ReadOnlySpan`1<char> right);
    public static int GetHashCode(string value);
    [NullableContextAttribute("2")]
public static string ToLower(string value);
    public static void ToLower(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary : object {
    public static ImmutableSegmentedDictionary`2<TKey, TValue> Create();
    public static ImmutableSegmentedDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(Builder<TKey, TValue> builder);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TSource> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TSource> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedDictionary`2<TKey, TValue> Empty;
    private SegmentedDictionary`2<TKey, TValue> _dictionary;
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsDefault { get; }
    public bool IsDefaultOrEmpty { get; }
    [NullableAttribute("0")]
public KeyCollection<TKey, TValue> Keys { get; }
    [NullableAttribute("0")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ImmutableSegmentedDictionary`2(SegmentedDictionary`2<TKey, TValue> dictionary);
    private static ImmutableSegmentedDictionary`2();
    public IEqualityComparer`1<TKey> get_KeyComparer();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public bool get_IsDefault();
    public bool get_IsDefaultOrEmpty();
    [NullableContextAttribute("0")]
public KeyCollection<TKey, TValue> get_Keys();
    [NullableContextAttribute("0")]
public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public static bool op_Equality(ImmutableSegmentedDictionary`2<TKey, TValue> left, ImmutableSegmentedDictionary`2<TKey, TValue> right);
    public static bool op_Inequality(ImmutableSegmentedDictionary`2<TKey, TValue> left, ImmutableSegmentedDictionary`2<TKey, TValue> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> left, Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> left, Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> right);
    public ImmutableSegmentedDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableSegmentedDictionary`2<TKey, TValue> Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    public ImmutableSegmentedDictionary`2<TKey, TValue> Remove(TKey key);
    public ImmutableSegmentedDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableSegmentedDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> WithComparer(IEqualityComparer`1<TKey> keyComparer);
    public Builder<TKey, TValue> ToBuilder();
    [NullableContextAttribute("0")]
private ValueBuilder<TKey, TValue> ToValueBuilder();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedDictionary`2<TKey, TValue> other);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private static bool TryCastToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, ImmutableSegmentedDictionary`2& other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet : object {
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> Create();
    public static ImmutableSegmentedHashSet`1<T> Create(T item);
    public static ImmutableSegmentedHashSet`1<T> Create(T[] items);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T item);
    public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T[] items);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableSegmentedHashSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableSegmentedHashSet`1<T> CreateRange(IEqualityComparer`1<T> equalityComparer, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> equalityComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(Builder<TSource> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedHashSet`1<T> Empty;
    private SegmentedHashSet`1<T> _set;
    public IEqualityComparer`1<T> KeyComparer { get; }
    public int Count { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ImmutableSegmentedHashSet`1(SegmentedHashSet`1<T> set);
    private static ImmutableSegmentedHashSet`1();
    public IEqualityComparer`1<T> get_KeyComparer();
    public sealed virtual int get_Count();
    public bool get_IsDefault();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public static bool op_Equality(ImmutableSegmentedHashSet`1<T> left, ImmutableSegmentedHashSet`1<T> right);
    public static bool op_Inequality(ImmutableSegmentedHashSet`1<T> left, ImmutableSegmentedHashSet`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedHashSet`1<T>> left, Nullable`1<ImmutableSegmentedHashSet`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedHashSet`1<T>> left, Nullable`1<ImmutableSegmentedHashSet`1<T>> right);
    public ImmutableSegmentedHashSet`1<T> Add(T value);
    public ImmutableSegmentedHashSet`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableSegmentedHashSet`1<T> Except(IEnumerable`1<T> other);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public ImmutableSegmentedHashSet`1<T> Intersect(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public ImmutableSegmentedHashSet`1<T> Remove(T value);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public ImmutableSegmentedHashSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableSegmentedHashSet`1<T> Union(IEnumerable`1<T> other);
    public Builder<T> ToBuilder();
    [NullableContextAttribute("0")]
private ValueBuilder<T> ToValueBuilder();
    public ImmutableSegmentedHashSet`1<T> WithComparer(IEqualityComparer`1<T> equalityComparer);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedHashSet`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList : object {
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> Create();
    public static ImmutableSegmentedList`1<T> Create(T item);
    public static ImmutableSegmentedList`1<T> Create(T[] items);
    public static Builder<T> CreateBuilder();
    public static ImmutableSegmentedList`1<T> CreateRange(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableSegmentedList`1<T> ToImmutableSegmentedList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableSegmentedList`1<T> ToImmutableSegmentedList(Builder<T> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedList`1<T> Empty;
    private SegmentedList`1<T> _list;
    public int Count { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private ImmutableSegmentedList`1(SegmentedList`1<T> list);
    private static ImmutableSegmentedList`1();
    public sealed virtual int get_Count();
    public bool get_IsDefault();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public static bool op_Equality(ImmutableSegmentedList`1<T> left, ImmutableSegmentedList`1<T> right);
    public static bool op_Inequality(ImmutableSegmentedList`1<T> left, ImmutableSegmentedList`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedList`1<T>> left, Nullable`1<ImmutableSegmentedList`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedList`1<T>> left, Nullable`1<ImmutableSegmentedList`1<T>> right);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public ImmutableSegmentedList`1<T> Add(T value);
    public ImmutableSegmentedList`1<T> AddRange(IEnumerable`1<T> items);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public ImmutableSegmentedList`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableSegmentedList`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public ImmutableSegmentedList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public ImmutableSegmentedList`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T value);
    public sealed virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Insert(int index, T item);
    public ImmutableSegmentedList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public sealed virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Remove(T value);
    public ImmutableSegmentedList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableSegmentedList`1<T> RemoveAt(int index);
    public ImmutableSegmentedList`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableSegmentedList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> RemoveRange(int index, int count);
    public ImmutableSegmentedList`1<T> Replace(T oldValue, T newValue);
    public ImmutableSegmentedList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Reverse();
    public ImmutableSegmentedList`1<T> Reverse(int index, int count);
    public ImmutableSegmentedList`1<T> SetItem(int index, T value);
    public ImmutableSegmentedList`1<T> Sort();
    public ImmutableSegmentedList`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableSegmentedList`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableSegmentedList`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    public Builder<T> ToBuilder();
    [NullableContextAttribute("0")]
private ValueBuilder<T> ToValueBuilder();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedList`1<T> other);
    public bool TrueForAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T element);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class Microsoft.CodeAnalysis.Collections.Internal.BitHelper : ValueType {
    private static int IntSize;
    private Span`1<int> _span;
    internal BitHelper(Span`1<int> span, bool clear);
    [IsReadOnlyAttribute]
internal void MarkBit(int bitPosition);
    [IsReadOnlyAttribute]
internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument value;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument index;
    public static ExceptionArgument capacity;
    public static ExceptionArgument collection;
    public static ExceptionArgument item;
    public static ExceptionArgument converter;
    public static ExceptionArgument match;
    public static ExceptionArgument count;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument source;
    public static ExceptionArgument length;
    public static ExceptionArgument destinationArray;
    public static ExceptionArgument other;
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArgumentOutOfRange_IndexMustBeLessOrEqual;
    public static ExceptionResource ArgumentOutOfRange_IndexMustBeLess;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource InvalidOperation_IComparerFailed;
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.HashHelpers : object {
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    private static ImmutableArray`1<int> s_primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls : object {
    public static bool IsSynchronized(TCollection& collection);
    public static void CopyTo(TCollection& collection, Array array, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls`1 : object {
    public static bool IsReadOnly(TCollection& collection);
    public static void Add(TCollection& collection, T item);
    public static void CopyTo(TCollection& collection, T[] array, int arrayIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.IDictionaryCalls : object {
    public static bool IsFixedSize(TDictionary& dictionary);
    public static bool IsReadOnly(TDictionary& dictionary);
    public static object GetItem(TDictionary& dictionary, object key);
    public static void SetItem(TDictionary& dictionary, object key, object value);
    public static void Add(TDictionary& dictionary, object key, object value);
    public static bool Contains(TDictionary& dictionary, object key);
    public static void CopyTo(TDictionary& dictionary, Array array, int index);
    public static IDictionaryEnumerator GetEnumerator(TDictionary& dictionary);
    public static void Remove(TDictionary& dictionary, object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls : object {
    [NullableContextAttribute("1")]
public static IEnumerator GetEnumerator(TEnumerable& enumerable);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls`1 : object {
    [NullableContextAttribute("1")]
public static IEnumerator`1<T> GetEnumerator(TEnumerable& enumerable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.IListCalls : object {
    public static object GetItem(TList& list, int index);
    public static void SetItem(TList& list, int index, object value);
    public static bool IsFixedSize(TList& list);
    public static bool IsReadOnly(TList& list);
    public static int Add(TList& list, object value);
    public static bool Contains(TList& list, object value);
    public static int IndexOf(TList& list, object value);
    public static void Insert(TList& list, int index, object value);
    public static void Remove(TList& list, object value);
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe : object {
    public static T& NullRef();
    public static bool IsNullRef(T& source);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper : object {
    internal static int IntrosortSizeThreshold;
    [NullableContextAttribute("2")]
internal static int GetSegmentSize();
    [NullableContextAttribute("2")]
internal static int GetSegmentShift();
    [NullableContextAttribute("2")]
internal static int GetOffsetMask();
    private static int CalculateSegmentSize(int elementSize);
    private static int CalculateSegmentShift(int segmentSize);
    private static int CalculateOffsetMask(int segmentSize);
    [CompilerGeneratedAttribute]
internal static int <CalculateSegmentSize>g__ArraySize|4_0(int elementSize, int segmentSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySegment`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SegmentedArray`1<T> <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SegmentedArray`1<T> Array { get; }
    public int Start { get; }
    public int Length { get; }
    public T& Item { get; }
    public SegmentedArraySegment`1(SegmentedArray`1<T> array, int start, int length);
    [CompilerGeneratedAttribute]
public SegmentedArray`1<T> get_Array();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    public T& get_Item(int index);
    public SegmentedArraySegment`1<T> Slice(int start);
    public SegmentedArraySegment`1<T> Slice(int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortHelper`1 : object {
    public static void Sort(SegmentedArraySegment`1<T> keys, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer, int i, int j);
    private static void Swap(SegmentedArraySegment`1<T> a, int i, int j);
    internal static void IntrospectiveSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void IntroSort(SegmentedArraySegment`1<T> keys, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void HeapSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void DownHeap(SegmentedArraySegment`1<T> keys, int i, int n, Comparison`1<T> comparer);
    private static void InsertionSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortHelper`2 : object {
    public static void Sort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer, int i, int j);
    private static void Swap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    internal static void IntrospectiveSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void IntroSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void HeapSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void DownHeap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int n, IComparer`1<TKey> comparer);
    private static void InsertionSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils : object {
    [NullableContextAttribute("1")]
public static int MoveNansToFront(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    public static int Log2(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1 : object {
    public static void Sort(SegmentedArraySegment`1<T> keys, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value);
    private static void SwapIfGreater(T& i, T& j);
    private static void Swap(T& i, T& j);
    private static void IntroSort(SegmentedArraySegment`1<T> keys, int depthLimit);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<T> keys);
    private static void HeapSort(SegmentedArraySegment`1<T> keys);
    private static void DownHeap(SegmentedArraySegment`1<T> keys, int i, int n);
    private static void InsertionSort(SegmentedArraySegment`1<T> keys);
    private static bool LessThan(T& left, T& right);
    private static bool GreaterThan(T& left, T& right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`2 : object {
    public static void Sort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void Swap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void IntroSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int depthLimit);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static void HeapSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static void DownHeap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int n);
    private static void InsertionSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static bool LessThan(TKey& left, TKey& right);
    private static bool GreaterThan(TKey& left, TKey& right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.SegmentedHashSetEqualityComparer`1 : object {
    public sealed virtual bool Equals(SegmentedHashSet`1<T> x, SegmentedHashSet`1<T> y);
    public sealed virtual int GetHashCode(SegmentedHashSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_LongerThanDestArray { get; }
    internal static string Arg_LongerThanSrcArray { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_IncompatibleArrayType { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string ArgumentOutOfRange_ArrayLB { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLess { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string InvalidOperation_ConcurrentOperationsNotSupported { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string Rank_MustMatch { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string ArgumentException_OtherNotArrayOfCorrectLength { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string CannotFindOldValue { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLessOrEqual { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_LongerThanDestArray();
    internal static string get_Arg_LongerThanSrcArray();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_IncompatibleArrayType();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_ArgumentOutOfRange_ArrayLB();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_IndexMustBeLess();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_InvalidOperation_ConcurrentOperationsNotSupported();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_Rank_MustMatch();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_ArgumentException_OtherNotArrayOfCorrectLength();
    internal static string get_Arg_BogusIComparer();
    internal static string get_CannotFindOldValue();
    internal static string get_ArgumentOutOfRange_IndexMustBeLessOrEqual();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowIndexOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexMustBeLessException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexMustBeLessOrEqualException();
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
internal static void ThrowArgumentException_BadComparer(object comparer);
    [DoesNotReturnAttribute]
internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_IndexMustBeLessOrEqual();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_IndexMustBeLess();
    [DoesNotReturnAttribute]
internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    [DoesNotReturnAttribute]
internal static void ThrowWrongKeyTypeArgumentException(T key, Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowWrongValueTypeArgumentException(T value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    [DoesNotReturnAttribute]
internal static void ThrowAddingDuplicateWithKeyArgumentException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowKeyNotFoundException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_Argument_IncompatibleArrayType();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [NullableContextAttribute("2")]
internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
internal interface Microsoft.CodeAnalysis.Collections.IOrderedReadOnlySet`1 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked : object {
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedList`1& location, Func`2<ImmutableSegmentedList`1<T>, ImmutableSegmentedList`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedList`1& location, Func`3<ImmutableSegmentedList`1<T>, TArg, ImmutableSegmentedList`1<T>> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> InterlockedExchange(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> InterlockedCompareExchange(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value, ImmutableSegmentedList`1<T> comparand);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedHashSet`1& location, Func`2<ImmutableSegmentedHashSet`1<T>, ImmutableSegmentedHashSet`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedHashSet`1& location, Func`3<ImmutableSegmentedHashSet`1<T>, TArg, ImmutableSegmentedHashSet`1<T>> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> InterlockedExchange(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> InterlockedCompareExchange(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value, ImmutableSegmentedHashSet`1<T> comparand);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value);
    public static bool Update(ImmutableSegmentedDictionary`2& location, Func`2<ImmutableSegmentedDictionary`2<TKey, TValue>, ImmutableSegmentedDictionary`2<TKey, TValue>> transformer);
    public static bool Update(ImmutableSegmentedDictionary`2& location, Func`3<ImmutableSegmentedDictionary`2<TKey, TValue>, TArg, ImmutableSegmentedDictionary`2<TKey, TValue>> transformer, TArg transformerArgument);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> InterlockedExchange(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> InterlockedCompareExchange(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value, ImmutableSegmentedDictionary`2<TKey, TValue> comparand);
    public static bool InterlockedInitialize(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, Func`2<TKey, TValue> valueFactory);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, TValue value);
    public static TValue AddOrUpdate(ImmutableSegmentedDictionary`2& location, TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static TValue AddOrUpdate(ImmutableSegmentedDictionary`2& location, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static bool TryAdd(ImmutableSegmentedDictionary`2& location, TKey key, TValue value);
    public static bool TryUpdate(ImmutableSegmentedDictionary`2& location, TKey key, TValue newValue, TValue comparisonValue);
    public static bool TryRemove(ImmutableSegmentedDictionary`2& location, TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.SegmentedArray : object {
    [NullableContextAttribute("2")]
internal static void Clear(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
internal static void Clear(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
internal static void Copy(SegmentedArray`1<T> sourceArray, SegmentedArray`1<T> destinationArray, int length);
    public static void Copy(SegmentedArray`1<T> sourceArray, Array destinationArray, int length);
    [NullableContextAttribute("2")]
public static void Copy(SegmentedArray`1<T> sourceArray, int sourceIndex, SegmentedArray`1<T> destinationArray, int destinationIndex, int length);
    [NullableContextAttribute("2")]
private static void CopyOverlapped(SegmentedArray`1<T> array, int sourceIndex, int destinationIndex, int length);
    public static void Copy(SegmentedArray`1<T> sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static int BinarySearch(SegmentedArray`1<T> array, T value);
    public static int BinarySearch(SegmentedArray`1<T> array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    public static int IndexOf(SegmentedArray`1<T> array, T value);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count, IEqualityComparer`1<T> comparer);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Reverse(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
public static void Reverse(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(SegmentedArray`1<T> array, Comparison`1<T> comparison);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static SegmentEnumerable`1<T> GetSegments(SegmentedArray`1<T> array, int offset, int length);
    [NullableContextAttribute("2")]
private static AlignedSegmentEnumerable`1<T> GetSegments(SegmentedArray`1<T> first, SegmentedArray`1<T> second, int length);
    [NullableContextAttribute("2")]
private static AlignedSegmentEnumerable`1<T> GetSegmentsAligned(SegmentedArray`1<T> first, int firstOffset, SegmentedArray`1<T> second, int secondOffset, int length);
    [NullableContextAttribute("2")]
private static UnalignedSegmentEnumerable`1<T> GetSegmentsUnaligned(SegmentedArray`1<T> first, int firstOffset, SegmentedArray`1<T> second, int secondOffset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedArray`1 : ValueType {
    private int _length;
    private T[][] _items;
    private static int SegmentSize { get; }
    private static int SegmentShift { get; }
    private static int OffsetMask { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public int Length { get; }
    public object SyncRoot { get; }
    public T& Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public SegmentedArray`1(int length);
    private SegmentedArray`1(int length, T[][] items);
    private static int get_SegmentSize();
    private static int get_SegmentShift();
    private static int get_OffsetMask();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public int get_Length();
    public sealed virtual object get_SyncRoot();
    public T& get_Item(int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual object Clone();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SegmentedArray`1<T> other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.SegmentedCollectionsMarshal : object {
    public static T[][] AsSegments(SegmentedArray`1<T> array);
    public static TValue& GetValueRefOrNullRef(SegmentedDictionary`2<TKey, TValue> dictionary, TKey key);
    public static TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRef(ImmutableSegmentedDictionary`2<TKey, TValue> dictionary, TKey key);
    public static TValue& GetValueRefOrNullRef(Builder<TKey, TValue> dictionary, TKey key);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> AsImmutableSegmentedList(SegmentedList`1<T> list);
    [NullableContextAttribute("2")]
public static SegmentedList`1<T> AsSegmentedList(ImmutableSegmentedList`1<T> list);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> AsImmutableSegmentedHashSet(SegmentedHashSet`1<T> set);
    [NullableContextAttribute("2")]
public static SegmentedHashSet`1<T> AsSegmentedHashSet(ImmutableSegmentedHashSet`1<T> set);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> AsImmutableSegmentedDictionary(SegmentedDictionary`2<TKey, TValue> dictionary);
    public static SegmentedDictionary`2<TKey, TValue> AsSegmentedDictionary(ImmutableSegmentedDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2 : object {
    private static bool SupportsComparerDevirtualization;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IEnumerator`1<KeyValuePair`2<TKey, TValue>> s_emptyEnumerator;
    [NullableAttribute("0")]
private SegmentedArray`1<int> _buckets;
    [NullableAttribute("0")]
private SegmentedArray`1<Entry<TKey, TValue>> _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<TKey> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> _keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> _values;
    private static int StartOfFreeList;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public SegmentedDictionary`2(int capacity);
    public SegmentedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SegmentedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public SegmentedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    private void AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> enumerable);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private static IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEmptyEnumerator();
    private TValue& FindValue(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    private void Resize();
    private void Resize(int newSize);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    [NullableContextAttribute("0")]
private void CopyEntries(SegmentedArray`1<Entry<TKey, TValue>> entries, int count);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private Int32& GetBucket(UInt32 hashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1 : object {
    private static bool SupportsComparerDevirtualization;
    private static int StackAllocThreshold;
    private static int ShrinkThreshold;
    private static int StartOfFreeList;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IEnumerator`1<T> s_emptyEnumerator;
    [NullableAttribute("0")]
private SegmentedArray`1<int> _buckets;
    [NullableAttribute("0")]
private SegmentedArray`1<Entry<T>> _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<T> _comparer;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public SegmentedHashSet`1(IEqualityComparer`1<T> comparer);
    public SegmentedHashSet`1(int capacity);
    public SegmentedHashSet`1(IEnumerable`1<T> collection);
    public SegmentedHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public SegmentedHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private void ConstructFrom(SegmentedHashSet`1<T> source);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private int FindItemIndex(T item);
    private Int32& GetBucketRef(int hashCode);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static IEnumerator`1<T> GetEmptyEnumerator();
    public sealed virtual bool Add(T item);
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public int RemoveWhere(Predicate`1<T> match);
    public IEqualityComparer`1<T> get_Comparer();
    public int EnsureCapacity(int capacity);
    private void Resize();
    private void Resize(int newSize);
    public void TrimExcess();
    public static IEqualityComparer`1<SegmentedHashSet`1<T>> CreateSetComparer();
    private int Initialize(int capacity);
    private bool AddIfNotPresent(T value, Int32& location);
    internal bool IsSubsetOfHashSetWithSameComparer(SegmentedHashSet`1<T> other);
    private void IntersectWithHashSetWithSameComparer(SegmentedHashSet`1<T> other);
    private void IntersectWithEnumerable(IEnumerable`1<T> other);
    private void SymmetricExceptWithUniqueHashSet(SegmentedHashSet`1<T> other);
    private void SymmetricExceptWithEnumerable(IEnumerable`1<T> other);
    [NullableContextAttribute("0")]
private ValueTuple`2<int, int> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    internal static bool EqualityComparersAreEqual(SegmentedHashSet`1<T> set1, SegmentedHashSet`1<T> set2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedList`1 : object {
    private static int DefaultCapacity;
    private static int MaxLength;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal SegmentedArray`1<T> _items;
    internal int _size;
    internal int _version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static SegmentedArray`1<T> s_emptyArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IEnumerator`1<T> s_emptyEnumerator;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public SegmentedList`1(int capacity);
    public SegmentedList`1(IEnumerable`1<T> collection);
    private static SegmentedList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object item);
    public SegmentedList`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public int EnsureCapacity(int capacity);
    internal void Grow(int capacity);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public SegmentedList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static IEnumerator`1<T> GetEmptyEnumerator();
    public SegmentedList`1<T> GetRange(int index, int count);
    public SegmentedList`1<T> Slice(int start, int length);
    public sealed virtual int IndexOf(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public int IndexOf(T item, int index, int count, IEqualityComparer`1<T> comparer);
    public sealed virtual void Insert(int index, T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> comparer);
    public sealed virtual bool Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
    [NullableContextAttribute("0")]
internal TestAccessor<T> GetTestAccessor();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.CodeAnalysis.EmptyReadOnlyMemoryOfCharComparer : object {
    public static EmptyReadOnlyMemoryOfCharComparer Instance;
    private static EmptyReadOnlyMemoryOfCharComparer();
    public sealed virtual bool Equals(ReadOnlyMemory`1<char> a, ReadOnlyMemory`1<char> b);
    public sealed virtual int GetHashCode(ReadOnlyMemory`1<char> s);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EncodingExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool TryGetMaxCharCount(Encoding encoding, long length, Int32& maxCharCount);
}
internal enum Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity : Enum {
    public int value__;
    public static ErrorSeverity Uncategorized;
    public static ErrorSeverity Diagnostic;
    public static ErrorSeverity General;
    public static ErrorSeverity Critical;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ErrorReporting.FatalError : object {
    [NullableAttribute("2")]
private static ErrorReporterHandler s_handler;
    [NullableAttribute("2")]
private static ErrorReporterHandler s_nonFatalHandler;
    [NullableAttribute("2")]
private static Exception s_reportedException;
    [NullableAttribute("2")]
private static string s_reportedExceptionMessage;
    private static object s_reportedMarker;
    private static FatalError();
    public static void SetHandlers(ErrorReporterHandler handler, ErrorReporterHandler nonFatalHandler);
    [NullableContextAttribute("2")]
public static void OverwriteHandler(ErrorReporterHandler value);
    public static void CopyHandlersTo(Assembly assembly);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagate(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagateUnlessCanceled(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagateUnlessCanceled(Exception exception, CancellationToken contextCancellationToken, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatch(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportWithDumpAndCatch(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatchUnlessCanceled(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatchUnlessCanceled(Exception exception, CancellationToken contextCancellationToken, ErrorSeverity severity);
    private static void Report(Exception exception, ErrorSeverity severity, bool forceDump);
    public static void ReportNonFatalError(Exception exception, ErrorSeverity severity, bool forceDump);
    private static void ReportException(Exception exception, ErrorSeverity severity, bool forceDump, ErrorReporterHandler handler);
    [CompilerGeneratedAttribute]
internal static void <CopyHandlersTo>g__copyHandlerTo|7_0(Assembly assembly, ErrorReporterHandler handler, string handlerName);
}
internal class Microsoft.CodeAnalysis.ErrorReporting.OperationCanceledIgnoringCallerTokenException : OperationCanceledException {
    [NullableContextAttribute("1")]
public OperationCanceledIgnoringCallerTokenException(Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FailFast : object {
    internal static ErrorReporterHandler Handler;
    private static FailFast();
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
internal static void OnFatalException(Exception exception);
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
internal static void Fail(string message);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
internal static void DumpStackTrace(Exception exception, string message);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
internal static void Assert(bool condition, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ImmutableArrayExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(IEnumerable`1<T> items);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(T[] items);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<byte> ToImmutable(MemoryStream stream);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, bool> predicate, Func`2<TItem, TResult> selector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> array, Func`3<TItem, TArg, bool> predicate, Func`3<TItem, TArg, TResult> selector, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, ImmutableArray`1<TResult>> selector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, bool> predicate, Func`2<TItem, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, bool> predicate, Func`2<TItem, ImmutableArray`1<TResult>> selector);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<SelectAsArrayAsync>d__16`2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(ImmutableArray`1<TItem> array, Func`3<TItem, CancellationToken, ValueTask`1<TResult>> selector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<SelectAsArrayAsync>d__17`3")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(ImmutableArray`1<TItem> array, Func`4<TItem, TArg, CancellationToken, ValueTask`1<TResult>> selector, TArg arg, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectManyAsArrayAsync(ImmutableArray`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<ImmutableArray`1<TResult>>> selector, TArg arg, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> ZipAsArray(ImmutableArray`1<T1> self, ImmutableArray`1<T2> other, Func`3<T1, T2, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> ZipAsArray(ImmutableArray`1<T1> self, ImmutableArray`1<T2> other, TArg arg, Func`5<T1, T2, int, TArg, TResult> map);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`2<T, bool> predicate);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    private static ImmutableArray`1<T> WhereAsArrayImpl(ImmutableArray`1<T> array, Func`2<T, bool> predicateWithoutArg, Func`3<T, TArg, bool> predicateWithArg, TArg arg);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool All(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<AnyAsync>d__26`1")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(ImmutableArray`1<T> array, Func`2<T, Task`1<bool>> predicateAsync);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<AnyAsync>d__27`2")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(ImmutableArray`1<T> array, Func`3<T, TArg, Task`1<bool>> predicateAsync, TArg arg);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<FirstOrDefaultAsync>d__28`1")]
[ExtensionAttribute]
public static ValueTask`1<T> FirstOrDefaultAsync(ImmutableArray`1<T> array, Func`2<T, Task`1<bool>> predicateAsync);
    [ExtensionAttribute]
public static TValue FirstOrDefault(ImmutableArray`1<TValue> array, Func`3<TValue, TArg, bool> predicate, TArg arg);
    [ExtensionAttribute]
public static TValue Single(ImmutableArray`1<TValue> array, Func`3<TValue, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<TBase> Cast(ImmutableArray`1<TDerived> items);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool SetEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(ImmutableArray`1<T> array);
    [ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(Nullable`1<ImmutableArray`1<T>> array);
    [ExtensionAttribute]
public static ImmutableArray`1<T> Distinct(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ConditionallyDeOrder(ImmutableArray`1<T> array);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ImmutableArray`1<TValue> Flatten(Dictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, IComparer`1<TValue> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third, ImmutableArray`1<T> fourth);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third, ImmutableArray`1<T> fourth, ImmutableArray`1<T> fifth);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third, ImmutableArray`1<T> fourth, ImmutableArray`1<T> fifth, ImmutableArray`1<T> sixth);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, T second);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> AddRange(ImmutableArray`1<T> self, TemporaryArray`1& items);
    [ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int Count(ImmutableArray`1<T> items, Func`2<T, bool> predicate);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int Sum(ImmutableArray`1<T> items, Func`2<T, int> selector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int Sum(ImmutableArray`1<T> items, Func`3<T, int, int> selector);
    [NullableContextAttribute("1")]
internal static void AddToMultiValueDictionaryBuilder(Dictionary`2<K, object> accumulator, K key, T item);
    [NullableContextAttribute("1")]
internal static void CreateNameToMembersMap(Dictionary`2<TKey, object> dictionary, Dictionary`2<TKey, ImmutableArray`1<TNamespaceOrTypeSymbol>> result);
    [NullableContextAttribute("1")]
internal static Dictionary`2<TKey, ImmutableArray`1<TNamedTypeSymbol>> GetTypesFromMemberMap(Dictionary`2<TKey, ImmutableArray`1<TNamespaceOrTypeSymbol>> map, IEqualityComparer`1<TKey> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool SequenceEqual(ImmutableArray`1<TElement> array1, ImmutableArray`1<TElement> array2, TArg arg, Func`4<TElement, TElement, TArg, bool> predicate);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int IndexOf(ImmutableArray`1<T> array, T item, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool IsSorted(ImmutableArray`1<T> array, IComparer`1<T> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int BinarySearch(ImmutableArray`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int BinarySearch(ReadOnlySpan`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int BinarySearch(ImmutableSegmentedList`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [ExtensionAttribute]
public static bool IsSubsetOf(ImmutableArray`1<TElement> array, ImmutableArray`1<TElement> other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<TNamespaceOrTypeSymbol> <CreateNameToMembersMap>g__createMembers|51_0(object value);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<TNamedTypeSymbol> <GetTypesFromMemberMap>g__getOrCreateNamedTypes|52_0(ImmutableArray`1<TNamespaceOrTypeSymbol> members);
}
internal static class Microsoft.CodeAnalysis.Internal.Strings : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2 : object {
    private int _capacity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<K, CacheValue<K, V>> _cache;
    private LinkedList`1<K> _nodeList;
    private object _lockObject;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IEnumerable`1<KeyValuePair`2<K, V>> TestingEnumerable { get; }
    public V Item { get; public set; }
    public ConcurrentLruCache`2(int capacity);
    public ConcurrentLruCache`2(KeyValuePair`2[] array);
    internal IEnumerable`1<KeyValuePair`2<K, V>> get_TestingEnumerable();
    public void Add(K key, V value);
    private void MoveNodeToTop(LinkedListNode`1<K> node);
    private void UnsafeEvictLastNode();
    private void UnsafeAddNodeToTop(K key, V value);
    private void UnsafeAdd(K key, V value, bool throwExceptionIfKeyExists);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool TryGetValue(K key, V& value);
    public bool UnsafeTryGetValue(K key, V& value);
    public V GetOrAdd(K key, V value);
    public V GetOrAdd(K key, Func`1<V> creator);
    public V GetOrAdd(K key, T arg, Func`2<T, V> creator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.LanguageNames : object {
    public static string CSharp;
    public static string VisualBasic;
    public static string FSharp;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class Microsoft.CodeAnalysis.LittleEndianReader : ValueType {
    private ReadOnlySpan`1<byte> _span;
    public LittleEndianReader(ReadOnlySpan`1<byte> span);
    internal UInt32 ReadUInt32();
    internal byte ReadByte();
    internal ushort ReadUInt16();
    internal ReadOnlySpan`1<byte> ReadBytes(int byteCount);
    internal int ReadInt32();
    [NullableContextAttribute("1")]
internal Byte[] ReadReversed(int byteCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.BuildHost : object {
    private BuildHostLogger _logger;
    private ImmutableDictionary`2<string, string> _globalMSBuildProperties;
    [NullableAttribute("2")]
private string _binaryLogPath;
    private RpcServer _server;
    private object _gate;
    [NullableAttribute("2")]
private ProjectBuildManager _buildManager;
    public BuildHost(BuildHostLogger logger, ImmutableDictionary`2<string, string> globalMSBuildProperties, string binaryLogPath, RpcServer server);
    private bool TryEnsureMSBuildLoaded(string projectOrSolutionFilePath);
    [MemberNotNullAttribute("_buildManager")]
private void CreateBuildManager();
    public sealed virtual bool HasUsableMSBuild(string projectOrSolutionFilePath);
    private void EnsureMSBuildLoaded(string projectFilePath);
    public sealed virtual ImmutableArray`1<ValueTuple`2<string, string>> GetProjectsInSolution(string solutionFilePath);
    private static ImmutableArray`1<ValueTuple`2<string, string>> GetProjectsInSolutionCore(string solutionFilePath);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.BuildHost/<LoadProjectFileAsync>d__13")]
public sealed virtual Task`1<int> LoadProjectFileAsync(string projectFilePath, string languageName, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> TryGetProjectOutputPathAsync(string projectFilePath, CancellationToken cancellationToken);
    public sealed virtual Task ShutdownAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.BuildHostLogger : object {
    [CompilerGeneratedAttribute]
private TextWriter <output>P;
    public BuildHostLogger(TextWriter output);
    public void LogInformation(string message);
    public void LogCritical(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MSBuild.CommandLineArgumentReader : object {
    protected ProjectInstance Project;
    private Builder<string> _builder;
    private static ImmutableDictionary`2<string, string> s_debugTypeValues;
    protected CommandLineArgumentReader(ProjectInstance project);
    private static CommandLineArgumentReader();
    protected abstract virtual void ReadCore();
    private static void ValidateName(string name);
    protected void Add(string name);
    protected void Add(string name, string value, bool addQuoteIfValueContainsWhitespace);
    protected void Add(string name, int value);
    protected void AddIfNotNullOrWhiteSpace(string name, string value, bool addQuoteIfValueContainsWhitespace);
    protected void AddIfTrue(string name, bool condition);
    protected void AddIfTrue(string name, string value, bool condition);
    protected void AddIfFalse(string name, bool condition);
    protected void AddWithPlus(string name);
    protected void AddWithMinus(string name);
    protected void AddWithPlusOrMinus(string name, bool condition);
    protected string GetDocumentFilePath(ITaskItem documentItem);
    protected string GetAbsolutePath(string path);
    protected void ReadAdditionalFiles();
    protected void ReadAnalyzers();
    protected void ReadCodePage();
    protected void ReadDebugInfo();
    protected void ReadDelaySign();
    protected void ReadErrorReport();
    protected void ReadFeatures();
    protected void ReadImports();
    protected void ReadPlatform();
    protected void ReadReferences();
    protected void ReadSigning();
    protected ImmutableArray`1<string> Read();
    [CompilerGeneratedAttribute]
internal static string <ReadImports>g__ReadImportItem|25_0(ITaskItem item);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.MSBuild.Conversions : object {
    public static bool ToBool(string value);
    public static int ToInt(string value);
    public static ulong ToULong(string value);
    [NullableContextAttribute("0")]
public static Nullable`1<TEnum> ToEnum(string value, bool ignoreCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.CSharpCommandLineArgumentReader : CommandLineArgumentReader {
    private CSharpCommandLineArgumentReader(ProjectInstance project);
    public static ImmutableArray`1<string> Read(ProjectInstance project);
    protected virtual void ReadCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.CSharpProjectFile : ProjectFile {
    public CSharpProjectFile(CSharpProjectFileLoader loader, Project project, ProjectBuildManager buildManager, DiagnosticLog log);
    protected virtual IEnumerable`1<ITaskItem> GetCompilerCommandLineArgs(ProjectInstance executedProject);
    protected virtual ImmutableArray`1<string> ReadCommandLineArgs(ProjectInstance project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.CSharpProjectFileLoader : ProjectFileLoader {
    public string Language { get; }
    public virtual string get_Language();
    protected virtual ProjectFile CreateProjectFile(Project project, ProjectBuildManager buildManager, DiagnosticLog log);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.MSBuild.DiagnosticLog : ValueType {
    private List`1<DiagnosticLogItem> _items;
    public int Count { get; }
    public DiagnosticLogItem Item { get; }
    public bool IsEmpty { get; }
    public int get_Count();
    public DiagnosticLogItem get_Item(int index);
    public bool get_IsEmpty();
    public sealed virtual IEnumerator`1<DiagnosticLogItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(DiagnosticLogItem item);
    public void Add(string message, string projectFilePath, DiagnosticLogItemKind kind);
    public void Add(Exception exception, string projectFilePath, DiagnosticLogItemKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.MSBuild.DiagnosticLogItem : object {
    [CompilerGeneratedAttribute]
private DiagnosticLogItemKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [DataMemberAttribute]
public DiagnosticLogItemKind Kind { get; }
    [DataMemberAttribute]
public string Message { get; }
    [DataMemberAttribute]
public string ProjectFilePath { get; }
    public DiagnosticLogItem(DiagnosticLogItemKind kind, string message, string projectFilePath);
    [CompilerGeneratedAttribute]
public DiagnosticLogItemKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    public virtual string ToString();
}
internal enum Microsoft.CodeAnalysis.MSBuild.DiagnosticLogItemKind : Enum {
    public int value__;
    public static DiagnosticLogItemKind Error;
    public static DiagnosticLogItemKind Warning;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.MSBuild.DocumentFileInfo : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogicalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLinked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGenerated>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Folders>k__BackingField;
    [DataMemberAttribute]
public string FilePath { get; }
    [DataMemberAttribute]
public string LogicalPath { get; }
    [DataMemberAttribute]
public bool IsLinked { get; }
    [DataMemberAttribute]
public bool IsGenerated { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> Folders { get; }
    public DocumentFileInfo(string filePath, string logicalPath, bool isLinked, bool isGenerated, ImmutableArray`1<string> folders);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_LogicalPath();
    [CompilerGeneratedAttribute]
public bool get_IsLinked();
    [CompilerGeneratedAttribute]
public bool get_IsGenerated();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Folders();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.MSBuild.Extensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetAdditionalFiles(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetAnalyzers(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetDocuments(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetEditorConfigFiles(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetMetadataReferences(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ProjectFileReference> GetProjectReferences(ProjectInstance executedProject);
    [ExtensionAttribute]
public static ImmutableArray`1<PackageReference> GetPackageReferences(ProjectInstance executedProject);
    private static ProjectFileReference CreateProjectFileReference(ProjectItemInstance reference);
    [ExtensionAttribute]
public static ImmutableArray`1<string> GetAliases(ITaskItem item);
    [ExtensionAttribute]
public static bool ReferenceOutputAssemblyIsTrue(ITaskItem item);
    [ExtensionAttribute]
public static string ReadPropertyString(ProjectInstance executedProject, string propertyName);
    [ExtensionAttribute]
public static bool ReadPropertyBool(ProjectInstance executedProject, string propertyName);
    [ExtensionAttribute]
public static int ReadPropertyInt(ProjectInstance executedProject, string propertyName);
    [ExtensionAttribute]
public static ulong ReadPropertyULong(ProjectInstance executedProject, string propertyName);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<TEnum> ReadPropertyEnum(ProjectInstance executedProject, string propertyName, bool ignoreCase);
    [ExtensionAttribute]
public static string ReadItemsAsString(ProjectInstance executedProject, string itemType);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetTaskItems(ProjectInstance executedProject, string itemType);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.MSBuild.IBuildHost {
    public abstract virtual bool HasUsableMSBuild(string projectOrSolutionFilePath);
    public abstract virtual ImmutableArray`1<ValueTuple`2<string, string>> GetProjectsInSolution(string solutionFilePath);
    public abstract virtual Task`1<int> LoadProjectFileAsync(string projectFilePath, string languageName, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> TryGetProjectOutputPathAsync(string projectFilePath, CancellationToken cancellationToken);
    public abstract virtual Task ShutdownAsync();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.MSBuild.IProjectFile {
    public abstract virtual ImmutableArray`1<DiagnosticLogItem> GetDiagnosticLogItems();
    public abstract virtual Task`1<ImmutableArray`1<ProjectFileInfo>> GetProjectFileInfosAsync(CancellationToken cancellationToken);
    public abstract virtual void AddDocument(string filePath, string logicalPath);
    public abstract virtual void RemoveDocument(string filePath);
    public abstract virtual void AddMetadataReference(string metadataReferenceIdentity, ImmutableArray`1<string> aliases, string hintPath);
    public abstract virtual void RemoveMetadataReference(string shortAssemblyName, string fullAssemblyName, string filePath);
    public abstract virtual void AddProjectReference(string projectName, ProjectFileReference reference);
    public abstract virtual void RemoveProjectReference(string projectName, string projectFilePath);
    public abstract virtual void AddAnalyzerReference(string fullPath);
    public abstract virtual void RemoveAnalyzerReference(string fullPath);
    public abstract virtual void Save();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.MSBuild.ItemNames : object {
    public static string AdditionalFiles;
    public static string Analyzer;
    public static string Compile;
    public static string Content;
    public static string CscCommandLineArgs;
    public static string DocFileItem;
    public static string EditorConfigFiles;
    public static string Import;
    public static string ProjectReference;
    public static string PackageReference;
    public static string ProjectCapability;
    public static string Reference;
    public static string ReferencePath;
    public static string VbcCommandLineArgs;
    public static string IntermediateAssembly;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.MSBuild.JsonSettings : object {
    public static Encoding StreamEncoding;
    public static JsonSerializerSettings SingleLineSerializerSettings;
    private static JsonSettings();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.MSBuild.MetadataNames : object {
    public static string Aliases;
    public static string FullPath;
    public static string HintPath;
    public static string Link;
    public static string Name;
    public static string ReferenceOutputAssembly;
    public static string Version;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.MSBuild.MonoMSBuildDiscovery : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IEnumerable`1<string> s_searchPaths;
    private static string s_monoRuntimeExecutablePath;
    private static string s_monoLibDirPath;
    private static string s_monoMSBuildDirectory;
    [NullableContextAttribute("1")]
private static IEnumerable`1<string> GetSearchPaths();
    [NullableContextAttribute("1")]
private static IntPtr Unix_realpath(string path, IntPtr buffer);
    private static void Unix_free(IntPtr ptr);
    [NullableContextAttribute("1")]
private static string RealPath(string path);
    private static string GetMonoRuntimeExecutablePath();
    private static string GetMonoLibDirPath();
    public static string GetMonoMSBuildDirectory();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.MSBuildDiagnosticLogger : object {
    private string _projectFilePath;
    private Nullable`1<DiagnosticLog> _log;
    private IEventSource _eventSource;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    public string Parameters { get; public set; }
    public LoggerVerbosity Verbosity { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [NullableContextAttribute("1")]
public void SetProjectAndLog(string projectFilePath, DiagnosticLog log);
    [NullableContextAttribute("1")]
private void OnErrorRaised(object sender, BuildErrorEventArgs e);
    [NullableContextAttribute("1")]
private void OnWarningRaised(object sender, BuildWarningEventArgs e);
    [NullableContextAttribute("1")]
public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.MSBuildDiagnosticLogItem : DiagnosticLogItem {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    public string FileName { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public MSBuildDiagnosticLogItem(DiagnosticLogItemKind kind, string projectFilePath, string message, string fileName, int lineNumber, int columnNumber);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.MSBuild.PackageReference : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionRange>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public string VersionRange { get; public set; }
    public PackageReference(string Name, string VersionRange);
    [CompilerGeneratedAttribute]
protected PackageReference(PackageReference original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_VersionRange();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VersionRange(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PackageReference left, PackageReference right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PackageReference left, PackageReference right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PackageReference other);
    [CompilerGeneratedAttribute]
public virtual PackageReference <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name, String& VersionRange);
}
internal static class Microsoft.CodeAnalysis.MSBuild.Program : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.Program/<Main>d__0")]
internal static Task Main(String[] args);
    private static void <Main>(String[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.ProjectBuildManager : object {
    private static XmlReaderSettings s_xmlReaderSettings;
    private static ImmutableDictionary`2<string, string> s_defaultGlobalProperties;
    private ImmutableDictionary`2<string, string> _additionalGlobalProperties;
    [NullableAttribute("2")]
private ILogger _msbuildLogger;
    [NullableAttribute("2")]
private ProjectCollection _batchBuildProjectCollection;
    [NullableAttribute("2")]
private MSBuildDiagnosticLogger _batchBuildLogger;
    [CompilerGeneratedAttribute]
private bool <BatchBuildStarted>k__BackingField;
    private static SemaphoreSlim s_buildManagerLock;
    private ImmutableDictionary`2<string, string> AllGlobalProperties { get; }
    public bool BatchBuildStarted { get; private set; }
    public ProjectBuildManager(ImmutableDictionary`2<string, string> additionalGlobalProperties, ILogger msbuildLogger);
    private static ProjectBuildManager();
    protected virtual override void Finalize();
    private ImmutableDictionary`2<string, string> get_AllGlobalProperties();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectBuildManager/<LoadProjectAsync>d__10")]
private static Task`1<ValueTuple`2<Project, DiagnosticLog>> LoadProjectAsync(string path, ProjectCollection projectCollection, CancellationToken cancellationToken);
    public Task`1<ValueTuple`2<Project, DiagnosticLog>> LoadProjectAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectBuildManager/<TryGetOutputFilePathAsync>d__12")]
public Task`1<string> TryGetOutputFilePathAsync(string path, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public bool get_BatchBuildStarted();
    [CompilerGeneratedAttribute]
private void set_BatchBuildStarted(bool value);
    public void StartBatchBuild(IDictionary`2<string, string> globalProperties);
    public void EndBatchBuild();
    public Task`1<ProjectInstance> BuildProjectAsync(Project project, DiagnosticLog log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectBuildManager/<BuildProjectAsync>d__20")]
private Task`1<ProjectInstance> BuildProjectAsync(Project project, String[] requiredTargets, String[] optionalTargets, DiagnosticLog log, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectBuildManager/<BuildAsync>d__22")]
private static Task`1<BuildResult> BuildAsync(BuildRequestData requestData, CancellationToken cancellationToken);
    private static Task`1<BuildResult> BuildAsync(BuildManager buildManager, BuildRequestData requestData, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MSBuild.ProjectFile : object {
    private ProjectFileLoader _loader;
    [NullableAttribute("2")]
private Project _loadedProject;
    private ProjectBuildManager _buildManager;
    private string _projectDirectory;
    [CompilerGeneratedAttribute]
private DiagnosticLog <Log>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, ProjectItem> _documents;
    public DiagnosticLog Log { get; }
    public string FilePath { get; }
    public string Language { get; }
    protected ProjectFile(ProjectFileLoader loader, Project loadedProject, ProjectBuildManager buildManager, DiagnosticLog log);
    [CompilerGeneratedAttribute]
public DiagnosticLog get_Log();
    public virtual string get_FilePath();
    public string get_Language();
    public sealed virtual ImmutableArray`1<DiagnosticLogItem> GetDiagnosticLogItems();
    protected abstract virtual IEnumerable`1<ITaskItem> GetCompilerCommandLineArgs(ProjectInstance executedProject);
    protected abstract virtual ImmutableArray`1<string> ReadCommandLineArgs(ProjectInstance project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFile/<GetProjectFileInfosAsync>d__15")]
public sealed virtual Task`1<ImmutableArray`1<ProjectFileInfo>> GetProjectFileInfosAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFile/<BuildProjectFileInfoAsync>d__16")]
private Task`1<ProjectFileInfo> BuildProjectFileInfoAsync(CancellationToken cancellationToken);
    private ProjectFileInfo CreateProjectFileInfo(ProjectInstance project);
    private static ImmutableArray`1<string> GetContentFiles(ProjectInstance project);
    private ImmutableArray`1<string> GetCommandLineArgs(ProjectInstance project);
    protected static bool IsNotTemporaryGeneratedFile(ITaskItem item);
    private DocumentFileInfo MakeDocumentFileInfo(ITaskItem documentItem);
    private DocumentFileInfo MakeNonSourceFileDocumentFileInfo(ITaskItem documentItem);
    private ImmutableArray`1<string> GetRelativeFolders(ITaskItem documentItem);
    private string GetAbsolutePathRelativeToProject(string path);
    private string GetDocumentFilePath(ITaskItem documentItem);
    private static bool IsDocumentLinked(ITaskItem documentItem);
    protected bool IsDocumentGenerated(ITaskItem documentItem);
    protected static string GetDocumentLogicalPath(ITaskItem documentItem, string projectDirectory);
    public sealed virtual void AddDocument(string filePath, string logicalPath);
    public sealed virtual void RemoveDocument(string filePath);
    public sealed virtual void AddMetadataReference(string metadataReferenceIdentity, ImmutableArray`1<string> aliases, string hintPath);
    public sealed virtual void RemoveMetadataReference(string shortAssemblyName, string fullAssemblyName, string filePath);
    private ProjectItem FindReferenceItem(string shortAssemblyName, string fullAssemblyName, string filePath);
    private static string GetHintPath(ProjectItem item);
    public sealed virtual void AddProjectReference(string projectName, ProjectFileReference reference);
    public sealed virtual void RemoveProjectReference(string projectName, string projectFilePath);
    private ProjectItem FindProjectReferenceItem(string projectName, string projectFilePath);
    public sealed virtual void AddAnalyzerReference(string fullPath);
    public sealed virtual void RemoveAnalyzerReference(string fullPath);
    public sealed virtual void Save();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.MSBuild.ProjectFileInfo : object {
    [CompilerGeneratedAttribute]
private bool <IsEmpty>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputRefFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IntermediateOutputFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkIdentifier>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <CommandLineArgs>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentFileInfo> <Documents>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentFileInfo> <AdditionalDocuments>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentFileInfo> <AnalyzerConfigDocuments>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ProjectFileReference> <ProjectReferences>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ProjectCapabilities>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ContentFilePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectAssetsFilePath>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<PackageReference> <PackageReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkVersion>k__BackingField;
    [DataMemberAttribute]
public bool IsEmpty { get; }
    [NullableAttribute("1")]
[DataMemberAttribute]
public string Language { get; }
    [DataMemberAttribute]
public string FilePath { get; }
    [DataMemberAttribute]
public string OutputFilePath { get; }
    [DataMemberAttribute]
public string OutputRefFilePath { get; }
    [DataMemberAttribute]
public string IntermediateOutputFilePath { get; }
    [DataMemberAttribute]
public string DefaultNamespace { get; }
    [DataMemberAttribute]
public string TargetFramework { get; }
    [DataMemberAttribute]
public string TargetFrameworkIdentifier { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> CommandLineArgs { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<DocumentFileInfo> Documents { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<DocumentFileInfo> AdditionalDocuments { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<DocumentFileInfo> AnalyzerConfigDocuments { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ProjectFileReference> ProjectReferences { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> ProjectCapabilities { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> ContentFilePaths { get; }
    [DataMemberAttribute]
public string ProjectAssetsFilePath { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<PackageReference> PackageReferences { get; }
    [DataMemberAttribute]
public string TargetFrameworkVersion { get; }
    public ProjectFileInfo(bool isEmpty, string language, string filePath, string outputFilePath, string outputRefFilePath, string intermediateOutputFilePath, string defaultNamespace, string targetFramework, string targetFrameworkIdentifier, string targetFrameworkVersion, string projectAssetsFilePath, ImmutableArray`1<string> commandLineArgs, ImmutableArray`1<DocumentFileInfo> documents, ImmutableArray`1<DocumentFileInfo> additionalDocuments, ImmutableArray`1<DocumentFileInfo> analyzerConfigDocuments, ImmutableArray`1<ProjectFileReference> projectReferences, ImmutableArray`1<PackageReference> packageReferences, ImmutableArray`1<string> projectCapabilities, ImmutableArray`1<string> contentFilePaths);
    [CompilerGeneratedAttribute]
public bool get_IsEmpty();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public string get_OutputRefFilePath();
    [CompilerGeneratedAttribute]
public string get_IntermediateOutputFilePath();
    [CompilerGeneratedAttribute]
public string get_DefaultNamespace();
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkIdentifier();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_CommandLineArgs();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentFileInfo> get_Documents();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentFileInfo> get_AdditionalDocuments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentFileInfo> get_AnalyzerConfigDocuments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ProjectFileReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ProjectCapabilities();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ContentFilePaths();
    [CompilerGeneratedAttribute]
public string get_ProjectAssetsFilePath();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<PackageReference> get_PackageReferences();
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkVersion();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static ProjectFileInfo Create(string language, string filePath, string outputFilePath, string outputRefFilePath, string intermediateOutputFilePath, string defaultNamespace, string targetFramework, string targetFrameworkIdentifier, string targetFrameworkVersion, string projectAssetsFilePath, ImmutableArray`1<string> commandLineArgs, ImmutableArray`1<DocumentFileInfo> documents, ImmutableArray`1<DocumentFileInfo> additionalDocuments, ImmutableArray`1<DocumentFileInfo> analyzerConfigDocuments, ImmutableArray`1<ProjectFileReference> projectReferences, ImmutableArray`1<PackageReference> packageReferences, ImmutableArray`1<string> projectCapabilities, ImmutableArray`1<string> contentFilePaths);
    [NullableContextAttribute("1")]
public static ProjectFileInfo CreateEmpty(string language, string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.MSBuild.ProjectFileLoader : object {
    public string Language { get; }
    public abstract virtual string get_Language();
    protected abstract virtual ProjectFile CreateProjectFile(Project project, ProjectBuildManager buildManager, DiagnosticLog log);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.ProjectFileLoader/<LoadProjectFileAsync>d__3")]
public Task`1<ProjectFile> LoadProjectFileAsync(string path, ProjectBuildManager buildManager, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.MSBuild.ProjectFileReference : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Aliases>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferenceOutputAssembly>k__BackingField;
    [DataMemberAttribute]
public string Path { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> Aliases { get; }
    [DataMemberAttribute]
public bool ReferenceOutputAssembly { get; }
    public ProjectFileReference(string path, ImmutableArray`1<string> aliases, bool referenceOutputAssembly);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Aliases();
    [CompilerGeneratedAttribute]
public bool get_ReferenceOutputAssembly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.MSBuild.PropertyNames : object {
    public static string AllowUnsafeBlocks;
    public static string AppConfigForCompiler;
    public static string BaseAddress;
    public static string BuildProjectReferences;
    public static string BuildingInsideVisualStudio;
    public static string BuildingProject;
    public static string CheckForOverflowUnderflow;
    public static string CodePage;
    public static string ContinueOnError;
    public static string DebugSymbols;
    public static string DebugType;
    public static string DefineConstants;
    public static string DelaySign;
    public static string DesignTimeBuild;
    public static string DocFileItem;
    public static string ErrorReport;
    public static string Features;
    public static string FileAlignment;
    public static string FinalDefineConstants;
    public static string FrameworkPathOverride;
    public static string GenerateDocumentation;
    public static string GenerateFullPaths;
    public static string HighEntropyVA;
    public static string IntermediateAssembly;
    public static string KeyContainerName;
    public static string KeyOriginatorFile;
    public static string LangVersion;
    public static string ModuleAssemblyName;
    public static string NoCompilerStandardLib;
    public static string NonExistentFile;
    public static string NoWarn;
    public static string _NoWarnings;
    public static string Optimize;
    public static string OptionCompare;
    public static string OptionExplicit;
    public static string OptionInfer;
    public static string OptionStrict;
    public static string OptionStrictType;
    public static string OutputType;
    public static string PdbFile;
    public static string PlatformTarget;
    public static string Prefer32Bit;
    public static string ProjectAssetsFile;
    public static string ProvideCommandLineArgs;
    public static string RemoveIntegerChecks;
    public static string ResolvedCodeAnalysisRuleSet;
    public static string RootNamespace;
    public static string ShouldUnsetParentConfigurationAndPlatform;
    public static string SignAssembly;
    public static string SkipCompilerExecution;
    public static string StartupObject;
    public static string SubsystemVersion;
    public static string TargetCompactFramework;
    public static string TargetFramework;
    public static string TargetFrameworks;
    public static string TargetFrameworkIdentifier;
    public static string TargetFrameworkVersion;
    public static string TargetPath;
    public static string TargetRefPath;
    public static string TreatWarningsAsErrors;
    public static string VbRuntime;
    public static string WarningLevel;
    public static string WarningsAsErrors;
    public static string WarningsNotAsErrors;
    public static string ChecksumAlgorithm;
}
internal static class Microsoft.CodeAnalysis.MSBuild.PropertyValues : object {
    [NullableAttribute("1")]
public static string ErrorAndContinue;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
internal class Microsoft.CodeAnalysis.MSBuild.Request : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TargetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<JToken> <Parameters>k__BackingField;
    public int Id { get; public set; }
    public int TargetObject { get; public set; }
    [RequiredMemberAttribute]
public string Method { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[RequiredMemberAttribute]
public ImmutableArray`1<JToken> Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(int value);
    [CompilerGeneratedAttribute]
public int get_TargetObject();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TargetObject(int value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Method(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<JToken> get_Parameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Parameters(ImmutableArray`1<JToken> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.Response : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exception>k__BackingField;
    public int Id { get; public set; }
    public JToken Value { get; public set; }
    public string Exception { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(int value);
    [CompilerGeneratedAttribute]
public JToken get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(JToken value);
    [CompilerGeneratedAttribute]
public string get_Exception();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Exception(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.RpcServer : object {
    private TextWriter _sendingStream;
    private SemaphoreSlim _sendingStreamSemaphore;
    private TextReader _receivingStream;
    private ConcurrentDictionary`2<int, object> _rpcTargets;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _nextRpcTargetIndex;
    private CancellationTokenSource _shutdownTokenSource;
    public RpcServer(Stream sendingStream, Stream receivingStream);
    public int AddTarget(object rpcTarget);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.RpcServer/<RunAsync>d__8")]
public Task RunAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.RpcServer/<ProcessRequestAsync>d__9")]
private Task ProcessRequestAsync(Request request);
    public void Shutdown();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.MSBuild.TargetNames : object {
    public static string Compile;
    public static string CoreCompile;
    public static string DesignTimeMarkupCompilation;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.MSBuild.TextReaderExtensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MSBuild.TextReaderExtensions/<TryReadLineOrReturnNullIfCancelledAsync>d__0")]
[ExtensionAttribute]
public static Task`1<string> TryReadLineOrReturnNullIfCancelledAsync(TextReader streamReader, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.VisualBasicCommandLineArgumentReader : CommandLineArgumentReader {
    public VisualBasicCommandLineArgumentReader(ProjectInstance project);
    public static ImmutableArray`1<string> Read(ProjectInstance project);
    protected virtual void ReadCore();
    private void ReadDoc();
    private void ReadOptions();
    private void ReadVbRuntime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.VisualBasicProjectFile : ProjectFile {
    public VisualBasicProjectFile(VisualBasicProjectFileLoader loader, Project loadedProject, ProjectBuildManager buildManager, DiagnosticLog log);
    protected virtual IEnumerable`1<ITaskItem> GetCompilerCommandLineArgs(ProjectInstance executedProject);
    protected virtual ImmutableArray`1<string> ReadCommandLineArgs(ProjectInstance project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.MSBuild.VisualBasicProjectFileLoader : ProjectFileLoader {
    public string Language { get; }
    public virtual string get_Language();
    protected virtual ProjectFile CreateProjectFile(Project project, ProjectBuildManager buildManager, DiagnosticLog log);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObject`1 : ValueType {
    private Action`2<ObjectPool`1<T>, T> _releaser;
    private ObjectPool`1<T> _pool;
    private T _pooledObject;
    public T Object { get; }
    public PooledObject`1(ObjectPool`1<T> pool, Func`2<ObjectPool`1<T>, T> allocator, Action`2<ObjectPool`1<T>, T> releaser);
    [IsReadOnlyAttribute]
public T get_Object();
    public sealed virtual void Dispose();
    public static PooledObject`1<StringBuilder> Create(ObjectPool`1<StringBuilder> pool);
    public static PooledObject`1<Stack`1<TItem>> Create(ObjectPool`1<Stack`1<TItem>> pool);
    public static PooledObject`1<Queue`1<TItem>> Create(ObjectPool`1<Queue`1<TItem>> pool);
    public static PooledObject`1<HashSet`1<TItem>> Create(ObjectPool`1<HashSet`1<TItem>> pool);
    public static PooledObject`1<Dictionary`2<TKey, TValue>> Create(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    public static PooledObject`1<List`1<TItem>> Create(ObjectPool`1<List`1<TItem>> pool);
    public static PooledObject`1<SegmentedList`1<TItem>> Create(ObjectPool`1<SegmentedList`1<TItem>> pool);
    private static StringBuilder Allocator(ObjectPool`1<StringBuilder> pool);
    private static void Releaser(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    private static Stack`1<TItem> Allocator(ObjectPool`1<Stack`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Stack`1<TItem>> pool, Stack`1<TItem> obj);
    private static Queue`1<TItem> Allocator(ObjectPool`1<Queue`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Queue`1<TItem>> pool, Queue`1<TItem> obj);
    private static HashSet`1<TItem> Allocator(ObjectPool`1<HashSet`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1<TItem> obj);
    private static Dictionary`2<TKey, TValue> Allocator(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    private static void Releaser(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> obj);
    private static List`1<TItem> Allocator(ObjectPool`1<List`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<List`1<TItem>> pool, List`1<TItem> obj);
    private static SegmentedList`1<TItem> Allocator(ObjectPool`1<SegmentedList`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<SegmentedList`1<TItem>> pool, SegmentedList`1<TItem> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1 : object {
    public static int PooledArrayLengthLimitExclusive;
    private Builder<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public int Capacity { get; public set; }
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsEmpty { get; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public ImmutableArray`1<T> ToImmutableAndClear();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsEmpty();
    public void SetItem(int index, T value);
    public sealed virtual void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public int FindIndex(Func`3<T, TArg, bool> match, TArg arg);
    public int FindIndex(int startIndex, Func`3<T, TArg, bool> match, TArg arg);
    public int FindIndex(int startIndex, int count, Func`3<T, TArg, bool> match, TArg arg);
    public sealed virtual bool Remove(T element);
    public void RemoveAt(int index);
    public void RemoveRange(int index, int length);
    public void RemoveLast();
    public void RemoveAll(Predicate`1<T> match);
    public void RemoveAll(Func`3<T, TArg, bool> match, TArg arg);
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public sealed virtual void CopyTo(T[] array, int start);
    public T Last();
    [NullableContextAttribute("2")]
internal T LastOrDefault();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutable();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutableAndFree();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items, Func`2<U, T> selector);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ArrayBuilder`1<U> items, int start, int length);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<T> items, int start, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public void SortAndRemoveDuplicates(IComparer`1<T> comparer);
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
}
internal interface Microsoft.CodeAnalysis.PooledObjects.IPooled {
    public abstract virtual void Free();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1 : object {
    [NullableAttribute("2")]
private T _firstItem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Element[] _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Factory<T> _factory;
    public bool TrimOnFree;
    internal ObjectPool`1(Factory<T> factory, bool trimOnFree);
    internal ObjectPool`1(Factory<T> factory, int size, bool trimOnFree);
    internal ObjectPool`1(Func`2<ObjectPool`1<T>, T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PooledObjects.PooledDelegates : object {
    private static Releaser GetPooledDelegate(TUnboundDelegate unboundDelegate, TArg argument, TBoundDelegate& boundDelegate);
    public static Releaser GetPooledAction(Action`1<TArg> unboundAction, TArg argument, Action& boundAction);
    public static Releaser GetPooledAction(Action`2<T1, TArg> unboundAction, TArg argument, Action`1& boundAction);
    public static Releaser GetPooledAction(Action`3<T1, T2, TArg> unboundAction, TArg argument, Action`2& boundAction);
    [NullableContextAttribute("2")]
public static Releaser GetPooledAction(Action`4<T1, T2, T3, TArg> unboundAction, TArg argument, Action`3& boundAction);
    public static Releaser GetPooledFunction(Func`2<TArg, TResult> unboundFunction, TArg argument, Func`1& boundFunction);
    public static Releaser GetPooledCreateValueCallback(Func`3<TKey, TArg, TValue> unboundFunction, TArg argument, CreateValueCallback& boundFunction);
    public static Releaser GetPooledFunction(Func`3<T1, TArg, TResult> unboundFunction, TArg argument, Func`2& boundFunction);
    [NullableContextAttribute("2")]
public static Releaser GetPooledFunction(Func`4<T1, T2, TArg, TResult> unboundFunction, TArg argument, Func`3& boundFunction);
    [NullableContextAttribute("2")]
public static Releaser GetPooledFunction(Func`5<T1, T2, T3, TArg, TResult> unboundFunction, TArg argument, Func`4& boundFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledDictionary`2();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public ImmutableDictionary`2<K, V> ToImmutableDictionary();
    public void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledDisposer`1 : ValueType {
    [CompilerGeneratedAttribute]
private TPoolable <instance>P;
    public PooledDisposer`1(TPoolable instance);
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool, IEqualityComparer`1<T> equalityComparer);
    private static PooledHashSet`1();
    public static PooledDisposer`1<PooledHashSet`1<T>> GetInstance(PooledHashSet`1& instance);
    public sealed virtual void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool(IEqualityComparer`1<T> equalityComparer);
    public static PooledHashSet`1<T> GetInstance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool(int size);
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
}
internal class Microsoft.CodeAnalysis.ReadOnlyMemoryOfCharComparer : object {
    public static ReadOnlyMemoryOfCharComparer Instance;
    private static ReadOnlyMemoryOfCharComparer();
    public static bool Equals(ReadOnlySpan`1<char> x, ReadOnlyMemory`1<char> y);
    public sealed virtual bool Equals(ReadOnlyMemory`1<char> x, ReadOnlyMemory`1<char> y);
    public sealed virtual int GetHashCode(ReadOnlyMemory`1<char> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream : Stream {
    private object _memoryOwner;
    private IntPtr _data;
    private int _length;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyUnmanagedMemoryStream(object memoryOwner, IntPtr data, int length);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RoslynExperiments : object {
    internal static string NullableDisabledSemanticModel;
    internal static string NullableDisabledSemanticModel_Url;
    internal static string Interceptors;
    internal static string Interceptors_Url;
    internal static string SyntaxTokenParser;
    internal static string SyntaxTokenParser_Url;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SerializableBytes : object {
    private static int ChunkSize;
    internal static PooledStream CreateReadableStream(Byte[] bytes);
    internal static PooledStream CreateReadableStream(Byte[] bytes, int length);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SerializableBytes/<CreateReadableStreamAsync>d__3")]
internal static Task`1<PooledStream> CreateReadableStreamAsync(Stream stream, CancellationToken cancellationToken);
    private static void BlowChunks(Byte[][] chunks);
    internal static ReadWriteStream CreateWritableStream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1 : ValueType {
    private static int InlineCapacity;
    private T _item0;
    private T _item1;
    private T _item2;
    private T _item3;
    private int _count;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TemporaryArray`1<T> Empty { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private TemporaryArray`1(TemporaryArray`1& array);
    public static TemporaryArray`1<T> GetInstance(int capacity);
    public static TemporaryArray`1<T> get_Empty();
    [IsReadOnlyAttribute]
public int get_Count();
    [IsReadOnlyAttribute]
public T get_Item(int index);
    public void set_Item(int index, T value);
    public sealed virtual void Dispose();
    public void Add(T item);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(TemporaryArray`1& items);
    public void Clear();
    public T RemoveLast();
    [IsReadOnlyAttribute]
public bool Contains(T value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public OneOrMany`1<T> ToOneOrManyAndClear();
    public ImmutableArray`1<T> ToImmutableAndClear();
    [MemberNotNullAttribute("_builder")]
private void MoveInlineToBuilder();
    public void ReverseContents();
    public void Sort(Comparison`1<T> compare);
    private static void ThrowIndexOutOfRangeException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SharedPoolExtensions : object {
    private static int Threshold;
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool, StringBuilder& builder);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Queue`1<TItem>> GetPooledObject(ObjectPool`1<Queue`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<SegmentedList`1<TItem>> GetPooledObject(ObjectPool`1<SegmentedList`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool, Stack`1& stack);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool, List`1& list);
    [ExtensionAttribute]
public static PooledObject`1<SegmentedList`1<TItem>> GetPooledObject(ObjectPool`1<SegmentedList`1<TItem>> pool, SegmentedList`1& list);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1& set);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2& dictionary);
    [ExtensionAttribute]
public static PooledObject`1<T> GetPooledObject(ObjectPool`1<T> pool);
    [ExtensionAttribute]
public static StringBuilder AllocateAndClear(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static Stack`1<T> AllocateAndClear(ObjectPool`1<Stack`1<T>> pool);
    [ExtensionAttribute]
public static Queue`1<T> AllocateAndClear(ObjectPool`1<Queue`1<T>> pool);
    [ExtensionAttribute]
public static HashSet`1<T> AllocateAndClear(ObjectPool`1<HashSet`1<T>> pool);
    [ExtensionAttribute]
public static SegmentedHashSet`1<T> AllocateAndClear(ObjectPool`1<SegmentedHashSet`1<T>> pool);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AllocateAndClear(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static List`1<T> AllocateAndClear(ObjectPool`1<List`1<T>> pool);
    [ExtensionAttribute]
public static SegmentedList`1<T> AllocateAndClear(ObjectPool`1<SegmentedList`1<T>> pool);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<HashSet`1<T>> pool, HashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<SegmentedHashSet`1<T>> pool, SegmentedHashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<ConcurrentSet`1<T>> pool, ConcurrentSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stack`1<T>> pool, Stack`1<T> stack);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<ConcurrentStack`1<T>> pool, ConcurrentStack`1<T> stack);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Queue`1<T>> pool, Queue`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<ConcurrentDictionary`2<TKey, TValue>> pool, ConcurrentDictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<List`1<T>> pool, List`1<T> list, bool trim);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<SegmentedList`1<T>> pool, SegmentedList`1<T> list, bool trim);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SharedPools : object {
    public static ObjectPool`1<HashSet`1<string>> StringIgnoreCaseHashSet;
    public static ObjectPool`1<HashSet`1<string>> StringHashSet;
    public static ObjectPool`1<Byte[]> ByteArray;
    public static int ByteBufferSize;
    private static int ByteBufferCount;
    private static SharedPools();
    public static ObjectPool`1<T> BigDefault();
    public static ObjectPool`1<T> Default();
    public static ObjectPool`1<Dictionary`2<string, T>> StringIgnoreCaseDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SpanUtilities : object {
    [ExtensionAttribute]
public static bool All(ReadOnlySpan`1<TElement> span, TParam param, Func`3<TElement, TParam, bool> predicate);
    [ExtensionAttribute]
public static bool All(ReadOnlySpan`1<TElement> span, Func`2<TElement, bool> predicate);
}
internal static class Microsoft.CodeAnalysis.StackGuard : object {
    public static int MaxUncheckedRecursionDepth;
    [DebuggerStepThroughAttribute]
public static void EnsureSufficientExecutionStack(int recursionDepth);
}
internal enum Microsoft.CodeAnalysis.ThreeState : Enum {
    public byte value__;
    public static ThreeState Unknown;
    public static ThreeState False;
    public static ThreeState True;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ThreeStateHelpers : object {
    [ExtensionAttribute]
public static ThreeState ToThreeState(bool value);
    [ExtensionAttribute]
public static bool HasValue(ThreeState value);
    [ExtensionAttribute]
public static bool Value(ThreeState value);
}
internal static class Microsoft.CodeAnalysis.WorkspaceMSBuildBuildHostResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Parameter_cannot_be_null_empty_or_contain_whitespace { get; }
    internal static string Project_does_not_contain_0_target { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Parameter_cannot_be_null_empty_or_contain_whitespace();
    internal static string get_Project_does_not_contain_0_target();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ArrayExtensions : object {
    [ExtensionAttribute]
internal static T[] Copy(T[] array, int start, int length);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T item);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T[] items);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T[] items);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position, int length);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, int length, T[] items);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array, int start, int count);
    [ExtensionAttribute]
internal static int BinarySearch(Int32[] array, int value);
    [ExtensionAttribute]
public static bool SequenceEqual(T[] first, T[] second, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
internal static int BinarySearchUpperBound(Int32[] array, int value);
}
internal static class Roslyn.Utilities.BitArithmeticUtilities : object {
    public static int CountBits(int v);
    public static int CountBits(UInt32 v);
    public static int CountBits(long v);
    public static int CountBits(ulong v);
    internal static UInt32 Align(UInt32 position, UInt32 alignment);
    internal static int Align(int position, int alignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.BlobBuildingStream : Stream {
    private static ObjectPool`1<BlobBuildingStream> s_pool;
    private BlobBuilder _builder;
    public static int ChunkSize;
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private static BlobBuildingStream();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public static BlobBuildingStream GetInstance();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public void WriteInt32(int value);
    public Blob ReserveBytes(int byteCount);
    [NullableContextAttribute("0")]
public ImmutableArray`1<byte> ToImmutableArray();
    public void Free();
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal class Roslyn.Utilities.CharMemoryEqualityComparer : object {
    [NullableAttribute("1")]
public static CharMemoryEqualityComparer Instance;
    private static CharMemoryEqualityComparer();
    public sealed virtual bool Equals(ReadOnlyMemory`1<char> x, ReadOnlyMemory`1<char> y);
    public sealed virtual int GetHashCode(ReadOnlyMemory`1<char> mem);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.CommandLineUtilities : object {
    public static List`1<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments);
    public static List`1<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments, Nullable`1& illegalChar);
    public static void SplitCommandLineIntoArguments(ReadOnlySpan`1<char> commandLine, bool removeHashComments, StringBuilder builder, List`1<string> list, Nullable`1& illegalChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.CompilerOptionParseUtilities : object {
    public static IList`1<string> ParseFeatureFromMSBuild(string features);
    public static void ParseFeatures(IDictionary`2<string, string> builder, List`1<string> values);
    private static void ParseFeatureCore(IDictionary`2<string, string> builder, string feature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ConcurrentDictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(ConcurrentDictionary`2<K, V> dict, K key, V value);
    [ExtensionAttribute]
public static TValue GetOrAdd(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    [ExtensionAttribute]
public static TValue AddOrUpdate(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, Func`3<TKey, TArg, TValue> addValueFactory, Func`4<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Roslyn.Utilities.ConcurrentSet`1 : object {
    private static int DefaultConcurrencyLevel;
    private static int DefaultCapacity;
    private ConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    public ConcurrentSet`1(IEqualityComparer`1<T> equalityComparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Contains(T value);
    public bool Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public sealed virtual bool Remove(T value);
    public sealed virtual void Clear();
    [NullableContextAttribute("0")]
public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.ConcurrentSet`1/<GetEnumeratorImpl>d__18")]
private IEnumerator`1<T> GetEnumeratorImpl();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ConfiguredYieldAwaitable : ValueType {
    private YieldAwaitable _awaitable;
    private bool _continueOnCapturedContext;
    public ConfiguredYieldAwaitable(YieldAwaitable awaitable, bool continueOnCapturedContext);
    public ConfiguredYieldAwaiter GetAwaiter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ConsList`1 : object {
    public static ConsList`1<T> Empty;
    [NullableAttribute("2")]
private T _head;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConsList`1<T> _tail;
    [DebuggerBrowsableAttribute("0")]
public T Head { get; }
    [DebuggerBrowsableAttribute("0")]
public ConsList`1<T> Tail { get; }
    public ConsList`1(T head, ConsList`1<T> tail);
    private static ConsList`1();
    public T get_Head();
    public ConsList`1<T> get_Tail();
    public bool Any();
    public ConsList`1<T> Push(T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Contract : object {
    [NullableContextAttribute("2")]
public static void ThrowIfNull(T value, int lineNumber, string filePath);
    [NullableContextAttribute("0")]
public static void ThrowIfNull(Nullable`1<T> value, int lineNumber, string filePath);
    public static void ThrowIfNull(T value, string message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfNull(T value, ThrowIfNullInterpolatedStringHandler`1<T> message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfFalse(bool condition, int lineNumber, string filePath);
    public static void ThrowIfFalse(bool condition, string message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfFalse(bool condition, ThrowIfFalseInterpolatedStringHandler message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfTrue(bool condition, int lineNumber, string filePath);
    public static void ThrowIfTrue(bool condition, string message, int lineNumber, string filePath);
    [NullableContextAttribute("2")]
public static void ThrowIfTrue(bool condition, ThrowIfTrueInterpolatedStringHandler message, int lineNumber, string filePath);
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
public static void Fail(string message, int lineNumber, string filePath);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.DecimalUtilities : object {
    [ExtensionAttribute]
public static int GetScale(decimal value);
    [ExtensionAttribute]
public static void GetBits(decimal value, Boolean& isNegative, Byte& scale, UInt32& low, UInt32& mid, UInt32& high);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.DocumentationCommentXmlNames : object {
    public static string CElementName;
    public static string CodeElementName;
    public static string CompletionListElementName;
    public static string DescriptionElementName;
    public static string ExampleElementName;
    public static string ExceptionElementName;
    public static string IncludeElementName;
    public static string InheritdocElementName;
    public static string ItemElementName;
    public static string ListElementName;
    public static string ListHeaderElementName;
    public static string ParaElementName;
    public static string ParameterElementName;
    public static string ParameterReferenceElementName;
    public static string PermissionElementName;
    public static string PlaceholderElementName;
    public static string PreliminaryElementName;
    public static string RemarksElementName;
    public static string ReturnsElementName;
    public static string SeeElementName;
    public static string SeeAlsoElementName;
    public static string SummaryElementName;
    public static string TermElementName;
    public static string ThreadSafetyElementName;
    public static string TypeParameterElementName;
    public static string TypeParameterReferenceElementName;
    public static string ValueElementName;
    public static string CrefAttributeName;
    public static string HrefAttributeName;
    public static string FileAttributeName;
    public static string InstanceAttributeName;
    public static string LangwordAttributeName;
    public static string NameAttributeName;
    public static string PathAttributeName;
    public static string StaticAttributeName;
    public static string TypeAttributeName;
    public static bool ElementEquals(string name1, string name2, bool fromVb);
    public static bool AttributeEquals(string name1, string name2);
    public static bool Equals(object left, object right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.EmptyComparer : object {
    public static EmptyComparer Instance;
    private static EmptyComparer();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.EnumerableExtensions : object {
    private static Func`2<object, bool> s_notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static int Count(IEnumerable`1<T> source, Func`3<T, TArg, bool> predicate, TArg arg);
    [ExtensionAttribute]
public static IEnumerable`1<T> Do(IEnumerable`1<T> source, Action`1<T> action);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArrayOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToBoxedImmutableArray(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<ConcatWorker>d__6`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> ConcatWorker(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> ToCollection(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static T FirstOrDefault(IEnumerable`1<T> source, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> FirstOrNull(IEnumerable`1<T> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> FirstOrNull(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> FirstOrNull(IEnumerable`1<T> source, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> LastOrNull(IEnumerable`1<T> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> SingleOrNull(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool IsSingle(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(IReadOnlyCollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(string source);
    [ExtensionAttribute]
public static bool IsEmpty(T[] source);
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> source);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IEnumerable`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IReadOnlyCollection`1<TSource> source, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(IEnumerable`1<TItem> source, Func`3<TItem, TArg, IEnumerable`1<TResult>> selector, TArg arg);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(IReadOnlyCollection`1<TItem> source, Func`2<TItem, IEnumerable`1<TResult>> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectManyAsArray(IReadOnlyCollection`1<TItem> source, Func`3<TItem, TArg, IEnumerable`1<TResult>> selector, TArg arg);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectAsArrayAsync>d__35`2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(IEnumerable`1<TItem> source, Func`2<TItem, ValueTask`1<TResult>> selector);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectAsArrayAsync>d__36`2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(IEnumerable`1<TItem> source, Func`3<TItem, CancellationToken, ValueTask`1<TResult>> selector, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectAsArrayAsync>d__37`3")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(IEnumerable`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<TResult>> selector, TArg arg, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectManyAsArrayAsync>d__38`3")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectManyAsArrayAsync(IEnumerable`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<IEnumerable`1<TResult>>> selector, TArg arg, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectManyInParallelAsync>d__39`2")]
[ExtensionAttribute]
public static ValueTask`1<IEnumerable`1<TResult>> SelectManyInParallelAsync(IEnumerable`1<TItem> sequence, Func`3<TItem, CancellationToken, Task`1<IEnumerable`1<TResult>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<bool> source);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> sequence, T value);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> sequence, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
private static int EnumeratingIndexOf(IEnumerable`1<T> sequence, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> sequence);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderByDescending(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderByDescending(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> sequence, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Contains(IEnumerable`1<string> sequence, string s);
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items, IEqualityComparer`1<K> keyComparer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static IList`1<IList`1<T>> Transpose(IEnumerable`1<IEnumerable`1<T>> data);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<TransposeInternal>d__61`1")]
[ExtensionAttribute]
private static IEnumerable`1<IList`1<T>> TransposeInternal(IEnumerable`1<IEnumerable`1<T>> data);
    [ExtensionAttribute]
internal static Dictionary`2<K, ImmutableArray`1<T>> ToMultiDictionary(IEnumerable`1<T> data, Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static TSource AsSingleton(IEnumerable`1<TSource> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Roslyn.Utilities.EnumField : ValueType {
    public static IComparer`1<EnumField> Comparer;
    public string Name;
    public ulong Value;
    [NullableAttribute("2")]
public object IdentityOpt;
    public bool IsDefault { get; }
    public EnumField(string name, ulong value, object identityOpt);
    private static EnumField();
    public bool get_IsDefault();
    private string GetDebuggerDisplay();
    internal static EnumField FindValue(ArrayBuilder`1<EnumField> sortedFields, ulong value);
}
internal static class Roslyn.Utilities.EnumUtilities : object {
    internal static T[] GetValues();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.ExceptionUtilities : object {
    internal static Exception UnexpectedValue(object o);
    internal static Exception Unreachable(string path, int line);
    internal static bool IsCurrentOperationBeingCancelled(Exception exception, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.FileNameUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    [NullableContextAttribute("0")]
private static int IndexOfExtension(ReadOnlySpan`1<char> path);
    internal static string GetExtension(string path);
    [NullableContextAttribute("0")]
internal static ReadOnlyMemory`1<char> GetExtension(ReadOnlyMemory`1<char> path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path, bool includeExtension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.FileUtilities : object {
    private static Char[] s_invalidPathChars;
    private static FileUtilities();
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory, IEnumerable`1<string> searchPaths, Func`2<string, bool> fileExists);
    [NullableContextAttribute("2")]
internal static string ResolveRelativePath(string path, string baseDirectory);
    [NullableContextAttribute("2")]
internal static string ResolveRelativePath(string path, string basePath, string baseDirectory);
    [NullableContextAttribute("2")]
private static string ResolveRelativePath(PathKind kind, string path, string basePath, string baseDirectory);
    [NullableContextAttribute("2")]
private static string GetBaseDirectory(string basePath, string baseDirectory);
    internal static string GetNormalizedPathOrOriginalPath(string path, string basePath);
    [NullableContextAttribute("2")]
internal static string NormalizeRelativePath(string path, string basePath, string baseDirectory);
    internal static string NormalizeAbsolutePath(string path);
    internal static string NormalizeDirectoryPath(string path);
    internal static string TryNormalizeAbsolutePath(string path);
    internal static Stream OpenRead(string fullPath);
    internal static Stream OpenAsyncRead(string fullPath);
    public static T RethrowExceptionsAsIOException(Func`1<T> operation);
    public static T RethrowExceptionsAsIOException(Func`2<TArg, T> operation, TArg arg);
    public static Task`1<T> RethrowExceptionsAsIOExceptionAsync(Func`1<Task`1<T>> operation);
    [AsyncStateMachineAttribute("Roslyn.Utilities.FileUtilities/<RethrowExceptionsAsIOExceptionAsync>d__16`2")]
public static Task`1<T> RethrowExceptionsAsIOExceptionAsync(Func`2<TArg, Task`1<T>> operation, TArg arg);
    internal static Stream CreateFileStreamChecked(Func`2<string, Stream> factory, string path, string paramName);
    internal static DateTime GetFileTimeStamp(string fullPath);
    internal static long GetFileLength(string fullPath);
    internal static void GetFileLengthAndTimeStamp(string fullPath, Int64& fileLength, DateTime& timeStamp);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Functions`1 : object {
    public static Func`2<T, T> Identity;
    public static Func`2<T, bool> True;
    private static Functions`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    [NullableContextAttribute("2")]
internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(ImmutableDictionary`2<TKey, TValue> values, int maxItemsToHash);
    [NullableContextAttribute("2")]
internal static int CombineValues(T[] values, int maxItemsToHash);
    [NullableContextAttribute("2")]
internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ReadOnlySpan`1<byte> data, Boolean& isAscii);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ReadOnlySpan`1<char> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetCaseInsensitiveFNVHashCode(string text);
    [NullableContextAttribute("0")]
internal static int GetCaseInsensitiveFNVHashCode(ReadOnlySpan`1<char> data);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
    [NullableContextAttribute("0")]
internal static int CombineFNVHash(int hashCode, ReadOnlySpan`1<char> data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(HashSet`1<T> set);
    [ExtensionAttribute]
public static bool Contains(ImmutableArray`1<T> items, T item, IEqualityComparer`1<T> equalityComparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArrayOrEmpty(T[] items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> TakeAsArray(ImmutableArray`1<T> array, int count);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableAndClear(Builder<T> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableListExtensions : object {
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(IEnumerable`1<T> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ImmutableSetWithInsertionOrder`1 : object {
    public static ImmutableSetWithInsertionOrder`1<T> Empty;
    private ImmutableDictionary`2<T, UInt32> _map;
    private UInt32 _nextElementValue;
    public int Count { get; }
    public IEnumerable`1<T> InInsertionOrder { get; }
    private ImmutableSetWithInsertionOrder`1(ImmutableDictionary`2<T, UInt32> map, UInt32 nextElementValue);
    private static ImmutableSetWithInsertionOrder`1();
    public int get_Count();
    public bool Contains(T value);
    public ImmutableSetWithInsertionOrder`1<T> Add(T value);
    public ImmutableSetWithInsertionOrder`1<T> Remove(T value);
    public IEnumerable`1<T> get_InInsertionOrder();
    public virtual string ToString();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IncrementalHashExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void AppendData(IncrementalHash hash, IEnumerable`1<Blob> blobs);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void AppendData(IncrementalHash hash, IEnumerable`1<ArraySegment`1<byte>> blobs);
    [ExtensionAttribute]
internal static void AppendData(IncrementalHash hash, ArraySegment`1<byte> segment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.InterlockedOperations : object {
    private static T GetOrStore(T& target, T value);
    private static int GetOrStore(Int32& target, int value, int uninitializedValue);
    public static T Initialize(T& target, Func`1<T> valueFactory);
    public static T Initialize(T& target, Func`2<TArg, T> valueFactory, TArg arg);
    public static int Initialize(Int32& target, int uninitializedValue, Func`2<TArg, int> valueFactory, TArg arg);
    [NullableContextAttribute("2")]
public static T Initialize(StrongBox`1& target, Func`1<T> valueFactory);
    [NullableContextAttribute("2")]
public static T Initialize(StrongBox`1& target, Func`2<TArg, T> valueFactory, TArg arg);
    public static T Initialize(T& target, T value);
    public static T Initialize(T& target, T initializedValue, T uninitializedValue);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Initialize(ImmutableArray`1& target, ImmutableArray`1<T> initializedValue);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Initialize(ImmutableArray`1& target, Func`1<ImmutableArray`1<T>> createArray);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Initialize(ImmutableArray`1& target, Func`2<TArg, ImmutableArray`1<T>> createArray, TArg arg);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<T> Initialize_Slow(ImmutableArray`1& target, Func`2<TArg, ImmutableArray`1<T>> createArray, TArg arg);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IReadOnlyListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Contains(IReadOnlyList`1<T> list, T item, IEqualityComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ISetExtensions : object {
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, ImmutableArray`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, ImmutableArray`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.JsonWriter : object {
    private TextWriter _output;
    private int _indent;
    private Pending _pending;
    private static string Indentation;
    public JsonWriter(TextWriter output);
    public void WriteObjectStart();
    public void WriteObjectStart(string key);
    public void WriteObjectEnd();
    public void WriteArrayStart();
    public void WriteArrayStart(string key);
    public void WriteArrayEnd();
    public void WriteKey(string key);
    public void Write(string key, string value);
    public void Write(string key, int value);
    public void Write(string key, Nullable`1<int> value);
    public void Write(string key, bool value);
    public void Write(string key, Nullable`1<bool> value);
    [NullableContextAttribute("0")]
public void Write(string key, T value);
    [NullableContextAttribute("0")]
public void WriteInvariant(T value);
    [NullableContextAttribute("0")]
public void WriteInvariant(string key, T value);
    public void WriteNull(string key);
    public void WriteNull();
    [NullableContextAttribute("2")]
public void Write(string value);
    public void Write(int value);
    public void Write(Nullable`1<int> value);
    public void Write(bool value);
    public void Write(Nullable`1<bool> value);
    [NullableContextAttribute("0")]
public void Write(T value);
    [NullableContextAttribute("0")]
public void Write(Nullable`1<T> value);
    private void WritePending();
    private void WriteStart(char c);
    private void WriteEnd(char c);
    public sealed virtual void Dispose();
    internal static string EscapeString(string value);
    private static void AppendCharAsUnicode(StringBuilder builder, char c);
    private static bool ShouldAppendAsUnicode(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.KeyValuePairUtil : object {
    public static KeyValuePair`2<K, V> Create(K key, V value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> keyValuePair, TKey& key, TValue& value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static KeyValuePair`2<TKey, TValue> ToKeyValuePair(ValueTuple`2<TKey, TValue> tuple);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.MultiDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<K, ValueSet<K, V>> _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<V> _valueComparer;
    [NullableAttribute("0")]
private ValueSet<K, V> _emptySet;
    public int Count { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<K, ValueSet<K, V>> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<K, ValueSet<K, V>> Values { get; }
    [NullableAttribute("0")]
public ValueSet<K, V> Item { get; }
    public MultiDictionary`2(IEqualityComparer`1<K> comparer);
    public MultiDictionary`2(int capacity, IEqualityComparer`1<K> comparer, IEqualityComparer`1<V> valueComparer);
    public int get_Count();
    public bool get_IsEmpty();
    public KeyCollection<K, ValueSet<K, V>> get_Keys();
    public ValueCollection<K, ValueSet<K, V>> get_Values();
    [NullableContextAttribute("0")]
public ValueSet<K, V> get_Item(K k);
    public void EnsureCapacity(int capacity);
    public bool Add(K k, V v);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<K, ValueSet<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,Roslyn.Utilities.MultiDictionary<K,V>.ValueSet>>.GetEnumerator();
    public bool ContainsKey(K k);
    internal void Clear();
    public void Remove(K key);
}
[AttributeUsageAttribute("16392")]
internal class Roslyn.Utilities.NonCopyableAttribute : Attribute {
}
[AttributeUsageAttribute("16392")]
internal class Roslyn.Utilities.NonDefaultableAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.OneOrMany : object {
    public static OneOrMany`1<T> Create(T one);
    public static OneOrMany`1<T> Create(T one, T two);
    [NullableContextAttribute("2")]
public static OneOrMany`1<T> OneOrNone(T one);
    [NullableContextAttribute("2")]
public static OneOrMany`1<T> Create(ImmutableArray`1<T> many);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<T> array, OneOrMany`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> array, OneOrMany`1<T> other, IEqualityComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
[DebuggerTypeProxyAttribute("Roslyn.Utilities.OneOrMany`1/DebuggerProxy")]
internal class Roslyn.Utilities.OneOrMany`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OneOrMany`1<T> Empty;
    [NullableAttribute("2")]
private T _one;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<T> _many;
    [MemberNotNullWhenAttribute("True", "_one")]
private bool HasOneItem { get; }
    public bool IsDefault { get; }
    public T Item { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public OneOrMany`1(T one);
    public OneOrMany`1(ImmutableArray`1<T> many);
    private static OneOrMany`1();
    [MemberNotNullWhenAttribute("True", "_one")]
private bool get_HasOneItem();
    public bool get_IsDefault();
    public T get_Item(int index);
    public int get_Count();
    public bool get_IsEmpty();
    public OneOrMany`1<T> Add(T item);
    public bool Contains(T item);
    public OneOrMany`1<T> RemoveAll(T item);
    public OneOrMany`1<TResult> Select(Func`2<T, TResult> selector);
    public OneOrMany`1<TResult> Select(Func`3<T, TArg, TResult> selector, TArg arg);
    public T First();
    [NullableContextAttribute("2")]
public T FirstOrDefault();
    public T FirstOrDefault(Func`2<T, bool> predicate);
    public T FirstOrDefault(Func`3<T, TArg, bool> predicate, TArg arg);
    public static OneOrMany`1<T> CastUp(OneOrMany`1<TDerived> from);
    public bool All(Func`2<T, bool> predicate);
    public bool All(Func`3<T, TArg, bool> predicate, TArg arg);
    public bool Any();
    public bool Any(Func`2<T, bool> predicate);
    public bool Any(Func`3<T, TArg, bool> predicate, TArg arg);
    public ImmutableArray`1<T> ToImmutable();
    public T[] ToArray();
    public bool SequenceEqual(OneOrMany`1<T> other, IEqualityComparer`1<T> comparer);
    public bool SequenceEqual(ImmutableArray`1<T> other, IEqualityComparer`1<T> comparer);
    public bool SequenceEqual(IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.OrderedMultiDictionary`2 : object {
    private Dictionary`2<K, SetWithInsertionOrder`1<V>> _dictionary;
    private List`1<K> _keys;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public SetWithInsertionOrder`1<V> Item { get; }
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public SetWithInsertionOrder`1<V> get_Item(K k);
    public void Add(K k, V v);
    public void AddRange(K k, IEnumerable`1<V> values);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.OrderedMultiDictionary`2/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<KeyValuePair`2<K, SetWithInsertionOrder`1<V>>> GetEnumerator();
}
internal enum Roslyn.Utilities.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.PathUtilities : object {
    internal static char AltDirectorySeparatorChar;
    internal static string ParentRelativeDirectory;
    internal static string ThisDirectory;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static Char[] s_pathChars;
    public static IEqualityComparer`1<string> Comparer;
    internal static char DirectorySeparatorChar { get; }
    internal static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    internal static char get_DirectorySeparatorChar();
    internal static bool get_IsUnixLikePlatform();
    public static bool IsDirectorySeparator(char c);
    public static bool IsAnyDirectorySeparator(char c);
    public static string TrimTrailingSeparators(string s);
    public static string EnsureTrailingSeparator(string s);
    public static string GetExtension(string path);
    [NullableContextAttribute("0")]
public static ReadOnlyMemory`1<char> GetExtension(ReadOnlyMemory`1<char> path);
    public static string ChangeExtension(string path, string extension);
    public static string RemoveExtension(string path);
    [NullableContextAttribute("2")]
public static string GetFileName(string path, bool includeExtension);
    [NullableContextAttribute("2")]
public static string GetDirectoryName(string path);
    [NullableContextAttribute("2")]
internal static string GetDirectoryName(string path, bool isUnixLike);
    internal static bool IsSameDirectoryOrChildOf(string child, string parent, StringComparison comparison);
    [NullableContextAttribute("2")]
public static string GetPathRoot(string path);
    [NullableContextAttribute("2")]
private static string GetPathRoot(string path, bool isUnixLike);
    private static string GetWindowsRoot(string path);
    private static int ConsumeDirectorySeparators(string path, int length, int i);
    private static string GetUnixRoot(string path);
    [NullableContextAttribute("2")]
public static PathKind GetPathKind(string path);
    [NullableContextAttribute("2")]
public static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    public static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    [NullableContextAttribute("2")]
public static string CombinePossiblyRelativeAndRelativePaths(string root, string relativePath);
    public static string CombinePathsUnchecked(string root, string relativePath);
    [NullableContextAttribute("2")]
public static string CombinePaths(string root, string path);
    private static string RemoveTrailingDirectorySeparator(string path);
    public static bool IsFilePath(string assemblyDisplayNameOrPath);
    public static bool ContainsPathComponent(string path, string component, bool ignoreCase);
    public static string GetRelativePath(string directory, string fullPath);
    public static bool IsChildPath(string parentPath, string childPath);
    private static string GetRelativeChildPath(string parentPath, string childPath);
    private static String[] GetPathParts(string path);
    public static bool PathsEqual(string path1, string path2);
    private static bool PathsEqual(string path1, string path2, int length);
    private static bool PathCharEqual(char x, char y);
    [NullableContextAttribute("2")]
private static int PathHashCode(string path);
    public static string NormalizePathPrefix(string filePath, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    public static string NormalizeDriveLetter(string filePath);
    [NullableContextAttribute("2")]
public static bool IsValidFilePath(string fullPath);
    public static string NormalizeWithForwardSlash(string p);
    [NullableContextAttribute("0")]
public static string CollapseWithForwardSlash(ReadOnlySpan`1<char> path);
    public static string ExpandAbsolutePathWithRelativeParts(string p);
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowImplicitBoxing { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitBoxing();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitBoxing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
internal static class Roslyn.Utilities.PlatformInformation : object {
    [SupportedOSPlatformGuardAttribute("windows")]
public static bool IsWindows { get; }
    public static bool IsUnix { get; }
    public static bool IsRunningOnMono { get; }
    public static bool IsUsingMonoRuntime { get; }
    public static bool get_IsWindows();
    public static bool get_IsUnix();
    public static bool get_IsRunningOnMono();
    public static bool get_IsUsingMonoRuntime();
}
internal static class Roslyn.Utilities.Predicates`1 : object {
    [NullableAttribute("1")]
public static Predicate`1<T> True;
    private static Predicates`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
internal static ReadLockExiter DisposableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static UpgradeableReadLockExiter DisposableUpgradeableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static WriteLockExiter DisposableWrite(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanWrite(ReaderWriterLockSlim lock);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ReferenceEqualityComparer : object {
    [NullableAttribute("1")]
public static ReferenceEqualityComparer Instance;
    private static ReferenceEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object a);
    public static int GetHashCode(object a);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReflectionUtilities : object {
    private static Type Missing;
    private static ReflectionUtilities();
    public static Type TryGetType(string assemblyQualifiedName);
    [NullableContextAttribute("2")]
public static Type TryGetType(Type& lazyType, string assemblyQualifiedName);
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static Type GetTypeFromEither(Type& lazyType, string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static object InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static T Invoke(MethodInfo methodInfo, object obj, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
    [ConditionalAttribute("DEBUG")]
public static void AssertNotNull(T value);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
internal static void AssertOrFailFast(bool condition, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynLazyInitializer : object {
    public static T EnsureInitialized(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    [NullableContextAttribute("2")]
public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    [NullableContextAttribute("2")]
public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynParallel : object {
    internal static ParallelOptions DefaultParallelOptions;
    private static RoslynParallel();
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`1<int> body, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynString : object {
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SemaphoreSlimExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SemaphoreDisposer DisposableWait(SemaphoreSlim semaphore, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SemaphoreSlimExtensions/<DisposableWaitAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<SemaphoreDisposer> DisposableWaitAsync(SemaphoreSlim semaphore, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.SetWithInsertionOrder`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<T> _set;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<T> _elements;
    public int Count { get; }
    public T Item { get; }
    private IReadOnlySet`1<T> Set { get; }
    public bool Add(T value);
    public bool Insert(int index, T value);
    public bool Remove(T value);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableArray`1<T> AsImmutable();
    public sealed virtual T get_Item(int i);
    private IReadOnlySet`1<T> get_Set();
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.SharedStopwatch : ValueType {
    private static Stopwatch s_stopwatch;
    private TimeSpan _started;
    public TimeSpan Elapsed { get; }
    private SharedStopwatch(TimeSpan started);
    private static SharedStopwatch();
    public TimeSpan get_Elapsed();
    public static SharedStopwatch StartNew();
    private static SharedStopwatch StartNewCore();
}
[NonCopyableAttribute]
internal class Roslyn.Utilities.SingleInitNullable`1 : ValueType {
    private int _initialized;
    private T _value;
    public T Initialize(Func`2<TArg, T> valueFactory, TArg arg);
    private Nullable`1<T> ReadIfInitialized();
    private T GetOrStore(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.SpecializedCollections : object {
    public static IEnumerator`1<T> EmptyEnumerator();
    public static IEnumerable`1<T> EmptyEnumerable();
    public static ICollection`1<T> EmptyCollection();
    public static IList`1<T> EmptyList();
    public static IReadOnlyList`1<T> EmptyBoxedImmutableArray();
    public static IReadOnlyList`1<T> EmptyReadOnlyList();
    public static ISet`1<T> EmptySet();
    public static IReadOnlySet`1<T> EmptyReadOnlySet();
    public static IDictionary`2<TKey, TValue> EmptyDictionary();
    public static IReadOnlyDictionary`2<TKey, TValue> EmptyReadOnlyDictionary();
    public static IEnumerable`1<T> SingletonEnumerable(T value);
    public static ICollection`1<T> SingletonCollection(T value);
    public static IEnumerator`1<T> SingletonEnumerator(T value);
    public static IReadOnlyList`1<T> SingletonReadOnlyList(T value);
    public static IList`1<T> SingletonList(T value);
    public static IEnumerable`1<T> ReadOnlyEnumerable(IEnumerable`1<T> values);
    public static ICollection`1<T> ReadOnlyCollection(ICollection`1<T> collection);
    public static ISet`1<T> ReadOnlySet(ISet`1<T> set);
    public static IReadOnlySet`1<T> StronglyTypedReadOnlySet(ISet`1<T> set);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.StreamExtensions : object {
    [ExtensionAttribute]
public static int TryReadAll(Stream stream, Byte[] buffer, int offset, int count);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_lazyNumerals;
    private static Func`2<char, char> s_toLower;
    private static Func`2<char, char> s_toUpper;
    private static string AttributeSuffix;
    private static StringExtensions();
    internal static string GetNumeral(int number);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static bool LooksLikeInterfaceName(string name);
    [ExtensionAttribute]
public static bool LooksLikeTypeParameterName(string name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string ToPascalCase(string shortName, bool trimLeadingTypePrefix);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string ToCamelCase(string shortName, bool trimLeadingTypePrefix);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static string ConvertCase(string shortName, bool trimLeadingTypePrefix, Func`2<char, char> convert);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsValidClrTypeName(string name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsValidClrNamespaceName(string name);
    [ExtensionAttribute]
internal static string GetWithSingleAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, String& result);
    [ExtensionAttribute]
internal static string GetWithoutAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, bool isCaseSensitive, String& result);
    [ExtensionAttribute]
internal static bool HasAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool IsValidUnicodeString(string str);
    [ExtensionAttribute]
internal static string Unquote(string arg);
    [ExtensionAttribute]
internal static string Unquote(string arg, Boolean& quoted);
    [ExtensionAttribute]
internal static char First(string arg);
    [ExtensionAttribute]
internal static char Last(string arg);
    [ExtensionAttribute]
internal static bool All(string arg, Predicate`1<char> predicate);
    [ExtensionAttribute]
public static int GetCaseInsensitivePrefixLength(string string1, string string2);
    [ExtensionAttribute]
public static int GetCaseSensitivePrefixLength(string string1, string string2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.StringOrdinalComparer : object {
    public static StringOrdinalComparer Instance;
    private static StringOrdinalComparer();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.String>.Equals(string a, string b);
    [NullableContextAttribute("2")]
public static bool Equals(string a, string b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.String>.GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.StringTable : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    private Entry[] _localTable;
    [NullableAttribute("0")]
private static SegmentedArray`1<Entry> s_sharedTable;
    private int _localRandom;
    private static int s_sharedRandom;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<StringTable> _pool;
    private static ObjectPool`1<StringTable> s_staticPool;
    private StringTable(ObjectPool`1<StringTable> pool);
    private static StringTable();
    private static ObjectPool`1<StringTable> CreatePool();
    public static StringTable GetInstance();
    public void Free();
    internal string Add(Char[] chars, int start, int len);
    internal string Add(string chars, int start, int len);
    internal string Add(char chars);
    internal string Add(StringBuilder chars);
    internal string Add(string chars);
    private static string FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    private static string FindSharedEntry(string chars, int start, int len, int hashCode);
    [NullableContextAttribute("0")]
private static string FindSharedEntryASCII(int hashCode, ReadOnlySpan`1<byte> asciiChars);
    [NullableContextAttribute("2")]
private static string FindSharedEntry(char chars, int hashCode);
    private static string FindSharedEntry(StringBuilder chars, int hashCode);
    private static string FindSharedEntry(string chars, int hashCode);
    private string AddItem(Char[] chars, int start, int len, int hashCode);
    private string AddItem(string chars, int start, int len, int hashCode);
    private string AddItem(char chars, int hashCode);
    private string AddItem(StringBuilder chars, int hashCode);
    private void AddCore(string chars, int hashCode);
    private void AddSharedEntry(int hashCode, string text);
    internal static string AddShared(StringBuilder chars);
    private static string AddSharedSlow(int hashCode, StringBuilder builder);
    [NullableContextAttribute("0")]
internal static string AddSharedUtf8(ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("0")]
private static string AddSharedSlow(int hashCode, ReadOnlySpan`1<byte> utf8Bytes, bool isAscii);
    private static void AddSharedSlow(int hashCode, string text);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int LocalNextRandom();
    private static int SharedNextRandom();
    internal static bool TextEquals(string array, string text, int start, int length);
    internal static bool TextEquals(string array, StringBuilder text);
    [NullableContextAttribute("0")]
internal static bool TextEqualsASCII(string text, ReadOnlySpan`1<byte> ascii);
    [NullableContextAttribute("0")]
internal static bool TextEquals(string array, ReadOnlySpan`1<char> text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.TextKeyedCache`1 : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`3[] _localTable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] s_sharedTable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _sharedTableInst;
    private StringTable _strings;
    [NullableAttribute("2")]
private Random _random;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<TextKeyedCache`1<T>> _pool;
    private static ObjectPool`1<TextKeyedCache`1<T>> s_staticPool;
    private TextKeyedCache`1(ObjectPool`1<TextKeyedCache`1<T>> pool);
    private static TextKeyedCache`1();
    private static ObjectPool`1<TextKeyedCache`1<T>> CreatePool();
    public static TextKeyedCache`1<T> GetInstance();
    public void Free();
    internal T FindItem(Char[] chars, int start, int len, int hashCode);
    private SharedEntryValue<T> FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    internal void AddItem(Char[] chars, int start, int len, int hashCode, T item);
    private void AddSharedEntry(int hashCode, SharedEntryValue<T> e);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int NextRandom();
}
internal static class Roslyn.Utilities.ThreadSafeFlagOperations : object {
    public static bool Set(Int32& flags, int toSet);
    public static bool Clear(Int32& flags, int toClear);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.UICultureUtilities : object {
    private static string currentUICultureName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`1<CultureInfo> s_setCurrentUICulture;
    private static UICultureUtilities();
    private static bool TryGetCurrentUICultureSetter(Action`1& setter);
    private static bool TryGetCurrentThreadUICultureSetter(Action`1& setter);
    public static Action WithCurrentUICulture(Action action);
    public static Action`1<T> WithCurrentUICulture(Action`1<T> action);
    public static Func`1<T> WithCurrentUICulture(Func`1<T> func);
}
internal static class Roslyn.Utilities.UnicodeCharacterUtilities : object {
    public static bool IsIdentifierStartCharacter(char ch);
    public static bool IsIdentifierPartCharacter(char ch);
    [NullableContextAttribute("2")]
public static bool IsValidIdentifier(string name);
    private static bool IsLetterChar(UnicodeCategory cat);
    private static bool IsCombiningChar(UnicodeCategory cat);
    private static bool IsDecimalDigitChar(UnicodeCategory cat);
    private static bool IsConnectingChar(UnicodeCategory cat);
    internal static bool IsFormattingChar(char ch);
    private static bool IsFormattingChar(UnicodeCategory cat);
}
internal static class Roslyn.Utilities.ValueTaskFactory : object {
    public static ValueTask CompletedTask { get; }
    [NullableContextAttribute("1")]
public static ValueTask`1<T> FromResult(T result);
    public static ValueTask get_CompletedTask();
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.VoidResult : ValueType {
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VoidResult other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.WeakList`1 : object {
    private WeakReference`1[] _items;
    private int _size;
    private static int MinimalNonEmptySize;
    public int WeakCount { get; }
    internal WeakReference`1[] TestOnly_UnderlyingArray { get; }
    private void Resize();
    private void Shrink(int firstDead, int alive);
    private static int GetExpandedSize(int baseSize);
    private void Compact(int firstDead, WeakReference`1[] result);
    public int get_WeakCount();
    public WeakReference`1<T> GetWeakReference(int index);
    public void Add(T item);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    internal WeakReference`1[] get_TestOnly_UnderlyingArray();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.WeakReferenceExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T GetTarget(WeakReference`1<T> reference);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNull(WeakReference`1<T> reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.XmlUtilities : object {
    [ExtensionAttribute]
internal static TNode Copy(TNode node, bool copyAttributeAnnotations);
    private static void CopyAnnotations(XObject source, XObject target);
    internal static XElement[] TrySelectElements(XNode node, string xpath, String& errorMessage, Boolean& invalidXPath);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.YieldAwaitableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredYieldAwaitable ConfigureAwait(YieldAwaitable awaitable, bool continueOnCapturedContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
internal class System.Diagnostics.CodeAnalysis.ExperimentalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string DiagnosticId { get; }
    [NullableAttribute("2")]
public string UrlFormat { get; public set; }
    public ExperimentalAttribute(string diagnosticId);
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_UrlFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Linq.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static T AggregateOrDefault(IEnumerable`1<T> source, Func`3<T, T, T> func);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Linq.ImmutableSegmentedListExtensions : object {
    [ExtensionAttribute]
public static bool All(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Any(ImmutableSegmentedList`1<T> immutableList);
    [ExtensionAttribute]
public static bool Any(Builder<T> builder);
    [ExtensionAttribute]
public static bool Any(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Last(ImmutableSegmentedList`1<T> immutableList);
    [ExtensionAttribute]
public static T Last(Builder<T> builder);
    [ExtensionAttribute]
public static T Last(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(ImmutableSegmentedList`1<T> immutableList, Func`2<T, TResult> selector);
}
[ExtensionAttribute]
internal static class System.Linq.RoslynEnumerable : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SegmentedList`1<TSource> ToSegmentedList(IEnumerable`1<TSource> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
internal class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
