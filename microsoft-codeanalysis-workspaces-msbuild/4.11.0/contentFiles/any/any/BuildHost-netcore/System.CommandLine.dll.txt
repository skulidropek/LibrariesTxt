[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.AliasSet : object {
    private HashSet`1<string> _aliases;
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal AliasSet(String[] aliases);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string item);
    internal bool Overlaps(AliasSet other);
    public Enumerator<string> GetEnumerator();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(string item);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual bool Remove(string item);
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("\{{MinimumNumberOfValues},{MaximumNumberOfValues}\}")]
public class System.CommandLine.ArgumentArity : ValueType {
    private static int MaximumArity;
    [CompilerGeneratedAttribute]
private int <MinimumNumberOfValues>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumNumberOfValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNonDefault>k__BackingField;
    public int MinimumNumberOfValues { get; }
    public int MaximumNumberOfValues { get; }
    internal bool IsNonDefault { get; }
    public static ArgumentArity Zero { get; }
    public static ArgumentArity ZeroOrOne { get; }
    public static ArgumentArity ExactlyOne { get; }
    public static ArgumentArity ZeroOrMore { get; }
    public static ArgumentArity OneOrMore { get; }
    public ArgumentArity(int minimumNumberOfValues, int maximumNumberOfValues);
    [CompilerGeneratedAttribute]
public int get_MinimumNumberOfValues();
    [CompilerGeneratedAttribute]
public int get_MaximumNumberOfValues();
    [CompilerGeneratedAttribute]
internal bool get_IsNonDefault();
    public sealed virtual bool Equals(ArgumentArity other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
internal static bool Validate(ArgumentResult argumentResult, ArgumentConversionResult& error);
    public static ArgumentArity get_Zero();
    public static ArgumentArity get_ZeroOrOne();
    public static ArgumentArity get_ExactlyOne();
    public static ArgumentArity get_ZeroOrMore();
    public static ArgumentArity get_OneOrMore();
    [NullableContextAttribute("1")]
internal static ArgumentArity Default(CliArgument argument, SymbolNode firstParent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.ArgumentValidation : object {
    [ExtensionAttribute]
public static CliArgument`1<FileInfo> AcceptExistingOnly(CliArgument`1<FileInfo> argument);
    [ExtensionAttribute]
public static CliArgument`1<DirectoryInfo> AcceptExistingOnly(CliArgument`1<DirectoryInfo> argument);
    [ExtensionAttribute]
public static CliArgument`1<FileSystemInfo> AcceptExistingOnly(CliArgument`1<FileSystemInfo> argument);
    [ExtensionAttribute]
public static CliArgument`1<T> AcceptExistingOnly(CliArgument`1<T> argument);
    private static void FileOrDirectoryExists(ArgumentResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.ArgumentConversionResult : object {
    internal ArgumentResult ArgumentResult;
    [NullableAttribute("2")]
internal object Value;
    [NullableAttribute("2")]
internal string ErrorMessage;
    internal ArgumentConversionResultType Result;
    private ArgumentConversionResult(ArgumentResult argumentResult, string error, ArgumentConversionResultType failure);
    private ArgumentConversionResult(ArgumentResult argumentResult, object value, ArgumentConversionResultType result);
    internal static ArgumentConversionResult Failure(ArgumentResult argumentResult, string error, ArgumentConversionResultType reason);
    internal static ArgumentConversionResult ArgumentConversionCannotParse(ArgumentResult argumentResult, Type expectedType, string value);
    public static ArgumentConversionResult Success(ArgumentResult argumentResult, object value);
    internal static ArgumentConversionResult None(ArgumentResult argumentResult);
    private static string FormatErrorMessage(ArgumentResult argumentResult, Type expectedType, string value);
}
internal enum System.CommandLine.Binding.ArgumentConversionResultType : Enum {
    public int value__;
    public static ArgumentConversionResultType NoArgument;
    public static ArgumentConversionResultType Successful;
    public static ArgumentConversionResultType Failed;
    public static ArgumentConversionResultType FailedArity;
    public static ArgumentConversionResultType FailedType;
    public static ArgumentConversionResultType FailedTooManyArguments;
    public static ArgumentConversionResultType FailedMissingArgument;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Binding.ArgumentConverter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<Type, TryConvertString> _stringConverters;
    private static Dictionary`2<Type, TryConvertString> StringConverters { get; }
    internal static ArgumentConversionResult ConvertObject(ArgumentResult argumentResult, Type type, object value);
    private static ArgumentConversionResult ConvertToken(ArgumentResult argumentResult, Type type, CliToken token);
    private static ArgumentConversionResult ConvertTokens(ArgumentResult argumentResult, Type type, IReadOnlyList`1<CliToken> tokens);
    internal static TryConvertArgument GetConverter(CliArgument argument);
    [ExtensionAttribute]
private static bool CanBeBoundFromScalarValue(Type type);
    [ExtensionAttribute]
internal static ArgumentConversionResult ConvertIfNeeded(ArgumentConversionResult conversionResult, Type toType);
    [ExtensionAttribute]
internal static T GetValueOrDefault(ArgumentConversionResult result);
    public static bool TryConvertArgument(ArgumentResult argumentResult, Object& value);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL3050")]
private static Array CreateArray(Type itemType, int capacity);
    private static IList CreateEmptyList(Type listType);
    internal static IList CreateEnumerable(Type type, Type itemType, int capacity);
    private static Dictionary`2<Type, TryConvertString> get_StringConverters();
    [CompilerGeneratedAttribute]
internal static bool <GetConverter>g__ConvertSingleString|3_2(ArgumentResult result, TryConvertString convert, Object& value);
}
internal class System.CommandLine.Binding.TryConvertArgument : MulticastDelegate {
    public TryConvertArgument(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(ArgumentResult argumentResult, Object& value);
    public virtual IAsyncResult BeginInvoke(ArgumentResult argumentResult, Object& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Object& value, IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Binding.TypeExtensions : object {
    [ExtensionAttribute]
internal static Type GetElementTypeIfEnumerable(Type type);
    [ExtensionAttribute]
internal static bool IsEnumerable(Type type);
    [ExtensionAttribute]
internal static bool IsNullable(Type t);
    [ExtensionAttribute]
internal static bool TryGetNullableType(Type type, Type& nullableType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class System.CommandLine.ChildSymbolList`1 : object {
    private List`1<T> _children;
    private CliCommand _parent;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ChildSymbolList`1(CliCommand parent);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.CliArgument : CliSymbol {
    private ArgumentArity _arity;
    [NullableAttribute("2")]
private TryConvertArgument _convertArguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Func`2<CompletionContext, IEnumerable`1<CompletionItem>>> _completionSources;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Action`1<ArgumentResult>> _validators;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <HelpName>k__BackingField;
    public ArgumentArity Arity { get; public set; }
    [NullableAttribute("2")]
public string HelpName { get; public set; }
    [NullableAttribute("2")]
internal TryConvertArgument ConvertArguments { get; internal set; }
    public List`1<Func`2<CompletionContext, IEnumerable`1<CompletionItem>>> CompletionSources { get; }
    public Type ValueType { get; }
    public List`1<Action`1<ArgumentResult>> Validators { get; }
    internal bool HasValidators { get; }
    public bool HasDefaultValue { get; }
    private protected CliArgument(string name);
    public ArgumentArity get_Arity();
    public void set_Arity(ArgumentArity value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_HelpName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_HelpName(string value);
    [NullableContextAttribute("2")]
internal TryConvertArgument get_ConvertArguments();
    [NullableContextAttribute("2")]
internal void set_ConvertArguments(TryConvertArgument value);
    public List`1<Func`2<CompletionContext, IEnumerable`1<CompletionItem>>> get_CompletionSources();
    public abstract virtual Type get_ValueType();
    public List`1<Action`1<ArgumentResult>> get_Validators();
    internal bool get_HasValidators();
    [NullableContextAttribute("2")]
public object GetDefaultValue();
    internal abstract virtual object GetDefaultValue(ArgumentResult argumentResult);
    public abstract virtual bool get_HasDefaultValue();
    public virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
    public virtual string ToString();
    internal bool IsBoolean();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.CliArgument`1 : CliArgument {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ArgumentResult, T> _customParser;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<ArgumentResult, T> <DefaultValueFactory>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<ArgumentResult, T> DefaultValueFactory { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<ArgumentResult, T> CustomParser { get; public set; }
    public Type ValueType { get; }
    public bool HasDefaultValue { get; }
    public CliArgument`1(string name);
    [CompilerGeneratedAttribute]
public Func`2<ArgumentResult, T> get_DefaultValueFactory();
    [CompilerGeneratedAttribute]
public void set_DefaultValueFactory(Func`2<ArgumentResult, T> value);
    public Func`2<ArgumentResult, T> get_CustomParser();
    public void set_CustomParser(Func`2<ArgumentResult, T> value);
    public virtual Type get_ValueType();
    public virtual bool get_HasDefaultValue();
    internal virtual object GetDefaultValue(ArgumentResult argumentResult);
    public void AcceptOnlyFromAmong(String[] values);
    public void AcceptLegalFilePathsOnly();
    public void AcceptLegalFileNamesOnly();
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL3050")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2091")]
internal static T CreateDefaultValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.CliCommand : CliSymbol {
    [NullableAttribute("2")]
internal AliasSet _aliases;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ChildSymbolList`1<CliArgument> _arguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ChildSymbolList`1<CliOption> _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ChildSymbolList`1<CliCommand> _subcommands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Action`1<CommandResult>> _validators;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CliAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatUnmatchedTokensAsErrors>k__BackingField;
    public IEnumerable`1<CliSymbol> Children { get; }
    public IList`1<CliArgument> Arguments { get; }
    internal bool HasArguments { get; }
    public IList`1<CliOption> Options { get; }
    internal bool HasOptions { get; }
    public IList`1<CliCommand> Subcommands { get; }
    internal bool HasSubcommands { get; }
    public List`1<Action`1<CommandResult>> Validators { get; }
    internal bool HasValidators { get; }
    public ICollection`1<string> Aliases { get; }
    [NullableAttribute("2")]
public CliAction Action { get; public set; }
    public bool TreatUnmatchedTokensAsErrors { get; public set; }
    public CliCommand(string name, string description);
    [IteratorStateMachineAttribute("System.CommandLine.CliCommand/<get_Children>d__7")]
public IEnumerable`1<CliSymbol> get_Children();
    public IList`1<CliArgument> get_Arguments();
    internal bool get_HasArguments();
    public IList`1<CliOption> get_Options();
    internal bool get_HasOptions();
    public IList`1<CliCommand> get_Subcommands();
    internal bool get_HasSubcommands();
    public List`1<Action`1<CommandResult>> get_Validators();
    internal bool get_HasValidators();
    public ICollection`1<string> get_Aliases();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CliAction get_Action();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Action(CliAction value);
    public void SetAction(Action`1<ParseResult> action);
    public void SetAction(Func`2<ParseResult, int> action);
    public void SetAction(Func`3<ParseResult, CancellationToken, Task> action);
    public void SetAction(Func`3<ParseResult, CancellationToken, Task`1<int>> action);
    public void Add(CliArgument argument);
    public void Add(CliOption option);
    public void Add(CliCommand command);
    [CompilerGeneratedAttribute]
public bool get_TreatUnmatchedTokensAsErrors();
    [CompilerGeneratedAttribute]
public void set_TreatUnmatchedTokensAsErrors(bool value);
    [DebuggerStepThroughAttribute]
[EditorBrowsableAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ParseResult Parse(IReadOnlyList`1<string> args, CliConfiguration configuration);
    public ParseResult Parse(string commandLine, CliConfiguration configuration);
    public virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
    internal bool EqualsNameOrAlias(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.CliConfiguration : object {
    [NullableAttribute("2")]
private TextWriter _output;
    [NullableAttribute("2")]
private TextWriter _error;
    [CompilerGeneratedAttribute]
private bool <EnablePosixBundling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDefaultExceptionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ProcessTerminationTimeout>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TryReplaceToken <ResponseFileTokenReplacer>k__BackingField;
    [CompilerGeneratedAttribute]
private CliCommand <RootCommand>k__BackingField;
    internal bool HasDirectives { get; }
    public bool EnablePosixBundling { get; public set; }
    public bool EnableDefaultExceptionHandler { get; public set; }
    public Nullable`1<TimeSpan> ProcessTerminationTimeout { get; public set; }
    [NullableAttribute("2")]
public TryReplaceToken ResponseFileTokenReplacer { get; public set; }
    public CliCommand RootCommand { get; }
    public TextWriter Output { get; public set; }
    public TextWriter Error { get; public set; }
    public CliConfiguration(CliCommand rootCommand);
    internal bool get_HasDirectives();
    [CompilerGeneratedAttribute]
public bool get_EnablePosixBundling();
    [CompilerGeneratedAttribute]
public void set_EnablePosixBundling(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableDefaultExceptionHandler();
    [CompilerGeneratedAttribute]
public void set_EnableDefaultExceptionHandler(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_ProcessTerminationTimeout();
    [CompilerGeneratedAttribute]
public void set_ProcessTerminationTimeout(Nullable`1<TimeSpan> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TryReplaceToken get_ResponseFileTokenReplacer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ResponseFileTokenReplacer(TryReplaceToken value);
    [CompilerGeneratedAttribute]
public CliCommand get_RootCommand();
    public TextWriter get_Output();
    public void set_Output(TextWriter value);
    public TextWriter get_Error();
    public void set_Error(TextWriter value);
    public ParseResult Parse(IReadOnlyList`1<string> args);
    public ParseResult Parse(string commandLine);
    public int Invoke(string commandLine);
    public int Invoke(String[] args);
    public Task`1<int> InvokeAsync(string commandLine, CancellationToken cancellationToken);
    public Task`1<int> InvokeAsync(String[] args, CancellationToken cancellationToken);
    public void ThrowIfInvalid();
    [CompilerGeneratedAttribute]
internal static void <ThrowIfInvalid>g__ThrowIfInvalid|36_0(CliCommand command);
    [CompilerGeneratedAttribute]
internal static CliSymbol <ThrowIfInvalid>g__GetChild|36_1(int index, CliCommand command, AliasSet& aliases);
}
public class System.CommandLine.CliConfigurationException : Exception {
    [NullableContextAttribute("1")]
public CliConfigurationException(string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.CliDirective : CliSymbol {
    [CompilerGeneratedAttribute]
private CliAction <Action>k__BackingField;
    public CliAction Action { get; public set; }
    [NullableContextAttribute("1")]
public CliDirective(string name);
    [CompilerGeneratedAttribute]
public virtual CliAction get_Action();
    [CompilerGeneratedAttribute]
public virtual void set_Action(CliAction value);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.CliOption : CliSymbol {
    [NullableAttribute("2")]
internal AliasSet _aliases;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Action`1<OptionResult>> _validators;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleArgumentsPerToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CliAction <Action>k__BackingField;
    internal CliArgument Argument { get; }
    public bool HasDefaultValue { get; }
    [NullableAttribute("2")]
public string HelpName { get; public set; }
    public ArgumentArity Arity { get; public set; }
    public bool Recursive { get; public set; }
    public List`1<Action`1<OptionResult>> Validators { get; }
    internal bool HasValidators { get; }
    public List`1<Func`2<CompletionContext, IEnumerable`1<CompletionItem>>> CompletionSources { get; }
    public bool AllowMultipleArgumentsPerToken { get; public set; }
    internal bool Greedy { get; }
    public bool Required { get; public set; }
    public ICollection`1<string> Aliases { get; }
    [NullableAttribute("2")]
public CliAction Action { get; public set; }
    private protected CliOption(string name, String[] aliases);
    internal abstract virtual CliArgument get_Argument();
    public bool get_HasDefaultValue();
    [NullableContextAttribute("2")]
public string get_HelpName();
    [NullableContextAttribute("2")]
public void set_HelpName(string value);
    public ArgumentArity get_Arity();
    public void set_Arity(ArgumentArity value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public void set_Recursive(bool value);
    public List`1<Action`1<OptionResult>> get_Validators();
    internal bool get_HasValidators();
    public List`1<Func`2<CompletionContext, IEnumerable`1<CompletionItem>>> get_CompletionSources();
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleArgumentsPerToken();
    [CompilerGeneratedAttribute]
public void set_AllowMultipleArgumentsPerToken(bool value);
    internal virtual bool get_Greedy();
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    public ICollection`1<string> get_Aliases();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual CliAction get_Action();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void set_Action(CliAction value);
    public virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.CliOption`1 : CliOption {
    internal CliArgument`1<T> _argument;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<ArgumentResult, T> DefaultValueFactory { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<ArgumentResult, T> CustomParser { get; public set; }
    internal CliArgument Argument { get; }
    public CliOption`1(string name, String[] aliases);
    private protected CliOption`1(string name, String[] aliases, CliArgument`1<T> argument);
    public Func`2<ArgumentResult, T> get_DefaultValueFactory();
    public void set_DefaultValueFactory(Func`2<ArgumentResult, T> value);
    public Func`2<ArgumentResult, T> get_CustomParser();
    public void set_CustomParser(Func`2<ArgumentResult, T> value);
    internal sealed virtual CliArgument get_Argument();
    public void AcceptOnlyFromAmong(String[] values);
    public void AcceptLegalFilePathsOnly();
    public void AcceptLegalFileNamesOnly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.CliRootCommand : CliCommand {
    [NullableAttribute("2")]
private static Assembly _assembly;
    [NullableAttribute("2")]
private static string _executablePath;
    [NullableAttribute("2")]
private static string _executableName;
    [NullableAttribute("2")]
private static string _executableVersion;
    [CompilerGeneratedAttribute]
private IList`1<CliDirective> <Directives>k__BackingField;
    public IList`1<CliDirective> Directives { get; }
    public static string ExecutableName { get; }
    public static string ExecutablePath { get; }
    internal static string ExecutableVersion { get; }
    public CliRootCommand(string description);
    [CompilerGeneratedAttribute]
public IList`1<CliDirective> get_Directives();
    public void Add(CliDirective directive);
    internal static Assembly GetAssembly();
    public static string get_ExecutableName();
    public static string get_ExecutablePath();
    internal static string get_ExecutableVersion();
    private static string GetExecutableVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.CliSymbol : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SymbolNode <FirstParent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    [NullableAttribute("2")]
public string Description { get; public set; }
    public string Name { get; }
    [NullableAttribute("2")]
internal SymbolNode FirstParent { get; private set; }
    public bool Hidden { get; public set; }
    public IEnumerable`1<CliSymbol> Parents { get; }
    private protected CliSymbol(string name, bool allowWhitespace);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SymbolNode get_FirstParent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_FirstParent(SymbolNode value);
    internal void AddParent(CliSymbol symbol);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(bool value);
    [IteratorStateMachineAttribute("System.CommandLine.CliSymbol/<get_Parents>d__18")]
public IEnumerable`1<CliSymbol> get_Parents();
    public abstract virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
    public virtual string ToString();
    [DebuggerStepThroughAttribute]
internal static string ThrowIfEmptyOrWithWhitespaces(string value, string paramName, bool canContainWhitespaces);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Completions.CompletionAction : SynchronousCliAction {
    private SuggestDirective _directive;
    internal CompletionAction(SuggestDirective suggestDirective);
    public virtual int Invoke(ParseResult parseResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Completions.CompletionContext : object {
    [NullableAttribute("2")]
private static CompletionContext _empty;
    [CompilerGeneratedAttribute]
private string <WordToComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseResult <ParseResult>k__BackingField;
    public string WordToComplete { get; }
    public ParseResult ParseResult { get; }
    public static CompletionContext Empty { get; }
    internal bool IsEmpty { get; }
    internal CompletionContext(ParseResult parseResult);
    internal CompletionContext(ParseResult parseResult, string wordToComplete);
    [CompilerGeneratedAttribute]
public string get_WordToComplete();
    [CompilerGeneratedAttribute]
public ParseResult get_ParseResult();
    public static CompletionContext get_Empty();
    internal bool get_IsEmpty();
    protected static string GetWordToComplete(ParseResult parseResult, Nullable`1<int> position);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.Completions.CompletionItem : object {
    [NullableAttribute("1")]
internal static string KindKeyword;
    [NullableAttribute("1")]
internal static string KindValue;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <SortText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InsertText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Detail>k__BackingField;
    [NullableAttribute("1")]
public string Label { get; }
    public string Kind { get; }
    [NullableAttribute("1")]
public string SortText { get; }
    public string InsertText { get; }
    public string Documentation { get; public set; }
    public string Detail { get; }
    public CompletionItem(string label, string kind, string sortText, string insertText, string documentation, string detail);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public string get_Kind();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_SortText();
    [CompilerGeneratedAttribute]
public string get_InsertText();
    [CompilerGeneratedAttribute]
public string get_Documentation();
    [CompilerGeneratedAttribute]
public void set_Documentation(string value);
    [CompilerGeneratedAttribute]
public string get_Detail();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(CompletionItem other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.Completions.SuggestDirective : CliDirective {
    private CliAction _action;
    public CliAction Action { get; public set; }
    public virtual CliAction get_Action();
    public virtual void set_Action(CliAction value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Completions.TextCompletionContext : CompletionContext {
    [CompilerGeneratedAttribute]
private int <CursorPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLineText>k__BackingField;
    public int CursorPosition { get; }
    public string CommandLineText { get; }
    private TextCompletionContext(ParseResult parseResult, string commandLineText, int cursorPosition);
    internal TextCompletionContext(ParseResult parseResult, string commandLineText);
    [CompilerGeneratedAttribute]
public int get_CursorPosition();
    [CompilerGeneratedAttribute]
public string get_CommandLineText();
    public TextCompletionContext AtCursorPosition(int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.CompletionSourceExtensions : object {
    [ExtensionAttribute]
public static void Add(List`1<Func`2<CompletionContext, IEnumerable`1<CompletionItem>>> completionSources, Func`2<CompletionContext, IEnumerable`1<string>> completionsDelegate);
    [ExtensionAttribute]
public static void Add(List`1<Func`2<CompletionContext, IEnumerable`1<CompletionItem>>> completionSources, String[] completions);
}
internal static class System.CommandLine.ConsoleHelpers : object {
    private static bool ColorsAreSupported;
    private static ConsoleHelpers();
    private static bool GetColorsAreSupported();
    internal static void SetTerminalForegroundRed();
    internal static void ResetTerminalForegroundColor();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.DiagramDirective : CliDirective {
    private CliAction _action;
    [CompilerGeneratedAttribute]
private int <ParseErrorReturnValue>k__BackingField;
    public CliAction Action { get; public set; }
    public int ParseErrorReturnValue { get; public set; }
    public virtual CliAction get_Action();
    public virtual void set_Action(CliAction value);
    [CompilerGeneratedAttribute]
public int get_ParseErrorReturnValue();
    [CompilerGeneratedAttribute]
public void set_ParseErrorReturnValue(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("System.CommandLine.EnumerableExtensions/<FlattenBreadthFirst>d__0`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> FlattenBreadthFirst(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> children);
    [IteratorStateMachineAttribute("System.CommandLine.EnumerableExtensions/<RecurseWhileNotNull>d__1`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> RecurseWhileNotNull(T source, Func`2<T, T> next);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.EnvironmentVariablesDirective : CliDirective {
    private CliAction _action;
    public CliAction Action { get; public set; }
    public virtual CliAction get_Action();
    public virtual void set_Action(CliAction value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Help.HelpAction : SynchronousCliAction {
    [NullableAttribute("2")]
private HelpBuilder _builder;
    public HelpBuilder Builder { get; public set; }
    public HelpBuilder get_Builder();
    public void set_Builder(HelpBuilder value);
    public virtual int Invoke(ParseResult parseResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Help.HelpBuilder : object {
    private static string Indent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<CliSymbol, Customization> _customizationsBySymbol;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<HelpContext, IEnumerable`1<Func`2<HelpContext, bool>>> _getLayout;
    [CompilerGeneratedAttribute]
private int <MaxWidth>k__BackingField;
    public int MaxWidth { get; }
    public HelpBuilder(int maxWidth);
    [CompilerGeneratedAttribute]
public int get_MaxWidth();
    public virtual void Write(HelpContext context);
    public void CustomizeSymbol(CliSymbol symbol, Func`2<HelpContext, string> firstColumnText, Func`2<HelpContext, string> secondColumnText, Func`2<HelpContext, string> defaultValue);
    public void CustomizeLayout(Func`2<HelpContext, IEnumerable`1<Func`2<HelpContext, bool>>> getLayout);
    private string GetUsage(CliCommand command);
    private IEnumerable`1<TwoColumnHelpRow> GetCommandArgumentRows(CliCommand command, HelpContext context);
    private bool WriteSubcommands(HelpContext context);
    private bool WriteAdditionalArguments(HelpContext context);
    [NullableContextAttribute("2")]
private void WriteHeading(string heading, string description, TextWriter writer);
    public void WriteColumns(IReadOnlyList`1<TwoColumnHelpRow> items, HelpContext context);
    private string FormatArgumentUsage(IList`1<CliArgument> arguments);
    private IEnumerable`1<Func`2<HelpContext, bool>> GetLayout(HelpContext context);
    [IteratorStateMachineAttribute("System.CommandLine.Help.HelpBuilder/<WrapText>d__18")]
private static IEnumerable`1<string> WrapText(string text, int maxWidth);
    public TwoColumnHelpRow GetTwoColumnRow(CliSymbol symbol, HelpContext context);
    private string GetArgumentDefaultValue(CliSymbol parent, CliArgument argument, bool displayArgumentName, HelpContext context);
    [NullableContextAttribute("2")]
public void CustomizeSymbol(CliSymbol symbol, string firstColumnText, string secondColumnText, string defaultValue);
    public void Write(CliCommand command, TextWriter writer);
    [IteratorStateMachineAttribute("System.CommandLine.Help.HelpBuilder/<<WriteColumns>g__ZipWithEmpty|15_2>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ValueTuple`2<string, string>> <WriteColumns>g__ZipWithEmpty|15_2(IEnumerable`1<string> first, IEnumerable`1<string> second);
    [CompilerGeneratedAttribute]
internal static bool <FormatArgumentUsage>g__IsOptional|16_0(CliArgument argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Help.HelpContext : object {
    [CompilerGeneratedAttribute]
private HelpBuilder <HelpBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseResult <ParseResult>k__BackingField;
    [CompilerGeneratedAttribute]
private CliCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Output>k__BackingField;
    public HelpBuilder HelpBuilder { get; }
    public ParseResult ParseResult { get; }
    public CliCommand Command { get; }
    public TextWriter Output { get; }
    public HelpContext(HelpBuilder helpBuilder, CliCommand command, TextWriter output, ParseResult parseResult);
    [CompilerGeneratedAttribute]
public HelpBuilder get_HelpBuilder();
    [CompilerGeneratedAttribute]
public ParseResult get_ParseResult();
    [CompilerGeneratedAttribute]
public CliCommand get_Command();
    [CompilerGeneratedAttribute]
public TextWriter get_Output();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.Help.HelpOption : CliOption`1<bool> {
    private CliAction _action;
    public CliAction Action { get; public set; }
    [NullableContextAttribute("1")]
public HelpOption(string name, String[] aliases);
    public virtual CliAction get_Action();
    public virtual void set_Action(CliAction value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Help.TwoColumnHelpRow : object {
    [CompilerGeneratedAttribute]
private string <FirstColumnText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecondColumnText>k__BackingField;
    public string FirstColumnText { get; }
    public string SecondColumnText { get; }
    public TwoColumnHelpRow(string firstColumnText, string secondColumnText);
    [CompilerGeneratedAttribute]
public string get_FirstColumnText();
    [CompilerGeneratedAttribute]
public string get_SecondColumnText();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TwoColumnHelpRow other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.AnonymousAsynchronousCliAction : AsynchronousCliAction {
    private Func`3<ParseResult, CancellationToken, Task`1<int>> _asyncAction;
    internal AnonymousAsynchronousCliAction(Func`3<ParseResult, CancellationToken, Task`1<int>> action);
    public virtual Task`1<int> InvokeAsync(ParseResult parseResult, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.AnonymousSynchronousCliAction : SynchronousCliAction {
    private Func`2<ParseResult, int> _syncAction;
    internal AnonymousSynchronousCliAction(Func`2<ParseResult, int> action);
    public virtual int Invoke(ParseResult parseResult);
}
public abstract class System.CommandLine.Invocation.AsynchronousCliAction : CliAction {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<int> InvokeAsync(ParseResult parseResult, CancellationToken cancellationToken);
}
public abstract class System.CommandLine.Invocation.CliAction : object {
    [CompilerGeneratedAttribute]
private bool <Terminating>k__BackingField;
    public bool Terminating { get; protected set; }
    [CompilerGeneratedAttribute]
public bool get_Terminating();
    [CompilerGeneratedAttribute]
protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Terminating(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.CommandLine.Invocation.InvocationPipeline : object {
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.InvocationPipeline/<InvokeAsync>d__0")]
internal static Task`1<int> InvokeAsync(ParseResult parseResult, CancellationToken cancellationToken);
    internal static int Invoke(ParseResult parseResult);
    private static int DefaultExceptionHandler(Exception exception, CliConfiguration config);
    private static int ReturnCodeForMissingAction(ParseResult parseResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Invocation.ParseErrorAction : SynchronousCliAction {
    [CompilerGeneratedAttribute]
private bool <ShowHelp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowTypoCorrections>k__BackingField;
    private static int MaxLevenshteinDistance;
    public bool ShowHelp { get; public set; }
    public bool ShowTypoCorrections { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ShowHelp();
    [CompilerGeneratedAttribute]
public void set_ShowHelp(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowTypoCorrections();
    [CompilerGeneratedAttribute]
public void set_ShowTypoCorrections(bool value);
    public virtual int Invoke(ParseResult parseResult);
    private static void WriteErrorDetails(ParseResult parseResult);
    private static void WriteHelp(ParseResult parseResult);
    private static void WriteTypoCorrectionSuggestions(ParseResult parseResult);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <WriteTypoCorrectionSuggestions>g__GetPossibleTokens|11_0(CliCommand targetSymbol, string token);
    [CompilerGeneratedAttribute]
internal static int <WriteTypoCorrectionSuggestions>g__GetStartsWithDistance|11_1(string first, string second);
    [CompilerGeneratedAttribute]
internal static int <WriteTypoCorrectionSuggestions>g__GetDistance|11_2(string first, string second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.ProcessTerminationHandler : object {
    private static int SIGINT_EXIT_CODE;
    private static int SIGTERM_EXIT_CODE;
    internal TaskCompletionSource`1<int> ProcessTerminationCompletionSource;
    private CancellationTokenSource _handlerCancellationTokenSource;
    private Task`1<int> _startedHandler;
    private TimeSpan _processTerminationTimeout;
    internal ProcessTerminationHandler(CancellationTokenSource handlerCancellationTokenSource, Task`1<int> startedHandler, TimeSpan processTerminationTimeout);
    public sealed virtual void Dispose();
    private void OnCancelKeyPress(object sender, ConsoleCancelEventArgs e);
    private void OnProcessExit(object sender, EventArgs e);
    private void Cancel(int forcedTerminationExitCode);
}
public abstract class System.CommandLine.Invocation.SynchronousCliAction : CliAction {
    [NullableContextAttribute("1")]
public abstract virtual int Invoke(ParseResult parseResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.CommandLine.LocalizationResources : object {
    internal static string ExpectsOneArgument(OptionResult optionResult);
    internal static string DirectoryDoesNotExist(string path);
    internal static string FileDoesNotExist(string filePath);
    internal static string FileOrDirectoryDoesNotExist(string path);
    internal static string InvalidCharactersInPath(char invalidChar);
    internal static string InvalidCharactersInFileName(char invalidChar);
    internal static string RequiredArgumentMissing(ArgumentResult argumentResult);
    internal static string RequiredArgumentMissing(OptionResult optionResult);
    internal static string RequiredCommandWasNotProvided();
    internal static string RequiredOptionWasNotProvided(string longestAliasWithPrefix);
    internal static string UnrecognizedArgument(string unrecognizedArg, IReadOnlyCollection`1<string> allowedValues);
    internal static string UnrecognizedCommandOrArgument(string arg);
    internal static string ResponseFileNotFound(string filePath);
    internal static string ErrorReadingResponseFile(string filePath, IOException e);
    internal static string HelpOptionDescription();
    internal static string HelpUsageTitle();
    internal static string HelpDescriptionTitle();
    internal static string HelpUsageOptions();
    internal static string HelpUsageCommand();
    internal static string HelpUsageAdditionalArguments();
    internal static string HelpArgumentsTitle();
    internal static string HelpOptionsTitle();
    internal static string HelpOptionsRequiredLabel();
    internal static string HelpArgumentDefaultValueLabel();
    internal static string HelpCommandsTitle();
    internal static string HelpAdditionalArgumentsTitle();
    internal static string HelpAdditionalArgumentsDescription();
    internal static string SuggestionsTokenNotMatched(string token);
    internal static string VersionOptionDescription();
    internal static string VersionOptionCannotBeCombinedWithOtherArguments(string optionAlias);
    internal static string ExceptionHandlerHeader();
    internal static string ArgumentConversionCannotParse(string value, Type expectedType);
    internal static string ArgumentConversionCannotParseForCommand(string value, string commandAlias, Type expectedType);
    internal static string ArgumentConversionCannotParseForCommand(string value, string commandAlias, Type expectedType, IEnumerable`1<string> completions);
    internal static string ArgumentConversionCannotParseForOption(string value, string optionAlias, Type expectedType);
    internal static string ArgumentConversionCannotParseForOption(string value, string optionAlias, Type expectedType, IEnumerable`1<string> completions);
    private static string GetResourceString(string resourceString, Object[] formatArguments);
    private static string GetOptionName(OptionResult optionResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.OptionValidation : object {
    [ExtensionAttribute]
public static CliOption`1<FileInfo> AcceptExistingOnly(CliOption`1<FileInfo> option);
    [ExtensionAttribute]
public static CliOption`1<DirectoryInfo> AcceptExistingOnly(CliOption`1<DirectoryInfo> option);
    [ExtensionAttribute]
public static CliOption`1<FileSystemInfo> AcceptExistingOnly(CliOption`1<FileSystemInfo> option);
    [ExtensionAttribute]
public static CliOption`1<T> AcceptExistingOnly(CliOption`1<T> option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.ParseResult : object {
    private CommandResult _rootCommandResult;
    private IReadOnlyList`1<CliToken> _unmatchedTokens;
    [NullableAttribute("2")]
private CompletionContext _completionContext;
    [NullableAttribute("2")]
private CliAction _action;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<CliAction> _preActions;
    [CompilerGeneratedAttribute]
private CommandResult <CommandResult>k__BackingField;
    [CompilerGeneratedAttribute]
private CliConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ParseError> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CliToken> <Tokens>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CommandLineText>k__BackingField;
    public CommandResult CommandResult { get; }
    public CliConfiguration Configuration { get; }
    public CommandResult RootCommandResult { get; }
    public IReadOnlyList`1<ParseError> Errors { get; }
    public IReadOnlyList`1<CliToken> Tokens { get; }
    [NullableAttribute("2")]
internal string CommandLineText { get; }
    public IReadOnlyList`1<string> UnmatchedTokens { get; }
    [NullableAttribute("2")]
public CliAction Action { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyList`1<CliAction> PreActions { get; }
    internal ParseResult(CliConfiguration configuration, CommandResult rootCommandResult, CommandResult commandResult, List`1<CliToken> tokens, List`1<CliToken> unmatchedTokens, List`1<ParseError> errors, string commandLineText, CliAction action, List`1<CliAction> preActions);
    internal static ParseResult Empty();
    [CompilerGeneratedAttribute]
public CommandResult get_CommandResult();
    [CompilerGeneratedAttribute]
public CliConfiguration get_Configuration();
    public CommandResult get_RootCommandResult();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ParseError> get_Errors();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CliToken> get_Tokens();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_CommandLineText();
    public IReadOnlyList`1<string> get_UnmatchedTokens();
    public CompletionContext GetCompletionContext();
    [NullableContextAttribute("2")]
public T GetValue(CliArgument`1<T> argument);
    [NullableContextAttribute("2")]
public T GetValue(CliOption`1<T> option);
    [NullableContextAttribute("2")]
public T GetValue(string name);
    public virtual string ToString();
    public ArgumentResult GetResult(CliArgument argument);
    public CommandResult GetResult(CliCommand command);
    public OptionResult GetResult(CliOption option);
    public DirectiveResult GetResult(CliDirective directive);
    public SymbolResult GetResult(CliSymbol symbol);
    public IEnumerable`1<CompletionItem> GetCompletions(Nullable`1<int> position);
    public Task`1<int> InvokeAsync(CancellationToken cancellationToken);
    public int Invoke();
    [NullableContextAttribute("2")]
public CliAction get_Action();
    internal IReadOnlyList`1<CliAction> get_PreActions();
    private SymbolResult SymbolToComplete(Nullable`1<int> position);
    [CompilerGeneratedAttribute]
internal static String[] <GetCompletions>g__OptionsWithArgumentLimitReached|36_1(CommandResult commandResult);
    [CompilerGeneratedAttribute]
internal static bool <SymbolToComplete>g__WillAcceptAnArgument|43_1(ParseResult parseResult, Nullable`1<int> position, OptionResult optionResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.ArgumentResult : SymbolResult {
    [NullableAttribute("2")]
private ArgumentConversionResult _conversionResult;
    private bool _onlyTakeHasBeenCalled;
    [CompilerGeneratedAttribute]
private CliArgument <Argument>k__BackingField;
    public CliArgument Argument { get; }
    internal bool ArgumentLimitReached { get; }
    private SymbolResult AppliesToPublicSymbolResult { get; }
    internal ArgumentResult(CliArgument argument, SymbolResultTree symbolResultTree, SymbolResult parent);
    [CompilerGeneratedAttribute]
public CliArgument get_Argument();
    internal bool get_ArgumentLimitReached();
    internal ArgumentConversionResult GetArgumentConversionResult();
    public T GetValueOrDefault();
    public void OnlyTake(int numberOfTokens);
    public virtual string ToString();
    public virtual void AddError(string errorMessage);
    private ArgumentConversionResult ValidateAndConvert(bool useValidators);
    private SymbolResult get_AppliesToPublicSymbolResult();
    [CompilerGeneratedAttribute]
private ArgumentConversionResult <ValidateAndConvert>g__ReportErrorIfNeeded|13_0(ArgumentConversionResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.CommandLine.Parsing.CliParser : object {
    public static ParseResult Parse(CliCommand command, IReadOnlyList`1<string> args, CliConfiguration configuration);
    public static ParseResult Parse(CliCommand command, string commandLine, CliConfiguration configuration);
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.CliParser/<SplitCommandLine>d__2")]
public static IEnumerable`1<string> SplitCommandLine(string commandLine);
    private static ParseResult Parse(CliCommand command, IReadOnlyList`1<string> arguments, string rawInput, CliConfiguration configuration);
    [CompilerGeneratedAttribute]
internal static void <SplitCommandLine>g__Advance|2_0(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <SplitCommandLine>g__CurrentToken|2_1(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static int <SplitCommandLine>g__IndexOfEndOfToken|2_2(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <SplitCommandLine>g__IsAtEndOfInput|2_3(<>c__DisplayClass2_0& );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.CliToken : object {
    internal static int ImplicitPosition;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private CliTokenType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private CliSymbol <Symbol>k__BackingField;
    internal int Position { get; }
    [NullableAttribute("1")]
public string Value { get; }
    internal bool Implicit { get; }
    public CliTokenType Type { get; }
    internal CliSymbol Symbol { get; internal set; }
    [NullableContextAttribute("1")]
public CliToken(string value, CliTokenType type, CliSymbol symbol);
    internal CliToken(string value, CliTokenType type, CliSymbol symbol, int position);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    internal bool get_Implicit();
    [CompilerGeneratedAttribute]
public CliTokenType get_Type();
    [CompilerGeneratedAttribute]
internal CliSymbol get_Symbol();
    [CompilerGeneratedAttribute]
internal void set_Symbol(CliSymbol value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CliToken other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(CliToken left, CliToken right);
    public static bool op_Inequality(CliToken left, CliToken right);
}
public enum System.CommandLine.Parsing.CliTokenType : Enum {
    public int value__;
    public static CliTokenType Argument;
    public static CliTokenType Command;
    public static CliTokenType Option;
    public static CliTokenType DoubleDash;
    public static CliTokenType Directive;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.CommandResult : SymbolResult {
    [CompilerGeneratedAttribute]
private CliCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private CliToken <IdentifierToken>k__BackingField;
    public CliCommand Command { get; }
    public CliToken IdentifierToken { get; }
    public IEnumerable`1<SymbolResult> Children { get; }
    internal CommandResult(CliCommand command, CliToken token, SymbolResultTree symbolResultTree, CommandResult parent);
    [CompilerGeneratedAttribute]
public CliCommand get_Command();
    [CompilerGeneratedAttribute]
public CliToken get_IdentifierToken();
    public IEnumerable`1<SymbolResult> get_Children();
    public virtual string ToString();
    internal virtual bool UseDefaultValueFor(ArgumentResult argumentResult);
    internal void Validate(bool completeValidation);
    private void ValidateOptions(bool completeValidation);
    private void ValidateArguments(bool completeValidation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.DirectiveResult : SymbolResult {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<string> _values;
    [CompilerGeneratedAttribute]
private CliDirective <Directive>k__BackingField;
    [CompilerGeneratedAttribute]
private CliToken <Token>k__BackingField;
    public IReadOnlyList`1<string> Values { get; }
    public CliDirective Directive { get; }
    public CliToken Token { get; }
    internal DirectiveResult(CliDirective directive, CliToken token, SymbolResultTree symbolResultTree);
    public IReadOnlyList`1<string> get_Values();
    [CompilerGeneratedAttribute]
public CliDirective get_Directive();
    [CompilerGeneratedAttribute]
public CliToken get_Token();
    internal void AddValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.OptionResult : SymbolResult {
    [NullableAttribute("2")]
private ArgumentConversionResult _argumentConversionResult;
    [CompilerGeneratedAttribute]
private CliOption <Option>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CliToken <IdentifierToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdentifierTokenCount>k__BackingField;
    public CliOption Option { get; }
    public bool Implicit { get; }
    [NullableAttribute("2")]
public CliToken IdentifierToken { get; }
    public int IdentifierTokenCount { get; internal set; }
    internal bool IsArgumentLimitReached { get; }
    internal ArgumentConversionResult ArgumentConversionResult { get; }
    internal OptionResult(CliOption option, SymbolResultTree symbolResultTree, CliToken token, CommandResult parent);
    [CompilerGeneratedAttribute]
public CliOption get_Option();
    public bool get_Implicit();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CliToken get_IdentifierToken();
    [CompilerGeneratedAttribute]
public int get_IdentifierTokenCount();
    [CompilerGeneratedAttribute]
internal void set_IdentifierTokenCount(int value);
    public virtual string ToString();
    public T GetValueOrDefault();
    internal bool get_IsArgumentLimitReached();
    internal ArgumentConversionResult get_ArgumentConversionResult();
    internal virtual bool UseDefaultValueFor(ArgumentResult argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.ParseDiagramAction : SynchronousCliAction {
    private int _parseErrorReturnValue;
    internal ParseDiagramAction(int parseErrorReturnValue);
    public virtual int Invoke(ParseResult parseResult);
    internal static StringBuilder Diagram(ParseResult parseResult);
    private static void Diagram(StringBuilder builder, SymbolResult symbolResult, ParseResult parseResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.ParseError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SymbolResult <SymbolResult>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public SymbolResult SymbolResult { get; }
    internal ParseError(string message, SymbolResult symbolResult);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SymbolResult get_SymbolResult();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.ParseOperation : object {
    private List`1<CliToken> _tokens;
    private CliConfiguration _configuration;
    [NullableAttribute("2")]
private string _rawInput;
    private SymbolResultTree _symbolResultTree;
    private CommandResult _rootCommandResult;
    private int _index;
    private CommandResult _innermostCommandResult;
    private bool _isHelpRequested;
    private bool _isTerminatingDirectiveSpecified;
    [NullableAttribute("2")]
private CliAction _primaryAction;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<CliAction> _preActions;
    private CliToken CurrentToken { get; }
    public ParseOperation(List`1<CliToken> tokens, CliConfiguration configuration, List`1<string> tokenizeErrors, string rawInput);
    private CliToken get_CurrentToken();
    private void Advance();
    private bool More(CliTokenType& currentTokenType);
    internal ParseResult Parse();
    private void ParseSubcommand();
    private void ParseCommandChildren();
    private void ParseCommandArguments(Int32& currentArgumentCount, Int32& currentArgumentIndex);
    private void ParseOption();
    private void ParseOptionArguments(OptionResult optionResult);
    private void ParseDirectives();
    private void AddPreAction(CliAction action);
    private void AddCurrentTokenToUnmatched();
    private void Validate();
    [CompilerGeneratedAttribute]
private void <ParseDirectives>g__ParseDirective|22_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Parsing.StringExtensions : object {
    [ExtensionAttribute]
internal static bool ContainsCaseInsensitive(string source, string value);
    [ExtensionAttribute]
internal static int IndexOfCaseInsensitive(string source, string value);
    [ExtensionAttribute]
internal static ValueTuple`2<string, string> SplitPrefix(string rawAlias);
    [ExtensionAttribute]
internal static void Tokenize(IReadOnlyList`1<string> args, CliConfiguration configuration, bool inferRootCommand, List`1& tokens, List`1& errors);
    private static bool FirstArgumentIsRootCommand(IReadOnlyList`1<string> args, CliCommand rootCommand, bool inferRootCommand);
    [ExtensionAttribute]
private static string GetReplaceableTokenValue(string arg);
    [ExtensionAttribute]
internal static bool TrySplitIntoSubtokens(string arg, String& first, String& rest);
    internal static bool TryReadResponseFile(string filePath, IReadOnlyList`1& newTokens, String& error);
    [ExtensionAttribute]
private static Dictionary`2<string, CliToken> ValidTokens(CliCommand command);
    [CompilerGeneratedAttribute]
internal static CliToken <Tokenize>g__Argument|3_3(string value, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static CliToken <Tokenize>g__CommandArgument|3_4(string value, CliCommand command, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static CliToken <Tokenize>g__OptionArgument|3_5(string value, CliOption option, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static CliToken <Tokenize>g__Command|3_6(string value, CliCommand cmd, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static CliToken <Tokenize>g__Option|3_7(string value, CliOption option, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static CliToken <Tokenize>g__DoubleDash|3_8(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static CliToken <Tokenize>g__Directive|3_9(string value, CliDirective directive, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <Tokenize>g__CanBeUnbundled|3_0(string arg, <>c__DisplayClass3_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <Tokenize>g__TryUnbundle|3_1(ReadOnlySpan`1<char> alias, int argumentIndex, <>c__DisplayClass3_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <Tokenize>g__PreviousTokenIsAnOptionExpectingAnArgument|3_2(CliOption& option, <>c__DisplayClass3_0& );
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.StringExtensions/<<TryReadResponseFile>g__ExpandResponseFile|7_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <TryReadResponseFile>g__ExpandResponseFile|7_0(string filePath);
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.StringExtensions/<<TryReadResponseFile>g__SplitLine|7_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <TryReadResponseFile>g__SplitLine|7_1(string line);
    [CompilerGeneratedAttribute]
internal static void <ValidTokens>g__AddCommandTokens|8_0(Dictionary`2<string, CliToken> tokens, CliCommand cmd);
    [CompilerGeneratedAttribute]
internal static void <ValidTokens>g__AddOptionTokens|8_1(Dictionary`2<string, CliToken> tokens, CliOption option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Parsing.SymbolResult : object {
    internal SymbolResultTree SymbolResultTree;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected List`1<CliToken> _tokens;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SymbolResult <Parent>k__BackingField;
    public IEnumerable`1<ParseError> Errors { get; }
    [NullableAttribute("2")]
public SymbolResult Parent { get; }
    public IReadOnlyList`1<CliToken> Tokens { get; }
    private protected SymbolResult(SymbolResultTree symbolResultTree, SymbolResult parent);
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.SymbolResult/<get_Errors>d__4")]
public IEnumerable`1<ParseError> get_Errors();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SymbolResult get_Parent();
    public IReadOnlyList`1<CliToken> get_Tokens();
    internal void AddToken(CliToken token);
    public virtual void AddError(string errorMessage);
    public ArgumentResult GetResult(CliArgument argument);
    public CommandResult GetResult(CliCommand command);
    public OptionResult GetResult(CliOption option);
    public DirectiveResult GetResult(CliDirective directive);
    public SymbolResult GetResult(string name);
    [NullableContextAttribute("2")]
public T GetValue(CliArgument`1<T> argument);
    [NullableContextAttribute("2")]
public T GetValue(CliOption`1<T> option);
    [NullableContextAttribute("2")]
public T GetValue(string name);
    internal virtual bool UseDefaultValueFor(ArgumentResult argumentResult);
}
[ExtensionAttribute]
internal static class System.CommandLine.Parsing.SymbolResultExtensions : object {
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("System.CommandLine.Parsing.SymbolResultExtensions/<AllSymbolResults>d__0")]
[ExtensionAttribute]
internal static IEnumerable`1<SymbolResult> AllSymbolResults(CommandResult commandResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.CommandLine.Parsing.SymbolResultTree : Dictionary`2<CliSymbol, SymbolResult> {
    private CliCommand _rootCommand;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<ParseError> Errors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<CliToken> UnmatchedTokens;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, SymbolNode> _symbolsByName;
    internal int ErrorCount { get; }
    internal SymbolResultTree(CliCommand rootCommand, List`1<string> tokenizeErrors);
    internal int get_ErrorCount();
    internal ArgumentResult GetResult(CliArgument argument);
    internal CommandResult GetResult(CliCommand command);
    internal OptionResult GetResult(CliOption option);
    internal DirectiveResult GetResult(CliDirective directive);
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.SymbolResultTree/<GetChildren>d__11")]
internal IEnumerable`1<SymbolResult> GetChildren(SymbolResult parent);
    internal void AddError(ParseError parseError);
    internal void InsertFirstError(ParseError parseError);
    internal void AddUnmatchedToken(CliToken token, CommandResult commandResult, CommandResult rootCommandResult);
    public SymbolResult GetResult(string name);
    private void PopulateSymbolsByName(CliCommand command);
    [CompilerGeneratedAttribute]
private void <PopulateSymbolsByName>g__AddToSymbolsByName|16_0(CliSymbol symbol);
}
public class System.CommandLine.Parsing.TryReplaceToken : MulticastDelegate {
    public TryReplaceToken(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(string tokenToReplace, IReadOnlyList`1& replacementTokens, String& errorMessage);
    public virtual IAsyncResult BeginInvoke(string tokenToReplace, IReadOnlyList`1& replacementTokens, String& errorMessage, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IReadOnlyList`1& replacementTokens, String& errorMessage, IAsyncResult result);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class System.CommandLine.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentConversionCannotParse { get; }
    internal static string ArgumentConversionCannotParseForCommand { get; }
    internal static string ArgumentConversionCannotParseForCommand_Completions { get; }
    internal static string ArgumentConversionCannotParseForOption { get; }
    internal static string ArgumentConversionCannotParseForOption_Completions { get; }
    internal static string CommandRequiredArgumentMissing { get; }
    internal static string DirectoryDoesNotExist { get; }
    internal static string ErrorReadingResponseFile { get; }
    internal static string ExceptionHandlerHeader { get; }
    internal static string FileDoesNotExist { get; }
    internal static string FileOrDirectoryDoesNotExist { get; }
    internal static string HelpAdditionalArgumentsDescription { get; }
    internal static string HelpAdditionalArgumentsTitle { get; }
    internal static string HelpArgumentDefaultValueLabel { get; }
    internal static string HelpArgumentsTitle { get; }
    internal static string HelpCommandsTitle { get; }
    internal static string HelpDescriptionTitle { get; }
    internal static string HelpOptionDescription { get; }
    internal static string HelpOptionsRequiredLabel { get; }
    internal static string HelpOptionsTitle { get; }
    internal static string HelpUsageAdditionalArguments { get; }
    internal static string HelpUsageCommand { get; }
    internal static string HelpUsageOptions { get; }
    internal static string HelpUsageTitle { get; }
    internal static string InvalidCharactersInFileName { get; }
    internal static string InvalidCharactersInPath { get; }
    internal static string OptionExpectsOneArgument { get; }
    internal static string OptionRequiredArgumentMissing { get; }
    internal static string RequiredCommandWasNotProvided { get; }
    internal static string RequiredOptionWasNotProvided { get; }
    internal static string ResponseFileNotFound { get; }
    internal static string SuggestionsTokenNotMatched { get; }
    internal static string UnrecognizedArgument { get; }
    internal static string UnrecognizedCommandOrArgument { get; }
    internal static string VersionOptionCannotBeCombinedWithOtherArguments { get; }
    internal static string VersionOptionDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentConversionCannotParse();
    internal static string get_ArgumentConversionCannotParseForCommand();
    internal static string get_ArgumentConversionCannotParseForCommand_Completions();
    internal static string get_ArgumentConversionCannotParseForOption();
    internal static string get_ArgumentConversionCannotParseForOption_Completions();
    internal static string get_CommandRequiredArgumentMissing();
    internal static string get_DirectoryDoesNotExist();
    internal static string get_ErrorReadingResponseFile();
    internal static string get_ExceptionHandlerHeader();
    internal static string get_FileDoesNotExist();
    internal static string get_FileOrDirectoryDoesNotExist();
    internal static string get_HelpAdditionalArgumentsDescription();
    internal static string get_HelpAdditionalArgumentsTitle();
    internal static string get_HelpArgumentDefaultValueLabel();
    internal static string get_HelpArgumentsTitle();
    internal static string get_HelpCommandsTitle();
    internal static string get_HelpDescriptionTitle();
    internal static string get_HelpOptionDescription();
    internal static string get_HelpOptionsRequiredLabel();
    internal static string get_HelpOptionsTitle();
    internal static string get_HelpUsageAdditionalArguments();
    internal static string get_HelpUsageCommand();
    internal static string get_HelpUsageOptions();
    internal static string get_HelpUsageTitle();
    internal static string get_InvalidCharactersInFileName();
    internal static string get_InvalidCharactersInPath();
    internal static string get_OptionExpectsOneArgument();
    internal static string get_OptionRequiredArgumentMissing();
    internal static string get_RequiredCommandWasNotProvided();
    internal static string get_RequiredOptionWasNotProvided();
    internal static string get_ResponseFileNotFound();
    internal static string get_SuggestionsTokenNotMatched();
    internal static string get_UnrecognizedArgument();
    internal static string get_UnrecognizedCommandOrArgument();
    internal static string get_VersionOptionCannotBeCombinedWithOtherArguments();
    internal static string get_VersionOptionDescription();
}
[ExtensionAttribute]
internal static class System.CommandLine.SymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static IList`1<CliArgument> Arguments(CliSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.SymbolNode : object {
    [CompilerGeneratedAttribute]
private CliSymbol <Symbol>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SymbolNode <Next>k__BackingField;
    internal CliSymbol Symbol { get; }
    [NullableAttribute("2")]
internal SymbolNode Next { get; internal set; }
    internal SymbolNode(CliSymbol symbol);
    [CompilerGeneratedAttribute]
internal CliSymbol get_Symbol();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SymbolNode get_Next();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Next(SymbolNode value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.VersionOption : CliOption`1<bool> {
    private CliAction _action;
    public CliAction Action { get; public set; }
    internal bool Greedy { get; }
    [NullableContextAttribute("1")]
public VersionOption(string name, String[] aliases);
    public virtual CliAction get_Action();
    public virtual void set_Action(CliAction value);
    private void AddValidators();
    internal virtual bool get_Greedy();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    public bool get_ParameterValue();
}
[AttributeUsageAttribute("27072")]
internal class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("749")]
internal class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    public bool get_ReturnValue();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
