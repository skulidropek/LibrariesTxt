public class Microsoft.Diagnostics.EventFlow.Configuration.DiagnosticPipelineConfiguration : object {
    [CompilerGeneratedAttribute]
private int <PipelineBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxEventBatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBatchDelayMsec>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PipelineCompletionTimeoutMsec>k__BackingField;
    public int PipelineBufferSize { get; public set; }
    public int MaxEventBatchSize { get; public set; }
    public int MaxBatchDelayMsec { get; public set; }
    public int MaxConcurrency { get; public set; }
    public int PipelineCompletionTimeoutMsec { get; public set; }
    [CompilerGeneratedAttribute]
public int get_PipelineBufferSize();
    [CompilerGeneratedAttribute]
public void set_PipelineBufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxEventBatchSize();
    [CompilerGeneratedAttribute]
public void set_MaxEventBatchSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxBatchDelayMsec();
    [CompilerGeneratedAttribute]
public void set_MaxBatchDelayMsec(int value);
    [CompilerGeneratedAttribute]
public int get_MaxConcurrency();
    [CompilerGeneratedAttribute]
public void set_MaxConcurrency(int value);
    [CompilerGeneratedAttribute]
public int get_PipelineCompletionTimeoutMsec();
    [CompilerGeneratedAttribute]
public void set_PipelineCompletionTimeoutMsec(int value);
}
public class Microsoft.Diagnostics.EventFlow.Configuration.EventMetadataFilterConfiguration : IncludeConditionFilterConfiguration {
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    public string Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(string value);
}
public class Microsoft.Diagnostics.EventFlow.Configuration.ExtensionsConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QualifiedTypeName>k__BackingField;
    public string Category { get; public set; }
    public string Type { get; public set; }
    public string QualifiedTypeName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_QualifiedTypeName();
    [CompilerGeneratedAttribute]
public void set_QualifiedTypeName(string value);
}
public class Microsoft.Diagnostics.EventFlow.Configuration.IncludeConditionFilterConfiguration : ItemConfiguration {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    public string Include { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
}
public class Microsoft.Diagnostics.EventFlow.Configuration.ItemConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public string Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
}
public static class Microsoft.Diagnostics.EventFlow.DateTimePrecise : object {
    private static bool UseSystemTimePrecise;
    public static DateTime UtcNow { get; }
    private static DateTimePrecise();
    private static void GetSystemTimePreciseAsFileTime(Int64& filetime);
    public static DateTime get_UtcNow();
}
public class Microsoft.Diagnostics.EventFlow.DiagnosticPipeline : object {
    private List`1<IDisposable> inputSubscriptions;
    private Timer batcherTimer;
    private List`1<Task> outputCompletionTasks;
    private bool disposed;
    private bool disposeDependencies;
    private object batcherTimerDisposalLock;
    private CancellationTokenSource cancellationTokenSource;
    private IDataflowBlock pipelineHead;
    private DiagnosticPipelineConfiguration pipelineConfiguration;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IObservable`1<EventData>> <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<EventSink> <Sinks>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IFilter> <GlobalFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private IHealthReporter <HealthReporter>k__BackingField;
    public IReadOnlyCollection`1<IObservable`1<EventData>> Inputs { get; private set; }
    public IReadOnlyCollection`1<EventSink> Sinks { get; private set; }
    public IReadOnlyCollection`1<IFilter> GlobalFilters { get; private set; }
    public IHealthReporter HealthReporter { get; private set; }
    public DiagnosticPipeline(IHealthReporter healthReporter, IReadOnlyCollection`1<IObservable`1<EventData>> inputs, IReadOnlyCollection`1<IFilter> globalFilters, IReadOnlyCollection`1<EventSink> sinks, DiagnosticPipelineConfiguration pipelineConfiguration, bool disposeDependencies, TaskScheduler taskScheduler);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IObservable`1<EventData>> get_Inputs();
    [CompilerGeneratedAttribute]
private void set_Inputs(IReadOnlyCollection`1<IObservable`1<EventData>> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<EventSink> get_Sinks();
    [CompilerGeneratedAttribute]
private void set_Sinks(IReadOnlyCollection`1<EventSink> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IFilter> get_GlobalFilters();
    [CompilerGeneratedAttribute]
private void set_GlobalFilters(IReadOnlyCollection`1<IFilter> value);
    [CompilerGeneratedAttribute]
public IHealthReporter get_HealthReporter();
    [CompilerGeneratedAttribute]
private void set_HealthReporter(IHealthReporter value);
    private void DisposeOf(IEnumerable`1<object> items);
}
public class Microsoft.Diagnostics.EventFlow.DiagnosticPipelineFactory : object {
    public static DiagnosticPipeline CreatePipeline(string jsonConfigFilePath);
    public static DiagnosticPipeline CreatePipeline(IConfiguration configuration, IHealthReporter healthReporter);
    private static IHealthReporter CreateHealthReporter(IConfiguration configuration);
    private static List`1<ItemWithChildren`2<PipelineItemType, PipelineItemChildType>> ProcessSection(IConfigurationSection configurationSection, IHealthReporter healthReporter, IDictionary`2<string, string> itemFactories, IDictionary`2<string, string> childFactories, string childSectionName);
    private static void ReportItemCreationFailedAndThrow(IHealthReporter healthReporter, string itemType, Exception e);
    private static void ReportInvalidConfigurationFragmentAndThrow(IHealthReporter healthReporter, IConfigurationSection itemFragment);
    private static void ReportSectionEmptyAndThrow(IHealthReporter healthReporter, IConfigurationSection configurationSection);
    private static void ReportNoItemsCreatedAndThrow(IHealthReporter healthReporter, IConfigurationSection configurationSection);
    private static void ReportUnknownItemTypeAndThrow(IHealthReporter healthReporter, IConfigurationSection configurationSection, ItemConfiguration itemConfiguration);
    private static void ReportInvalidPipelineConfiguration(IHealthReporter healthReporter);
    private static void CreateItemFactories(IConfiguration configuration, IHealthReporter healthReporter, IDictionary`2& inputFactories, IDictionary`2& outputFactories, IDictionary`2& filterFactories);
    private static void DisposeOf(IEnumerable`1<object> items);
}
internal class Microsoft.Diagnostics.EventFlow.EmptyDisposable : object {
    public static EmptyDisposable Instance;
    private static EmptyDisposable();
    public sealed virtual void Dispose();
}
public class Microsoft.Diagnostics.EventFlow.EventData : object {
    private Dictionary`2<string, object> payload;
    private Dictionary`2<string, List`1<EventMetadata>> metadata;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Keywords>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public string ProviderName { get; public set; }
    public LogLevel Level { get; public set; }
    public long Keywords { get; public set; }
    public IDictionary`2<string, object> Payload { get; }
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_ProviderName();
    [CompilerGeneratedAttribute]
public void set_ProviderName(string value);
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public long get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(long value);
    public IDictionary`2<string, object> get_Payload();
    public bool TryGetMetadata(string metadataKind, IReadOnlyCollection`1& metadataOfKind);
    public void SetMetadata(EventMetadata newMetadata);
    public bool TryGetPropertyValue(string propertyName, Object& value);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<T> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<bool> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<DateTime> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<DateTimeOffset> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<Guid> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<TimeSpan> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<float> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<double> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<int> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<long> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<UInt32> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<ulong> handler);
    public bool GetValueFromPayload(string payloadName, ProcessPayload`1<string> handler);
    public void AddPayloadProperty(string key, object value, IHealthReporter healthReporter, string context);
    public sealed virtual EventData DeepClone();
    private bool GetValueFromPayloadMatchingType(string payloadName, ProcessPayload`1<T> handler);
    private object TryGetNonNullPayloadValue(string payloadName);
}
public static class Microsoft.Diagnostics.EventFlow.EventFlowContextIdentifiers : object {
    public static string Throttling;
    public static string Filtering;
    public static string Output;
    public static string Configuration;
    private static EventFlowContextIdentifiers();
}
public class Microsoft.Diagnostics.EventFlow.EventFlowSubject`1 : object {
    private object lockObject;
    private ImmutableList`1 modreq(System.Runtime.CompilerServices.IsVolatile) observers;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) shuttingDown;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) notificationsInProgress;
    private Lazy`1<IDictionary`2<string, string>> labelsSource;
    private TimeSpan shutdownTimeout;
    public IDictionary`2<string, string> Labels { get; }
    private bool IsCompleted { get; }
    public EventFlowSubject`1(TimeSpan shutdownTimeout);
    public sealed virtual IDictionary`2<string, string> get_Labels();
    public sealed virtual void Dispose();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(SubjectType value);
    public sealed virtual IDisposable Subscribe(IObserver`1<SubjectType> observer);
    public void Unsubscribe(IObserver`1<SubjectType> observer);
    private bool get_IsCompleted();
    private IEnumerable`1<IObserver`1<SubjectType>> Shutdown();
    [CompilerGeneratedAttribute]
private bool <Shutdown>b__18_0();
}
[ExtensionAttribute]
public static class Microsoft.Diagnostics.EventFlow.EventLevelExtensions : object {
    private static String[] LogLevelNames;
    private static EventLevelExtensions();
    [ExtensionAttribute]
public static string GetName(LogLevel level);
}
public class Microsoft.Diagnostics.EventFlow.EventSink : object {
    [CompilerGeneratedAttribute]
private IOutput <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IFilter> <Filters>k__BackingField;
    public IOutput Output { get; private set; }
    public IReadOnlyCollection`1<IFilter> Filters { get; private set; }
    public EventSink(IOutput output, IReadOnlyCollection`1<IFilter> filters);
    [CompilerGeneratedAttribute]
public IOutput get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(IOutput value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IFilter> get_Filters();
    [CompilerGeneratedAttribute]
private void set_Filters(IReadOnlyCollection`1<IFilter> value);
    public sealed virtual void Dispose();
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.AlternativeEvaluator : FilterEvaluator {
    private FilterEvaluator first;
    private FilterEvaluator second;
    public string SemanticsString { get; }
    public AlternativeEvaluator(FilterEvaluator first, FilterEvaluator second);
    public virtual bool Evaluate(EventData e);
    public virtual string get_SemanticsString();
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.BitwiseEqualityEvaluator : EventPropertyExpressionEvaluator {
    private ulong unsignedRhsValue;
    private long signedRhsValue;
    public string SemanticsString { get; }
    public BitwiseEqualityEvaluator(string propertyName, string value);
    public virtual string get_SemanticsString();
    public virtual bool Evaluate(EventData e);
}
internal abstract class Microsoft.Diagnostics.EventFlow.FilterEvaluators.CachingPropertyExpressionEvaluator : EventPropertyExpressionEvaluator {
    private IImmutableDictionary`2<Type, object> interpretedValueCache;
    private object lockObj;
    public CachingPropertyExpressionEvaluator(string propertyName, string value);
    protected object GetOrAddInterpretedRHSValue(object eventPropertyValue);
    private object InterpretRhsValue(Type eventPropertyValueType);
    private object ParseNumber(NumberParser`1<T> parser);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.ConjunctionEvaluator : FilterEvaluator {
    private FilterEvaluator first;
    private FilterEvaluator second;
    public string SemanticsString { get; }
    public ConjunctionEvaluator(FilterEvaluator first, FilterEvaluator second);
    public virtual bool Evaluate(EventData e);
    public virtual string get_SemanticsString();
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.EqualityEvaluator : CachingPropertyExpressionEvaluator {
    public string SemanticsString { get; }
    public EqualityEvaluator(string propertyName, string value);
    public virtual string get_SemanticsString();
    public virtual bool Evaluate(EventData e);
    protected bool EvaluateEquality(EventData e, Boolean& fullyEvaluated);
}
internal abstract class Microsoft.Diagnostics.EventFlow.FilterEvaluators.EventPropertyExpressionEvaluator : FilterEvaluator {
    protected string propertyName;
    protected string value;
    public EventPropertyExpressionEvaluator(string propertyName, string value);
}
internal static class Microsoft.Diagnostics.EventFlow.FilterEvaluators.EventPropertyExpressionEvaluatorFactory : object {
    public static EventPropertyExpressionEvaluator CreateEvaluator(string propertyName, string op, string value);
}
public abstract class Microsoft.Diagnostics.EventFlow.FilterEvaluators.FilterEvaluator : object {
    public string SemanticsString { get; }
    public abstract virtual string get_SemanticsString();
    public abstract virtual bool Evaluate(EventData e);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.GreaterOrEqualsEvaluator : OrderingEvaluator {
    public string SemanticsString { get; }
    public GreaterOrEqualsEvaluator(string propertyName, string value);
    public virtual string get_SemanticsString();
    protected virtual bool IsMatch(int comparisonResult);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.GreaterThanEvaluator : OrderingEvaluator {
    public string SemanticsString { get; }
    public GreaterThanEvaluator(string propertyName, string value);
    public virtual string get_SemanticsString();
    protected virtual bool IsMatch(int comparisonResult);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.HasNoPropertyEvaluator : FilterEvaluator {
    private string propertyName;
    public string SemanticsString { get; }
    public HasNoPropertyEvaluator(string propertyName);
    public virtual string get_SemanticsString();
    public virtual bool Evaluate(EventData e);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.HasPropertyEvaluator : FilterEvaluator {
    private string propertyName;
    public string SemanticsString { get; }
    public HasPropertyEvaluator(string propertyName);
    public virtual string get_SemanticsString();
    public virtual bool Evaluate(EventData e);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.InequalityEvaluator : EqualityEvaluator {
    public string SemanticsString { get; }
    public InequalityEvaluator(string propertyName, string value);
    public virtual string get_SemanticsString();
    public virtual bool Evaluate(EventData e);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.LessOrEqualsEvaluator : OrderingEvaluator {
    public string SemanticsString { get; }
    public LessOrEqualsEvaluator(string propertyName, string value);
    public virtual string get_SemanticsString();
    protected virtual bool IsMatch(int comparisonResult);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.LessThanEvaluator : OrderingEvaluator {
    public string SemanticsString { get; }
    public LessThanEvaluator(string propertyName, string value);
    public virtual string get_SemanticsString();
    protected virtual bool IsMatch(int comparisonResult);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.NegationEvaluator : FilterEvaluator {
    private FilterEvaluator inner;
    public string SemanticsString { get; }
    public NegationEvaluator(FilterEvaluator inner);
    public virtual bool Evaluate(EventData e);
    public virtual string get_SemanticsString();
}
internal abstract class Microsoft.Diagnostics.EventFlow.FilterEvaluators.OrderingEvaluator : CachingPropertyExpressionEvaluator {
    public OrderingEvaluator(string propertyName, string value);
    protected abstract virtual bool IsMatch(int comparisonResult);
    public virtual bool Evaluate(EventData e);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.PositiveEvaluator : FilterEvaluator {
    public static Lazy`1<PositiveEvaluator> Instance;
    public string SemanticsString { get; }
    private static PositiveEvaluator();
    public virtual string get_SemanticsString();
    public virtual bool Evaluate(EventData e);
}
internal class Microsoft.Diagnostics.EventFlow.FilterEvaluators.RegexEvaluator : EventPropertyExpressionEvaluator {
    private static string Iso8601DurationFormat;
    public static TimeSpan MatchTimeout;
    private Regex regex;
    public string SemanticsString { get; }
    public RegexEvaluator(string propertyName, string value);
    private static RegexEvaluator();
    public virtual string get_SemanticsString();
    public virtual bool Evaluate(EventData e);
}
[GeneratedCodeAttribute("Pegasus", "4.1.0.0")]
internal class Microsoft.Diagnostics.EventFlow.FilterParser : object {
    private Dictionary`2<CacheKey, object> storage;
    public FilterEvaluator Parse(string subject, string fileName);
    private IParseResult`1<FilterEvaluator> filter(Cursor& cursor);
    private IParseResult`1<FilterEvaluator> orExp(Cursor& cursor);
    private IParseResult`1<FilterEvaluator> andExp(Cursor& cursor);
    private IParseResult`1<FilterEvaluator> primaryExp(Cursor& cursor);
    private IParseResult`1<FilterEvaluator> basicExp(Cursor& cursor);
    private IParseResult`1<string> property(Cursor& cursor);
    private IParseResult`1<string> operator(Cursor& cursor);
    private IParseResult`1<string> value(Cursor& cursor);
    private IParseResult`1<string> quotedText(Cursor& cursor);
    private IParseResult`1<string> letterDigit(Cursor& cursor);
    private IParseResult`1<IList`1<string>> _(Cursor& cursor);
    private IParseResult`1<string> eof(Cursor& cursor);
    private IParseResult`1<T> StartRuleHelper(Cursor cursor, ParseDelegate`1<T> startRule, string ruleName);
    private IParseResult`1<string> ParseLiteral(Cursor& cursor, string literal, bool ignoreCase);
    private IParseResult`1<string> ParseClass(Cursor& cursor, string characterRanges, bool negated, bool ignoreCase);
    private IParseResult`1<string> ParseAny(Cursor& cursor);
    private IParseResult`1<T> ReturnHelper(Cursor startCursor, Cursor& endCursor, Func`2<Cursor, T> wrappedCode);
    private IParseResult`1<T> ParseHelper(Cursor& cursor, ParseDelegate`1<T> wrappedCode);
    private Exception ExceptionHelper(Cursor cursor, Func`2<Cursor, string> wrappedCode);
    private T ValueOrDefault(IParseResult`1<T> result);
}
public enum Microsoft.Diagnostics.EventFlow.FilterResult : Enum {
    public int value__;
    public static FilterResult KeepEvent;
    public static FilterResult DiscardEvent;
}
public class Microsoft.Diagnostics.EventFlow.Filters.DropFilter : IncludeConditionFilter {
    public DropFilter(string includeCondition);
    public virtual FilterResult Evaluate(EventData eventData);
}
public class Microsoft.Diagnostics.EventFlow.Filters.DropFilterFactory : object {
    public sealed virtual DropFilter CreateItem(IConfiguration configuration, IHealthReporter healthReporter);
}
public class Microsoft.Diagnostics.EventFlow.Filters.EventMetadataFilter : IncludeConditionFilter {
    private EventMetadata metadata;
    public EventMetadataFilter(EventMetadata metadata, string includeCondition);
    public virtual FilterResult Evaluate(EventData eventData);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.Diagnostics.EventFlow.Filters.EventMetadataFilterFactory : object {
    public sealed virtual EventMetadataFilter CreateItem(IConfiguration configuration, IHealthReporter healthReporter);
}
public abstract class Microsoft.Diagnostics.EventFlow.Filters.IncludeConditionFilter : object {
    private string includeCondition;
    protected FilterEvaluator Evaluator;
    public string IncludeCondition { get; public set; }
    public IncludeConditionFilter(string includeCondition);
    public string get_IncludeCondition();
    public void set_IncludeCondition(string value);
    public abstract virtual FilterResult Evaluate(EventData eventData);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.EventFlow.HealthReporterExtensions : object {
    [ExtensionAttribute]
public static void ReportThrottling(IHealthReporter healthReporter);
}
public class Microsoft.Diagnostics.EventFlow.HealthReporters.CsvHealthReporter : object {
    internal static string DefaultLogFilePrefix;
    private static int DefaultThrottlingPeriodMsec;
    private static string TraceTag;
    private static TimeSpan DisposalTimeout;
    private bool disposed;
    private bool newStreamRequested;
    private BlockingCollection`1<string> reportCollection;
    private INewReportFileTrigger newReportFileTrigger;
    private TimeSpanThrottle throttle;
    private Task writingTask;
    private HealthReportLevel minReportLevel;
    private Action`3<HealthReportLevel, string, string> innerReportWriter;
    private DateTime flushTime;
    private int flushPeriodMsec;
    private Func`1<DateTime> getCurrentTime;
    private FileStream fileStream;
    private string logFileNameRandomizer;
    internal StreamWriter StreamWriter;
    [CompilerGeneratedAttribute]
private bool <EnsureOutputCanBeSaved>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SingleLogFileMaximumSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private CsvHealthReporterConfiguration <Configuration>k__BackingField;
    internal bool EnsureOutputCanBeSaved { get; private set; }
    internal long SingleLogFileMaximumSizeInBytes { get; private set; }
    protected CsvHealthReporterConfiguration Configuration { get; private set; }
    public CsvHealthReporter(CsvHealthReporterConfiguration configuration);
    public CsvHealthReporter(IConfiguration configuration);
    public CsvHealthReporter(string configurationFilePath);
    internal CsvHealthReporter(CsvHealthReporterConfiguration configuration, INewReportFileTrigger newReportTrigger, int flushPeriodMsec, Func`1<DateTime> currentTimeProvider);
    private static CsvHealthReporter();
    [CompilerGeneratedAttribute]
internal bool get_EnsureOutputCanBeSaved();
    [CompilerGeneratedAttribute]
private void set_EnsureOutputCanBeSaved(bool value);
    [CompilerGeneratedAttribute]
internal long get_SingleLogFileMaximumSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_SingleLogFileMaximumSizeInBytes(long value);
    [CompilerGeneratedAttribute]
protected CsvHealthReporterConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(CsvHealthReporterConfiguration value);
    public sealed virtual void Activate();
    private void ConsumeCollectedData();
    public string RotateLogFile(string logFileFolder);
    public sealed virtual void ReportHealthy(string description, string context);
    public sealed virtual void ReportProblem(string description, string context);
    public sealed virtual void ReportWarning(string description, string context);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual string RotateLogFileImp(string logFileFolder, Func`2<string, bool> fileExist, Action`1<string> fileDelete, Action`2<string, string> fileMove);
    internal virtual void SetNewStreamWriter(Func`2<string, bool> directoryExists, Func`2<string, DirectoryInfo> createDirectory);
    internal void CreateNewFileStream(string logFilePath);
    internal virtual FileStream CreateFileStream(string logFilePath);
    private void FinishCurrentStream();
    private void Initialize(CsvHealthReporterConfiguration configuration, INewReportFileTrigger newReportTrigger);
    private void VerifyObjectIsNotDisposed();
    private void ProcessLogFileFolder();
    private void OnNewReportFileRequested(object sender, EventArgs e);
    private bool IsIOException(Exception e);
    internal void CleanupExistingLogs(Action`1<ILogFileInfo> cleaner);
    internal virtual IEnumerable`1<ILogFileInfo> GetLogFiles(DirectoryInfo logFolder);
    private string GetNewLogFileName();
    private string GetLastLogFileName();
    private void ReportText(HealthReportLevel level, string text, string context);
    private void WriteLine(HealthReportLevel level, string text, string context);
    internal string EscapeComma(string text);
    [CompilerGeneratedAttribute]
private void <Activate>b__36_0();
}
public class Microsoft.Diagnostics.EventFlow.HealthReporters.CsvHealthReporterConfiguration : object {
    [CompilerGeneratedAttribute]
private string <LogFileFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogFilePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinReportLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ThrottlingPeriodMsec>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SingleLogFileMaximumSizeInMBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LogRetentionInDays>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnsureOutputCanBeSaved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AssumeSharedLogFolder>k__BackingField;
    public string LogFileFolder { get; public set; }
    public string LogFilePrefix { get; public set; }
    public string MinReportLevel { get; public set; }
    public Nullable`1<int> ThrottlingPeriodMsec { get; public set; }
    public int SingleLogFileMaximumSizeInMBytes { get; public set; }
    public int LogRetentionInDays { get; public set; }
    public bool EnsureOutputCanBeSaved { get; public set; }
    public bool AssumeSharedLogFolder { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LogFileFolder();
    [CompilerGeneratedAttribute]
public void set_LogFileFolder(string value);
    [CompilerGeneratedAttribute]
public string get_LogFilePrefix();
    [CompilerGeneratedAttribute]
public void set_LogFilePrefix(string value);
    [CompilerGeneratedAttribute]
public string get_MinReportLevel();
    [CompilerGeneratedAttribute]
public void set_MinReportLevel(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ThrottlingPeriodMsec();
    [CompilerGeneratedAttribute]
public void set_ThrottlingPeriodMsec(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public int get_SingleLogFileMaximumSizeInMBytes();
    [CompilerGeneratedAttribute]
public void set_SingleLogFileMaximumSizeInMBytes(int value);
    [CompilerGeneratedAttribute]
public int get_LogRetentionInDays();
    [CompilerGeneratedAttribute]
public void set_LogRetentionInDays(int value);
    [CompilerGeneratedAttribute]
public bool get_EnsureOutputCanBeSaved();
    [CompilerGeneratedAttribute]
public void set_EnsureOutputCanBeSaved(bool value);
    [CompilerGeneratedAttribute]
public bool get_AssumeSharedLogFolder();
    [CompilerGeneratedAttribute]
public void set_AssumeSharedLogFolder(bool value);
}
[ExtensionAttribute]
internal static class Microsoft.Diagnostics.EventFlow.HealthReporters.CsvHeathReporterExtensions : object {
    [ExtensionAttribute]
public static CsvHealthReporterConfiguration ToCsvHealthReporterConfiguration(IConfiguration configuration);
}
internal class Microsoft.Diagnostics.EventFlow.HealthReporters.FileInfoWrapper : object {
    private FileInfo innerFileInfo;
    public DateTime CreationTimeUtc { get; }
    public FileInfoWrapper(FileInfo fileInfo);
    public sealed virtual void Delete();
    public sealed virtual DateTime get_CreationTimeUtc();
}
internal interface Microsoft.Diagnostics.EventFlow.HealthReporters.INewReportFileTrigger {
    [CompilerGeneratedAttribute]
public abstract virtual void add_NewReportFileRequested(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NewReportFileRequested(EventHandler`1<EventArgs> value);
}
internal class Microsoft.Diagnostics.EventFlow.HealthReporters.ReportWriter : object {
    private Action`3<HealthReportLevel, string, string> reportText;
    public ReportWriter(Action`3<HealthReportLevel, string, string> action);
    public sealed virtual void Dispose();
    public sealed virtual void ReportHealthy(string description, string context);
    public sealed virtual void ReportProblem(string description, string context);
    public sealed virtual void ReportWarning(string description, string context);
}
internal interface Microsoft.Diagnostics.EventFlow.IDeepCloneable`1 {
    public abstract virtual T DeepClone();
}
public interface Microsoft.Diagnostics.EventFlow.IFilter {
    public abstract virtual FilterResult Evaluate(EventData eventData);
}
public interface Microsoft.Diagnostics.EventFlow.IHealthReporter {
    public abstract virtual void ReportHealthy(string description, string context);
    public abstract virtual void ReportProblem(string description, string context);
    public abstract virtual void ReportWarning(string description, string context);
}
public interface Microsoft.Diagnostics.EventFlow.IItemWithLabels {
    public IDictionary`2<string, string> Labels { get; }
    public abstract virtual IDictionary`2<string, string> get_Labels();
}
internal interface Microsoft.Diagnostics.EventFlow.ILogFileInfo {
    public DateTime CreationTimeUtc { get; }
    public abstract virtual DateTime get_CreationTimeUtc();
    public abstract virtual void Delete();
}
public interface Microsoft.Diagnostics.EventFlow.IOutput {
    public abstract virtual Task SendEventsAsync(IReadOnlyCollection`1<EventData> events, long transmissionSequenceNumber, CancellationToken cancellationToken);
}
public interface Microsoft.Diagnostics.EventFlow.IPipelineItemFactory`1 {
    public abstract virtual ItemType CreateItem(IConfiguration configuration, IHealthReporter healthReporter);
}
public interface Microsoft.Diagnostics.EventFlow.IRequireActivation {
    public abstract virtual void Activate();
}
public enum Microsoft.Diagnostics.EventFlow.LogLevel : Enum {
    public int value__;
    public static LogLevel Critical;
    public static LogLevel Error;
    public static LogLevel Warning;
    public static LogLevel Informational;
    public static LogLevel Verbose;
}
internal class Microsoft.Diagnostics.EventFlow.LossReportingPropagatorBlock`1 : object {
    private IHealthReporter healthReporter;
    private ITargetBlock`1<T> target;
    private ISourceBlock`1<T> source;
    private bool propagateCompletion;
    private bool completed;
    private Lazy`1<TaskCompletionSource`1<bool>> completionSource;
    private long postponements;
    private long consumptionAttempts;
    public Task Completion { get; }
    public LossReportingPropagatorBlock`1(IHealthReporter healthReporter);
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    public sealed virtual void Fault(Exception exception);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T> target, DataflowLinkOptions linkOptions);
    public sealed virtual DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    public sealed virtual T ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target, Boolean& messageConsumed);
    public sealed virtual void ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    public sealed virtual bool ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private void VerifyTargetInitiatedOperation(ITargetBlock`1<T> target);
    private void VerifySourceInitiatedOperation(ISourceBlock`1<T> source);
}
public class Microsoft.Diagnostics.EventFlow.Metadata.DataRetrievalResult : object {
    public static DataRetrievalResult Success;
    [CompilerGeneratedAttribute]
private DataRetrievalStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public DataRetrievalStatus Status { get; private set; }
    public string Message { get; private set; }
    private static DataRetrievalResult();
    [CompilerGeneratedAttribute]
public DataRetrievalStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(DataRetrievalStatus value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    public static DataRetrievalResult MissingMetadataProperty(string missingPropertyName);
    public static DataRetrievalResult InvalidMetadataPropertyValue(string invalidPropertyName, string invalidPropertyValue);
    public static DataRetrievalResult DataMissingOrInvalid(string propertyName);
    public static DataRetrievalResult InvalidMetadataType(string actualMetadataType, string expectedMetadataType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Microsoft.Diagnostics.EventFlow.Metadata.DataRetrievalStatus : Enum {
    public int value__;
    public static DataRetrievalStatus Success;
    public static DataRetrievalStatus MetadataPropertyMissing;
    public static DataRetrievalStatus InvalidMetadataValue;
    public static DataRetrievalStatus DataMissingOrInvalid;
    public static DataRetrievalStatus InvalidMetadataType;
}
public class Microsoft.Diagnostics.EventFlow.Metadata.DependencyData : NetworkCallData {
    public static string DependencyMetadataKind;
    public static string TargetPropertyMoniker;
    public static string DependecyTypeMoniker;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependencyType>k__BackingField;
    public string Target { get; private set; }
    public string DependencyType { get; private set; }
    private static DependencyData();
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
private void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_DependencyType();
    [CompilerGeneratedAttribute]
private void set_DependencyType(string value);
    public static DataRetrievalResult TryGetData(EventData eventData, EventMetadata dependencyMetadata, DependencyData& dependency);
}
public enum Microsoft.Diagnostics.EventFlow.Metadata.DurationUnit : Enum {
    public int value__;
    public static DurationUnit TimeSpan;
    public static DurationUnit Milliseconds;
    public static DurationUnit Seconds;
    public static DurationUnit Minutes;
    public static DurationUnit Hours;
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Diagnostics.EventFlow.Metadata.EventMetadata : object {
    [CompilerGeneratedAttribute]
private string <MetadataType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string MetadataType { get; private set; }
    public IDictionary`2<string, string> Properties { get; private set; }
    public string Item { get; }
    public EventMetadata(string metadataKind);
    [CompilerGeneratedAttribute]
public string get_MetadataType();
    [CompilerGeneratedAttribute]
private void set_MetadataType(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, string> value);
    public string get_Item(string propertyName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public DataRetrievalResult GetEventPropertyValue(EventData eventData, string metadataPropertyName, T& eventPropertyValue);
}
public class Microsoft.Diagnostics.EventFlow.Metadata.ExceptionData : object {
    public static string ExceptionMetadataKind;
    public static string ExceptionPropertyMoniker;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; private set; }
    private ExceptionData(Exception e);
    private static ExceptionData();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    public static DataRetrievalResult TryGetData(EventData eventData, EventMetadata exceptionMetadata, ExceptionData& exceptionData);
}
public class Microsoft.Diagnostics.EventFlow.Metadata.MetricData : object {
    public static string MetricMetadataKind;
    public static string MetricNameMoniker;
    public static string MetricNamePropertyMoniker;
    public static string MetricValueMoniker;
    public static string MetricValuePropertyMoniker;
    [CompilerGeneratedAttribute]
private string <MetricName>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public string MetricName { get; private set; }
    public double Value { get; private set; }
    private static MetricData();
    [CompilerGeneratedAttribute]
public string get_MetricName();
    [CompilerGeneratedAttribute]
private void set_MetricName(string value);
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(double value);
    public static DataRetrievalResult TryGetData(EventData eventData, EventMetadata metricMetadata, MetricData& metric);
}
public abstract class Microsoft.Diagnostics.EventFlow.Metadata.NetworkCallData : object {
    public static string IsSuccessPropertyMoniker;
    public static string DurationPropertyMoniker;
    public static string DurationUnitMoniker;
    public static string ResponseCodePropertyMoniker;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseCode>k__BackingField;
    public Nullable`1<TimeSpan> Duration { get; protected set; }
    public Nullable`1<bool> IsSuccess { get; protected set; }
    public string ResponseCode { get; protected set; }
    private static NetworkCallData();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Duration();
    [CompilerGeneratedAttribute]
protected void set_Duration(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSuccess();
    [CompilerGeneratedAttribute]
protected void set_IsSuccess(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_ResponseCode();
    [CompilerGeneratedAttribute]
protected void set_ResponseCode(string value);
    protected static DataRetrievalResult GetSuccessValue(EventData eventData, EventMetadata networkCallMetadata, Nullable`1& success);
    protected static DataRetrievalResult GetDurationValue(EventData eventData, EventMetadata networkCallMetadata, Nullable`1& duration);
    protected static DataRetrievalResult GetResponseCodeValue(EventData eventData, EventMetadata networkCallMetadata, String& responseCode);
    private static TimeSpan ToTimeSpan(double value, DurationUnit durationUnit);
}
public class Microsoft.Diagnostics.EventFlow.Metadata.RequestData : NetworkCallData {
    public static string RequestMetadataKind;
    public static string RequestNamePropertyMoniker;
    [CompilerGeneratedAttribute]
private string <RequestName>k__BackingField;
    public string RequestName { get; private set; }
    private static RequestData();
    [CompilerGeneratedAttribute]
public string get_RequestName();
    [CompilerGeneratedAttribute]
private void set_RequestName(string value);
    public static DataRetrievalResult TryGetData(EventData eventData, EventMetadata requestMetadata, RequestData& request);
}
public static class Microsoft.Diagnostics.EventFlow.PayloadDictionaryUtilities : object {
    public static void AddPayloadProperty(IDictionary`2<string, object> payload, string key, object value, IHealthReporter healthReporter, string context);
}
internal class Microsoft.Diagnostics.EventFlow.TargetBlockObserver`1 : object {
    private ITargetBlock`1<TInput> target;
    private IHealthReporter healthReporter;
    public TargetBlockObserver`1(ITargetBlock`1<TInput> target, IHealthReporter healthReporter);
    internal Task`1<bool> SendAsyncToTarget(TInput value);
    private sealed virtual override void System.IObserver<TInput>.OnCompleted();
    private sealed virtual override void System.IObserver<TInput>.OnError(Exception error);
    private sealed virtual override void System.IObserver<TInput>.OnNext(TInput value);
}
internal class Microsoft.Diagnostics.EventFlow.TimeSpanThrottle : object {
    private TimeSpan throttlingTimeSpan;
    private Nullable`1<DateTimeOffset> lastExecutionTime;
    private object lockObject;
    public TimeSpanThrottle(TimeSpan throttlingTimeSpan);
    public void Execute(Action work);
    private bool TooEarly(DateTimeOffset now);
}
internal class Microsoft.Diagnostics.EventFlow.UtcMidnightNotifier : object {
    private Timer timer;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> DayChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> NewReportFileRequested;
    private static Lazy`1<UtcMidnightNotifier> instance;
    public static UtcMidnightNotifier Instance { get; }
    private static UtcMidnightNotifier();
    [CompilerGeneratedAttribute]
public void add_DayChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DayChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_NewReportFileRequested(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_NewReportFileRequested(EventHandler`1<EventArgs> value);
    public static UtcMidnightNotifier get_Instance();
    private void CreateNewTimer();
    private static TimeSpan GetSleepTime();
    private void OnDayChanged();
    [CompilerGeneratedAttribute]
private void <CreateNewTimer>b__11_0(object state);
}
public class Microsoft.Diagnostics.EventFlow.Utilities.ErrorHandlingPolicies : object {
    public static void HandleOutputTaskError(Exception e, Action handler);
}
