internal static class FxResources.Microsoft.Diagnostics.Tracing.EventSource.SR : object {
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Diagnostics.Tracing.ActivityTracker : object {
    private AsyncLocal`1<ActivityInfo> m_current;
    private bool m_checkedForEnable;
    private static ActivityTracker s_activityTrackerInstance;
    private static long m_nextId;
    private static ushort MAX_ACTIVITY_DEPTH;
    public static ActivityTracker Instance { get; }
    private static ActivityTracker();
    public void OnStart(string providerName, string activityName, int task, Guid& activityId, Guid& relatedActivityId, EventActivityOptions options, bool useTplSource);
    public void OnStop(string providerName, string activityName, int task, Guid& activityId, bool useTplSource);
    public void Enable();
    public static ActivityTracker get_Instance();
    private static ActivityInfo FindActiveActivity(string name, ActivityInfo startLocation);
    private static string NormalizeActivityName(string providerName, string activityName, int task);
    private void ActivityChanging(AsyncLocalValueChangedArgs`1<ActivityInfo> args);
}
internal class Microsoft.Diagnostics.Tracing.ArrayTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public ArrayTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.ConcurrentSet`2 : ValueType {
    private ItemType[] items;
    public ItemType TryGet(KeyType key);
    public ItemType GetOrAdd(ItemType newItem);
}
internal abstract class Microsoft.Diagnostics.Tracing.ConcurrentSetItem`2 : object {
    public abstract virtual int Compare(ItemType other);
    public abstract virtual int Compare(KeyType key);
}
internal enum Microsoft.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
internal class Microsoft.Diagnostics.Tracing.CounterGroup : object {
    private EventSource _eventSource;
    private List`1<DiagnosticCounter> _counters;
    private static object s_counterGroupLock;
    private static WeakReference`1[] s_counterGroups;
    private DateTime _timeStampSinceCollectionStarted;
    private int _pollingIntervalInMilliseconds;
    private DateTime _nextPollingTimeStamp;
    private static Thread s_pollingThread;
    private static AutoResetEvent s_pollingThreadSleepEvent;
    private static List`1<CounterGroup> s_counterGroupEnabledList;
    internal CounterGroup(EventSource eventSource);
    private static CounterGroup();
    internal void Add(DiagnosticCounter eventCounter);
    internal void Remove(DiagnosticCounter eventCounter);
    private void RegisterCommandCallback();
    private void OnEventSourceCommand(object sender, EventCommandEventArgs e);
    private static void EnsureEventSourceIndexAvailable(int eventSourceIndex);
    internal static CounterGroup GetCounterGroup(EventSource eventSource);
    private void EnableTimer(float pollingIntervalInSeconds);
    private void DisableTimer();
    private void ResetCounters();
    private void OnTimer();
    private static void PollForValues();
}
[EventDataAttribute]
internal class Microsoft.Diagnostics.Tracing.CounterPayload : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private float <IntervalSec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Series>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayUnits>k__BackingField;
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    public double Mean { get; public set; }
    public double StandardDeviation { get; public set; }
    public int Count { get; public set; }
    public double Min { get; public set; }
    public double Max { get; public set; }
    public float IntervalSec { get; internal set; }
    public string Series { get; public set; }
    public string CounterType { get; public set; }
    public string Metadata { get; public set; }
    public string DisplayUnits { get; public set; }
    private IEnumerable`1<KeyValuePair`2<string, object>> ForEnumeration { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
public void set_Mean(double value);
    [CompilerGeneratedAttribute]
public double get_StandardDeviation();
    [CompilerGeneratedAttribute]
public void set_StandardDeviation(double value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(double value);
    [CompilerGeneratedAttribute]
public float get_IntervalSec();
    [CompilerGeneratedAttribute]
internal void set_IntervalSec(float value);
    [CompilerGeneratedAttribute]
public string get_Series();
    [CompilerGeneratedAttribute]
public void set_Series(string value);
    [CompilerGeneratedAttribute]
public string get_CounterType();
    [CompilerGeneratedAttribute]
public void set_CounterType(string value);
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayUnits();
    [CompilerGeneratedAttribute]
public void set_DisplayUnits(string value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Tracing.CounterPayload/<get_ForEnumeration>d__51")]
private IEnumerable`1<KeyValuePair`2<string, object>> get_ForEnumeration();
}
[EventDataAttribute]
internal class Microsoft.Diagnostics.Tracing.CounterPayloadType : object {
    [CompilerGeneratedAttribute]
private CounterPayload <Payload>k__BackingField;
    public CounterPayload Payload { get; public set; }
    public CounterPayloadType(CounterPayload payload);
    [CompilerGeneratedAttribute]
public CounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(CounterPayload value);
}
internal class Microsoft.Diagnostics.Tracing.DataCollector : ValueType {
    [ThreadStaticAttribute]
internal static DataCollector ThreadInstance;
    private Byte* scratchEnd;
    private EventData* datasEnd;
    private GCHandle* pinsEnd;
    private EventData* datasStart;
    private Byte* scratch;
    private EventData* datas;
    private GCHandle* pins;
    private Byte[] buffer;
    private int bufferPos;
    private int bufferNesting;
    private bool writingScalars;
    internal void Enable(Byte* scratch, int scratchSize, EventData* datas, int dataCount, GCHandle* pins, int pinCount);
    internal void Disable();
    internal EventData* Finish();
    internal void AddScalar(Void* value, int size);
    internal void AddBinary(string value, int size);
    internal void AddNullTerminatedString(string value);
    internal void AddBinary(Array value, int size);
    internal void AddArray(Array value, int length, int itemSize);
    internal int BeginBufferedArray();
    internal void EndBufferedArray(int bookmark, int count);
    internal void BeginBuffered();
    internal void EndBuffered();
    private void EnsureBuffer();
    private void EnsureBuffer(int additionalSize);
    private void GrowBuffer(int required);
    private void PinArray(object value, int size);
    private void ScalarsBegin();
    private void ScalarsEnd();
}
internal class Microsoft.Diagnostics.Tracing.DateTimeOffsetTypeInfo : TraceLoggingTypeInfo {
    private static DateTimeOffsetTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
internal class Microsoft.Diagnostics.Tracing.DateTimeTypeInfo : TraceLoggingTypeInfo {
    private static DateTimeTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
internal class Microsoft.Diagnostics.Tracing.DecimalTypeInfo : TraceLoggingTypeInfo {
    private static DecimalTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Diagnostics.Tracing.DiagnosticCounter : object {
    private string _displayName;
    private string _displayUnits;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    private CounterGroup _group;
    private Dictionary`2<string, string> _metadata;
    public string DisplayName { get; public set; }
    public string DisplayUnits { get; public set; }
    public string Name { get; }
    public EventSource EventSource { get; }
    internal DiagnosticCounter(string name, EventSource eventSource);
    private protected void Publish();
    public sealed virtual void Dispose();
    public void AddMetadata(string key, string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_DisplayUnits();
    public void set_DisplayUnits(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    internal abstract virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void ReportOutOfBandMessage(string message);
    internal string GetMetadataString();
}
internal class Microsoft.Diagnostics.Tracing.EmptyStruct : ValueType {
}
internal class Microsoft.Diagnostics.Tracing.EnumerableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    internal TraceLoggingTypeInfo ElementInfo { get; }
    public EnumerableTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    internal TraceLoggingTypeInfo get_ElementInfo();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
internal static class Microsoft.Diagnostics.Tracing.Environment : object {
    public static int ProcessId;
    private static Environment();
    private static int GetCurrentProcessId();
}
internal class Microsoft.Diagnostics.Tracing.EtwEventProvider : object {
    private sealed virtual override UInt32 Microsoft.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 Microsoft.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override WriteEventErrorCode Microsoft.Diagnostics.Tracing.IEventProvider.EventWriteTransfer(long registrationHandle, EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int Microsoft.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr Microsoft.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions None;
    public static EventActivityOptions Disable;
    public static EventActivityOptions Recursive;
    public static EventActivityOptions Detachable;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class Microsoft.Diagnostics.Tracing.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    private EventOpcode m_opcode;
    private bool m_opcodeSet;
    public int EventId { get; private set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventTask Task { get; public set; }
    public EventChannel Channel { get; public set; }
    public byte Version { get; public set; }
    public string Message { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(EventChannel value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
public enum Microsoft.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel None;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
}
[AttributeUsageAttribute("256")]
internal class Microsoft.Diagnostics.Tracing.EventChannelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannelType <EventChannelType>k__BackingField;
    public bool Enabled { get; public set; }
    public EventChannelType EventChannelType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public EventChannelType get_EventChannelType();
    [CompilerGeneratedAttribute]
public void set_EventChannelType(EventChannelType value);
}
internal enum Microsoft.Diagnostics.Tracing.EventChannelType : Enum {
    public int value__;
    public static EventChannelType Admin;
    public static EventChannelType Operational;
    public static EventChannelType Analytic;
    public static EventChannelType Debug;
}
public enum Microsoft.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class Microsoft.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    internal EventProviderType eventProviderType;
    internal EventListener listener;
    internal int perEventSourceSessionId;
    internal int etwSessionId;
    internal bool enable;
    internal EventLevel level;
    internal EventKeywords matchAnyKeyword;
    internal EventCommandEventArgs nextCommand;
    public EventCommand Command { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> Arguments { get; internal set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, int etwSessionId, bool enable, EventLevel level, EventKeywords matchAnyKeyword);
    [CompilerGeneratedAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
internal void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(IDictionary`2<string, string> value);
    public bool EnableEvent(int eventId);
    public bool DisableEvent(int eventId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.EventCounter : DiagnosticCounter {
    private int _count;
    private double _sum;
    private double _sumSquared;
    private double _min;
    private double _max;
    private static int BufferedSize;
    private static double UnusedBufferSlotValue;
    private Double[] _bufferedValues;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedValuesIndex;
    public EventCounter(string name, EventSource eventSource);
    public void WriteMetric(float value);
    public void WriteMetric(double value);
    public virtual string ToString();
    internal void OnMetricWritten(double value);
    internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void ResetStatistics();
    private void Enqueue(double value);
    protected void Flush();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class Microsoft.Diagnostics.Tracing.EventDataAttribute : Attribute {
    private EventLevel level;
    private EventOpcode opcode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    public string Name { get; public set; }
    internal EventLevel Level { get; internal set; }
    internal EventOpcode Opcode { get; internal set; }
    internal EventKeywords Keywords { get; internal set; }
    internal EventTags Tags { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal EventLevel get_Level();
    internal void set_Level(EventLevel value);
    internal EventOpcode get_Opcode();
    internal void set_Opcode(EventOpcode value);
    [CompilerGeneratedAttribute]
internal EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
internal void set_Keywords(EventKeywords value);
    [CompilerGeneratedAttribute]
internal EventTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventTags value);
}
internal class Microsoft.Diagnostics.Tracing.EventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    internal int TraceLoggingId { get; }
    public EventDescriptor(int traceloggingId, byte level, byte opcode, long keywords);
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    internal int get_TraceLoggingId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
    public static bool op_Equality(EventDescriptor event1, EventDescriptor event2);
    public static bool op_Inequality(EventDescriptor event1, EventDescriptor event2);
}
internal class Microsoft.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[AttributeUsageAttribute("128")]
public class Microsoft.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventFieldFormat <Format>k__BackingField;
    public EventFieldTags Tags { get; public set; }
    [NullableAttribute("2")]
internal string Name { get; internal set; }
    public EventFieldFormat Format { get; public set; }
    [CompilerGeneratedAttribute]
public EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventFieldTags value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public EventFieldFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(EventFieldFormat value);
}
public enum Microsoft.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Default;
    public static EventFieldFormat String;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat Xml;
    public static EventFieldFormat Json;
    public static EventFieldFormat HResult;
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class Microsoft.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords All;
    public static EventKeywords MicrosoftTelemetry;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum Microsoft.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.EventListener : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventSourceCreatedEventArgs> _EventSourceCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventWrittenEventArgs> EventWritten;
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference`1<EventSource>> s_EventSources;
    private static bool s_CreatingListener;
    private static bool s_EventSourceShutdownRegistered;
    internal static object EventListenersLock { get; }
    private static EventListener();
    [CompilerGeneratedAttribute]
private void add__EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    public static int EventSourceIndex(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    internal static void AddEventSource(EventSource newEventSource);
    private static void DisposeOnShutdown(object sender, EventArgs e);
    private static void RemoveReferencesToListenerInEventSources(EventListener listenerToRemove);
    [ConditionalAttribute("DEBUG")]
internal static void Validate();
    internal static object get_EventListenersLock();
    private void CallBackForExistingEventSources(bool addToListenersList, EventHandler`1<EventSourceCreatedEventArgs> callback);
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions None;
    public static EventManifestOptions Strict;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions AllowEventSourceOverride;
}
public enum Microsoft.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Diagnostics.Tracing.EventPayload : object {
    private String[] m_names;
    private Object[] m_values;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal EventPayload(String[] payloadNames, Object[] payloadValues);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> payloadEntry);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> entry);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Tracing.EventPayload/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] payloadEntries, int count);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> entry);
    public sealed virtual bool TryGetValue(string key, Object& value);
}
internal class Microsoft.Diagnostics.Tracing.EventProvider : object {
    internal IEventProvider m_eventProvider;
    private EtwEnableCallback m_etwCallback;
    private long m_regHandle;
    private byte m_level;
    private long m_anyKeywordMask;
    private long m_allKeywordMask;
    private List`1<SessionInfo> m_liveSessions;
    private bool m_enabled;
    private string m_providerName;
    private Guid m_providerId;
    internal bool m_disposed;
    [ThreadStaticAttribute]
private static WriteEventErrorCode s_returnCode;
    private static int BasicTypeAllocationBufferSize;
    private static int EtwMaxNumberArguments;
    private static int EtwAPIMaxRefObjCount;
    private static int TraceEventMaximumSize;
    private static bool m_setInformationMissing;
    protected EventLevel Level { get; protected set; }
    protected EventKeywords MatchAnyKeyword { get; protected set; }
    protected EventKeywords MatchAllKeyword { get; protected set; }
    internal EventProvider(EventProviderType providerType);
    internal void Register(EventSource eventSource);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual override void Finalize();
    private void EtwEnableCallBack(Guid& sourceId, int controlCode, byte setLevel, long anyKeyword, long allKeyword, EVENT_FILTER_DESCRIPTOR* filterData, Void* callbackContext);
    protected virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments, int sessionId, int etwSessionId);
    protected EventLevel get_Level();
    protected void set_Level(EventLevel value);
    protected EventKeywords get_MatchAnyKeyword();
    protected void set_MatchAnyKeyword(EventKeywords value);
    protected EventKeywords get_MatchAllKeyword();
    protected void set_MatchAllKeyword(EventKeywords value);
    private static int FindNull(Byte[] buffer, int idx);
    private List`1<KeyValuePair`2<SessionInfo, bool>> GetSessions();
    private static void GetSessionInfoCallback(int etwSessionId, long matchAllKeywords, List`1& sessionList);
    private void GetSessionInfo(SessionInfoCallback action, List`1& sessionList);
    private static int IndexOfSessionInList(List`1<SessionInfo> sessions, int etwSessionId);
    private bool GetDataFromController(int etwSessionId, EVENT_FILTER_DESCRIPTOR* filterData, ControllerCommand& command, Byte[]& data, Int32& dataStart);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    private static void SetLastError(WriteEventErrorCode error);
    private static object EncodeObject(Object& data, EventData*& dataDescriptor, Byte*& dataBuffer, UInt32& totalEventSize);
    internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, Object[] eventPayload);
    protected internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, int dataCount, IntPtr data);
    internal bool WriteEventRaw(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private UInt32 EventRegister(EventSource eventSource, EtwEnableCallback enableCallback);
    private void EventUnregister(long registrationHandle);
    internal int SetInformation(EVENT_INFO_CLASS eventInfoClass, Void* data, UInt32 dataSize);
}
internal enum Microsoft.Diagnostics.Tracing.EventProviderType : Enum {
    public int value__;
    public static EventProviderType None;
    public static EventProviderType ETW;
    public static EventProviderType EventPipe;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.EventSource : object {
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    private string m_name;
    internal int m_id;
    private Guid m_guid;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_rawManifest;
    private EventHandler`1<EventCommandEventArgs> m_eventCommandExecuted;
    private EventSourceSettings m_config;
    private bool m_eventSourceDisposed;
    private bool m_eventSourceEnabled;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    private OverrideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_etwProvider;
    private bool m_completelyInited;
    private Exception m_constructionException;
    private byte m_outOfBandMessageCount;
    private EventCommandEventArgs m_deferredCommands;
    private String[] m_traits;
    [ThreadStaticAttribute]
private static byte m_EventSourceExceptionRecurenceCount;
    internal UInt64[] modreq(System.Runtime.CompilerServices.IsVolatile) m_channelData;
    private ActivityTracker m_activityTracker;
    internal static string s_ActivityStartSuffix;
    internal static string s_ActivityStopSuffix;
    internal static string DuplicateSourceNamesSwitch;
    private static bool AllowDuplicateSourceNames;
    private static Byte[] namespaceBytes;
    private Byte[] m_providerMetadata;
    internal static bool IsSupported { get; }
    [NullableAttribute("1")]
public string Name { get; }
    public Guid Guid { get; }
    public EventSourceSettings Settings { get; }
    public Exception ConstructionException { get; }
    public static Guid CurrentThreadActivityId { get; }
    private bool IsDisposed { get; }
    private bool ThrowOnEventWriteErrors { get; }
    private bool SelfDescribingEvents { get; }
    [NullableAttribute("1")]
private Byte[] ProviderMetadata { get; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    internal EventSource(Guid eventSourceGuid, string eventSourceName, EventSourceSettings settings, String[] traits);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName, EventSourceSettings config);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    private static EventSource();
    [CompilerGeneratedAttribute]
internal static bool get_IsSupported();
    private static bool InitializeIsSupported();
    [NullableContextAttribute("1")]
public string get_Name();
    public Guid get_Guid();
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    public EventSourceSettings get_Settings();
    [NullableContextAttribute("1")]
public static Guid GetGuid(Type eventSourceType);
    [NullableContextAttribute("1")]
public static string GetName(Type eventSourceType);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    [NullableContextAttribute("1")]
public static IEnumerable`1<EventSource> GetSources();
    [NullableContextAttribute("1")]
public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    public Exception get_ConstructionException();
    [NullableContextAttribute("1")]
public string GetTrait(string key);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public static void SetCurrentThreadActivityId(Guid activityId);
    public static Guid get_CurrentThreadActivityId();
    public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    [NullableContextAttribute("1")]
protected virtual void OnEventCommand(EventCommandEventArgs command);
    protected void WriteEvent(int eventId);
    protected void WriteEvent(int eventId, int arg1);
    protected void WriteEvent(int eventId, int arg1, int arg2);
    protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, long arg1);
    protected void WriteEvent(int eventId, long arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    protected void WriteEvent(int eventId, string arg1);
    protected void WriteEvent(int eventId, string arg1, string arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    protected void WriteEvent(int eventId, string arg1, int arg2);
    protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, string arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, string arg2);
    protected void WriteEvent(int eventId, int arg1, string arg2);
    protected void WriteEvent(int eventId, Byte[] arg1);
    protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    protected void WriteEvent(int eventId, Object[] args);
    protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void WriteEventRaw(string eventName, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private void Initialize(Guid eventSourceGuid, string eventSourceName, String[] traits);
    private static string GetName(Type eventSourceType, EventManifestOptions flags);
    private static Guid GenerateGuidFromName(string name);
    private static void DecodeObjects(Object[] decodedObjects, Type[] parameterTypes, EventData* data);
    [ConditionalAttribute("DEBUG")]
private static void AssertValidString(EventData* data);
    private EventDispatcher GetDispatcher(EventListener listener);
    private void WriteEventVarargs(int eventId, Guid* childActivityID, Object[] args);
    private Object[] SerializeEventArgs(int eventId, Object[] args);
    private void LogEventArgsMismatches(int eventId, Object[] args);
    private void WriteToAllListeners(EventWrittenEventArgs eventCallbackArgs, int eventDataCount, EventData* data);
    internal void DispatchToAllListeners(EventWrittenEventArgs eventCallbackArgs);
    private void WriteEventString(string msgString);
    private void WriteStringToAllListeners(string eventName, string msg);
    private bool IsEnabledByDefault(int eventNum, bool enable, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword);
    private bool IsEnabledCommon(bool enabled, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword, EventLevel eventLevel, EventKeywords eventKeywords, EventChannel eventChannel);
    private void ThrowEventSourceException(string eventName, Exception innerEx);
    internal static EventOpcode GetOpcodeWithDefault(EventOpcode opcode, string eventName);
    internal void SendCommand(EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, int etwSessionId, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void DoCommand(EventCommandEventArgs commandArgs);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, EventProviderType eventProviderType, int eventId, bool value);
    private bool AnyEventEnabled();
    private bool get_IsDisposed();
    private void EnsureDescriptorsInitialized();
    private void SendManifest(Byte[] rawManifest);
    internal static bool IsCustomAttributeDefinedHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    private static bool AttributeTypeNamesMatch(Type attributeType, Type reflectedAttributeType);
    private static Type GetEventSourceBaseType(Type eventSourceType, bool allowEventSourceOverride, bool reflectionOnly);
    private static Byte[] CreateManifestAndDescriptors(Type eventSourceType, string eventSourceDllName, EventSource source, EventManifestOptions flags);
    private static bool RemoveFirstArgIfRelatedActivityId(ParameterInfo[]& args);
    private static void AddProviderEnumKind(ManifestBuilder manifest, FieldInfo staticField, string providerEnumKind);
    private static void AddEventDescriptor(EventMetadata[]& eventData, string eventName, EventAttribute eventAttribute, ParameterInfo[] eventParameters, bool hasRelatedActivityID);
    private static void TrimEventDescriptors(EventMetadata[]& eventData);
    internal void AddListener(EventListener listener);
    private static void DebugCheckEvent(Dictionary`2& eventsByName, EventMetadata[] eventData, MethodInfo method, EventAttribute eventAttribute, ManifestBuilder manifest, EventManifestOptions options);
    private static int GetHelperCallFirstArg(MethodInfo method);
    internal void ReportOutOfBandMessage(string msg);
    private static EventSourceSettings ValidateSettings(EventSourceSettings settings);
    private bool get_ThrowOnEventWriteErrors();
    private bool get_SelfDescribingEvents();
    private Byte[] get_ProviderMetadata();
    public void Write(string eventName);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, EventSourceOptions& options, T& data);
    public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    private void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    private void WriteMultiMergeInner(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    internal void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, EventData* data);
    private void WriteImpl(string eventName, EventSourceOptions& options, object data, Guid* pActivityId, Guid* pRelatedActivityId, TraceLoggingEventTypes eventTypes);
    private void WriteToAllListeners(string eventName, EventDescriptor& eventDescriptor, EventTags tags, Guid* pActivityId, Guid* pChildActivityId, EventPayload payload);
    [ReliabilityContractAttribute("3", "2")]
[NonEventAttribute]
private static void WriteCleanup(GCHandle* pPins, int cPins);
    private void InitializeProviderMetadata();
    private static int AddValueToMetaData(List`1<byte> metaData, string value);
    private static int HexDigit(char c);
    private NameInfo UpdateDescriptor(string name, TraceLoggingEventTypes eventInfo, EventSourceOptions& options, EventDescriptor& descriptor);
    [CompilerGeneratedAttribute]
internal static TraceLoggingEventTypes <WriteEventString>g__GetTrimSafeTraceLoggingEventTypes|74_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Microsoft.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    public string Name { get; public set; }
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    public EventSource EventSource { get; internal set; }
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
internal void set_EventSource(EventSource value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected EventSourceException(SerializationInfo info, StreamingContext context);
    internal EventSourceException(Exception innerException);
}
public class Microsoft.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    internal static byte keywordsSet;
    internal static byte tagsSet;
    internal static byte levelSet;
    internal static byte opcodeSet;
    internal static byte activityOptionsSet;
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventKeywords Keywords { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings ThrowOnEventWriteErrors;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
public enum Microsoft.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
public enum Microsoft.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    internal static ReadOnlyCollection`1<object> EmptyPayload;
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    private Guid _activityId;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    private MoreEventInfo _moreInfo;
    private EventMetadata& Metadata { get; }
    public string EventName { get; internal set; }
    public int EventId { get; }
    public Guid ActivityId { get; }
    public Guid RelatedActivityId { get; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    [NullableAttribute("1")]
public EventSource EventSource { get; }
    public EventKeywords Keywords { get; internal set; }
    public EventOpcode Opcode { get; internal set; }
    public EventTask Task { get; }
    public EventTags Tags { get; internal set; }
    public string Message { get; internal set; }
    public EventChannel Channel { get; }
    public byte Version { get; }
    public EventLevel Level { get; internal set; }
    public long OSThreadId { get; internal set; }
    public DateTime TimeStamp { get; internal set; }
    [NullableAttribute("1")]
private MoreEventInfo MoreInfo { get; }
    internal EventWrittenEventArgs(EventSource eventSource, int eventId);
    internal EventWrittenEventArgs(EventSource eventSource, int eventId, Guid* pActivityID, Guid* pChildActivityID);
    private static EventWrittenEventArgs();
    private EventMetadata& get_Metadata();
    public string get_EventName();
    internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    public Guid get_ActivityId();
    public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    public ReadOnlyCollection`1<string> get_PayloadNames();
    internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    internal void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    internal void set_Opcode(EventOpcode value);
    public EventTask get_Task();
    public EventTags get_Tags();
    internal void set_Tags(EventTags value);
    public string get_Message();
    internal void set_Message(string value);
    public EventChannel get_Channel();
    public byte get_Version();
    public EventLevel get_Level();
    internal void set_Level(EventLevel value);
    public long get_OSThreadId();
    internal void set_OSThreadId(long value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
internal void set_TimeStamp(DateTime value);
    private MoreEventInfo get_MoreInfo();
}
internal class Microsoft.Diagnostics.Tracing.FieldMetadata : object {
    private string name;
    private int nameSize;
    private EventFieldTags tags;
    private Byte[] custom;
    private ushort fixedCount;
    private byte inType;
    private byte outType;
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, bool variableCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, ushort fixedCount);
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, Byte[] custom);
    private FieldMetadata(string name, TraceLoggingDataType dataType, EventFieldTags tags, byte countFlags, ushort fixedCount, Byte[] custom);
    public void IncrementStructFieldCount();
    public void Encode(Int32& pos, Byte[] metadata);
}
internal interface Microsoft.Diagnostics.Tracing.IEventProvider {
    public abstract virtual UInt32 EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    public abstract virtual UInt32 EventUnregister(long registrationHandle);
    public abstract virtual WriteEventErrorCode EventWriteTransfer(long registrationHandle, EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    public abstract virtual int EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    public abstract virtual IntPtr DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
[EventDataAttribute]
internal class Microsoft.Diagnostics.Tracing.IncrementingCounterPayload : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayRateTimeScale>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private float <IntervalSec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Series>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayUnits>k__BackingField;
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    public string DisplayRateTimeScale { get; public set; }
    public double Increment { get; public set; }
    public float IntervalSec { get; internal set; }
    public string Metadata { get; public set; }
    public string Series { get; public set; }
    public string CounterType { get; public set; }
    public string DisplayUnits { get; public set; }
    private IEnumerable`1<KeyValuePair`2<string, object>> ForEnumeration { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(string value);
    [CompilerGeneratedAttribute]
public double get_Increment();
    [CompilerGeneratedAttribute]
public void set_Increment(double value);
    [CompilerGeneratedAttribute]
public float get_IntervalSec();
    [CompilerGeneratedAttribute]
internal void set_IntervalSec(float value);
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(string value);
    [CompilerGeneratedAttribute]
public string get_Series();
    [CompilerGeneratedAttribute]
public void set_Series(string value);
    [CompilerGeneratedAttribute]
public string get_CounterType();
    [CompilerGeneratedAttribute]
public void set_CounterType(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayUnits();
    [CompilerGeneratedAttribute]
public void set_DisplayUnits(string value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Diagnostics.Tracing.IncrementingCounterPayload/<get_ForEnumeration>d__39")]
private IEnumerable`1<KeyValuePair`2<string, object>> get_ForEnumeration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.IncrementingEventCounter : DiagnosticCounter {
    [CompilerGeneratedAttribute]
private TimeSpan <DisplayRateTimeScale>k__BackingField;
    private double _increment;
    private double _prevIncrement;
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingEventCounter(string name, EventSource eventSource);
    public void Increment(double increment);
    [CompilerGeneratedAttribute]
public TimeSpan get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(TimeSpan value);
    public virtual string ToString();
    internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void UpdateMetric();
}
[EventDataAttribute]
internal class Microsoft.Diagnostics.Tracing.IncrementingEventCounterPayloadType : object {
    [CompilerGeneratedAttribute]
private IncrementingCounterPayload <Payload>k__BackingField;
    public IncrementingCounterPayload Payload { get; public set; }
    public IncrementingEventCounterPayloadType(IncrementingCounterPayload payload);
    [CompilerGeneratedAttribute]
public IncrementingCounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(IncrementingCounterPayload value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.IncrementingPollingCounter : DiagnosticCounter {
    [CompilerGeneratedAttribute]
private TimeSpan <DisplayRateTimeScale>k__BackingField;
    private double _increment;
    private double _prevIncrement;
    private Func`1<double> _totalValueProvider;
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingPollingCounter(string name, EventSource eventSource, Func`1<double> totalValueProvider);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public TimeSpan get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(TimeSpan value);
    internal void UpdateMetric();
    internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
}
[EventDataAttribute]
internal class Microsoft.Diagnostics.Tracing.IncrementingPollingCounterPayloadType : object {
    [CompilerGeneratedAttribute]
private IncrementingCounterPayload <Payload>k__BackingField;
    public IncrementingCounterPayload Payload { get; public set; }
    public IncrementingPollingCounterPayloadType(IncrementingCounterPayload payload);
    [CompilerGeneratedAttribute]
public IncrementingCounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(IncrementingCounterPayload value);
}
internal class Microsoft.Diagnostics.Tracing.InvokeTypeInfo : TraceLoggingTypeInfo {
    internal PropertyAnalysis[] properties;
    public InvokeTypeInfo(Type type, TypeAnalysis typeAnalysis);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.ManifestBuilder : object {
    private static String[] s_escapes;
    private Dictionary`2<int, string> opcodeTab;
    private Dictionary`2<int, string> taskTab;
    private Dictionary`2<int, ChannelInfo> channelTab;
    private Dictionary`2<ulong, string> keywordTab;
    private Dictionary`2<string, Type> mapsTab;
    private Dictionary`2<string, string> stringTab;
    internal static ulong ValidPredefinedChannelKeywords;
    private ulong nextChannelKeywordBit;
    private static int MaxCountChannels;
    private StringBuilder sb;
    private StringBuilder events;
    private StringBuilder templates;
    private string providerName;
    private ResourceManager resources;
    private EventManifestOptions flags;
    private IList`1<string> errors;
    private Dictionary`2<string, List`1<int>> perEventByteArrayArgIndices;
    private string eventName;
    private int numParams;
    private List`1<int> byteArrArgIndices;
    public IList`1<string> Errors { get; }
    public bool HasResources { get; }
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources, EventManifestOptions flags);
    private static ManifestBuilder();
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void AddChannel(string name, int value, EventChannelAttribute channelAttribute);
    private static EventChannelType EventChannelToChannelType(EventChannel channel);
    private static EventChannelAttribute GetDefaultChannelAttribute(EventChannel channel);
    public UInt64[] GetChannelData();
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public ulong GetChannelKeyword(EventChannel channel, ulong channelKeyword);
    public Byte[] CreateManifest();
    public IList`1<string> get_Errors();
    public bool get_HasResources();
    public void ManifestError(string msg, bool runtimeCritical);
    private string CreateManifestString();
    private void WriteNameAndMessageAttribs(StringBuilder stringBuilder, string elementName, string name);
    private void WriteMessageAttrib(StringBuilder stringBuilder, string elementName, string name, string value);
    internal string GetLocalizedMessage(string key, CultureInfo ci, bool etwFormat);
    private static void AppendLevelName(StringBuilder sb, EventLevel level);
    private string GetChannelName(EventChannel channel, string eventName, string eventMessage);
    private string GetTaskName(EventTask task, string eventName);
    private string GetOpcodeName(EventOpcode opcode, string eventName);
    private void AppendKeywords(StringBuilder sb, ulong keywords, string eventName);
    private string GetTypeName(Type type);
    private static void UpdateStringBuilder(StringBuilder& stringBuilder, string eventMessage, int startIndex, int count);
    private string TranslateToManifestConvention(string eventMessage, string evtName);
    private int TranslateIndexToManifestConvention(int idx, string evtName);
    [CompilerGeneratedAttribute]
internal static FieldInfo[] <CreateManifestString>g__GetEnumFields|18_0(Type localEnumType);
}
internal class Microsoft.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public static int MaxChunkSize;
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
internal class Microsoft.Diagnostics.Tracing.NameInfo : ConcurrentSetItem`2<KeyValuePair`2<string, EventTags>, NameInfo> {
    private static int lastIdentity;
    internal string name;
    internal EventTags tags;
    internal int identity;
    internal Byte[] nameMetadata;
    public NameInfo(string name, EventTags tags, int typeMetadataSize);
    private static NameInfo();
    internal static void ReserveEventIDsBelow(int eventId);
    public virtual int Compare(NameInfo other);
    public virtual int Compare(KeyValuePair`2<string, EventTags> key);
    private int Compare(string otherName, EventTags otherTags);
}
[AttributeUsageAttribute("64")]
public class Microsoft.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
internal class Microsoft.Diagnostics.Tracing.NoOpEventProvider : object {
    private sealed virtual override UInt32 Microsoft.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 Microsoft.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override WriteEventErrorCode Microsoft.Diagnostics.Tracing.IEventProvider.EventWriteTransfer(long registrationHandle, EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int Microsoft.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr Microsoft.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
internal class Microsoft.Diagnostics.Tracing.NullableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo valueInfo;
    public NullableTypeInfo(Type type, List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
internal class Microsoft.Diagnostics.Tracing.NullTypeInfo : TraceLoggingTypeInfo {
    private static NullTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Diagnostics.Tracing.PollingCounter : DiagnosticCounter {
    private Func`1<double> _metricProvider;
    private double _lastVal;
    public PollingCounter(string name, EventSource eventSource, Func`1<double> metricProvider);
    public virtual string ToString();
    internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
}
[EventDataAttribute]
internal class Microsoft.Diagnostics.Tracing.PollingPayloadType : object {
    [CompilerGeneratedAttribute]
private CounterPayload <Payload>k__BackingField;
    public CounterPayload Payload { get; public set; }
    public PollingPayloadType(CounterPayload payload);
    [CompilerGeneratedAttribute]
public CounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(CounterPayload value);
}
internal class Microsoft.Diagnostics.Tracing.PropertyAnalysis : object {
    internal string name;
    internal PropertyInfo propertyInfo;
    internal Func`2<PropertyValue, PropertyValue> getter;
    internal TraceLoggingTypeInfo typeInfo;
    internal EventFieldAttribute fieldAttribute;
    public PropertyAnalysis(string name, PropertyInfo propertyInfo, TraceLoggingTypeInfo typeInfo, EventFieldAttribute fieldAttribute);
}
[IsReadOnlyAttribute]
internal class Microsoft.Diagnostics.Tracing.PropertyValue : ValueType {
    private object _reference;
    private Scalar _scalar;
    private int _scalarLength;
    public object ReferenceValue { get; }
    public Scalar ScalarValue { get; }
    public int ScalarLength { get; }
    private PropertyValue(object value);
    private PropertyValue(Scalar scalar, int scalarLength);
    private PropertyValue(bool value);
    private PropertyValue(byte value);
    private PropertyValue(sbyte value);
    private PropertyValue(char value);
    private PropertyValue(short value);
    private PropertyValue(ushort value);
    private PropertyValue(int value);
    private PropertyValue(UInt32 value);
    private PropertyValue(long value);
    private PropertyValue(ulong value);
    private PropertyValue(IntPtr value);
    private PropertyValue(UIntPtr value);
    private PropertyValue(float value);
    private PropertyValue(double value);
    private PropertyValue(Guid value);
    private PropertyValue(DateTime value);
    private PropertyValue(DateTimeOffset value);
    private PropertyValue(TimeSpan value);
    private PropertyValue(decimal value);
    public static Func`2<object, PropertyValue> GetFactory(Type type);
    public object get_ReferenceValue();
    public Scalar get_ScalarValue();
    public int get_ScalarLength();
    public static Func`2<PropertyValue, PropertyValue> GetPropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetBoxedValueTypePropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetReferenceTypePropertyGetter(PropertyInfo property);
}
internal class Microsoft.Diagnostics.Tracing.ScalarArrayTypeInfo : TraceLoggingTypeInfo {
    private static ScalarArrayTypeInfo s_boolean;
    private static ScalarArrayTypeInfo s_byte;
    private static ScalarArrayTypeInfo s_sbyte;
    private static ScalarArrayTypeInfo s_char;
    private static ScalarArrayTypeInfo s_int16;
    private static ScalarArrayTypeInfo s_uint16;
    private static ScalarArrayTypeInfo s_int32;
    private static ScalarArrayTypeInfo s_uint32;
    private static ScalarArrayTypeInfo s_int64;
    private static ScalarArrayTypeInfo s_uint64;
    private static ScalarArrayTypeInfo s_intptr;
    private static ScalarArrayTypeInfo s_uintptr;
    private static ScalarArrayTypeInfo s_single;
    private static ScalarArrayTypeInfo s_double;
    private static ScalarArrayTypeInfo s_guid;
    private TraceLoggingDataType nativeFormat;
    private int elementSize;
    private ScalarArrayTypeInfo(Type type, TraceLoggingDataType nativeFormat, int elementSize);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
internal class Microsoft.Diagnostics.Tracing.ScalarTypeInfo : TraceLoggingTypeInfo {
    private static ScalarTypeInfo s_boolean;
    private static ScalarTypeInfo s_byte;
    private static ScalarTypeInfo s_sbyte;
    private static ScalarTypeInfo s_char;
    private static ScalarTypeInfo s_int16;
    private static ScalarTypeInfo s_uint16;
    private static ScalarTypeInfo s_int32;
    private static ScalarTypeInfo s_uint32;
    private static ScalarTypeInfo s_int64;
    private static ScalarTypeInfo s_uint64;
    private static ScalarTypeInfo s_intptr;
    private static ScalarTypeInfo s_uintptr;
    private static ScalarTypeInfo s_single;
    private static ScalarTypeInfo s_double;
    private static ScalarTypeInfo s_guid;
    private TraceLoggingDataType nativeFormat;
    private ScalarTypeInfo(Type type, TraceLoggingDataType nativeFormat);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Diagnostics.Tracing.SessionMask : ValueType {
    private UInt32 m_mask;
    internal static int SHIFT_SESSION_TO_KEYWORD;
    internal static UInt32 MASK;
    internal static UInt32 MAX;
    public static SessionMask All { get; }
    public bool Item { get; public set; }
    public SessionMask(SessionMask m);
    public SessionMask(UInt32 mask);
    public bool IsEqualOrSupersetOf(SessionMask m);
    public static SessionMask get_All();
    public static SessionMask FromId(int perEventSourceSessionId);
    public ulong ToEventKeywords();
    public static SessionMask FromEventKeywords(ulong m);
    public bool get_Item(int perEventSourceSessionId);
    public void set_Item(int perEventSourceSessionId, bool value);
    public static SessionMask op_BitwiseOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_BitwiseAnd(SessionMask m1, SessionMask m2);
    public static SessionMask op_ExclusiveOr(SessionMask m1, SessionMask m2);
    public static SessionMask op_OnesComplement(SessionMask m);
    public static ulong op_Explicit(SessionMask m);
    public static UInt32 op_Explicit(SessionMask m);
}
internal static class Microsoft.Diagnostics.Tracing.SimpleEventTypes`1 : object {
    private static TraceLoggingEventTypes instance;
    public static TraceLoggingEventTypes Instance { get; }
    public static TraceLoggingEventTypes get_Instance();
    private static TraceLoggingEventTypes InitInstance();
}
internal static class Microsoft.Diagnostics.Tracing.Statics : object {
    public static byte DefaultLevel;
    public static byte TraceLoggingChannel;
    public static byte InTypeMask;
    public static byte InTypeFixedCountFlag;
    public static byte InTypeVariableCountFlag;
    public static byte InTypeCustomCountFlag;
    public static byte InTypeCountMask;
    public static byte InTypeChainFlag;
    public static byte OutTypeMask;
    public static byte OutTypeChainFlag;
    public static EventTags EventTagsMask;
    public static TraceLoggingDataType IntPtrType;
    public static TraceLoggingDataType UIntPtrType;
    public static TraceLoggingDataType HexIntPtrType;
    private static Statics();
    public static Byte[] MetadataForString(string name, int prefixSize, int suffixSize, int additionalSize);
    public static void EncodeTags(int tags, Int32& pos, Byte[] metadata);
    public static byte Combine(int settingValue, byte defaultValue);
    public static byte Combine(int settingValue1, int settingValue2, byte defaultValue);
    public static int Combine(int settingValue1, int settingValue2);
    public static void CheckName(string name);
    public static bool ShouldOverrideFieldName(string fieldName);
    public static TraceLoggingDataType MakeDataType(TraceLoggingDataType baseType, EventFieldFormat format);
    public static TraceLoggingDataType Format8(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format16(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format32(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format64(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatPtr(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatScalar(EventFieldFormat format, TraceLoggingDataType nativeFormat);
    public static bool HasCustomAttribute(PropertyInfo propInfo, Type attributeType);
    public static AttributeType GetCustomAttribute(PropertyInfo propInfo);
    public static AttributeType GetCustomAttribute(Type type);
    public static Type FindEnumerableElementType(Type type);
    public static bool IsGenericMatch(Type type, object openType);
    public static TraceLoggingTypeInfo CreateDefaultTypeInfo(Type dataType, List`1<Type> recursionCheck);
}
internal class Microsoft.Diagnostics.Tracing.StringTypeInfo : TraceLoggingTypeInfo {
    private static StringTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
internal class Microsoft.Diagnostics.Tracing.TimeSpanTypeInfo : TraceLoggingTypeInfo {
    private static TimeSpanTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
[EventSourceAttribute]
internal class Microsoft.Diagnostics.Tracing.TplEventSource : EventSource {
    public static TplEventSource Log;
    public bool Debug { get; }
    private static TplEventSource();
    public bool get_Debug();
    public void DebugFacilityMessage(string Facility, string Message);
    public void DebugFacilityMessage1(string Facility, string Message, string Arg);
    public void SetActivityId(Guid Id);
}
internal static class Microsoft.Diagnostics.Tracing.TraceLoggingDataCollector : object {
    public static int BeginBufferedArray();
    public static void EndBufferedArray(int bookmark, int count);
    public static void AddScalar(PropertyValue value);
    public static void AddScalar(long value);
    public static void AddScalar(double value);
    public static void AddScalar(bool value);
    public static void AddNullTerminatedString(string value);
    public static void AddBinary(string value);
    public static void AddArray(PropertyValue value, int elementSize);
}
internal enum Microsoft.Diagnostics.Tracing.TraceLoggingDataType : Enum {
    public int value__;
    public static TraceLoggingDataType Nil;
    public static TraceLoggingDataType Utf16String;
    public static TraceLoggingDataType MbcsString;
    public static TraceLoggingDataType Int8;
    public static TraceLoggingDataType UInt8;
    public static TraceLoggingDataType Int16;
    public static TraceLoggingDataType UInt16;
    public static TraceLoggingDataType Int32;
    public static TraceLoggingDataType UInt32;
    public static TraceLoggingDataType Int64;
    public static TraceLoggingDataType UInt64;
    public static TraceLoggingDataType Float;
    public static TraceLoggingDataType Double;
    public static TraceLoggingDataType Boolean32;
    public static TraceLoggingDataType Binary;
    public static TraceLoggingDataType Guid;
    public static TraceLoggingDataType FileTime;
    public static TraceLoggingDataType SystemTime;
    public static TraceLoggingDataType HexInt32;
    public static TraceLoggingDataType HexInt64;
    public static TraceLoggingDataType CountedUtf16String;
    public static TraceLoggingDataType CountedMbcsString;
    public static TraceLoggingDataType Struct;
    public static TraceLoggingDataType Char16;
    public static TraceLoggingDataType Char8;
    public static TraceLoggingDataType Boolean8;
    public static TraceLoggingDataType HexInt8;
    public static TraceLoggingDataType HexInt16;
    public static TraceLoggingDataType Utf16Xml;
    public static TraceLoggingDataType MbcsXml;
    public static TraceLoggingDataType CountedUtf16Xml;
    public static TraceLoggingDataType CountedMbcsXml;
    public static TraceLoggingDataType Utf16Json;
    public static TraceLoggingDataType MbcsJson;
    public static TraceLoggingDataType CountedUtf16Json;
    public static TraceLoggingDataType CountedMbcsJson;
    public static TraceLoggingDataType HResult;
}
public class Microsoft.Diagnostics.Tracing.TraceLoggingEventTypes : object {
    internal TraceLoggingTypeInfo[] typeInfos;
    internal string name;
    internal EventTags tags;
    internal byte level;
    internal byte opcode;
    internal EventKeywords keywords;
    internal Byte[] typeMetadata;
    internal int scratchSize;
    internal int dataCount;
    internal int pinCount;
    private ConcurrentSet`2<KeyValuePair`2<string, EventTags>, NameInfo> nameInfos;
    [NullableAttribute("1")]
internal string Name { get; }
    internal EventLevel Level { get; }
    internal EventOpcode Opcode { get; }
    internal EventKeywords Keywords { get; }
    internal EventTags Tags { get; }
    internal TraceLoggingEventTypes(string name, EventTags tags, Type[] types);
    internal TraceLoggingEventTypes(string name, EventTags tags, TraceLoggingTypeInfo[] typeInfos);
    internal TraceLoggingEventTypes(string name, EventTags tags, ParameterInfo[] paramInfos);
    private TraceLoggingEventTypes(EventTags tags, string defaultName, TraceLoggingTypeInfo[] typeInfos);
    internal string get_Name();
    internal EventLevel get_Level();
    internal EventOpcode get_Opcode();
    internal EventKeywords get_Keywords();
    internal EventTags get_Tags();
    internal NameInfo GetNameInfo(string name, EventTags tags);
    private static TraceLoggingTypeInfo[] MakeArray(ParameterInfo[] paramInfos);
    private static TraceLoggingTypeInfo[] MakeArray(Type[] types);
    private static TraceLoggingTypeInfo[] MakeArray(TraceLoggingTypeInfo[] typeInfos);
}
internal class Microsoft.Diagnostics.Tracing.TraceLoggingMetadataCollector : object {
    private Impl impl;
    private FieldMetadata currentGroup;
    private int bufferedArrayFieldCount;
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    internal EventFieldTags Tags { get; internal set; }
    internal int ScratchSize { get; }
    internal int DataCount { get; }
    internal int PinCount { get; }
    private bool BeginningBufferedArray { get; }
    private TraceLoggingMetadataCollector(TraceLoggingMetadataCollector other, FieldMetadata group);
    [CompilerGeneratedAttribute]
internal EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventFieldTags value);
    internal int get_ScratchSize();
    internal int get_DataCount();
    internal int get_PinCount();
    private bool get_BeginningBufferedArray();
    public TraceLoggingMetadataCollector AddGroup(string name);
    public void AddScalar(string name, TraceLoggingDataType type);
    public void AddBinary(string name, TraceLoggingDataType type);
    public void AddNullTerminatedString(string name, TraceLoggingDataType type);
    public void AddArray(string name, TraceLoggingDataType type);
    public void BeginBufferedArray();
    public void EndBufferedArray();
    public void AddCustom(string name, TraceLoggingDataType type, Byte[] metadata);
    internal Byte[] GetMetadata();
    private void AddField(FieldMetadata fieldMetadata);
}
internal abstract class Microsoft.Diagnostics.Tracing.TraceLoggingTypeInfo : object {
    private string name;
    private EventKeywords keywords;
    private EventLevel level;
    private EventOpcode opcode;
    private EventTags tags;
    private Type dataType;
    private Func`2<object, PropertyValue> propertyValueFactory;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TraceLoggingTypeInfo> threadCache;
    public string Name { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventKeywords Keywords { get; }
    public EventTags Tags { get; }
    internal Type DataType { get; }
    internal Func`2<object, PropertyValue> PropertyValueFactory { get; }
    internal TraceLoggingTypeInfo(Type dataType);
    internal TraceLoggingTypeInfo(Type dataType, string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public string get_Name();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventKeywords get_Keywords();
    public EventTags get_Tags();
    internal Type get_DataType();
    internal Func`2<object, PropertyValue> get_PropertyValueFactory();
    public abstract virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public abstract virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
    public static TraceLoggingTypeInfo GetInstance(Type type, List`1<Type> recursionCheck);
}
internal class Microsoft.Diagnostics.Tracing.TypeAnalysis : object {
    internal PropertyAnalysis[] properties;
    internal string name;
    internal EventKeywords keywords;
    internal EventLevel level;
    internal EventOpcode opcode;
    internal EventTags tags;
    public TypeAnalysis(Type dataType, EventDataAttribute eventAttrib, List`1<Type> recursionCheck);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal static class System.Numerics.BitOperations : object {
    public static UInt32 RotateLeft(UInt32 value, int offset);
    public static int PopCount(UInt32 value);
    public static int TrailingZeroCount(UInt32 value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
internal abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public string PlatformName { get; }
    private protected OSPlatformAttribute(string platformName);
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
    public SupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public SupportedOSPlatformGuardAttribute(string platformName);
}
[AttributeUsageAttribute("1")]
internal class System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
    public TargetPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformGuardAttribute(string platformName);
}
internal class System.Sha1ForNonSecretPurposes : ValueType {
    private long _length;
    private UInt32[] _w;
    private int _pos;
    public void Start();
    public void Append(byte input);
    public void Append(Byte[] input);
    public void Finish(Byte[] output);
    private void Drain();
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Argument_InvalidTypeName { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedValidId { get; }
    internal static string EventSource_AbstractMustNotDeclareEventMethods { get; }
    internal static string EventSource_AbstractMustNotDeclareKTOC { get; }
    internal static string EventSource_AddScalarOutOfRange { get; }
    internal static string EventSource_BadHexDigit { get; }
    internal static string EventSource_ChannelTypeDoesNotMatchEventChannelValue { get; }
    internal static string EventSource_DataDescriptorsOutOfRange { get; }
    internal static string EventSource_DuplicateStringKey { get; }
    internal static string EventSource_EnumKindMismatch { get; }
    internal static string EventSource_EvenHexDigits { get; }
    internal static string EventSource_EventChannelOutOfRange { get; }
    internal static string EventSource_EventIdReused { get; }
    internal static string EventSource_EventMustHaveTaskIfNonDefaultOpcode { get; }
    internal static string EventSource_EventMustNotBeExplicitImplementation { get; }
    internal static string EventSource_EventNameDoesNotEqualTaskPlusOpcode { get; }
    internal static string EventSource_EventNameReused { get; }
    internal static string EventSource_EventParametersMismatch { get; }
    internal static string EventSource_EventSourceGuidInUse { get; }
    internal static string EventSource_EventTooBig { get; }
    internal static string EventSource_EventWithAdminChannelMustHaveMessage { get; }
    internal static string EventSource_IllegalKeywordsValue { get; }
    internal static string EventSource_IllegalOpcodeValue { get; }
    internal static string EventSource_IllegalTaskValue { get; }
    internal static string EventSource_IllegalValue { get; }
    internal static string EventSource_IncorrentlyAuthoredTypeInfo { get; }
    internal static string EventSource_InvalidCommand { get; }
    internal static string EventSource_InvalidEventFormat { get; }
    internal static string EventSource_KeywordCollision { get; }
    internal static string EventSource_KeywordNeedPowerOfTwo { get; }
    internal static string EventSource_ListenerCreatedInsideCallback { get; }
    internal static string EventSource_ListenerNotFound { get; }
    internal static string EventSource_ListenerWriteFailure { get; }
    internal static string EventSource_MaxChannelExceeded { get; }
    internal static string EventSource_MismatchIdToWriteEvent { get; }
    internal static string EventSource_NeedGuid { get; }
    internal static string EventSource_NeedName { get; }
    internal static string EventSource_NeedPositiveId { get; }
    internal static string EventSource_NoFreeBuffers { get; }
    internal static string EventSource_NonCompliantTypeError { get; }
    internal static string EventSource_NoRelatedActivityId { get; }
    internal static string EventSource_NotSupportedArrayOfBinary { get; }
    internal static string EventSource_NotSupportedArrayOfNil { get; }
    internal static string EventSource_NotSupportedArrayOfNullTerminatedString { get; }
    internal static string EventSource_NotSupportedCustomSerializedData { get; }
    internal static string EventSource_NotSupportedNestedArraysEnums { get; }
    internal static string EventSource_NullInput { get; }
    internal static string EventSource_OpcodeCollision { get; }
    internal static string EventSource_PinArrayOutOfRange { get; }
    internal static string EventSource_RecursiveTypeDefinition { get; }
    internal static string EventSource_SessionIdError { get; }
    internal static string EventSource_StopsFollowStarts { get; }
    internal static string EventSource_TaskCollision { get; }
    internal static string EventSource_TaskOpcodePairReused { get; }
    internal static string EventSource_TooManyArgs { get; }
    internal static string EventSource_TooManyFields { get; }
    internal static string EventSource_ToString { get; }
    internal static string EventSource_TraitEven { get; }
    internal static string EventSource_TypeMustBeSealedOrAbstract { get; }
    internal static string EventSource_TypeMustDeriveFromEventSource { get; }
    internal static string EventSource_UndefinedChannel { get; }
    internal static string EventSource_UndefinedKeyword { get; }
    internal static string EventSource_UndefinedOpcode { get; }
    internal static string EventSource_UnknownEtwTrait { get; }
    internal static string EventSource_UnsupportedEventTypeInManifest { get; }
    internal static string EventSource_UnsupportedMessageProperty { get; }
    internal static string EventSource_VarArgsParameterMismatch { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Argument_InvalidTypeName();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedValidId();
    internal static string get_EventSource_AbstractMustNotDeclareEventMethods();
    internal static string get_EventSource_AbstractMustNotDeclareKTOC();
    internal static string get_EventSource_AddScalarOutOfRange();
    internal static string get_EventSource_BadHexDigit();
    internal static string get_EventSource_ChannelTypeDoesNotMatchEventChannelValue();
    internal static string get_EventSource_DataDescriptorsOutOfRange();
    internal static string get_EventSource_DuplicateStringKey();
    internal static string get_EventSource_EnumKindMismatch();
    internal static string get_EventSource_EvenHexDigits();
    internal static string get_EventSource_EventChannelOutOfRange();
    internal static string get_EventSource_EventIdReused();
    internal static string get_EventSource_EventMustHaveTaskIfNonDefaultOpcode();
    internal static string get_EventSource_EventMustNotBeExplicitImplementation();
    internal static string get_EventSource_EventNameDoesNotEqualTaskPlusOpcode();
    internal static string get_EventSource_EventNameReused();
    internal static string get_EventSource_EventParametersMismatch();
    internal static string get_EventSource_EventSourceGuidInUse();
    internal static string get_EventSource_EventTooBig();
    internal static string get_EventSource_EventWithAdminChannelMustHaveMessage();
    internal static string get_EventSource_IllegalKeywordsValue();
    internal static string get_EventSource_IllegalOpcodeValue();
    internal static string get_EventSource_IllegalTaskValue();
    internal static string get_EventSource_IllegalValue();
    internal static string get_EventSource_IncorrentlyAuthoredTypeInfo();
    internal static string get_EventSource_InvalidCommand();
    internal static string get_EventSource_InvalidEventFormat();
    internal static string get_EventSource_KeywordCollision();
    internal static string get_EventSource_KeywordNeedPowerOfTwo();
    internal static string get_EventSource_ListenerCreatedInsideCallback();
    internal static string get_EventSource_ListenerNotFound();
    internal static string get_EventSource_ListenerWriteFailure();
    internal static string get_EventSource_MaxChannelExceeded();
    internal static string get_EventSource_MismatchIdToWriteEvent();
    internal static string get_EventSource_NeedGuid();
    internal static string get_EventSource_NeedName();
    internal static string get_EventSource_NeedPositiveId();
    internal static string get_EventSource_NoFreeBuffers();
    internal static string get_EventSource_NonCompliantTypeError();
    internal static string get_EventSource_NoRelatedActivityId();
    internal static string get_EventSource_NotSupportedArrayOfBinary();
    internal static string get_EventSource_NotSupportedArrayOfNil();
    internal static string get_EventSource_NotSupportedArrayOfNullTerminatedString();
    internal static string get_EventSource_NotSupportedCustomSerializedData();
    internal static string get_EventSource_NotSupportedNestedArraysEnums();
    internal static string get_EventSource_NullInput();
    internal static string get_EventSource_OpcodeCollision();
    internal static string get_EventSource_PinArrayOutOfRange();
    internal static string get_EventSource_RecursiveTypeDefinition();
    internal static string get_EventSource_SessionIdError();
    internal static string get_EventSource_StopsFollowStarts();
    internal static string get_EventSource_TaskCollision();
    internal static string get_EventSource_TaskOpcodePairReused();
    internal static string get_EventSource_TooManyArgs();
    internal static string get_EventSource_TooManyFields();
    internal static string get_EventSource_ToString();
    internal static string get_EventSource_TraitEven();
    internal static string get_EventSource_TypeMustBeSealedOrAbstract();
    internal static string get_EventSource_TypeMustDeriveFromEventSource();
    internal static string get_EventSource_UndefinedChannel();
    internal static string get_EventSource_UndefinedKeyword();
    internal static string get_EventSource_UndefinedOpcode();
    internal static string get_EventSource_UnknownEtwTrait();
    internal static string get_EventSource_UnsupportedEventTypeInManifest();
    internal static string get_EventSource_UnsupportedMessageProperty();
    internal static string get_EventSource_VarArgsParameterMismatch();
}
