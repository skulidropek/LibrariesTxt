internal static class Microsoft.DotNet.Cli.DotnetFiles : object {
    private static Lazy`1<DotnetVersionFile> s_versionFileObject;
    private static string SdkRootFolder { get; }
    public static string VersionFile { get; }
    internal static DotnetVersionFile VersionFileObject { get; }
    private static DotnetFiles();
    private static string get_SdkRootFolder();
    public static string get_VersionFile();
    internal static DotnetVersionFile get_VersionFileObject();
}
public abstract class Microsoft.DotNet.Cli.Utils.AbstractPathBasedCommandResolver : object {
    protected IEnvironmentProvider _environment;
    protected IPlatformCommandSpecFactory _commandSpecFactory;
    public AbstractPathBasedCommandResolver(IEnvironmentProvider environment, IPlatformCommandSpecFactory commandSpecFactory);
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
    internal abstract virtual string ResolveCommandPath(CommandResolverArguments commandResolverArguments);
    internal abstract virtual CommandResolutionStrategy GetCommandResolutionStrategy();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Cli.Utils.AnsiColorExtensions : object {
    [ExtensionAttribute]
public static string Black(string text);
    [ExtensionAttribute]
public static string Red(string text);
    [ExtensionAttribute]
public static string Green(string text);
    [ExtensionAttribute]
public static string Yellow(string text);
    [ExtensionAttribute]
public static string Blue(string text);
    [ExtensionAttribute]
public static string Magenta(string text);
    [ExtensionAttribute]
public static string Cyan(string text);
    [ExtensionAttribute]
public static string White(string text);
    [ExtensionAttribute]
public static string Bold(string text);
}
public class Microsoft.DotNet.Cli.Utils.AnsiConsole : object {
    private static int Light;
    private int _boldRecursion;
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleColor <OriginalForegroundColor>k__BackingField;
    public TextWriter Writer { get; }
    public ConsoleColor OriginalForegroundColor { get; }
    private AnsiConsole(TextWriter writer);
    public static AnsiConsole GetOutput();
    public static AnsiConsole GetError();
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    [CompilerGeneratedAttribute]
public ConsoleColor get_OriginalForegroundColor();
    private void SetColor(ConsoleColor color);
    private void SetBold(bool bold);
    public void WriteLine(string message);
    public void Write(string message);
}
public class Microsoft.DotNet.Cli.Utils.AppBaseCommandResolver : AbstractPathBasedCommandResolver {
    public AppBaseCommandResolver(IEnvironmentProvider environment, IPlatformCommandSpecFactory commandSpecFactory);
    internal virtual string ResolveCommandPath(CommandResolverArguments commandResolverArguments);
    internal virtual CommandResolutionStrategy GetCommandResolutionStrategy();
}
public class Microsoft.DotNet.Cli.Utils.AppBaseDllCommandResolver : object {
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
}
public class Microsoft.DotNet.Cli.Utils.ApplicationInsightsEntryFormat : object {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <Measurements>k__BackingField;
    public string EventName { get; }
    public IDictionary`2<string, string> Properties { get; }
    public IDictionary`2<string, double> Measurements { get; }
    public ApplicationInsightsEntryFormat(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> measurements);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_Measurements();
}
public static class Microsoft.DotNet.Cli.Utils.ArgumentEscaper : object {
    public static string EscapeAndConcatenateArgArrayForProcessStart(IEnumerable`1<string> args);
    public static string EscapeAndConcatenateArgArrayForCmdProcessStart(IEnumerable`1<string> args);
    private static IEnumerable`1<string> EscapeArgArray(IEnumerable`1<string> args);
    private static IEnumerable`1<string> EscapeArgArrayForCmd(IEnumerable`1<string> arguments);
    public static string EscapeSingleArg(string arg);
    private static string EscapeArgForCmd(string argument);
    internal static bool ShouldSurroundWithQuotes(string argument);
    internal static bool IsSurroundedWithQuotes(string argument);
    internal static bool ArgumentContainsWhitespace(string argument);
}
public class Microsoft.DotNet.Cli.Utils.BlockFilter : object {
    public sealed virtual IEnumerable`1<ApplicationInsightsEntryFormat> Filter(object o);
}
public class Microsoft.DotNet.Cli.Utils.BlockingMemoryStream : Stream {
    private BlockingCollection`1<Byte[]> _buffers;
    private ArraySegment`1<byte> _remaining;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void DoneWriting();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
public class Microsoft.DotNet.Cli.Utils.BuiltInCommand : object {
    private IEnumerable`1<string> _commandArgs;
    private Func`2<String[], int> _builtInCommand;
    private IBuiltInCommandEnvironment _environment;
    private StreamForwarder _stdOut;
    private StreamForwarder _stdErr;
    private string _workingDirectory;
    [CompilerGeneratedAttribute]
private string <CommandName>k__BackingField;
    public string CommandName { get; }
    public string CommandArgs { get; }
    public CommandResolutionStrategy ResolutionStrategy { get; }
    public BuiltInCommand(string commandName, IEnumerable`1<string> commandArgs, Func`2<String[], int> builtInCommand);
    internal BuiltInCommand(string commandName, IEnumerable`1<string> commandArgs, Func`2<String[], int> builtInCommand, IBuiltInCommandEnvironment environment);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CommandName();
    public sealed virtual string get_CommandArgs();
    public sealed virtual CommandResult Execute();
    public sealed virtual ICommand OnOutputLine(Action`1<string> handler);
    public sealed virtual ICommand OnErrorLine(Action`1<string> handler);
    public sealed virtual ICommand WorkingDirectory(string workingDirectory);
    public sealed virtual CommandResolutionStrategy get_ResolutionStrategy();
    public sealed virtual ICommand CaptureStdErr();
    public sealed virtual ICommand CaptureStdOut();
    public sealed virtual ICommand EnvironmentVariable(string name, string value);
    public sealed virtual ICommand ForwardStdErr(TextWriter to, bool onlyIfVerbose, bool ansiPassThrough);
    public sealed virtual ICommand ForwardStdOut(TextWriter to, bool onlyIfVerbose, bool ansiPassThrough);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Cli.Utils.CollectionsExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> OrEmptyIfNull(IEnumerable`1<T> enumerable);
}
public class Microsoft.DotNet.Cli.Utils.Command : object {
    private Process _process;
    private StreamForwarder _stdOut;
    private StreamForwarder _stdErr;
    private bool _running;
    [CompilerGeneratedAttribute]
private CommandResolutionStrategy <ResolutionStrategy>k__BackingField;
    public CommandResolutionStrategy ResolutionStrategy { get; }
    public string CommandName { get; }
    public string CommandArgs { get; }
    private Command(CommandSpec commandSpec);
    public static Command CreateDotNet(string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration);
    public static Command Create(string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration, string outputPath, string applicationName);
    public static Command Create(ICommandResolverPolicy commandResolverPolicy, string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration, string outputPath, string applicationName);
    public static Command Create(CommandSpec commandSpec);
    public sealed virtual CommandResult Execute();
    public sealed virtual ICommand WorkingDirectory(string projectDirectory);
    public sealed virtual ICommand EnvironmentVariable(string name, string value);
    public sealed virtual ICommand CaptureStdOut();
    public sealed virtual ICommand CaptureStdErr();
    public sealed virtual ICommand ForwardStdOut(TextWriter to, bool onlyIfVerbose, bool ansiPassThrough);
    public sealed virtual ICommand ForwardStdErr(TextWriter to, bool onlyIfVerbose, bool ansiPassThrough);
    public sealed virtual ICommand OnOutputLine(Action`1<string> handler);
    public sealed virtual ICommand OnErrorLine(Action`1<string> handler);
    [CompilerGeneratedAttribute]
public sealed virtual CommandResolutionStrategy get_ResolutionStrategy();
    public sealed virtual string get_CommandName();
    public sealed virtual string get_CommandArgs();
    private string FormatProcessInfo(ProcessStartInfo info);
    private void EnsureStdOut();
    private void EnsureStdErr();
    private void ThrowIfRunning(string memberName);
}
public static class Microsoft.DotNet.Cli.Utils.CommandContext : object {
    private static Lazy`1<bool> _verbose;
    private static Lazy`1<bool> _ansiPassThru;
    private static CommandContext();
    public static bool IsVerbose();
    public static bool ShouldPassAnsiCodesThrough();
    public static void SetVerbose(bool value);
}
public class Microsoft.DotNet.Cli.Utils.CommandFactory : object {
    public sealed virtual ICommand Create(string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration);
}
public class Microsoft.DotNet.Cli.Utils.CommandParsing.Chain`2 : ValueType {
    public TLeft Left;
    public TDown Down;
    public Chain`2(TLeft left, TDown down);
}
public class Microsoft.DotNet.Cli.Utils.CommandParsing.CommandGrammar : Grammar {
    public Parser`1<IList`1<string>> Parse;
    private CommandGrammar(Func`2<string, string> variable, bool preserveSurroundingQuotes);
    public static String[] Process(string text, Func`2<string, string> variables, bool preserveSurroundingQuotes);
}
public class Microsoft.DotNet.Cli.Utils.CommandParsing.Cursor : ValueType {
    private string _text;
    private int _start;
    private int _end;
    public bool IsEnd { get; }
    public Cursor(string text, int start, int end);
    public bool get_IsEnd();
    public char Peek(int index);
    public Result`1<TValue> Advance(TValue result, int length);
}
public class Microsoft.DotNet.Cli.Utils.CommandParsing.Grammar : object {
    protected static Parser`1<IList`1<TValue>> Rep1(Parser`1<TValue> parser);
    protected static Parser`1<IList`1<TValue>> Rep(Parser`1<TValue> parser);
    protected static Parser`1<char> Ch();
    private static Parser`1<bool> IsEnd();
    protected static Parser`1<char> Ch(char ch);
}
public class Microsoft.DotNet.Cli.Utils.CommandParsing.Parser`1 : MulticastDelegate {
    public Parser`1(object object, IntPtr method);
    public virtual Result`1<TValue> Invoke(Cursor cursor);
    public virtual IAsyncResult BeginInvoke(Cursor cursor, AsyncCallback callback, object object);
    public virtual Result`1<TValue> EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Cli.Utils.CommandParsing.ParserExtensions : object {
    [ExtensionAttribute]
public static Parser`1<Chain`2<T1, T2>> And(Parser`1<T1> parser1, Parser`1<T2> parser2);
    [ExtensionAttribute]
public static Parser`1<T1> Or(Parser`1<T1> parser1, Parser`1<T1> parser2);
    [ExtensionAttribute]
public static Parser`1<T1> Not(Parser`1<T1> parser1, Parser`1<T2> parser2);
    [ExtensionAttribute]
public static Parser`1<T1> Left(Parser`1<Chain`2<T1, T2>> parser);
    [ExtensionAttribute]
public static Parser`1<T2> Down(Parser`1<Chain`2<T1, T2>> parser);
    [ExtensionAttribute]
public static Parser`1<T2> Build(Parser`1<T1> parser, Func`2<T1, T2> builder);
    [ExtensionAttribute]
public static Parser`1<string> Str(Parser`1<IList`1<char>> parser);
    [ExtensionAttribute]
public static Parser`1<string> Str(Parser`1<IList`1<string>> parser);
}
public class Microsoft.DotNet.Cli.Utils.CommandParsing.Result`1 : ValueType {
    public TValue Value;
    public Cursor Remainder;
    public bool IsEmpty { get; }
    public static Result`1<TValue> Empty { get; }
    public Result`1(TValue value, Cursor remainder);
    public bool get_IsEmpty();
    public static Result`1<TValue> get_Empty();
    public Result`1<TValue2> AsValue(TValue2 value2);
}
public enum Microsoft.DotNet.Cli.Utils.CommandResolutionStrategy : Enum {
    public int value__;
    public static CommandResolutionStrategy DepsFile;
    public static CommandResolutionStrategy ProjectDependenciesPackage;
    public static CommandResolutionStrategy ProjectToolsPackage;
    public static CommandResolutionStrategy BaseDirectory;
    public static CommandResolutionStrategy ProjectLocal;
    public static CommandResolutionStrategy Path;
    public static CommandResolutionStrategy RootedPath;
    public static CommandResolutionStrategy OutputPath;
    public static CommandResolutionStrategy None;
}
internal class Microsoft.DotNet.Cli.Utils.CommandResolver : object {
    public static CommandSpec TryResolveCommandSpec(string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration, string outputPath, string applicationName);
    public static CommandSpec TryResolveCommandSpec(ICommandResolverPolicy commandResolverPolicy, string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration, string outputPath, string applicationName);
}
public class Microsoft.DotNet.Cli.Utils.CommandResolverArguments : object {
    [CompilerGeneratedAttribute]
private string <CommandName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CommandArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <InferredExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildBasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DepsJsonFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    public string CommandName { get; public set; }
    public IEnumerable`1<string> CommandArguments { get; public set; }
    public NuGetFramework Framework { get; public set; }
    public string OutputPath { get; public set; }
    public string ProjectDirectory { get; public set; }
    public string Configuration { get; public set; }
    public IEnumerable`1<string> InferredExtensions { get; public set; }
    public string BuildBasePath { get; public set; }
    public string DepsJsonFile { get; public set; }
    public string ApplicationName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CommandName();
    [CompilerGeneratedAttribute]
public void set_CommandName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CommandArguments();
    [CompilerGeneratedAttribute]
public void set_CommandArguments(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public void set_Framework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectDirectory();
    [CompilerGeneratedAttribute]
public void set_ProjectDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_InferredExtensions();
    [CompilerGeneratedAttribute]
public void set_InferredExtensions(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_BuildBasePath();
    [CompilerGeneratedAttribute]
public void set_BuildBasePath(string value);
    [CompilerGeneratedAttribute]
public string get_DepsJsonFile();
    [CompilerGeneratedAttribute]
public void set_DepsJsonFile(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
public void set_ApplicationName(string value);
}
public class Microsoft.DotNet.Cli.Utils.CommandResult : ValueType {
    public static CommandResult Empty;
    [CompilerGeneratedAttribute]
private ProcessStartInfo <StartInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdOut>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StdErr>k__BackingField;
    public ProcessStartInfo StartInfo { get; }
    public int ExitCode { get; }
    public string StdOut { get; }
    public string StdErr { get; }
    public CommandResult(ProcessStartInfo startInfo, int exitCode, string stdOut, string stdErr);
    private static CommandResult();
    [CompilerGeneratedAttribute]
public ProcessStartInfo get_StartInfo();
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
public string get_StdOut();
    [CompilerGeneratedAttribute]
public string get_StdErr();
}
public class Microsoft.DotNet.Cli.Utils.CommandSpec : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandResolutionStrategy <ResolutionStrategy>k__BackingField;
    public string Path { get; }
    public string Args { get; }
    public Dictionary`2<string, string> EnvironmentVariables { get; }
    public CommandResolutionStrategy ResolutionStrategy { get; }
    public CommandSpec(string path, string args, CommandResolutionStrategy resolutionStrategy, Dictionary`2<string, string> environmentVariables);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Args();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public CommandResolutionStrategy get_ResolutionStrategy();
    internal void AddEnvironmentVariablesFromProject(IProject project);
}
public class Microsoft.DotNet.Cli.Utils.CommandUnknownException : GracefulException {
    public CommandUnknownException(string commandName);
    public CommandUnknownException(string commandName, Exception innerException);
}
public class Microsoft.DotNet.Cli.Utils.CompositeCommandResolver : object {
    private IList`1<ICommandResolver> _orderedCommandResolvers;
    public IEnumerable`1<ICommandResolver> OrderedCommandResolvers { get; }
    public IEnumerable`1<ICommandResolver> get_OrderedCommandResolvers();
    public void AddCommandResolver(ICommandResolver commandResolver);
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
}
public static class Microsoft.DotNet.Cli.Utils.Constants : object {
    public static string DefaultConfiguration;
    public static string ProjectFileName;
    public static string ExeSuffix;
    public static string BinDirectoryName;
    public static string ObjDirectoryName;
    public static string MSBUILD_EXE_PATH;
    public static string MSBuildExtensionsPath;
    public static string ProjectArgumentName;
    public static string SolutionArgumentName;
    private static Platform CurrentPlatform { get; }
    private static Constants();
    private static Platform get_CurrentPlatform();
}
public static class Microsoft.DotNet.Cli.Utils.DebugHelper : object {
    [ConditionalAttribute("DEBUG")]
public static void HandleDebugSwitch(String[]& args);
    public static void WaitForDebugger();
}
public class Microsoft.DotNet.Cli.Utils.DefaultCommandResolverPolicy : object {
    public sealed virtual CompositeCommandResolver CreateCommandResolver();
    public static CompositeCommandResolver Create();
    public static CompositeCommandResolver CreateDefaultCommandResolver(IEnvironmentProvider environment, IPackagedCommandSpecFactory packagedCommandSpecFactory, IPlatformCommandSpecFactory platformCommandSpecFactory, IPublishedPathCommandSpecFactory publishedPathCommandSpecFactory);
}
public class Microsoft.DotNet.Cli.Utils.DepsJsonCommandFactory : object {
    private DepsJsonCommandResolver _depsJsonCommandResolver;
    private string _temporaryDirectory;
    private string _depsJsonFile;
    private string _runtimeConfigFile;
    public DepsJsonCommandFactory(string depsJsonFile, string runtimeConfigFile, string nugetPackagesRoot, string temporaryDirectory);
    public sealed virtual ICommand Create(string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration);
}
public class Microsoft.DotNet.Cli.Utils.DepsJsonCommandResolver : object {
    private static String[] s_extensionPreferenceOrder;
    private string _nugetPackageRoot;
    private Muxer _muxer;
    public DepsJsonCommandResolver(string nugetPackageRoot);
    public DepsJsonCommandResolver(Muxer muxer, string nugetPackageRoot);
    private static DepsJsonCommandResolver();
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
    private CommandSpec ResolveFromDepsJsonFile(string commandName, IEnumerable`1<string> commandArgs, string depsJsonFile);
    public DependencyContext LoadDependencyContextFromFile(string depsJsonFile);
    public string GetCommandPathFromDependencyContext(string commandName, DependencyContext dependencyContext);
    private IEnumerable`1<CommandCandidate> GetCommandCandidates(string commandName, DependencyContext dependencyContext, CommandCandidateType commandCandidateType);
    private IEnumerable`1<CommandCandidate> GetCommandCandidatesFromRuntimeAssetGroups(string commandName, IEnumerable`1<RuntimeAssetGroup> runtimeAssetGroups, string PackageName, string PackageVersion);
    private CommandCandidate ChooseCommandCandidate(IEnumerable`1<CommandCandidate> commandCandidates);
    private CommandSpec CreateCommandSpecUsingMuxerIfPortable(string commandPath, IEnumerable`1<string> commandArgs, string depsJsonFile, CommandResolutionStrategy commandResolutionStrategy, string nugetPackagesRoot, bool isPortable);
    private bool IsPortableApp(string commandPath);
    private IEnumerable`1<string> GetDepsFileArguments(string depsJsonFile);
    private IEnumerable`1<string> GetAdditionalProbingPathArguments();
}
internal class Microsoft.DotNet.Cli.Utils.DotnetVersionFile : object {
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitSha>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildRid>k__BackingField;
    public bool Exists { get; public set; }
    public string CommitSha { get; public set; }
    public string BuildNumber { get; public set; }
    public string BuildRid { get; public set; }
    public DotnetVersionFile(string versionFilePath);
    [CompilerGeneratedAttribute]
public bool get_Exists();
    [CompilerGeneratedAttribute]
public void set_Exists(bool value);
    [CompilerGeneratedAttribute]
public string get_CommitSha();
    [CompilerGeneratedAttribute]
public void set_CommitSha(string value);
    [CompilerGeneratedAttribute]
public string get_BuildNumber();
    [CompilerGeneratedAttribute]
public void set_BuildNumber(string value);
    [CompilerGeneratedAttribute]
public string get_BuildRid();
    [CompilerGeneratedAttribute]
public void set_BuildRid(string value);
}
public static class Microsoft.DotNet.Cli.Utils.Env : object {
    private static IEnvironmentProvider _environment;
    public static IEnumerable`1<string> ExecutableExtensions { get; }
    private static Env();
    public static IEnumerable`1<string> get_ExecutableExtensions();
    public static string GetCommandPath(string commandName, String[] extensions);
    public static string GetCommandPathFromRootPath(string rootPath, string commandName, String[] extensions);
    public static string GetCommandPathFromRootPath(string rootPath, string commandName, IEnumerable`1<string> extensions);
    public static bool GetEnvironmentVariableAsBool(string name, bool defaultValue);
}
public class Microsoft.DotNet.Cli.Utils.EnvironmentProvider : object {
    private IEnumerable`1<string> _searchPaths;
    private IEnumerable`1<string> _executableExtensions;
    public IEnumerable`1<string> ExecutableExtensions { get; }
    private IEnumerable`1<string> SearchPaths { get; }
    public EnvironmentProvider(IEnumerable`1<string> extensionsOverride, IEnumerable`1<string> searchPathsOverride);
    public sealed virtual IEnumerable`1<string> get_ExecutableExtensions();
    private IEnumerable`1<string> get_SearchPaths();
    public sealed virtual string GetCommandPath(string commandName, String[] extensions);
    public sealed virtual string GetCommandPathFromRootPath(string rootPath, string commandName, String[] extensions);
    public sealed virtual string GetCommandPathFromRootPath(string rootPath, string commandName, IEnumerable`1<string> extensions);
    public sealed virtual string GetEnvironmentVariable(string name);
    public sealed virtual bool GetEnvironmentVariableAsBool(string name, bool defaultValue);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Cli.Utils.ExceptionExtensions : object {
    internal static string CLI_User_Displayed_Exception;
    [ExtensionAttribute]
public static TException DisplayAsError(TException exception);
    [ExtensionAttribute]
public static void ReportAsWarning(Exception e);
    [ExtensionAttribute]
public static bool ShouldBeDisplayedAsError(Exception e);
}
public static class Microsoft.DotNet.Cli.Utils.FileAccessRetrier : object {
    [AsyncStateMachineAttribute("Microsoft.DotNet.Cli.Utils.FileAccessRetrier/<RetryOnFileAccessFailure>d__0`1")]
public static Task`1<T> RetryOnFileAccessFailure(Func`1<T> func, int maxRetries, TimeSpan sleepDuration);
}
public static class Microsoft.DotNet.Cli.Utils.FileNameSuffixes : object {
    public static string DepsJson;
    public static string RuntimeConfigJson;
    public static string RuntimeConfigDevJson;
    [CompilerGeneratedAttribute]
private static PlatformFileNameSuffixes <DotNet>k__BackingField;
    [CompilerGeneratedAttribute]
private static PlatformFileNameSuffixes <Windows>k__BackingField;
    [CompilerGeneratedAttribute]
private static PlatformFileNameSuffixes <OSX>k__BackingField;
    [CompilerGeneratedAttribute]
private static PlatformFileNameSuffixes <Linux>k__BackingField;
    public static PlatformFileNameSuffixes CurrentPlatform { get; }
    public static PlatformFileNameSuffixes DotNet { get; }
    public static PlatformFileNameSuffixes Windows { get; }
    public static PlatformFileNameSuffixes OSX { get; }
    public static PlatformFileNameSuffixes Linux { get; }
    private static FileNameSuffixes();
    public static PlatformFileNameSuffixes get_CurrentPlatform();
    [CompilerGeneratedAttribute]
public static PlatformFileNameSuffixes get_DotNet();
    [CompilerGeneratedAttribute]
public static PlatformFileNameSuffixes get_Windows();
    [CompilerGeneratedAttribute]
public static PlatformFileNameSuffixes get_OSX();
    [CompilerGeneratedAttribute]
public static PlatformFileNameSuffixes get_Linux();
}
internal class Microsoft.DotNet.Cli.Utils.ForwardingAppImplementation : object {
    private static string HostExe;
    private string _forwardApplicationPath;
    private IEnumerable`1<string> _argsToForward;
    private string _depsFile;
    private string _runtimeConfig;
    private string _additionalProbingPath;
    private Dictionary`2<string, string> _environmentVariables;
    private String[] _allArgs;
    public ForwardingAppImplementation(string forwardApplicationPath, IEnumerable`1<string> argsToForward, string depsFile, string runtimeConfig, string additionalProbingPath, Dictionary`2<string, string> environmentVariables);
    public int Execute();
    public ProcessStartInfo GetProcessStartInfo();
    public ForwardingAppImplementation WithEnvironmentVariable(string name, string value);
    private string GetHostExeName();
}
internal class Microsoft.DotNet.Cli.Utils.FrameworkDependencyFile : object {
    private string _depsFilePath;
    private Lazy`1<DependencyContext> _dependencyContext;
    private DependencyContext DependencyContext { get; }
    private DependencyContext get_DependencyContext();
    public bool SupportsCurrentRuntime();
    public bool IsRuntimeSupported(string runtimeIdentifier);
    public string GetNetStandardLibraryVersion();
    private DependencyContext CreateDependencyContext();
}
public class Microsoft.DotNet.Cli.Utils.GenericPlatformCommandSpecFactory : object {
    public sealed virtual CommandSpec CreateCommandSpec(string commandName, IEnumerable`1<string> args, string commandPath, CommandResolutionStrategy resolutionStrategy, IEnvironmentProvider environment);
}
public class Microsoft.DotNet.Cli.Utils.GracefulException : Exception {
    public GracefulException(string message);
    public GracefulException(string format, String[] args);
    public GracefulException(string message, Exception innerException);
}
internal interface Microsoft.DotNet.Cli.Utils.IBuiltInCommandEnvironment {
    public abstract virtual TextWriter GetConsoleOut();
    public abstract virtual void SetConsoleOut(TextWriter newOut);
    public abstract virtual TextWriter GetConsoleError();
    public abstract virtual void SetConsoleError(TextWriter newError);
    public abstract virtual string GetWorkingDirectory();
    public abstract virtual void SetWorkingDirectory(string path);
}
public interface Microsoft.DotNet.Cli.Utils.ICommand {
    public CommandResolutionStrategy ResolutionStrategy { get; }
    public string CommandName { get; }
    public string CommandArgs { get; }
    public abstract virtual CommandResult Execute();
    public abstract virtual ICommand WorkingDirectory(string projectDirectory);
    public abstract virtual ICommand EnvironmentVariable(string name, string value);
    public abstract virtual ICommand CaptureStdOut();
    public abstract virtual ICommand CaptureStdErr();
    public abstract virtual ICommand ForwardStdOut(TextWriter to, bool onlyIfVerbose, bool ansiPassThrough);
    public abstract virtual ICommand ForwardStdErr(TextWriter to, bool onlyIfVerbose, bool ansiPassThrough);
    public abstract virtual ICommand OnOutputLine(Action`1<string> handler);
    public abstract virtual ICommand OnErrorLine(Action`1<string> handler);
    public abstract virtual CommandResolutionStrategy get_ResolutionStrategy();
    public abstract virtual string get_CommandName();
    public abstract virtual string get_CommandArgs();
}
public interface Microsoft.DotNet.Cli.Utils.ICommandFactory {
    public abstract virtual ICommand Create(string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration);
}
public interface Microsoft.DotNet.Cli.Utils.ICommandResolver {
    public abstract virtual CommandSpec Resolve(CommandResolverArguments arguments);
}
public interface Microsoft.DotNet.Cli.Utils.ICommandResolverPolicy {
    public abstract virtual CompositeCommandResolver CreateCommandResolver();
}
public interface Microsoft.DotNet.Cli.Utils.IEnvironmentProvider {
    public IEnumerable`1<string> ExecutableExtensions { get; }
    public abstract virtual IEnumerable`1<string> get_ExecutableExtensions();
    public abstract virtual string GetCommandPath(string commandName, String[] extensions);
    public abstract virtual string GetCommandPathFromRootPath(string rootPath, string commandName, String[] extensions);
    public abstract virtual string GetCommandPathFromRootPath(string rootPath, string commandName, IEnumerable`1<string> extensions);
    public abstract virtual bool GetEnvironmentVariableAsBool(string name, bool defaultValue);
    public abstract virtual string GetEnvironmentVariable(string name);
}
public class Microsoft.DotNet.Cli.Utils.InstrumentationEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, double> <Measurements>k__BackingField;
    public string EventName { get; }
    public IDictionary`2<string, string> Properties { get; }
    public IDictionary`2<string, double> Measurements { get; }
    internal InstrumentationEventArgs(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> measurements);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, double> get_Measurements();
}
public interface Microsoft.DotNet.Cli.Utils.IPackagedCommandSpecFactory {
    public abstract virtual CommandSpec CreateCommandSpecFromLibrary(LockFileTargetLibrary toolLibrary, string commandName, IEnumerable`1<string> commandArguments, IEnumerable`1<string> allowedExtensions, LockFile lockFile, CommandResolutionStrategy commandResolutionStrategy, string depsFilePath, string runtimeConfigPath);
}
public interface Microsoft.DotNet.Cli.Utils.IPlatformCommandSpecFactory {
    public abstract virtual CommandSpec CreateCommandSpec(string commandName, IEnumerable`1<string> args, string commandPath, CommandResolutionStrategy resolutionStrategy, IEnvironmentProvider environment);
}
internal interface Microsoft.DotNet.Cli.Utils.IProject {
    public string DepsJsonPath { get; }
    public string ProjectRoot { get; }
    public string RuntimeConfigJsonPath { get; }
    public string FullOutputPath { get; }
    public NuGetFramework DotnetCliToolTargetFramework { get; }
    public Dictionary`2<string, string> EnvironmentVariables { get; }
    public string ToolDepsJsonGeneratorProject { get; }
    public abstract virtual LockFile GetLockFile();
    public abstract virtual bool TryGetLockFile(LockFile& lockFile);
    public abstract virtual IEnumerable`1<SingleProjectInfo> GetTools();
    public abstract virtual string get_DepsJsonPath();
    public abstract virtual string get_ProjectRoot();
    public abstract virtual string get_RuntimeConfigJsonPath();
    public abstract virtual string get_FullOutputPath();
    public abstract virtual NuGetFramework get_DotnetCliToolTargetFramework();
    public abstract virtual Dictionary`2<string, string> get_EnvironmentVariables();
    public abstract virtual string get_ToolDepsJsonGeneratorProject();
}
public interface Microsoft.DotNet.Cli.Utils.IPublishedPathCommandSpecFactory {
    public abstract virtual CommandSpec CreateCommandSpecFromPublishFolder(string commandPath, IEnumerable`1<string> commandArguments, CommandResolutionStrategy commandResolutionStrategy, string depsFilePath, string runtimeConfigPath);
}
public interface Microsoft.DotNet.Cli.Utils.IReporter {
    public abstract virtual void WriteLine(string message);
    public abstract virtual void WriteLine();
    public abstract virtual void Write(string message);
}
public interface Microsoft.DotNet.Cli.Utils.ITelemetryFilter {
    public abstract virtual IEnumerable`1<ApplicationInsightsEntryFormat> Filter(object o);
}
internal static class Microsoft.DotNet.Cli.Utils.LocalizableStrings : object {
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private static ResourceManager <ResourceManager>k__BackingField;
    internal static CultureInfo Culture { get; internal set; }
    internal static ResourceManager ResourceManager { get; }
    internal static string MalformedText { get; }
    internal static string BuildOutputPathDoesNotExist { get; }
    internal static string AttemptingToFindCommand { get; }
    internal static string FailedToFindToolAssembly { get; }
    internal static string FailedToFindCommandPath { get; }
    internal static string UnableToLocateDotnetMultiplexer { get; }
    internal static string LookingForPreferCliRuntimeFile { get; }
    internal static string IgnoringPreferCLIRuntimeFile { get; }
    internal static string CouldNotFindToolRuntimeConfigFile { get; }
    internal static string AttemptingToResolve { get; }
    internal static string DidNotFindAMatchingProject { get; }
    internal static string InvalidCommandResolverArguments { get; }
    internal static string DoesNotExist { get; }
    internal static string AmbiguousCommandName { get; }
    internal static string ToolLibraryFound { get; }
    internal static string MSBuildExePath { get; }
    internal static string MSBuildProjectPath { get; }
    internal static string MultipleProjectFilesFound { get; }
    internal static string DidNotFindProject { get; }
    internal static string ResolvingCommandSpec { get; }
    internal static string FailedToResolveCommandSpec { get; }
    internal static string AttemptingToResolveCommandSpec { get; }
    internal static string NuGetPackagesRoot { get; }
    internal static string FoundToolLockFile { get; }
    internal static string LibraryNotFoundInLockFile { get; }
    internal static string AttemptingToCreateCommandSpec { get; }
    internal static string CommandSpecIsNull { get; }
    internal static string ExpectDepsJsonAt { get; }
    internal static string GeneratingDepsJson { get; }
    internal static string UnableToGenerateDepsJson { get; }
    internal static string DepsJsonGeneratorProjectNotSet { get; }
    internal static string UnableToDeleteTemporaryDepsJson { get; }
    internal static string VersionForPackageCouldNotBeResolved { get; }
    internal static string FileNotFound { get; }
    internal static string ProjectNotRestoredOrRestoreFailed { get; }
    internal static string NoExecutableFoundMatchingCommand { get; }
    internal static string CommandAssembliesNotFound { get; }
    internal static string WaitingForDebuggerToAttach { get; }
    internal static string ProcessId { get; }
    internal static string CouldNotAccessAssetsFile { get; }
    internal static string DotNetCommandLineTools { get; }
    internal static string WriteLineForwarderSetPreviously { get; }
    internal static string AlreadyCapturingStream { get; }
    internal static string RunningFileNameArguments { get; }
    internal static string ProcessExitedWithCode { get; }
    internal static string UnableToInvokeMemberNameAfterCommand { get; }
    private static LocalizableStrings();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
internal static ResourceManager get_ResourceManager();
    internal static string get_MalformedText();
    internal static string get_BuildOutputPathDoesNotExist();
    internal static string get_AttemptingToFindCommand();
    internal static string get_FailedToFindToolAssembly();
    internal static string get_FailedToFindCommandPath();
    internal static string get_UnableToLocateDotnetMultiplexer();
    internal static string get_LookingForPreferCliRuntimeFile();
    internal static string get_IgnoringPreferCLIRuntimeFile();
    internal static string get_CouldNotFindToolRuntimeConfigFile();
    internal static string get_AttemptingToResolve();
    internal static string get_DidNotFindAMatchingProject();
    internal static string get_InvalidCommandResolverArguments();
    internal static string get_DoesNotExist();
    internal static string get_AmbiguousCommandName();
    internal static string get_ToolLibraryFound();
    internal static string get_MSBuildExePath();
    internal static string get_MSBuildProjectPath();
    internal static string get_MultipleProjectFilesFound();
    internal static string get_DidNotFindProject();
    internal static string get_ResolvingCommandSpec();
    internal static string get_FailedToResolveCommandSpec();
    internal static string get_AttemptingToResolveCommandSpec();
    internal static string get_NuGetPackagesRoot();
    internal static string get_FoundToolLockFile();
    internal static string get_LibraryNotFoundInLockFile();
    internal static string get_AttemptingToCreateCommandSpec();
    internal static string get_CommandSpecIsNull();
    internal static string get_ExpectDepsJsonAt();
    internal static string get_GeneratingDepsJson();
    internal static string get_UnableToGenerateDepsJson();
    internal static string get_DepsJsonGeneratorProjectNotSet();
    internal static string get_UnableToDeleteTemporaryDepsJson();
    internal static string get_VersionForPackageCouldNotBeResolved();
    internal static string get_FileNotFound();
    internal static string get_ProjectNotRestoredOrRestoreFailed();
    internal static string get_NoExecutableFoundMatchingCommand();
    internal static string get_CommandAssembliesNotFound();
    internal static string get_WaitingForDebuggerToAttach();
    internal static string get_ProcessId();
    internal static string get_CouldNotAccessAssetsFile();
    internal static string get_DotNetCommandLineTools();
    internal static string get_WriteLineForwarderSetPreviously();
    internal static string get_AlreadyCapturingStream();
    internal static string get_RunningFileNameArguments();
    internal static string get_ProcessExitedWithCode();
    internal static string get_UnableToInvokeMemberNameAfterCommand();
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Cli.Utils.LockFileExtensions : object {
    [ExtensionAttribute]
public static string GetPackageDirectory(LockFile lockFile, LockFileTargetLibrary library);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetNormalizedPackageFolders(LockFile lockFile);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Cli.Utils.LockFileFormatExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.DotNet.Cli.Utils.LockFileFormatExtensions/<ReadWithLock>d__0")]
[ExtensionAttribute]
public static Task`1<LockFile> ReadWithLock(LockFileFormat subject, string path);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Cli.Utils.LockFileTargetExtensions : object {
    [ExtensionAttribute]
public static bool IsPortable(LockFileTarget lockFileTarget);
    [ExtensionAttribute]
public static LockFileTargetLibrary GetPlatformLibrary(LockFileTarget lockFileTarget);
    [ExtensionAttribute]
public static HashSet`1<string> GetPlatformExclusionList(LockFileTarget lockFileTarget, IDictionary`2<string, LockFileTargetLibrary> libraryLookup);
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTargetLibrary> GetRuntimeLibraries(LockFileTarget lockFileTarget);
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTargetLibrary> GetCompileLibraries(LockFileTarget lockFileTarget);
    [ExtensionAttribute]
public static IEnumerable`1<LockFileTargetLibrary> Filter(IEnumerable`1<LockFileTargetLibrary> libraries, HashSet`1<string> exclusionList);
    [ExtensionAttribute]
public static IEnumerable`1<IGrouping`2<string, LockFileRuntimeTarget>> GetRuntimeTargetsGroups(LockFileTargetLibrary library, string assetType);
    private static void CollectDependencies(IDictionary`2<string, LockFileTargetLibrary> libraryLookup, IEnumerable`1<PackageDependency> dependencies, HashSet`1<string> exclusionList);
}
internal class Microsoft.DotNet.Cli.Utils.MSBuildForwardingAppWithoutLogging : object {
    private static string MSBuildExeName;
    private static string SdksDirectoryName;
    private ForwardingAppImplementation _forwardingApp;
    private Dictionary`2<string, string> _msbuildRequiredEnvironmentVariables;
    private IEnumerable`1<string> _msbuildRequiredParameters;
    public MSBuildForwardingAppWithoutLogging(IEnumerable`1<string> argsToForward, string msbuildPath);
    public virtual ProcessStartInfo GetProcessStartInfo();
    public int Execute();
    private static string Escape(string arg);
    private static string GetMSBuildExePath();
    private static string GetMSBuildSDKsPath();
    private static string GetRunVbcPath();
    private static string GetRunCscPath();
    private static string GetRunToolPath(string compilerName);
}
internal class Microsoft.DotNet.Cli.Utils.MSBuildProject : object {
    private static NuGetFramework s_toolPackageFramework;
    private Project _project;
    private string _projectRoot;
    private string _msBuildExePath;
    public string DepsJsonPath { get; }
    public string RuntimeConfigJsonPath { get; }
    public string FullOutputPath { get; }
    public string ProjectRoot { get; }
    public NuGetFramework DotnetCliToolTargetFramework { get; }
    public Dictionary`2<string, string> EnvironmentVariables { get; }
    public string ToolDepsJsonGeneratorProject { get; }
    public MSBuildProject(string msBuildProjectPath, NuGetFramework framework, string configuration, string outputPath, string msBuildExePath);
    private static MSBuildProject();
    public sealed virtual string get_DepsJsonPath();
    public sealed virtual string get_RuntimeConfigJsonPath();
    public sealed virtual string get_FullOutputPath();
    public sealed virtual string get_ProjectRoot();
    public sealed virtual NuGetFramework get_DotnetCliToolTargetFramework();
    public sealed virtual Dictionary`2<string, string> get_EnvironmentVariables();
    public sealed virtual string get_ToolDepsJsonGeneratorProject();
    public sealed virtual IEnumerable`1<SingleProjectInfo> GetTools();
    public sealed virtual LockFile GetLockFile();
    public sealed virtual bool TryGetLockFile(LockFile& lockFile);
    private string GetLockFilePathFromProjectLockFileProperty();
    private string GetLockFilePathFromIntermediateBaseOutputPath();
}
public class Microsoft.DotNet.Cli.Utils.Muxer : object {
    public static string MuxerName;
    private static string s_muxerFileName;
    private string _muxerPath;
    internal string SharedFxVersion { get; }
    public string MuxerPath { get; }
    private static Muxer();
    internal string get_SharedFxVersion();
    public string get_MuxerPath();
    public static string GetDataFromAppDomain(string propertyName);
    private bool TryResolveMuxerFromParentDirectories();
    private bool TryResolverMuxerFromPath();
}
public class Microsoft.DotNet.Cli.Utils.MuxerCommandResolver : object {
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Cli.Utils.NuGetUtils : object {
    public static bool IsPlaceholderFile(string path);
    [ExtensionAttribute]
public static IEnumerable`1<LockFileItem> FilterPlaceHolderFiles(IEnumerable`1<LockFileItem> files);
}
public class Microsoft.DotNet.Cli.Utils.OutputPathCommandResolver : AbstractPathBasedCommandResolver {
    public OutputPathCommandResolver(IEnvironmentProvider environment, IPlatformCommandSpecFactory commandSpecFactory);
    internal virtual string ResolveCommandPath(CommandResolverArguments commandResolverArguments);
    private string ResolveFromProjectOutput(string projectDirectory, NuGetFramework framework, string configuration, string commandName, IEnumerable`1<string> commandArguments, string outputPath, string buildBasePath);
    internal virtual CommandResolutionStrategy GetCommandResolutionStrategy();
}
public class Microsoft.DotNet.Cli.Utils.PackagedCommandSpecFactory : object {
    private static string PackagedCommandSpecFactoryName;
    private Action`2<string, IList`1<string>> _addAdditionalArguments;
    internal PackagedCommandSpecFactory(Action`2<string, IList`1<string>> addAdditionalArguments);
    public sealed virtual CommandSpec CreateCommandSpecFromLibrary(LockFileTargetLibrary toolLibrary, string commandName, IEnumerable`1<string> commandArguments, IEnumerable`1<string> allowedExtensions, LockFile lockFile, CommandResolutionStrategy commandResolutionStrategy, string depsFilePath, string runtimeConfigPath);
    private string GetCommandFilePath(LockFile lockFile, LockFileTargetLibrary toolLibrary, LockFileItem runtimeAssembly);
    private CommandSpec CreateCommandSpecWrappingWithMuxerIfDll(string commandPath, IEnumerable`1<string> commandArguments, string depsFilePath, CommandResolutionStrategy commandResolutionStrategy, IEnumerable`1<string> packageFolders, string runtimeConfigPath);
    private CommandSpec CreatePackageCommandSpecUsingMuxer(string commandPath, IEnumerable`1<string> commandArguments, string depsFilePath, CommandResolutionStrategy commandResolutionStrategy, IEnumerable`1<string> packageFolders, string runtimeConfigPath);
    private CommandSpec CreateCommandSpec(string commandPath, IEnumerable`1<string> commandArguments, CommandResolutionStrategy commandResolutionStrategy);
}
public class Microsoft.DotNet.Cli.Utils.PackagedCommandSpecFactoryWithCliRuntime : PackagedCommandSpecFactory {
    private static void AddAditionalParameters(string commandPath, IList`1<string> arguments);
    private static Version GetVersionWithoutPrerelease(string version);
    private static bool PrefersCliRuntime(string commandPath);
}
public class Microsoft.DotNet.Cli.Utils.PathCommandResolver : AbstractPathBasedCommandResolver {
    public PathCommandResolver(IEnvironmentProvider environment, IPlatformCommandSpecFactory commandSpecFactory);
    internal virtual string ResolveCommandPath(CommandResolverArguments commandResolverArguments);
    internal virtual CommandResolutionStrategy GetCommandResolutionStrategy();
}
public class Microsoft.DotNet.Cli.Utils.PathCommandResolverPolicy : object {
    public sealed virtual CompositeCommandResolver CreateCommandResolver();
    public static CompositeCommandResolver Create();
    public static CompositeCommandResolver CreatePathCommandResolverPolicy(IEnvironmentProvider environment, IPlatformCommandSpecFactory platformCommandSpecFactory);
}
public static class Microsoft.DotNet.Cli.Utils.PerfTrace : object {
    private static ConcurrentBag`1<PerfTraceThreadContext> _threads;
    [ThreadStaticAttribute]
private static PerfTraceThreadContext _current;
    [CompilerGeneratedAttribute]
private static bool <Enabled>k__BackingField;
    public static bool Enabled { get; public set; }
    public static PerfTraceThreadContext Current { get; }
    private static PerfTrace();
    [CompilerGeneratedAttribute]
public static bool get_Enabled();
    [CompilerGeneratedAttribute]
public static void set_Enabled(bool value);
    public static PerfTraceThreadContext get_Current();
    private static PerfTraceThreadContext InitializeCurrent();
    public static IEnumerable`1<PerfTraceThreadContext> GetEvents();
}
public class Microsoft.DotNet.Cli.Utils.PerfTraceEvent : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PerfTraceEvent> <Children>k__BackingField;
    public string Type { get; }
    public string Instance { get; }
    public DateTime StartUtc { get; }
    public TimeSpan Duration { get; }
    public IList`1<PerfTraceEvent> Children { get; }
    public PerfTraceEvent(string type, string instance, IEnumerable`1<PerfTraceEvent> children, DateTime startUtc, TimeSpan duration);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Instance();
    [CompilerGeneratedAttribute]
public DateTime get_StartUtc();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public IList`1<PerfTraceEvent> get_Children();
}
public class Microsoft.DotNet.Cli.Utils.PerfTraceOutput : object {
    private static TimeSpan _minDuration;
    private static PerfTraceOutput();
    public static void Print(Reporter reporter, IEnumerable`1<PerfTraceThreadContext> contexts);
    private static void Print(Reporter reporter, IEnumerable`1<PerfTraceEvent> events, PerfTraceEvent root, PerfTraceEvent parent, int padding);
    private static string FormatEvent(PerfTraceEvent e, PerfTraceEvent root, PerfTraceEvent parent);
    private static void FormatEventTimeStat(StringBuilder builder, PerfTraceEvent e, PerfTraceEvent root, PerfTraceEvent parent);
    private static void AppendTime(StringBuilder builder, Nullable`1<double> percent, double treshold);
}
public class Microsoft.DotNet.Cli.Utils.PerfTraceThreadContext : object {
    private int _threadId;
    private TimerDisposable _activeEvent;
    public PerfTraceEvent Root { get; }
    public PerfTraceThreadContext(int threadId);
    public PerfTraceEvent get_Root();
    public IDisposable CaptureTiming(string instance, string memberName, string filePath);
    private void RecordTiming(PerfTraceEvent newEvent, TimerDisposable parent);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Cli.Utils.ProcessStartInfoExtensions : object {
    [ExtensionAttribute]
public static int Execute(ProcessStartInfo startInfo);
    [ExtensionAttribute]
public static int ExecuteAndCaptureOutput(ProcessStartInfo startInfo, String& stdOut, String& stdErr);
}
public class Microsoft.DotNet.Cli.Utils.Product : object {
    public static string Version;
    public static string LongName { get; }
    private static Product();
    public static string get_LongName();
    private static string GetProductVersion();
}
public class Microsoft.DotNet.Cli.Utils.ProjectDependenciesCommandFactory : object {
    private NuGetFramework _nugetFramework;
    private string _configuration;
    private string _outputPath;
    private string _buildBasePath;
    private string _projectDirectory;
    public ProjectDependenciesCommandFactory(NuGetFramework nugetFramework, string configuration, string outputPath, string buildBasePath, string projectDirectory);
    public sealed virtual ICommand Create(string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration);
    private CommandSpec FindProjectDependencyCommands(string commandName, IEnumerable`1<string> commandArgs, string configuration, NuGetFramework framework, string outputPath, string buildBasePath, string projectDirectory);
    private ICommandResolver GetProjectDependenciesCommandResolver(NuGetFramework framework);
}
public class Microsoft.DotNet.Cli.Utils.ProjectDependenciesCommandResolver : object {
    private static string ProjectDependenciesCommandResolverName;
    private static CommandResolutionStrategy s_commandResolutionStrategy;
    private IEnvironmentProvider _environment;
    private IPackagedCommandSpecFactory _packagedCommandSpecFactory;
    public ProjectDependenciesCommandResolver(IEnvironmentProvider environment, IPackagedCommandSpecFactory packagedCommandSpecFactory);
    private static ProjectDependenciesCommandResolver();
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
    private CommandSpec ResolveFromProjectDependencies(string projectDirectory, NuGetFramework framework, string configuration, string commandName, IEnumerable`1<string> commandArguments, string outputPath, string buildBasePath);
    private LockFileTargetLibrary GetToolLibraryForContext(LockFile lockFile, string commandName, NuGetFramework targetFramework);
    private IEnumerable`1<string> GetAllowedCommandExtensionsFromEnvironment(IEnvironmentProvider environment);
}
internal class Microsoft.DotNet.Cli.Utils.ProjectFactory : object {
    private static string ProjectFactoryName;
    private IEnvironmentProvider _environment;
    public ProjectFactory(IEnvironmentProvider environment);
    public IProject GetProject(string projectDirectory, NuGetFramework framework, string configuration, string buildBasePath, string outputPath);
    private IProject GetMSBuildProj(string projectDirectory, NuGetFramework framework, string configuration, string outputPath);
    private string GetMSBuildProjPath(string projectDirectory);
}
public class Microsoft.DotNet.Cli.Utils.ProjectPathCommandResolver : AbstractPathBasedCommandResolver {
    public ProjectPathCommandResolver(IEnvironmentProvider environment, IPlatformCommandSpecFactory commandSpecFactory);
    internal virtual string ResolveCommandPath(CommandResolverArguments commandResolverArguments);
    internal virtual CommandResolutionStrategy GetCommandResolutionStrategy();
}
public class Microsoft.DotNet.Cli.Utils.ProjectToolsCommandResolver : object {
    private static string ProjectToolsCommandResolverName;
    private static CommandResolutionStrategy s_commandResolutionStrategy;
    private List`1<string> _allowedCommandExtensions;
    private IPackagedCommandSpecFactory _packagedCommandSpecFactory;
    private IEnvironmentProvider _environment;
    public ProjectToolsCommandResolver(IPackagedCommandSpecFactory packagedCommandSpecFactory, IEnvironmentProvider environment);
    private static ProjectToolsCommandResolver();
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
    private CommandSpec ResolveFromProjectTools(CommandResolverArguments commandResolverArguments);
    private CommandSpec ResolveCommandSpecFromAllToolLibraries(IEnumerable`1<SingleProjectInfo> toolsLibraries, string commandName, IEnumerable`1<string> args, IProject project);
    private CommandSpec ResolveCommandSpecFromToolLibrary(SingleProjectInfo toolLibraryRange, string commandName, IEnumerable`1<string> args, IProject project);
    private IEnumerable`1<string> GetPossiblePackageRoots(IProject project);
    private LockFile GetToolLockFile(SingleProjectInfo toolLibrary, NuGetFramework framework, IEnumerable`1<string> possibleNugetPackagesRoot);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Cli.Utils.ProjectToolsCommandResolver/<FileExistsWithLock>d__12")]
private static Task`1<bool> FileExistsWithLock(string path);
    private bool TryGetToolLockFile(SingleProjectInfo toolLibrary, NuGetFramework framework, string nugetPackagesRoot, LockFile& lockFile);
    private string GetToolLockFilePath(SingleProjectInfo toolLibrary, NuGetFramework framework, string nugetPackagesRoot);
    private string GetToolDepsFilePath(SingleProjectInfo toolLibrary, NuGetFramework framework, LockFile toolLockFile, string depsPathRoot, string toolDepsJsonGeneratorProject);
    private void EnsureToolJsonDepsFileExists(LockFile toolLockFile, NuGetFramework framework, string depsPath, SingleProjectInfo toolLibrary, string toolDepsJsonGeneratorProject);
    internal void GenerateDepsJsonFile(LockFile toolLockFile, NuGetFramework framework, string depsPath, SingleProjectInfo toolLibrary, string toolDepsJsonGeneratorProject);
}
public class Microsoft.DotNet.Cli.Utils.PublishedPathCommandFactory : object {
    private string _publishDirectory;
    private string _applicationName;
    public PublishedPathCommandFactory(string publishDirectory, string applicationName);
    public sealed virtual ICommand Create(string commandName, IEnumerable`1<string> args, NuGetFramework framework, string configuration);
}
public class Microsoft.DotNet.Cli.Utils.PublishedPathCommandResolver : object {
    private static string PublishedPathCommandResolverName;
    private IEnvironmentProvider _environment;
    private IPublishedPathCommandSpecFactory _commandSpecFactory;
    public PublishedPathCommandResolver(IEnvironmentProvider environment, IPublishedPathCommandSpecFactory commandSpecFactory);
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
    private string ResolveCommandPath(string publishDirectory, string commandName);
}
public class Microsoft.DotNet.Cli.Utils.PublishPathCommandSpecFactory : object {
    public sealed virtual CommandSpec CreateCommandSpecFromPublishFolder(string commandPath, IEnumerable`1<string> commandArguments, CommandResolutionStrategy commandResolutionStrategy, string depsFilePath, string runtimeConfigPath);
    private CommandSpec CreateCommandSpecWrappingWithMuxerIfDll(string commandPath, IEnumerable`1<string> commandArguments, string depsFilePath, CommandResolutionStrategy commandResolutionStrategy, string runtimeConfigPath);
    private CommandSpec CreatePackageCommandSpecUsingMuxer(string commandPath, IEnumerable`1<string> commandArguments, string depsFilePath, CommandResolutionStrategy commandResolutionStrategy, string runtimeConfigPath);
    private CommandSpec CreateCommandSpec(string commandPath, IEnumerable`1<string> commandArguments, CommandResolutionStrategy commandResolutionStrategy);
}
public class Microsoft.DotNet.Cli.Utils.Reporter : object {
    private static Reporter NullReporter;
    private static object _lock;
    private AnsiConsole _console;
    [CompilerGeneratedAttribute]
private static Reporter <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private static Reporter <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private static Reporter <Verbose>k__BackingField;
    public static Reporter Output { get; private set; }
    public static Reporter Error { get; private set; }
    public static Reporter Verbose { get; private set; }
    public static bool IsVerbose { get; }
    private static Reporter();
    private Reporter(AnsiConsole console);
    [CompilerGeneratedAttribute]
public static Reporter get_Output();
    [CompilerGeneratedAttribute]
private static void set_Output(Reporter value);
    [CompilerGeneratedAttribute]
public static Reporter get_Error();
    [CompilerGeneratedAttribute]
private static void set_Error(Reporter value);
    [CompilerGeneratedAttribute]
public static Reporter get_Verbose();
    [CompilerGeneratedAttribute]
private static void set_Verbose(Reporter value);
    public static void Reset();
    public static bool get_IsVerbose();
    public sealed virtual void WriteLine(string message);
    public sealed virtual void WriteLine();
    public sealed virtual void Write(string message);
}
internal class Microsoft.DotNet.Cli.Utils.ResourceAssemblyInfo : object {
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    public string Culture { get; }
    public string RelativePath { get; }
    public ResourceAssemblyInfo(string culture, string relativePath);
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public string get_RelativePath();
}
public class Microsoft.DotNet.Cli.Utils.RootedCommandResolver : object {
    public sealed virtual CommandSpec Resolve(CommandResolverArguments commandResolverArguments);
}
public class Microsoft.DotNet.Cli.Utils.RuntimeConfig : object {
    [CompilerGeneratedAttribute]
private bool <IsPortable>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeConfigFramework <Framework>k__BackingField;
    public bool IsPortable { get; }
    public RuntimeConfigFramework Framework { get; }
    public RuntimeConfig(string runtimeConfigPath);
    [CompilerGeneratedAttribute]
public bool get_IsPortable();
    [CompilerGeneratedAttribute]
public RuntimeConfigFramework get_Framework();
    public static bool IsApplicationPortable(string entryAssemblyPath);
    private JObject OpenRuntimeConfig(StreamReader streamReader);
    private RuntimeConfigFramework ParseFramework(JObject runtimeConfigRoot);
}
public class Microsoft.DotNet.Cli.Utils.RuntimeConfigFramework : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Name { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public static RuntimeConfigFramework ParseFromFrameworkRoot(JObject framework);
}
public static class Microsoft.DotNet.Cli.Utils.RuntimeEnvironmentRidExtensions : object {
    public static string GetLegacyRestoreRuntimeIdentifier();
}
public class Microsoft.DotNet.Cli.Utils.ScriptCommandResolverPolicy : object {
    public static CompositeCommandResolver Create();
    public static CompositeCommandResolver CreateScriptCommandResolver(IEnvironmentProvider environment, IPlatformCommandSpecFactory platformCommandSpecFactory);
}
internal class Microsoft.DotNet.Cli.Utils.SingleProjectInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ResourceAssemblyInfo> <ResourceAssemblies>k__BackingField;
    public string Name { get; }
    public string Version { get; }
    public IEnumerable`1<ResourceAssemblyInfo> ResourceAssemblies { get; }
    public SingleProjectInfo(string name, string version, IEnumerable`1<ResourceAssemblyInfo> resourceAssemblies);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ResourceAssemblyInfo> get_ResourceAssemblies();
    public string GetOutputName();
}
public class Microsoft.DotNet.Cli.Utils.StreamForwarder : object {
    private static Char[] s_ignoreCharacters;
    private static char s_flushBuilderCharacter;
    private StringBuilder _builder;
    private StringWriter _capture;
    private Action`1<string> _writeLine;
    public string CapturedOutput { get; }
    private static StreamForwarder();
    public string get_CapturedOutput();
    public StreamForwarder Capture();
    public StreamForwarder ForwardTo(Action`1<string> writeLine);
    public Task BeginRead(TextReader reader);
    public void Read(TextReader reader);
    private void WriteBuilder();
    private void WriteLine(string str);
    private void ThrowIfNull(object obj);
    private void ThrowIfForwarderSet();
    private void ThrowIfCaptureSet();
}
public static class Microsoft.DotNet.Cli.Utils.TelemetryEventEntry : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<InstrumentationEventArgs> EntryPosted;
    [CompilerGeneratedAttribute]
private static ITelemetryFilter <TelemetryFilter>k__BackingField;
    public static ITelemetryFilter TelemetryFilter { get; public set; }
    private static TelemetryEventEntry();
    [CompilerGeneratedAttribute]
public static void add_EntryPosted(EventHandler`1<InstrumentationEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_EntryPosted(EventHandler`1<InstrumentationEventArgs> value);
    [CompilerGeneratedAttribute]
public static ITelemetryFilter get_TelemetryFilter();
    [CompilerGeneratedAttribute]
public static void set_TelemetryFilter(ITelemetryFilter value);
    public static void TrackEvent(string eventName, IDictionary`2<string, string> properties, IDictionary`2<string, double> measurements);
    public static void SendFiltered(object o);
    public static void Subscribe(Action`3<string, IDictionary`2<string, string>, IDictionary`2<string, double>> subscriber);
}
public class Microsoft.DotNet.Cli.Utils.ToolPathCalculator : object {
    private string _packagesDirectory;
    public ToolPathCalculator(string packagesDirectory);
    public string GetBestLockFilePath(string packageId, VersionRange versionRange, NuGetFramework framework);
    public string GetLockFilePath(string packageId, NuGetVersion version, NuGetFramework framework);
    private string GetBaseToolPath(string packageId);
    private IEnumerable`1<NuGetVersion> GetAvailableToolVersions(string packageId);
}
public class Microsoft.DotNet.Cli.Utils.WindowsExePreferredCommandSpecFactory : object {
    public sealed virtual CommandSpec CreateCommandSpec(string commandName, IEnumerable`1<string> args, string commandPath, CommandResolutionStrategy resolutionStrategy, IEnvironmentProvider environment);
    private CommandSpec CreateCommandSpecFromExecutable(string command, IEnumerable`1<string> args, CommandResolutionStrategy resolutionStrategy);
    private CommandSpec CreateCommandSpecWrappedWithCmd(string command, IEnumerable`1<string> args, CommandResolutionStrategy resolutionStrategy);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Tools.Common.PathUtility : object {
    public static bool IsPlaceholderFile(string path);
    public static bool IsChildOfDirectory(string dir, string candidate);
    public static string EnsureTrailingSlash(string path);
    public static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
    public static string EnsureNoTrailingDirectorySeparator(string path);
    public static void EnsureParentDirectoryExists(string filePath);
    public static void EnsureDirectoryExists(string directoryPath);
    public static bool TryDeleteDirectory(string directoryPath);
    public static string GetRelativePath(DirectoryInfo directory, FileSystemInfo childItem);
    public static string GetRelativePath(string path1, string path2);
    public static string GetRelativePathIgnoringDirectoryTraversals(string path1, string path2);
    public static string GetRelativePath(string path1, string path2, char separator, bool includeDirectoryTraversals);
    public static string GetAbsolutePath(string basePath, string relativePath);
    public static string GetDirectoryName(string path);
    public static string GetPathWithForwardSlashes(string path);
    public static string GetPathWithBackSlashes(string path);
    public static string GetPathWithDirectorySeparator(string path);
    public static string RemoveExtraPathSeparators(string path);
    [ExtensionAttribute]
public static bool HasExtension(string filePath, string extension);
    public static string GetFullPath(string path);
    public static void EnsureAllPathsExist(IReadOnlyCollection`1<string> paths, string pathDoesNotExistLocalizedFormatString);
    [ExtensionAttribute]
public static bool IsDirectory(string path);
}
