[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class Continuation : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TReturn sequence(FSharpList`1<FSharpFunc`2<FSharpFunc`2<T, TReturn>, TReturn>> recursions, FSharpFunc`2<FSharpList`1<T>, TReturn> finalContinuation);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TReturn concatenate(FSharpList`1<FSharpFunc`2<FSharpFunc`2<FSharpList`1<T>, TReturn>, TReturn>> recursions, FSharpFunc`2<FSharpList`1<T>, TReturn> finalContinuation);
}
[CompilationMappingAttribute("3")]
internal class FSComp.SR : object {
    internal static Lazy`1<ResourceManager> resources;
    internal static Type funTyC;
    internal static bool swallowResourceText;
    internal static int init@14;
    internal static bool SwallowResourceText { get; internal set; }
    private static SR();
    internal static bool get_SwallowResourceText();
    internal static void set_SwallowResourceText(bool b);
    internal static string undefinedNameNamespace(string a0);
    internal static string undefinedNameNamespaceOrModule(string a0);
    internal static string undefinedNameFieldConstructorOrMember(string a0);
    internal static string undefinedNameFieldConstructorOrMemberWhenTypeIsKnown(string a0, string a1);
    internal static string undefinedNameValueConstructorNamespaceOrType(string a0);
    internal static string undefinedNameValueOfConstructor(string a0);
    internal static string undefinedNameValueNamespaceTypeOrModule(string a0);
    internal static string undefinedNameConstructorModuleOrNamespace(string a0);
    internal static string undefinedNameType(string a0);
    internal static string undefinedNameTypeIn(string a0, string a1);
    internal static string undefinedNameRecordLabelOrNamespace(string a0);
    internal static string undefinedNameRecordLabel(string a0);
    internal static string undefinedNameSuggestionsIntro();
    internal static string undefinedNameTypeParameter(string a0);
    internal static string undefinedNamePatternDiscriminator(string a0);
    internal static string replaceWithSuggestion(string a0);
    internal static string addIndexerDot();
    internal static string listElementHasWrongType(string a0, string a1);
    internal static string listElementHasWrongTypeTuple(int a0, string a1, int a2, string a3);
    internal static string arrayElementHasWrongType(string a0, string a1);
    internal static string arrayElementHasWrongTypeTuple(int a0, string a1, int a2, string a3);
    internal static string missingElseBranch(string a0);
    internal static string ifExpression(string a0, string a1);
    internal static string ifExpressionTuple(int a0, string a1, int a2, string a3);
    internal static string elseBranchHasWrongType(string a0, string a1);
    internal static string elseBranchHasWrongTypeTuple(int a0, string a1, int a2, string a3);
    internal static string followingPatternMatchClauseHasWrongType(string a0, string a1);
    internal static string followingPatternMatchClauseHasWrongTypeTuple(int a0, string a1, int a2, string a3);
    internal static string patternMatchGuardIsNotBool(string a0);
    internal static string commaInsteadOfSemicolonInRecord();
    internal static string derefInsteadOfNot();
    internal static string buildUnexpectedTypeArgs(string a0, int a1);
    internal static string returnUsedInsteadOfReturnBang();
    internal static string yieldUsedInsteadOfYieldBang();
    internal static string tupleRequiredInAbstractMethod();
    internal static Tuple`2<int, string> parsUnexpectedSymbolDot();
    internal static Tuple`2<int, string> tcNamespaceCannotContainValues();
    internal static Tuple`2<int, string> unsupportedAttribute();
    internal static Tuple`2<int, string> buildInvalidWarningNumber(string a0);
    internal static Tuple`2<int, string> buildInvalidVersionString(string a0);
    internal static Tuple`2<int, string> buildInvalidVersionFile(string a0);
    internal static Tuple`2<int, string> buildProblemWithFilename(string a0, string a1);
    internal static Tuple`2<int, string> buildNoInputsSpecified();
    internal static Tuple`2<int, string> buildPdbRequiresDebug();
    internal static Tuple`2<int, string> buildInvalidSearchDirectory(string a0);
    internal static Tuple`2<int, string> buildSearchDirectoryNotFound(string a0);
    internal static Tuple`2<int, string> buildInvalidFilename(string a0);
    internal static Tuple`2<int, string> buildInvalidAssemblyName(string a0);
    internal static Tuple`2<int, string> buildInvalidPrivacy(string a0);
    internal static Tuple`2<int, string> buildCannotReadAssembly(string a0);
    internal static Tuple`2<int, string> buildAssemblyResolutionFailed();
    internal static Tuple`2<int, string> buildImplicitModuleIsNotLegalIdentifier(string a0, string a1);
    internal static Tuple`2<int, string> buildMultiFileRequiresNamespaceOrModule();
    internal static Tuple`2<int, string> noEqualSignAfterModule();
    internal static Tuple`2<int, string> buildMultipleToplevelModules();
    internal static Tuple`2<int, string> buildOptionRequiresParameter(string a0);
    internal static Tuple`2<int, string> buildCouldNotFindSourceFile(string a0);
    internal static Tuple`2<int, string> buildInvalidSourceFileExtension(string a0);
    internal static Tuple`2<int, string> buildInvalidSourceFileExtensionUpdated(string a0);
    internal static Tuple`2<int, string> buildInvalidSourceFileExtensionML(string a0);
    internal static Tuple`2<int, string> buildCouldNotResolveAssembly(string a0);
    internal static Tuple`2<int, string> buildErrorOpeningBinaryFile(string a0, string a1);
    internal static Tuple`2<int, string> buildDifferentVersionMustRecompile(string a0);
    internal static Tuple`2<int, string> buildInvalidHashIDirective();
    internal static Tuple`2<int, string> buildInvalidHashrDirective();
    internal static Tuple`2<int, string> buildInvalidHashloadDirective();
    internal static Tuple`2<int, string> buildInvalidHashtimeDirective();
    internal static Tuple`2<int, string> buildDirectivesInModulesAreIgnored();
    internal static Tuple`2<int, string> buildSignatureAlreadySpecified(string a0);
    internal static Tuple`2<int, string> buildImplementationAlreadyGivenDetail(string a0);
    internal static Tuple`2<int, string> buildImplementationAlreadyGiven(string a0);
    internal static Tuple`2<int, string> buildSignatureWithoutImplementation(string a0);
    internal static Tuple`2<int, string> buildArgInvalidInt(string a0);
    internal static Tuple`2<int, string> buildArgInvalidFloat(string a0);
    internal static Tuple`2<int, string> buildUnrecognizedOption(string a0);
    internal static Tuple`2<int, string> buildInvalidModuleOrNamespaceName();
    internal static string pickleErrorReadingWritingMetadata(string a0, string a1);
    internal static Tuple`2<int, string> tastTypeOrModuleNotConcrete(string a0);
    internal static string tastTypeHasAssemblyCodeRepresentation(string a0);
    internal static Tuple`2<int, string> optsUnrecognizedLanguageVersion(string a0);
    internal static Tuple`2<int, string> tastNamespaceAndModuleWithSameNameInAssembly(string a0);
    internal static Tuple`2<int, string> tastTwoModulesWithSameNameInAssembly(string a0);
    internal static Tuple`2<int, string> tastDuplicateTypeDefinitionInAssembly(string a0, string a1);
    internal static Tuple`2<int, string> tastConflictingModuleAndTypeDefinitionInAssembly(string a0, string a1);
    internal static Tuple`2<int, string> tastInvalidMemberSignature();
    internal static Tuple`2<int, string> tastValueDoesNotHaveSetterType();
    internal static Tuple`2<int, string> tastInvalidFormForPropertyGetter();
    internal static Tuple`2<int, string> tastInvalidFormForPropertySetter();
    internal static Tuple`2<int, string> tastUnexpectedByRef();
    internal static Tuple`2<int, string> tastValueMustBeMutable();
    internal static Tuple`2<int, string> tastInvalidMutationOfConstant();
    internal static string tastValueHasBeenCopied();
    internal static Tuple`2<int, string> tastRecursiveValuesMayNotBeInConstructionOfTuple();
    internal static Tuple`2<int, string> tastRecursiveValuesMayNotAppearInConstructionOfType(string a0);
    internal static Tuple`2<int, string> tastRecursiveValuesMayNotBeAssignedToNonMutableField(string a0, string a1);
    internal static string tastUnexpectedDecodeOfAutoOpenAttribute();
    internal static string tastUnexpectedDecodeOfInternalsVisibleToAttribute();
    internal static string tastUnexpectedDecodeOfInterfaceDataVersionAttribute();
    internal static Tuple`2<int, string> tastActivePatternsLimitedToSeven();
    internal static Tuple`2<int, string> tastNotAConstantExpression();
    internal static string ValueNotContainedMutabilityAttributesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityNamesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityCompiledNamesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityDisplayNamesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityAccessibilityMore(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityInlineFlagsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityLiteralConstantValuesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityOneIsTypeFunction(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityParameterCountsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityTypesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityExtensionsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityArityNotInferred(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityGenericParametersDiffer(string a0, string a1, string a2, string a3, string a4);
    internal static string ValueNotContainedMutabilityGenericParametersAreDifferentKinds(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityAritiesDiffer(string a0, string a1, string a2, string a3, string a4, string a5, string a6);
    internal static string ValueNotContainedMutabilityDotNetNamesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityStaticsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityVirtualsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityAbstractsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityFinalsDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityOverridesDiffer(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityOneIsConstructor(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityStaticButInstance(string a0, string a1, string a2);
    internal static string ValueNotContainedMutabilityInstanceButStatic(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleNamesDiffer(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleMissingInterface(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationSaysNull(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureSaysNull(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationSealed(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleNumbersDiffer(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleImplDefinesStruct(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleTypeIsHidden(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleILDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleFieldWasPresent(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig(string a0, string a1, string a2);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig(string a0, string a1);
    internal static Tuple`2<int, string> DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation(string a0, string a1);
    internal static string ModuleContainsConstructorButNamesDiffer(string a0, string a1);
    internal static string ModuleContainsConstructorButDataFieldsDiffer(string a0, string a1);
    internal static string ModuleContainsConstructorButTypesOfFieldsDiffer(string a0, string a1);
    internal static string ModuleContainsConstructorButAccessibilityDiffers(string a0, string a1);
    internal static string FieldNotContainedNamesDiffer(string a0, string a1);
    internal static string FieldNotContainedAccessibilitiesDiffer(string a0, string a1);
    internal static string FieldNotContainedStaticsDiffer(string a0, string a1);
    internal static string FieldNotContainedMutablesDiffer(string a0, string a1);
    internal static string FieldNotContainedLiteralsDiffer(string a0, string a1);
    internal static string FieldNotContainedTypesDiffer(string a0, string a1);
    internal static Tuple`2<int, string> typrelCannotResolveImplicitGenericInstantiation(string a0, string a1);
    internal static Tuple`2<int, string> typrelCannotResolveAmbiguityInPrintf();
    internal static Tuple`2<int, string> typrelCannotResolveAmbiguityInEnum();
    internal static Tuple`2<int, string> typrelCannotResolveAmbiguityInDelegate();
    internal static Tuple`2<int, string> typrelInvalidValue();
    internal static Tuple`2<int, string> typrelSigImplNotCompatibleParamCountsDiffer();
    internal static Tuple`2<int, string> typrelSigImplNotCompatibleCompileTimeRequirementsDiffer();
    internal static Tuple`2<int, string> typrelSigImplNotCompatibleConstraintsDiffer(string a0, string a1);
    internal static Tuple`2<int, string> typrelSigImplNotCompatibleConstraintsDifferRemove(string a0, string a1);
    internal static Tuple`2<int, string> typrelTypeImplementsIComparableShouldOverrideObjectEquals(string a0);
    internal static Tuple`2<int, string> typrelTypeImplementsIComparableDefaultObjectEqualsProvided(string a0);
    internal static Tuple`2<int, string> typrelExplicitImplementationOfGetHashCodeOrEquals(string a0);
    internal static Tuple`2<int, string> typrelExplicitImplementationOfGetHashCode(string a0);
    internal static Tuple`2<int, string> typrelExplicitImplementationOfEquals(string a0);
    internal static string ExceptionDefsNotCompatibleHiddenBySignature(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleDotNetRepresentationsDiffer(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleAbbreviationHiddenBySignature(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleSignaturesDiffer(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleExceptionDeclarationsDiffer(string a0, string a1);
    internal static string ExceptionDefsNotCompatibleFieldInSigButNotImpl(string a0, string a1, string a2);
    internal static string ExceptionDefsNotCompatibleFieldInImplButNotSig(string a0, string a1, string a2);
    internal static string ExceptionDefsNotCompatibleFieldOrderDiffers(string a0, string a1);
    internal static Tuple`2<int, string> typrelModuleNamespaceAttributesDifferInSigAndImpl();
    internal static Tuple`2<int, string> typrelMethodIsOverconstrained();
    internal static Tuple`2<int, string> typrelOverloadNotFound(string a0, string a1);
    internal static Tuple`2<int, string> typrelOverrideWasAmbiguous(string a0);
    internal static Tuple`2<int, string> typrelMoreThenOneOverride(string a0);
    internal static Tuple`2<int, string> typrelMethodIsSealed(string a0);
    internal static Tuple`2<int, string> typrelOverrideImplementsMoreThenOneSlot(string a0, string a1, string a2);
    internal static Tuple`2<int, string> typrelDuplicateInterface();
    internal static Tuple`2<int, string> typrelNeedExplicitImplementation(string a0);
    internal static Tuple`2<int, string> typrelNamedArgumentHasBeenAssignedMoreThenOnce(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGiven(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenSeveral(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenSeveralTruncated(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenWithSuggestion(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenSeveralWithSuggestion(string a0);
    internal static Tuple`2<int, string> typrelNoImplementationGivenSeveralTruncatedWithSuggestion(string a0);
    internal static Tuple`2<int, string> typrelMemberDoesNotHaveCorrectNumberOfArguments(string a0, string a1);
    internal static Tuple`2<int, string> typrelMemberDoesNotHaveCorrectNumberOfTypeParameters(string a0, string a1);
    internal static Tuple`2<int, string> typrelMemberDoesNotHaveCorrectKindsOfGenericParameters(string a0, string a1);
    internal static Tuple`2<int, string> typrelMemberCannotImplement(string a0, string a1, string a2);
    internal static Tuple`2<int, string> astParseEmbeddedILError();
    internal static Tuple`2<int, string> astParseEmbeddedILTypeError();
    internal static string astDeprecatedIndexerNotation();
    internal static Tuple`2<int, string> astInvalidExprLeftHandOfAssignment();
    internal static Tuple`2<int, string> augNoRefEqualsOnStruct();
    internal static Tuple`2<int, string> augInvalidAttrs();
    internal static Tuple`2<int, string> augNoEqualityNeedsNoComparison();
    internal static Tuple`2<int, string> augStructCompNeedsStructEquality();
    internal static Tuple`2<int, string> augStructEqNeedsNoCompOrStructComp();
    internal static Tuple`2<int, string> augTypeCantHaveRefEqAndStructAttrs();
    internal static Tuple`2<int, string> augOnlyCertainTypesCanHaveAttrs();
    internal static Tuple`2<int, string> augRefEqCantHaveObjEquals();
    internal static Tuple`2<int, string> augCustomEqNeedsObjEquals();
    internal static Tuple`2<int, string> augCustomCompareNeedsIComp();
    internal static Tuple`2<int, string> augNoEqNeedsNoObjEquals();
    internal static Tuple`2<int, string> augNoCompCantImpIComp();
    internal static Tuple`2<int, string> augCustomEqNeedsNoCompOrCustomComp();
    internal static string forPositionalSpecifiersNotPermitted();
    internal static string forMissingFormatSpecifier();
    internal static string forFlagSetTwice(string a0);
    internal static string forPrefixFlagSpacePlusSetTwice();
    internal static string forHashSpecifierIsInvalid();
    internal static string forBadPrecision();
    internal static string forBadWidth();
    internal static string forDoesNotSupportZeroFlag(string a0);
    internal static string forPrecisionMissingAfterDot();
    internal static string forFormatDoesntSupportPrecision(string a0);
    internal static string forBadFormatSpecifier();
    internal static string forLIsUnnecessary();
    internal static string forHIsUnnecessary();
    internal static string forDoesNotSupportPrefixFlag(string a0, string a1);
    internal static string forBadFormatSpecifierGeneral(string a0);
    internal static string forPercentAInReflectionFreeCode();
    internal static string elSysEnvExitDidntExit();
    internal static string elDeprecatedOperator();
    internal static Tuple`2<int, string> chkProtectedOrBaseCalled();
    internal static Tuple`2<int, string> chkByrefUsedInInvalidWay(string a0);
    internal static Tuple`2<int, string> chkBaseUsedInInvalidWay();
    internal static string chkVariableUsedInInvalidWay(string a0);
    internal static Tuple`2<int, string> chkTypeLessAccessibleThanType(string a0, string a1);
    internal static Tuple`2<int, string> chkSystemVoidOnlyInTypeof();
    internal static Tuple`2<int, string> chkErrorUseOfByref();
    internal static Tuple`2<int, string> chkErrorContainsCallToRethrow();
    internal static Tuple`2<int, string> chkSplicingOnlyInQuotations();
    internal static Tuple`2<int, string> chkNoFirstClassSplicing();
    internal static Tuple`2<int, string> chkNoFirstClassAddressOf();
    internal static Tuple`2<int, string> chkNoFirstClassRethrow();
    internal static Tuple`2<int, string> chkNoByrefAtThisPoint(string a0);
    internal static Tuple`2<int, string> chkLimitationsOfBaseKeyword();
    internal static Tuple`2<int, string> chkNoAddressOfAtThisPoint(string a0);
    internal static Tuple`2<int, string> chkNoAddressStaticFieldAtThisPoint(string a0);
    internal static Tuple`2<int, string> chkNoAddressFieldAtThisPoint(string a0);
    internal static Tuple`2<int, string> chkNoAddressOfArrayElementAtThisPoint();
    internal static Tuple`2<int, string> chkFirstClassFuncNoByref();
    internal static Tuple`2<int, string> chkReturnTypeNoByref();
    internal static Tuple`2<int, string> chkInvalidCustAttrVal();
    internal static Tuple`2<int, string> chkAttrHasAllowMultiFalse(string a0);
    internal static Tuple`2<int, string> chkMemberUsedInInvalidWay(string a0, string a1, string a2);
    internal static Tuple`2<int, string> chkNoByrefAsTopValue();
    internal static Tuple`2<int, string> chkReflectedDefCantSplice();
    internal static Tuple`2<int, string> chkEntryPointUsage();
    internal static string chkUnionCaseCompiledForm();
    internal static string chkUnionCaseDefaultAugmentation();
    internal static Tuple`2<int, string> chkPropertySameNameMethod(string a0, string a1);
    internal static Tuple`2<int, string> chkGetterSetterDoNotMatchAbstract(string a0, string a1);
    internal static Tuple`2<int, string> chkPropertySameNameIndexer(string a0, string a1);
    internal static Tuple`2<int, string> chkCantStoreByrefValue();
    internal static Tuple`2<int, string> chkDuplicateMethod(string a0, string a1);
    internal static Tuple`2<int, string> chkDuplicateMethodWithSuffix(string a0, string a1);
    internal static Tuple`2<int, string> chkDuplicateMethodCurried(string a0, string a1);
    internal static Tuple`2<int, string> chkCurriedMethodsCantHaveOutParams();
    internal static Tuple`2<int, string> chkDuplicateProperty(string a0, string a1);
    internal static Tuple`2<int, string> chkDuplicatePropertyWithSuffix(string a0, string a1);
    internal static Tuple`2<int, string> chkDuplicateMethodInheritedType(string a0);
    internal static Tuple`2<int, string> chkDuplicateMethodInheritedTypeWithSuffix(string a0);
    internal static Tuple`2<int, string> chkMultipleGenericInterfaceInstantiations(string a0, string a1);
    internal static Tuple`2<int, string> chkValueWithDefaultValueMustHaveDefaultValue();
    internal static Tuple`2<int, string> chkNoByrefInTypeAbbrev();
    internal static Tuple`2<int, string> crefBoundVarUsedInSplice(string a0);
    internal static Tuple`2<int, string> crefQuotationsCantContainGenericExprs();
    internal static Tuple`2<int, string> crefQuotationsCantContainGenericFunctions();
    internal static Tuple`2<int, string> crefQuotationsCantContainObjExprs();
    internal static Tuple`2<int, string> crefQuotationsCantContainAddressOf();
    internal static Tuple`2<int, string> crefQuotationsCantContainStaticFieldRef();
    internal static Tuple`2<int, string> crefQuotationsCantContainInlineIL();
    internal static Tuple`2<int, string> crefQuotationsCantContainDescendingForLoops();
    internal static Tuple`2<int, string> crefQuotationsCantFetchUnionIndexes();
    internal static Tuple`2<int, string> crefQuotationsCantSetUnionFields();
    internal static Tuple`2<int, string> crefQuotationsCantSetExceptionFields();
    internal static Tuple`2<int, string> crefQuotationsCantRequireByref();
    internal static Tuple`2<int, string> crefQuotationsCantCallTraitMembers();
    internal static Tuple`2<int, string> crefQuotationsCantContainThisConstant();
    internal static Tuple`2<int, string> crefQuotationsCantContainThisPatternMatch();
    internal static Tuple`2<int, string> crefQuotationsCantContainArrayPatternMatching();
    internal static Tuple`2<int, string> crefQuotationsCantContainThisType();
    internal static string csTypeCannotBeResolvedAtCompileTime(string a0);
    internal static Tuple`2<int, string> csCodeLessGeneric();
    internal static Tuple`2<int, string> csTypeInferenceMaxDepth();
    internal static string csExpectedArguments();
    internal static string csIndexArgumentMismatch(int a0, int a1);
    internal static string csExpectTypeWithOperatorButGivenFunction(string a0);
    internal static string csExpectTypeWithOperatorButGivenTuple(string a0);
    internal static string csTypesDoNotSupportOperator(string a0, string a1);
    internal static string csTypeDoesNotSupportOperator(string a0, string a1);
    internal static string csTypesDoNotSupportOperatorNullable(string a0, string a1);
    internal static string csTypeDoesNotSupportOperatorNullable(string a0, string a1);
    internal static string csTypeDoesNotSupportConversion(string a0, string a1);
    internal static string csMethodFoundButIsStatic(string a0, string a1, string a2);
    internal static string csMethodFoundButIsNotStatic(string a0, string a1, string a2);
    internal static Tuple`2<int, string> csStructConstraintInconsistent();
    internal static Tuple`2<int, string> csUnmanagedConstraintInconsistent();
    internal static string csTypeDoesNotHaveNull(string a0);
    internal static string csNullableTypeDoesNotHaveNull(string a0);
    internal static string csTypeDoesNotSupportComparison1(string a0);
    internal static string csTypeDoesNotSupportComparison2(string a0);
    internal static string csTypeDoesNotSupportComparison3(string a0);
    internal static string csTypeDoesNotSupportEquality1(string a0);
    internal static string csTypeDoesNotSupportEquality2(string a0);
    internal static string csTypeDoesNotSupportEquality3(string a0);
    internal static string csTypeIsNotEnumType(string a0);
    internal static string csTypeHasNonStandardDelegateType(string a0);
    internal static string csTypeIsNotDelegateType(string a0);
    internal static string csTypeParameterCannotBeNullable();
    internal static string csGenericConstructRequiresStructType(string a0);
    internal static string csGenericConstructRequiresUnmanagedType(string a0);
    internal static string csTypeNotCompatibleBecauseOfPrintf(string a0, string a1);
    internal static string csGenericConstructRequiresReferenceSemantics(string a0);
    internal static string csGenericConstructRequiresNonAbstract(string a0);
    internal static string csGenericConstructRequiresPublicDefaultConstructor(string a0);
    internal static string csGenericConstructRequiresStructOrReferenceConstraint();
    internal static Tuple`2<int, string> csTypeInstantiationLengthMismatch();
    internal static Tuple`2<int, string> csOptionalArgumentNotPermittedHere();
    internal static Tuple`2<int, string> csMemberIsNotStatic(string a0);
    internal static Tuple`2<int, string> csMemberIsNotInstance(string a0);
    internal static Tuple`2<int, string> csArgumentLengthMismatch();
    internal static Tuple`2<int, string> csArgumentTypesDoNotMatch();
    internal static Tuple`2<int, string> csMethodExpectsParams();
    internal static Tuple`2<int, string> csMemberIsNotAccessible(string a0, string a1);
    internal static Tuple`2<int, string> csMemberIsNotAccessible2(string a0, string a1);
    internal static Tuple`2<int, string> csMethodIsNotAStaticMethod(string a0);
    internal static Tuple`2<int, string> csMethodIsNotAnInstanceMethod(string a0);
    internal static string csMemberHasNoArgumentOrReturnProperty(string a0, string a1, string a2);
    internal static string csCtorHasNoArgumentOrReturnProperty(string a0, string a1, string a2);
    internal static Tuple`2<int, string> csRequiredSignatureIs(string a0);
    internal static Tuple`2<int, string> csMemberSignatureMismatch(string a0, int a1, string a2);
    internal static Tuple`2<int, string> csMemberSignatureMismatch2(string a0, int a1, string a2);
    internal static Tuple`2<int, string> csMemberSignatureMismatch3(string a0, int a1, string a2, string a3);
    internal static Tuple`2<int, string> csMemberSignatureMismatch4(string a0, int a1, string a2, string a3);
    internal static Tuple`2<int, string> csMemberSignatureMismatchArityNamed(string a0, int a1, int a2, int a3, string a4);
    internal static Tuple`2<int, string> csMemberSignatureMismatchArity(string a0, int a1, int a2, string a3);
    internal static Tuple`2<int, string> csCtorSignatureMismatchArity(string a0, int a1, int a2, string a3);
    internal static Tuple`2<int, string> csCtorSignatureMismatchArityProp(string a0, int a1, int a2, string a3);
    internal static Tuple`2<int, string> csMemberSignatureMismatchArityType(string a0, int a1, int a2, string a3);
    internal static Tuple`2<int, string> csMemberNotAccessible(string a0, int a1, string a2, int a3);
    internal static Tuple`2<int, string> csIncorrectGenericInstantiation(string a0, string a1, int a2);
    internal static Tuple`2<int, string> csMemberOverloadArityMismatch(string a0, int a1, int a2);
    internal static Tuple`2<int, string> csNoMemberTakesTheseArguments(string a0, string a1, int a2);
    internal static Tuple`2<int, string> csNoMemberTakesTheseArguments2(string a0, string a1, int a2, int a3);
    internal static Tuple`2<int, string> csNoMemberTakesTheseArguments3(string a0, string a1, int a2, string a3);
    internal static Tuple`2<int, string> csMethodNotFound(string a0);
    internal static string csNoOverloadsFound(string a0);
    internal static string csNoOverloadsFoundArgumentsPrefixSingular(string a0);
    internal static string csNoOverloadsFoundArgumentsPrefixPlural(string a0);
    internal static string csNoOverloadsFoundTypeParametersPrefixSingular(string a0);
    internal static string csNoOverloadsFoundTypeParametersPrefixPlural(string a0);
    internal static string csNoOverloadsFoundReturnType(string a0);
    internal static string csMethodIsOverloaded(string a0);
    internal static string csCandidates(string a0);
    internal static string csAvailableOverloads(string a0);
    internal static string csOverloadCandidateNamedArgumentTypeMismatch(string a0);
    internal static string csOverloadCandidateIndexedArgumentTypeMismatch(int a0);
    internal static Tuple`2<int, string> parsDoCannotHaveVisibilityDeclarations(string a0);
    internal static Tuple`2<int, string> parsEofInHashIf();
    internal static Tuple`2<int, string> parsEofInString();
    internal static Tuple`2<int, string> parsEofInVerbatimString();
    internal static Tuple`2<int, string> parsEofInComment();
    internal static Tuple`2<int, string> parsEofInStringInComment();
    internal static Tuple`2<int, string> parsEofInVerbatimStringInComment();
    internal static Tuple`2<int, string> parsEofInIfOcaml();
    internal static Tuple`2<int, string> parsEofInDirective();
    internal static Tuple`2<int, string> parsNoHashEndIfFound();
    internal static Tuple`2<int, string> parsAttributesIgnored();
    internal static Tuple`2<int, string> parsUseBindingsIllegalInImplicitClassConstructors();
    internal static Tuple`2<int, string> parsUseBindingsIllegalInModules();
    internal static Tuple`2<int, string> parsIntegerForLoopRequiresSimpleIdentifier();
    internal static Tuple`2<int, string> parsOnlyOneWithAugmentationAllowed();
    internal static Tuple`2<int, string> parsUnexpectedSemicolon();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFile();
    internal static Tuple`2<int, string> parsUnexpectedVisibilityDeclaration(string a0);
    internal static Tuple`2<int, string> parsOnlyHashDirectivesAllowed();
    internal static Tuple`2<int, string> parsVisibilityDeclarationsShouldComePriorToIdentifier();
    internal static Tuple`2<int, string> parsNamespaceOrModuleNotBoth();
    internal static Tuple`2<int, string> parsModuleAbbreviationMustBeSimpleName();
    internal static Tuple`2<int, string> parsIgnoreAttributesOnModuleAbbreviation();
    internal static Tuple`2<int, string> parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate(string a0);
    internal static Tuple`2<int, string> parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate(string a0);
    internal static Tuple`2<int, string> parsUnClosedBlockInHashLight();
    internal static Tuple`2<int, string> parsUnmatchedBeginOrStruct();
    internal static Tuple`2<int, string> parsModuleDefnMustBeSimpleName();
    internal static Tuple`2<int, string> parsUnexpectedEmptyModuleDefn();
    internal static string parsAttributesMustComeBeforeVal();
    internal static Tuple`2<int, string> parsAttributesAreNotPermittedOnInterfaceImplementations();
    internal static Tuple`2<int, string> parsSyntaxError();
    internal static Tuple`2<int, string> parsAugmentationsIllegalOnDelegateType();
    internal static Tuple`2<int, string> parsUnmatchedClassInterfaceOrStruct();
    internal static Tuple`2<int, string> parsEmptyTypeDefinition();
    internal static Tuple`2<int, string> parsUnmatchedWith();
    internal static Tuple`2<int, string> parsGetOrSetRequired();
    internal static Tuple`2<int, string> parsOnlyClassCanTakeValueArguments();
    internal static Tuple`2<int, string> parsUnmatchedBegin();
    internal static Tuple`2<int, string> parsInvalidDeclarationSyntax();
    internal static Tuple`2<int, string> parsGetAndOrSetRequired();
    internal static Tuple`2<int, string> parsTypeAnnotationsOnGetSet();
    internal static Tuple`2<int, string> parsGetterMustHaveAtLeastOneArgument();
    internal static Tuple`2<int, string> parsMultipleAccessibilitiesForGetSet();
    internal static Tuple`2<int, string> parsSetSyntax();
    internal static Tuple`2<int, string> parsInterfacesHaveSameVisibilityAsEnclosingType();
    internal static Tuple`2<int, string> parsAccessibilityModsIllegalForAbstract();
    internal static Tuple`2<int, string> parsAttributesIllegalOnInherit();
    internal static Tuple`2<int, string> parsVisibilityIllegalOnInherit();
    internal static Tuple`2<int, string> parsInheritDeclarationsCannotHaveAsBindings();
    internal static Tuple`2<int, string> parsAttributesIllegalHere();
    internal static Tuple`2<int, string> parsTypeAbbreviationsCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsEnumTypesCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsAllEnumFieldsRequireValues();
    internal static Tuple`2<int, string> parsInlineAssemblyCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsUnexpectedIdentifier(string a0);
    internal static Tuple`2<int, string> parsUnionCasesCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsEnumFieldsCannotHaveVisibilityDeclarations();
    internal static string parsConsiderUsingSeparateRecordType();
    internal static Tuple`2<int, string> parsRecordFieldsCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> parsLetAndForNonRecBindings();
    internal static Tuple`2<int, string> parsUnmatchedParen();
    internal static Tuple`2<int, string> parsSuccessivePatternsShouldBeSpacedOrTupled();
    internal static Tuple`2<int, string> parsNoMatchingInForLet();
    internal static Tuple`2<int, string> parsErrorInReturnForLetIncorrectIndentation();
    internal static Tuple`2<int, string> parsExpectedExpressionAfterLet(string a0, string a1);
    internal static Tuple`2<int, string> parsIncompleteIf();
    internal static Tuple`2<int, string> parsAssertIsNotFirstClassValue();
    internal static Tuple`2<int, string> parsIdentifierExpected();
    internal static Tuple`2<int, string> parsInOrEqualExpected();
    internal static Tuple`2<int, string> parsArrowUseIsLimited();
    internal static Tuple`2<int, string> parsSuccessiveArgsShouldBeSpacedOrTupled();
    internal static Tuple`2<int, string> parsUnmatchedBracket();
    internal static Tuple`2<int, string> parsMissingQualificationAfterDot();
    internal static string parsParenFormIsForML();
    internal static Tuple`2<int, string> parsMismatchedQuote(string a0);
    internal static Tuple`2<int, string> parsUnmatched(string a0);
    internal static Tuple`2<int, string> parsUnmatchedBracketBar();
    internal static Tuple`2<int, string> parsUnmatchedBrace();
    internal static Tuple`2<int, string> parsUnmatchedBraceBar();
    internal static Tuple`2<int, string> parsFieldBinding();
    internal static Tuple`2<int, string> parsMemberIllegalInObjectImplementation();
    internal static Tuple`2<int, string> parsMissingFunctionBody();
    internal static Tuple`2<int, string> parsSyntaxErrorInLabeledType();
    internal static Tuple`2<int, string> parsUnexpectedInfixOperator();
    internal static string parsMultiArgumentGenericTypeFormDeprecated();
    internal static Tuple`2<int, string> parsInvalidLiteralInType();
    internal static Tuple`2<int, string> parsUnexpectedOperatorForUnitOfMeasure();
    internal static Tuple`2<int, string> parsUnexpectedIntegerLiteralForUnitOfMeasure();
    internal static Tuple`2<int, string> parsMismatchedQuotationName(string a0);
    internal static Tuple`2<int, string> parsActivePatternCaseMustBeginWithUpperCase();
    internal static Tuple`2<int, string> parsActivePatternCaseContainsPipe();
    internal static Tuple`2<int, string> parsIllegalDenominatorForMeasureExponent();
    internal static Tuple`2<int, string> parsIncompleteTyparExpr1();
    internal static Tuple`2<int, string> parsIncompleteTyparExpr2();
    internal static string parsNoEqualShouldFollowNamespace();
    internal static string parsSyntaxModuleStructEndDeprecated();
    internal static string parsSyntaxModuleSigEndDeprecated();
    internal static Tuple`2<int, string> tcStaticFieldUsedWhenInstanceFieldExpected();
    internal static Tuple`2<int, string> tcMethodNotAccessible(string a0);
    internal static Tuple`2<int, string> tcImplicitMeasureFollowingSlash();
    internal static Tuple`2<int, string> tcUnexpectedMeasureAnon();
    internal static Tuple`2<int, string> tcNonZeroConstantCannotHaveGenericUnit();
    internal static Tuple`2<int, string> tcSeqResultsUseYield();
    internal static string tcUnexpectedBigRationalConstant();
    internal static Tuple`2<int, string> tcInvalidTypeForUnitsOfMeasure();
    internal static string tcUnexpectedConstUint16Array();
    internal static string tcUnexpectedConstByteArray();
    internal static Tuple`2<int, string> tcParameterRequiresName();
    internal static Tuple`2<int, string> tcReturnValuesCannotHaveNames();
    internal static string tcMemberKindPropertyGetSetNotExpected();
    internal static Tuple`2<int, string> tcNamespaceCannotContainExtensionMembers();
    internal static Tuple`2<int, string> tcMultipleVisibilityAttributes();
    internal static Tuple`2<int, string> tcMultipleVisibilityAttributesWithLet();
    internal static string tcInvalidMethodNameForRelationalOperator(string a0, string a1);
    internal static string tcInvalidMethodNameForEquality(string a0, string a1);
    internal static string tcInvalidMemberName(string a0, string a1);
    internal static string tcInvalidMemberNameFixedTypes(string a0);
    internal static string tcInvalidOperatorDefinitionRelational(string a0);
    internal static string tcInvalidOperatorDefinitionEquality(string a0);
    internal static string tcInvalidOperatorDefinition(string a0);
    internal static string tcInvalidIndexOperatorDefinition(string a0);
    internal static string tcExpectModuleOrNamespaceParent(string a0);
    internal static Tuple`2<int, string> tcImplementsIComparableExplicitly(string a0);
    internal static Tuple`2<int, string> tcImplementsGenericIComparableExplicitly(string a0);
    internal static Tuple`2<int, string> tcImplementsIStructuralComparableExplicitly(string a0);
    internal static Tuple`2<int, string> tcRecordFieldInconsistentTypes();
    internal static Tuple`2<int, string> tcDllImportStubsCannotBeInlined();
    internal static Tuple`2<int, string> tcStructsCanOnlyBindThisAtMemberDeclaration();
    internal static Tuple`2<int, string> tcUnexpectedExprAtRecInfPoint();
    internal static Tuple`2<int, string> tcLessGenericBecauseOfAnnotation(string a0, string a1);
    internal static Tuple`2<int, string> tcConstrainedTypeVariableCannotBeGeneralized();
    internal static Tuple`2<int, string> tcGenericParameterHasBeenConstrained(string a0);
    internal static Tuple`2<int, string> tcTypeParameterHasBeenConstrained(string a0);
    internal static Tuple`2<int, string> tcTypeParametersInferredAreNotStable();
    internal static Tuple`2<int, string> tcExplicitTypeParameterInvalid();
    internal static Tuple`2<int, string> tcOverridingMethodRequiresAllOrNoTypeParameters();
    internal static Tuple`2<int, string> tcFieldsDoNotDetermineUniqueRecordType();
    internal static Tuple`2<int, string> tcMultipleFieldsInRecord(string a0);
    internal static Tuple`2<int, string> tcUnknownUnion();
    internal static Tuple`2<int, string> tcNotSufficientlyGenericBecauseOfScope(string a0);
    internal static Tuple`2<int, string> tcPropertyRequiresExplicitTypeParameters();
    internal static Tuple`2<int, string> tcConstructorCannotHaveTypeParameters();
    internal static Tuple`2<int, string> tcInstanceMemberRequiresTarget();
    internal static Tuple`2<int, string> tcUnexpectedPropertyInSyntaxTree();
    internal static Tuple`2<int, string> tcStaticInitializerRequiresArgument();
    internal static Tuple`2<int, string> tcObjectConstructorRequiresArgument();
    internal static Tuple`2<int, string> tcStaticMemberShouldNotHaveThis();
    internal static Tuple`2<int, string> tcExplicitStaticInitializerSyntax();
    internal static Tuple`2<int, string> tcExplicitObjectConstructorSyntax();
    internal static Tuple`2<int, string> tcUnexpectedPropertySpec();
    internal static string tcObjectExpressionFormDeprecated();
    internal static Tuple`2<int, string> tcInvalidDeclaration();
    internal static Tuple`2<int, string> tcAttributesInvalidInPatterns();
    internal static Tuple`2<int, string> tcFunctionRequiresExplicitTypeArguments(string a0);
    internal static Tuple`2<int, string> tcDoesNotAllowExplicitTypeArguments(string a0);
    internal static Tuple`2<int, string> tcTypeParameterArityMismatch(int a0, int a1);
    internal static Tuple`2<int, string> tcDefaultStructConstructorCall();
    internal static string tcCouldNotFindIDisposable();
    internal static Tuple`2<int, string> tcNonLiteralCannotBeUsedInPattern();
    internal static Tuple`2<int, string> tcFieldIsReadonly();
    internal static Tuple`2<int, string> tcNameArgumentsMustAppearLast();
    internal static Tuple`2<int, string> tcFunctionRequiresExplicitLambda(int a0);
    internal static Tuple`2<int, string> tcTypeCannotBeEnumerated(string a0);
    internal static Tuple`2<int, string> tcInvalidMixtureOfRecursiveForms();
    internal static Tuple`2<int, string> tcInvalidObjectConstructionExpression();
    internal static Tuple`2<int, string> tcInvalidConstraint();
    internal static Tuple`2<int, string> tcInvalidConstraintTypeSealed();
    internal static Tuple`2<int, string> tcInvalidEnumConstraint();
    internal static Tuple`2<int, string> tcInvalidNewConstraint();
    internal static Tuple`2<int, string> tcInvalidPropertyType();
    internal static Tuple`2<int, string> tcExpectedUnitOfMeasureMarkWithAttribute();
    internal static Tuple`2<int, string> tcExpectedTypeParameter();
    internal static Tuple`2<int, string> tcExpectedTypeNotUnitOfMeasure();
    internal static Tuple`2<int, string> tcExpectedUnitOfMeasureNotType();
    internal static Tuple`2<int, string> tcInvalidUnitsOfMeasurePrefix();
    internal static Tuple`2<int, string> tcUnitsOfMeasureInvalidInTypeConstructor();
    internal static Tuple`2<int, string> tcRequireBuilderMethod(string a0);
    internal static Tuple`2<int, string> tcTypeHasNoNestedTypes();
    internal static Tuple`2<int, string> tcUnexpectedSymbolInTypeExpression(string a0);
    internal static Tuple`2<int, string> tcTypeParameterInvalidAsTypeConstructor();
    internal static Tuple`2<int, string> tcIllegalSyntaxInTypeExpression();
    internal static Tuple`2<int, string> tcAnonymousUnitsOfMeasureCannotBeNested();
    internal static Tuple`2<int, string> tcAnonymousTypeInvalidInDeclaration();
    internal static Tuple`2<int, string> tcUnexpectedSlashInType();
    internal static Tuple`2<int, string> tcUnexpectedTypeArguments();
    internal static Tuple`2<int, string> tcOptionalArgsOnlyOnMembers();
    internal static Tuple`2<int, string> tcNameNotBoundInPattern(string a0);
    internal static Tuple`2<int, string> tcInvalidNonPrimitiveLiteralInPatternMatch();
    internal static Tuple`2<int, string> tcInvalidTypeArgumentUsage();
    internal static Tuple`2<int, string> tcRequireActivePatternWithOneResult();
    internal static Tuple`2<int, string> tcInvalidArgForParameterizedPattern();
    internal static Tuple`2<int, string> tcInvalidIndexIntoActivePatternArray();
    internal static Tuple`2<int, string> tcUnionCaseDoesNotTakeArguments();
    internal static Tuple`2<int, string> tcUnionCaseRequiresOneArgument();
    internal static Tuple`2<int, string> tcUnionCaseExpectsTupledArguments(int a0, int a1, string a2);
    internal static Tuple`2<int, string> tcFieldIsNotStatic(string a0);
    internal static Tuple`2<int, string> tcFieldNotLiteralCannotBeUsedInPattern();
    internal static Tuple`2<int, string> tcRequireVarConstRecogOrLiteral();
    internal static Tuple`2<int, string> tcInvalidPattern();
    internal static Tuple`2<int, string> tcIllegalPattern();
    internal static Tuple`2<int, string> tcSyntaxErrorUnexpectedQMark();
    internal static Tuple`2<int, string> tcExpressionCountMisMatch(int a0, int a1);
    internal static Tuple`2<int, string> tcExprUndelayed();
    internal static Tuple`2<int, string> tcExpressionRequiresSequence();
    internal static Tuple`2<int, string> tcInvalidObjectExpressionSyntaxForm();
    internal static Tuple`2<int, string> tcInvalidObjectSequenceOrRecordExpression();
    internal static Tuple`2<int, string> tcInvalidSequenceExpressionSyntaxForm();
    internal static string tcExpressionWithIfRequiresParenthesis();
    internal static Tuple`2<int, string> tcUnableToParseFormatString(string a0);
    internal static Tuple`2<int, string> tcListLiteralMaxSize();
    internal static Tuple`2<int, string> tcExpressionFormRequiresObjectConstructor();
    internal static Tuple`2<int, string> tcNamedArgumentsCannotBeUsedInMemberTraits();
    internal static Tuple`2<int, string> tcNotValidEnumCaseName();
    internal static Tuple`2<int, string> tcFieldIsNotMutable();
    internal static Tuple`2<int, string> tcConstructRequiresListArrayOrSequence();
    internal static Tuple`2<int, string> tcConstructRequiresComputationExpressions();
    internal static Tuple`2<int, string> tcConstructRequiresSequenceOrComputations();
    internal static Tuple`2<int, string> tcConstructRequiresComputationExpression();
    internal static Tuple`2<int, string> tcInvalidIndexerExpression();
    internal static Tuple`2<int, string> tcObjectOfIndeterminateTypeUsedRequireTypeConstraint();
    internal static Tuple`2<int, string> tcCannotInheritFromVariableType();
    internal static Tuple`2<int, string> tcObjectConstructorsOnTypeParametersCannotTakeArguments();
    internal static Tuple`2<int, string> tcCompiledNameAttributeMisused();
    internal static Tuple`2<int, string> tcNamedTypeRequired(string a0);
    internal static Tuple`2<int, string> tcInheritCannotBeUsedOnInterfaceType();
    internal static Tuple`2<int, string> tcNewCannotBeUsedOnInterfaceType();
    internal static Tuple`2<int, string> tcAbstractTypeCannotBeInstantiated();
    internal static Tuple`2<int, string> tcIDisposableTypeShouldUseNew();
    internal static Tuple`2<int, string> tcSyntaxCanOnlyBeUsedToCreateObjectTypes(string a0);
    internal static Tuple`2<int, string> tcConstructorRequiresCall(string a0);
    internal static Tuple`2<int, string> tcUndefinedField(string a0, string a1);
    internal static Tuple`2<int, string> tcFieldRequiresAssignment(string a0, string a1);
    internal static Tuple`2<int, string> tcExtraneousFieldsGivenValues();
    internal static Tuple`2<int, string> tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual();
    internal static Tuple`2<int, string> tcNoAbstractOrVirtualMemberFound(string a0);
    internal static Tuple`2<int, string> tcMemberFoundIsNotAbstractOrVirtual(string a0, string a1);
    internal static Tuple`2<int, string> tcArgumentArityMismatch(string a0, int a1, int a2, string a3, string a4);
    internal static Tuple`2<int, string> tcArgumentArityMismatchOneOverload(string a0, int a1, int a2, string a3, string a4);
    internal static Tuple`2<int, string> tcSimpleMethodNameRequired();
    internal static Tuple`2<int, string> tcPredefinedTypeCannotBeUsedAsSuperType();
    internal static Tuple`2<int, string> tcNewMustBeUsedWithNamedType();
    internal static Tuple`2<int, string> tcCannotCreateExtensionOfSealedType();
    internal static Tuple`2<int, string> tcNoArgumentsForRecordValue();
    internal static Tuple`2<int, string> tcNoInterfaceImplementationForConstructionExpression();
    internal static Tuple`2<int, string> tcObjectConstructionCanOnlyBeUsedInClassTypes();
    internal static Tuple`2<int, string> tcOnlySimpleBindingsCanBeUsedInConstructionExpressions();
    internal static Tuple`2<int, string> tcObjectsMustBeInitializedWithObjectExpression();
    internal static Tuple`2<int, string> tcExpectedInterfaceType();
    internal static Tuple`2<int, string> tcConstructorForInterfacesDoNotTakeArguments();
    internal static Tuple`2<int, string> tcConstructorRequiresArguments();
    internal static Tuple`2<int, string> tcNewRequiresObjectConstructor();
    internal static Tuple`2<int, string> tcAtLeastOneOverrideIsInvalid();
    internal static Tuple`2<int, string> tcNumericLiteralRequiresModule(string a0);
    internal static Tuple`2<int, string> tcInvalidRecordConstruction();
    internal static Tuple`2<int, string> tcExpressionFormRequiresRecordTypes();
    internal static Tuple`2<int, string> tcInheritedTypeIsNotObjectModelType();
    internal static Tuple`2<int, string> tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes();
    internal static Tuple`2<int, string> tcEmptyRecordInvalid();
    internal static Tuple`2<int, string> tcTypeIsNotARecordTypeNeedConstructor();
    internal static Tuple`2<int, string> tcTypeIsNotARecordType();
    internal static Tuple`2<int, string> tcConstructIsAmbiguousInComputationExpression();
    internal static Tuple`2<int, string> tcConstructIsAmbiguousInSequenceExpression();
    internal static Tuple`2<int, string> tcDoBangIllegalInSequenceExpression();
    internal static Tuple`2<int, string> tcUseForInSequenceExpression();
    internal static Tuple`2<int, string> tcTryIllegalInSequenceExpression();
    internal static Tuple`2<int, string> tcUseYieldBangForMultipleResults();
    internal static Tuple`2<int, string> tcInvalidAssignment();
    internal static Tuple`2<int, string> tcInvalidUseOfTypeName();
    internal static Tuple`2<int, string> tcTypeHasNoAccessibleConstructor();
    internal static Tuple`2<int, string> tcInvalidUseOfInterfaceType();
    internal static Tuple`2<int, string> tcInvalidUseOfDelegate();
    internal static Tuple`2<int, string> tcPropertyIsNotStatic(string a0);
    internal static Tuple`2<int, string> tcPropertyIsNotReadable(string a0);
    internal static Tuple`2<int, string> tcLookupMayNotBeUsedHere();
    internal static Tuple`2<int, string> tcPropertyIsStatic(string a0);
    internal static Tuple`2<int, string> tcPropertyCannotBeSet1(string a0);
    internal static Tuple`2<int, string> tcInitOnlyPropertyCannotBeSet1(string a0);
    internal static Tuple`2<int, string> tcSetterForInitOnlyPropertyCannotBeCalled1(string a0);
    internal static Tuple`2<int, string> tcConstructorsCannotBeFirstClassValues();
    internal static Tuple`2<int, string> tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields();
    internal static Tuple`2<int, string> tcEventIsStatic(string a0);
    internal static Tuple`2<int, string> tcEventIsNotStatic(string a0);
    internal static Tuple`2<int, string> tcNamedArgumentDidNotMatch(string a0);
    internal static Tuple`2<int, string> tcOverloadsCannotHaveCurriedArguments();
    internal static string tcUnnamedArgumentsDoNotFormPrefix();
    internal static Tuple`2<int, string> tcStaticOptimizationConditionalsOnlyForFSharpLibrary();
    internal static Tuple`2<int, string> tcFormalArgumentIsNotOptional();
    internal static Tuple`2<int, string> tcInvalidOptionalAssignmentToPropertyOrField();
    internal static Tuple`2<int, string> tcDelegateConstructorMustBePassed();
    internal static Tuple`2<int, string> tcBindingCannotBeUseAndRec();
    internal static Tuple`2<int, string> tcVolatileOnlyOnClassLetBindings();
    internal static Tuple`2<int, string> tcAttributesAreNotPermittedOnLetBindings();
    internal static Tuple`2<int, string> tcDefaultValueAttributeRequiresVal();
    internal static Tuple`2<int, string> tcConditionalAttributeRequiresMembers();
    internal static Tuple`2<int, string> tcInvalidActivePatternName();
    internal static Tuple`2<int, string> tcEntryPointAttributeRequiresFunctionInModule();
    internal static Tuple`2<int, string> tcMutableValuesCannotBeInline();
    internal static Tuple`2<int, string> tcMutableValuesMayNotHaveGenericParameters();
    internal static Tuple`2<int, string> tcMutableValuesSyntax();
    internal static Tuple`2<int, string> tcOnlyFunctionsCanBeInline();
    internal static Tuple`2<int, string> tcIllegalAttributesForLiteral();
    internal static Tuple`2<int, string> tcLiteralCannotBeMutable();
    internal static Tuple`2<int, string> tcLiteralCannotBeInline();
    internal static Tuple`2<int, string> tcLiteralCannotHaveGenericParameters();
    internal static Tuple`2<int, string> tcInvalidConstantExpression();
    internal static Tuple`2<int, string> tcTypeIsInaccessible();
    internal static Tuple`2<int, string> tcUnexpectedConditionInImportedAssembly();
    internal static Tuple`2<int, string> tcUnrecognizedAttributeTarget();
    internal static Tuple`2<int, string> tcAttributeIsNotValidForLanguageElementUseDo();
    internal static Tuple`2<int, string> tcAttributeIsNotValidForLanguageElement();
    internal static Tuple`2<int, string> tcOptionalArgumentsCannotBeUsedInCustomAttribute();
    internal static Tuple`2<int, string> tcPropertyCannotBeSet0();
    internal static Tuple`2<int, string> tcPropertyOrFieldNotFoundInAttribute();
    internal static Tuple`2<int, string> tcCustomAttributeMustBeReferenceType();
    internal static Tuple`2<int, string> tcCustomAttributeArgumentMismatch();
    internal static Tuple`2<int, string> tcCustomAttributeMustInvokeConstructor();
    internal static Tuple`2<int, string> tcAttributeExpressionsMustBeConstructorCalls();
    internal static Tuple`2<int, string> tcUnsupportedAttribute();
    internal static Tuple`2<int, string> tcInvalidInlineSpecification();
    internal static Tuple`2<int, string> tcInvalidUseBinding();
    internal static Tuple`2<int, string> tcAbstractMembersIllegalInAugmentation();
    internal static Tuple`2<int, string> tcMethodOverridesIllegalHere();
    internal static Tuple`2<int, string> tcNoMemberFoundForOverride();
    internal static Tuple`2<int, string> tcOverrideArityMismatch(string a0);
    internal static Tuple`2<int, string> tcDefaultImplementationAlreadyExists();
    internal static Tuple`2<int, string> tcDefaultAmbiguous();
    internal static Tuple`2<int, string> tcNoPropertyFoundForOverride();
    internal static Tuple`2<int, string> tcAbstractPropertyMissingGetOrSet(string a0);
    internal static Tuple`2<int, string> tcInvalidSignatureForSet();
    internal static Tuple`2<int, string> tcNewMemberHidesAbstractMember(string a0);
    internal static Tuple`2<int, string> tcNewMemberHidesAbstractMemberWithSuffix(string a0);
    internal static Tuple`2<int, string> tcStaticInitializersIllegalInInterface();
    internal static Tuple`2<int, string> tcObjectConstructorsIllegalInInterface();
    internal static Tuple`2<int, string> tcMemberOverridesIllegalInInterface();
    internal static Tuple`2<int, string> tcConcreteMembersIllegalInInterface();
    internal static Tuple`2<int, string> tcConstructorsDisallowedInExceptionAugmentation();
    internal static Tuple`2<int, string> tcStructsCannotHaveConstructorWithNoArguments();
    internal static Tuple`2<int, string> tcConstructorsIllegalForThisType();
    internal static Tuple`2<int, string> tcRecursiveBindingsWithMembersMustBeDirectAugmentation();
    internal static Tuple`2<int, string> tcOnlySimplePatternsInLetRec();
    internal static Tuple`2<int, string> tcOnlyRecordFieldsAndSimpleLetCanBeMutable();
    internal static Tuple`2<int, string> tcMemberIsNotSufficientlyGeneric();
    internal static Tuple`2<int, string> tcLiteralAttributeRequiresConstantValue();
    internal static Tuple`2<int, string> tcValueInSignatureRequiresLiteralAttribute();
    internal static Tuple`2<int, string> tcThreadStaticAndContextStaticMustBeStatic();
    internal static Tuple`2<int, string> tcVolatileFieldsMustBeMutable();
    internal static Tuple`2<int, string> tcUninitializedValFieldsMustBeMutable();
    internal static Tuple`2<int, string> tcStaticValFieldsMustBeMutableAndPrivate();
    internal static Tuple`2<int, string> tcFieldRequiresName();
    internal static Tuple`2<int, string> tcInvalidNamespaceModuleTypeUnionName();
    internal static Tuple`2<int, string> tcIllegalFormForExplicitTypeDeclaration();
    internal static Tuple`2<int, string> tcReturnTypesForUnionMustBeSameAsType();
    internal static Tuple`2<int, string> tcInvalidEnumerationLiteral();
    internal static Tuple`2<int, string> tcTypeIsNotInterfaceType1(string a0);
    internal static Tuple`2<int, string> tcDuplicateSpecOfInterface();
    internal static Tuple`2<int, string> tcFieldValIllegalHere();
    internal static Tuple`2<int, string> tcInheritIllegalHere();
    internal static Tuple`2<int, string> tcModuleRequiresQualifiedAccess(string a0);
    internal static Tuple`2<int, string> tcOpenUsedWithPartiallyQualifiedPath(string a0);
    internal static Tuple`2<int, string> tcLocalClassBindingsCannotBeInline();
    internal static Tuple`2<int, string> tcTypeAbbreviationsMayNotHaveMembers();
    internal static string tcTypeAbbreviationsCheckedAtCompileTime();
    internal static Tuple`2<int, string> tcEnumerationsMayNotHaveMembers();
    internal static Tuple`2<int, string> tcMeasureDeclarationsRequireStaticMembers();
    internal static string tcStructsMayNotContainDoBindings();
    internal static Tuple`2<int, string> tcStructsMayNotContainLetBindings();
    internal static Tuple`2<int, string> tcStaticLetBindingsRequireClassesWithImplicitConstructors();
    internal static Tuple`2<int, string> tcMeasureDeclarationsRequireStaticMembersNotConstructors();
    internal static Tuple`2<int, string> tcMemberAndLocalClassBindingHaveSameName(string a0);
    internal static Tuple`2<int, string> tcTypeAbbreviationsCannotHaveInterfaceDeclaration();
    internal static Tuple`2<int, string> tcEnumerationsCannotHaveInterfaceDeclaration();
    internal static Tuple`2<int, string> tcTypeIsNotInterfaceType0();
    internal static Tuple`2<int, string> tcAllImplementedInterfacesShouldBeDeclared();
    internal static Tuple`2<int, string> tcDefaultImplementationForInterfaceHasAlreadyBeenAdded();
    internal static Tuple`2<int, string> tcMemberNotPermittedInInterfaceImplementation();
    internal static Tuple`2<int, string> tcDeclarationElementNotPermittedInAugmentation();
    internal static Tuple`2<int, string> tcTypesCannotContainNestedTypes();
    internal static string tcTypeExceptionOrModule();
    internal static string tcTypeOrModule();
    internal static Tuple`2<int, string> tcImplementsIStructuralEquatableExplicitly(string a0);
    internal static Tuple`2<int, string> tcImplementsIEquatableExplicitly(string a0);
    internal static Tuple`2<int, string> tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors();
    internal static Tuple`2<int, string> tcExceptionAbbreviationsShouldNotHaveArgumentList();
    internal static Tuple`2<int, string> tcAbbreviationsFordotNetExceptionsCannotTakeArguments();
    internal static Tuple`2<int, string> tcExceptionAbbreviationsMustReferToValidExceptions();
    internal static Tuple`2<int, string> tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor();
    internal static Tuple`2<int, string> tcNotAnException();
    internal static Tuple`2<int, string> tcInvalidModuleName();
    internal static Tuple`2<int, string> tcInvalidTypeExtension();
    internal static Tuple`2<int, string> tcAttributesOfTypeSpecifyMultipleKindsForType();
    internal static Tuple`2<int, string> tcKindOfTypeSpecifiedDoesNotMatchDefinition();
    internal static Tuple`2<int, string> tcMeasureDefinitionsCannotHaveTypeParameters();
    internal static Tuple`2<int, string> tcTypeRequiresDefinition();
    internal static string tcTypeAbbreviationHasTypeParametersMissingOnType();
    internal static Tuple`2<int, string> tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes();
    internal static Tuple`2<int, string> tcTypesCannotInheritFromMultipleConcreteTypes();
    internal static Tuple`2<int, string> tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute();
    internal static Tuple`2<int, string> tcAllowNullTypesMayOnlyInheritFromAllowNullTypes();
    internal static Tuple`2<int, string> tcGenericTypesCannotHaveStructLayout();
    internal static Tuple`2<int, string> tcOnlyStructsCanHaveStructLayout();
    internal static Tuple`2<int, string> tcRepresentationOfTypeHiddenBySignature();
    internal static Tuple`2<int, string> tcOnlyClassesCanHaveAbstract();
    internal static Tuple`2<int, string> tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure();
    internal static Tuple`2<int, string> tcOverridesCannotHaveVisibilityDeclarations();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedDU();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedRecord();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedAssemblyCode();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedStruct();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedDelegate();
    internal static Tuple`2<int, string> tcTypesAreAlwaysSealedEnum();
    internal static Tuple`2<int, string> tcInterfaceTypesAndDelegatesCannotContainFields();
    internal static Tuple`2<int, string> tcAbbreviatedTypesCannotBeSealed();
    internal static Tuple`2<int, string> tcCannotInheritFromSealedType();
    internal static Tuple`2<int, string> tcCannotInheritFromInterfaceType();
    internal static Tuple`2<int, string> tcStructTypesCannotContainAbstractMembers();
    internal static Tuple`2<int, string> tcInterfaceTypesCannotBeSealed();
    internal static Tuple`2<int, string> tcInvalidDelegateSpecification();
    internal static Tuple`2<int, string> tcDelegatesCannotBeCurried();
    internal static Tuple`2<int, string> tcInvalidTypeForLiteralEnumeration();
    internal static Tuple`2<int, string> tcTypeDefinitionIsCyclic();
    internal static Tuple`2<int, string> tcTypeDefinitionIsCyclicThroughInheritance();
    internal static string tcReservedSyntaxForAugmentation();
    internal static Tuple`2<int, string> tcMembersThatExtendInterfaceMustBePlacedInSeparateModule();
    internal static Tuple`2<int, string> tcDeclaredTypeParametersForExtensionDoNotMatchOriginal(string a0);
    internal static Tuple`2<int, string> tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit();
    internal static Tuple`2<int, string> tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers();
    internal static Tuple`2<int, string> tcInheritDeclarationMissingArguments();
    internal static Tuple`2<int, string> tcInheritConstructionCallNotPartOfImplicitSequence();
    internal static Tuple`2<int, string> tcLetAndDoRequiresImplicitConstructionSequence();
    internal static Tuple`2<int, string> tcTypeAbbreviationsCannotHaveAugmentations();
    internal static Tuple`2<int, string> tcModuleAbbreviationForNamespace(string a0);
    internal static Tuple`2<int, string> tcTypeUsedInInvalidWay(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcMemberUsedInInvalidWay(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcAttributeAutoOpenWasIgnored(string a0, string a1);
    internal static Tuple`2<int, string> ilUndefinedValue(string a0);
    internal static Tuple`2<int, string> ilLabelNotFound(string a0);
    internal static Tuple`2<int, string> ilIncorrectNumberOfTypeArguments();
    internal static string ilDynamicInvocationNotSupported(string a0);
    internal static Tuple`2<int, string> ilAddressOfLiteralFieldIsInvalid();
    internal static Tuple`2<int, string> ilAddressOfValueHereIsInvalid(string a0);
    internal static Tuple`2<int, string> ilCustomMarshallersCannotBeUsedInFSharp();
    internal static Tuple`2<int, string> ilMarshalAsAttributeCannotBeDecoded();
    internal static Tuple`2<int, string> ilSignatureForExternalFunctionContainsTypeParameters();
    internal static Tuple`2<int, string> ilDllImportAttributeCouldNotBeDecoded();
    internal static Tuple`2<int, string> ilLiteralFieldsCannotBeSet();
    internal static Tuple`2<int, string> ilStaticMethodIsNotLambda(string a0);
    internal static Tuple`2<int, string> ilMutableVariablesCannotEscapeMethod();
    internal static Tuple`2<int, string> ilUnexpectedUnrealizedValue();
    internal static Tuple`2<int, string> ilMainModuleEmpty();
    internal static Tuple`2<int, string> ilTypeCannotBeUsedForLiteralField();
    internal static Tuple`2<int, string> ilUnexpectedGetSetAnnotation();
    internal static Tuple`2<int, string> ilFieldOffsetAttributeCouldNotBeDecoded();
    internal static Tuple`2<int, string> ilStructLayoutAttributeCouldNotBeDecoded();
    internal static Tuple`2<int, string> ilDefaultAugmentationAttributeCouldNotBeDecoded();
    internal static Tuple`2<int, string> ilReflectedDefinitionsCannotUseSliceOperator();
    internal static Tuple`2<int, string> packageManagerUnknown(string a0, string a1, string a2);
    internal static Tuple`2<int, string> packageManagerError(string a0);
    internal static Tuple`2<int, string> optsProblemWithCodepage(int a0, string a1);
    internal static string optsCopyright();
    internal static string optsCopyrightCommunity();
    internal static string optsNameOfOutputFile();
    internal static string optsBuildConsole();
    internal static string optsBuildWindows();
    internal static string optsBuildLibrary();
    internal static string optsBuildModule();
    internal static string optsDelaySign();
    internal static string optsPublicSign();
    internal static string optsWriteXml();
    internal static string optsStrongKeyFile();
    internal static string optsStrongKeyContainer();
    internal static string optsCompressMetadata();
    internal static string optsPlatform();
    internal static string optsNoOpt();
    internal static string optsNoInterface();
    internal static string optsSig();
    internal static string optsAllSigs();
    internal static string optsReference();
    internal static string optsCompilerTool();
    internal static string optsWin32icon();
    internal static string optsWin32res();
    internal static string optsWin32manifest();
    internal static string optsNowin32manifest();
    internal static string optsEmbedAllSource();
    internal static string optsEmbedSource();
    internal static string optsSourceLink();
    internal static Tuple`2<int, string> optsPdbMatchesOutputFileName();
    internal static string srcFileTooLarge();
    internal static string optsResource();
    internal static string optsLinkresource();
    internal static string optsDebugPM();
    internal static string optsDebug(string a0);
    internal static string optsOptimize();
    internal static string optsTailcalls();
    internal static string optsDeterministic();
    internal static string optsRefOnly();
    internal static string optsRefOut();
    internal static string optsPathMap();
    internal static string optsCrossoptimize();
    internal static string optsReflectionFree();
    internal static string optsWarnaserrorPM();
    internal static string optsWarnaserror();
    internal static string optsWarn();
    internal static string optsNowarn();
    internal static string optsWarnOn();
    internal static string optsChecked();
    internal static string optsDefine();
    internal static string optsMlcompatibility();
    internal static string optsNologo();
    internal static string optsHelp();
    internal static string optsVersion();
    internal static string optsResponseFile();
    internal static string optsCodepage();
    internal static string optsClearResultsCache();
    internal static string optsUtf8output();
    internal static string optsFullpaths();
    internal static string optsLib();
    internal static string optsBaseaddress();
    internal static string optsChecksumAlgorithm();
    internal static string optsNoframework();
    internal static string optsStandalone();
    internal static string optsStaticlink();
    internal static string optsResident();
    internal static string optsPdb();
    internal static string optsSimpleresolution();
    internal static string optsShortFormOf(string a0);
    internal static string optsClirootDeprecatedMsg();
    internal static string optsClirootDescription();
    internal static string optsHelpBannerOutputFiles();
    internal static string optsHelpBannerInputFiles();
    internal static string optsHelpBannerResources();
    internal static string optsHelpBannerCodeGen();
    internal static string optsHelpBannerAdvanced();
    internal static string optsHelpBannerMisc();
    internal static string optsHelpBannerLanguage();
    internal static string optsHelpBannerErrsAndWarns();
    internal static string optsInternalNoDescription(string a0);
    internal static string optsDCLONoDescription(string a0);
    internal static string optsDCLODeprecatedSuggestAlternative(string a0, string a1);
    internal static string optsDCLOHtmlDoc(string a0);
    internal static string optsConsoleColors();
    internal static string optsUseHighEntropyVA();
    internal static string optsSubSystemVersion();
    internal static string optsTargetProfile();
    internal static string optsEmitDebugInfoInQuotations();
    internal static string optsPreferredUiLang();
    internal static string optsNoCopyFsharpCore();
    internal static string optsSignatureData();
    internal static Tuple`2<int, string> optsUnknownSignatureData(string a0);
    internal static string optsOptimizationData();
    internal static Tuple`2<int, string> optsUnknownOptimizationData(string a0);
    internal static Tuple`2<int, string> optsUnrecognizedTarget(string a0);
    internal static Tuple`2<int, string> optsUnrecognizedDebugType(string a0);
    internal static Tuple`2<int, string> optsInvalidWarningLevel(int a0);
    internal static Tuple`2<int, string> optsInvalidSubSystemVersion(string a0);
    internal static Tuple`2<int, string> optsInvalidTargetProfile(string a0);
    internal static Tuple`2<int, string> optsUnknownArgumentToTheTestSwitch(string a0);
    internal static Tuple`2<int, string> optsUnknownPlatform(string a0);
    internal static Tuple`2<int, string> optsUnknownChecksumAlgorithm(string a0);
    internal static string typeInfoFullName();
    internal static string typeInfoOtherOverloads(int a0);
    internal static string typeInfoUnionCase();
    internal static string typeInfoActivePatternResult();
    internal static string typeInfoActiveRecognizer();
    internal static string typeInfoField();
    internal static string typeInfoEvent();
    internal static string typeInfoProperty();
    internal static string typeInfoExtension();
    internal static string typeInfoCustomOperation();
    internal static string typeInfoArgument();
    internal static string typeInfoAnonRecdField();
    internal static string typeInfoPatternVariable();
    internal static string typeInfoNamespace();
    internal static string typeInfoModule();
    internal static string typeInfoNamespaceOrModule();
    internal static string typeInfoFromFirst(string a0);
    internal static string typeInfoFromNext(string a0);
    internal static string typeInfoGeneratedProperty();
    internal static string typeInfoGeneratedType();
    internal static string suggestedName();
    internal static Tuple`2<int, string> recursiveClassHierarchy(string a0);
    internal static Tuple`2<int, string> InvalidRecursiveReferenceToAbstractSlot();
    internal static Tuple`2<int, string> eventHasNonStandardType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> typeIsNotAccessible(string a0);
    internal static Tuple`2<int, string> unionCasesAreNotAccessible(string a0);
    internal static Tuple`2<int, string> valueIsNotAccessible(string a0);
    internal static Tuple`2<int, string> unionCaseIsNotAccessible(string a0);
    internal static Tuple`2<int, string> fieldIsNotAccessible(string a0);
    internal static Tuple`2<int, string> structOrClassFieldIsNotAccessible(string a0);
    internal static string experimentalConstruct();
    internal static Tuple`2<int, string> noInvokeMethodsFound();
    internal static string moreThanOneInvokeMethodFound();
    internal static Tuple`2<int, string> delegatesNotAllowedToHaveCurriedSignatures();
    internal static Tuple`2<int, string> tlrUnexpectedTExpr();
    internal static Tuple`2<int, string> tlrLambdaLiftingOptimizationsNotApplied();
    internal static Tuple`2<int, string> lexhlpIdentifiersContainingAtSymbolReserved();
    internal static string lexhlpIdentifierReserved(string a0);
    internal static Tuple`2<int, string> patcMissingVariable(string a0);
    internal static Tuple`2<int, string> patcPartialActivePatternsGenerateOneResult();
    internal static Tuple`2<int, string> impTypeRequiredUnavailable(string a0, string a1);
    internal static Tuple`2<int, string> impReferencedTypeCouldNotBeFoundInAssembly(string a0, string a1);
    internal static Tuple`2<int, string> impNotEnoughTypeParamsInScopeWhileImporting();
    internal static Tuple`2<int, string> impReferenceToDllRequiredByAssembly(string a0, string a1, string a2);
    internal static Tuple`2<int, string> impImportedAssemblyUsesNotPublicType(string a0);
    internal static Tuple`2<int, string> optValueMarkedInlineButIncomplete(string a0);
    internal static Tuple`2<int, string> optValueMarkedInlineButWasNotBoundInTheOptEnv(string a0);
    internal static Tuple`2<int, string> optLocalValueNotFoundDuringOptimization(string a0);
    internal static Tuple`2<int, string> optValueMarkedInlineHasUnexpectedValue();
    internal static Tuple`2<int, string> optValueMarkedInlineCouldNotBeInlined();
    internal static Tuple`2<int, string> optFailedToInlineValue(string a0);
    internal static Tuple`2<int, string> optRecursiveValValue(string a0);
    internal static string lexfltIncorrentIndentationOfIn();
    internal static string lexfltTokenIsOffsideOfContextStartedEarlier(string a0);
    internal static string lexfltSeparatorTokensOfPatternMatchMisaligned();
    internal static Tuple`2<int, string> nrInvalidModuleExprType();
    internal static Tuple`2<int, string> nrTypeInstantiationNeededToDisambiguateTypesWithSameName(string a0, string a1);
    internal static Tuple`2<int, string> nrTypeInstantiationIsMissingAndCouldNotBeInferred(string a0, string a1);
    internal static Tuple`2<int, string> nrGlobalUsedOnlyAsFirstName();
    internal static Tuple`2<int, string> nrIsNotConstructorOrLiteral();
    internal static Tuple`2<int, string> nrUnexpectedEmptyLongId();
    internal static Tuple`2<int, string> nrRecordDoesNotContainSuchLabel(string a0, string a1);
    internal static Tuple`2<int, string> nrInvalidFieldLabel();
    internal static Tuple`2<int, string> nrInvalidExpression(string a0);
    internal static Tuple`2<int, string> nrNoConstructorsAvailableForType(string a0);
    internal static Tuple`2<int, string> nrUnionTypeNeedsQualifiedAccess(string a0, string a1);
    internal static Tuple`2<int, string> nrRecordTypeNeedsQualifiedAccess(string a0, string a1);
    internal static Tuple`2<int, string> ilwriteErrorCreatingPdb(string a0);
    internal static Tuple`2<int, string> lexOutsideIntegerRange();
    internal static string lexCharNotAllowedInOperatorNames(string a0);
    internal static string lexUnexpectedChar(string a0);
    internal static Tuple`2<int, string> lexByteArrayCannotEncode();
    internal static Tuple`2<int, string> lexIdentEndInMarkReserved(string a0);
    internal static Tuple`2<int, string> lexOutsideEightBitSigned();
    internal static Tuple`2<int, string> lexOutsideEightBitSignedHex();
    internal static Tuple`2<int, string> lexOutsideEightBitUnsigned();
    internal static Tuple`2<int, string> lexOutsideSixteenBitSigned();
    internal static Tuple`2<int, string> lexOutsideSixteenBitUnsigned();
    internal static Tuple`2<int, string> lexOutsideThirtyTwoBitSigned();
    internal static Tuple`2<int, string> lexOutsideThirtyTwoBitUnsigned();
    internal static Tuple`2<int, string> lexOutsideSixtyFourBitSigned();
    internal static Tuple`2<int, string> lexOutsideSixtyFourBitUnsigned();
    internal static Tuple`2<int, string> lexOutsideNativeSigned();
    internal static Tuple`2<int, string> lexOutsideNativeUnsigned();
    internal static Tuple`2<int, string> lexInvalidFloat();
    internal static Tuple`2<int, string> lexOusideDecimal();
    internal static Tuple`2<int, string> lexOusideThirtyTwoBitFloat();
    internal static Tuple`2<int, string> lexInvalidNumericLiteral();
    internal static Tuple`2<int, string> lexInvalidByteLiteral();
    internal static Tuple`2<int, string> lexInvalidCharLiteral();
    internal static Tuple`2<int, string> lexThisUnicodeOnlyInStringLiterals();
    internal static Tuple`2<int, string> lexTokenReserved();
    internal static Tuple`2<int, string> lexTabsNotAllowed();
    internal static Tuple`2<int, string> lexInvalidLineNumber(string a0);
    internal static Tuple`2<int, string> lexHashIfMustBeFirst();
    internal static string lexHashElseNoMatchingIf();
    internal static string lexHashEndifRequiredForElse();
    internal static Tuple`2<int, string> lexHashElseMustBeFirst();
    internal static string lexHashEndingNoMatchingIf();
    internal static Tuple`2<int, string> lexHashEndifMustBeFirst();
    internal static Tuple`2<int, string> lexHashIfMustHaveIdent();
    internal static Tuple`2<int, string> lexWrongNestedHashEndif();
    internal static string lexHashBangMustBeFirstInFile();
    internal static Tuple`2<int, string> pplexExpectedSingleLineComment();
    internal static Tuple`2<int, string> memberOperatorDefinitionWithNoArguments(string a0);
    internal static Tuple`2<int, string> memberOperatorDefinitionWithNonPairArgument(string a0, int a1);
    internal static Tuple`2<int, string> memberOperatorDefinitionWithCurriedArguments(string a0);
    internal static Tuple`2<int, string> tcFSharpCoreRequiresExplicit();
    internal static Tuple`2<int, string> tcStructuralComparisonNotSatisfied1(string a0, string a1);
    internal static Tuple`2<int, string> tcStructuralComparisonNotSatisfied2(string a0, string a1);
    internal static Tuple`2<int, string> tcNoComparisonNeeded1(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcNoComparisonNeeded2(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcNoEqualityNeeded1(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcNoEqualityNeeded2(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcStructuralEqualityNotSatisfied1(string a0, string a1);
    internal static Tuple`2<int, string> tcStructuralEqualityNotSatisfied2(string a0, string a1);
    internal static Tuple`2<int, string> tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly();
    internal static Tuple`2<int, string> chkUnusedValue(string a0);
    internal static Tuple`2<int, string> chkUnusedThisVariable(string a0);
    internal static Tuple`2<int, string> parsGetterAtMostOneArgument();
    internal static Tuple`2<int, string> parsSetterAtMostTwoArguments();
    internal static Tuple`2<int, string> parsInvalidProperty();
    internal static Tuple`2<int, string> parsIndexerPropertyRequiresAtLeastOneArgument();
    internal static Tuple`2<int, string> tastInvalidAddressOfMutableAcrossAssemblyBoundary();
    internal static Tuple`2<int, string> parsNonAdjacentTypars();
    internal static Tuple`2<int, string> parsNonAdjacentTyargs();
    internal static string parsNonAtomicType();
    internal static Tuple`2<int, string> tastUndefinedItemRefModuleNamespace(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tastUndefinedItemRefVal(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tastUndefinedItemRefModuleNamespaceType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcInvalidUseNullAsTrueValue();
    internal static Tuple`2<int, string> tcParameterInferredByref(string a0);
    internal static Tuple`2<int, string> tcNonUniformMemberUse(string a0);
    internal static Tuple`2<int, string> tcAttribArgsDiffer(string a0);
    internal static Tuple`2<int, string> tcCannotCallAbstractBaseMember(string a0);
    internal static Tuple`2<int, string> typrelCannotResolveAmbiguityInUnmanaged();
    internal static string mlCompatMessage(string a0);
    internal static string mlCompatError(string a0);
    internal static string mlCompatKeyword(string a0);
    internal static string mlCompatLightOffNoLongerSupported();
    internal static string mlCompatSigColonNoLongerSupported();
    internal static string mlCompatSigEndNoLongerSupported();
    internal static string mlCompatMultiPrefixTyparsNoLongerSupported();
    internal static string mlCompatStructEndNoLongerSupported();
    internal static Tuple`2<int, string> ilFieldDoesNotHaveValidOffsetForStructureLayout(string a0, string a1);
    internal static Tuple`2<int, string> tcInterfacesShouldUseInheritNotInterface();
    internal static Tuple`2<int, string> parsInvalidPrefixOperator();
    internal static Tuple`2<int, string> parsInvalidPrefixOperatorDefinition();
    internal static string buildCompilingExtensionIsForML();
    internal static string lexIndentOffForML();
    internal static string lexIfOCaml();
    internal static Tuple`2<int, string> activePatternIdentIsNotFunctionTyped(string a0);
    internal static Tuple`2<int, string> activePatternChoiceHasFreeTypars(string a0);
    internal static Tuple`2<int, string> ilFieldHasOffsetForSequentialLayout();
    internal static Tuple`2<int, string> tcOptionalArgsMustComeAfterNonOptionalArgs();
    internal static Tuple`2<int, string> tcConditionalAttributeUsage();
    internal static Tuple`2<int, string> tcMemberOperatorDefinitionInExtrinsic();
    internal static Tuple`2<int, string> tcUnionCaseNameConflictsWithGeneratedType(string a0, string a1);
    internal static Tuple`2<int, string> chkNoReflectedDefinitionOnStructMember();
    internal static Tuple`2<int, string> tcDllImportNotAllowed();
    internal static Tuple`2<int, string> buildExpectedSigdataFile(string a0);
    internal static Tuple`2<int, string> buildExpectedFileAlongSideFSharpCore(string a0, string a1);
    internal static Tuple`2<int, string> buildUnexpectedFileNameCharacter(string a0, string a1);
    internal static Tuple`2<int, string> tcInvalidUseBangBinding();
    internal static Tuple`2<int, string> crefNoInnerGenericsInQuotations();
    internal static Tuple`2<int, string> tcEnumTypeCannotBeEnumerated(string a0);
    internal static Tuple`2<int, string> parsEofInTripleQuoteString();
    internal static Tuple`2<int, string> parsEofInTripleQuoteStringInComment();
    internal static Tuple`2<int, string> tcTypeTestLosesMeasures(string a0);
    internal static Tuple`2<int, string> parsMissingTypeArgs();
    internal static Tuple`2<int, string> parsMissingGreaterThan();
    internal static Tuple`2<int, string> parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString();
    internal static Tuple`2<int, string> parsErrorParsingAsOperatorName();
    internal static Tuple`2<int, string> lexInvalidUnicodeLiteral(string a0);
    internal static Tuple`2<int, string> tcCallerInfoWrongType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcCallerInfoNotOptional(string a0);
    internal static Tuple`2<int, string> lexTooManyLBracesInTripleQuote();
    internal static Tuple`2<int, string> lexUnmatchedRBracesInTripleQuote();
    internal static Tuple`2<int, string> lexTooManyPercentsInTripleQuote();
    internal static Tuple`2<int, string> lexExtendedStringInterpolationNotSupported();
    internal static Tuple`2<int, string> toolLocationHelperUnsupportedFrameworkVersion(string a0);
    internal static Tuple`2<int, string> ilSignInvalidMagicValue();
    internal static Tuple`2<int, string> ilSignBadImageFormat();
    internal static Tuple`2<int, string> ilSignPrivateKeyExpected();
    internal static Tuple`2<int, string> ilSignRsaKeyExpected();
    internal static Tuple`2<int, string> ilSignInvalidBitLen();
    internal static Tuple`2<int, string> ilSignInvalidRSAParams();
    internal static Tuple`2<int, string> ilSignInvalidAlgId();
    internal static Tuple`2<int, string> ilSignInvalidSignatureSize();
    internal static Tuple`2<int, string> ilSignNoSignatureDirectory();
    internal static Tuple`2<int, string> ilSignInvalidPKBlob();
    internal static string fscTooManyErrors();
    internal static Tuple`2<int, string> docfileNoXmlSuffix();
    internal static Tuple`2<int, string> fscNoImplementationFiles();
    internal static Tuple`2<int, string> fscBadAssemblyVersion(string a0, string a1);
    internal static Tuple`2<int, string> fscTwoResourceManifests();
    internal static Tuple`2<int, string> fscQuotationLiteralsStaticLinking(string a0);
    internal static Tuple`2<int, string> fscQuotationLiteralsStaticLinking0();
    internal static Tuple`2<int, string> fscStaticLinkingNoEXE();
    internal static Tuple`2<int, string> fscStaticLinkingNoMixedDLL();
    internal static Tuple`2<int, string> fscIgnoringMixedWhenLinking(string a0);
    internal static Tuple`2<int, string> fscAssumeStaticLinkContainsNoDependencies(string a0);
    internal static Tuple`2<int, string> fscAssemblyNotFoundInDependencySet(string a0);
    internal static Tuple`2<int, string> fscKeyFileCouldNotBeOpened(string a0);
    internal static Tuple`2<int, string> fscProblemWritingBinary(string a0, string a1);
    internal static Tuple`2<int, string> fscAssemblyVersionAttributeIgnored();
    internal static Tuple`2<int, string> fscAssemblyCultureAttributeError();
    internal static Tuple`2<int, string> fscDelaySignWarning();
    internal static Tuple`2<int, string> fscKeyFileWarning();
    internal static Tuple`2<int, string> fscKeyNameWarning();
    internal static Tuple`2<int, string> fscReferenceOnCommandLine(string a0);
    internal static Tuple`2<int, string> fscRemotingError();
    internal static Tuple`2<int, string> pathIsInvalid(string a0);
    internal static Tuple`2<int, string> fscResxSourceFileDeprecated(string a0);
    internal static Tuple`2<int, string> fscStaticLinkingNoProfileMismatches();
    internal static Tuple`2<int, string> fscAssemblyWildcardAndDeterminism(string a0, string a1);
    internal static Tuple`2<int, string> optsInvalidPathMapFormat();
    internal static Tuple`2<int, string> optsInvalidRefOut();
    internal static Tuple`2<int, string> optsInvalidRefAssembly();
    internal static Tuple`2<int, string> etIllegalCharactersInNamespaceName(string a0, string a1);
    internal static Tuple`2<int, string> etNullOrEmptyMemberName(string a0);
    internal static Tuple`2<int, string> etNullMember(string a0);
    internal static Tuple`2<int, string> etNullMemberDeclaringType(string a0, string a1);
    internal static Tuple`2<int, string> etNullMemberDeclaringTypeDifferentFromProvidedType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> etHostingAssemblyFoundWithoutHosts(string a0, string a1);
    internal static Tuple`2<int, string> etEmptyNamespaceOfTypeNotAllowed(string a0, string a1);
    internal static Tuple`2<int, string> etEmptyNamespaceNotAllowed(string a0);
    internal static Tuple`2<int, string> etMustNotBeGeneric(string a0);
    internal static Tuple`2<int, string> etMustNotBeAnArray(string a0);
    internal static Tuple`2<int, string> etMethodHasRequirements(string a0, string a1);
    internal static Tuple`2<int, string> etUnsupportedMemberKind(string a0, string a1);
    internal static Tuple`2<int, string> etPropertyCanReadButHasNoGetter(string a0, string a1);
    internal static Tuple`2<int, string> etPropertyHasGetterButNoCanRead(string a0, string a1);
    internal static Tuple`2<int, string> etPropertyCanWriteButHasNoSetter(string a0, string a1);
    internal static Tuple`2<int, string> etPropertyHasSetterButNoCanWrite(string a0, string a1);
    internal static Tuple`2<int, string> etOneOrMoreErrorsSeenDuringExtensionTypeSetting();
    internal static Tuple`2<int, string> etUnexpectedExceptionFromProvidedTypeMember(string a0, string a1, string a2);
    internal static Tuple`2<int, string> etUnsupportedConstantType(string a0);
    internal static Tuple`2<int, string> etUnsupportedProvidedExpression(string a0);
    internal static Tuple`2<int, string> etProvidedTypeHasUnexpectedName(string a0, string a1);
    internal static Tuple`2<int, string> etEventNoAdd(string a0, string a1);
    internal static Tuple`2<int, string> etEventNoRemove(string a0, string a1);
    internal static Tuple`2<int, string> etProviderHasWrongDesignerAssemblyNoPath(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> etProviderHasWrongDesignerAssembly(string a0, string a1, string a2, string a3, string a4);
    internal static Tuple`2<int, string> etProviderDoesNotHaveValidConstructor();
    internal static Tuple`2<int, string> etProviderError(string a0, string a1);
    internal static Tuple`2<int, string> etIncorrectParameterExpression(string a0, string a1);
    internal static Tuple`2<int, string> etIncorrectProvidedMethod(string a0, string a1, int a2, string a3);
    internal static Tuple`2<int, string> etIncorrectProvidedConstructor(string a0, string a1);
    internal static Tuple`2<int, string> etDirectReferenceToGeneratedTypeNotAllowed(string a0);
    internal static Tuple`2<int, string> etProvidedTypeHasUnexpectedPath(string a0, string a1);
    internal static Tuple`2<int, string> etUnexpectedNullFromProvidedTypeMember(string a0, string a1);
    internal static Tuple`2<int, string> etUnexpectedExceptionFromProvidedMemberMember(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters();
    internal static Tuple`2<int, string> etInvalidStaticArgument(string a0);
    internal static Tuple`2<int, string> etErrorApplyingStaticArgumentsToType();
    internal static Tuple`2<int, string> etUnknownStaticArgumentKind(string a0, string a1);
    internal static Tuple`2<int, string> etProviderHasDesignerAssemblyDependency(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> etProviderHasDesignerAssemblyException(string a0, string a1, string a2, string a3);
    internal static string invalidNamespaceForProvidedType();
    internal static string invalidFullNameForProvidedType();
    internal static Tuple`2<int, string> etProviderReturnedNull(string a0);
    internal static Tuple`2<int, string> etTypeProviderConstructorException(string a0);
    internal static Tuple`2<int, string> etNullProvidedExpression(string a0);
    internal static Tuple`2<int, string> etProvidedAppliedTypeHadWrongName(string a0, string a1, string a2);
    internal static Tuple`2<int, string> etProvidedAppliedMethodHadWrongName(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcTypeTestLossy(string a0, string a1);
    internal static Tuple`2<int, string> tcTypeCastErased(string a0, string a1);
    internal static Tuple`2<int, string> tcTypeTestErased(string a0, string a1);
    internal static Tuple`2<int, string> tcCannotInheritFromErasedType();
    internal static Tuple`2<int, string> etInvalidTypeProviderAssemblyName(string a0, string a1);
    internal static Tuple`2<int, string> tcInvalidMemberNameCtor();
    internal static Tuple`2<int, string> tcInferredGenericTypeGivesRiseToInconsistency(string a0, string a1);
    internal static Tuple`2<int, string> tcInvalidTypeArgumentCount(int a0, int a1);
    internal static Tuple`2<int, string> tcCannotOverrideSealedMethod(string a0);
    internal static Tuple`2<int, string> etProviderErrorWithContext(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> etProvidedTypeWithNameException(string a0, string a1);
    internal static Tuple`2<int, string> etProvidedTypeWithNullOrEmptyName(string a0);
    internal static Tuple`2<int, string> etIllegalCharactersInTypeName(string a0, string a1);
    internal static Tuple`2<int, string> tcJoinMustUseSimplePattern(string a0);
    internal static Tuple`2<int, string> tcMissingCustomOperation(string a0);
    internal static Tuple`2<int, string> etBadUnnamedStaticArgs();
    internal static Tuple`2<int, string> etStaticParameterRequiresAValue(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> etNoStaticParameterWithName(string a0);
    internal static Tuple`2<int, string> etStaticParameterAlreadyHasValue(string a0);
    internal static Tuple`2<int, string> etMultipleStaticParameterWithName(string a0);
    internal static Tuple`2<int, string> tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings();
    internal static Tuple`2<int, string> tcCustomOperationMayNotBeUsedHere();
    internal static Tuple`2<int, string> tcCustomOperationMayNotBeOverloaded(string a0);
    internal static string featureOverloadsForCustomOperations();
    internal static string featureExpandedMeasurables();
    internal static string featurePrintfBinaryFormat();
    internal static string featureIndexerNotationWithoutDot();
    internal static string featureRefCellNotationInformationals();
    internal static string featureDiscardUseValue();
    internal static string featureNonVariablePatternsToRightOfAsPatterns();
    internal static string featureAttributesToRightOfModuleKeyword();
    internal static string featureMLCompatRevisions();
    internal static string featureBetterExceptionPrinting();
    internal static string featureDelegateTypeNameResolutionFix();
    internal static Tuple`2<int, string> tcIfThenElseMayNotBeUsedWithinQueries();
    internal static Tuple`2<int, string> ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen();
    internal static Tuple`2<int, string> etProvidedTypeReferenceMissingArgument(string a0);
    internal static Tuple`2<int, string> etProvidedTypeReferenceInvalidText(string a0);
    internal static Tuple`2<int, string> tcCustomOperationNotUsedCorrectly(string a0);
    internal static Tuple`2<int, string> tcCustomOperationNotUsedCorrectly2(string a0, string a1);
    internal static string customOperationTextLikeJoin(string a0, string a1, string a2);
    internal static string customOperationTextLikeGroupJoin(string a0, string a1, string a2);
    internal static string customOperationTextLikeZip(string a0);
    internal static Tuple`2<int, string> tcBinaryOperatorRequiresVariable(string a0, string a1);
    internal static Tuple`2<int, string> tcOperatorIncorrectSyntax(string a0, string a1);
    internal static Tuple`2<int, string> tcBinaryOperatorRequiresBody(string a0, string a1);
    internal static Tuple`2<int, string> tcCustomOperationHasIncorrectArgCount(string a0, int a1, int a2);
    internal static Tuple`2<int, string> parsExpectedExpressionAfterToken();
    internal static Tuple`2<int, string> parsExpectedTypeAfterToken();
    internal static Tuple`2<int, string> parsUnmatchedLBrackLess();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileMatch();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileTry();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileWhile();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileFor();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileWith();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileThen();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileElse();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileFunBody();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileTypeArgs();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileTypeSignature();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileTypeDefinition();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileObjectMembers();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileDefinition();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileExpression();
    internal static Tuple`2<int, string> parsExpectedNameAfterToken();
    internal static Tuple`2<int, string> parsUnmatchedLet();
    internal static Tuple`2<int, string> parsUnmatchedLetBang();
    internal static Tuple`2<int, string> parsUnmatchedUseBang();
    internal static Tuple`2<int, string> parsUnmatchedUse();
    internal static Tuple`2<int, string> parsWhileDoExpected();
    internal static Tuple`2<int, string> parsForDoExpected();
    internal static Tuple`2<int, string> tcInvalidRelationInJoin(string a0);
    internal static string typeInfoCallsWord();
    internal static Tuple`2<int, string> impInvalidNumberOfGenericArguments(string a0, int a1, int a2);
    internal static Tuple`2<int, string> impInvalidMeasureArgument1(string a0, string a1);
    internal static Tuple`2<int, string> impInvalidMeasureArgument2(string a0);
    internal static Tuple`2<int, string> etPropertyNeedsCanWriteOrCanRead(string a0, string a1);
    internal static Tuple`2<int, string> tcIntoNeedsRestOfQuery();
    internal static Tuple`2<int, string> tcOperatorDoesntAcceptInto(string a0);
    internal static Tuple`2<int, string> tcCustomOperationInvalid(string a0);
    internal static Tuple`2<int, string> tcThisTypeMayNotHaveACLIMutableAttribute();
    internal static Tuple`2<int, string> tcAutoPropertyRequiresImplicitConstructionSequence();
    internal static Tuple`2<int, string> parsMutableOnAutoPropertyShouldBeGetSet();
    internal static Tuple`2<int, string> parsMutableOnAutoPropertyShouldBeGetSetNotJustSet();
    internal static Tuple`2<int, string> chkNoByrefsOfByrefs(string a0);
    internal static Tuple`2<int, string> tastopsMaxArrayThirtyTwo(int a0);
    internal static Tuple`2<int, string> tcNoIntegerForLoopInQuery();
    internal static Tuple`2<int, string> tcNoWhileInQuery();
    internal static Tuple`2<int, string> tcNoTryFinallyInQuery();
    internal static Tuple`2<int, string> tcUseMayNotBeUsedInQueries();
    internal static Tuple`2<int, string> tcBindMayNotBeUsedInQueries();
    internal static Tuple`2<int, string> tcReturnMayNotBeUsedInQueries();
    internal static Tuple`2<int, string> tcUnrecognizedQueryOperator();
    internal static Tuple`2<int, string> tcTryWithMayNotBeUsedInQueries();
    internal static Tuple`2<int, string> tcNonSimpleLetBindingInQuery();
    internal static Tuple`2<int, string> etTooManyStaticParameters(int a0, int a1, int a2);
    internal static Tuple`2<int, string> infosInvalidProvidedLiteralValue(string a0);
    internal static Tuple`2<int, string> invalidPlatformTarget();
    internal static Tuple`2<int, string> tcThisValueMayNotBeInlined();
    internal static Tuple`2<int, string> etErasedTypeUsedInGeneration(string a0, string a1);
    internal static Tuple`2<int, string> tcUnrecognizedQueryBinaryOperator();
    internal static Tuple`2<int, string> crefNoSetOfHole();
    internal static string nicePrintOtherOverloads1();
    internal static string nicePrintOtherOverloadsN(int a0);
    internal static string erasedTo();
    internal static Tuple`2<int, string> parsUnfinishedExpression(string a0);
    internal static Tuple`2<int, string> parsAttributeOnIncompleteCode();
    internal static Tuple`2<int, string> parsTypeNameCannotBeEmpty();
    internal static Tuple`2<int, string> buildProblemReadingAssembly(string a0, string a1);
    internal static Tuple`2<int, string> tcTPFieldMustBeLiteral();
    internal static string loadingDescription();
    internal static string descriptionUnavailable();
    internal static Tuple`2<int, string> chkTyparMultipleClassConstraints();
    internal static Tuple`2<int, string> tcMatchMayNotBeUsedWithQuery();
    internal static Tuple`2<int, string> memberOperatorDefinitionWithNonTripleArgument(string a0, int a1);
    internal static Tuple`2<int, string> cannotResolveNullableOperators(string a0);
    internal static Tuple`2<int, string> tcOperatorRequiresIn(string a0, string a1);
    internal static Tuple`2<int, string> parsIllegalMemberVarInObjectImplementation();
    internal static Tuple`2<int, string> tcEmptyCopyAndUpdateRecordInvalid();
    internal static Tuple`2<int, string> parsUnderscoreInvalidFieldName();
    internal static Tuple`2<int, string> tcGeneratedTypesShouldBeInternalOrPrivate();
    internal static Tuple`2<int, string> chkGetterAndSetterHaveSamePropertyType(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcRuntimeSuppliedMethodCannotBeUsedInUserCode(string a0);
    internal static Tuple`2<int, string> tcUnionCaseConstructorDoesNotHaveFieldWithGivenName(string a0, string a1);
    internal static Tuple`2<int, string> tcExceptionConstructorDoesNotHaveFieldWithGivenName(string a0, string a1);
    internal static Tuple`2<int, string> tcActivePatternsDoNotHaveFields();
    internal static Tuple`2<int, string> tcConstructorDoesNotHaveFieldWithGivenName(string a0);
    internal static Tuple`2<int, string> tcUnionCaseFieldCannotBeUsedMoreThanOnce(string a0);
    internal static Tuple`2<int, string> tcFieldNameIsUsedModeThanOnce(string a0);
    internal static Tuple`2<int, string> tcFieldNameConflictsWithGeneratedNameForAnonymousField(string a0);
    internal static Tuple`2<int, string> tastConstantExpressionOverflow();
    internal static Tuple`2<int, string> tcIllegalStructTypeForConstantExpression();
    internal static Tuple`2<int, string> fscSystemRuntimeInteropServicesIsRequired();
    internal static Tuple`2<int, string> abImplicitHeapAllocation(string a0);
    internal static string estApplyStaticArgumentsForMethodNotImplemented();
    internal static Tuple`2<int, string> etErrorApplyingStaticArgumentsToMethod();
    internal static Tuple`2<int, string> pplexUnexpectedChar(string a0);
    internal static Tuple`2<int, string> ppparsUnexpectedToken(string a0);
    internal static Tuple`2<int, string> ppparsIncompleteExpression();
    internal static Tuple`2<int, string> ppparsMissingToken(string a0);
    internal static Tuple`2<int, string> pickleMissingDefinition(int a0, string a1, string a2);
    internal static Tuple`2<int, string> checkNotSufficientlyGenericBecauseOfScope(string a0);
    internal static Tuple`2<int, string> checkNotSufficientlyGenericBecauseOfScopeAnon();
    internal static Tuple`2<int, string> checkRaiseFamilyFunctionArgumentCount(string a0, int a1, int a2);
    internal static Tuple`2<int, string> checkLowercaseLiteralBindingInPattern(string a0);
    internal static Tuple`2<int, string> tcLiteralDoesNotTakeArguments();
    internal static Tuple`2<int, string> tcConstructorsIllegalInAugmentation();
    internal static Tuple`2<int, string> optsInvalidResponseFile(string a0, string a1);
    internal static Tuple`2<int, string> optsResponseFileNotFound(string a0, string a1);
    internal static Tuple`2<int, string> optsResponseFileNameInvalid(string a0);
    internal static Tuple`2<int, string> fsharpCoreNotFoundToBeCopied();
    internal static string tcTupleStructMismatch();
    internal static Tuple`2<int, string> etMissingStaticArgumentsToMethod();
    internal static Tuple`2<int, string> considerUpcast(string a0, string a1);
    internal static Tuple`2<int, string> considerUpcastOperator(string a0, string a1);
    internal static Tuple`2<int, string> tcRecImplied();
    internal static Tuple`2<int, string> tcOpenFirstInMutRec();
    internal static Tuple`2<int, string> tcModuleAbbrevFirstInMutRec();
    internal static Tuple`2<int, string> tcUnsupportedMutRecDecl();
    internal static Tuple`2<int, string> parsInvalidUseOfRec();
    internal static Tuple`2<int, string> tcStructUnionMultiCaseDistinctFields();
    internal static Tuple`2<int, string> CallerMemberNameIsOverriden(string a0);
    internal static Tuple`2<int, string> tcFixedNotAllowed();
    internal static Tuple`2<int, string> tcCouldNotFindOffsetToStringData();
    internal static Tuple`2<int, string> chkNoByrefAddressOfLocal(string a0);
    internal static Tuple`2<int, string> tcNamedActivePattern(string a0);
    internal static Tuple`2<int, string> DefaultParameterValueNotAppropriateForArgument();
    internal static string tcGlobalsSystemTypeNotFound(string a0);
    internal static Tuple`2<int, string> typrelMemberHasMultiplePossibleDispatchSlots(string a0, string a1);
    internal static Tuple`2<int, string> methodIsNotStatic(string a0);
    internal static Tuple`2<int, string> parsUnexpectedSymbolEqualsInsteadOfIn();
    internal static string tcAnonRecdInvalid();
    internal static string tcAnonRecdCcuMismatch(string a0, string a1);
    internal static string tcAnonRecdFieldNameMismatch(string a0, string a1);
    internal static string tcAnonRecdSingleFieldNameSubset(string a0);
    internal static string tcAnonRecdMultipleFieldsNameSubset(string a0);
    internal static string tcAnonRecdSingleFieldNameSuperset(string a0);
    internal static string tcAnonRecdMultipleFieldsNameSuperset(string a0);
    internal static string tcAnonRecdSingleFieldNameSingleDifferent(string a0, string a1);
    internal static string tcAnonRecdSingleFieldNameMultipleDifferent(string a0, string a1);
    internal static string tcAnonRecdMultipleFieldNameSingleDifferent(string a0, string a1);
    internal static string tcAnonRecdMultipleFieldNameMultipleDifferent(string a0, string a1);
    internal static string keywordDescriptionAbstract();
    internal static string keywordDescriptionAnd();
    internal static string keywordDescriptionAs();
    internal static string keywordDescriptionAssert();
    internal static string keywordDescriptionBase();
    internal static string keywordDescriptionBegin();
    internal static string keywordDescriptionClass();
    internal static string keywordDescriptionConst();
    internal static string keywordDescriptionDefault();
    internal static string keywordDescriptionDelegate();
    internal static string keywordDescriptionDo();
    internal static string keywordDescriptionDone();
    internal static string keywordDescriptionDowncast();
    internal static string keywordDescriptionDownto();
    internal static string keywordDescriptionElif();
    internal static string keywordDescriptionElse();
    internal static string keywordDescriptionEnd();
    internal static string keywordDescriptionException();
    internal static string keywordDescriptionExtern();
    internal static string keywordDescriptionTrueFalse();
    internal static string keywordDescriptionFinally();
    internal static string keywordDescriptionFor();
    internal static string keywordDescriptionFun();
    internal static string keywordDescriptionFunction();
    internal static string keywordDescriptionGlobal();
    internal static string keywordDescriptionIf();
    internal static string keywordDescriptionIn();
    internal static string keywordDescriptionInherit();
    internal static string keywordDescriptionInline();
    internal static string keywordDescriptionInterface();
    internal static string keywordDescriptionInternal();
    internal static string keywordDescriptionLazy();
    internal static string keywordDescriptionLet();
    internal static string keywordDescriptionLetBang();
    internal static string keywordDescriptionMatch();
    internal static string keywordDescriptionMatchBang();
    internal static string keywordDescriptionMember();
    internal static string keywordDescriptionModule();
    internal static string keywordDescriptionMutable();
    internal static string keywordDescriptionNamespace();
    internal static string keywordDescriptionNew();
    internal static string keywordDescriptionNot();
    internal static string keywordDescriptionNull();
    internal static string keywordDescriptionOf();
    internal static string keywordDescriptionOpen();
    internal static string keywordDescriptionOr();
    internal static string keywordDescriptionOverride();
    internal static string keywordDescriptionPrivate();
    internal static string keywordDescriptionPublic();
    internal static string keywordDescriptionRec();
    internal static string keywordDescriptionReturn();
    internal static string keywordDescriptionReturnBang();
    internal static string keywordDescriptionSelect();
    internal static string keywordDescriptionSig();
    internal static string keywordDescriptionStatic();
    internal static string keywordDescriptionStruct();
    internal static string keywordDescriptionThen();
    internal static string keywordDescriptionTo();
    internal static string keywordDescriptionTry();
    internal static string keywordDescriptionType();
    internal static string keywordDescriptionTypeTest();
    internal static string keywordDescriptionUpcast();
    internal static string keywordDescriptionUse();
    internal static string keywordDescriptionUseBang();
    internal static string keywordDescriptionVal();
    internal static string keywordDescriptionVoid();
    internal static string keywordDescriptionWhen();
    internal static string keywordDescriptionWhile();
    internal static string keywordDescriptionWhileBang();
    internal static string keywordDescriptionWith();
    internal static string keywordDescriptionYield();
    internal static string keywordDescriptionYieldBang();
    internal static string keywordDescriptionRightArrow();
    internal static string keywordDescriptionLeftArrow();
    internal static string keywordDescriptionCast();
    internal static string keywordDescriptionDynamicCast();
    internal static string keywordDescriptionTypedQuotation();
    internal static string keywordDescriptionUntypedQuotation();
    internal static Tuple`2<int, string> itemNotFoundDuringDynamicCodeGen(string a0, string a1, string a2);
    internal static Tuple`2<int, string> itemNotFoundInTypeDuringDynamicCodeGen(string a0, string a1, string a2, string a3);
    internal static string descriptionWordIs();
    internal static string notAFunction();
    internal static string notAFunctionButMaybeIndexerWithName(string a0);
    internal static string notAFunctionButMaybeIndexer();
    internal static string notAFunctionButMaybeIndexerWithName2(string a0);
    internal static string notAFunctionButMaybeIndexer2();
    internal static Tuple`2<int, string> notAFunctionButMaybeIndexerErrorCode();
    internal static string notAFunctionButMaybeDeclaration();
    internal static Tuple`2<int, string> pickleUnexpectedNonZero(string a0);
    internal static Tuple`2<int, string> tcTupleMemberNotNormallyUsed();
    internal static Tuple`2<int, string> implicitlyDiscardedInSequenceExpression(string a0);
    internal static Tuple`2<int, string> implicitlyDiscardedSequenceInSequenceExpression(string a0);
    internal static Tuple`2<int, string> ilreadFileChanged(string a0);
    internal static Tuple`2<int, string> writeToReadOnlyByref();
    internal static Tuple`2<int, string> readOnlyAttributeOnStructWithMutableField();
    internal static Tuple`2<int, string> tcByrefReturnImplicitlyDereferenced();
    internal static Tuple`2<int, string> tcByRefLikeNotStruct();
    internal static Tuple`2<int, string> chkNoByrefAddressOfValueFromExpression();
    internal static Tuple`2<int, string> chkNoWriteToLimitedSpan(string a0);
    internal static Tuple`2<int, string> tastValueMustBeLocal();
    internal static Tuple`2<int, string> tcIsReadOnlyNotStruct();
    internal static Tuple`2<int, string> chkStructsMayNotReturnAddressesOfContents();
    internal static Tuple`2<int, string> chkNoByrefLikeFunctionCall();
    internal static Tuple`2<int, string> chkNoSpanLikeVariable(string a0);
    internal static Tuple`2<int, string> chkNoSpanLikeValueFromExpression();
    internal static Tuple`2<int, string> tastCantTakeAddressOfExpression();
    internal static Tuple`2<int, string> tcCannotCallExtensionMethodInrefToByref(string a0);
    internal static Tuple`2<int, string> tcByrefsMayNotHaveTypeExtensions();
    internal static Tuple`2<int, string> tcCannotPartiallyApplyExtensionMethodForByref(string a0);
    internal static Tuple`2<int, string> tcTypeDoesNotInheritAttribute();
    internal static Tuple`2<int, string> parsInvalidAnonRecdExpr();
    internal static Tuple`2<int, string> parsInvalidAnonRecdType();
    internal static Tuple`2<int, string> tcCopyAndUpdateNeedsRecordType();
    internal static Tuple`2<int, string> tcAugmentationsCannotHaveAttributes();
    internal static Tuple`2<int, string> couldNotLoadDependencyManagerExtension(string a0, string a1);
    internal static Tuple`2<int, string> expressionHasNoName();
    internal static Tuple`2<int, string> chkNoFirstClassNameOf();
    internal static Tuple`2<int, string> tcIllegalByrefsInOpenTypeDeclaration();
    internal static Tuple`2<int, string> chkInvalidFunctionParameterType(string a0, string a1);
    internal static Tuple`2<int, string> chkInvalidFunctionReturnType(string a0);
    internal static Tuple`2<int, string> packageManagementRequiresVFive();
    internal static Tuple`2<int, string> fromEndSlicingRequiresVFive();
    internal static Tuple`2<int, string> poundiNotSupportedByRegisteredDependencyManagers();
    internal static Tuple`2<int, string> tcRequireMergeSourcesOrBindN(string a0);
    internal static Tuple`2<int, string> tcAndBangNotSupported();
    internal static Tuple`2<int, string> tcInvalidUseBangBindingNoAndBangs();
    internal static Tuple`2<int, string> chkFeatureNotSupportedInLibrary(string a0, string a1);
    internal static Tuple`2<int, string> chkFeatureNotLanguageSupported(string a0, string a1, string a2);
    internal static Tuple`2<int, string> chkFeatureNotRuntimeSupported(string a0);
    internal static Tuple`2<int, string> typrelInterfaceMemberNoMostSpecificImplementation(string a0);
    internal static Tuple`2<int, string> fsiInvalidDirective(string a0, string a1);
    internal static string useSdkRefs();
    internal static string optsGetLangVersions();
    internal static string optsSetLangVersion();
    internal static string optsSupportedLangVersions();
    internal static string optsStrictIndentation();
    internal static string nativeResourceFormatError();
    internal static string nativeResourceHeaderMalformed(string a0);
    internal static string formatDashItem(string a0);
    internal static string featureSingleUnderscorePattern();
    internal static string featureWildCardInForLoop();
    internal static string featureRelaxWhitespace();
    internal static string featureNameOf();
    internal static string featureImplicitYield();
    internal static string featureOpenTypeDeclaration();
    internal static string featureDotlessFloat32Literal();
    internal static string featurePackageManagement();
    internal static string featureFromEndSlicing();
    internal static string featureFixedIndexSlice3d4d();
    internal static string featureAndBang();
    internal static string featureResumableStateMachines();
    internal static string featureNullableOptionalInterop();
    internal static string featureDefaultInterfaceMemberConsumption();
    internal static string featureStringInterpolation();
    internal static string featureWitnessPassing();
    internal static string featureAdditionalImplicitConversions();
    internal static string featureStructActivePattern();
    internal static string featureRelaxWhitespace2();
    internal static string featureReallyLongList();
    internal static string featureErrorOnDeprecatedRequireQualifiedAccess();
    internal static string featureInterfacesWithAbstractStaticMembers();
    internal static string featureSelfTypeConstraints();
    internal static string featureRequiredProperties();
    internal static string featureInitProperties();
    internal static string featureLowercaseDUWhenRequireQualifiedAccess();
    internal static string featureMatchNotAllowedForUnionCaseWithNoData();
    internal static string featureCSharpExtensionAttributeNotRequired();
    internal static string featureErrorForNonVirtualMembersOverrides();
    internal static string featureWarningWhenInliningMethodImplNoInlineMarkedFunction();
    internal static string featureArithmeticInLiterals();
    internal static string featureErrorReportingOnStaticClasses();
    internal static string featureTryWithInSeqExpressions();
    internal static string featureWarningWhenCopyAndUpdateRecordChangesAllFields();
    internal static string featureStaticMembersInInterfaces();
    internal static string featureNonInlineLiteralsAsPrintfFormat();
    internal static string featureNestedCopyAndUpdate();
    internal static string featureExtendedStringInterpolation();
    internal static string featureWarningWhenMultipleRecdTypeChoice();
    internal static string featureImprovedImpliedArgumentNames();
    internal static string featureStrictIndentation();
    internal static string featureConstraintIntersectionOnFlexibleTypes();
    internal static string featureChkNotTailRecursive();
    internal static string featureWhileBang();
    internal static string featureExtendedFixedBindings();
    internal static string featurePreferStringGetPinnableReference();
    internal static Tuple`2<int, string> tcNotAFunctionButIndexerNamedIndexingNotYetEnabled(string a0, string a1);
    internal static Tuple`2<int, string> tcNotAFunctionButIndexerIndexingNotYetEnabled();
    internal static Tuple`2<int, string> tcNotAnIndexerNamedIndexingNotYetEnabled(string a0);
    internal static Tuple`2<int, string> tcNotAnIndexerIndexingNotYetEnabled();
    internal static Tuple`2<int, string> typrelInterfaceWithConcreteAndVariable(string a0, string a1, string a2, string a3);
    internal static Tuple`2<int, string> typrelInterfaceWithConcreteAndVariableObjectExpression(string a0, string a1, string a2);
    internal static string featureInterfacesWithMultipleGenericInstantiation();
    internal static Tuple`2<int, string> tcLiteralFieldAssignmentWithArg(string a0);
    internal static Tuple`2<int, string> tcLiteralFieldAssignmentNoArg();
    internal static Tuple`2<int, string> tcInvalidUseOfReverseIndex();
    internal static Tuple`2<int, string> tcHighPrecedenceFunctionApplicationToListDeprecated();
    internal static Tuple`2<int, string> tcIndexNotationDeprecated();
    internal static Tuple`2<int, string> tcHighPrecedenceFunctionApplicationToListReserved();
    internal static Tuple`2<int, string> tcParenThenAdjacentListArgumentReserved();
    internal static Tuple`2<int, string> tcListThenAdjacentListArgumentReserved();
    internal static Tuple`2<int, string> tcOtherThenAdjacentListArgumentReserved();
    internal static Tuple`2<int, string> tcParenThenAdjacentListArgumentNeedsAdjustment();
    internal static Tuple`2<int, string> tcListThenAdjacentListArgumentNeedsAdjustment();
    internal static Tuple`2<int, string> tcOtherThenAdjacentListArgumentNeedsAdjustment();
    internal static Tuple`2<int, string> chkInfoRefcellDeref();
    internal static Tuple`2<int, string> chkInfoRefcellAssign();
    internal static Tuple`2<int, string> chkInfoRefcellIncr();
    internal static Tuple`2<int, string> chkInfoRefcellDecr();
    internal static string forFormatInvalidForInterpolated();
    internal static string forFormatInvalidForInterpolated2();
    internal static string forFormatInvalidForInterpolated3();
    internal static string forFormatInvalidForInterpolated4();
    internal static Tuple`2<int, string> tcInterpolationMixedWithPercent();
    internal static Tuple`2<int, string> tcInvalidAlignmentInInterpolatedString();
    internal static Tuple`2<int, string> lexSingleQuoteInSingleQuote();
    internal static Tuple`2<int, string> lexTripleQuoteInTripleQuote();
    internal static Tuple`2<int, string> tcUnableToParseInterpolatedString(string a0);
    internal static Tuple`2<int, string> lexByteStringMayNotBeInterpolated();
    internal static Tuple`2<int, string> parsEofInInterpolatedStringFill();
    internal static Tuple`2<int, string> parsEofInInterpolatedString();
    internal static Tuple`2<int, string> parsEofInInterpolatedVerbatimString();
    internal static Tuple`2<int, string> parsEofInInterpolatedTripleQuoteString();
    internal static Tuple`2<int, string> parsEmptyFillInInterpolatedString();
    internal static Tuple`2<int, string> lexRBraceInInterpolatedString();
    internal static Tuple`2<int, string> scriptSdkNotDetermined(string a0, string a1, string a2, int a3);
    internal static Tuple`2<int, string> scriptSdkNotDeterminedUnexpected(string a0);
    internal static Tuple`2<int, string> scriptSdkNotDeterminedNoHost();
    internal static Tuple`2<int, string> tcInvalidStructReturn();
    internal static Tuple`2<int, string> tcAmbiguousImplicitConversion(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcSubsumptionImplicitConversionUsed(string a0, string a1);
    internal static Tuple`2<int, string> tcBuiltInImplicitConversionUsed(string a0, string a1);
    internal static Tuple`2<int, string> xmlDocBadlyFormed(string a0);
    internal static Tuple`2<int, string> xmlDocMissingParameterName();
    internal static Tuple`2<int, string> xmlDocMissingCrossReference();
    internal static Tuple`2<int, string> xmlDocInvalidParameterName(string a0);
    internal static Tuple`2<int, string> xmlDocDuplicateParameter(string a0);
    internal static Tuple`2<int, string> xmlDocUnresolvedCrossReference(string a0);
    internal static Tuple`2<int, string> xmlDocMissingParameter(string a0);
    internal static Tuple`2<int, string> tcImplicitConversionUsedForNonMethodArg(string a0, string a1, string a2);
    internal static Tuple`2<int, string> containerDeprecated();
    internal static Tuple`2<int, string> containerSigningUnsupportedOnThisPlatform();
    internal static Tuple`2<int, string> parsNewExprMemberAccess();
    internal static Tuple`2<int, string> tcImplicitConversionUsedForMethodArg(string a0, string a1, string a2);
    internal static Tuple`2<int, string> tcLiteralAttributeCannotUseActivePattern();
    internal static Tuple`2<int, string> ilxgenInvalidConstructInStateMachineDuringCodegen(string a0);
    internal static Tuple`2<int, string> tcInvalidResumableConstruct(string a0);
    internal static Tuple`2<int, string> tcResumableCodeFunctionMustBeInline();
    internal static Tuple`2<int, string> tcResumableCodeArgMustHaveRightName();
    internal static Tuple`2<int, string> tcResumableCodeArgMustHaveRightKind();
    internal static Tuple`2<int, string> tcResumableCodeContainsLetRec();
    internal static Tuple`2<int, string> tcResumableCodeNotSupported();
    internal static Tuple`2<int, string> tcNoEagerConstraintApplicationAttribute();
    internal static Tuple`2<int, string> reprStateMachineNotCompilable(string a0);
    internal static Tuple`2<int, string> reprStateMachineNotCompilableNoAlternative(string a0);
    internal static Tuple`2<int, string> tcResumableCodeInvocation();
    internal static Tuple`2<int, string> ilxGenUnknownDebugPoint(string a0, string a1);
    internal static string reprResumableCodeInvokeNotReduced(string a0);
    internal static string reprResumableCodeContainsLetRec();
    internal static string reprResumableCodeContainsConstrainedGenericLet();
    internal static string reprResumableCodeContainsDynamicResumeAtInBody();
    internal static string reprResumableCodeContainsResumptionInTryFinally();
    internal static string reprResumableCodeContainsResumptionInHandlerOrFilter();
    internal static string reprResumableCodeContainsFastIntegerForLoop();
    internal static string reprResumableCodeValueHasNoDefinition(string a0);
    internal static string reprResumableCodeDefinitionWasGeneric();
    internal static string reprStateMachineInvalidForm();
    internal static Tuple`2<int, string> optFailedToInlineSuggestedValue(string a0);
    internal static Tuple`2<int, string> implMissingInlineIfLambda();
    internal static Tuple`2<int, string> tcInlineIfLambdaUsedOnNonInlineFunctionOrMethod();
    internal static Tuple`2<int, string> invalidXmlDocPosition();
    internal static Tuple`2<int, string> tcInvalidMemberDeclNameMissingOrHasParen();
    internal static Tuple`2<int, string> tcAnonRecdDuplicateFieldId(string a0);
    internal static Tuple`2<int, string> tcAnonRecdTypeDuplicateFieldId(string a0);
    internal static Tuple`2<int, string> parsExpectingExpression();
    internal static Tuple`2<int, string> tcTraitIsStatic(string a0);
    internal static Tuple`2<int, string> tcTraitIsNotStatic(string a0);
    internal static Tuple`2<int, string> tcTraitMayNotUseComplexThings();
    internal static Tuple`2<int, string> tcInvalidSelfConstraint();
    internal static Tuple`2<int, string> tcTraitInvocationShouldUseTick();
    internal static Tuple`2<int, string> tcUsingInterfacesWithStaticAbstractMethods();
    internal static Tuple`2<int, string> tcUsingInterfaceWithStaticAbstractMethodAsType(string a0);
    internal static Tuple`2<int, string> tcTraitHasMultipleSupportTypes(string a0);
    internal static Tuple`2<int, string> tcMissingRequiredMembers(string a0);
    internal static Tuple`2<int, string> parsExpectingPattern();
    internal static Tuple`2<int, string> parsExpectedPatternAfterToken();
    internal static Tuple`2<int, string> matchNotAllowedForUnionCaseWithNoData();
    internal static Tuple`2<int, string> tcSynTypeOrInvalidInDeclaration();
    internal static Tuple`2<int, string> chkDuplicatedMethodParameter(string a0);
    internal static string featureEscapeBracesInFormattableString();
    internal static Tuple`2<int, string> buildDuplicateFile(string a0, int a1, int a2, int a3, int a4);
    internal static Tuple`2<int, string> chkConstructorWithArgumentsOnStaticClasses();
    internal static Tuple`2<int, string> chkAdditionalConstructorOnStaticClasses();
    internal static Tuple`2<int, string> chkInstanceMemberOnStaticClasses();
    internal static Tuple`2<int, string> chkInstanceLetBindingOnStaticClasses();
    internal static Tuple`2<int, string> chkImplementingInterfacesOnStaticClasses();
    internal static Tuple`2<int, string> chkAbstractMembersDeclarationsOnStaticClasses();
    internal static Tuple`2<int, string> chkExplicitFieldsDeclarationsOnStaticClasses();
    internal static Tuple`2<int, string> typrelNeverRefinedAwayFromTop();
    internal static Tuple`2<int, string> tcCopyAndUpdateRecordChangesAllFields(string a0);
    internal static Tuple`2<int, string> chkAutoOpenAttributeInTypeAbbrev();
    internal static Tuple`2<int, string> parsUnexpectedEndOfFileElif();
    internal static Tuple`2<int, string> lexInvalidIdentifier();
    internal static Tuple`2<int, string> parsMissingUnionCaseName();
    internal static Tuple`2<int, string> parsExpectingType();
    internal static string featureInformationalObjInferenceDiagnostic();
    internal static string featureStaticLetInRecordsDusEmptyTypes();
    internal static Tuple`2<int, string> tcMultipleRecdTypeChoice(string a0, string a1, string a2);
    internal static Tuple`2<int, string> parsMissingMemberBody();
    internal static Tuple`2<int, string> parsMissingKeyword(string a0);
    internal static Tuple`2<int, string> chkNotTailRecursive(string a0);
    internal static Tuple`2<int, string> tcAmbiguousDiscardDotLambda();
    internal static Tuple`2<int, string> parsUnderScoreDotLambdaNonAtomic();
    internal static string featureAccessorFunctionShorthand();
    internal static Tuple`2<int, string> parsConstraintIntersectionSyntaxUsedWithNonFlexibleType();
    internal static Tuple`2<int, string> tcStaticBindingInExtrinsicAugmentation();
    internal static Tuple`2<int, string> pickleFsharpCoreBackwardsCompatible(string a0, string a1);
    internal static Tuple`2<int, string> tcOverrideUsesMultipleArgumentsInsteadOfTuple();
    internal static string featureUnmanagedConstraintCsharpInterop();
    internal static Tuple`2<int, string> chkCopyUpdateSyntaxInAnonRecords();
    internal static Tuple`2<int, string> alwaysUseTypedStringInterpolation();
    internal static Tuple`2<int, string> tcUnexpectedFunTypeInUnionCaseField();
    internal static void RunStartupValidation();
    [CompilerGeneratedAttribute]
internal static Assembly getCurrentAssembly();
    [CompilerGeneratedAttribute]
internal static Type getTypeInfo(Type t);
    [CompilerGeneratedAttribute]
internal static string GetString(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object mkFunctionValue(Type[] tys, FSharpFunc`2<object, object> impl);
    [CompilerGeneratedAttribute]
internal static bool isNamedType(Type ty);
    [CompilerGeneratedAttribute]
internal static bool isFunctionType(Type ty1);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Type, Type[]> destFunTy(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object buildFunctionForOneArgPat(Type ty, FSharpFunc`2<Type, FSharpFunc`2<object, object>> impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object capture1(string fmt, int i, FSharpList`1<object> args, Type ty, FSharpFunc`2<FSharpList`1<object>, FSharpFunc`2<Type, FSharpFunc`2<int, object>>> go);
    [CompilerGeneratedAttribute]
internal static string postProcessString(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static T createMessageString(string messageString, PrintfFormat`4<T, Unit, string, string> fmt);
    [CompilerGeneratedAttribute]
internal static T GetStringFunc(string messageID, PrintfFormat`4<T, Unit, string, string> fmt);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.BuildProperties : object {
    internal static string fsProductVersion { get; }
    internal static string fsLanguageVersion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_fsProductVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_fsLanguageVersion();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.AsciiConstants : object {
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, ILInstr>>> noArgInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Unit, ILInstr>>>> NoArgInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<long, ILInstr>>>> Int64Instrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<int, ILInstr>>>> Int32Instrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<int, int>, ILInstr>>>> Int32Int32Instrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILConst, ILInstr>>>> DoubleInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<string, ILInstr>>>> StringInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILToken, ILInstr>>>> TokenInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILType, ILInstr>>>> TypeInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<int, ILType>, ILInstr>>>> IntTypeInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILType, ILInstr>>>> ValueTypeInstrs { get; }
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, ILInstr>>> get_noArgInstrs();
    internal static Tuple`2<a, FSharpFunc`2<Unit, ILInstr>> mk_stind(a nm, ILBasicType dt);
    internal static Tuple`2<a, FSharpFunc`2<Unit, ILInstr>> mk_ldind(a nm, ILBasicType dt);
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Unit, ILInstr>>>> get_NoArgInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<long, ILInstr>>>> get_Int64Instrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<int, ILInstr>>>> get_Int32Instrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<int, int>, ILInstr>>>> get_Int32Int32Instrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILConst, ILInstr>>>> get_DoubleInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<string, ILInstr>>>> get_StringInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILToken, ILInstr>>>> get_TokenInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILType, ILInstr>>>> get_TypeInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<Tuple`2<int, ILType>, ILInstr>>>> get_IntTypeInstrs();
    internal static Lazy`1<FSharpList`1<Tuple`2<FSharpList`1<string>, FSharpFunc`2<ILType, ILInstr>>>> get_ValueTypeInstrs();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.AsciiLexer : object {
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063071@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063072@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063073@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063074@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063075@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063076@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063077@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063078@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063079@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063080@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063081@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063082@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063083@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063084@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063085@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063086@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063087@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063088@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063089@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063090@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063091@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063092@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063093@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063094@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063095@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063096@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063097@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063098@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063099@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063100@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063101@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063102@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063103@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063104@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063105@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063106@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063107@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063108@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063109@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063110@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063111@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063112@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063113@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063114@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063115@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063116@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063117@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063118@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063119@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063120@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063121@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063122@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063123@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063124@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063125@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063126@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063127@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063128@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063129@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063130@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063131@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063132@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063133@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063134@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063135@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063136@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063137@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063138@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063139@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063140@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063141@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063142@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063143@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063144@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063145@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063146@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063147@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063148@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063149@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063150@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063151@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063152@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063153@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063154@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063155@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063156@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063157@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063158@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063159@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063160@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063161@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063162@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063163@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063164@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063165@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063166@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063167@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063168@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063169@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063170@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063171@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063172@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063173@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063174@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063175@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063176@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063177@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063178@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063179@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063180@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063181@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063182@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063183@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063184@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063185@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063186@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063187@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063188@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063189@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063190@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063191@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063192@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063193@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063194@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063195@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063196@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063197@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063198@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063199@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063200@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063201@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063202@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063203@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063204@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063205@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063206@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063070_830Bytes@ field1063207@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063208_274Bytes@ field1063209@;
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<string, token>>> keywords { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<HashMultiMap`2<string, token>> kwdInstrTable { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[][] trans { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] actions { get; }
    [CompilationMappingAttribute("9")]
internal static UnicodeTables _fslex_tables { get; }
    private static AsciiLexer();
    internal static Lazy`1<FSharpList`1<Tuple`2<string, token>>> get_keywords();
    internal static Lazy`1<HashMultiMap`2<string, token>> get_kwdInstrTable();
    internal static void addTable@59(HashMultiMap`2<string, token> t, FSharpFunc`2<a, token> f, Lazy`1<FSharpList`1<Tuple`2<b, a>>> l);
    internal static token kwdOrInstrOrId(string s);
    internal static UInt16[][] get_trans();
    internal static UInt16[] get_actions();
    internal static UnicodeTables get__fslex_tables();
    internal static a _fslex_dummy();
    internal static token token(LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.AsciiParser : object {
    [DebuggerBrowsableAttribute("0")]
internal static T1063055_476Bytes@ field1063056@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063057_52Bytes@ field1063058@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063059_512Bytes@ field1063060@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063061_228Bytes@ field1063062@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063063_1612Bytes@ field1063064@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063061_228Bytes@ field1063065@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063066_172Bytes@ field1063067@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063066_172Bytes@ field1063068@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063061_228Bytes@ field1063069@;
    internal static int _fsyacc_endOfInputTag { get; }
    internal static int _fsyacc_tagOfErrorTerminal { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_gotos { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_sparseGotoTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableRowOffsets { get; }
    internal static int _fsyacc_action_rows { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_reductionSymbolCounts { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_productionToNonTerminalTable { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_immediateActions { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpFunc`2[]> _fsyacc_reductions { get; }
    [CompilationMappingAttribute("9")]
internal static Tables`1<token> tables { get; }
    private static AsciiParser();
    internal static ResolvedAtMethodSpecScope`1<a> noMethodSpecScope(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResolvedAtMethodSpecScope`1<b> resolveMethodSpecScopeThen(ResolvedAtMethodSpecScope`1<a> _arg1, FSharpFunc`2<a, ResolvedAtMethodSpecScope`1<b>> g);
    internal static int tagOfToken(token t);
    internal static tokenId tokenTagToTokenId(int tokenIdx);
    internal static nonTerminalId prodIdxToNonTerminal(int prodIdx);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_endOfInputTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_tagOfErrorTerminal();
    internal static string token_to_string(token t);
    internal static object _fsyacc_dataOfToken(token t);
    internal static UInt16[] get__fsyacc_gotos();
    internal static UInt16[] get__fsyacc_sparseGotoTableRowOffsets();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableElements();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_action_rows();
    internal static UInt16[] get__fsyacc_actionTableElements();
    internal static UInt16[] get__fsyacc_actionTableRowOffsets();
    internal static UInt16[] get__fsyacc_reductionSymbolCounts();
    internal static UInt16[] get__fsyacc_productionToNonTerminalTable();
    internal static UInt16[] get__fsyacc_immediateActions();
    internal static Lazy`1<FSharpFunc`2[]> get__fsyacc_reductions();
    internal static Tables`1<token> get_tables();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr[] ilInstrs(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType ilType(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.BinaryConstants : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<TableName, int>> sortedTableInfo { get; }
    [CompilationMappingAttribute("9")]
internal static TypeDefOrRefTag tdor_TypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static TypeDefOrRefTag tdor_TypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static TypeDefOrRefTag tdor_TypeSpec { get; }
    [CompilationMappingAttribute("9")]
internal static HasConstantTag hc_FieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasConstantTag hc_ParamDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasConstantTag hc_Property { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_FieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_TypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_TypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_ParamDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_InterfaceImpl { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_MemberRef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Module { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Permission { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Property { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Event { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_StandAloneSig { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_ModuleRef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_TypeSpec { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_Assembly { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_AssemblyRef { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_File { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_ExportedType { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_ManifestResource { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_GenericParam { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_GenericParamConstraint { get; }
    [CompilationMappingAttribute("9")]
internal static HasCustomAttributeTag hca_MethodSpec { get; }
    [CompilationMappingAttribute("9")]
internal static HasFieldMarshalTag hfm_FieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasFieldMarshalTag hfm_ParamDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasDeclSecurityTag hds_TypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasDeclSecurityTag hds_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static HasDeclSecurityTag hds_Assembly { get; }
    [CompilationMappingAttribute("9")]
internal static MemberRefParentTag mrp_TypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static MemberRefParentTag mrp_ModuleRef { get; }
    [CompilationMappingAttribute("9")]
internal static MemberRefParentTag mrp_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static MemberRefParentTag mrp_TypeSpec { get; }
    [CompilationMappingAttribute("9")]
internal static HasSemanticsTag hs_Event { get; }
    [CompilationMappingAttribute("9")]
internal static HasSemanticsTag hs_Property { get; }
    [CompilationMappingAttribute("9")]
internal static MethodDefOrRefTag mdor_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static MethodDefOrRefTag mdor_MemberRef { get; }
    [CompilationMappingAttribute("9")]
internal static MethodDefOrRefTag mdor_MethodSpec { get; }
    [CompilationMappingAttribute("9")]
internal static MemberForwardedTag mf_FieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static MemberForwardedTag mf_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static ImplementationTag i_File { get; }
    [CompilationMappingAttribute("9")]
internal static ImplementationTag i_AssemblyRef { get; }
    [CompilationMappingAttribute("9")]
internal static ImplementationTag i_ExportedType { get; }
    [CompilationMappingAttribute("9")]
internal static CustomAttributeTypeTag cat_MethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static CustomAttributeTypeTag cat_MemberRef { get; }
    [CompilationMappingAttribute("9")]
internal static ResolutionScopeTag rs_Module { get; }
    [CompilationMappingAttribute("9")]
internal static ResolutionScopeTag rs_ModuleRef { get; }
    [CompilationMappingAttribute("9")]
internal static ResolutionScopeTag rs_AssemblyRef { get; }
    [CompilationMappingAttribute("9")]
internal static ResolutionScopeTag rs_TypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static TypeOrMethodDefTag tomd_TypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static TypeOrMethodDefTag tomd_MethodDef { get; }
    internal static byte et_END { get; }
    internal static byte et_VOID { get; }
    internal static byte et_BOOLEAN { get; }
    internal static byte et_CHAR { get; }
    internal static byte et_I1 { get; }
    internal static byte et_U1 { get; }
    internal static byte et_I2 { get; }
    internal static byte et_U2 { get; }
    internal static byte et_I4 { get; }
    internal static byte et_U4 { get; }
    internal static byte et_I8 { get; }
    internal static byte et_U8 { get; }
    internal static byte et_R4 { get; }
    internal static byte et_R8 { get; }
    internal static byte et_STRING { get; }
    internal static byte et_PTR { get; }
    internal static byte et_BYREF { get; }
    internal static byte et_VALUETYPE { get; }
    internal static byte et_CLASS { get; }
    internal static byte et_VAR { get; }
    internal static byte et_ARRAY { get; }
    internal static byte et_WITH { get; }
    internal static byte et_TYPEDBYREF { get; }
    internal static byte et_I { get; }
    internal static byte et_U { get; }
    internal static byte et_FNPTR { get; }
    internal static byte et_OBJECT { get; }
    internal static byte et_SZARRAY { get; }
    internal static byte et_MVAR { get; }
    internal static byte et_CMOD_REQD { get; }
    internal static byte et_CMOD_OPT { get; }
    internal static byte et_SENTINEL { get; }
    internal static byte et_PINNED { get; }
    internal static int i_nop { get; }
    internal static int i_break { get; }
    internal static int i_ldarg_0 { get; }
    internal static int i_ldarg_1 { get; }
    internal static int i_ldarg_2 { get; }
    internal static int i_ldarg_3 { get; }
    internal static int i_ldloc_0 { get; }
    internal static int i_ldloc_1 { get; }
    internal static int i_ldloc_2 { get; }
    internal static int i_ldloc_3 { get; }
    internal static int i_stloc_0 { get; }
    internal static int i_stloc_1 { get; }
    internal static int i_stloc_2 { get; }
    internal static int i_stloc_3 { get; }
    internal static int i_ldarg_s { get; }
    internal static int i_ldarga_s { get; }
    internal static int i_starg_s { get; }
    internal static int i_ldloc_s { get; }
    internal static int i_ldloca_s { get; }
    internal static int i_stloc_s { get; }
    internal static int i_ldnull { get; }
    internal static int i_ldc_i4_m1 { get; }
    internal static int i_ldc_i4_0 { get; }
    internal static int i_ldc_i4_1 { get; }
    internal static int i_ldc_i4_2 { get; }
    internal static int i_ldc_i4_3 { get; }
    internal static int i_ldc_i4_4 { get; }
    internal static int i_ldc_i4_5 { get; }
    internal static int i_ldc_i4_6 { get; }
    internal static int i_ldc_i4_7 { get; }
    internal static int i_ldc_i4_8 { get; }
    internal static int i_ldc_i4_s { get; }
    internal static int i_ldc_i4 { get; }
    internal static int i_ldc_i8 { get; }
    internal static int i_ldc_r4 { get; }
    internal static int i_ldc_r8 { get; }
    internal static int i_dup { get; }
    internal static int i_pop { get; }
    internal static int i_jmp { get; }
    internal static int i_call { get; }
    internal static int i_calli { get; }
    internal static int i_ret { get; }
    internal static int i_br_s { get; }
    internal static int i_brfalse_s { get; }
    internal static int i_brtrue_s { get; }
    internal static int i_beq_s { get; }
    internal static int i_bge_s { get; }
    internal static int i_bgt_s { get; }
    internal static int i_ble_s { get; }
    internal static int i_blt_s { get; }
    internal static int i_bne_un_s { get; }
    internal static int i_bge_un_s { get; }
    internal static int i_bgt_un_s { get; }
    internal static int i_ble_un_s { get; }
    internal static int i_blt_un_s { get; }
    internal static int i_br { get; }
    internal static int i_brfalse { get; }
    internal static int i_brtrue { get; }
    internal static int i_beq { get; }
    internal static int i_bge { get; }
    internal static int i_bgt { get; }
    internal static int i_ble { get; }
    internal static int i_blt { get; }
    internal static int i_bne_un { get; }
    internal static int i_bge_un { get; }
    internal static int i_bgt_un { get; }
    internal static int i_ble_un { get; }
    internal static int i_blt_un { get; }
    internal static int i_switch { get; }
    internal static int i_ldind_i1 { get; }
    internal static int i_ldind_u1 { get; }
    internal static int i_ldind_i2 { get; }
    internal static int i_ldind_u2 { get; }
    internal static int i_ldind_i4 { get; }
    internal static int i_ldind_u4 { get; }
    internal static int i_ldind_i8 { get; }
    internal static int i_ldind_i { get; }
    internal static int i_ldind_r4 { get; }
    internal static int i_ldind_r8 { get; }
    internal static int i_ldind_ref { get; }
    internal static int i_stind_ref { get; }
    internal static int i_stind_i1 { get; }
    internal static int i_stind_i2 { get; }
    internal static int i_stind_i4 { get; }
    internal static int i_stind_i8 { get; }
    internal static int i_stind_r4 { get; }
    internal static int i_stind_r8 { get; }
    internal static int i_add { get; }
    internal static int i_sub { get; }
    internal static int i_mul { get; }
    internal static int i_div { get; }
    internal static int i_div_un { get; }
    internal static int i_rem { get; }
    internal static int i_rem_un { get; }
    internal static int i_and { get; }
    internal static int i_or { get; }
    internal static int i_xor { get; }
    internal static int i_shl { get; }
    internal static int i_shr { get; }
    internal static int i_shr_un { get; }
    internal static int i_neg { get; }
    internal static int i_not { get; }
    internal static int i_conv_i1 { get; }
    internal static int i_conv_i2 { get; }
    internal static int i_conv_i4 { get; }
    internal static int i_conv_i8 { get; }
    internal static int i_conv_r4 { get; }
    internal static int i_conv_r8 { get; }
    internal static int i_conv_u4 { get; }
    internal static int i_conv_u8 { get; }
    internal static int i_callvirt { get; }
    internal static int i_cpobj { get; }
    internal static int i_ldobj { get; }
    internal static int i_ldstr { get; }
    internal static int i_newobj { get; }
    internal static int i_castclass { get; }
    internal static int i_isinst { get; }
    internal static int i_conv_r_un { get; }
    internal static int i_unbox { get; }
    internal static int i_throw { get; }
    internal static int i_ldfld { get; }
    internal static int i_ldflda { get; }
    internal static int i_stfld { get; }
    internal static int i_ldsfld { get; }
    internal static int i_ldsflda { get; }
    internal static int i_stsfld { get; }
    internal static int i_stobj { get; }
    internal static int i_conv_ovf_i1_un { get; }
    internal static int i_conv_ovf_i2_un { get; }
    internal static int i_conv_ovf_i4_un { get; }
    internal static int i_conv_ovf_i8_un { get; }
    internal static int i_conv_ovf_u1_un { get; }
    internal static int i_conv_ovf_u2_un { get; }
    internal static int i_conv_ovf_u4_un { get; }
    internal static int i_conv_ovf_u8_un { get; }
    internal static int i_conv_ovf_i_un { get; }
    internal static int i_conv_ovf_u_un { get; }
    internal static int i_box { get; }
    internal static int i_newarr { get; }
    internal static int i_ldlen { get; }
    internal static int i_ldelema { get; }
    internal static int i_ldelem_i1 { get; }
    internal static int i_ldelem_u1 { get; }
    internal static int i_ldelem_i2 { get; }
    internal static int i_ldelem_u2 { get; }
    internal static int i_ldelem_i4 { get; }
    internal static int i_ldelem_u4 { get; }
    internal static int i_ldelem_i8 { get; }
    internal static int i_ldelem_i { get; }
    internal static int i_ldelem_r4 { get; }
    internal static int i_ldelem_r8 { get; }
    internal static int i_ldelem_ref { get; }
    internal static int i_stelem_i { get; }
    internal static int i_stelem_i1 { get; }
    internal static int i_stelem_i2 { get; }
    internal static int i_stelem_i4 { get; }
    internal static int i_stelem_i8 { get; }
    internal static int i_stelem_r4 { get; }
    internal static int i_stelem_r8 { get; }
    internal static int i_stelem_ref { get; }
    internal static int i_conv_ovf_i1 { get; }
    internal static int i_conv_ovf_u1 { get; }
    internal static int i_conv_ovf_i2 { get; }
    internal static int i_conv_ovf_u2 { get; }
    internal static int i_conv_ovf_i4 { get; }
    internal static int i_conv_ovf_u4 { get; }
    internal static int i_conv_ovf_i8 { get; }
    internal static int i_conv_ovf_u8 { get; }
    internal static int i_refanyval { get; }
    internal static int i_ckfinite { get; }
    internal static int i_mkrefany { get; }
    internal static int i_ldtoken { get; }
    internal static int i_conv_u2 { get; }
    internal static int i_conv_u1 { get; }
    internal static int i_conv_i { get; }
    internal static int i_conv_ovf_i { get; }
    internal static int i_conv_ovf_u { get; }
    internal static int i_add_ovf { get; }
    internal static int i_add_ovf_un { get; }
    internal static int i_mul_ovf { get; }
    internal static int i_mul_ovf_un { get; }
    internal static int i_sub_ovf { get; }
    internal static int i_sub_ovf_un { get; }
    internal static int i_endfinally { get; }
    internal static int i_leave { get; }
    internal static int i_leave_s { get; }
    internal static int i_stind_i { get; }
    internal static int i_conv_u { get; }
    internal static int i_arglist { get; }
    internal static int i_ceq { get; }
    internal static int i_cgt { get; }
    internal static int i_cgt_un { get; }
    internal static int i_clt { get; }
    internal static int i_clt_un { get; }
    internal static int i_ldftn { get; }
    internal static int i_ldvirtftn { get; }
    internal static int i_ldarg { get; }
    internal static int i_ldarga { get; }
    internal static int i_starg { get; }
    internal static int i_ldloc { get; }
    internal static int i_ldloca { get; }
    internal static int i_stloc { get; }
    internal static int i_localloc { get; }
    internal static int i_endfilter { get; }
    internal static int i_unaligned { get; }
    internal static int i_volatile { get; }
    internal static int i_constrained { get; }
    internal static int i_readonly { get; }
    internal static int i_tail { get; }
    internal static int i_initobj { get; }
    internal static int i_cpblk { get; }
    internal static int i_initblk { get; }
    internal static int i_rethrow { get; }
    internal static int i_sizeof { get; }
    internal static int i_refanytype { get; }
    internal static int i_ldelem_any { get; }
    internal static int i_stelem_any { get; }
    internal static int i_unbox_any { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<int, ILInstr>>> noArgInstrs { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<Dictionary`2<ILComparisonInstr, int>> ILCmpInstrMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<Dictionary`2<ILComparisonInstr, int>> ILCmpInstrRevMap { get; }
    internal static byte nt_VOID { get; }
    internal static byte nt_BOOLEAN { get; }
    internal static byte nt_I1 { get; }
    internal static byte nt_U1 { get; }
    internal static byte nt_I2 { get; }
    internal static byte nt_U2 { get; }
    internal static byte nt_I4 { get; }
    internal static byte nt_U4 { get; }
    internal static byte nt_I8 { get; }
    internal static byte nt_U8 { get; }
    internal static byte nt_R4 { get; }
    internal static byte nt_R8 { get; }
    internal static byte nt_SYSCHAR { get; }
    internal static byte nt_VARIANT { get; }
    internal static byte nt_CURRENCY { get; }
    internal static byte nt_PTR { get; }
    internal static byte nt_DECIMAL { get; }
    internal static byte nt_DATE { get; }
    internal static byte nt_BSTR { get; }
    internal static byte nt_LPSTR { get; }
    internal static byte nt_LPWSTR { get; }
    internal static byte nt_LPTSTR { get; }
    internal static byte nt_FIXEDSYSSTRING { get; }
    internal static byte nt_OBJECTREF { get; }
    internal static byte nt_IUNKNOWN { get; }
    internal static byte nt_IDISPATCH { get; }
    internal static byte nt_STRUCT { get; }
    internal static byte nt_INTF { get; }
    internal static byte nt_SAFEARRAY { get; }
    internal static byte nt_FIXEDARRAY { get; }
    internal static byte nt_INT { get; }
    internal static byte nt_UINT { get; }
    internal static byte nt_NESTEDSTRUCT { get; }
    internal static byte nt_BYVALSTR { get; }
    internal static byte nt_ANSIBSTR { get; }
    internal static byte nt_TBSTR { get; }
    internal static byte nt_VARIANTBOOL { get; }
    internal static byte nt_FUNC { get; }
    internal static byte nt_ASANY { get; }
    internal static byte nt_ARRAY { get; }
    internal static byte nt_LPSTRUCT { get; }
    internal static byte nt_CUSTOMMARSHALER { get; }
    internal static byte nt_ERROR { get; }
    internal static byte nt_LPUTF8STR { get; }
    internal static byte nt_MAX { get; }
    internal static int vt_EMPTY { get; }
    internal static int vt_NULL { get; }
    internal static int vt_I2 { get; }
    internal static int vt_I4 { get; }
    internal static int vt_R4 { get; }
    internal static int vt_R8 { get; }
    internal static int vt_CY { get; }
    internal static int vt_DATE { get; }
    internal static int vt_BSTR { get; }
    internal static int vt_DISPATCH { get; }
    internal static int vt_ERROR { get; }
    internal static int vt_BOOL { get; }
    internal static int vt_VARIANT { get; }
    internal static int vt_UNKNOWN { get; }
    internal static int vt_DECIMAL { get; }
    internal static int vt_I1 { get; }
    internal static int vt_UI1 { get; }
    internal static int vt_UI2 { get; }
    internal static int vt_UI4 { get; }
    internal static int vt_I8 { get; }
    internal static int vt_UI8 { get; }
    internal static int vt_INT { get; }
    internal static int vt_UINT { get; }
    internal static int vt_VOID { get; }
    internal static int vt_HRESULT { get; }
    internal static int vt_PTR { get; }
    internal static int vt_SAFEARRAY { get; }
    internal static int vt_CARRAY { get; }
    internal static int vt_USERDEFINED { get; }
    internal static int vt_LPSTR { get; }
    internal static int vt_LPWSTR { get; }
    internal static int vt_RECORD { get; }
    internal static int vt_FILETIME { get; }
    internal static int vt_BLOB { get; }
    internal static int vt_STREAM { get; }
    internal static int vt_STORAGE { get; }
    internal static int vt_STREAMED_OBJECT { get; }
    internal static int vt_STORED_OBJECT { get; }
    internal static int vt_BLOB_OBJECT { get; }
    internal static int vt_CF { get; }
    internal static int vt_CLSID { get; }
    internal static int vt_VECTOR { get; }
    internal static int vt_ARRAY { get; }
    internal static int vt_BYREF { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<byte, ILNativeType>>> ILNativeTypeMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<ILNativeType, byte>>> ILNativeTypeRevMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<ILNativeVariant, int>>> ILVariantTypeMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<int, ILNativeVariant>>> ILVariantTypeRevMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<ILSecurityAction, int>>> ILSecurityActionMap { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpList`1<Tuple`2<int, ILSecurityAction>>> ILSecurityActionRevMap { get; }
    internal static byte e_CorILMethod_TinyFormat { get; }
    internal static byte e_CorILMethod_FatFormat { get; }
    internal static byte e_CorILMethod_FormatMask { get; }
    internal static byte e_CorILMethod_MoreSects { get; }
    internal static byte e_CorILMethod_InitLocals { get; }
    internal static byte e_CorILMethod_Sect_EHTable { get; }
    internal static byte e_CorILMethod_Sect_FatFormat { get; }
    internal static byte e_CorILMethod_Sect_MoreSects { get; }
    internal static int e_COR_ILEXCEPTION_CLAUSE_EXCEPTION { get; }
    internal static int e_COR_ILEXCEPTION_CLAUSE_FILTER { get; }
    internal static int e_COR_ILEXCEPTION_CLAUSE_FINALLY { get; }
    internal static int e_COR_ILEXCEPTION_CLAUSE_FAULT { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_FASTCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_STDCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_THISCALL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_CDECL { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_VARARG { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_FIELD { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_LOCAL_SIG { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_PROPERTY { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_GENERICINST { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_GENERIC { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_INSTANCE { get; }
    internal static byte e_IMAGE_CEE_CS_CALLCONV_INSTANCE_EXPLICIT { get; }
    internal static FSharpList`1<Tuple`2<TableName, int>> get_sortedTableInfo();
    internal static TypeDefOrRefTag get_tdor_TypeDef();
    internal static TypeDefOrRefTag get_tdor_TypeRef();
    internal static TypeDefOrRefTag get_tdor_TypeSpec();
    internal static TypeDefOrRefTag mkTypeDefOrRefOrSpecTag(int x);
    internal static HasConstantTag get_hc_FieldDef();
    internal static HasConstantTag get_hc_ParamDef();
    internal static HasConstantTag get_hc_Property();
    internal static HasConstantTag mkHasConstantTag(int x);
    internal static HasCustomAttributeTag get_hca_MethodDef();
    internal static HasCustomAttributeTag get_hca_FieldDef();
    internal static HasCustomAttributeTag get_hca_TypeRef();
    internal static HasCustomAttributeTag get_hca_TypeDef();
    internal static HasCustomAttributeTag get_hca_ParamDef();
    internal static HasCustomAttributeTag get_hca_InterfaceImpl();
    internal static HasCustomAttributeTag get_hca_MemberRef();
    internal static HasCustomAttributeTag get_hca_Module();
    internal static HasCustomAttributeTag get_hca_Permission();
    internal static HasCustomAttributeTag get_hca_Property();
    internal static HasCustomAttributeTag get_hca_Event();
    internal static HasCustomAttributeTag get_hca_StandAloneSig();
    internal static HasCustomAttributeTag get_hca_ModuleRef();
    internal static HasCustomAttributeTag get_hca_TypeSpec();
    internal static HasCustomAttributeTag get_hca_Assembly();
    internal static HasCustomAttributeTag get_hca_AssemblyRef();
    internal static HasCustomAttributeTag get_hca_File();
    internal static HasCustomAttributeTag get_hca_ExportedType();
    internal static HasCustomAttributeTag get_hca_ManifestResource();
    internal static HasCustomAttributeTag get_hca_GenericParam();
    internal static HasCustomAttributeTag get_hca_GenericParamConstraint();
    internal static HasCustomAttributeTag get_hca_MethodSpec();
    internal static HasCustomAttributeTag mkHasCustomAttributeTag(int x);
    internal static HasFieldMarshalTag get_hfm_FieldDef();
    internal static HasFieldMarshalTag get_hfm_ParamDef();
    internal static HasFieldMarshalTag mkHasFieldMarshalTag(int x);
    internal static HasDeclSecurityTag get_hds_TypeDef();
    internal static HasDeclSecurityTag get_hds_MethodDef();
    internal static HasDeclSecurityTag get_hds_Assembly();
    internal static HasDeclSecurityTag mkHasDeclSecurityTag(int x);
    internal static MemberRefParentTag get_mrp_TypeRef();
    internal static MemberRefParentTag get_mrp_ModuleRef();
    internal static MemberRefParentTag get_mrp_MethodDef();
    internal static MemberRefParentTag get_mrp_TypeSpec();
    internal static MemberRefParentTag mkMemberRefParentTag(int x);
    internal static HasSemanticsTag get_hs_Event();
    internal static HasSemanticsTag get_hs_Property();
    internal static HasSemanticsTag mkHasSemanticsTag(int x);
    internal static MethodDefOrRefTag get_mdor_MethodDef();
    internal static MethodDefOrRefTag get_mdor_MemberRef();
    internal static MethodDefOrRefTag get_mdor_MethodSpec();
    internal static MethodDefOrRefTag mkMethodDefOrRefTag(int x);
    internal static MemberForwardedTag get_mf_FieldDef();
    internal static MemberForwardedTag get_mf_MethodDef();
    internal static MemberForwardedTag mkMemberForwardedTag(int x);
    internal static ImplementationTag get_i_File();
    internal static ImplementationTag get_i_AssemblyRef();
    internal static ImplementationTag get_i_ExportedType();
    internal static ImplementationTag mkImplementationTag(int x);
    internal static CustomAttributeTypeTag get_cat_MethodDef();
    internal static CustomAttributeTypeTag get_cat_MemberRef();
    internal static CustomAttributeTypeTag mkILCustomAttributeTypeTag(int x);
    internal static ResolutionScopeTag get_rs_Module();
    internal static ResolutionScopeTag get_rs_ModuleRef();
    internal static ResolutionScopeTag get_rs_AssemblyRef();
    internal static ResolutionScopeTag get_rs_TypeRef();
    internal static ResolutionScopeTag mkResolutionScopeTag(int x);
    internal static TypeOrMethodDefTag get_tomd_TypeDef();
    internal static TypeOrMethodDefTag get_tomd_MethodDef();
    internal static TypeOrMethodDefTag mkTypeOrMethodDefTag(int x);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_END();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VOID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BOOLEAN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CHAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_STRING();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_PTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BYREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VALUETYPE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CLASS();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_VAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_ARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_WITH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_TYPEDBYREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_FNPTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_SZARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_MVAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CMOD_REQD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CMOD_OPT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_SENTINEL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_PINNED();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_nop();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_break();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarga_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_starg_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloca_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldnull();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_m1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_0();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_3();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_5();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_7();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldc_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_dup();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_pop();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_jmp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_call();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_calli();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ret();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_br_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_brfalse_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_brtrue_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_beq_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bge_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bgt_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ble_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_blt_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bne_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bge_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bgt_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ble_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_blt_un_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_br();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_brfalse();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_brtrue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_beq();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bge();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bgt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ble();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_blt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bne_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bge_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_bgt_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ble_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_blt_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_switch();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_u1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_u2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_u4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldind_ref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_ref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_add();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_sub();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_mul();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_div();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_div_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_rem();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_rem_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_and();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_or();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_xor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_shl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_shr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_shr_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_neg();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_not();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_callvirt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_cpobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldstr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_newobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_castclass();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_isinst();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_r_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_unbox();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_throw();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldfld();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldflda();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stfld();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldsfld();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldsflda();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stsfld();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i1_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i2_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i4_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i8_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u1_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u2_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u4_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u8_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_box();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_newarr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldlen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelema();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_u1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_u2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_u4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_ref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_r4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_r8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_ref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_refanyval();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ckfinite();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_mkrefany();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldtoken();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_ovf_u();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_add_ovf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_add_ovf_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_mul_ovf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_mul_ovf_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_sub_ovf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_sub_ovf_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_endfinally();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_leave();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_leave_s();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stind_i();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_conv_u();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_arglist();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ceq();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_cgt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_cgt_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_clt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_clt_un();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldftn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldvirtftn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarg();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldarga();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_starg();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldloca();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stloc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_localloc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_endfilter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_unaligned();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_volatile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_constrained();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_readonly();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_tail();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_initobj();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_cpblk();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_initblk();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_rethrow();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_sizeof();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_refanytype();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_ldelem_any();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_stelem_any();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_i_unbox_any();
    internal static Lazy`1<FSharpList`1<Tuple`2<int, ILInstr>>> get_noArgInstrs();
    [CompilerGeneratedAttribute]
internal static bool isNoArgInstr$cont@691(ILInstr i, Unit unitVar);
    internal static bool isNoArgInstr(ILInstr i);
    internal static Lazy`1<Dictionary`2<ILComparisonInstr, int>> get_ILCmpInstrMap();
    internal static Lazy`1<Dictionary`2<ILComparisonInstr, int>> get_ILCmpInstrRevMap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_VOID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_BOOLEAN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_U1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_U2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_U4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_U8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_SYSCHAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_VARIANT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_CURRENCY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_PTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_DECIMAL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_DATE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_BSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPWSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPTSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_FIXEDSYSSTRING();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_OBJECTREF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_IUNKNOWN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_IDISPATCH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_STRUCT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_INTF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_SAFEARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_FIXEDARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_INT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_UINT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_NESTEDSTRUCT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_BYVALSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_ANSIBSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_TBSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_VARIANTBOOL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_FUNC();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_ASANY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_ARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPSTRUCT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_CUSTOMMARSHALER();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_ERROR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_LPUTF8STR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_nt_MAX();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_EMPTY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_NULL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_CY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_DATE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_DISPATCH();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_ERROR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BOOL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_VARIANT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UNKNOWN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_DECIMAL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UI1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UI2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UI4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UI8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_INT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_UINT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_VOID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_HRESULT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_PTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_SAFEARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_CARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_USERDEFINED();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_LPSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_LPWSTR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_RECORD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_FILETIME();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BLOB();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_STREAM();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_STORAGE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_STREAMED_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_STORED_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BLOB_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_CF();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_CLSID();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_VECTOR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_ARRAY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_vt_BYREF();
    internal static Lazy`1<FSharpList`1<Tuple`2<byte, ILNativeType>>> get_ILNativeTypeMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<ILNativeType, byte>>> get_ILNativeTypeRevMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<ILNativeVariant, int>>> get_ILVariantTypeMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<int, ILNativeVariant>>> get_ILVariantTypeRevMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<ILSecurityAction, int>>> get_ILSecurityActionMap();
    internal static Lazy`1<FSharpList`1<Tuple`2<int, ILSecurityAction>>> get_ILSecurityActionRevMap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_TinyFormat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_FatFormat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_FormatMask();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_MoreSects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_InitLocals();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_Sect_EHTable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_Sect_FatFormat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_CorILMethod_Sect_MoreSects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_e_COR_ILEXCEPTION_CLAUSE_EXCEPTION();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_e_COR_ILEXCEPTION_CLAUSE_FILTER();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_e_COR_ILEXCEPTION_CLAUSE_FINALLY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_e_COR_ILEXCEPTION_CLAUSE_FAULT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_FASTCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_STDCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_THISCALL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_CDECL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_VARARG();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_FIELD();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_LOCAL_SIG();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_PROPERTY();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_GENERICINST();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_GENERIC();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_INSTANCE();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_e_IMAGE_CEE_CS_CALLCONV_INSTANCE_EXPLICIT();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Diagnostics : object {
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<TextWriter> diagnosticsLog { get; internal set; }
    internal static FSharpOption`1<TextWriter> get_diagnosticsLog();
    internal static void set_diagnosticsLog(FSharpOption`1<TextWriter> value);
    internal static void setDiagnosticsChannel(FSharpOption`1<TextWriter> s);
    internal static void dflushn();
    internal static void dflush();
    internal static void dprintn(string s);
    internal static a dprintf(PrintfFormat`4<a, TextWriter, Unit, Unit> fmt);
    internal static a dprintfn(PrintfFormat`4<a, TextWriter, Unit, Unit> fmt);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.AbstractIL.IL : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Attribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Enum;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_SealedAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Object;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_String;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Array;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Type;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Int64;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UInt64;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Int32;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UInt32;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Int16;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UInt16;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_SByte;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Byte;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Single;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Double;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Bool;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Char;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_IntPtr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UIntPtr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_TypedReference;
    [DebuggerBrowsableAttribute("0")]
internal static T1063003_32Bytes@ field1063004@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063013_1Bytes@ field1063014@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063013_1Bytes@ field1063015@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063013_1Bytes@ field1063016@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063013_1Bytes@ field1063017@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063013_1Bytes@ field1063018@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063003_32Bytes@ field1063019@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063013_1Bytes@ field1063020@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063037_2Bytes@ field1063038@;
    internal static bool logging { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, FSharpList`1<string>> memoizeNamespaceTable { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, Tuple`2<FSharpOption`1<string>, string>> memoizeNamespaceRightTable { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, string> memoizeNamespacePartTable { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, String[]> memoizeNamespaceArrayTable { get; }
    [CompilationMappingAttribute("9")]
internal static UniqueStampGenerator`1<AssemblyRefData> AssemblyRefUniqueStampGenerator { get; }
    [CompilationMappingAttribute("9")]
public static ILAttributes emptyILCustomAttrs { get; }
    [CompilationMappingAttribute("9")]
internal static ILAttributesStored emptyILCustomAttrsStored { get; }
    [CompilationMappingAttribute("9")]
public static ILSecurityDecls emptyILSecurityDecls { get; }
    [CompilationMappingAttribute("9")]
internal static ILSecurityDeclsStored emptyILSecurityDeclsStored { get; }
    public static int NoMetadataIdx { get; }
    internal static FSharpList`1<ILGenericParameterDef> mkILEmptyGenericParams { get; }
    internal static FSharpList`1<ILType> emptyILGenericArgsList { get; }
    internal static string typeNameForGlobalFunctions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<int> codeLabelCount { get; }
    [CompilationMappingAttribute("9")]
public static ILTypeDefs emptyILTypeDefs { get; }
    [CompilationMappingAttribute("9")]
public static ILMethodDefs emptyILMethods { get; }
    internal static int defaultSubSystem { get; }
    internal static int defaultPhysAlignment { get; }
    internal static int defaultVirtAlignment { get; }
    internal static int defaultImageBase { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr[] ldargs { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr mkLdarg0 { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr[] ldlocs { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr[] stlocs { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr[] ldi32s { get; }
    [CompilationMappingAttribute("9")]
internal static PublicKey ecmaPublicKey { get; }
    [CompilationMappingAttribute("9")]
internal static ILReturn mkILVoidReturn { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<MethodBody> methBodyNotAvailable { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<MethodBody> methBodyAbstract { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<MethodBody> methBodyNative { get; }
    [CompilationMappingAttribute("9")]
public static ILFieldDefs emptyILFields { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILFieldDef> l@4071-7 { get; }
    [CompilationMappingAttribute("9")]
public static ILEventDefs emptyILEvents { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILEventDef> l@4078-8 { get; }
    [CompilationMappingAttribute("9")]
public static ILPropertyDefs emptyILProperties { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILPropertyDef> l@4085-9 { get; }
    [CompilationMappingAttribute("9")]
public static ILResources emptyILResources { get; }
    [CompilationMappingAttribute("9")]
public static ILMethodImplDefs emptyILMethodImpls { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILMethodImplDef> l@4123-10 { get; }
    internal static byte et_BOOLEAN { get; }
    internal static byte et_CHAR { get; }
    internal static byte et_I1 { get; }
    internal static byte et_U1 { get; }
    internal static byte et_I2 { get; }
    internal static byte et_U2 { get; }
    internal static byte et_I4 { get; }
    internal static byte et_U4 { get; }
    internal static byte et_I8 { get; }
    internal static byte et_U8 { get; }
    internal static byte et_R4 { get; }
    internal static byte et_R8 { get; }
    internal static byte et_STRING { get; }
    internal static byte et_OBJECT { get; }
    internal static byte et_SZARRAY { get; }
    [CompilationMappingAttribute("9")]
internal static TimeSpan tspan { get; }
    [CompilationMappingAttribute("9")]
internal static DateTime copyOfStruct@4666-1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static DateTime copyOfStruct@4666-2 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static ILScopeRef DummyFSharpCoreScopeRef { get; }
    [CompilationMappingAttribute("9")]
internal static ILGlobals PrimaryAssemblyILGlobals { get; }
    [CompilationMappingAttribute("9")]
internal static ILScopeRef primaryScopeRef@3480 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILAssemblyRef> equivPrimaryAssemblyRefs@3480 { get; }
    [CompilationMappingAttribute("9")]
internal static ILReferences emptyILRefs { get; }
    private static IL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_logging();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<b> lazyMap(FSharpFunc`2<a, b> f, Lazy`1<a> x);
    internal static ConcurrentDictionary`2<string, FSharpList`1<string>> get_memoizeNamespaceTable();
    internal static ConcurrentDictionary`2<string, Tuple`2<FSharpOption`1<string>, string>> get_memoizeNamespaceRightTable();
    internal static ConcurrentDictionary`2<string, string> get_memoizeNamespacePartTable();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, string> splitNameAt(string nm, int idx);
    internal static FSharpList`1<string> splitNamespaceAux(string nm);
    internal static FSharpList`1<string> splitNamespace(string nm);
    internal static ConcurrentDictionary`2<string, String[]> get_memoizeNamespaceArrayTable();
    internal static String[] splitNamespaceToArray(string nm);
    internal static Tuple`2<FSharpList`1<string>, string> splitILTypeName(string nm);
    internal static Tuple`2<String[], string> splitILTypeNameWithPossibleStaticArguments(string nm);
    internal static Tuple`2<FSharpOption`1<string>, string> splitTypeNameRightAux(string nm);
    internal static Tuple`2<FSharpOption`1<string>, string> splitTypeNameRight(string nm);
    internal static Byte[] sha1HashBytes(Byte[] s);
    internal static long sha1HashInt64(Byte[] s);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@417-2(AssemblyRefData this, AssemblyRefData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@417-3(IComparer comp, AssemblyRefData this, AssemblyRefData objTemp, Unit unitVar);
    internal static UniqueStampGenerator`1<AssemblyRefData> get_AssemblyRefUniqueStampGenerator();
    internal static char convDigit@545(int digit);
    internal static ILCallingSignature mkILCallSig(ILCallingConv cc, FSharpList`1<ILType> args, ILType ret);
    internal static ILType mkILBoxedType(ILTypeSpec tspec);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1131-4(ILDebugPoint this, ILDebugPoint obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1131-5(ILDebugPoint this, ILDebugPoint objTemp, Unit unitVar);
    public static ILAttributes get_emptyILCustomAttrs();
    public static ILAttributes mkILCustomAttrsFromArray(ILAttribute[] attrs);
    public static ILAttributes mkILCustomAttrs(FSharpList`1<ILAttribute> l);
    internal static ILAttributesStored get_emptyILCustomAttrsStored();
    public static ILAttributesStored storeILCustomAttrs(ILAttributes attrs);
    internal static ILAttributesStored mkILCustomAttrsReader(FSharpFunc`2<int, ILAttribute[]> f);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1287-6(ILConst this, ILConst obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1287-7(IComparer comp, ILConst this, ILConst objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1287(ILConst this, ILConst obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1443-8(ILExceptionClause this, ILExceptionClause obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1443-9(ILExceptionClause this, ILExceptionClause objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1535-10(ILFieldInit this, ILFieldInit obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1535-11(IComparer comp, ILFieldInit this, ILFieldInit objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1535(IEqualityComparer comp, ILFieldInit this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1535-1(ILFieldInit this, ILFieldInit that, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1535-2(ILFieldInit this, ILFieldInit obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1575-12(ILNativeType this, ILNativeType obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1575-13(IComparer comp, ILNativeType this, ILNativeType objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1575-1(IEqualityComparer comp, ILNativeType this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1575-3(ILNativeType this, ILNativeType that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1575-4(ILNativeType this, ILNativeType obj, Unit unitVar);
    public static ILSecurityDecls get_emptyILSecurityDecls();
    internal static ILSecurityDeclsStored get_emptyILSecurityDeclsStored();
    public static ILSecurityDecls mkILSecurityDecls(FSharpList`1<ILSecurityDecl> l);
    public static ILSecurityDeclsStored storeILSecurityDecls(ILSecurityDecls x);
    internal static ILSecurityDeclsStored mkILSecurityDeclsReader(FSharpFunc`2<int, ILSecurityDecl[]> f);
    internal static FSharpList`1<ILType> typesOfILParams(FSharpList`1<ILParameter> ps);
    internal static ILMemberAccess memberAccessOfFlags(int flags);
    internal static MethodAttributes convertMemberAccess(ILMemberAccess ilMemberAccess);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_NoMetadataIdx();
    internal static FieldAttributes convertFieldAccess(ILMemberAccess ilMemberAccess);
    internal static ILTypeDefAccess typeAccessOfFlags(int flags);
    internal static ILDefaultPInvokeEncoding typeEncodingOfFlags(int flags);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefKind typeKindOfFlags(string nm, FSharpOption`1<ILType> super, int flags);
    internal static TypeAttributes convertTypeAccessFlags(ILTypeDefAccess access);
    internal static TypeAttributes convertTypeKind(ILTypeDefKind kind);
    internal static TypeAttributes convertToNestedTypeAccess(ILMemberAccess ilMemberAccess);
    internal static ILTypeDefStored mkILTypeDefReader(FSharpFunc`2<int, ILTypeDef> f);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@3030-14(ILNativeResource this, ILNativeResource obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@3029-15(IComparer comp, ILNativeResource this, ILNativeResource objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpList`1<ILGenericParameterDef> get_mkILEmptyGenericParams();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpList`1<ILType> get_emptyILGenericArgsList();
    internal static ILTypeRef mkILNestedTyRef(ILScopeRef scope, FSharpList`1<string> l, string nm);
    internal static ILTypeRef mkILTyRef(ILScopeRef scope, string nm);
    internal static ILTypeSpec mkILTySpec(ILTypeRef tref, FSharpList`1<ILType> inst);
    internal static ILTypeSpec mkILNonGenericTySpec(ILTypeRef tref);
    internal static ILTypeRef mkILTyRefInTyRef(ILTypeRef tref, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILTy(ILBoxity boxed, ILTypeSpec tspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILNamedTy(ILBoxity vc, ILTypeRef tref, FSharpList`1<ILType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILValueTy(ILTypeRef tref, FSharpList`1<ILType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILBoxedTy(ILTypeRef tref, FSharpList`1<ILType> tinst);
    internal static ILType mkILNonGenericValueTy(ILTypeRef tref);
    internal static ILType mkILNonGenericBoxedTy(ILTypeRef tref);
    internal static ILAssemblyRef mkSimpleAssemblyRef(string n);
    internal static ILModuleRef mkSimpleModRef(string n);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_typeNameForGlobalFunctions();
    internal static ILType mkILTypeForGlobalFunctions(ILScopeRef scoref);
    internal static bool isTypeNameForGlobalFunctions(string d);
    internal static ILMethodRef mkILMethRef(ILTypeRef tref, ILCallingConv callconv, string nm, int numGenericParams, FSharpList`1<ILType> argTys, ILType retTy);
    internal static ILMethodSpec mkILMethSpecForMethRefInTy(ILMethodRef mref, ILType ty, FSharpList`1<ILType> methInst);
    internal static ILMethodSpec mkILMethSpec(ILMethodRef mref, ILBoxity vc, FSharpList`1<ILType> tinst, FSharpList`1<ILType> methInst);
    internal static ILMethodSpec mkILMethSpecInTypeRef(ILTypeRef tref, ILBoxity vc, ILCallingConv cc, string nm, FSharpList`1<ILType> argTys, ILType retTy, FSharpList`1<ILType> tinst, FSharpList`1<ILType> methInst);
    internal static ILMethodSpec mkILMethSpecInTy(ILType ty, ILCallingConv cc, string nm, FSharpList`1<ILType> argTys, ILType retTy, FSharpList`1<ILType> methInst);
    internal static ILMethodSpec mkILNonGenericMethSpecInTy(ILType ty, ILCallingConv cc, string nm, FSharpList`1<ILType> argTys, ILType retTy);
    internal static ILMethodSpec mkILInstanceMethSpecInTy(ILType ty, string nm, FSharpList`1<ILType> argTys, ILType retTy, FSharpList`1<ILType> methInst);
    internal static ILMethodSpec mkILNonGenericInstanceMethSpecInTy(ILType ty, string nm, FSharpList`1<ILType> argTys, ILType retTy);
    internal static ILMethodSpec mkILStaticMethSpecInTy(ILType ty, string nm, FSharpList`1<ILType> argTys, ILType retTy, FSharpList`1<ILType> methInst);
    internal static ILMethodSpec mkILNonGenericStaticMethSpecInTy(ILType ty, string nm, FSharpList`1<ILType> argTys, ILType retTy);
    internal static ILMethodSpec mkILCtorMethSpec(ILTypeRef tref, FSharpList`1<ILType> argTys, FSharpList`1<ILType> tinst);
    internal static ILMethodSpec mkILCtorMethSpecForTy(ILType ty, FSharpList`1<ILType> args);
    internal static ILFieldRef mkILFieldRef(ILTypeRef tref, string nm, ILType ty);
    internal static ILFieldSpec mkILFieldSpec(ILFieldRef tref, ILType ty);
    internal static ILFieldSpec mkILFieldSpecInTy(ILType ty, string nm, ILType fty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTailcall andTailness(ILTailcall x, bool y);
    internal static string formatCodeLabel(int x);
    internal static FSharpRef`1<int> get_codeLabelCount();
    internal static int generateCodeLabel();
    internal static ILCode nonBranchingInstrsToCode(FSharpList`1<ILInstr> instrs);
    internal static ILType mkILTyvarTy(ushort tv);
    internal static ILGenericParameterDef mkILSimpleTypar(string nm);
    internal static FSharpList`1<ILGenericParameterDef> mkILFormalTypars(FSharpList`1<ILType> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> mkILFormalGenericArgs(int numtypars, FSharpList`1<ILGenericParameterDef> gparams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILFormalBoxedTy(ILTypeRef tref, FSharpList`1<ILGenericParameterDef> gparams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILFormalNamedTy(ILBoxity bx, ILTypeRef tref, FSharpList`1<ILGenericParameterDef> gparams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef mkRefForNestedILTypeDef(ILScopeRef scope, FSharpList`1<ILTypeDef> enc, ILTypeDef td);
    internal static ILPreTypeDef mkILPreTypeDef(ILTypeDef td);
    internal static ILPreTypeDef mkILPreTypeDefComputed(FSharpList`1<string> ns, string n, FSharpFunc`2<Unit, ILTypeDef> f);
    internal static ILPreTypeDef mkILPreTypeDefRead(FSharpList`1<string> ns, string n, int idx, ILTypeDefStored f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefs addILTypeDef(ILTypeDef td, ILTypeDefs tdefs);
    public static ILTypeDefs mkILTypeDefsFromArray(ILTypeDef[] l);
    public static ILTypeDefs mkILTypeDefs(FSharpList`1<ILTypeDef> l);
    public static ILTypeDefs mkILTypeDefsComputed(FSharpFunc`2<Unit, ILPreTypeDef[]> f);
    public static ILTypeDefs get_emptyILTypeDefs();
    public static ILMethodDefs mkILMethodsFromArray(ILMethodDef[] xs);
    public static ILMethodDefs mkILMethods(FSharpList`1<ILMethodDef> xs);
    public static ILMethodDefs mkILMethodsComputed(FSharpFunc`2<Unit, ILMethodDef[]> f);
    public static ILMethodDefs get_emptyILMethods();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_defaultSubSystem();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_defaultPhysAlignment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_defaultVirtAlignment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_defaultImageBase();
    internal static ILType mkILArrTy(ILType ty, ILArrayShape shape);
    internal static ILType mkILArr1DTy(ILType ty);
    internal static bool isILArrTy(ILType ty);
    internal static Tuple`2<ILArrayShape, ILType> destILArrTy(ILType ty);
    internal static ILGlobals mkILGlobals(ILScopeRef primaryScopeRef, FSharpList`1<ILAssemblyRef> equivPrimaryAssemblyRefs, ILScopeRef fsharpCoreAssemblyScopeRef);
    internal static ILInstr mkNormalCall(ILMethodSpec mspec);
    internal static ILInstr mkNormalCallvirt(ILMethodSpec mspec);
    internal static ILInstr mkNormalNewobj(ILMethodSpec mspec);
    internal static ILInstr[] get_ldargs();
    internal static ILInstr mkLdarg(ushort i);
    internal static ILInstr get_mkLdarg0();
    internal static ILInstr[] get_ldlocs();
    internal static ILInstr mkLdloc(ushort i);
    internal static ILInstr[] get_stlocs();
    internal static ILInstr mkStloc(ushort i);
    internal static ILInstr[] get_ldi32s();
    internal static ILInstr mkLdcInt32(int i);
    internal static PublicKey get_ecmaPublicKey();
    internal static ILType stripILModifiedFromTy(ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isBuiltInTySpec(ILGlobals ilg, ILTypeSpec tspec, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILBoxedBuiltInTy(ILGlobals ilg, ILType ty, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILValueBuiltInTy(ILGlobals ilg, ILType ty, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILObjectTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILStringTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILTypedReferenceTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILSByteTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILByteTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILInt16Ty(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILUInt16Ty(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILInt32Ty(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILUInt32Ty(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILInt64Ty(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILUInt64Ty(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILIntPtrTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILUIntPtrTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILBoolTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILCharTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILSingleTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILDoubleTy(ILGlobals ilg, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILScopeRef rescopeILScopeRef(ILScopeRef scoref, ILScopeRef scoref1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef rescopeILTypeRef(ILScopeRef scoref, ILTypeRef tref1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeSpec rescopeILTypeSpec(ILScopeRef scoref, ILTypeSpec tspec1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType rescopeILType(ILScopeRef scoref, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> rescopeILTypes(ILScopeRef scoref, FSharpList`1<ILType> i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCallingSignature rescopeILCallSig(ILScopeRef scoref, ILCallingSignature csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodRef rescopeILMethodRef(ILScopeRef scoref, ILMethodRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldRef rescopeILFieldRef(ILScopeRef scoref, ILFieldRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType instILTypeAux(int numFree, FSharpList`1<ILType> inst, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> instILGenericArgsAux(int numFree, FSharpList`1<ILType> inst, FSharpList`1<ILType> i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCallingSignature instILCallSigAux(int numFree, FSharpList`1<ILType> inst, ILCallingSignature csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType instILType(FSharpList`1<ILType> i, ILType t);
    internal static ILParameter mkILParam(FSharpOption`1<string> name, ILType ty);
    internal static ILParameter mkILParamNamed(string s, ILType ty);
    internal static ILParameter mkILParamAnon(ILType ty);
    public static ILReturn mkILReturn(ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILLocal mkILLocal(ILType ty, FSharpOption`1<Tuple`3<string, int, int>> dbgInfo);
    internal static ILMethodBody mkILMethodBody(bool initlocals, FSharpList`1<ILLocal> locals, int maxstack, ILCode code, FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports);
    internal static MethodBody mkMethodBody(bool zeroinit, FSharpList`1<ILLocal> locals, int maxstack, ILCode code, FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports);
    internal static ILReturn get_mkILVoidReturn();
    internal static Lazy`1<MethodBody> get_methBodyNotAvailable();
    internal static Lazy`1<MethodBody> get_methBodyAbstract();
    internal static Lazy`1<MethodBody> get_methBodyNative();
    internal static ILMethodDef mkILCtor(ILMemberAccess access, FSharpList`1<ILParameter> args, MethodBody impl);
    internal static FSharpList`1<ILInstr> mkCallBaseConstructor(ILType ty, FSharpList`1<ILType> args);
    internal static ILInstr mkNormalStfld(ILFieldSpec fspec);
    internal static ILInstr mkNormalStsfld(ILFieldSpec fspec);
    internal static ILInstr mkNormalLdsfld(ILFieldSpec fspec);
    internal static ILInstr mkNormalLdfld(ILFieldSpec fspec);
    internal static ILInstr mkNormalLdflda(ILFieldSpec fspec);
    internal static ILInstr mkNormalLdobj(ILType dt);
    internal static ILInstr mkNormalStobj(ILType dt);
    internal static ILMethodDef mkILNonGenericEmptyCtor(ILType superTy, FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports);
    internal static ILMethodDef mkILStaticMethod(FSharpList`1<ILGenericParameterDef> genparams, string nm, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    internal static ILMethodDef mkILNonGenericStaticMethod(string nm, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    internal static ILMethodDef mkILClassCtor(MethodBody impl);
    internal static ILMethodDef mkILGenericVirtualMethod(string nm, ILCallingConv callconv, ILMemberAccess access, FSharpList`1<ILGenericParameterDef> genparams, FSharpList`1<ILParameter> actual_args, ILReturn actual_ret, MethodBody impl);
    internal static ILMethodDef mkILNonGenericVirtualMethod(string nm, ILCallingConv callconv, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    internal static ILMethodDef mkILNonGenericVirtualInstanceMethod(string nm, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    internal static ILMethodDef mkILGenericNonVirtualMethod(string nm, ILMemberAccess access, FSharpList`1<ILGenericParameterDef> genparams, FSharpList`1<ILParameter> actual_args, ILReturn actual_ret, MethodBody impl);
    internal static ILMethodDef mkILNonGenericInstanceMethod(string nm, ILMemberAccess access, FSharpList`1<ILParameter> args, ILReturn ret, MethodBody impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodBody ilmbody_code2code(FSharpFunc`2<ILCode, ILCode> f, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef mdef_code2code(FSharpFunc`2<ILCode, ILCode> f, ILMethodDef md);
    [CompilerGeneratedAttribute]
internal static ILCode prependInstrsToCode$cont@3965(ILCode c2, ILInstr[] instrs, int n, ILInstr i0, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode prependInstrsToCode(FSharpList`1<ILInstr> instrs, ILCode c2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef prependInstrsToMethod(FSharpList`1<ILInstr> newCode, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef cdef_cctorCode2CodeOrCreate(FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports, FSharpFunc`2<ILMethodDef, ILMethodDef> f, ILTypeDef cd);
    internal static ILMethodRef mkRefToILMethod(ILTypeRef tref, ILMethodDef md);
    internal static ILFieldRef mkRefToILField(ILTypeRef tref, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodRef mkRefForILMethod(ILScopeRef scope, FSharpList`1<ILTypeDef> tdefs, ILTypeDef tdef, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldRef mkRefForILField(ILScopeRef scope, FSharpList`1<ILTypeDef> tdefs, ILTypeDef tdef, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef prependInstrsToClassCtor(FSharpList`1<ILInstr> instrs, FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports, ILTypeDef cd);
    internal static ILFieldDef mkILField(bool isStatic, string nm, ILType ty, FSharpOption`1<ILFieldInit> init, FSharpOption`1<Byte[]> at, ILMemberAccess access, bool isLiteral);
    internal static ILFieldDef mkILInstanceField(string nm, ILType ty, FSharpOption`1<ILFieldInit> init, ILMemberAccess access);
    internal static ILFieldDef mkILStaticField(string nm, ILType ty, FSharpOption`1<ILFieldInit> init, FSharpOption`1<Byte[]> at, ILMemberAccess access);
    internal static ILFieldDef mkILStaticLiteralField(string nm, ILType ty, ILFieldInit init, FSharpOption`1<Byte[]> at, ILMemberAccess access);
    internal static ILFieldDef mkILLiteralField(string nm, ILType ty, ILFieldInit init, FSharpOption`1<Byte[]> at, ILMemberAccess access);
    public static ILFieldDefs mkILFieldsLazy(Lazy`1<FSharpList`1<ILFieldDef>> l);
    public static ILFieldDefs mkILFields(FSharpList`1<ILFieldDef> l);
    public static ILFieldDefs get_emptyILFields();
    internal static FSharpList`1<ILFieldDef> get_l@4071-7();
    public static ILEventDefs mkILEventsLazy(Lazy`1<FSharpList`1<ILEventDef>> l);
    public static ILEventDefs mkILEvents(FSharpList`1<ILEventDef> l);
    public static ILEventDefs get_emptyILEvents();
    internal static FSharpList`1<ILEventDef> get_l@4078-8();
    public static ILPropertyDefs mkILPropertiesLazy(Lazy`1<FSharpList`1<ILPropertyDef>> l);
    public static ILPropertyDefs mkILProperties(FSharpList`1<ILPropertyDef> l);
    public static ILPropertyDefs get_emptyILProperties();
    internal static FSharpList`1<ILPropertyDef> get_l@4085-9();
    public static ILExportedTypesAndForwarders mkILExportedTypes(FSharpList`1<ILExportedTypeOrForwarder> l);
    internal static ILExportedTypesAndForwarders mkILExportedTypesLazy(Lazy`1<FSharpList`1<ILExportedTypeOrForwarder>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILExportedTypeOrForwarder mkTypeForwarder(ILScopeRef scopeRef, string name, ILNestedExportedTypes nested, ILAttributes customAttrs, ILTypeDefAccess access);
    public static ILNestedExportedTypes mkILNestedExportedTypes(FSharpList`1<ILNestedExportedType> l);
    internal static ILNestedExportedTypes mkILNestedExportedTypesLazy(Lazy`1<FSharpList`1<ILNestedExportedType>> l);
    internal static ILResources mkILResources(FSharpList`1<ILResource> l);
    public static ILResources get_emptyILResources();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<Tuple`2<string, int>, FSharpList`1<ILMethodImplDef>> addMethodImplToTable(ILMethodImplDef y, FSharpMap`2<Tuple`2<string, int>, FSharpList`1<ILMethodImplDef>> tab);
    public static ILMethodImplDefs mkILMethodImpls(FSharpList`1<ILMethodImplDef> l);
    public static ILMethodImplDefs mkILMethodImplsLazy(Lazy`1<FSharpList`1<ILMethodImplDef>> l);
    public static ILMethodImplDefs get_emptyILMethodImpls();
    internal static FSharpList`1<ILMethodImplDef> get_l@4123-10();
    internal static ILMethodDef mkILStorageCtorWithParamNames(FSharpList`1<ILInstr> preblock, ILType ty, FSharpList`1<ILParameter> extraParams, FSharpList`1<Tuple`3<string, string, ILType>> flds, ILMemberAccess access, FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports);
    internal static ILMethodDef mkILSimpleStorageCtorWithParamNames(FSharpOption`1<ILTypeSpec> baseTySpec, ILType ty, FSharpList`1<ILParameter> extraParams, FSharpList`1<Tuple`3<string, string, ILType>> flds, ILMemberAccess access, FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports);
    internal static FSharpList`1<Tuple`3<a, a, b>> addParamNames(FSharpList`1<Tuple`2<a, b>> flds);
    internal static ILMethodDef mkILSimpleStorageCtor(FSharpOption`1<ILTypeSpec> baseTySpec, ILType ty, FSharpList`1<ILParameter> extraParams, FSharpList`1<Tuple`2<string, ILType>> flds, ILMemberAccess access, FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports);
    internal static ILMethodDef mkILStorageCtor(FSharpList`1<ILInstr> preblock, ILType ty, FSharpList`1<Tuple`2<string, ILType>> flds, ILMemberAccess access, FSharpOption`1<ILDebugPoint> tag, FSharpOption`1<ILDebugImports> imports);
    internal static ILTypeDef mkILGenericClass(string nm, ILTypeDefAccess access, FSharpList`1<ILGenericParameterDef> genparams, ILType extends, FSharpList`1<ILType> impl, ILMethodDefs methods, ILFieldDefs fields, ILTypeDefs nestedTypes, ILPropertyDefs props, ILEventDefs events, ILAttributes attrs, ILTypeInit init);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef mkRawDataValueTypeDef(ILType iltyp_ValueType, string nm, int size, ushort pack);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef mkILSimpleClass(ILGlobals ilg, string nm, ILTypeDefAccess access, ILMethodDefs methods, ILFieldDefs fields, ILTypeDefs nestedTypes, ILPropertyDefs props, ILEventDefs events, ILAttributes attrs, ILTypeInit init);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef mkILTypeDefForGlobalFunctions(ILGlobals ilg, ILMethodDefs methods, ILFieldDefs fields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILTypeDef> destTypeDefsWithGlobalFunctionsFirst(ILGlobals ilg, ILTypeDefs tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ILModuleDef mkILSimpleModule(string assemblyName, string moduleName, bool dll, Tuple`2<int, int> subsystemVersion, bool useHighEntropyVA, ILTypeDefs tdefs, FSharpOption`1<int> hashalg, FSharpOption`1<string> locale, int flags, ILExportedTypesAndForwarders exportedTypes, string metadataVersion);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode buildILCode(string _methName, Dictionary`2<int, int> lab2pc, ILInstr[] instrs, FSharpList`1<ILExceptionSpec> tryspecs, FSharpList`1<ILLocalDebugInfo> localspecs);
    internal static ILMethodDef one@4333(ILMemberAccess access, string nm, FSharpList`1<ILParameter> args, ILType ret);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILMethodDef> mkILDelegateMethods(ILMemberAccess access, ILGlobals ilg, ILType iltyp_AsyncCallback, ILType iltyp_IAsyncResult, FSharpList`1<ILParameter> parms, ILReturn rtv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodSpec mkCtorMethSpecForDelegate(ILGlobals ilg, ILType ty, bool useUIntPtr);
    internal static ILType getTyOfILEnumInfo(ILEnumInfo info);
    internal static ILEnumInfo computeILEnumInfo(string mdName, ILFieldDefs mdFields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<byte, int> sigptr_get_u8(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<sbyte, int> sigptr_get_i8(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ushort, int> sigptr_get_u16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<short, int> sigptr_get_i16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptr_get_i32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<UInt32, int> sigptr_get_u32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<long, int> sigptr_get_i64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ulong, int> sigptr_get_u64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<float, int> sigptr_get_ieee32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<double, int> sigptr_get_ieee64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Byte[], int> sigptr_get_intarray(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptr_get_string(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptr_get_z_i32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptr_get_serstring(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<string>, int> sigptr_get_serstring_possibly_null(Byte[] bytes, int sigptr);
    internal static ILAssemblyRef mkRefToILAssembly(ILAssemblyManifest m);
    internal static Byte[] z_unsigned_int(int n);
    internal static Byte[] u16AsBytes(ushort x);
    internal static Byte[] i32AsBytes(int i);
    internal static Byte[] i64AsBytes(long i);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_BOOLEAN();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_CHAR();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U1();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_I8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_U8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R4();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_R8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_STRING();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_OBJECT();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static byte get_et_SZARRAY();
    internal static string formatILVersion(ILVersionInfo version);
    internal static Byte[] encodeCustomAttrString(string s);
    internal static Byte[] encodeCustomAttrElemType(ILType x);
    internal static Byte[] encodeCustomAttrElemTypeForObject(ILAttribElem x);
    internal static TimeSpan get_tspan();
    internal static DateTime get_copyOfStruct@4666-1();
    internal static void set_copyOfStruct@4666-1(DateTime value);
    internal static DateTime get_copyOfStruct@4666-2();
    internal static void set_copyOfStruct@4666-2(DateTime value);
    internal static ushort zero32@4695(int n);
    internal static ILVersionInfo parseILVersion(string vstr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compareILVersions(ILVersionInfo version1, ILVersionInfo version2);
    internal static ILScopeRef get_DummyFSharpCoreScopeRef();
    internal static ILGlobals get_PrimaryAssemblyILGlobals();
    internal static ILScopeRef get_primaryScopeRef@3480();
    internal static FSharpList`1<ILAssemblyRef> get_equivPrimaryAssemblyRefs@3480();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILType, int> decodeCustomAttrElemType(Byte[] bytes, int sigptr, byte x);
    internal static Byte[] encodeCustomAttrPrimValue(ILAttribElem c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] encodeCustomAttrValue(ILType ty, ILAttribElem c);
    internal static Byte[] encodeCustomAttrNamedArg(string nm, ILType ty, bool prop, ILAttribElem elem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] encodeCustomAttrArgs(ILMethodSpec mspec, FSharpList`1<ILAttribElem> fixedArgs, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> namedArgs);
    internal static ILAttribute encodeCustomAttr(ILMethodSpec mspec, FSharpList`1<ILAttribElem> fixedArgs, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> namedArgs);
    internal static ILAttribute mkILCustomAttribMethRef(ILMethodSpec mspec, FSharpList`1<ILAttribElem> fixedArgs, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> namedArgs);
    internal static ILAttribute mkILCustomAttribute(ILTypeRef tref, FSharpList`1<ILType> argTys, FSharpList`1<ILAttribElem> argvs, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> propvs);
    internal static Byte[] getCustomAttrData(ILAttribute cattr);
    internal static ILSecurityDecl mkPermissionSet(ILSecurityAction action, FSharpList`1<Tuple`2<ILTypeRef, FSharpList`1<Tuple`3<string, ILType, ILAttribElem>>>> attributes);
    internal static string grabScopeComponent@4999(ILTypeSigParser x, Unit unitVar0);
    internal static Tuple`2<FSharpList`1<ILAttribElem>, int> parseElems@5145(Byte[] bytes, ILType elemTy, FSharpList`1<ILAttribElem> acc, int n, int sigptr);
    internal static Tuple`2<ILAttribElem, int> parseVal@5079(Byte[] bytes, ILType argTy, int sigptr);
    internal static Tuple`2<FSharpList`1<ILAttribElem>, int> parseFixed@5159(Byte[] bytes, FSharpList`1<ILType> argTys, int sigptr);
    internal static FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> parseNamed@5170(Byte[] bytes, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>> acc, int n, int sigptr);
    internal static Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>> decodeILAttribData(ILAttribute ca);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@5214-16(ILReferences this, ILReferences obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@5214-17(IComparer comp, ILReferences this, ILReferences objTemp, Unit unitVar);
    internal static ILReferences get_emptyILRefs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfScopeRef(ILReferencesAccumulator s, ILScopeRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILType(ILReferencesAccumulator s, ILType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILTypeSpec(ILReferencesAccumulator s, ILTypeSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILCallsig(ILReferencesAccumulator s, ILCallingSignature csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILGenericParams(ILReferencesAccumulator s, FSharpList`1<ILGenericParameterDef> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILMethodRef(ILReferencesAccumulator s, ILMethodRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILFieldRef(ILReferencesAccumulator s, ILFieldRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILOverridesSpec(ILReferencesAccumulator s, ILOverridesSpec _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILMethodSpec(ILReferencesAccumulator s, ILMethodSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILTypes(ILReferencesAccumulator s, FSharpList`1<ILType> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILToken(ILReferencesAccumulator s, ILToken x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILCustomAttrElem(ILReferencesAccumulator s, ILAttribElem elem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILCustomAttrElems(ILReferencesAccumulator s, FSharpList`1<ILAttribElem> els);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILCustomAttrs(ILReferencesAccumulator s, ILAttributes cas);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILVarArgs(ILReferencesAccumulator s, FSharpOption`1<FSharpList`1<ILType>> tyso);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILInstr(ILReferencesAccumulator s, ILInstr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILCode(ILReferencesAccumulator s, ILCode c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILMethodBody(ILReferencesAccumulator s, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILLocal(ILReferencesAccumulator s, ILLocal loc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfMethodBody(ILReferencesAccumulator s, MethodBody x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILMethodDef(ILReferencesAccumulator s, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILParam(ILReferencesAccumulator s, ILParameter p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILReturn(ILReferencesAccumulator s, ILReturn rt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILMethodDefs(ILReferencesAccumulator s, IEnumerable`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILEventDef(ILReferencesAccumulator s, ILEventDef ed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILEventDefs(ILReferencesAccumulator s, ILEventDefs x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILPropertyDef(ILReferencesAccumulator s, ILPropertyDef pd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILPropertyDefs(ILReferencesAccumulator s, ILPropertyDefs x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILFieldDef(ILReferencesAccumulator s, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILFieldDefs(ILReferencesAccumulator s, FSharpList`1<b> fields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILMethodImpls(ILReferencesAccumulator s, FSharpList`1<ILMethodImplDef> mimpls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILMethodImpl(ILReferencesAccumulator s, ILMethodImplDef m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILTypeDef(ILReferencesAccumulator s, ILTypeDef td);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILTypeDefs(ILReferencesAccumulator s, ILTypeDefs types);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILExportedTypes(ILReferencesAccumulator s, ILExportedTypesAndForwarders tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILResourceLocation(ILReferencesAccumulator s, ILResourceLocation x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILResource(ILReferencesAccumulator s, ILResource x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILResources(ILReferencesAccumulator s, ILResources tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILModule(ILReferencesAccumulator s, ILModuleDef m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void refsOfILManifest(ILReferencesAccumulator s, ILAssemblyManifest m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILReferences computeILRefs(ILGlobals ilg, ILModuleDef modul);
    internal static ILTypeRef unscopeILTypeRef(ILTypeRef x);
    internal static ILTypeSpec unscopeILTypeSpec(ILTypeSpec tspec);
    internal static ILType unscopeILType(ILType ty);
    internal static FSharpList`1<ILType> unscopeILTypes(FSharpList`1<ILType> i);
    internal static ILCallingSignature unscopeILCallSig(ILCallingSignature csig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef resolveILMethodRefWithRescope(FSharpFunc`2<ILType, ILType> r, ILTypeDef td, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef resolveILMethodRef(ILTypeDef td, ILMethodRef mref);
    internal static ILModuleRef mkRefToILModule(ILModuleDef m);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILAsciiWriter : object {
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.AbstractIL.ILBinaryReader : object {
    [DebuggerBrowsableAttribute("0")]
internal static T1063279_32Bytes@ field1063280@;
    internal static bool checking { get; }
    internal static bool logging { get; }
    [CompilationMappingAttribute("9")]
internal static bool noStableFileHeuristic { get; }
    [CompilationMappingAttribute("9")]
internal static bool alwaysMemoryMapFSC { get; }
    internal static int stronglyHeldReaderCacheSizeDefault { get; }
    [CompilationMappingAttribute("9")]
internal static int stronglyHeldReaderCacheSize { get; }
    [CompilationMappingAttribute("9")]
internal static Statistics stats { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<ILInstrDecoder[]> oneByteInstrs { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<ILInstrDecoder[]> twoByteInstrs { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindAssemblyRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindModuleRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFileRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindTypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindTypeSpec { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindTypeDef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindPropertyMap { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindEventMap { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindInterfaceImpl { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindNested { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindCustomAttribute { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindDeclSecurity { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMemberRef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindStandAloneSig { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFieldRVA { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFieldMarshal { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindConstant { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindFieldLayout { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindParam { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMethodImpl { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindImplMap { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMethodSemantics { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindProperty { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindEvent { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindManifestResource { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindClassLayout { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindExportedType { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindAssembly { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindGenericParam_v2_0 { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindMethodSpec { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindGenericParamConstraint { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindModule { get; }
    [CompilationMappingAttribute("9")]
internal static RowKind kindIllegal { get; }
    [CompilationMappingAttribute("9")]
internal static AgedLookup`3<ILModuleReaderCache1LockToken, ILModuleReaderCacheKey, ILModuleReader> ilModuleReaderCache1 { get; }
    [CompilationMappingAttribute("9")]
internal static Lock`1<ILModuleReaderCache1LockToken> ilModuleReaderCache1Lock { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<ILModuleReaderCacheKey, WeakReference`1<ILModuleReader>> ilModuleReaderCache2 { get; }
    private static ILBinaryReader();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_checking();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_logging();
    internal static bool get_noStableFileHeuristic();
    internal static bool get_alwaysMemoryMapFSC();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_stronglyHeldReaderCacheSizeDefault();
    internal static int get_stronglyHeldReaderCacheSize();
    internal static Tuple`2<TableName, int> i32ToUncodedToken(int tok);
    internal static TaggedIndex`1<TypeDefOrRefTag> uncodedTokenToTypeDefOrRefOrSpec(TableName tab, int tok);
    internal static TaggedIndex`1<MethodDefOrRefTag> uncodedTokenToMethodDefOrRef(TableName tab, int tok);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@123-21(Statistics this, Statistics obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@123-22(Statistics this, Statistics objTemp, Unit unitVar);
    internal static Statistics get_stats();
    internal static Statistics GetStatistics();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static long seekReadInt64(ReadOnlyByteMemory mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueTuple`2<int, int> seekReadCompressedUInt32(ReadOnlyByteMemory mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekCountUtf8String(ReadOnlyByteMemory mdv, int addr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string seekReadUTF8String(ReadOnlyByteMemory mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] seekReadBlob(ReadOnlyByteMemory mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string seekReadUserString(ReadOnlyByteMemory mdv, int addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, int> sigptrGetBool(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<sbyte, int> sigptrGetSByte(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ushort, int> sigptrGetUInt16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<short, int> sigptrGetInt16(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> sigptrGetInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<UInt32, int> sigptrGetUInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ulong, int> sigptrGetUInt64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<long, int> sigptrGetInt64(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<float, int> sigptrGetSingle(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<double, int> sigptrGetDouble(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueTuple`2<int, int> sigptrGetZInt32(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<a>, int> sigptrFoldAcc(FSharpFunc`2<Byte[], FSharpFunc`2<int, Tuple`2<a, int>>> f, int n, Byte[] bytes, int sigptr, int i, FSharpList`1<a> acc);
    internal static ValueTuple`2<FSharpList`1<b>, int> sigptrFoldAcc@424(FSharpFunc`2<Byte[], FSharpFunc`2<int, ValueTuple`2<b, int>>> f, int n, Byte[] bytes, int sigptr, int i, FSharpList`1<b> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueTuple`2<FSharpList`1<a>, int> sigptrFoldStruct(FSharpFunc`2<Byte[], FSharpFunc`2<int, ValueTuple`2<a, int>>> f, int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Byte[], int> sigptrGetBytes(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, int> sigptrGetString(int n, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a noPrefixes(a mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a volatileOrUnalignedPrefix(FSharpFunc`2<Tuple`2<ILAlignment, ILVolatility>, a> mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a volatilePrefix(FSharpFunc`2<ILVolatility, a> mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a tailPrefix(FSharpFunc`2<ILTailcall, a> mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a constraintOrTailPrefix(FSharpFunc`2<Tuple`2<FSharpOption`1<ILType>, ILTailcall>, a> mk, ILInstrPrefixesRegister prefixes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a readonlyPrefix(FSharpFunc`2<ILReadonly, a> mk, ILInstrPrefixesRegister prefixes);
    internal static FSharpFunc`2<ILInstrPrefixesRegister, ILInstr> mkStind(ILBasicType dt);
    internal static FSharpFunc`2<ILInstrPrefixesRegister, ILInstr> mkLdind(ILBasicType dt);
    internal static FSharpList`1<Tuple`2<int, ILInstrDecoder>> instrs();
    internal static FSharpOption`1<ILInstrDecoder[]> get_oneByteInstrs();
    internal static void set_oneByteInstrs(FSharpOption`1<ILInstrDecoder[]> value);
    internal static FSharpOption`1<ILInstrDecoder[]> get_twoByteInstrs();
    internal static void set_twoByteInstrs(FSharpOption`1<ILInstrDecoder[]> value);
    internal static void addInstr@701(ILInstrDecoder[] oneByteInstrTable, ILInstrDecoder[] twoByteInstrTable, int i, ILInstrDecoder f);
    internal static void fillInstrs();
    internal static ILInstrDecoder getOneByteInstr(int i);
    internal static ILInstrDecoder getTwoByteInstr(int i);
    internal static RowKind get_kindAssemblyRef();
    internal static RowKind get_kindModuleRef();
    internal static RowKind get_kindFileRef();
    internal static RowKind get_kindTypeRef();
    internal static RowKind get_kindTypeSpec();
    internal static RowKind get_kindTypeDef();
    internal static RowKind get_kindPropertyMap();
    internal static RowKind get_kindEventMap();
    internal static RowKind get_kindInterfaceImpl();
    internal static RowKind get_kindNested();
    internal static RowKind get_kindCustomAttribute();
    internal static RowKind get_kindDeclSecurity();
    internal static RowKind get_kindMemberRef();
    internal static RowKind get_kindStandAloneSig();
    internal static RowKind get_kindFieldDef();
    internal static RowKind get_kindFieldRVA();
    internal static RowKind get_kindFieldMarshal();
    internal static RowKind get_kindConstant();
    internal static RowKind get_kindFieldLayout();
    internal static RowKind get_kindParam();
    internal static RowKind get_kindMethodDef();
    internal static RowKind get_kindMethodImpl();
    internal static RowKind get_kindImplMap();
    internal static RowKind get_kindMethodSemantics();
    internal static RowKind get_kindProperty();
    internal static RowKind get_kindEvent();
    internal static RowKind get_kindManifestResource();
    internal static RowKind get_kindClassLayout();
    internal static RowKind get_kindExportedType();
    internal static RowKind get_kindAssembly();
    internal static RowKind get_kindGenericParam_v2_0();
    internal static RowKind get_kindMethodSpec();
    internal static RowKind get_kindGenericParamConstraint();
    internal static RowKind get_kindModule();
    internal static RowKind get_kindIllegal();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hcCompare(TaggedIndex`1<HasConstantTag> _arg2, TaggedIndex`1<HasConstantTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hsCompare(TaggedIndex`1<HasSemanticsTag> _arg2, TaggedIndex`1<HasSemanticsTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hcaCompare(TaggedIndex`1<HasCustomAttributeTag> _arg2, TaggedIndex`1<HasCustomAttributeTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int mfCompare(TaggedIndex`1<MemberForwardedTag> _arg2, TaggedIndex`1<MemberForwardedTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hdsCompare(TaggedIndex`1<HasDeclSecurityTag> _arg2, TaggedIndex`1<HasDeclSecurityTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int hfmCompare(TaggedIndex`1<HasFieldMarshalTag> _arg2, TaggedIndex`1<HasFieldMarshalTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int tomdCompare(TaggedIndex`1<TypeOrMethodDefTag> _arg2, TaggedIndex`1<TypeOrMethodDefTag> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpFunc`2<int, d>, FSharpFunc`2<int, d>> mkCacheInt32(bool lowMem, a _inbase, b _nm, c _sz);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpFunc`2<T, d>, FSharpFunc`2<T, d>> mkCacheGeneric(bool lowMem, a _inbase, b _nm, c _sz);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<c> seekReadIndexedRows$cont@995(FSharpFunc`2<int, a> rowReader, FSharpFunc`2<a, c> rowConverter, int numRows, FSharpFunc`2<a, b> keyFunc, FSharpFunc`2<b, int> keyComparer, Unit unitVar);
    internal static FSharpList`1<c> seekReadIndexedRows(int numRows, FSharpFunc`2<int, a> rowReader, FSharpFunc`2<a, b> keyFunc, FSharpFunc`2<b, int> keyComparer, bool binaryChop, FSharpFunc`2<a, c> rowConverter);
    internal static FSharpOption`1<c> seekReadOptionalIndexedRow(int info_0, FSharpFunc`2<int, a> info_1, FSharpFunc`2<a, b> info_2, FSharpFunc`2<b, int> info_3, bool info_4, FSharpFunc`2<a, c> info_5);
    internal static c seekReadIndexedRow(int info_0, FSharpFunc`2<int, a> info_1, FSharpFunc`2<a, b> info_2, FSharpFunc`2<b, int> info_3, bool info_4, FSharpFunc`2<a, c> info_5);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1099-23(MethodData thisCast, MethodData objCast, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1099-24(IComparer comp, MethodData thisCastu, MethodData thatCastu, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1099-6(MethodData this, MethodData that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1102-25(VarArgMethodData thisCast, VarArgMethodData objCast, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@1102-26(IComparer comp, VarArgMethodData thisCastu, VarArgMethodData thatCastu, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@1101-3(IEqualityComparer comp, VarArgMethodData this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@1102-7(VarArgMethodData this, VarArgMethodData that, IEqualityComparer comp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b[] seekReadIndexedRowsByInterface(int numRows, bool binaryChop, ISeekReadIndexedRowReader`3<RowT, a, b> reader);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadUInt16AsInt32Adv(ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadIdx(bool big, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<ResolutionScopeTag> seekReadResolutionScopeIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<TypeDefOrRefTag> seekReadTypeDefOrRefOrSpecIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<TypeOrMethodDefTag> seekReadTypeOrMethodDefIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<HasConstantTag> seekReadHasConstantIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<HasCustomAttributeTag> seekReadHasCustomAttributeIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<HasFieldMarshalTag> seekReadHasFieldMarshalIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<HasDeclSecurityTag> seekReadHasDeclSecurityIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<MemberRefParentTag> seekReadMemberRefParentIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<HasSemanticsTag> seekReadHasSemanticsIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<MethodDefOrRefTag> seekReadMethodDefOrRefIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<MemberForwardedTag> seekReadMemberForwardedIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<ImplementationTag> seekReadImplementationIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedIndex`1<CustomAttributeTypeTag> seekReadCustomAttributeTypeIdx(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, Int32& addr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<ushort, int, int, int, int> seekReadModuleRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TaggedIndex`1<ResolutionScopeTag>, int, int> seekReadTypeRefRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<int, int, int, TaggedIndex`1<TypeDefOrRefTag>, int, int> seekReadTypeDefRowUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> seekReadFieldRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<int, int, int, int, int, int> seekReadMethodRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> seekReadParamRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, TaggedIndex`1<TypeDefOrRefTag>> seekReadInterfaceImplRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TaggedIndex`1<MemberRefParentTag>, int, int> seekReadMemberRefRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ushort, TaggedIndex`1<HasConstantTag>, int> seekReadConstantRowUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void seekReadCustomAttributeRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx, CustomAttributeRow& attrRow);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TaggedIndex`1<HasFieldMarshalTag>, int> seekReadFieldMarshalRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ushort, TaggedIndex`1<HasDeclSecurityTag>, int> seekReadPermissionRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ushort, int, int> seekReadClassLayoutRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadFieldLayoutRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadStandAloneSigRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadEventMapRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, TaggedIndex`1<TypeDefOrRefTag>> seekReadEventRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadPropertyMapRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> seekReadPropertyRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, TaggedIndex`1<HasSemanticsTag>> seekReadMethodSemanticsRowUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, TaggedIndex`1<MethodDefOrRefTag>, TaggedIndex`1<MethodDefOrRefTag>> seekReadMethodImplRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadModuleRefRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int seekReadTypeSpecRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<int, TaggedIndex`1<MemberForwardedTag>, int, int> seekReadImplMapRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadFieldRVARow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<int, ushort, ushort, ushort, ushort, int, int, Tuple`2<int, int>> seekReadAssemblyRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<ushort, ushort, ushort, ushort, int, int, int, Tuple`2<int, int>> seekReadAssemblyRefRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, int, int> seekReadFileRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<int, int, int, int, TaggedIndex`1<ImplementationTag>> seekReadExportedTypeRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<int, int, int, TaggedIndex`1<ImplementationTag>> seekReadManifestResourceRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> seekReadNestedRowUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<int, ushort, ushort, TaggedIndex`1<TypeOrMethodDefTag>, int> seekReadGenericParamRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, TaggedIndex`1<TypeDefOrRefTag>> seekReadGenericParamConstraintRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TaggedIndex`1<MethodDefOrRefTag>, int> seekReadMethodSpecRow(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string readUserStringHeapUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string readStringHeapUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> readStringHeapOption(ILMetadataReader ctxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] readBlobHeapUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Byte[]> readBlobHeapOption(ILMetadataReader ctxt, int idx);
    internal static FSharpList`1<ILNativeResource> readNativeResources(PEReader pectxt);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<int> getDataEndPointsDelayed$cont@1789(PEReader pectxt, ILMetadataReader ctxt, ReadOnlyByteMemory mdv, FSharpList`1<Tuple`2<string, int>> dataStartPoints, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<FSharpList`1<int>> getDataEndPointsDelayed(PEReader pectxt, FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH);
    internal static Byte[] look@1838-1(ILMetadataReader ctxt, PEReader pectxt, string nm, int rva, int start, FSharpList`1<int> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] rvaToData(ILMetadataReader ctxt, PEReader pectxt, string nm, int rva);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSorted(ILMetadataReader ctxt, TableName tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef seekReadModule(ILMetadataReader ctxt, bool canReduceMemory, PEReader pectxtEager, ReadOnlyByteMemory pevEager, ushort subsys, Tuple`2<int, int> subsysversion, bool useHighEntropyVA, bool ilOnly, bool only32, bool is32bitpreferred, bool only64, FSharpOption`1<ILPlatform> platform, bool isDll, int alignVirt, int alignPhys, int imageBaseReal, string ilMetadataVersion, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAssemblyManifest seekReadAssemblyManifest(ILMetadataReader ctxt, PEReader pectxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAssemblyRef seekReadAssemblyRefUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleRef seekReadModuleRef(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleRef seekReadFile(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefLayoutInfo seekReadClassLayout(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int idx);
    internal static ILTypeDefAccess typeAccessOfFlags(int flags);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefLayout typeLayoutOfFlags(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int flags, int tidx);
    internal static bool isTopTypeDef(int flags);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<string>, string> readBlobHeapAsSplitTypeName(ILMetadataReader ctxt, int nameIdx, int namespaceIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string readBlobHeapAsTypeName(ILMetadataReader ctxt, int nameIdx, int namespaceIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueTuple`2<int, int> seekReadTypeDefRowExtents(ILMetadataReader ctxt, a _info, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`6<int, int, int, TaggedIndex`1<TypeDefOrRefTag>, int, int>, ValueTuple`2<int, int>> seekReadTypeDefRowWithExtents(ILMetadataReader ctxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILPreTypeDef> seekReadPreTypeDef(ILMetadataReader ctxt, bool toponly, int idx);
    internal static ILTypeDefStored typeDefReader(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH);
    internal static ILPreTypeDef[] seekReadTopTypeDefs(ILMetadataReader ctxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefs seekReadNestedTypeDefs(ILMetadataReader ctxt, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> seekReadInterfaceImpls(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int numTypars, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILGenericParameterDef> seekReadGenericParams(ILMetadataReader ctxt, int numTypars, TypeOrMethodDefTag a, int b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILGenericParameterDef> seekReadGenericParamsUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, GenericParamsIdx _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> seekReadGenericParamConstraints(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int numTypars, int gpidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType seekReadTypeDefAsTypeUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, TypeDefAsTypIdx _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef seekReadTypeDefAsTypeRef(ILMetadataReader ctxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef seekReadTypeRefUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType seekReadTypeRefAsTypeUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, TypeRefAsTypIdx _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType seekReadTypeDefOrRef(ILMetadataReader ctxt, int numTypars, ILBoxity boxity, FSharpList`1<ILType> ginst, TaggedIndex`1<TypeDefOrRefTag> _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef seekReadTypeDefOrRefAsTypeRef(ILMetadataReader ctxt, TaggedIndex`1<TypeDefOrRefTag> _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType seekReadMethodRefParent(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int numTypars, TaggedIndex`1<MemberRefParentTag> _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarArgMethodData seekReadMethodDefOrRef(ILMetadataReader ctxt, int numTypars, TaggedIndex`1<MethodDefOrRefTag> _arg7);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodData seekReadMethodDefOrRefNoVarargs(ILMetadataReader ctxt, int numTypars, TaggedIndex`1<MethodDefOrRefTag> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodSpec seekReadCustomAttrType(ILMetadataReader ctxt, TaggedIndex`1<CustomAttributeTypeTag> _arg8);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILScopeRef seekReadImplAsScopeRef(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, TaggedIndex`1<ImplementationTag> _arg9);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILScopeRef, FSharpList`1<string>> seekReadTypeRefScope(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, TaggedIndex`1<ResolutionScopeTag> _arg10);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILType> seekReadOptionalTypeDefOrRef(ILMetadataReader ctxt, int numTypars, ILBoxity boxity, TaggedIndex`1<TypeDefOrRefTag> idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldDef seekReadField(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int numTypars, bool hasLayout, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldDefs seekReadFields(ILMetadataReader ctxt, int numTypars, bool hasLayout, int fidx1, int fidx2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDefs seekReadMethods(ILMetadataReader ctxt, int numTypars, int midx1, int midx2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TaggedIndex`1<TypeDefOrRefTag>, int> sigptrGetTypeDefOrRefOrSpecIdx(Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILType, int> sigptrGetTy(ILMetadataReader ctxt, int numTypars, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<ILType>, FSharpOption`1<FSharpList`1<ILType>>>, int> sigptrGetArgTys(ILMetadataReader ctxt, int n, int numTypars, Byte[] bytes, int sigptr, FSharpList`1<ILType> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILLocal, int> sigptrGetLocal(ILMetadataReader ctxt, int numTypars, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<bool, int, ILCallingConv, ILType, FSharpList`1<ILType>, FSharpOption`1<FSharpList`1<ILType>>> readBlobHeapAsMethodSigUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, BlobAsMethodSigIdx _arg11);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType readBlobHeapAsType(ILMetadataReader ctxt, int numTypars, int blobIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType readBlobHeapAsFieldSig(ILMetadataReader ctxt, int numTypars, int blobIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType readBlobHeapAsFieldSigUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, BlobAsFieldSigIdx _arg12);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ILThisConvention, ILType, FSharpList`1<ILType>> readBlobHeapAsPropertySigUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, BlobAsPropSigIdx _arg13);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILLocal> readBlobHeapAsLocalsSigUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, BlobAsLocalSigIdx _arg14);
    internal static ILThisConvention byteAsHasThis(byte b);
    internal static Tuple`2<bool, ILCallingConv> byteAsCallConv(byte b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarArgMethodData seekReadMemberRefAsMethodData(ILMetadataReader ctxt, int numTypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarArgMethodData seekReadMemberRefAsMethodDataUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, MemberRefAsMspecIdx _arg15);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodData seekReadMemberRefAsMethDataNoVarArgs(ILMetadataReader ctxt, int numTypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static VarArgMethodData seekReadMethodSpecAsMethodDataUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, MethodSpecAsMspecIdx _arg16);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec seekReadMemberRefAsFieldSpecUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, MemberRefAsFspecIdx _arg17);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodData seekReadMethodDefAsMethodData(ILMetadataReader ctxt, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodData seekReadMethodDefAsMethodDataUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec seekReadFieldDefAsFieldSpecUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef seekReadMethod(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int numTypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILReturn, FSharpList`1<ILParameter>> seekReadParams(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, ILType retTy, FSharpList`1<ILType> argTys, int pidx1, int pidx2);
    internal static ILNativeType fmReader@2944(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, TaggedIndex`1<HasFieldMarshalTag> idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void seekReadParamExtras(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, ILReturn& retRes, ILParameter[] paramsRes, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodImplDefs seekReadMethodImpls(ILMetadataReader ctxt, int numTypars, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILMethodRef> seekReadMultipleMethodSemantics(ILMetadataReader ctxt, int flags, TaggedIndex`1<HasSemanticsTag> id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILMethodRef> seekReadOptionalMethodSemantics(ILMetadataReader ctxt, int id_0, TaggedIndex`1<HasSemanticsTag> id_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodRef seekReadMethodSemantics(ILMetadataReader ctxt, int id_0, TaggedIndex`1<HasSemanticsTag> id_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDef seekReadEvent(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int numTypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDefs seekReadEvents(ILMetadataReader ctxt, int numTypars, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDef seekReadProperty(ILMetadataReader ctxt, ReadOnlyByteMemory mdv, int numTypars, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDefs seekReadProperties(ILMetadataReader ctxt, int numTypars, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttributesStored customAttrsReader(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, HasCustomAttributeTag tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute seekReadCustomAttr(ILMetadataReader ctxt, TaggedIndex`1<CustomAttributeTypeTag> _arg18, int b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute seekReadCustomAttrUncached(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, CustomAttrIdx _arg19);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILSecurityDeclsStored securityDeclsReader(FSharpRef`1<FSharpOption`1<ILMetadataReader>> ctxtH, HasDeclSecurityTag tag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILSecurityDecl seekReadSecurityDecl(ILMetadataReader ctxt, ushort act, int ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldInit seekReadConstant(ILMetadataReader ctxt, TaggedIndex`1<HasConstantTag> idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<MethodBody> seekReadImplMap(ILMetadataReader ctxt, string nm, int midx);
    internal static int rawToLabel@3348(Dictionary`2<int, int> labelsOfRawOffsets, int rawOffset);
    internal static void get@3376(ReadOnlyByteMemory pev, int sz, int start, FSharpRef`1<int> curr, FSharpRef`1<int> lastb, FSharpRef`1<int> lastb2, FSharpRef`1<int> b, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ILInstr[], FSharpFunc`2<int, int>, Dictionary`2<int, int>> seekReadTopCode(ILMetadataReader ctxt, ReadOnlyByteMemory pev, ReadOnlyByteMemory mdv, int numTypars, int sz, int start);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<MethodBody> seekReadMethodRVA(PEReader pectxt, ILMetadataReader ctxt, string nm, bool noinline, bool aggressiveinline, int numTypars, int rva);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILNativeVariant int32AsILVariantType(ILMetadataReader ctxt, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILNativeType readBlobHeapAsNativeType(ILMetadataReader ctxt, int blobIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILNativeType, int> sigptrGetILNativeType(ILMetadataReader ctxt, Byte[] bytes, int sigptr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILResources seekReadManifestResources(ILMetadataReader ctxt, bool canReduceMemory, ReadOnlyByteMemory mdv, PEReader pectxtEager, ReadOnlyByteMemory pevEager);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILNestedExportedTypes seekReadNestedExportedTypes(ILMetadataReader ctxt, Tuple`5[] exported, Lazy`1<FSharpList`1[]> nested, int parentIdx);
    internal static ILExportedTypesAndForwarders seekReadTopExportedTypes(ILMetadataReader ctxt);
    internal static FSharpOption`1<Tuple`2<int, int>> look@4070-6(int metadataPhysLoc, ReadOnlyByteMemory mdv, int numStreams, Int32[] name, int i, int pos);
    internal static FSharpOption`1<Tuple`2<int, int>> tryFindStream@4069(int metadataPhysLoc, ReadOnlyByteMemory mdv, int numStreams, int streamHeadersStart, Int32[] name);
    internal static Tuple`2<int, int> findStream@4097(int metadataPhysLoc, ReadOnlyByteMemory mdv, int numStreams, int streamHeadersStart, Int32[] name);
    internal static bool codedBigness@4227(Int32[] numRows, int nbits, TableName tab);
    [CompilerGeneratedAttribute]
internal static int rowKindSize$cont@4306(bool stringsBigness, bool guidsBigness, bool blobsBigness, Boolean[] tableBigness, bool tdorBigness, bool tomdBigness, bool hcBigness, bool hcaBigness, bool hfmBigness, bool hdsBigness, bool mrpBigness, bool hsBigness, bool mdorBigness, bool mfBigness, bool iBigness, bool catBigness, bool rsBigness, FSharpList`1<RowElementKind> kinds, Unit unitVar);
    internal static int rowKindSize@4304(bool stringsBigness, bool guidsBigness, bool blobsBigness, Boolean[] tableBigness, bool tdorBigness, bool tomdBigness, bool hcBigness, bool hcaBigness, bool hfmBigness, bool hdsBigness, bool mrpBigness, bool hsBigness, bool mdorBigness, bool mfBigness, bool iBigness, bool catBigness, bool rsBigness, RowKind _arg1);
    internal static Tuple`2<ILModuleDef, Lazy`1<FSharpList`1<ILAssemblyRef>>> openMetadataReader(string fileName, BinaryFile mdfile, int metadataPhysLoc, Tuple`8<ushort, Tuple`2<int, int>, bool, bool, bool, bool, bool, Tuple`5<FSharpOption`1<ILPlatform>, bool, int, int, int>> peinfo, PEReader pectxtEager, ReadOnlyByteMemory pevEager, FSharpOption`1<PEReader> pectxtCaptured, bool reduceMemoryUsage);
    internal static int look@4670-7(ReadOnlyByteMemory pev, int numSections, int addr, int i, int pos);
    internal static int findSectionHeader@4669(ReadOnlyByteMemory pev, int numSections, int sectionHeadersStartPhysLoc, int addr);
    internal static int look@4729-8(string fileName, int numSections, int v, string n, ReadOnlyByteMemory pev, int i, int pos);
    internal static int anyV2P@4726(BinaryFile pefile, string fileName, int numSections, int sectionHeadersStartPhysLoc, Tuple`2<string, int> tupledArg);
    internal static Tuple`5<int, int, Tuple`8<ushort, Tuple`2<int, int>, bool, bool, bool, bool, bool, Tuple`5<FSharpOption`1<ILPlatform>, bool, int, int, int>>, PEReader, ReadOnlyByteMemory> openPEFileReader(string fileName, BinaryFile pefile, bool noFileOnDisk);
    internal static Tuple`2<ILModuleDef, Lazy`1<FSharpList`1<ILAssemblyRef>>> openPE(string fileName, BinaryFile pefile, bool reduceMemoryUsage, bool noFileOnDisk);
    internal static Tuple`2<ILModuleDef, Lazy`1<FSharpList`1<ILAssemblyRef>>> openPEMetadataOnly(string fileName, Tuple`8<ushort, Tuple`2<int, int>, bool, bool, bool, bool, bool, Tuple`5<FSharpOption`1<ILPlatform>, bool, int, int, int>> peinfo, PEReader pectxtEager, ReadOnlyByteMemory pevEager, BinaryFile mdfile, bool reduceMemoryUsage);
    internal static AgedLookup`3<ILModuleReaderCache1LockToken, ILModuleReaderCacheKey, ILModuleReader> get_ilModuleReaderCache1();
    internal static Lock`1<ILModuleReaderCache1LockToken> get_ilModuleReaderCache1Lock();
    internal static ConcurrentDictionary`2<ILModuleReaderCacheKey, WeakReference`1<ILModuleReader>> get_ilModuleReaderCache2();
    internal static bool stableFileHeuristicApplies(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static BinaryFile createByteFileChunk(ILReaderOptions opts, string fileName, FSharpOption`1<Tuple`2<int, int>> chunk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<IDisposable, BinaryFile> getBinaryFile(string fileName, bool useMemoryMappedFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleReader OpenILModuleReaderFromBytes(string fileName, Byte[] assemblyContents, ILReaderOptions options);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleReader OpenILModuleReaderFromStream(string fileName, Stream peStream, ILReaderOptions options);
    internal static void ClearAllILModuleReaderCache();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleReader OpenILModuleReader(string fileName, ILReaderOptions opts);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILBinaryWriter : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int EmitBytesViaBufferCapacity;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int CodeBufferCapacity;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int CodeChunkCapacity;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int DataCapacity;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int ResourceCapacity;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int TableCapacity;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int MetadataCapacity;
    [DebuggerBrowsableAttribute("0")]
internal static T1063321_32Bytes@ field1063322@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063323_48Bytes@ field1063324@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063321_32Bytes@ field1063325@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063321_32Bytes@ field1063326@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063327_128Bytes@ field1063328@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063329_4Bytes@ field1063330@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063329_4Bytes@ field1063331@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063332_8Bytes@ field1063333@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063329_4Bytes@ field1063334@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063332_8Bytes@ field1063335@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063329_4Bytes@ field1063336@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063332_8Bytes@ field1063337@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063329_4Bytes@ field1063338@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063332_8Bytes@ field1063339@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063329_4Bytes@ field1063340@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063341_14Bytes@ field1063342@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063341_14Bytes@ field1063343@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063344_12Bytes@ field1063345@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063332_8Bytes@ field1063346@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063347_1Bytes@ field1063348@;
    [CompilationMappingAttribute("9")]
internal static ILMethodBody ilMethodBodyThrowNull { get; }
    [CompilationMappingAttribute("9")]
internal static ILCode ilCode@2605 { get; }
    [CompilationMappingAttribute("9")]
internal static int timestamp { get; }
    [CompilationMappingAttribute("9")]
internal static Byte[] msdosHeader { get; }
    private static ILBinaryWriter();
    internal static Byte[] emitBytesViaBuffer(FSharpFunc`2<ByteBuffer, Unit> f);
    internal static int ByteBuffer.Z32Size.Static(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ByteBuffer.EmitZ32(ByteBuffer buf, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ByteBuffer.EmitPadding(ByteBuffer buf, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ByteBuffer.EmitZUntaggedIndex(ByteBuffer buf, bool big, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ByteBuffer.EmitZTaggedIndex(ByteBuffer buf, int tag, int nbits, bool big, int idx);
    internal static bool scan@112(Byte[] b, int len, int i);
    internal static int markerForUnicodeBytes(Byte[] b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkFixup32(Byte[] data, int offset, int exp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void applyFixup32(Byte[] data, int offset, int v);
    internal static RowElement Data(int x, bool k);
    internal static int hashRow(RowElement[] elems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equalRows(RowElement[] elems, RowElement[] elems2);
    internal static SharedRow AssemblyRefRow(ushort s1, ushort s2, ushort s3, ushort s4, int l1, int b1, int nameIdx, int str2, int b2);
    internal static SharedRow MemberRefRow(RowElement mrp, int nmIdx, int blobIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeWriterEnv envForMethodRef(ILTypeWriterEnv env, ILType ty);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@478-33(PropertyTableKey this, PropertyTableKey obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@478-34(IComparer comp, PropertyTableKey this, PropertyTableKey objTemp, Unit unitVar);
    internal static Tuple`2<int, int> metadataSchemaVersionSupportedByCLRVersion(ILVersionInfo v);
    internal static Tuple`2<int, int> headerVersionSupportedByCLRVersion(ILVersionInfo v);
    internal static int peOptionalHeaderByteByCLRVersion(ILVersionInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void recordRequiredDataFixup(FSharpRef`1<FSharpList`1<Tuple`2<T, U>>> requiredDataFixups, ByteBuffer buf, T pos, U lab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetBytesAsBlobIdx(cenv cenv, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetStringHeapIdx(cenv cenv, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetStringHeapIdxOption(cenv cenv, FSharpOption`1<string> sopt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<RowElement, RowElement> GetTypeNameAsElemPair(cenv cenv, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefPass1(FSharpList`1<string> enc, cenv cenv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefsPass1(FSharpList`1<string> enc, cenv cenv, FSharpList`1<ILTypeDef> tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetIdxForTypeDef(cenv cenv, TypeDefTableKey key);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetAssemblyRefAsRow(cenv cenv, ILAssemblyRef aref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetAssemblyRefAsIdx(cenv cenv, ILAssemblyRef aref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetModuleRefAsRow(cenv cenv, ILModuleRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetModuleRefAsFileRow(cenv cenv, ILModuleRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetModuleRefAsIdx(cenv cenv, ILModuleRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetModuleRefAsFileIdx(cenv cenv, ILModuleRef mref);
    internal static bool isScopeRefLocal(ILScopeRef scoref);
    internal static bool isTypeLocal(ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ImplementationTag, int> GetScopeRefAsImplementationElem(cenv cenv, ILScopeRef scoref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetTypeRefAsTypeRefRow(cenv cenv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetTypeRefAsTypeRefIdx(cenv cenv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ResolutionScopeTag, int> GetResolutionScopeAsElem(cenv cenv, ILScopeRef scoref, FSharpList`1<string> enc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int getTypeInfoAsTypeDefOrRefEncoded(cenv cenv, ILScopeRef scoref, FSharpList`1<string> enc, string nm);
    internal static int getTypeDefOrRefAsUncodedToken(TypeDefOrRefTag tag, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitArrayShape(ByteBuffer bb, ILArrayShape _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static byte callconvToByte(int ntypars, ILCallingConv _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitTypeSpec(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, byte et, ILTypeSpec tspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TypeDefOrRefTag, int> GetTypeAsTypeDefOrRef(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetTypeAsBytes(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetTypeOfLocalAsBytes(cenv cenv, ILTypeWriterEnv env, ILLocal l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetTypeAsTypeSpecRow(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetTypeAsTypeSpecIdx(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitType(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitLocalInfo(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, ILLocal l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitCallsig(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, ILCallingConv callconv, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, int genarity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetCallsigAsBytes(cenv cenv, ILTypeWriterEnv env, ILCallingConv x_0, FSharpList`1<ILType> x_1, ILType x_2, FSharpOption`1<FSharpList`1<ILType>> x_3, int x_4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitTypes(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, FSharpList`1<ILType> inst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RowElement GetTypeAsMemberRefParent(cenv cenv, ILTypeWriterEnv env, ILType ty);
    internal static int GetVariantTypeAsInt32(ILNativeVariant ty);
    internal static Byte[] GetNativeTypeAsBytes(ILNativeType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitNativeType(ByteBuffer bb, ILNativeType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldInitAsBlobIdx(cenv cenv, ILFieldInit x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GetFieldInit(ByteBuffer bb, ILFieldInit x);
    internal static RowElement GetFieldInitFlags(ILFieldInit i);
    internal static int GetMemberAccessFlags(ILMemberAccess access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethodDefIdxExists(cenv cenv, ILMethodRef mref);
    internal static TypeDefTableKey typeNameOfIdx@1092(cenv cenv, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int FindMethodDefIdx(cenv cenv, MethodDefKey mdkey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpResult`2<int, string> TryGetMethodRefAsMethodDefIdx(cenv cenv, ILMethodRef mref);
    [CompilerGeneratedAttribute]
internal static bool canGenMethodDef$cont@1151(cenv cenv, ILMethodDef mdef, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canGenMethodDef(ILTypeDef tdef, cenv cenv, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canGenFieldDef(ILTypeDef tdef, cenv cenv, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canGenEventDef(cenv cenv, ILEventDef ev);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canGenPropertyDef(cenv cenv, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetTypeDefAsRow(cenv cenv, ILTypeWriterEnv env, a _enc, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TypeDefOrRefTag, int> GetTypeOptionAsTypeDefOrRef(cenv cenv, ILTypeWriterEnv env, FSharpOption`1<ILType> tyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetTypeDefAsPropertyMapRow(cenv cenv, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetTypeDefAsEventMapRow(cenv cenv, int tidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenFieldDefPass2(ILTypeDef tdef, cenv cenv, int tidx, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodDefKey GetKeyForMethodDef(cenv cenv, int tidx, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodDefPass2(ILTypeDef tdef, cenv cenv, int tidx, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PropertyTableKey GetKeyForPropertyDef(int tidx, ILPropertyDef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenPropertyDefPass2(cenv cenv, int tidx, ILPropertyDef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetTypeAsImplementsRow(cenv cenv, ILTypeWriterEnv env, int tidx, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenImplementsPass2(cenv cenv, ILTypeWriterEnv env, int tidx, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenEventDefPass2(cenv cenv, int tidx, ILEventDef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefPass2(int pidx, FSharpList`1<string> enc, cenv cenv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefsPass2(int pidx, FSharpList`1<string> enc, cenv cenv, FSharpList`1<ILTypeDef> tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int FindFieldDefIdx(cenv cenv, FieldDefKey fdkey);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodRefAsMethodDefIdx(cenv cenv, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow MethodRefInfoAsMemberRefRow(cenv cenv, ILTypeWriterEnv env, ILTypeWriterEnv fenv, string nm, ILType ty, ILCallingConv callconv, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, int genarity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodRefInfoAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILCallingConv info_0, FSharpList`1<ILType> info_1, ILType info_2, FSharpOption`1<FSharpList`1<ILType>> info_3, int info_4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodRefInfoAsMemberRefIdx(cenv cenv, ILTypeWriterEnv env, string minfo_0, ILType ty, ILCallingConv minfo_2, FSharpList`1<ILType> minfo_3, ILType minfo_4, FSharpOption`1<FSharpList`1<ILType>> minfo_5, int minfo_6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MethodDefOrRefTag, int> GetMethodRefInfoAsMethodRefOrDef(bool isAlwaysMethodDef, cenv cenv, ILTypeWriterEnv env, string nm, ILType ty, ILCallingConv cc, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, int genarity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodSpecInfoAsMethodSpecIdx(cenv cenv, ILTypeWriterEnv env, string nm, ILType ty, ILCallingConv cc, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, FSharpList`1<ILType> minst);
    internal static int GetMethodDefOrRefAsUncodedToken(MethodDefOrRefTag tag, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodSpecInfoAsUncodedToken(cenv cenv, ILTypeWriterEnv env, string minfo_0, ILType minfo_1, ILCallingConv minfo_2, FSharpList`1<ILType> minfo_3, ILType minfo_4, FSharpOption`1<FSharpList`1<ILType>> minfo_5, FSharpList`1<ILType> minst);
    internal static Tuple`7<string, ILType, ILCallingConv, FSharpList`1<ILType>, ILType, FSharpOption`1<FSharpList`1<ILType>>, int> GetMethodRefInfoOfMethodSpecInfo(string nm, ILType ty, ILCallingConv cc, FSharpList`1<ILType> args, ILType ret, FSharpOption`1<FSharpList`1<ILType>> varargs, FSharpList`1<ILType> minst);
    internal static Tuple`7<string, ILType, ILCallingConv, FSharpList`1<ILType>, ILType, FSharpOption`1<FSharpList`1<ILType>>, FSharpList`1<ILType>> InfoOfMethodSpec(ILMethodSpec mspec, FSharpOption`1<FSharpList`1<ILType>> varargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetOverridesSpecAsMemberRefIdx(cenv cenv, ILTypeWriterEnv env, ILOverridesSpec ospec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MethodDefOrRefTag, int> GetOverridesSpecAsMethodDefOrRef(cenv cenv, ILTypeWriterEnv env, ILOverridesSpec ospec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetMethodRefAsMemberRefIdx(cenv cenv, ILTypeWriterEnv env, ILTypeWriterEnv fenv, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CustomAttributeTypeTag, int> GetMethodRefAsCustomAttribType(cenv cenv, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetCustomAttrDataAsBlobIdx(cenv cenv, Byte[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetCustomAttrRow(cenv cenv, HasCustomAttributeTag hca_0, int hca_1, ILAttribute attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenCustomAttrPass3Or4(cenv cenv, HasCustomAttributeTag hca_0, int hca_1, ILAttribute attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenCustomAttrsPass3Or4(cenv cenv, HasCustomAttributeTag hca_0, int hca_1, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetSecurityDeclRow(cenv cenv, HasDeclSecurityTag hds_0, int hds_1, ILSecurityDecl _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSecurityDeclPass3(cenv cenv, HasDeclSecurityTag hds_0, int hds_1, ILSecurityDecl attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSecurityDeclsPass3(cenv cenv, HasDeclSecurityTag hds_0, int hds_1, FSharpList`1<ILSecurityDecl> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetFieldSpecAsMemberRefRow(cenv cenv, ILTypeWriterEnv env, ILTypeWriterEnv fenv, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldSpecAsMemberRefIdx(cenv cenv, ILTypeWriterEnv env, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetFieldSpecSigAsBytes(cenv cenv, ILTypeWriterEnv env, ILFieldSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldSpecSigAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILFieldSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, int> GetFieldSpecAsFieldDefOrRef(cenv cenv, ILTypeWriterEnv env, ILFieldSpec fspec);
    internal static int GetFieldDefOrRefAsUncodedToken(bool tag, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetCallsigAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILCallingSignature callsig, FSharpOption`1<FSharpList`1<ILType>> varargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetCallsigAsStandAloneSigRow(cenv cenv, ILTypeWriterEnv env, ILCallingSignature x_0, FSharpOption`1<FSharpList`1<ILType>> x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetCallsigAsStandAloneSigIdx(cenv cenv, ILTypeWriterEnv env, ILCallingSignature info_0, FSharpOption`1<FSharpList`1<ILType>> info_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitLocalSig(cenv cenv, ILTypeWriterEnv env, ByteBuffer bb, FSharpList`1<ILLocal> locals);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetLocalSigAsBlobHeapIdx(cenv cenv, ILTypeWriterEnv env, FSharpList`1<ILLocal> locals);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetLocalSigAsStandAloneSigIdx(cenv cenv, ILTypeWriterEnv env, FSharpList`1<ILLocal> locals);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldDefTypeAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PdbImport GenPdbImport(cenv cenv, ILDebugImport input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<PdbImports> GenPdbImports(cenv cenv, FSharpOption`1<ILDebugImports> input);
    internal static int kindAsInt32@2387(ExceptionClauseKind k);
    internal static int kindAsExtraInt32@2393(ExceptionClauseKind k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<int, Tuple`2<Tuple`2<int, FSharpList`1<Tuple`2<int, int>>>, Byte[]>, PdbDebugPoint[], PdbMethodScope> GenILMethodBody(a mname, cenv cenv, ILTypeWriterEnv env, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetFieldDefAsFieldDefRow(cenv cenv, ILTypeWriterEnv env, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetFieldDefSigAsBlobIdx(cenv cenv, ILTypeWriterEnv env, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenFieldDefPass3(ILTypeDef tdef, cenv cenv, ILTypeWriterEnv env, ILFieldDef fd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SharedRow GetGenericParamAsGenericParamRow(cenv cenv, a _env, int idx, TypeOrMethodDefTag owner_0, int owner_1, ILGenericParameterDef gp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GenTypeAsGenericParamConstraintRow(cenv cenv, ILTypeWriterEnv env, int gpidx, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGenericParamConstraintPass4(cenv cenv, ILTypeWriterEnv env, int gpidx, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGenericParamPass3(cenv cenv, a env, int idx, TypeOrMethodDefTag owner_0, int owner_1, ILGenericParameterDef gp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGenericParamPass4(cenv cenv, ILTypeWriterEnv env, int idx, TypeOrMethodDefTag owner_0, int owner_1, ILGenericParameterDef gp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetParamAsParamRow(cenv cenv, a _env, int seq, ILParameter param);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenParamPass3(cenv cenv, a env, int seq, ILParameter param);
    internal static UnsharedRow GenReturnAsParamRow(ILReturn returnv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenReturnPass3(cenv cenv, ILReturn returnv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetMethodDefSigAsBytes(cenv cenv, ILTypeWriterEnv env, ILMethodDef mdef);
    internal static ILMethodBody get_ilMethodBodyThrowNull();
    internal static ILCode get_ilCode@2605();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GenMethodDefAsRow(cenv cenv, ILTypeWriterEnv env, int midx, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodImplPass3(cenv cenv, ILTypeWriterEnv env, a _tgparams, int tidx, ILMethodImplDef mimpl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodDefPass3(ILTypeDef tdef, cenv cenv, ILTypeWriterEnv env, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodDefPass4(ILTypeDef tdef, cenv cenv, ILTypeWriterEnv env, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenPropertyMethodSemanticsPass3(cenv cenv, int pidx, int kind, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] GetPropertySigAsBytes(cenv cenv, ILTypeWriterEnv env, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetPropertyAsPropertyRow(cenv cenv, ILTypeWriterEnv env, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenPropertyPass3(cenv cenv, ILTypeWriterEnv env, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenEventMethodSemanticsPass3(cenv cenv, int eidx, int kind, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GenEventAsEventRow(cenv cenv, ILTypeWriterEnv env, ILEventDef edef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenEventPass3(cenv cenv, ILTypeWriterEnv env, ILEventDef edef);
    internal static Tuple`2<RowElement, Tuple`2<ImplementationTag, int>> embedManagedResources@2817(cenv cenv, ReadOnlyByteMemory bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetResourceAsManifestResourceRow(cenv cenv, ILResource rdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenResourcePass3(cenv cenv, ILResource rdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefPass3(FSharpList`1<string> enc, cenv cenv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefsPass3(FSharpList`1<string> enc, cenv cenv, FSharpList`1<ILTypeDef> tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefPass4(FSharpList`1<string> enc, cenv cenv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDefsPass4(FSharpList`1<string> enc, cenv cenv, FSharpList`1<ILTypeDef> tdefs);
    internal static int get_timestamp();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenNestedExportedTypePass3(cenv cenv, int cidx, ILNestedExportedType ce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenNestedExportedTypesPass3(cenv cenv, int nidx, ILNestedExportedTypes nce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExportedTypePass3(cenv cenv, ILExportedTypeOrForwarder ce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExportedTypesPass3(cenv cenv, ILExportedTypesAndForwarders ce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetManifestAsAssemblyRow(cenv cenv, ILAssemblyManifest m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenManifestPass3(cenv cenv, ILAssemblyManifest m);
    internal static Byte[] newGuid(ILModuleDef modul);
    internal static Byte[] deterministicGuid(ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnsharedRow GetModuleAsRow(cenv cenv, ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int rowElemCompare(RowElement e1, RowElement e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RowElement[][] SortTableRows(TableName tab, RowElement[][] rows);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenModule(cenv cenv, ILModuleDef modul);
    [CompilerGeneratedAttribute]
internal static MetadataTable initializer@1-1(int i);
    internal static int idxForNextedTypeDef@3155(cenv cenv, FSharpList`1<ILTypeDef> tdefs, ILTypeDef tdef);
    internal static Tuple`8<Byte[][], Byte[][], Byte[][], Byte[][], MetadataTable[], int, Byte[], Tuple`5<FSharpList`1<Tuple`2<int, FSharpList`1<Tuple`2<int, int>>>>, Byte[], Byte[], PdbData, ILTokenMappings>> generateIL(FSharpRef`1<FSharpList`1<Tuple`2<int, Tuple`2<int, bool>>>> requiredDataFixups, ILVersionInfo desiredMetadataVersion, bool generatePdb, ILGlobals ilg, bool emitTailcalls, bool deterministic, bool referenceAssemblyOnly, FSharpOption`1<ILAttribute> referenceAssemblyAttribOpt, IEnumerable`1<ILSourceDocument> allGivenSources, ILModuleDef m, int cilStartAddress, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int count(FSharpFunc`2<a, int> f, a[] arr);
    internal static int guidAddress@3319(int n);
    internal static int stringAddress@3330(Int32[] stringAddressTable, int n);
    internal static int userStringAddress@3344(Int32[] userStringAddressTable, int n);
    internal static int blobAddress@3357(Int32[] blobAddressTable, int n);
    [CompilerGeneratedAttribute]
internal static RowElement[][] initializer@1-2(MetadataTable[] tables, int i);
    internal static bool codedBigness@3377-1(MetadataTable[] tables, int nbits, TableName tab);
    internal static Tuple`8<int, Byte[], Byte[], Byte[], Byte[], Byte[], FSharpList`1<Tuple`2<int, Tuple`2<int, bool>>>, Tuple`3<PdbData, ILTokenMappings, int>> writeILMetadataAndCode(bool generatePdb, ILVersionInfo desiredMetadataVersion, ILGlobals ilg, bool emitTailcalls, bool deterministic, bool referenceAssemblyOnly, FSharpOption`1<ILAttribute> referenceAssemblyAttribOpt, IEnumerable`1<ILSourceDocument> allGivenSources, ILModuleDef modul, int cilStartAddress, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    internal static Byte[] get_msdosHeader();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeInt64(BinaryWriter os, long x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeInt32(BinaryWriter os, int x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeInt32AsUInt16(BinaryWriter os, int x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeDirectory(BinaryWriter os, BinaryChunk dict);
    internal static void signImage@3709(FSharpOption`1<ILStrongNameSigner> signer, FSharpFunc`2<Unit, b> reopenOutput);
    internal static FSharpOption`1<Byte[]> writePdb(bool dumpDebugInfo, bool embeddedPDB, FSharpOption`1<string> pdbfile, string outfile, FSharpFunc`2<Unit, a> reopenOutput, bool writePdbInMemory, FSharpOption`1<ILStrongNameSigner> signer, bool deterministic, PathMap pathMap, PdbData pdbData, FSharpOption`1<Tuple`5<long, BlobContentId, MemoryStream, string, Byte[]>> pdbInfoOpt, BinaryChunk debugDirectoryChunk, BinaryChunk debugDataChunk, BinaryChunk debugChecksumPdbChunk, BinaryChunk debugEmbeddedPdbChunk, BinaryChunk debugDeterministicPdbChunk, FSharpFunc`2<int, int> textV2P);
    internal static void write@4099(FSharpOption`1<int> p, BinaryWriter os, string chunkName, Byte[] chunk);
    internal static void writePadding@4109(BinaryWriter os, a _comment, int sz);
    internal static Byte[] deterministicMvid@4146(Byte[] deterministicId, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static PdbData pdbData$cont@4151(BinaryWriter os, PdbData pdbData, Byte[] metadata, int guidStart, Byte[] deterministicId, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void writeBinaryAux$cont@4415(bool isDll, BinaryWriter os, int imageBaseReal, bool isItanium, int nextPhys, int next, BinaryChunk importAddrTableChunk, int importTableChunkPrePadding, BinaryChunk importLookupTableChunk, BinaryChunk importNameHintTableChunk, BinaryChunk mscoreeStringChunk, BinaryChunk importTableChunk, int importTableChunkPadding, BinaryChunk entrypointCodeChunk, BinaryChunk globalpointerCodeChunk, Unit unitVar);
    internal static Tuple`8<PdbData, FSharpOption`1<Tuple`5<long, BlobContentId, MemoryStream, string, Byte[]>>, BinaryChunk, BinaryChunk, BinaryChunk, BinaryChunk, BinaryChunk, Tuple`2<FSharpFunc`2<int, int>, ILTokenMappings>> writeBinaryAux(Stream stream, options options, ILModuleDef modul, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    internal static ILTokenMappings writeBinaryFiles(options options, ILModuleDef modul, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    internal static Tuple`2<Byte[], FSharpOption`1<Byte[]>> writeBinaryInMemory(options options, ILModuleDef modul, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    internal static void WriteILBinaryFile(options options, ILModuleDef inputModule, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
    internal static Tuple`2<Byte[], FSharpOption`1<Byte[]>> WriteILBinaryInMemory(options options, ILModuleDef inputModule, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILDynamicAssemblyWriter : object {
    [CompilationMappingAttribute("9")]
internal static IComparer`1<int> codeLabelOrder { get; }
    internal static bool logRefEmitCalls { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ILTypeRef> orderILTypeRef { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ILMethodRef> orderILMethodRef { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ILFieldRef> orderILFieldRef { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ILPropertyRef> orderILPropertyRef { get; }
    [CompilationMappingAttribute("9")]
internal static ILDynamicAssemblyEmitEnv emEnv0 { get; }
    [CompilationMappingAttribute("9")]
internal static Type TypeBuilderInstantiationT { get; }
    [CompilationMappingAttribute("9")]
internal static MethodInfo definePInvokeMethod { get; }
    [CompilationMappingAttribute("9")]
internal static bool enablePInvoke { get; }
    internal static bool verbose2 { get; }
    internal static IComparer`1<int> get_codeLabelOrder();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_logRefEmitCalls();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleBuilder AssemblyBuilder.DefineDynamicModuleAndLog(AssemblyBuilder this, string assemblyName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AssemblyBuilder.SetCustomAttributeAndLog(AssemblyBuilder this, ConstructorInfo cinfo, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AssemblyBuilder.SetCustomAttributeAndLog(AssemblyBuilder asmB, CustomAttributeBuilder cab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo ModuleBuilder.GetArrayMethodAndLog(ModuleBuilder modB, Type arrayTy, string nm, CallingConventions flags, Type retTy, Type[] argTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type ModuleBuilder.GetTypeAndLog(ModuleBuilder modB, string nameInModule, bool flag1, bool flag2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeBuilder ModuleBuilder.DefineTypeAndLog(ModuleBuilder modB, string name, TypeAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ModuleBuilder.SetCustomAttributeAndLog(ModuleBuilder modB, ConstructorInfo cinfo, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ConstructorBuilder.SetImplementationFlagsAndLog(ConstructorBuilder consB, MethodImplAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParameterBuilder ConstructorBuilder.DefineParameterAndLog(ConstructorBuilder consB, int n, ParameterAttributes attr, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILGenerator ConstructorBuilder.GetILGeneratorAndLog(ConstructorBuilder );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void MethodBuilder.SetImplementationFlagsAndLog(MethodBuilder methB, MethodImplAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void MethodBuilder.SetSignatureAndLog(MethodBuilder methB, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParameterBuilder MethodBuilder.DefineParameterAndLog(MethodBuilder methB, int n, ParameterAttributes attr, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static GenericTypeParameterBuilder[] MethodBuilder.DefineGenericParametersAndLog(MethodBuilder methB, String[] gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILGenerator MethodBuilder.GetILGeneratorAndLog(MethodBuilder );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void MethodBuilder.SetCustomAttributeAndLog(MethodBuilder methB, ConstructorInfo cinfo, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type TypeBuilder.CreateTypeAndLog(TypeBuilder );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeBuilder TypeBuilder.DefineNestedTypeAndLog(TypeBuilder typB, string name, TypeAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodBuilder TypeBuilder.DefineMethodAndLog(TypeBuilder typB, string name, MethodAttributes attrs, CallingConventions cconv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static GenericTypeParameterBuilder[] TypeBuilder.DefineGenericParametersAndLog(TypeBuilder typB, String[] gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorBuilder TypeBuilder.DefineConstructorAndLog(TypeBuilder typB, MethodAttributes attrs, CallingConventions cconv, Type[] parms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldBuilder TypeBuilder.DefineFieldAndLog(TypeBuilder typB, string nm, Type ty, FieldAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PropertyBuilder TypeBuilder.DefinePropertyAndLog(TypeBuilder typB, string nm, PropertyAttributes attrs, Type ty, Type[] args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EventBuilder TypeBuilder.DefineEventAndLog(TypeBuilder typB, string nm, EventAttributes attrs, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TypeBuilder.SetParentAndLog(TypeBuilder typB, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TypeBuilder.AddInterfaceImplementationAndLog(TypeBuilder typB, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object TypeBuilder.InvokeMemberAndLog(TypeBuilder typB, string nm, a _flags, Object[] args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TypeBuilder.SetCustomAttributeAndLog(TypeBuilder typB, ConstructorInfo cinfo, Byte[] bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string OpCode.get_RefEmitName(OpCode );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LocalBuilder ILGenerator.DeclareLocalAndLog(ILGenerator ilG, Type ty, bool isPinned);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.MarkLabelAndLog(ILGenerator ilG, Label lab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Label ILGenerator.BeginExceptionBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EndExceptionBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.BeginFinallyBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.BeginCatchBlockAndLog(ILGenerator ilG, Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.BeginExceptFilterBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.BeginFaultBlockAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Label ILGenerator.DefineLabelAndLog(ILGenerator );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, Label v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, short v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, int v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, MethodInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, string v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, Type v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, FieldInfo v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILGenerator.EmitAndLog(ILGenerator x, OpCode op, ConstructorInfo v);
    internal static Type[] getGenericArgumentsOfType(Type typT);
    internal static Type[] getGenericArgumentsOfMethod(MethodInfo methI);
    internal static Type getTypeConstructor(Type ty);
    internal static void setVersion@451(AssemblyName asmName, ILVersionInfo version);
    internal static AssemblyName convAssemblyRef(ILAssemblyRef aref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convResolveAssemblyRef(cenv cenv, ILAssemblyRef asmref, string qualifiedName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeRefAux(cenv cenv, ILTypeRef tref);
    internal static IComparer`1<ILTypeRef> get_orderILTypeRef();
    internal static IComparer`1<ILMethodRef> get_orderILMethodRef();
    internal static IComparer`1<ILFieldRef> get_orderILFieldRef();
    internal static IComparer`1<ILPropertyRef> get_orderILPropertyRef();
    internal static ILDynamicAssemblyEmitEnv get_emEnv0();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envBindTypeRef(ILDynamicAssemblyEmitEnv emEnv, ILTypeRef tref, Type typT, TypeBuilder typB, ILTypeDef typeDef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envUpdateCreatedTypeRef(ILDynamicAssemblyEmitEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeRef(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, bool preferCreated, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envBindConsRef(ILDynamicAssemblyEmitEnv emEnv, ILMethodRef mref, ConstructorBuilder consB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envBindMethodRef(ILDynamicAssemblyEmitEnv emEnv, ILMethodRef mref, MethodBuilder methB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envBindFieldRef(ILDynamicAssemblyEmitEnv emEnv, ILFieldRef fref, FieldBuilder fieldB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envBindPropRef(ILDynamicAssemblyEmitEnv emEnv, ILPropertyRef pref, PropertyBuilder propB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envSetLocals(ILDynamicAssemblyEmitEnv emEnv, LocalBuilder[] locs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envSetLabel(ILDynamicAssemblyEmitEnv emEnv, int name, Label lab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envPushTyvars(ILDynamicAssemblyEmitEnv emEnv, Type[] tys);
    internal static ILDynamicAssemblyEmitEnv envPopTyvars(ILDynamicAssemblyEmitEnv emEnv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type envGetTyvar(ILDynamicAssemblyEmitEnv emEnv, ushort u16);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv envAddEntryPt(ILDynamicAssemblyEmitEnv emEnv, TypeBuilder mref_0, string mref_1);
    internal static Tuple`2<ILDynamicAssemblyEmitEnv, FSharpList`1<Tuple`2<TypeBuilder, string>>> envPopEntryPts(ILDynamicAssemblyEmitEnv emEnv);
    internal static CallingConventions convCallConv(ILCallingConv _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeSpec(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, bool preferCreated, ILTypeSpec tspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeAux(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, bool preferCreated, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type convTypeOrTypeDef(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type[] convTypesToArray(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, FSharpList`1<ILType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2[] convParamModifiersOfType(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILType paramTy);
    internal static Tuple`2<a[], a[]> splitModifiers(Tuple`2[] mods);
    internal static Type get_TypeBuilderInstantiationT();
    internal static bool typeIsNotQueryable(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldInfo queryableTypeGetField(a _emEnv, Type parentT, ILFieldRef fref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldInfo nonQueryableTypeGetField(Type parentTI, FieldInfo fieldInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FieldInfo convFieldSpec(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILFieldSpec fspec);
    internal static bool satisfiesAllParameters@931(FSharpFunc`2<FSharpOption`1<Type>, FSharpFunc`2<Type, bool>> satisfiesParameter, FSharpOption`1[] args, Type[] ps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo queryableTypeGetMethodBySearch(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, Type parentT, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo queryableTypeGetMethod(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, Type parentT, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo nonQueryableTypeGetMethod(Type parentTI, MethodInfo methInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo convMethodRef(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, Type parentTI, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodInfo convMethodSpec(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILMethodSpec mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorInfo queryableTypeGetConstructor(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, Type parentT, ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorInfo nonQueryableTypeGetConstructor(Type parentTI, ConstructorInfo consInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstructorInfo convConstructorSpec(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILMethodSpec mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrCompare(ILDynamicAssemblyEmitEnv emEnv, ILGenerator ilG, ILComparisonInstr comp, int targ);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrAlign(ILGenerator ilG, ILAlignment _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrTail(cenv cenv, ILGenerator ilG, ILTailcall tail, FSharpFunc`2<Unit, Unit> emitTheCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrNewobj(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILGenerator ilG, ILMethodSpec mspec, FSharpOption`1<a> varargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstrCall(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILGenerator ilG, OpCode opCall, ILTailcall tail, ILMethodSpec mspec, FSharpOption`1<FSharpList`1<ILType>> varargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitInstr(cenv cenv, ModuleBuilder modB, ILDynamicAssemblyEmitEnv emEnv, ILGenerator ilG, ILInstr instr);
    internal static void add@1606-1(Dictionary`2<int, FSharpList`1<FSharpFunc`2<Unit, Unit>>> pc2action, Dictionary`2<int, int> lab2pc, int lab, FSharpFunc`2<Unit, Unit> action);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitCode(cenv cenv, ModuleBuilder modB, ILDynamicAssemblyEmitEnv emEnv, ILGenerator ilG, ILCode code);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitILMethodBody(cenv cenv, ModuleBuilder modB, ILDynamicAssemblyEmitEnv emEnv, ILGenerator ilG, ILMethodBody ilmbody);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitMethodBody(cenv cenv, ModuleBuilder modB, ILDynamicAssemblyEmitEnv emEnv, FSharpFunc`2<Unit, a> ilG, b _name, MethodBody mbody);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitCustomAttrs(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, FSharpFunc`2<Tuple`2<ConstructorInfo, Byte[]>, Unit> add, ILAttributes cattrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildGenParamsPass1(a _emEnv, FSharpFunc`2<String[], b> defineGenericParameters, FSharpList`1<ILGenericParameterDef> gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildGenParamsPass1b(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, Type[] genArgs, FSharpList`1<ILGenericParameterDef> gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitParameter(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, FSharpFunc`2<Tuple`3<int, ParameterAttributes, string>, ParameterBuilder> defineParameter, int i, ILParameter param);
    internal static MethodInfo get_definePInvokeMethod();
    internal static bool get_enablePInvoke();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildMethodPass2(cenv cenv, ILTypeRef tref, TypeBuilder typB, ILDynamicAssemblyEmitEnv emEnv, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildMethodPass3(cenv cenv, ILTypeRef tref, ModuleBuilder modB, TypeBuilder typB, ILDynamicAssemblyEmitEnv emEnv, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildFieldPass2(cenv cenv, ILTypeRef tref, TypeBuilder typB, ILDynamicAssemblyEmitEnv emEnv, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildFieldPass3(cenv cenv, ILTypeRef tref, TypeBuilder _typB, ILDynamicAssemblyEmitEnv emEnv, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildPropertyPass2(cenv cenv, ILTypeRef tref, TypeBuilder typB, ILDynamicAssemblyEmitEnv emEnv, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildPropertyPass3(cenv cenv, ILTypeRef tref, TypeBuilder _typB, ILDynamicAssemblyEmitEnv emEnv, ILPropertyDef prop);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildEventPass3(cenv cenv, TypeBuilder typB, ILDynamicAssemblyEmitEnv emEnv, ILEventDef eventDef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildMethodImplsPass3(cenv cenv, a _tref, TypeBuilder typB, ILDynamicAssemblyEmitEnv emEnv, ILMethodImplDef mimpl);
    internal static FSharpOption`1<Tuple`2<ConstructorInfo, Byte[]>> attr@2077(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, int x, ILTypeDefLayoutInfo p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<ConstructorInfo, Byte[]>> typeAttributesOfTypeLayout(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILTypeDefLayout x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildTypeDefPass1(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ModuleBuilder modB, FSharpFunc`2<Tuple`2<string, TypeAttributes>, TypeBuilder> rootTypeBuilder, FSharpList`1<ILTypeDef> nesting, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildTypeTypeDef(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ModuleBuilder modB, TypeBuilder typB, FSharpList`1<ILTypeDef> nesting, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildTypeDefPass1b(cenv cenv, FSharpList`1<ILTypeDef> nesting, ILDynamicAssemblyEmitEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildTypeDefPass2(cenv cenv, FSharpList`1<ILTypeDef> nesting, ILDynamicAssemblyEmitEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildTypeDefPass3(cenv cenv, FSharpList`1<ILTypeDef> nesting, ModuleBuilder modB, ILDynamicAssemblyEmitEnv emEnv, ILTypeDef tdef);
    internal static FSharpList`1<ILTypeRef> getEnclosingTypeRefs(ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILTypeRef> getTypeRefsInType(CollectTypes allTypes, ILType ty, FSharpList`1<ILTypeRef> acc);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_verbose2();
    internal static void traverseTypeDef@2304(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, ILDynamicAssemblyEmitEnv emEnv, ILTypeRef tref, ILTypeDef tdef);
    internal static void traverseType@2349(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, ILDynamicAssemblyEmitEnv emEnv, CollectTypes allTypes, ILType ty);
    internal static void traverseTypeRef@2354(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, ILDynamicAssemblyEmitEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void createTypeRef(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, ILDynamicAssemblyEmitEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void buildTypeDefPass4(Dictionary`2<ILTypeRef, bool> visited, Dictionary`2<ILTypeRef, bool> created, FSharpList`1<ILTypeDef> nesting, ILDynamicAssemblyEmitEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildModuleTypePass1(cenv cenv, ModuleBuilder modB, ILDynamicAssemblyEmitEnv emEnv, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDynamicAssemblyEmitEnv buildModuleFragment(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ModuleBuilder modB, ILModuleDef m);
    internal static Tuple`2<AssemblyBuilder, ModuleBuilder> mkDynamicAssemblyAndModule(string assemblyName, bool optimize, bool collectible);
    internal static Tuple`2<ILDynamicAssemblyEmitEnv, FSharpList`1<FSharpFunc`2<Unit, FSharpOption`1<Exception>>>> EmitDynamicAssemblyFragment(ILGlobals ilg, bool emitTailcalls, ILDynamicAssemblyEmitEnv emEnv, AssemblyBuilder asmB, ModuleBuilder modB, ILModuleDef modul, bool debugInfo, FSharpFunc`2<ILAssemblyRef, FSharpOption`1<FSharpChoice`2<string, Assembly>>> resolveAssemblyRef, FSharpFunc`2<string, FSharpOption`1<ILTypeRef>> tryFindSysILTypeRef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type LookupTypeRef(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Type LookupType(cenv cenv, ILDynamicAssemblyEmitEnv emEnv, ILType ty);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILPdbWriter : object {
    internal static int sizeof_IMAGE_DEBUG_DIRECTORY { get; }
    [CompilationMappingAttribute("9")]
internal static Guid guidSha1 { get; }
    [CompilationMappingAttribute("9")]
internal static Guid guidSha2 { get; }
    internal static long cvMagicNumber { get; }
    internal static long pdbMagicNumber { get; }
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@84-27(PdbMethodScope this, PdbMethodScope obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@84-28(IComparer comp, PdbMethodScope this, PdbMethodScope objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@100-29(PdbDebugPoint this, PdbDebugPoint obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@100-30(PdbDebugPoint this, PdbDebugPoint objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@113-31(PdbMethodData this, PdbMethodData obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@113-32(IComparer comp, PdbMethodData this, PdbMethodData objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@113-4(IEqualityComparer comp, PdbMethodData this, Unit unitVar);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_sizeof_IMAGE_DEBUG_DIRECTORY();
    internal static Guid get_guidSha1();
    internal static Guid get_guidSha2();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Guid, Byte[]>> checkSum(string url, HashAlgorithm checksumAlgorithm);
    internal static Byte[] i32AsBytes(int i);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static long get_cvMagicNumber();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd pdbGetCvDebugInfo(Byte[] mvid, int timestamp, string filepath, BinaryChunk cvChunk);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static long get_pdbMagicNumber();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd pdbGetEmbeddedPdbDebugInfo(BinaryChunk embeddedPdbChunk, long uncompressedLength, MemoryStream compressedStream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd pdbChecksumDebugInfo(int timestamp, BinaryChunk checksumPdbChunk, string algorithmName, Byte[] checksum);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd[] pdbGetDebugInfo(Byte[] contentId, int timestamp, string filepath, BinaryChunk cvChunk, FSharpOption`1<BinaryChunk> embeddedPdbChunk, BinaryChunk deterministicPdbChunk, BinaryChunk checksumPdbChunk, string algorithmName, Byte[] checksum, long uncompressedLength, FSharpOption`1<MemoryStream> compressedStream, bool embeddedPdb, bool deterministic);
    internal static string getDebugFileName(string outfile);
    internal static void sortMethods(PdbData info);
    internal static ImmutableArray`1<int> getRowCounts(Int32[] tableRowCounts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int scopeSorter(PdbMethodScope scope1, PdbMethodScope scope2);
    internal static BlobContentId convert@809(FSharpRef`1<Byte[]> contentHash, FSharpRef`1<HashAlgorithm> hashAlgorithm, IEnumerable`1<Blob> content);
    internal static FSharpFunc`2<a, int> count@364-1(IEnumerable`1<a> s);
    internal static void flattenScopes@609(List`1<PdbMethodScope> list, PdbMethodScope scope, FSharpOption`1<PdbMethodScope> parent);
    internal static int capValue@721(int v, int maxValue);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<long, BlobContentId, MemoryStream, string, Byte[]> generatePortablePdb(bool embedAllSource, FSharpList`1<string> embedSourceList, string sourceLink, HashAlgorithm checksumAlgorithm, PdbData info, PathMap pathMap);
    internal static MemoryStream compressPortablePdbStream(MemoryStream stream);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd[] getInfoForPortablePdb(BlobContentId contentId, string pdbfile, PathMap pathMap, BinaryChunk cvChunk, BinaryChunk deterministicPdbChunk, BinaryChunk checksumPdbChunk, string algorithmName, Byte[] checksum, bool embeddedPdb, bool deterministic);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static idd[] getInfoForEmbeddedPortablePdb(long uncompressedLength, BlobContentId contentId, MemoryStream compressedStream, string pdbfile, BinaryChunk cvChunk, BinaryChunk pdbChunk, BinaryChunk deterministicPdbChunk, BinaryChunk checksumPdbChunk, string algorithmName, Byte[] checksum, bool deterministic);
    internal static void writeScope@947(StreamWriter sw, string offs, PdbMethodScope scope);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void logDebugInfo(string outfile, PdbData info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpSet`1<string> allNamesOfScope(FSharpSet`1<string> acc, PdbMethodScope scope);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpSet`1<string> allNamesOfScopes(FSharpSet`1<string> acc, PdbMethodScope[] scopes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<PdbMethodScope[], bool> pushShadowedLocals(StackGuard stackGuard, PdbLocalVar[] localsToPush, PdbMethodScope scope);
    internal static PdbMethodScope[] unshadowScopes(PdbMethodScope rootScope);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILX.EraseClosures : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string fsharpCoreNamespace;
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<b>, a> stripUpTo(int n, FSharpFunc`2<a, bool> test, FSharpFunc`2<a, Tuple`2<b, a>> dest, a x);
    internal static Tuple`2<ILGenericParameterDef, IlxClosureLambdas> destTyLambda(IlxClosureLambdas _arg1);
    internal static Tuple`3<FSharpList`1<ILType>, FSharpList`1<ILType>, IlxClosureApps> stripSupportedIndirectCall(IlxClosureApps apps);
    internal static Tuple`3<FSharpList`1<ILGenericParameterDef>, FSharpList`1<ILParameter>, IlxClosureLambdas> stripSupportedAbstraction(IlxClosureLambdas lambdas);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef mkFuncTypeRef(ILScopeRef fsharpCoreAssemblyScopeRef, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef addMethodGeneratedAttrsToTypeDef(cenv cenv, ILTypeDef tdef);
    internal static cenv newIlxPubCloEnv(ILGlobals ilg, FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, FSharpFunc`2<ILFieldDef, ILFieldDef> addFieldGeneratedAttrs, FSharpFunc`2<ILFieldDef, ILFieldDef> addFieldNeverAttrs);
    internal static ILType mkILTyFuncTy(cenv cenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkILFuncTy(cenv cenv, ILType dty, ILType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType typ_Func(cenv cenv, FSharpList`1<ILType> dtys, ILType rty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkTyOfApps(cenv cenv, IlxClosureApps apps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType mkTyOfLambdas(cenv cenv, IlxClosureLambdas lam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, ILMethodSpec> mkMethSpecForMultiApp(cenv cenv, FSharpList`1<ILType> argTys, ILType retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkCallBlockForMultiValueApp(cenv cenv, ILTailcall doTailCall, FSharpList`1<ILType> argTys, ILType retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkLdFreeVar(IlxClosureSpec clospec, IlxClosureFreeVar fv);
    internal static Tuple`2<FSharpList`1<FSharpList`1<ILInstr>>, FSharpList`1<FSharpList`1<ILInstr>>> unwind@242(FSharpFunc`2<ILType, ushort> allocLocal, int numThisGenParams, IlxClosureApps apps);
    internal static Tuple`2<FSharpList`1<ILInstr>, FSharpList`1<ILInstr>> computePreCall@258(FSharpFunc`2<ILType, ushort> allocLocal, int numThisGenParams, bool fst, int n, IlxClosureApps rest, FSharpList`1<ILInstr> loaders);
    internal static FSharpList`1<ILInstr> buildApp@273(cenv cenv, FSharpFunc`2<ILType, ushort> allocLocal, int numThisGenParams, ILTailcall tailness, bool fst, FSharpList`1<ILInstr> loaders, IlxClosureApps apps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkCallFunc(cenv cenv, FSharpFunc`2<ILType, ushort> allocLocal, int numThisGenParams, ILTailcall tailness, IlxClosureApps apps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> convReturnInstr(ILType ty, ILInstr instr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodBody convILMethodBody(FSharpOption`1<a> thisClo, FSharpOption`1<ILType> boxReturnTy, ILMethodBody il);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodBody convMethodBody(FSharpOption`1<a> thisClo, MethodBody _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef convMethodDef(FSharpOption`1<a> thisClo, ILMethodDef md);
    internal static IlxClosureFreeVar mkILFreeVarForParam(ILParameter p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<string, ILType>> mkILCloFldSpecs(a _cenv, IlxClosureFreeVar[] flds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILFieldDef> mkILCloFldDefs(cenv cenv, IlxClosureFreeVar[] flds);
    internal static a findMatchingArg@441(FSharpList`1<Tuple`2<int, IlxClosureFreeVar>> argToFreeVarMap, FSharpFunc`2<int, a> mkEnv, FSharpFunc`2<int, a> mkArg, int n, FSharpList`1<Tuple`2<int, b>> l, int c);
    internal static a fixupArg@440(FSharpList`1<Tuple`2<int, IlxClosureFreeVar>> argToFreeVarMap, FSharpFunc`2<int, a> mkEnv, FSharpFunc`2<int, a> mkArg, int n);
    internal static ILMethodBody rewriteCodeToAccessArgsFromEnv@435(IlxClosureInfo clo, IlxClosureSpec laterCloSpec, FSharpList`1<Tuple`2<int, IlxClosureFreeVar>> argToFreeVarMap);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ILTypeDef> newTypeDefs$cont@547(cenv cenv, ILTypeDef td, IlxClosureInfo clo, IlxClosureFreeVar[] nowFields, ILType nowTy, IlxClosureSpec nowCloSpec, FSharpList`1<ILMethodDef> nowMethods, FSharpList`1<ILGenericParameterDef> tyargsl, ILType nowReturnTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ILTypeDef> newTypeDefs$cont@684-1(cenv cenv, ILTypeDef td, IlxClosureInfo clo, IlxClosureFreeVar[] nowFields, ILType nowTy, IlxClosureSpec nowCloSpec, FSharpList`1<ILMethodDef> nowMethods, FSharpOption`1<ILDebugImports> cloImports, FSharpList`1<ILParameter> tmargsl, ILType nowReturnTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<ILTypeDef> newTypeDefs$cont@739-2(cenv cenv, ILTypeDef td, IlxClosureInfo clo, IlxClosureFreeVar[] nowFields, ILType nowTy, IlxClosureSpec nowCloSpec, FSharpList`1<ILMethodDef> nowMethods, FSharpOption`1<ILDebugImports> cloImports, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILTypeDef> convIlxClosureDef(cenv cenv, FSharpList`1<string> encl, ILTypeDef td, IlxClosureInfo clo);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILX.EraseUnions : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int TagNil;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int TagCons;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string ALT_NAME_CONS;
    [CompilationMappingAttribute("9")]
internal static UnionReprDecisions`3<IlxUnionSpec, IlxUnionCase, ILType> cuspecRepr { get; }
    [CompilationMappingAttribute("9")]
internal static UnionReprDecisions`3<Tuple`2<ILTypeDef, IlxUnionInfo>, IlxUnionCase, NoTypesGeneratedViaThisReprDecider> cudefRepr { get; }
    internal static string tagPropertyName { get; }
    private static EraseUnions();
    internal static ILType baseTyOfUnionSpec(IlxUnionSpec cuspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string mkMakerName(IlxUnionSpec cuspec, string nm);
    internal static UnionReprDecisions`3<IlxUnionSpec, IlxUnionCase, ILType> get_cuspecRepr();
    internal static UnionReprDecisions`3<Tuple`2<ILTypeDef, IlxUnionInfo>, IlxUnionCase, NoTypesGeneratedViaThisReprDecider> get_cudefRepr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagPropertyName();
    internal static FSharpList`1<ILType> formalTypeArgs(ILType baseTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec mkConstFieldSpec(string nm, ILType baseTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GetILTypeForAlternative(IlxUnionSpec cuspec, int alt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxUnionCase altOfUnionSpec(IlxUnionSpec cuspec, int cidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool doesRuntimeTypeDiscriminateUseHelper(bool avoidHelpers, IlxUnionSpec cuspec, IlxUnionCase alt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkRuntimeTypeDiscriminate(ILGlobals ilg, bool avoidHelpers, IlxUnionSpec cuspec, IlxUnionCase alt, string altName, ILType altTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkRuntimeTypeDiscriminateThen(ILGlobals ilg, bool avoidHelpers, IlxUnionSpec cuspec, IlxUnionCase alt, string altName, ILType altTy, ILInstr after);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr mkGetTagFromField(ILGlobals ilg, a cuspec, ILType baseTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr mkSetTagToField(ILGlobals ilg, a cuspec, ILType baseTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string adjustFieldName(IlxUnionHasHelpers hasHelpers, string nm);
    internal static ILInstr mkLdData(bool avoidHelpers, IlxUnionSpec cuspec, int cidx, int fidx);
    internal static ILInstr mkLdDataAddr(bool avoidHelpers, IlxUnionSpec cuspec, int cidx, int fidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr mkGetTagFromHelpers(ILGlobals ilg, IlxUnionSpec cuspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr mkGetTag(ILGlobals ilg, IlxUnionSpec cuspec);
    internal static FSharpList`1<ILInstr> mkCeqThen(ILInstr after);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkTagDiscriminate(ILGlobals ilg, IlxUnionSpec cuspec, a _baseTy, int cidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkTagDiscriminateThen(ILGlobals ilg, IlxUnionSpec cuspec, int cidx, ILInstr after);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> convNewDataInstrInternal(ILGlobals ilg, IlxUnionSpec cuspec, int cidx);
    internal static ILInstr mkStData(IlxUnionSpec cuspec, int cidx, int fidx);
    internal static FSharpList`1<ILInstr> viaMakerCall@386(IlxUnionSpec cuspec, IlxUnionCase alt, string altName, ILType baseTy, Unit unitVar0);
    internal static FSharpList`1<ILInstr> viaGetAltNameProperty@398(string altName, ILType baseTy, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkNewData(ILGlobals ilg, IlxUnionSpec cuspec, int cidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkIsData(ILGlobals ilg, bool avoidHelpers, IlxUnionSpec cuspec, int cidx);
    internal static ILCode genWith(FSharpFunc`2<ICodeGen`1<int>, Unit> g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILInstr> mkBrIsData(ILGlobals ilg, bool sense, bool avoidHelpers, IlxUnionSpec cuspec, int cidx, int tg);
    internal static void emitCase@535(ILGlobals ilg, ICodeGen`1<Mark> cg, IlxUnionSpec cuspec, bool avoidHelpers, ILInstr ld, Mark outlab, int cidx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitLdDataTagPrim(ILGlobals ilg, FSharpOption`1<ILInstr> ldOpt, ICodeGen`1<Mark> cg, bool avoidHelpers, IlxUnionSpec cuspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitLdDataTag(ILGlobals ilg, ICodeGen`1<Mark> cg, bool avoidHelpers, IlxUnionSpec cuspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitCastData(ILGlobals ilg, ICodeGen`1<Mark> cg, bool canfail, bool avoidHelpers, IlxUnionSpec cuspec, int cidx);
    internal static FSharpFunc`2<int, FSharpFunc`2<a, int>> emitCase@645-1(ICodeGen`1<Mark> cg, Dictionary`2<int, int> dict, Mark failLab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitDataSwitch(ILGlobals ilg, ICodeGen`1<Mark> cg, bool avoidHelpers, IlxUnionSpec cuspec, FSharpList`1<Tuple`2<int, int>> cases);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<b>, FSharpList`1<a>> mkMethodsAndPropertiesForFields(FSharpFunc`2<ILMethodDef, a> addMethodGeneratedAttrs, FSharpFunc`2<ILPropertyDef, b> addPropertyGeneratedAttrs, ILMemberAccess access, FSharpOption`1<ILDebugPoint> attr, FSharpOption`1<ILDebugImports> imports, IlxUnionHasHelpers hasHelpers, ILType ilTy, IlxUnionCaseField[] fields);
    internal static ILMethodDef addAltAttribs@745(IlxUnionCase alt, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<ILMethodDef>, FSharpList`1<a>, FSharpList`1<ILMethodDef>, FSharpList`1<ILTypeDef>, FSharpList`1<ILTypeDef>, FSharpList`1<Tuple`6<Tuple`2<ILTypeDef, IlxUnionInfo>, IlxUnionCase, ILType, int, ILFieldDef, bool>>> convAlternativeDef(FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyGeneratedAttrs, FSharpFunc`2<ILPropertyDef, a> addPropertyNeverAttrs, FSharpFunc`2<b, ILFieldDef> addFieldGeneratedAttrs, FSharpFunc`2<ILFieldDef, b> addFieldNeverAttrs, FSharpFunc`2<ILType, ILAttribute> mkDebuggerTypeProxyAttribute, TcGlobals g, int num, ILTypeDef td, IlxUnionInfo cud, ILTypeDef info_0, IlxUnionInfo info_1, IlxUnionSpec cuspec, ILType baseTy, IlxUnionCase alt);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Tuple`3<FSharpList`1<Tuple`2<string, ILType>>, FSharpList`1<ILMethodDef>, FSharpList`1<ILPropertyDef>>> mkClassUnionDef$cont@1234(FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyGeneratedAttrs, FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, TcGlobals g, ILTypeDef td, IlxUnionInfo cud, ILType baseTy, FSharpList`1<Tuple`2<string, ILType>> tagFieldsInObject, bool isStruct, ILMemberAccess ctorAccess, int minNullaryIdx, int cidx, IlxUnionCase alt, Unit unitVar);
    internal static ILTypeDef addConstFieldInit@1324(TcGlobals g, IlxUnionInfo cud, ILType baseTy, FSharpList`1<Tuple`6<Tuple`2<ILTypeDef, IlxUnionInfo>, IlxUnionCase, ILType, int, ILFieldDef, bool>> altNullaryFields, ILTypeDef cd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef mkClassUnionDef(FSharpFunc`2<ILMethodDef, ILMethodDef> addMethodGeneratedAttrs, FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyGeneratedAttrs, FSharpFunc`2<ILPropertyDef, ILPropertyDef> addPropertyNeverAttrs, FSharpFunc`2<ILFieldDef, ILFieldDef> addFieldGeneratedAttrs, FSharpFunc`2<ILFieldDef, ILFieldDef> addFieldNeverAttrs, FSharpFunc`2<ILType, ILAttribute> mkDebuggerTypeProxyAttribute, TcGlobals g, ILTypeRef tref, ILTypeDef td, IlxUnionInfo cud);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.ILX.Types : object {
    internal static string mkLowerName(string nm);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@89-18(IlxClosureApps this, IlxClosureApps obj, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxClosureApps instAppsAux(int n, FSharpList`1<ILType> inst, IlxClosureApps apps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxClosureLambdas instLambdasAux(int n, FSharpList`1<ILType> inst, IlxClosureLambdas lambdas);
    internal static IlxClosureFreeVar mkILFreeVar(string name, bool compgen, ILType ty);
    internal static Tuple`2<ILType, IlxClosureApps> destTyFuncApp(IlxClosureApps input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxClosureSpec mkILFormalCloRef(FSharpList`1<ILGenericParameterDef> gparams, IlxClosureRef csig, bool useStaticField);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType actualTypOfIlxUnionField(IlxUnionSpec cuspec, int idx, int fidx);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Morphs : object {
    [CompilationMappingAttribute("9")]
internal static bool morphCustomAttributeData { get; internal set; }
    internal static bool get_morphCustomAttributeData();
    internal static void set_morphCustomAttributeData(bool value);
    internal static void enableMorphCustomAttributeData();
    internal static void disableMorphCustomAttributeData();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode code_instr2instr(FSharpFunc`2<ILInstr, ILInstr> f, ILCode code);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode code_instr2instrs(FSharpFunc`2<ILInstr, FSharpList`1<ILInstr>> f, ILCode code);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode code_instr2instr_ty2ty(FSharpFunc`2<ILInstr, ILInstr> finstr, FSharpFunc`2<ILType, ILType> fTy, ILCode code);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType morphILTypeRefsInILType(FSharpFunc`2<ILTypeRef, ILTypeRef> f, ILType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeSpec tspec_tref2tref(FSharpFunc`2<ILTypeRef, ILTypeRef> f, ILTypeSpec tspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType ty_scoref2scoref_tyvar2ty(FSharpFunc`2<ILScopeRef, ILScopeRef> fs_0, FSharpFunc`2<ushort, ILType> fTyvar, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeSpec tspec_scoref2scoref_tyvar2ty(FSharpFunc`2<ILScopeRef, ILScopeRef> fs_0, FSharpFunc`2<ushort, ILType> fs_1, ILTypeSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCallingSignature callsig_scoref2scoref_tyvar2ty(FSharpFunc`2<ILScopeRef, ILScopeRef> f_0, FSharpFunc`2<ushort, ILType> f_1, ILCallingSignature x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> tys_scoref2scoref_tyvar2ty(FSharpFunc`2<ILScopeRef, ILScopeRef> f_0, FSharpFunc`2<ushort, ILType> f_1, FSharpList`1<ILType> i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef morphILScopeRefsInILTypeRef(FSharpFunc`2<ILScopeRef, ILScopeRef> fscope, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCallingSignature callsig_ty2ty(FSharpFunc`2<ILType, ILType> f, ILCallingSignature callsig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILGenericParameterDef gparam_ty2ty(FSharpFunc`2<ILType, ILType> f, ILGenericParameterDef gf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodRef mref_ty2ty(FSharpFunc`2<ILType, ILType> f, ILMethodRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodSpec mspec_ty2ty(FSharpFunc`2<ILType, ILType> factualTy, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>> fformalTy, ILMethodSpec x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldRef fref_ty2ty(FSharpFunc`2<ILType, ILType> f, ILFieldRef fref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec fspec_ty2ty(FSharpFunc`2<ILType, ILType> factualTy, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>> fformalTy, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribElem celem_ty2ty(FSharpFunc`2<ILType, ILType> f, ILAttribElem celem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute cattr_ty2ty(FSharpFunc`2<ILType, ILType> f, ILAttribute c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldDef fdef_ty2ty(FSharpFunc`2<ILType, ILType> fTyInCtxt, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILLocal morphILLocal(FSharpFunc`2<ILType, ILType> f, ILLocal l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<a>> morphILVarArgs(FSharpFunc`2<ILType, a> f, FSharpOption`1<FSharpList`1<ILType>> varargs);
    internal static ILFieldSpec conv_fspec@200(ILInstr i, FSharpFunc`2<ILType, ILType> factualTy, FSharpFunc`2<FSharpOption`1<ILInstr>, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>>> fformalTy, ILFieldSpec fr);
    internal static ILMethodSpec conv_mspec@203(ILInstr i, FSharpFunc`2<ILType, ILType> factualTy, FSharpFunc`2<FSharpOption`1<ILInstr>, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>>> fformalTy, ILMethodSpec mr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr morphILTypesInILInstr(FSharpFunc`2<FSharpOption`1<ILInstr>, FSharpFunc`2<ILType, ILType>> factualTy, FSharpFunc`2<FSharpOption`1<ILInstr>, FSharpFunc`2<FSharpChoice`2<ILMethodSpec, ILFieldSpec>, FSharpFunc`2<ILType, ILType>>> fformalTy, ILInstr i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILReturn morphILReturn(FSharpFunc`2<ILType, ILType> f, ILReturn r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILParameter morphILParameter(FSharpFunc`2<ILType, ILType> f, ILParameter p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDefs morphILMethodDefs(FSharpFunc`2<ILMethodDef, ILMethodDef> f, ILMethodDefs m);
    internal static ILTypeDef[] filtered@260(FSharpFunc`2<string, bool> isInKnownSet, ILTypeDef[] tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefs morphILTypeDefs(FSharpFunc`2<string, bool> isInKnownSet, FSharpFunc`2<ILTypeDef, ILTypeDef> f, ILTypeDefs tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDebugImport morphILDebugImport(a fs_0, FSharpFunc`2<ILType, ILType> f, ILDebugImport debugImport);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDebugImport[] morphILDebugImports(a fs_0, FSharpFunc`2<ILType, ILType> fs_1, ILDebugImport[] ilDebugImports);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodBody ilmbody_instr2instr_ty2ty(FSharpFunc`2<ILInstr, ILInstr> fs_0, FSharpFunc`2<ILType, ILType> fTyInCtxt, ILMethodBody ilmbody);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodBody morphILMethodBody(FSharpFunc`2<ILMethodBody, ILMethodBody> fMethBody, MethodBody x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILOverridesSpec ospec_ty2ty(FSharpFunc`2<ILType, ILType> f, ILOverridesSpec _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef mdef_ty2ty_ilmbody2ilmbody(FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>> fTyInCtxt, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILMethodBody, ILMethodBody>> fMethBody, ILMethodDef md);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldDefs fdefs_ty2ty(FSharpFunc`2<ILType, ILType> f, ILFieldDefs fdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDefs mdefs_ty2ty_ilmbody2ilmbody(FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>> fs_0, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILMethodBody, ILMethodBody>> fs_1, ILMethodDefs mdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodImplDef mimpl_ty2ty(FSharpFunc`2<ILType, ILType> f, ILMethodImplDef mimpl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDef edef_ty2ty(FSharpFunc`2<ILType, ILType> f, ILEventDef edef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDef pdef_ty2ty(FSharpFunc`2<ILType, ILType> f, ILPropertyDef pdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDefs pdefs_ty2ty(FSharpFunc`2<ILType, ILType> f, ILPropertyDefs pdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDefs edefs_ty2ty(FSharpFunc`2<ILType, ILType> f, ILEventDefs edefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDef tdef_ty2ty_ilmbody2ilmbody_mdefs2mdefs(FSharpFunc`2<string, bool> isInKnownSet, FSharpList`1<ILTypeDef> enc, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<ILType, ILType>>> fTyInCtxt, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<ILMethodDefs, ILMethodDefs>> fMethodDefs, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefs tdefs_ty2ty_ilmbody2ilmbody_mdefs2mdefs(FSharpFunc`2<string, bool> isInKnownSet, FSharpList`1<ILTypeDef> enc, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<a>, FSharpFunc`2<ILType, ILType>>> fs_0, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<ILMethodDefs, ILMethodDefs>> fs_1, ILTypeDefs tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAssemblyManifest manifest_ty2ty(FSharpFunc`2<ILType, ILType> f, ILAssemblyManifest m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILTypeInILModule_ilmbody2ilmbody_mdefs2mdefs(FSharpFunc`2<string, bool> isInKnownSet, FSharpFunc`2<ILModuleDef, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>>>> fTyInCtxt, FSharpFunc`2<ILModuleDef, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<ILMethodDefs, ILMethodDefs>>> fMethodDefs, ILModuleDef modul);
    internal static FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILMethodBody, ILMethodBody>> fMethBody@414(FSharpFunc`2<ILModuleDef, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILInstr, ILInstr>>>> fCode, FSharpFunc`2<ILModuleDef, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>>>> fTyInCtxt, ILModuleDef modCtxt, Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef> tdefCtxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILInstrsAndILTypesInILModule(FSharpFunc`2<string, bool> isInKnownSet, FSharpFunc`2<ILModuleDef, FSharpFunc`2<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILInstr, ILInstr>>>> fCode, FSharpFunc`2<ILModuleDef, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>>>> fTyInCtxt, ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILCode morphILInstrsInILCode(FSharpFunc`2<ILInstr, FSharpList`1<ILInstr>> f, ILCode ilcode);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILTypeInILModule(FSharpFunc`2<string, bool> isInKnownSet, FSharpFunc`2<ILModuleDef, FSharpFunc`2<FSharpOption`1<Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef>>, FSharpFunc`2<FSharpOption`1<ILMethodDef>, FSharpFunc`2<ILType, ILType>>>> fTyInCtxt, ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILTypeRefsInILModuleMemoized(FSharpFunc`2<string, bool> isInKnownSet, FSharpFunc`2<ILTypeRef, ILTypeRef> f, ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILModuleDef morphILScopeRefsInILModuleMemoized(FSharpFunc`2<string, bool> isInKnownSet, FSharpFunc`2<ILScopeRef, ILScopeRef> f, ILModuleDef modul);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.NativeRes : object {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.StrongNameSign : object {
    [CompilationMappingAttribute("9")]
internal static int ALG_TYPE_RSA { get; }
    [CompilationMappingAttribute("9")]
internal static int ALG_CLASS_KEY_EXCHANGE { get; }
    [CompilationMappingAttribute("9")]
internal static int ALG_CLASS_SIGNATURE { get; }
    [CompilationMappingAttribute("9")]
internal static int CALG_RSA_KEYX { get; }
    [CompilationMappingAttribute("9")]
internal static int CALG_RSA_SIGN { get; }
    [CompilationMappingAttribute("9")]
internal static int ALG_CLASS_HASH { get; }
    [CompilationMappingAttribute("9")]
internal static int ALG_TYPE_ANY { get; }
    [CompilationMappingAttribute("9")]
internal static int CALG_SHA1 { get; }
    [CompilationMappingAttribute("9")]
internal static int PUBLICKEYBLOB { get; }
    [CompilationMappingAttribute("9")]
internal static int PRIVATEKEYBLOB { get; }
    [CompilationMappingAttribute("9")]
internal static int BLOBHEADER_CURRENT_BVERSION { get; }
    [CompilationMappingAttribute("9")]
internal static int BLOBHEADER_LENGTH { get; }
    [CompilationMappingAttribute("9")]
internal static int RSA_PUB_MAGIC { get; }
    [CompilationMappingAttribute("9")]
internal static int RSA_PRIV_MAGIC { get; }
    internal static int get_ALG_TYPE_RSA();
    internal static int get_ALG_CLASS_KEY_EXCHANGE();
    internal static int get_ALG_CLASS_SIGNATURE();
    internal static int get_CALG_RSA_KEYX();
    internal static int get_CALG_RSA_SIGN();
    internal static int get_ALG_CLASS_HASH();
    internal static int get_ALG_TYPE_ANY();
    internal static int get_CALG_SHA1();
    internal static int get_PUBLICKEYBLOB();
    internal static int get_PRIVATEKEYBLOB();
    internal static int get_BLOBHEADER_CURRENT_BVERSION();
    internal static int get_BLOBHEADER_LENGTH();
    internal static int get_RSA_PUB_MAGIC();
    internal static int get_RSA_PRIV_MAGIC();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] hashAssembly(PEReader peReader, IncrementalHash hashAlgorithm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RSAParameters RSAParamatersFromBlob(Byte[] blob, KeyType keyType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void validateRSAField(Byte[] field, int expected, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] toCLRKeyBlob(RSAParameters rsaParameters, int algId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] createSignature(Byte[] hash, Byte[] keyBlob, KeyType keyType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void patchSignature(Stream stream, PEReader peReader, Byte[] signature);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void signStream(Stream stream, Byte[] keyBlob);
    internal static int signatureSize(Byte[] pk);
    internal static Byte[] getPublicKeyForKeyPair(Byte[] keyBlob);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@332-19(ILStrongNameSigner this, ILStrongNameSigner obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@332-20(IComparer comp, ILStrongNameSigner this, ILStrongNameSigner objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@332-2(IEqualityComparer comp, ILStrongNameSigner this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@332-5(ILStrongNameSigner this, object obj, IEqualityComparer comp, Unit unitVar);
    internal static int pkSignatureSize@363(Byte[] pk);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AbstractIL.Support : object {
    [CompilationMappingAttribute("9")]
internal static DateTime DateTime1970Jan01 { get; }
    internal static int E_FAIL { get; }
    internal static DateTime get_DateTime1970Jan01();
    internal static int absilWriteGetTimeStamp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_E_FAIL();
    internal static short bytesToWord(byte b0, byte b1);
    internal static int bytesToDWord(byte b0, byte b1, byte b2, byte b3);
    internal static Tuple`2<Byte[], int> dwToBytes(int n);
    internal static Tuple`2<Byte[], int> wToBytes(short n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_RESOURCE_DIRECTORY bytesToIRD(Byte[] buffer, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_RESOURCE_DIRECTORY_ENTRY bytesToIRDE(Byte[] buffer, int offset);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IMAGE_RESOURCE_DATA_ENTRY bytesToIRDataE(Byte[] buffer, int offset);
    internal static void SaveChunk@487(Byte[] pUnlinkedResource, int offset, FSharpRef`1<int> size, FSharpRef`1<int> unlinkedResourceOffset, Byte[] p, int sz);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] linkNativeResources(FSharpList`1<Byte[]> unlinkedResources, int rva);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Byte[] unlinkResource(int ulLinkedResourceBaseRVA, Byte[] pbLinkedResource);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AccessibilityLogic : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsAccessible(AccessorDomain ad, Accessibility taccess);
    [CompilerGeneratedAttribute]
internal static bool IsILMemberAccessible$cont@80(TcGlobals g, ImportMap amap, Range m, EntityRef tcrefOfViewedItem, AccessorDomain ad, ILMemberAccess access, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILMemberAccessible(TcGlobals g, ImportMap amap, Range m, EntityRef tcrefOfViewedItem, AccessorDomain ad, ILMemberAccess access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILTypeDefAccessible(ImportMap amap, Range m, AccessorDomain ad, FSharpOption`1<EntityRef> encTyconRefOpt, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTyconAccessibleViaVisibleTo(AccessorDomain ad, EntityRef tcrefOfViewedItem);
    internal static bool check@134-3(ImportMap amap, Range m, AccessorDomain ad, EntityRef tcrefOfViewedItem, ILScopeRef scoref, FSharpOption`1<Tuple`2<EntityRef, FSharpList`1<ILTypeDef>>> parentTycon, FSharpList`1<ILTypeDef> path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILTypeInfoAccessible(ImportMap amap, Range m, AccessorDomain ad, EntityRef tcrefOfViewedItem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILTypeAndMemberAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain adType, AccessorDomain ad, ILTypeInfo ty, ILMemberAccess access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsEntityAccessible(ImportMap amap, Range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckTyconAccessible(ImportMap amap, Range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTyconReprAccessible(ImportMap amap, Range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckTyconReprAccessible(ImportMap amap, Range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTypeAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain ad, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTypeInstAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain ad, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsProvidedMemberAccessible(ImportMap amap, Range m, AccessorDomain ad, TType ty, ILMemberAccess access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMemberAccess ComputeILAccess(bool isPublic, bool isFamily, bool isFamilyOrAssembly, bool isFamilyAndAssembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILFieldInfoAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain ad, ILFieldInfo x);
    internal static ILMemberAccess GetILAccessOfILEventInfo(ILEventInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILEventInfoAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain ad, ILEventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILMethInfoAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain adType, AccessorDomain ad, ILMethInfo ilminfo);
    [CompilerGeneratedAttribute]
internal static ILMemberAccess ilAccess$cont@270(ILTypeDef tdef, ILMethodRef mrefSet, ILMethodRef mrefGet, Unit unitVar);
    internal static ILMemberAccess GetILAccessOfILPropInfo(ILPropInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILPropInfoAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain ad, ILPropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsValAccessible(AccessorDomain ad, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValAccessible(Range m, AccessorDomain ad, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsUnionCaseAccessible(ImportMap amap, Range m, AccessorDomain ad, UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckUnionCaseAccessible(ImportMap amap, Range m, AccessorDomain ad, UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsRecdFieldAccessible(ImportMap amap, Range m, AccessorDomain ad, RecdFieldRef rfref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckRecdFieldAccessible(ImportMap amap, Range m, AccessorDomain ad, RecdFieldRef rfref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckRecdFieldInfoAccessible(ImportMap amap, Range m, AccessorDomain ad, RecdFieldInfo rfinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckILFieldInfoAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain ad, ILFieldInfo finfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTypeAndMethInfoAccessible(ImportMap amap, Range m, AccessorDomain accessDomainTy, AccessorDomain ad, MethInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMethInfoAccessible(ImportMap amap, Range m, AccessorDomain ad, MethInfo minfo);
    internal static FSharpOption`1<ILMemberAccess> tryGetILAccessForProvidedMethodBase@376(ProvidedMethodInfo mi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsPropInfoAccessible(TcGlobals g, ImportMap amap, Range m, AccessorDomain ad, PropInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsFieldInfoAccessible(AccessorDomain ad, RecdFieldInfo rfref);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AttributeChecking : object {
    internal static string langVersionPrefix { get; }
    internal static a fail();
    internal static object evalILAttribElem(ILAttribElem elem);
    [CompilerGeneratedAttribute]
internal static object evalFSharpAttribArg$cont@59(Const c, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object evalFSharpAttribArg(TcGlobals g, Expr attribExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> AttribInfosOfIL(TcGlobals g, ImportMap amap, ILScopeRef scoref, Range m, ILAttributes attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> AttribInfosOfFS(TcGlobals g, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> GetAttribInfosOfEntity(TcGlobals g, ImportMap amap, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> GetAttribInfosOfMethod(ImportMap amap, Range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> GetAttribInfosOfProp(ImportMap amap, Range m, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AttribInfo> GetAttribInfosOfEvent(ImportMap amap, Range m, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a BindMethInfoAttributes(Range m, MethInfo minfo, FSharpFunc`2<ILAttributes, a> f1, FSharpFunc`2<FSharpList`1<Attrib>, a> f2, FSharpFunc`2<Tainted`1<IProvidedCustomAttributeProvider>, a> f3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> TryBindMethInfoAttribute(TcGlobals g, Range m, BuiltinAttribInfo attribSpec, MethInfo minfo, FSharpFunc`2<Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>>, FSharpOption`1<a>> f1, FSharpFunc`2<Attrib, FSharpOption`1<a>> f2, FSharpFunc`2<Tuple`2<FSharpList`1<FSharpOption`1<object>>, FSharpList`1<Tuple`2<string, FSharpOption`1<object>>>>, FSharpOption`1<a>> f3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindMethInfoStringAttribute(TcGlobals g, Range m, BuiltinAttribInfo attribSpec, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfoHasAttribute(TcGlobals g, Range m, BuiltinAttribInfo attribSpec, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckCompilerFeatureRequiredAttribute(TcGlobals g, ILAttributes cattrs, string msg, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckILAttributes(TcGlobals g, bool isByrefLikeTyconRef, ILAttributes cattrs, Range m);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_langVersionPrefix();
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> CheckFSharpAttributes$cont@277-2(Range m, string s, bool isError, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> CheckFSharpAttributes$cont@273-1(Range m, FSharpOption`1<Attrib> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> CheckFSharpAttributes$cont@297-3(TcGlobals g, int n, Exception msg, bool isError, Unit unitVar);
    internal static bool isExperimentalAttributeDisabled@306(TcGlobals g, string s);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-2(TcGlobals g, FSharpList`1<Attrib> attribs, Range m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-1(TcGlobals g, FSharpList`1<Attrib> attribs, Range m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695(TcGlobals g, FSharpList`1<Attrib> attribs, Range m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> CheckFSharpAttributes$cont@273(TcGlobals g, FSharpList`1<Attrib> attribs, Range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckFSharpAttributes(TcGlobals g, FSharpList`1<Attrib> attribs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckProvidedAttributes(TcGlobals g, Range m, Tainted`1<IProvidedCustomAttributeProvider> provAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckILAttributesForUnseen(TcGlobals g, ILAttributes cattrs, a _m);
    [CompilerGeneratedAttribute]
internal static bool CheckFSharpAttributesForHidden$cont@353(TcGlobals g, FSharpList`1<Attrib> attribs, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckFSharpAttributesForHidden(TcGlobals g, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckFSharpAttributesForObsolete(TcGlobals g, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckFSharpAttributesForUnseen(TcGlobals g, FSharpList`1<Attrib> attribs, a _m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckProvidedAttributesForUnseen(Tainted`1<IProvidedCustomAttributeProvider> provAttribs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckPropInfoAttributes(PropInfo pinfo, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckILFieldAttributes(TcGlobals g, ILFieldInfo finfo, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckEntityAttributes(TcGlobals g, EntityRef tcref, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckILEventAttributes(TcGlobals g, EntityRef tcref, ILAttributes cattrs, Range m);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691(TcGlobals g, Range m, FSharpOption`1<a> tyargsOpt, MethInfo minfo, FSharpList`1<Attrib> fsAttribs, Unit _arg2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-3(TcGlobals g, Range m, FSharpOption`1<a> tyargsOpt, MethInfo minfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckMethInfoAttributes(TcGlobals g, Range m, FSharpOption`1<a> tyargsOpt, MethInfo minfo);
    internal static bool isUnseenByObsoleteAttrib@449(TcGlobals g, Range m, MethInfo minfo, Unit unitVar0);
    internal static bool isUnseenByHidingAttribute@462(TcGlobals g, Range m, TType ty, MethInfo minfo, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfoIsUnseen(TcGlobals g, Range m, TType ty, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PropInfoIsUnseen(a m, PropInfo pinfo);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-1(TcGlobals g, UnionCaseRef x, Range m, Unit _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckUnionCaseAttributes(TcGlobals g, UnionCaseRef x, Range m);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-3(TcGlobals g, RecdFieldRef x, Range m, Unit _arg2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-2(TcGlobals g, RecdFieldRef x, Range m, Unit _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckRecdFieldAttributes(TcGlobals g, RecdFieldRef x, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckValAttributes(TcGlobals g, ValRef x, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckRecdFieldInfoAttributes(TcGlobals g, RecdFieldInfo x, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsSecurityAttribute(TcGlobals g, ImportMap amap, IDictionary`2<long, bool> casmap, Attrib _arg1, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsSecurityCriticalAttribute(TcGlobals g, Attrib _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsAssemblyVersionAttribute(TcGlobals g, Attrib _arg1);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.AugmentWithHashCompare : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<FSharpList`1<ArgReprInfo>> unitArg { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<FSharpList`1<ArgReprInfo>> unaryArg { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<FSharpList`1<ArgReprInfo>> tupArg { get; }
    internal static SlotSig mkIComparableCompareToSlotSig(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig mkGenericIComparableCompareToSlotSig(TcGlobals g, TType ty);
    internal static SlotSig mkIStructuralComparableCompareToSlotSig(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig mkGenericIEquatableEqualsSlotSig(TcGlobals g, TType ty);
    internal static SlotSig mkIStructuralEquatableEqualsSlotSig(TcGlobals g);
    internal static SlotSig mkIStructuralEquatableGetHashCodeSlotSig(TcGlobals g);
    internal static SlotSig mkGetHashCodeSlotSig(TcGlobals g);
    internal static SlotSig mkEqualsSlotSig(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkThisTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkCompareObjTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkCompareTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkCompareWithComparerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkEqualsObjTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkEqualsTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkEqualsWithComparerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkHashTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkHashWithComparerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRelBinOp(TcGlobals g, ILInstr op, Range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkILCallGetComparer(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkILCallGetEqualityComparer(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkShl(TcGlobals g, Range m, Expr acce, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkShr(TcGlobals g, Range m, Expr acce, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAdd(TcGlobals g, Range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAddToHashAcc(TcGlobals g, Range m, Expr e, ValRef accv, Expr acce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCombineHashGenerators(TcGlobals g, Range m, FSharpList`1<Expr> exprs, ValRef accv, Expr acce);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Val>, Expr> mkThatAddrLocalIfNeeded(TcGlobals g, Range m, Expr tcve, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<Val, Val, Expr, Expr> mkThisVarThatVar(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkThatVarBind(TcGlobals g, Range m, TType ty, Val thataddrv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindThatAddr(TcGlobals g, Range m, TType ty, Val thataddrv, Val thatv, Expr thate, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindThatAddrIfNeeded(Range m, FSharpOption`1<Val> thataddrvOpt, Val thatv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompareTestConjuncts(TcGlobals g, Range m, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkEqualsTestConjuncts(TcGlobals g, Range m, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, TType> mkMinimalTy(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindNullComparison(TcGlobals g, Range m, Expr thise, Expr thate, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindThisNullEquals(TcGlobals g, Range m, Expr thise, Expr thate, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindThatNullEquals(TcGlobals g, Range m, Expr thise, Expr thate, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBindNullHash(TcGlobals g, Range m, Expr thise, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkRecdCompare(TcGlobals g, EntityRef tcref, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRecdCompareWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, a _thisv, Expr thise, b _arg1, Expr thate, Expr compe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkRecdEquality(TcGlobals g, EntityRef tcref, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRecdEqualityWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, a _thisv, Expr thise, Expr thatobje, Val thatv, Expr thate, Expr compe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkExnEquality(TcGlobals g, EntityRef exnref, Entity exnc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkExnEqualityWithComparer(TcGlobals g, EntityRef exnref, Entity exnc, a _thisv, Expr thise, Expr thatobje, Val thatv, Expr thate, Expr compe);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkTest@341-6(TcGlobals g, FSharpList`1<TType> tinst, Expr compe, UnionCaseRef cref, Range m, Expr thise, Expr thataddre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkUnionCompare(TcGlobals g, EntityRef tcref, Entity tycon);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkTest@401-8(TcGlobals g, Expr compe, FSharpList`1<TType> tinst, UnionCaseRef cref, Range m, Expr thise, Expr thataddre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnionCompareWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, a _thisv, Expr thise, b _thatobjv, Expr thatcaste, Expr compe);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkTest@463-10(TcGlobals g, FSharpList`1<TType> tinst, UnionCaseRef cref, Range m, Expr thise, Expr thataddre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Expr> mkUnionEquality(TcGlobals g, EntityRef tcref, Entity tycon);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkTest@524-12(TcGlobals g, Expr compe, FSharpList`1<TType> tinst, UnionCaseRef cref, Range m, Expr thise, Expr thataddre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnionEqualityWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, a _thisv, Expr thise, Expr thatobje, Val thatv, Expr thate, Expr compe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkRecdHashWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, Expr compe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkExnHashWithComparer(TcGlobals g, EntityRef exnref, Entity exnc, Expr compe);
    internal static FSharpFunc`2<int, FSharpFunc`2<RecdField, Expr>> mkHash@622-1(TcGlobals g, Expr compe, FSharpList`1<TType> tinst, UnionCaseRef c1ref, Range m, Expr thise);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkUnionHashWithComparer(TcGlobals g, EntityRef tcref, Entity tycon, Expr compe);
    internal static bool isNominalExnc(Entity exnc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTrueFSharpStructTycon(a _g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBeAugmentedWithEquals(a g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canBeAugmentedWithCompare(a g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<bool, bool, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, FSharpOption`1<bool>, Tuple`2<FSharpOption`1<bool>, FSharpOption`1<bool>>> getAugmentationAttribs(TcGlobals g, Entity tycon);
    internal static bool hasNominalInterface@769(TcGlobals g, ImportMap amap, Entity tycon, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAugmentationAttribs(bool isImplementation, TcGlobals g, ImportMap amap, Entity tycon);
    [CompilerGeneratedAttribute]
internal static bool TyconIsCandidateForAugmentationWithCompare$cont@814(TcGlobals g, Entity tycon, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconIsCandidateForAugmentationWithCompare(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconIsCandidateForAugmentationWithEquals(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconIsCandidateForAugmentationWithHash(TcGlobals g, Entity tycon);
    internal static ValMemberInfo slotImplMethod(bool final, EntityRef c, SlotSig slotsig);
    internal static ValMemberInfo nonVirtualMethod(EntityRef c);
    internal static FSharpList`1<FSharpList`1<ArgReprInfo>> get_unitArg();
    internal static FSharpList`1<FSharpList`1<ArgReprInfo>> get_unaryArg();
    internal static FSharpList`1<FSharpList`1<ArgReprInfo>> get_tupArg();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val mkValSpec(TcGlobals g, EntityRef tcref, TType ty, Accessibility vis, FSharpOption`1<SlotSig> slotsig, string methn, TType valTy, FSharpList`1<FSharpList`1<ArgReprInfo>> argData);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Val> MakeValsForCompareAugmentation(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val MakeValsForCompareWithComparerAugmentation(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Val> MakeValsForEqualsAugmentation(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Val, Val> MakeValsForEqualityWithComparerAugmentation(TcGlobals g, EntityRef tcref);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Binding> mkCompare$cont@932(TcGlobals g, Entity tycon, EntityRef tcref, Range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, Tuple`3<Val, Val, Expr>>>> comparef, FSharpOption`1<Tuple`2<ValRef, ValRef>> matchValue, Unit unitVar);
    internal static FSharpList`1<Binding> mkCompare@928(TcGlobals g, Entity tycon, EntityRef tcref, Range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, Tuple`3<Val, Val, Expr>>>> comparef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> MakeBindingsForCompareAugmentation(TcGlobals g, Entity tycon);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Binding> mkCompare$cont@965-1(TcGlobals g, Entity tycon, EntityRef tcref, Range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, Expr>>>>>> comparef, FSharpOption`1<ValRef> matchValue, Unit unitVar);
    internal static FSharpList`1<Binding> mkCompare@961-1(TcGlobals g, Entity tycon, EntityRef tcref, Range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, Expr>>>>>> comparef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> MakeBindingsForCompareWithComparerAugmentation(TcGlobals g, Entity tycon);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Binding> mkStructuralEquatable$cont@993(TcGlobals g, Entity tycon, EntityRef tcref, Range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Expr, Tuple`2<Val, Expr>>>>> hashf, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, Expr>>>>>>> equalsf, FSharpOption`1<Tuple`3<ValRef, ValRef, ValRef>> matchValue, Unit unitVar);
    internal static FSharpList`1<Binding> mkStructuralEquatable@987(TcGlobals g, Entity tycon, EntityRef tcref, Range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Expr, Tuple`2<Val, Expr>>>>> hashf, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, FSharpFunc`2<Tuple`2<Val, Expr>, FSharpFunc`2<Expr, Expr>>>>>>> equalsf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> MakeBindingsForEqualityWithComparerAugmentation(TcGlobals g, Entity tycon);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Binding> mkEquals$cont@1047(TcGlobals g, Entity tycon, EntityRef tcref, Range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, Tuple`3<Val, Val, Expr>>>> equalsf, FSharpOption`1<Tuple`2<ValRef, ValRef>> matchValue, Unit unitVar);
    internal static FSharpList`1<Binding> mkEquals@1042(TcGlobals g, Entity tycon, EntityRef tcref, Range m, FSharpList`1<Typar> tps, FSharpFunc`2<TcGlobals, FSharpFunc`2<EntityRef, FSharpFunc`2<Entity, Tuple`3<Val, Val, Expr>>>> equalsf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> MakeBindingsForEqualsAugmentation(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeDefinitelyHasEquality(TcGlobals g, TType ty);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.BinaryResourceFormats : object {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.BuildGraph : object {
    [CompilationMappingAttribute("9")]
internal static NodeCodeBuilder node { get; }
    internal static FSharpAsync`1<a> wrapThreadStaticInfo(FSharpAsync`1<a> computation);
    internal static FSharpAsync`1<T> Async`1.AwaitNodeCode.Static(NodeCode`1<T> node);
    internal static NodeCodeBuilder get_node();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckBasics : object {
    [CompilationMappingAttribute("9")]
internal static int TcStackGuardDepth { get; }
    internal static int get_TcStackGuardDepth();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckComputationExpressions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> TryFindIntrinsicOrExtensionMethInfo(ResultCollectionSettings collectionSettings, TcFileState cenv, TcEnv env, Range m, AccessorDomain ad, string nm, TType ty);
    internal static FSharpOption`1<SynPat> |ExprAsPat|_|(SynExpr f);
    internal static bool isOpName@59(TcFileState cenv, TcEnv env, Range m, AccessorDomain ad, string opName, ValRef vref, string s);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |JoinRelation|_|$cont@65(TcFileState cenv, TcEnv env, SynExpr expr, Range m, AccessorDomain ad, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |JoinRelation|_|(TcFileState cenv, TcEnv env, SynExpr expr);
    internal static SynExpr elimFastIntegerForLoop(DebugPointAtFor spFor, DebugPointAtInOrTo spTo, Ident id, SynExpr start, bool dir, SynExpr finish, SynExpr innerExpr, Range m);
    internal static bool YieldFree@96(SynExpr expr);
    internal static bool YieldFree@128-3(SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool YieldFree(TcFileState cenv, SynExpr expr);
    internal static bool IsSimpleSemicolonSequenceElement@167(TcFileState cenv, bool acceptDeprecated, SynExpr expr);
    internal static FSharpOption`1<FSharpList`1<SynExpr>> TryGetSimpleSemicolonSequenceOfComprehension@186(TcFileState cenv, bool acceptDeprecated, SynExpr expr, FSharpList`1<SynExpr> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<SynExpr>> |SimpleSemicolonSequence|_|(TcFileState cenv, bool acceptDeprecated, SynExpr cexpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecordNameAndTypeResolutions(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr expr);
    internal static SynExpr mkSynCall@239(string builderValName, string nm, Range m, FSharpList`1<SynExpr> args);
    internal static bool hasMethInfo@250(TcFileState cenv, TcEnv env, TType builderTy, AccessorDomain ad, Range mBuilderVal, string nm);
    internal static SynExpr mkSourceExpr@255(string builderValName, FSharpList`1<MethInfo> sourceMethInfo, SynExpr callExpr);
    internal static FSharpFunc`2<SynExpr, SynExpr> mkSourceExprConditional@260(string builderValName, FSharpList`1<MethInfo> sourceMethInfo, bool isFromSource);
    internal static FSharpOption`1<bool> flagSearch@285(TcFileState cenv, Range mBuilderVal, MethInfo methInfo, string propName);
    internal static bool isOpDataCountAllowed@331(TcFileState cenv, FSharpList`1<a> opDatas);
    internal static FSharpOption`1<FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> tryGetDataForCustomOperation@330(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static CustomOperationsMode hasCustomOperations@352(FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>> customOperationMethods, Unit unitVar0);
    internal static FSharpFunc`2<FSharpList`1<Tuple`8<string, a, b, c, d, e, f, Tuple`2<g, h>>>, i> customOperationCheckValidity@356(Range m, FSharpFunc`2<Tuple`8<string, a, b, c, d, e, f, Tuple`2<g, h>>, i> f);
    internal static bool customOperationMaintainsVarSpace@365(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationMaintainsVarSpaceUsingBind@371(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationIsLikeZip@377(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationIsLikeJoin@383(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationIsLikeGroupJoin@389(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static string customOperationJoinConditionWord@395(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool customOperationAllowsInto@402(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static FSharpOption`1<string> customOpUsageText@408(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static FSharpOption`1<FSharpList`1<FSharpOption`1<FSharpList`1<ParamAttribs>>>> tryGetArgAttribsForCustomOperator@435(TcFileState cenv, Range mWhole, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static FSharpOption`1<FSharpList`1<FSharpOption`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>>> tryGetArgInfosForCustomOperator@446(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static FSharpOption`1<int> tryExpectedArgCountForCustomOperator@460(TcFileState cenv, Range mWhole, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, Ident nm);
    internal static bool isCustomOperationProjectionParameter@486(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, int i, Ident nm);
    internal static FSharpOption`1<Tuple`5<bool, SynPat, SynExpr, SynExpr, SynExpr>> |ForEachThen|_|@504(SynExpr synExpr);
    internal static FSharpFunc`2<SynExpr, FSharpOption`1<Ident>> |CustomOpId|_|@510(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> predicate);
    internal static FSharpOption`1<Tuple`3<SynExpr, SynExpr, Range>> |InExpr|_|@516(SynExpr synExpr);
    internal static FSharpFunc`2<SynExpr, FSharpOption`1<Tuple`2<SynExpr, SynExpr>>> |OnExpr|_|@522(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, TcEnv env, Ident nm);
    internal static FSharpOption`1<Tuple`3<SynExpr, Range, SynPat>> |IntoSuffix|_|@534(SynExpr e);
    internal static SynPat arbPat@541(Range m);
    internal static Tuple`3<SynExpr, SynPat, bool> MatchIntoSuffixOrRecover@543(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, TcEnv env, bool alreadyGivenError, Ident nm, SynExpr synExpr);
    internal static Tuple`2<SynExpr, SynExpr> MatchOnExprOrRecover@555(TcFileState cenv, UnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, TcEnv env, bool alreadyGivenError, Ident nm, SynExpr onExpr);
    internal static FSharpOption`1<Tuple`4<Ident, SynPat, Range, bool>> JoinOrGroupJoinOp@565(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> detector, SynExpr synExpr);
    internal static SynExpr arbKeySelectors@585(Range m);
    internal static FSharpOption`1<Tuple`5<Ident, SynPat, SynExpr, SynExpr, Range>> |JoinExpr|_|@587(TcFileState cenv, UnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, TcEnv env, SynExpr synExpr);
    internal static FSharpOption`1<Tuple`6<Ident, SynPat, SynExpr, SynExpr, SynPat, Range>> |GroupJoinExpr|_|@598(TcFileState cenv, UnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, SynExpr synExpr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`6<Ident, SynPat, SynExpr, FSharpOption`1<SynExpr>, FSharpOption`1<SynPat>, Range>> |JoinOrGroupJoinOrZipClause|_|$cont@614(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, SynExpr synExpr, Unit unitVar);
    internal static FSharpOption`1<Tuple`6<Ident, SynPat, SynExpr, FSharpOption`1<SynExpr>, FSharpOption`1<SynPat>, Range>> |JoinOrGroupJoinOrZipClause|_|@612(TcFileState cenv, UnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, SynExpr synExpr);
    internal static FSharpFunc`2<SynExpr, FSharpOption`1<Tuple`8<bool, SynPat, SynExpr, Ident, SynPat, SynExpr, FSharpOption`1<SynExpr>, Tuple`3<FSharpOption`1<SynPat>, Range, SynExpr>>>> |ForEachThenJoinOrGroupJoinOrZipClause|_|@640(TcFileState cenv, UnscopedTyparEnv tpenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, bool strict);
    internal static Tuple`2<SynExpr, FSharpList`1<SynExpr>> strip@658-1(SynExpr e);
    internal static Tuple`2<SynExpr, FSharpList`1<SynExpr>> |StripApps|@657(SynExpr e);
    internal static Tuple`2<SynExpr, FSharpOption`1<Tuple`2<Range, SynPat>>> |OptionalIntoSuffix|@668(SynExpr e);
    internal static FSharpOption`1<Tuple`5<Ident, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>, SynExpr, Range, FSharpOption`1<SynPat>>> |CustomOperationClause|_|@673(TcFileState cenv, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, TcEnv env, SynExpr e);
    internal static SynExpr mkSynLambda@688(SynSimplePats p, SynExpr e, Range m);
    internal static SynExpr mkExprForVarSpace@690(Range m, FSharpList`1<Val> patvs);
    internal static SynSimplePats mkSimplePatForVarSpace@696(Range m, FSharpList`1<Val> patvs);
    internal static SynPat mkPatForVarSpace@704(Range m, FSharpList`1<Val> patvs);
    internal static Tuple`2<SynExpr, FSharpOption`1<SynExpr>> |OptionalSequential|@710(SynExpr e);
    internal static Range rangeForCombine@718(SynExpr innerComp1);
    internal static bool checkForBinaryApp@733(TcFileState cenv, Range mWhole, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, SynExpr comp);
    internal static LazyWithContext`2<Tuple`2<FSharpList`1<Val>, a>, Range> addVarsToVarSpace@751(LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, FSharpFunc`2<Range, FSharpFunc`2<TcEnv, Tuple`2<FSharpList`1<Val>, a>>> f);
    internal static FSharpFunc`2<SynExpr, SynExpr> addBindDebugPoint@761(DebugPointAtBinding spBind);
    internal static FSharpFunc`2<SynExpr, SynExpr> mkJoinExpr@851(string builderValName, Range mOpCore, SynExpr firstSource, SynExpr secondSource, SynSimplePats firstSourceSimplePats, SynSimplePats secondSourceSimplePats, MethInfo methInfo, SynExpr keySelector1, SynExpr keySelector2, SynSimplePats innerPat);
    internal static SynExpr wrapInArbErrSequence@880(SynExpr l, string caption);
    internal static bool isNullableOp@885(string opId);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<SynExpr, SynExpr>, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range>> tryTrans$cont@893-1(TcFileState cenv, string builderValName, TcEnv env, Ident nm, Range mOpCore, SynExpr firstSource, SynExpr secondSource, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpaceWithGroupJoinVars, SynSimplePats firstSourceSimplePats, SynSimplePats secondSourceSimplePats, MethInfo methInfo, SynPat secondResultPat, SynExpr relExpr, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<SynExpr, SynExpr>, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range>> tryTrans$cont@917-2(TcFileState cenv, string builderValName, TcEnv env, Ident nm, Range mOpCore, SynExpr firstSource, SynExpr secondSource, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpaceWithSecondVars, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpaceWithGroupJoinVars, SynSimplePats firstSourceSimplePats, SynSimplePats secondSourceSimplePats, MethInfo methInfo, SynExpr relExpr, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@842(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CustomOperationsMode q, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, FSharpOption`1<SynPat> secondResultPatOpt, Ident nm, Range mOpCore, FSharpOption`1<SynExpr> keySelectorsOpt, SynExpr innerComp, SynExpr firstSource, SynExpr secondSource, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpaceWithSecondVars, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpaceWithGroupJoinVars, SynSimplePats firstSourceSimplePats, SynSimplePats secondSourceSimplePats, FSharpOption`1<FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@1009-3(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CustomOperationsMode q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, DebugPointAtWhile spWhile, SynExpr innerComp, SynExpr guardExpr, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@1065-4(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, SynExpr unwindExpr, SynExprTryFinallyTrivia trivia, DebugPointAtTry spTry, DebugPointAtFinally spFinally, SynExpr innerComp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@1215-5(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CustomOperationsMode q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, SynExprLetOrUseTrivia trivia, Range m, bool isRec, SynExpr innerComp, FSharpList`1<SynBinding> binds, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@1276-6(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, DebugPointAtBinding spBind, SynExpr rhsExpr, SynPat pat, bool isFromSource, SynExpr innerComp, Ident id, Unit unitVar);
    internal static string mkMergeSourcesName@1355(int n);
    internal static int loop@1358-71(TcFileState cenv, TType builderTy, AccessorDomain ad, TcEnv env, Range mBind, int n);
    internal static Tuple`2<SynExpr, SynPat> mergeSources@1368(TcFileState cenv, TType builderTy, AccessorDomain ad, string builderValName, TcEnv env, SynPat letPat, Range mBind, Range sourcesRange, string bindNName, int maxMergeSources, FSharpList`1<Tuple`2<SynExpr, SynPat>> sourcesAndPats);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@1341-8(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CustomOperationsMode q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, DebugPointAtBinding spBind, SynPat letPat, SynExpr innerComp, Range mBind, FSharpList`1<SynExpr> sources, FSharpList`1<SynPat> pats, Range sourcesRange, string bindNName, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@1308-7(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CustomOperationsMode q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, SynExpr comp@1308, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, DebugPointAtBinding spBind, SynExpr letRhsExpr, SynPat letPat, Range letBindRange, bool isFromSource, SynExpr innerComp, FSharpList`1<SynExprAndBang> andBangBindings, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<SynExpr> tryTrans$cont@1436-9(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt, SynExprTryWithTrivia trivia, DebugPointAtWith spWith, DebugPointAtTry spTry, Range mTryToLast, SynExpr innerComp, FSharpList`1<SynMatchClause> clauses, Unit unitVar);
    internal static FSharpOption`1<SynExpr> tryTrans@781(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CompExprTranslationPass firstTry, CustomOperationsMode q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, SynExpr comp@781-1, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt);
    internal static SynExpr consumeCustomOpClauses@1517(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CustomOperationsMode q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, SynExpr dataCompPrior, SynExpr compClausesExpr, bool lastUsesBind, Range mClause);
    internal static SynExpr transNoQueryOps@1626(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, SynExpr comp@1626-2);
    internal static SynExpr trans@1629-2(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CompExprTranslationPass firstTry, CustomOperationsMode q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, SynExpr comp@1629-3, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt);
    internal static SynExpr transBind@1670(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, CustomOperationsMode q, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, Range bindRange, FSharpFunc`2<SynExpr, SynExpr> addBindDebugPoint, string bindName, FSharpList`1<SynExpr> bindArgs, SynPat consumePat, SynExpr innerComp, FSharpFunc`2<SynExpr, SynExpr> translatedCtxt);
    internal static FSharpOption`1<Tuple`2<SynExpr, FSharpOption`1<Tuple`2<SynExpr, Range>>>> convertSimpleReturnToExpr@1711(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> varSpace, SynExpr innerComp);
    internal static bool isSimpleExpr@1774(TcFileState cenv, UnscopedTyparEnv tpenv, Range mWhole, SynExpr comp, TType builderTy, TcGlobals g, AccessorDomain ad, string builderValName, bool isQuery, FSharpList`1<MethInfo> sourceMethInfo, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByKeyword, IDictionary`2<string, FSharpList`1<Tuple`8<string, bool, bool, bool, bool, bool, bool, Tuple`2<FSharpOption`1<string>, MethInfo>>>> customOperationMethodsIndexedByMethodName, FSharpFunc`2<Ident, bool> customOperationIsLikeZip, FSharpFunc`2<Ident, bool> customOperationIsLikeJoin, FSharpFunc`2<Ident, bool> customOperationIsLikeGroupJoin, TcEnv env, LazyWithContext`2<Tuple`2<FSharpList`1<Val>, TcEnv>, Range> emptyVarSpace, bool enableImplicitYield, SynExpr comp@1774-4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcComputationExpression(TcFileState cenv, TcEnv env, OverallTy overallTy, UnscopedTyparEnv tpenv, Range mWhole, Expr interpExpr, TType builderTy, SynExpr comp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqEmpty(TcFileState cenv, TcEnv env, Range m, TType genTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqCollect(TcFileState cenv, TcEnv env, Range m, TType enumElemTy, TType genTy, Expr lam, Expr enumExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqUsing(TcFileState cenv, TcEnv env, Range m, TType resourceTy, TType genTy, Expr resourceExpr, Expr lam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqDelay(TcFileState cenv, TcEnv env, Range m, TType genTy, Expr lam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqAppend(TcFileState cenv, TcEnv env, Range m, TType genTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqFromFunctions(TcFileState cenv, TcEnv env, Range m, TType genTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqFinally(TcFileState cenv, TcEnv env, Range m, TType genTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSeqTryWith(TcFileState cenv, TcEnv env, Range m, TType genTy, Expr origSeq, Expr exnFilter, Expr exnHandler);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MatchClause> mkSeqExprMatchClauses(Pattern pat, FSharpList`1<Val> vspecs, Expr innerExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> compileSeqExprMatchClauses(TcFileState cenv, TcEnv env, Range inputExprMark, Pattern pat, FSharpList`1<Val> vspecs, Expr innerExpr, FSharpOption`1<Expr> inputExprOpt, TType bindPatTy, TType genInnerTy);
    internal static Expr mkSeqDelayedExpr@1928(TcFileState cenv, TcEnv env, Range m, Expr coreExpr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@1935(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@1935, TType genOuterTy, UnscopedTyparEnv tpenv, DebugPointAtInOrTo spIn, DebugPointAtFor spFor, SynExpr pseudoEnumExpr, SynPat pat, SynExpr innerComp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@1984-1(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@1984-1, TType genOuterTy, UnscopedTyparEnv tpenv, DebugPointAtWhile spWhile, SynExpr innerComp, SynExpr guardExpr, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@2005-2(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@2005-2, TType genOuterTy, UnscopedTyparEnv tpenv, SynExpr unwindExpr, SynExprTryFinallyTrivia trivia, DebugPointAtTry spTry, DebugPointAtFinally spFinally, Range mTryToLast, SynExpr innerComp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@2035-3(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@2035-3, TType genOuterTy, UnscopedTyparEnv tpenv, DebugPointAtSequential sp, Range m@2035-1, SynExpr innerComp2, SynExpr innerComp1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@2053-4(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@2053-4, TType genOuterTy, UnscopedTyparEnv tpenv, SynExprIfThenElseTrivia trivia, SynExpr thenComp, DebugPointAtBinding spIfToThen, Range mIfToEndOfElseBranch, SynExpr guardExpr, FSharpOption`1<SynExpr> elseCompOpt, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@2073-5(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@2073-5, TType genOuterTy, UnscopedTyparEnv tpenv, Range wholeExprMark, DebugPointAtBinding spBind, SynExpr rhsExpr, SynPat pat, SynExpr innerComp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@2124-6(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@2124-6, TType genOuterTy, UnscopedTyparEnv tpenv, FSharpList`1<SynMatchClause> withList, SynExprTryWithTrivia trivia, Range mTryToWith, SynExpr innerTry, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@2157-7(TcFileState cenv, TcEnv env, TType genOuterTy, UnscopedTyparEnv tpenv, SynExpr synYieldExpr, Range m, bool isYield, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody$cont@2175-8(TcFileState cenv, TcGlobals g, bool flex, TcEnv env, TType genOuterTy, UnscopedTyparEnv tpenv, SynExpr synYieldExpr, Range m, bool isYield, Unit unitVar);
    internal static FSharpOption`1<Tuple`2<Expr, UnscopedTyparEnv>> tryTcSequenceExprBody@1932(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@1932-7, TType genOuterTy, UnscopedTyparEnv tpenv, SynExpr comp);
    internal static Tuple`2<Expr, UnscopedTyparEnv> tcSequenceExprBody@2196(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@2196-8, TType genOuterTy, UnscopedTyparEnv tpenv, SynExpr comp);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpChoice`2<Expr, Expr>, UnscopedTyparEnv> tcSequenceExprBodyAsSequenceOrStatement$cont@2211(TcFileState cenv, TcGlobals g, bool enableImplicitYield, TcEnv env, TType genOuterTy, UnscopedTyparEnv tpenv, SynExpr comp, Unit unitVar);
    internal static Tuple`2<FSharpChoice`2<Expr, Expr>, UnscopedTyparEnv> tcSequenceExprBodyAsSequenceOrStatement@2206(TcFileState cenv, TcEnv env, OverallTy overallTy, Range m, TcGlobals g, bool flex, bool enableImplicitYield, TcEnv env@2206-9, TType genOuterTy, UnscopedTyparEnv tpenv, SynExpr comp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcSequenceExpression(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr comp, OverallTy overallTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcSequenceExpressionEntry(TcFileState cenv, TcEnv env, OverallTy overallTy, UnscopedTyparEnv tpenv, bool hasBuilder, SynExpr comp, Range m);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcArrayOrListComputedExpression$cont@2301(TcFileState cenv, TcEnv env, OverallTy overallTy, UnscopedTyparEnv tpenv, bool isArray, SynExpr comp, Range m, bool validateExpressionWithIfRequiresParenthesis, FSharpList`1<SynExpr> elems, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcArrayOrListComputedExpression(TcFileState cenv, TcEnv env, OverallTy overallTy, UnscopedTyparEnv tpenv, bool isArray, SynExpr comp, Range m);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckDeclarations : object {
    [CompilationMappingAttribute("9")]
internal static TopAttribs EmptyTopAttrs { get; }
    internal static ContainerInfo ModuleOrNamespaceContainerInfo(EntityRef modref);
    internal static ContainerInfo TyconContainerInfo(ParentRef parent, EntityRef tcref, FSharpList`1<Typar> declaredTyconTypars, SafeInitData safeInitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalExnDefnAndReport(TcResultsSink tcSink, Range scopem, TcEnv env, Entity exnc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalTyconRefs(bool ownDefinition, TcGlobals g, ImportMap amap, Range m, FSharpList`1<EntityRef> tcrefs, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalTycons(TcGlobals g, ImportMap amap, Range m, FSharpList`1<Entity> tycons, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalTyconsAndReport(TcResultsSink tcSink, Range scopem, TcGlobals g, ImportMap amap, Range m, FSharpList`1<Entity> tycons, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalSubModule(TcGlobals g, ImportMap amap, Range m, TcEnv env, Entity moduleEntity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalSubModuleAndReport(TcResultsSink tcSink, Range scopem, TcGlobals g, ImportMap amap, Range m, TcEnv env, Entity moduleEntity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceType, FSharpList`1<Entity>> BuildRootModuleType(FSharpList`1<Ident> enclosingNamespacePath, CompilationPath cpath, ModuleOrNamespaceType moduleTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceContents BuildRootModuleContents(bool isModule, FSharpList`1<Ident> enclosingNamespacePath, CompilationPath cpath, ModuleOrNamespaceContents moduleContents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Ident, FSharpList`1<Ident>>> TryStripPrefixPath(TcGlobals g, FSharpList`1<Ident> enclosingNamespacePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddModuleAbbreviationAndReport(TcResultsSink tcSink, Range scopem, Ident id, FSharpList`1<EntityRef> modrefs, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv OpenModuleOrNamespaceRefs(TcResultsSink tcSink, TcGlobals g, ImportMap amap, Range scopem, bool root, TcEnv env, FSharpList`1<EntityRef> mvvs, OpenDeclaration openDeclaration);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv OpenTypeContent(TcResultsSink tcSink, TcGlobals g, ImportMap amap, Range scopem, TcEnv env, TType ty, OpenDeclaration openDeclaration);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddRootModuleOrNamespaceRefs(TcGlobals g, ImportMap amap, Range m, TcEnv env, FSharpList`1<EntityRef> modrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv addInternalsAccessibility(TcEnv env, CcuThunk ccu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddNonLocalCcu(TcGlobals g, ImportMap amap, Range scopem, TcEnv env, string assemblyName, CcuThunk ccu, FSharpList`1<string> internalsVisibleToAttributes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalRootModuleOrNamespace(TcResultsSink tcSink, TcGlobals g, ImportMap amap, Range scopem, TcEnv env, ModuleOrNamespaceType moduleTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv ImplicitlyOpenOwnNamespace(TcResultsSink tcSink, TcGlobals g, ImportMap amap, Range scopem, FSharpList`1<Ident> enclosingNamespacePath, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckNamespaceModuleOrTypeName(TcGlobals g, Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> CheckDuplicates(FSharpFunc`2<a, Ident> idf, string k, FSharpList`1<a> elems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDuplicatesArgNames(SynValSig synVal, Range m);
    internal static void CheckDuplicatesAbstractMethodParmsSig(FSharpList`1<SynTypeDefnSig> typeSpecs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishInterface(TcFileState cenv, DisplayEnv denv, EntityRef tcref, Range m, bool isCompGen, TType interfaceTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, UnscopedTyparEnv> TcAndPublishMemberSpec(TcFileState cenv, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, UnscopedTyparEnv tpenv, SynMemberSig memb);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, UnscopedTyparEnv> TcTyconMemberSpecs(TcFileState cenv, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, UnscopedTyparEnv tpenv, FSharpList`1<SynMemberSig> augSpfn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>> TcOpenLidAndPermitAutoResolve(TcResultsSink tcSink, TcEnv env, ImportMap amap, FSharpList`1<Ident> longId);
    internal static bool IsPartiallyQualifiedNamespace@658(TcGlobals g, FSharpList`1<Ident> longId, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TcEnv, FSharpList`1<OpenDeclaration>> TcOpenModuleOrNamespaceDecl(TcResultsSink tcSink, TcGlobals g, ImportMap amap, Range scopem, TcEnv env, FSharpList`1<Ident> longId, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TcEnv, FSharpList`1<OpenDeclaration>> TcOpenTypeDecl(TcFileState cenv, Range mOpenDecl, Range scopem, TcEnv env, SynType synType, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TcEnv, FSharpList`1<OpenDeclaration>> TcOpenDecl(TcFileState cenv, Range mOpenDecl, Range scopem, TcEnv env, SynOpenDeclTarget target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdField MakeSafeInitField(TcFileState cenv, TcEnv env, Range m, bool isStatic);
    internal static void ReportErrorOnStaticClass(FSharpList`1<SynMemberDefn> synMembers);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`3<TType, FSharpList`1<SynMemberDefn>, Range>> interfacesFromTypeDefn$cont@1792(TcFileState cenv, bool isMutRec, TcGlobals g, TcEnv envForTycon, EntityRef tcref, FSharpList`1<Typar> declaredTyconTypars, OverridesOK overridesOK, SynMemberDefn _arg1, Unit unitVar);
    internal static FSharpList`1<Tuple`3<TType, FSharpList`1<SynMemberDefn>, Range>> interfacesFromTypeDefn@1787(TcFileState cenv, bool isMutRec, TcGlobals g, TcEnv envForTycon, MutRecDefnsPhase2DataForTycon tyconMembersData);
    internal static FSharpFunc`2<Tuple`3<TType, IEnumerable`1<SynMemberDefn>, a>, FSharpFunc`2<SlotImplSet, FSharpList`1<TyconBindingDefn>>> interfaceMembersFromTypeDefn@1827(MutRecDefnsPhase2DataForTycon tyconMembersData);
    internal static FSharpList`1<TyconBindingDefn> tyconBindingsOfTypeDefn@1836(MutRecDefnsPhase2DataForTycon _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<MutRecShape`3<Tuple`2<FSharpOption`1<Entity>, FSharpList`1<Binding>>, FSharpList`1<Binding>, Tuple`2<MutRecDefnsPhase2DataForModule, TcEnv>>>, TcEnv> TcMutRecDefns_Phase2(TcFileState cenv, TcEnv envInitial, Range mBinds, Range scopem, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, TcEnv envMutRec, FSharpList`1<MutRecShape`3<MutRecDefnsPhase2DataForTycon, FSharpList`1<RecDefnBindingInfo>, Tuple`2<MutRecDefnsPhase2DataForModule, TcEnv>>> mutRecDefns, bool isMutRec);
    internal static Ident ComputeModuleName(FSharpList`1<Ident> longPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForDuplicateConcreteType(TcEnv env, string nm, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForDuplicateModule(TcEnv env, string nm, Range m);
    [CompilerGeneratedAttribute]
internal static Cancellable`1<TcEnv> TcSignatureElementNonMutRec$cont@4708(TcFileState cenv, ParentRef parent, FSharpSet`1<string> typeNames, Range endm, TcEnv env, TcGlobals g, FSharpList`1<SynAttribute> attribs, PreXmlDoc xml, FSharpOption`1<SynAccess> vis, FSharpList`1<SynModuleSigDecl> moduleDefs, Range m, FSharpList`1<Ident> longPath, Range im, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Cancellable`1<TcEnv> TcSignatureElementNonMutRec$cont@4734-1(TcFileState cenv, Range endm, TcEnv env, SynModuleSigDecl synSigDecl, TcGlobals g, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Cancellable`1<TcEnv> TcSignatureElementNonMutRec$cont@4760-2(TcFileState cenv, TcEnv env, SynModuleSigDecl synSigDecl, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<TcEnv> TcSignatureElementNonMutRec(TcFileState cenv, ParentRef parent, FSharpSet`1<string> typeNames, Range endm, TcEnv env, SynModuleSigDecl synSigDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<TcEnv> TcSignatureElements(TcFileState cenv, ParentRef parent, Range endm, TcEnv env, PreXmlDoc xml, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, FSharpList`1<SynModuleSigDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<TcEnv> TcSignatureElementsNonMutRec(TcFileState cenv, ParentRef parent, FSharpSet`1<string> typeNames, Range endm, TcEnv env, FSharpList`1<SynModuleSigDecl> defs);
    internal static FSharpList`1<MutRecShape`3<SynTypeDefnSig, a, b>> decls@4865(FSharpOption`1<Range> withKeyword, FSharpList`1<SynMemberSig> members, SynExceptionDefnRepr exnRepr, Range m, SynComponentInfo compInfo);
    internal static FSharpList`1<MutRecShape`3<a, SynValSig, b>> decls@4870-1(SynValSig vspec);
    internal static FSharpList`1<MutRecShape`3<a, b, c>> decls@4884-2(FSharpList`1<Ident> p, Range m, Ident id);
    internal static FSharpList`1<MutRecShape`3<SynTypeDefnSig, SynValSig, SynComponentInfo>> loop@4849-74(bool isNamespace, Range moduleRange, FSharpList`1<SynModuleSigDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<TcEnv> TcSignatureElementsMutRec(TcFileState cenv, ParentRef parent, FSharpSet`1<string> typeNames, Range m, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, TcEnv envInitial, FSharpList`1<SynModuleSigDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<Tuple`2<ModuleOrNamespaceType, TcEnv>> TcModuleOrNamespaceSignatureElementsNonMutRec(TcFileState cenv, ParentRef parent, TcEnv env, Ident id, ModuleOrNamespaceKind moduleKind, FSharpList`1<SynModuleSigDecl> defs, Range m, PreXmlDoc xml);
    internal static SynModuleDecl ElimSynModuleDeclExpr(SynModuleDecl bind);
    internal static void checkTycon@4926(Set`2<Entity, IComparer`1<Entity>> freeInEnv, Entity tycon);
    [CompilerGeneratedAttribute]
internal static void func2@1-6(Set`2<Entity, IComparer`1<Entity>> freeInEnv, FSharpOption`1<Entity> option);
    internal static void checkBinds@4934(Set`2<Val, IComparer`1<Val>> freeInEnv, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcMutRecDefnsEscapeCheck(FSharpList`1<MutRecShape`3<Tuple`2<FSharpOption`1<Entity>, FSharpList`1<Binding>>, FSharpList`1<Binding>, a>> binds, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckLetOrDoInNamespace(FSharpList`1<SynBinding> binds, Range m);
    [CompilerGeneratedAttribute]
internal static Cancellable`1<Tuple`3<Tuple`3<FSharpList`1<ModuleOrNamespaceContents>, FSharpList`1<FSharpFunc`2<Unit, Unit>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>, TcEnv, TcEnv>> TcModuleOrNamespaceElementNonMutRec$cont@5010(TcFileState cenv, ParentRef parent, Range scopem, TcEnv env, Range m, bool letrec, FSharpList`1<SynBinding> binds, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Cancellable`1<Tuple`3<Tuple`3<FSharpList`1<ModuleOrNamespaceContents>, FSharpList`1<FSharpFunc`2<Unit, Unit>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>, TcEnv, TcEnv>> TcModuleOrNamespaceElementNonMutRec$cont@5043-1(TcFileState cenv, ParentRef parent, FSharpSet`1<string> typeNames, Range scopem, TcEnv env, TcGlobals g, FSharpList`1<SynModuleDecl> moduleDefs, Range m, bool isContinuingModule, SynComponentInfo compInfo, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Cancellable`1<Tuple`3<Tuple`3<FSharpList`1<ModuleOrNamespaceContents>, FSharpList`1<FSharpFunc`2<Unit, Unit>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>, TcEnv, TcEnv>> TcModuleOrNamespaceElementNonMutRec$cont@5117-2(TcFileState cenv, ParentRef parent, TcEnv env, TcGlobals g, PreXmlDoc xml, FSharpOption`1<SynAccess> vis, Range m, FSharpList`1<Ident> longId, SynModuleOrNamespaceKind kind, bool isRec, FSharpList`1<SynModuleDecl> defs, FSharpList`1<SynAttributeList> attribs, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<Tuple`3<Tuple`3<FSharpList`1<ModuleOrNamespaceContents>, FSharpList`1<FSharpFunc`2<Unit, Unit>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>, TcEnv, TcEnv>> TcModuleOrNamespaceElementNonMutRec(TcFileState cenv, ParentRef parent, FSharpSet`1<string> typeNames, Range scopem, TcEnv env, SynModuleDecl synDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<Tuple`2<FSharpList`1<Tuple`3<FSharpList`1<ModuleOrNamespaceContents>, FSharpList`1<FSharpFunc`2<Unit, Unit>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>>, TcEnv>> TcModuleOrNamespaceElementsNonMutRec(TcFileState cenv, ParentRef parent, FSharpSet`1<string> typeNames, Range endm, FSharpList`1<Tuple`3<FSharpList`1<ModuleOrNamespaceContents>, FSharpList`1<FSharpFunc`2<Unit, Unit>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>> defsSoFar, TcEnv env, TcEnv envAtEnd, FSharpList`1<SynModuleDecl> moreDefs);
    internal static FSharpList`1<MutRecShape`3<a, b, c>> decls@5263-3(FSharpList`1<Ident> p, Range m, Ident id);
    internal static Tuple`2<FSharpList`1<MutRecShape`3<SynTypeDefn, FSharpList`1<SynBinding>, SynComponentInfo>>, Tuple`3<bool, bool, FSharpList`1<SynAttributeList>>> loop@5217-78(bool isNamespace, Range moduleRange, FSharpList`1<SynAttributeList> attrs, FSharpList`1<SynModuleDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<Tuple`3<Tuple`3<FSharpList`1<ModuleOrNamespaceContents>, FSharpList`1<FSharpFunc`2<Unit, Unit>>, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>>, TcEnv, TcEnv>> TcModuleOrNamespaceElementsMutRec(TcFileState cenv, ParentRef parent, FSharpSet`1<string> typeNames, Range m, TcEnv envInitial, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, FSharpList`1<SynModuleDecl> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceContents TcMutRecDefsFinish(TcFileState cenv, FSharpList`1<MutRecShape`3<Tuple`2<FSharpOption`1<Entity>, FSharpList`1<Binding>>, FSharpList`1<Binding>, Tuple`2<MutRecDefnsPhase2DataForModule, TcEnv>>> defs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<Tuple`3<ModuleOrNamespaceContents, FSharpList`1<Tuple`2<AttributeTargets, Attrib>>, TcEnv>> TcModuleOrNamespaceElements(TcFileState cenv, ParentRef parent, Range endm, TcEnv env, PreXmlDoc xml, FSharpOption`1<Tuple`2<FSharpOption`1<Entity>, FSharpRef`1<ModuleOrNamespaceType>>> mutRecNSInfo, FSharpList`1<OpenDeclaration> openDecls0, FSharpList`1<SynModuleDecl> synModuleDecls);
    internal static Tuple`2<FSharpList`1<a>, TcEnv> warn@5353-2(CcuThunk ccu, Range scopem, TcEnv env, string p, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<OpenDeclaration>, TcEnv> ApplyAssemblyLevelAutoOpenAttributeToTcEnv(TcGlobals g, ImportMap amap, CcuThunk ccu, Range scopem, TcEnv env, string p, bool root);
    internal static Tuple`2<FSharpList`1<OpenDeclaration>, TcEnv> AddCcuToTcEnv(TcGlobals g, ImportMap amap, Range scopem, TcEnv env, string assemblyName, CcuThunk ccu, FSharpList`1<string> autoOpens, FSharpList`1<string> internalsVisibleToAttributes);
    internal static TcEnv emptyTcEnv(TcGlobals g);
    internal static Tuple`2<FSharpList`1<OpenDeclaration>, TcEnv> CreateInitialTcEnv(TcGlobals g, ImportMap amap, Range scopem, string assemblyName, FSharpList`1<Tuple`3<CcuThunk, FSharpList`1<string>, FSharpList`1<string>>> ccus);
    internal static TopAttribs get_EmptyTopAttrs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TopAttribs CombineTopAttrs(TopAttribs topAttrs1, TopAttribs topAttrs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IterTyconsOfModuleOrNamespaceType(FSharpFunc`2<Entity, Unit> f, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ApplyDefaults(TcFileState cenv, TcGlobals g, DisplayEnv denvAtEnd, Range m, ModuleOrNamespaceContents moduleContents, FSharpList`1<Attrib> extraAttribs);
    internal static void check@5464-10(DisplayEnv denvAtEnd, InfoReader infoReader, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValueRestriction(DisplayEnv denvAtEnd, InfoReader infoReader, FSharpOption`1<a> rootSigOpt, ModuleOrNamespaceType implFileTypePriorToSig, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SolveInternalUnknowns(TcGlobals g, TcFileState cenv, DisplayEnv denvAtEnd, ModuleOrNamespaceContents moduleContents, FSharpList`1<Attrib> extraAttribs);
    [CompilerGeneratedAttribute]
internal static Tuple`2<ModuleOrNamespaceType, a> CheckModuleSignature$cont@5500(TcGlobals g, TcFileState cenv, Range m, DisplayEnv denvAtEnd, FSharpOption`1<ModuleOrNamespaceType> rootSigOpt, ModuleOrNamespaceType implFileTypePriorToSig, Entity implFileSpecPriorToSig, a moduleContents, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceType, a> CheckModuleSignature(TcGlobals g, TcFileState cenv, Range m, DisplayEnv denvAtEnd, FSharpOption`1<ModuleOrNamespaceType> rootSigOpt, ModuleOrNamespaceType implFileTypePriorToSig, Entity implFileSpecPriorToSig, a moduleContents);
    internal static Tuple`2<TcEnv, FSharpRef`1<ModuleOrNamespaceType>> MakeInitialEnv(TcEnv env);
    [CompilerGeneratedAttribute]
internal static void f@614-13(TcFileState cenv, TcEnv envAtEnd, ModuleOrNamespaceType implFileTypePriorToSig, DisplayEnv denvAtEnd, Range m, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static Tuple`2<ModuleOrNamespaceType, ModuleOrNamespaceContents> f@614-14(FSharpOption`1<ModuleOrNamespaceType> rootSigOpt, TcGlobals g, TcFileState cenv, ModuleOrNamespaceContents moduleContents, ModuleOrNamespaceType implFileTypePriorToSig, DisplayEnv denvAtEnd, Range m, Entity implFileSpecPriorToSig, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void f@614-15(TcFileState cenv, Range m, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static Tuple`2<bool, FSharpMap`2<long, AnonRecdTypeInfo>> f@614-16(bool isInternalTestSpanStackReferring, TcGlobals g, TcEnv env, FSharpFunc`2<Unit, bool> checkForErrors, Tuple`2<bool, bool> isLastCompiland, TcFileState cenv, TcEnv envAtEnd, Range m, FSharpList`1<Attrib> extraAttribs, ModuleOrNamespaceType implFileTy, ModuleOrNamespaceContents implFileContents, Unit unitVar0);
    internal static bool isValid@5657(string version, Unit unitVar0);
    internal static Cancellable`1<Tuple`4<TopAttribs, CheckedImplFile, TcEnv, bool>> CheckOneImplFile(TcGlobals g, ImportMap amap, CcuThunk thisCcu, FSharpList`1<OpenDeclaration> openDecls0, FSharpFunc`2<Unit, bool> checkForErrors, FSharpOption`1<FSharpList`1<string>> conditionalDefines, TcResultsSink tcSink, bool isInternalTestSpanStackReferring, TcEnv env, FSharpOption`1<ModuleOrNamespaceType> rootSigOpt, ParsedImplFileInput synImplFile, FSharpDiagnosticOptions diagnosticOptions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<Tuple`3<TcEnv, ModuleOrNamespaceType, bool>> CheckOneSigFile(TcGlobals g, ImportMap amap, CcuThunk thisCcu, FSharpFunc`2<Unit, bool> checkForErrors, FSharpOption`1<FSharpList`1<string>> conditionalDefines, TcResultsSink tcSink, bool isInternalTestSpanStackReferring, FSharpDiagnosticOptions diagnosticOptions, TcEnv tcEnv, ParsedSigFileInput sigFile);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckExpressions : object {
    [CompilationMappingAttribute("9")]
internal static UnscopedTyparEnv emptyUnscopedTyparEnv { get; }
    [CompilationMappingAttribute("9")]
internal static ExplicitTyparInfo permitInferTypars { get; }
    [CompilationMappingAttribute("9")]
internal static ExplicitTyparInfo dontInferTypars { get; }
    [CompilationMappingAttribute("9")]
internal static ArgAndRetAttribs noArgOrRetAttribs { get; }
    [CompilationMappingAttribute("9")]
internal static ContainerInfo ExprContainerInfo { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AccessorDomain ComputeAccessRights(CompilationPath eAccessPath, FSharpList`1<CompilationPath> eInternalsVisibleCompPaths, FSharpOption`1<EntityRef> eFamilyType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv EnterFamilyRegion(EntityRef tcref, TcEnv env);
    internal static TcEnv ExitFamilyRegion(TcEnv env);
    internal static bool AreWithinCtorShape(TcEnv env);
    internal static int GetCtorShapeCounter(TcEnv env);
    internal static RecordConstructionInfo GetRecdInfo(TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AdjustCtorShapeCounter(FSharpFunc`2<int, int> f, TcEnv env);
    internal static TcEnv ExitCtorShapeRegion(TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<UngeneralizableItem> addFreeItemOfTy(TType ty, FSharpList`1<UngeneralizableItem> eUngeneralizableItems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<UngeneralizableItem> addFreeItemOfModuleTy(ModuleOrNamespaceType mtyp, FSharpList`1<UngeneralizableItem> eUngeneralizableItems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddValMapToNameEnv(TcGlobals g, FSharpMap`2<string, Val> vs, NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddValListToNameEnv(TcGlobals g, FSharpList`1<Val> vs, NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalValPrimitive(TcGlobals g, Val v, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalValMap(TcGlobals g, TcResultsSink tcSink, Range scopem, FSharpMap`2<string, Val> vals, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalVals(TcGlobals g, TcResultsSink tcSink, Range scopem, FSharpList`1<Val> vals, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddLocalVal(TcGlobals g, TcResultsSink tcSink, Range scopem, Val v, TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv AddDeclaredTypars(CheckForDuplicateTyparFlag check, FSharpList`1<Typar> typars, TcEnv env);
    internal static UnscopedTyparEnv get_emptyUnscopedTyparEnv();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnscopedTyparEnv AddUnscopedTypar(string name, Typar typar, UnscopedTyparEnv _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnscopedTyparEnv HideUnscopedTypars(FSharpList`1<Typar> typars, UnscopedTyparEnv _arg1);
    internal static ExplicitTyparInfo get_permitInferTypars();
    internal static ExplicitTyparInfo get_dontInferTypars();
    internal static ArgAndRetAttribs get_noArgOrRetAttribs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UnifyTypes(TcFileState cenv, TcEnv env, Range m, TType expectedTy, TType actualTy);
    [CompilerGeneratedAttribute]
internal static void UnifyOverallType$cont@453(TcFileState cenv, TcEnv env, Range m, bool isMethodArg, TType actualTy, TType reqdTy, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UnifyOverallType(TcFileState cenv, TcEnv env, Range m, OverallTy overallTy, TType actualTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UnifyOverallTypeAndRecover(TcFileState cenv, TcEnv env, Range m, OverallTy overallTy, TType actualTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv MakeInnerEnvWithAcc(bool addOpenToNameEnv, TcEnv env, Ident nm, FSharpRef`1<ModuleOrNamespaceType> moduleTyAcc, ModuleOrNamespaceKind moduleKind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TcEnv, FSharpRef`1<ModuleOrNamespaceType>> MakeInnerEnv(bool addOpenToNameEnv, TcEnv env, Ident nm, ModuleOrNamespaceKind moduleKind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv MakeInnerEnvForTyconRef(TcEnv env, EntityRef tcref, bool isExtrinsicExtension);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv MakeInnerEnvForMember(TcEnv env, Val v);
    internal static ModuleOrNamespaceType GetCurrAccumulatedModuleOrNamespaceType(TcEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv LocateEnv(bool isModule, CcuThunk ccu, TcEnv env, FSharpList`1<Ident> enclosingNamespacePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TcEnv ShrinkContext(TcEnv env, Range oldRange, Range newRange);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TupInfo, FSharpList`1<TType>> UnifyTupleTypeAndInferCharacteristics(ContextInfo contextInfo, TcFileState cenv, DisplayEnv denv, Range m, TType knownTy, bool isExplicitStruct, FSharpList`1<T> ps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<AnonRecdTypeInfo, FSharpList`1<TType>> UnifyAnonRecdTypeAndInferCharacteristics(ContextInfo contextInfo, TcFileState cenv, DisplayEnv denv, Range m, TType ty, bool isExplicitStruct, Ident[] unsortedNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Tuple`2<TType, TType>> UnifyFunctionTypeUndoIfFailed(TcFileState cenv, DisplayEnv denv, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, TType> UnifyFunctionType(FSharpOption`1<Range> extraInfo, TcFileState cenv, DisplayEnv denv, Range mFunExpr, TType ty);
    [CompilerGeneratedAttribute]
internal static Exception checkExpr$cont@660(DisplayEnv denv, TType ty, Range m, FSharpList`1<Expr> exprs, Unit unitVar);
    internal static Exception checkExpr@657-2(DisplayEnv denv, TType ty, Range m, Expr expr);
    internal static Exception extractNext@687(DisplayEnv denv, TType ty, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception ReportImplicitlyIgnoredBoolExpression(DisplayEnv denv, Range m, TType ty, Expr expr);
    internal static void reportImplicitlyDiscardError@705(Range m, TType ty, Expr expr, TcGlobals g, DisplayEnv denv, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static bool UnifyUnitType$cont@700(TcFileState cenv, TcEnv env, Range m, TType ty, Expr expr, TcGlobals g, DisplayEnv denv, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool UnifyUnitType(TcFileState cenv, TcEnv env, Range m, TType ty, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TryUnifyUnitTypeWithoutWarning(TcFileState cenv, TcEnv env, Range m, TType ty);
    internal static void callSink@743-2(TcResultsSink tcSink, TcEnv env, Range mObjTy, Item origItem, Item item, FSharpList`1<Tuple`2<Typar, TType>> minst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AfterResolution ForNewConstructors(TcResultsSink tcSink, TcEnv env, Range mObjTy, string methodName, FSharpList`1<MethInfo> meths);
    internal static Rational TcSynRationalConst(SynRationalConst c);
    internal static Measure tcMeasure@765(TcFileState cenv, Range m, TcEnv env, SynMeasure ms);
    internal static void unifyMeasureArg@791(TcFileState cenv, TType overallTy, Range m, TcEnv env, SynConst synConst, bool iszero, EntityRef tcr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Const TcConst(TcFileState cenv, TType overallTy, Range m, TcEnv env, SynConst synConst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Const TcFieldInit(Range _m, ILFieldInit lit);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynValInfo AdjustValSynInfoInSignature(TcGlobals g, TType ty, SynValInfo sigMD);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArgReprInfo TranslateTopArgSynInfo(TcFileState cenv, bool isArg, Range m, FSharpFunc`2<FSharpList`1<SynAttribute>, FSharpList`1<Attrib>> tcAttributes, SynArgInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PrelimValReprInfo TranslateSynValInfo(TcFileState cenv, Range m, FSharpFunc`2<AttributeTargets, FSharpFunc`2<FSharpList`1<SynAttribute>, FSharpList`1<Attrib>>> tcAttributes, SynValInfo synValInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo TranslatePartialValReprInfo(FSharpList`1<Typar> tps, PrelimValReprInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ComputeLogicalName(Ident id, SynMemberFlags memberFlags);
    [CompilerGeneratedAttribute]
internal static void MakeMemberDataAndMangledNameForMemberVal$cont@1038(SynValInfo valSynData, Ident id, Unit unitVar);
    internal static PrelimMemberInfo MakeMemberDataAndMangledNameForMemberVal(TcGlobals g, EntityRef tcref, bool isExtrinsic, FSharpList`1<Attrib> attrs, FSharpList`1<TType> implSlotTys, SynMemberFlags memberFlags, SynValInfo valSynData, Ident id, bool isCompGen);
    internal static GeneralizedType NonGenericTypeScheme(TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UpdateAccModuleOrNamespaceType(TcFileState cenv, TcEnv env, FSharpFunc`2<bool, FSharpFunc`2<ModuleOrNamespaceType, ModuleOrNamespaceType>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishModuleDefn(TcFileState cenv, TcEnv env, Entity mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishTypeDefn(TcFileState cenv, TcEnv env, Entity mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishValueDefnPrim(TcFileState cenv, TcEnv env, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishValueDefn(TcFileState cenv, TcEnv env, DeclKind declKind, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> CombineVisibilityAttribs(FSharpOption`1<a> vis1, FSharpOption`1<a> vis2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Accessibility, FSharpOption`1<CompilationPath>> ComputeAccessAndCompPath(TcEnv env, FSharpOption`1<DeclKind> declKindOpt, Range m, FSharpOption`1<SynAccess> vis, FSharpOption`1<Accessibility> overrideVis, ParentRef actualParent);
    [CompilerGeneratedAttribute]
internal static void CheckForAbnormalOperatorNames$cont@1170(Range idRange, string coreDisplayName, FSharpOption`1<ValMemberInfo> memberInfoOpt, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForAbnormalOperatorNames(TcFileState cenv, Range idRange, string coreDisplayName, FSharpOption`1<ValMemberInfo> memberInfoOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInitProperties(TcGlobals g, MethInfo minfo, string methodName, Range mItem);
    [CompilerGeneratedAttribute]
internal static bool contains@1-9(string value, a e, FSharpList`1<string> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckRequiredProperties(TcGlobals g, TcEnv env, TcFileState cenv, MethInfo minfo, FSharpList`1<AssignedItemSetter`1<a>> finalAssignedItemSetters, Range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasMethodImplNoInliningAttribute(TcGlobals g, FSharpList`1<Attrib> attrs);
    internal static bool shouldNotifySink@1355(Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val MakeAndPublishVal(TcFileState cenv, TcEnv env, ParentRef altActualParent, bool inSig, DeclKind declKind, ValRecursiveScopeInfo valRecInfo, ValScheme vscheme, FSharpList`1<Attrib> attrs, XmlDoc xmlDoc, FSharpOption`1<Const> konst, bool isGeneratedEventVal);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<a, Tuple`2<Val, GeneralizedType>> MakeAndPublishVals(TcFileState cenv, TcEnv env, ParentRef altActualParent, bool inSig, DeclKind declKind, ValRecursiveScopeInfo valRecInfo, FSharpMap`2<a, ValScheme> valSchemes, FSharpList`1<Attrib> attrs, XmlDoc xmlDoc, FSharpOption`1<Const> literalValue);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Val> MakeAndPublishBaseVal(TcFileState cenv, TcEnv env, FSharpOption`1<Ident> baseIdOpt, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Val> MakeAndPublishSafeThisVal(TcFileState cenv, TcEnv env, FSharpOption`1<Ident> thisIdOpt, TType thisTy);
    [CompilerGeneratedAttribute]
internal static void AdjustAndForgetUsesOfRecValue$cont@1420(TcFileState cenv, ValRef vrefTgt, FSharpList`1<Typar> generalizedTypars, TType valTy, Val lvrefTgt, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AdjustAndForgetUsesOfRecValue(TcFileState cenv, ValRef vrefTgt, ValScheme valScheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AdjustRecType(Val v, ValScheme vscheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr RecordUseOfRecValue(TcFileState cenv, ValRecursiveScopeInfo valRecInfo, ValRef vrefTgt, Expr vExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecursiveUseFixupPoints GetAllUsesOfRecValue(TcFileState cenv, Val vrefTgt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> ChooseCanonicalDeclaredTyparsAfterInference(TcGlobals g, DisplayEnv denv, FSharpList`1<Typar> declaredTypars, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValScheme ChooseCanonicalValSchemeAfterInference(TcGlobals g, DisplayEnv denv, ValScheme vscheme, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> PlaceTyparsInDeclarationOrder(FSharpList`1<Typar> declaredTypars, FSharpList`1<Typar> generalizedTypars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetTyparRigid(DisplayEnv denv, Range m, Typar tp);
    internal static FSharpList`1<Typar> computeRelevantTypars@1521(FSharpList`1<Typar> generalizedTyparsForThisBinding, TcGlobals g, TType ty, FSharpList`1<Typar> allDeclaredTypars, bool thruFlag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PrelimVal2 GeneralizeVal(TcFileState cenv, DisplayEnv denv, FSharpList`1<Typar> enclosingDeclaredTypars, FSharpList`1<Typar> generalizedTyparsForThisBinding, PrelimVal1 prelimVal);
    internal static FSharpMap`2<string, PrelimVal2> DontGeneralizeVals(FSharpMap`2<string, PrelimVal1> types);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo InferGenericArityFromTyScheme(GeneralizedType _arg1, PrelimValReprInfo prelimValReprInfo);
    internal static bool ComputeIsTyFunc(Ident id, bool hasDeclaredTypars, FSharpOption`1<ValReprInfo> arityInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<ValReprInfo>, FSharpOption`1<ValReprInfo>> UseSyntacticValReprInfo(DeclKind declKind, GeneralizedType typeScheme, PrelimValReprInfo prelimValReprInfo);
    internal static FSharpList`1<a> choose@1623-5(FSharpList`1<a> ai1, FSharpList`1<a> ai2);
    internal static FSharpList`1<FSharpList`1<a>> loop@1631-66(FSharpList`1<FSharpList`1<a>> ais1, FSharpList`1<FSharpList`1<a>> ais2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<PrelimValReprInfo> CombineSyntacticAndInferredValReprInfo(TcGlobals g, Expr rhsExpr, PrelimVal2 prelimScheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValScheme BuildValScheme(DeclKind declKind, FSharpOption`1<PrelimValReprInfo> partialValReprInfoOpt, PrelimVal2 prelimScheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpMap`2<string, Tuple`2<Val, GeneralizedType>>, FSharpMap`2<string, Val>> MakeAndPublishSimpleVals(TcFileState cenv, TcEnv env, FSharpMap`2<string, PrelimVal1> names);
    internal static void notifyNameResolution@1688-1(List`1<Tuple`8<Position, Item, Item, FSharpList`1<Tuple`2<Typar, TType>>, ItemOccurence, NameResolutionEnv, AccessorDomain, Tuple`2<Range, bool>>> nameResolutions, Position pos, Item item, Item itemGroup, FSharpList`1<Tuple`2<Typar, TType>> itemTyparInst, ItemOccurence occurence, NameResolutionEnv nenv, AccessorDomain ad, Range m, bool replacing);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpMap`2<string, Tuple`2<Val, GeneralizedType>>, FSharpMap`2<string, Val>> MakeAndPublishSimpleValsForMergedScope$cont@1686(TcFileState cenv, TcEnv env, FSharpMap`2<string, PrelimVal1> names, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TcEnv, FSharpMap`2<string, Tuple`2<Val, GeneralizedType>>, FSharpMap`2<string, Val>> MakeAndPublishSimpleValsForMergedScope(TcFileState cenv, TcEnv env, Range m, FSharpMap`2<string, PrelimVal1> names);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<TType, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, TType> FreshenTyconRef(TcGlobals g, Range m, TyparRigidity rigid, EntityRef tcref, FSharpList`1<Typar> declaredTyconTypars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<TType>, TType> FreshenPossibleForallTy(TcGlobals g, Range m, TyparRigidity rigid, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>, TType> FreshenTyconRef2(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<bool, FSharpList`1<Typar>, FSharpList`1<FSharpList`1<TType>>, TType> FreshenAbstractSlot(TcGlobals g, ImportMap amap, Range m, SynValTyparDecls synTyparDecls, MethInfo absMethInfo);
    internal static void CheckRecdExprDuplicateFields(FSharpList`1<Ident> elems);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`4<FSharpList`1<TType>, EntityRef, FSharpMap`2<string, T>, FSharpList`1<Tuple`2<string, T>>>> BuildFieldMap$cont@1836(TcFileState cenv, TcEnv env, bool isPartial, FSharpList`1<Tuple`2<Tuple`2<FSharpList`1<Ident>, Ident>, T>> flds, Range m, TcGlobals g, AccessorDomain ad, FSharpList`1<Tuple`3<Tuple`2<FSharpList`1<Ident>, Ident>, FSharpList`1<FieldResolution>, T>> fldResolutions, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`4<FSharpList`1<TType>, EntityRef, FSharpMap`2<string, T>, FSharpList`1<Tuple`2<string, T>>>> BuildFieldMap(TcFileState cenv, TcEnv env, bool isPartial, TType ty, FSharpList`1<Tuple`2<Tuple`2<FSharpList`1<Ident>, Ident>, T>> flds, Range m);
    [CompilerGeneratedAttribute]
internal static Tuple`3<a, FSharpList`1<TType>, FSharpList`1<Ident>> ApplyUnionCaseOrExn$cont@1906(FSharpFunc`2<Tuple`2<UnionCaseRef, FSharpList`1<TType>>, a> makerForUnionCase, Range m, TcFileState cenv, TcEnv env, TType overallTy, Item item, TcGlobals g, AccessorDomain ad, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<a, FSharpList`1<TType>, FSharpList`1<Ident>> ApplyUnionCaseOrExn(FSharpFunc`2<Tuple`2<UnionCaseRef, FSharpList`1<TType>>, a> makerForUnionCase, FSharpFunc`2<EntityRef, a> makerForExnTag, Range m, TcFileState cenv, TcEnv env, TType overallTy, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpFunc`2<Range, FSharpFunc`2<FSharpList`1<Expr>, Expr>>, FSharpList`1<TType>, FSharpList`1<Ident>> ApplyUnionCaseOrExnTypes(Range m, TcFileState cenv, TcEnv env, TType overallTy, Item c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UnionCaseOrExnCheck(TcEnv env, int numArgTys, int numArgs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<a, TType> TcUnionCaseOrExnField(TcFileState cenv, TcEnv env, TType ty1, Range m, FSharpList`1<Ident> longId, int fieldNum, FSharpFunc`2<Tuple`2<UnionCaseRef, FSharpList`1<TType>>, a> funcs_0, FSharpFunc`2<EntityRef, a> funcs_1);
    internal static bool hasNoCompilerInliningAttribute@2239(TcGlobals g, FSharpList`1<Attrib> attrs, Unit unitVar0);
    internal static bool isCtorOrAbstractSlot@2241(FSharpOption`1<SynMemberFlags> memFlagsOption, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValInline ComputeInlineFlag(FSharpOption`1<SynMemberFlags> memFlagsOption, bool isInline, bool isMutable, TcGlobals g, FSharpList`1<Attrib> attrs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NormalizedBindingRhs PushOnePatternToRhs(TcFileState cenv, bool isMember, SynPat synPat, NormalizedBindingRhs _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<TType, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, TType, TType> FreshenObjectArgType(TcFileState cenv, Range m, TyparRigidity rigid, EntityRef tcref, bool isExtrinsic, FSharpList`1<Typar> declaredTyconTypars);
    [CompilerGeneratedAttribute]
internal static void f@284-8(TcFileState cenv, TcEnv env, Val v, StringBuilder buf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcValEarlyGeneralizationConsistencyCheck(TcFileState cenv, TcEnv env, Val v, ValRecursiveScopeInfo valRecInfo, FSharpList`1<TType> tinst, TType vTy, TType tau, Range m);
    internal static void checkInst@2704(Range m, Val v, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<Typar>, Expr, bool, TType, FSharpList`1<TType>, UnscopedTyparEnv> TcVal(bool checkAttributes, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, ValRef vref, FSharpOption`1<Tuple`2<ValUseFlag, FSharpFunc`2<UnscopedTyparEnv, FSharpFunc`2<FSharpList`1<TyparKind>, Tuple`2<FSharpList`1<TType>, UnscopedTyparEnv>>>>> instantiationInfoOpt, FSharpOption`1<AfterResolution> optAfterResolution, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> LightweightTcValForUsingInBuildMethodCall(TcGlobals g, ValRef vref, ValUseFlag vrefFlags, FSharpList`1<TType> vrefTypeInst, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ApplicableExpr MakeApplicableExprForTraitCall(TcFileState cenv, Expr expr, FSharpList`1<Val> traitCallInfo_0, Expr traitCallInfo_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ApplicableExpr MakeApplicableExprWithFlex(TcFileState cenv, TcEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcRuntimeTypeTest(bool isCast, bool isOperator, TcFileState cenv, DisplayEnv denv, Range m, TType tgtTy, TType srcTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcStaticUpcast(TcFileState cenv, DisplayEnv denv, Range m, TType tgtTy, TType srcTy);
    [CompilerGeneratedAttribute]
internal static bool contains@1-10(string d, a e, FSharpList`1<string> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildPossiblyConditionalMethodCall(TcFileState cenv, TcEnv env, Mutates isMutable, Range m, bool isProp, MethInfo minfo, ValUseFlag valUseFlags, FSharpList`1<TType> minst, FSharpList`1<Expr> objArgs, FSharpList`1<Expr> args, FSharpOption`1<TType> staticTyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> TryFindIntrinsicOrExtensionMethInfo(ResultCollectionSettings collectionSettings, TcFileState cenv, TcEnv env, Range m, AccessorDomain ad, string nm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<PropInfo> TryFindFSharpSignatureInstanceGetterProperty(TcFileState cenv, TcEnv env, Range m, string nm, TType ty, FSharpList`1<TType> sigTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildDisposableCleanup(TcFileState cenv, TcEnv env, Range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildOffsetToStringData(TcFileState cenv, TcEnv env, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildILFieldGet(TcGlobals g, ImportMap amap, Range m, Expr objExpr, ILFieldInfo finfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckFieldLiteralArg(ILFieldInfo finfo, Expr argExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildILFieldSet(TcGlobals g, Range m, Expr objExpr, ILFieldInfo finfo, Expr argExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildILStaticFieldSet(Range m, ILFieldInfo finfo, Expr argExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildRecdFieldSet(TcGlobals g, Range m, Expr objExpr, RecdFieldInfo rfinfo, Expr argExpr);
    internal static FSharpOption`1<Tuple`3<Ident, SynExpr, SynExpr>> |BinOpExpr|_|(SynExpr expr);
    internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |SimpleEqualsExpr|_|(SynExpr expr);
    internal static FSharpOption`1<Tuple`3<bool, Ident, SynExpr>> TryGetNamedArg(SynExpr expr);
    internal static Tuple`2<FSharpList`1<SynExpr>, FSharpList`1<Tuple`3<bool, Ident, SynExpr>>> GetMethodArgs(SynExpr arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CompilePatternForMatch(TcFileState cenv, TcEnv env, Range mExpr, Range mMatch, bool warnOnUnused, ActionOnFailure actionOnFailure, Val inputVal, FSharpList`1<Typar> generalizedTypars, FSharpOption`1<Expr> inputExprOpt, FSharpList`1<MatchClause> clauses, TType inputTy, TType resultTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> CompilePatternForMatchClauses(TcFileState cenv, TcEnv env, Range mExpr, Range mMatch, bool warnOnUnused, ActionOnFailure actionOnFailure, FSharpOption`1<Expr> inputExprOpt, TType inputTy, TType resultTy, FSharpList`1<MatchClause> tclauses);
    internal static ResultOrException`1<a> err@3198-4(TcEnv env, Range m, bool k, TType ty);
    internal static ResultOrException`1<MethInfo> findMethInfo@3203-3(TcFileState cenv, TcEnv env, Range m, AccessorDomain ad, bool k, Range m@3203, string nm, TType ty);
    internal static bool hasArgs@3209(TcFileState cenv, Range m, MethInfo minfo, FSharpList`1<TType> minst);
    internal static bool allEquivReturnTypes@3252(TcFileState cenv, Range m, TcGlobals g, MethInfo minfo, FSharpList`1<MethInfo> others);
    [CompilerGeneratedAttribute]
internal static TType enumElemTy$cont@3252(TcFileState cenv, TcEnv env, Range m, AccessorDomain ad, TcGlobals g, TType tyToSearchForGetEnumeratorAndItem, TType enumElemTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ResultOrException`1<Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>>> tryType$cont@3238-1(TcFileState cenv, TcEnv env, bool localAlloc, Range m, AccessorDomain ad, TcGlobals g, TType tyToSearchForGetEnumeratorAndItem, Expr exprToSearchForGetEnumeratorAndItem, MethInfo getEnumeratorMethInfo, FSharpList`1<TType> getEnumeratorMethInst, TType getEnumeratorRetTy, MethInfo moveNextMethInfo, FSharpList`1<TType> moveNextMethInst, MethInfo getCurrentMethInfo, FSharpList`1<TType> getCurrentMethInst, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ResultOrException`1<Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>>> tryType$cont@3219(TcFileState cenv, TcEnv env, bool localAlloc, Range m, AccessorDomain ad, TcGlobals g, TType tyToSearchForGetEnumeratorAndItem, Expr exprToSearchForGetEnumeratorAndItem, ResultOrException`1<MethInfo> matchValue, Unit unitVar);
    internal static ResultOrException`1<Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>>> tryType@3214(TcFileState cenv, TcEnv env, bool localAlloc, Range m, AccessorDomain ad, TcGlobals g, Expr exprToSearchForGetEnumeratorAndItem, TType tyToSearchForGetEnumeratorAndItem);
    internal static FSharpOption`1<Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>>> probe@3324(TcFileState cenv, TcEnv env, bool localAlloc, Range m, TType exprTy, Expr expr, AccessorDomain ad, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<Val, Expr, TType, TType, Expr, TType, Expr, Tuple`2<TType, Expr>> AnalyzeArbitraryExprAsEnumerable(TcFileState cenv, TcEnv env, bool localAlloc, Range m, TType exprTy, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> ConvertArbitraryExprToEnumerable(TcFileState cenv, TType ty, TcEnv env, Expr expr);
    internal static Expr stripChooseAndExpr@3407(Expr e);
    internal static InitializationGraphAnalysisState strict@3414(InitializationGraphAnalysisState _arg1);
    internal static InitializationGraphAnalysisState lzy@3418(InitializationGraphAnalysisState _arg2);
    internal static InitializationGraphAnalysisState fixable@3421(InitializationGraphAnalysisState _arg3);
    [CompilerGeneratedAttribute]
internal static void func2@1-2(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, FSharpList`1<ObjExprMethod> list);
    [CompilerGeneratedAttribute]
internal static void func2@1-3(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, InitializationGraphAnalysisState st, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, FSharpList`1<ObjExprMethod> list);
    internal static void CheckExpr@3427-3(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, InitializationGraphAnalysisState st, Expr e);
    internal static void CheckBinding@3486-5(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, InitializationGraphAnalysisState st, Binding _arg4);
    internal static void CheckDecisionTree@3488(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, InitializationGraphAnalysisState st, DecisionTree dt);
    internal static FSharpFunc`2<DecisionTreeTarget, Unit> CheckDecisionTreeTarget@3494(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, InitializationGraphAnalysisState st);
    internal static void CheckExprOp@3496(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, InitializationGraphAnalysisState st, TOp op, Range m);
    internal static void CheckValRef@3501(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, InitializationGraphAnalysisState st, ValRef v, Range m);
    internal static void checkDelayed@3522(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, ValRef boundv, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, InitializationGraphAnalysisState st, Expr b);
    internal static void check@3413-6(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, ValRef boundv, Expr expr);
    internal static void checkBind@3533(TcGlobals g, DisplayEnv denv, ValHash`1<Val> recursiveVals, ValHash`1<int> availIfInOrder, FSharpRef`1<bool> outOfOrder, FSharpRef`1<bool> runtimeChecks, FSharpRef`1<bool> directRecursiveData, FSharpRef`1<bool> reportedEager, FSharpRef`1<FSharpList`1<Tuple`2<ValRef, ValRef>>> definiteDependencies, PreInitializationGraphEliminationBinding pgrbind);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Binding>> morphBinding$cont@3557(TcGlobals g, bool mustHaveValReprInfo, FSharpList`1<Tuple`2<FSharpRef`1<Expr>, Range>> fixupPoints, Val v, DebugPointAtBinding seqPtOpt, Expr e, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Result> EliminateInitializationGraphs(TcGlobals g, bool mustHaveValReprInfo, DisplayEnv denv, FSharpList`1<Binding> bindings, FSharpFunc`2<FSharpFunc`2<FSharpList`1<PreInitializationGraphEliminationBinding>, Unit>, FSharpFunc`2<FSharpList`1<Binding>, Unit>> iterBindings, FSharpFunc`2<FSharpList`1<Binding>, Result> buildLets, FSharpFunc`2<FSharpFunc`2<FSharpList`1<PreInitializationGraphEliminationBinding>, FSharpList`1<Binding>>, FSharpFunc`2<FSharpList`1<Binding>, FSharpList`1<Result>>> mapBindings, Range bindsm);
    internal static Expr error@3600-2(Expr expr);
    internal static Expr rewriteConstruction@3606(TcGlobals g, TcEnv env, Range m, Expr recdExpr);
    internal static Expr checkAndRewrite@3630(TcGlobals g, TcEnv env, Range m, Expr expr);
    internal static Expr checkAndRewriteCtorUsage@3669(TcGlobals g, TcEnv env, Range m, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CheckAndRewriteObjectCtor(TcGlobals g, TcEnv env, Expr ctorLambdaExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ApplicableExpr, TType> buildApp(TcFileState cenv, ApplicableExpr expr, TType resultTy, Expr arg, Range m);
    internal static DelayedItem MakeDelayedSet(SynExpr e, Range m);
    internal static ContainerInfo get_ExprContainerInfo();
    internal static bool CanInferExtraGeneralizedTyparsForRecBinding(PreGeneralizationRecursiveBinding pgrbind);
    internal static FSharpOption`1<Val> firstArg@3942(Expr e);
    internal static FSharpOption`1<Val> GetInstanceMemberThisVariable(Val vspec, Expr expr);
    [CompilerGeneratedAttribute]
internal static UnscopedTyparEnv TcTyparConstraint$cont@4010(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, TcEnv env, UnscopedTyparEnv tpenv, SynTypeConstraint c, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnscopedTyparEnv TcTyparConstraint(int ridx, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, SynTypeConstraint c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnscopedTyparEnv TcConstraintWhereTyparIsEnum(TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, UnscopedTyparEnv tpenv, SynTypar tp, FSharpList`1<SynType> synUnderlingTys, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnscopedTyparEnv TcConstraintWhereTyparIsDelegate(TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, UnscopedTyparEnv tpenv, SynTypar tp, FSharpList`1<SynType> synTys, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnscopedTyparEnv TcConstraintWhereTyparSupportsMember(TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, UnscopedTyparEnv tpenv, FSharpList`1<SynType> synSupportTys, SynMemberSig synMemberSig, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnscopedTyparEnv TcSimpleTyparConstraint(TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, UnscopedTyparEnv tpenv, SynTypar tp, Range m, FSharpFunc`2<DisplayEnv, FSharpFunc`2<ConstraintSolverState, FSharpFunc`2<Range, FSharpFunc`2<OptionalTrace, FSharpFunc`2<TType, Unit>>>>> constraintAdder);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TraitConstraintInfo, UnscopedTyparEnv> TcPseudoMemberSpec$cont@4087(TcFileState cenv, TcEnv env, TcGlobals g, FSharpList`1<TType> tys, SynMemberFlags memberFlags, Range m, UnscopedTyparEnv tpenv, PrelimValReprInfo prelimValReprInfo, TType memberConstraintTy, Ident id, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TraitConstraintInfo, UnscopedTyparEnv> TcPseudoMemberSpec(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, TcEnv env, FSharpList`1<SynType> synTypes, UnscopedTyparEnv tpenv, SynMemberSig synMemberSig, Range m);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TType, SynValInfo> generateOneMember$cont@4169(TcFileState cenv, TcGlobals g, SynValInfo valSynInfo, Range m, TType declaredTy, SynMemberFlags memberFlags, Unit unitVar);
    internal static ValSpecResult reallyGenerateOneMember@4197(TcFileState cenv, TcEnv env, FSharpList`1<Attrib> attrs, TcGlobals g, Range m, FSharpList`1<Typar> declaredTypars, ParentRef altActualParent, FSharpRef`1<FSharpList`1<Typar>> enclosingDeclaredTypars, FSharpRef`1<FSharpOption`1<EntityRef>> memberContainerInfo, FSharpRef`1<DeclKind> declKind, Ident id, SynValInfo valSynInfo, TType tyR, SynMemberFlags memberFlags);
    internal static FSharpList`1<ValSpecResult> generateOneMember@4158(TcFileState cenv, TcEnv env, FSharpList`1<Attrib> attrs, TcGlobals g, SynValInfo valSynInfo, Range m, Ident id, FSharpList`1<Typar> declaredTypars, ParentRef altActualParent, TType declaredTy, TType thisTy, FSharpRef`1<FSharpList`1<Typar>> enclosingDeclaredTypars, FSharpRef`1<FSharpOption`1<EntityRef>> memberContainerInfo, FSharpRef`1<DeclKind> declKind, SynMemberFlags memberFlags);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ValSpecResult>, UnscopedTyparEnv> TcValSpec(TcFileState cenv, TcEnv env, DeclKind declKind, ImplicitlyBoundTyparsAllowed newOk, ContainerInfo containerInfo, FSharpOption`1<SynMemberFlags> memFlagsOpt, FSharpOption`1<TType> thisTyOpt, UnscopedTyparEnv tpenv, SynValSig synValSig, FSharpList`1<Attrib> attrs);
    internal static Tuple`2<Typar, UnscopedTyparEnv> checkRes@4267(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, Ident id, Typar res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Typar, UnscopedTyparEnv> TcTypeOrMeasureParameter(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, UnscopedTyparEnv tpenv, SynTypar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Typar, UnscopedTyparEnv> TcTypar(TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, UnscopedTyparEnv tpenv, SynTypar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar TcTyparDecl(TcFileState cenv, TcEnv env, SynTyparDecl synTyparDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> TcTyparDecls(TcFileState cenv, TcEnv env, FSharpList`1<SynTyparDecl> synTypars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeOrMeasure(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, WarnOnIWSAM iwsam, TcEnv env, UnscopedTyparEnv tpenv, SynType synTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckIWSAM(TcFileState cenv, TcEnv env, CheckConstraints checkConstraints, WarnOnIWSAM iwsam, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcLongIdentType(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, WarnOnIWSAM iwsam, TcEnv env, UnscopedTyparEnv tpenv, SynLongIdent synLongId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcLongIdentAppType(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, WarnOnIWSAM iwsam, TcEnv env, UnscopedTyparEnv tpenv, SynLongIdent longId, bool postfix, FSharpList`1<SynType> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcNestedAppType(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, WarnOnIWSAM iwsam, TcEnv env, UnscopedTyparEnv tpenv, SynType synLeftTy, SynLongIdent synLongId, FSharpList`1<SynType> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTupleType(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, bool isStruct, FSharpList`1<SynTupleTypeSegment> args, Range m);
    internal static void CheckAnonRecdTypeDuplicateFields(Ident[] elems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcAnonRecdType(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, bool isStruct, FSharpList`1<Tuple`2<Ident, SynType>> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcFunctionType(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, SynType domainTy, SynType resultTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcArrayType(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, int rank, SynType elemTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeParameter(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, UnscopedTyparEnv tpenv, SynTypar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcAnonType(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, UnscopedTyparEnv tpenv, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeWithConstraints(TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, UnscopedTyparEnv tpenv, SynType synTy, FSharpList`1<SynTypeConstraint> synConstraints);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeHashConstraint(TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, UnscopedTyparEnv tpenv, SynType synTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcIntersectionConstraint(TcFileState cenv, TcEnv env, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, UnscopedTyparEnv tpenv, FSharpOption`1<SynTypar> synTypar, FSharpList`1<SynType> synTys, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeStaticConstant(FSharpOption`1<TyparKind> kindOpt, UnscopedTyparEnv tpenv, SynConst c, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeMeasurePower(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, SynType ty, SynRationalConst exponent, Range m);
    [CompilerGeneratedAttribute]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeMeasureApp$cont@4631(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, SynType arg1, FSharpList`1<SynType> args, bool postfix, Range m, Range m1, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeMeasureApp(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, SynType arg1, FSharpList`1<SynType> args, bool postfix, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcType(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, WarnOnIWSAM iwsam, TcEnv env, UnscopedTyparEnv tpenv, SynType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Measure, UnscopedTyparEnv> TcMeasure(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, SynType _arg1, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar TcAnonTypeOrMeasure(FSharpOption`1<TyparKind> kindOpt, TcFileState _cenv, TyparRigidity rigid, TyparDynamicReq dyn, ImplicitlyBoundTyparsAllowed newOk, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, UnscopedTyparEnv> TcTypesAsTuple(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<SynTupleTypeSegment> args, Range m);
    internal static Tuple`2<Measure, UnscopedTyparEnv> gather@4701-8(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, Range m, FSharpList`1<SynTupleTypeSegment> args, UnscopedTyparEnv tpenv, Measure acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Measure, UnscopedTyparEnv> TcMeasuresAsTuple(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<SynTupleTypeSegment> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, UnscopedTyparEnv> TcTypesOrMeasures(FSharpOption`1<FSharpList`1<TyparKind>> optKinds, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<SynType> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnscopedTyparEnv TcTyparConstraints(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<SynTypeConstraint> synConstraints);
    internal static s fail@4735-4(TcEnv env, TType kind, SynType v, Unit unitVar0);
    internal static void record@4736(TcFileState cenv, TcEnv env, FSharpOption`1<Ident> idOpt, ArgumentContainer container, TType ttype);
    [CompilerGeneratedAttribute]
internal static Tuple`2<object, UnscopedTyparEnv> TcStaticConstantParameter$cont@4745(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, TType kind, FSharpOption`1<Ident> idOpt, ArgumentContainer container, SynType v, TcGlobals g, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static object v$cont@4776(TcFileState cenv, TcEnv env, TType kind, FSharpOption`1<Ident> idOpt, ArgumentContainer container, SynType v, TcGlobals g, Expr matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<object, UnscopedTyparEnv> TcStaticConstantParameter(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, TType kind, SynType _arg2, FSharpOption`1<Ident> idOpt, ArgumentContainer container);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Object[] CrackStaticConstantArgs(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, Tainted`1[] staticParameters, FSharpList`1<SynType> args, ArgumentContainer container, string containerName, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<bool, Tainted`1<ProvidedType>, FSharpFunc`2<Unit, Unit>> TcProvidedTypeAppToStaticConstantArgs(TcFileState cenv, TcEnv env, FSharpOption`1<FSharpList`1<string>> generatedTypePathOpt, UnscopedTyparEnv tpenv, EntityRef tcref, FSharpList`1<SynType> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethInfo> TryTcMethodAppToStaticConstantArgs(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<MethInfo> minfos, FSharpOption`1<Tuple`2<FSharpList`1<SynType>, a>> argsOpt, Range mExprAndArg, Range mItem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tainted`1<ProvidedMethodBase> TcProvidedMethodAppToStaticConstantArgs(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, MethInfo minfo, Tainted`1<ProvidedMethodBase> methBeforeArguments, Tainted`1[] staticParams, FSharpList`1<SynType> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcProvidedTypeApp(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, EntityRef tcref, FSharpList`1<SynType> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeApp(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, TcEnv env, UnscopedTyparEnv tpenv, Range m, EntityRef tcref, FSharpList`1<TType> pathTypeArgs, FSharpList`1<SynType> synArgTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeOrMeasureAndRecover(FSharpOption`1<TyparKind> kindOpt, TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, WarnOnIWSAM iwsam, TcEnv env, UnscopedTyparEnv tpenv, SynType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcTypeAndRecover(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, WarnOnIWSAM iwsam, TcEnv env, UnscopedTyparEnv tpenv, SynType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, UnscopedTyparEnv> TcNestedTypeApplication(TcFileState cenv, ImplicitlyBoundTyparsAllowed newOk, CheckConstraints checkConstraints, ItemOccurence occ, WarnOnIWSAM iwsam, TcEnv env, UnscopedTyparEnv tpenv, Range mWholeTypeApp, TType ty, FSharpList`1<TType> pathTypeArgs, FSharpList`1<SynType> tyargs);
    internal static SynExpr ConvSynPatToSynExpr(SynPat synPat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatLongIdentActivePatternCase(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, Range mLongId, Item item, ActivePatternElemRef apref, FSharpList`1<SynPat> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecordNameAndTypeResolutions(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr expr);
    internal static void dummyCheckedDelayed@5112(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecordNameAndTypeResolutionsDelayed(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Expr, TType, UnscopedTyparEnv> TcExprOfUnknownType(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprFlex(TcFileState cenv, bool flex, bool compat, TType desiredTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprFlex2(TcFileState cenv, TType desiredTy, TcEnv env, bool isMethodArg, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExpr(TcFileState cenv, OverallTy ty, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprNoRecover(TcFileState cenv, OverallTy ty, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Expr, TType, UnscopedTyparEnv> TcExprOfUnknownTypeThen(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprThatIsCtorBody(FSharpOption`1<Val> safeInitInfo_0, SafeInitData safeInitInfo_1, TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprThatCanBeCtorBody(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprThatCantBeCtorBody(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcStmtThatCantBeCtorBody(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcStmt(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<bool, Expr, UnscopedTyparEnv> TryTcStmt(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilerGeneratedAttribute]
internal static void CheckForAdjacentListExpression$cont@5241(SynExpr arg, TcGlobals g, SynExpr arg2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForAdjacentListExpression(TcFileState cenv, SynExpr synExpr, ExprAtomicFlag hpa, bool isInfix, FSharpList`1<DelayedItem> delayed, SynExpr arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isArg, SynExpr synExpr, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprThenSetDynamic(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isArg, SynExpr e1, SynExpr e2, SynExpr rhsExpr, Range m, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprThenDynamic(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isArg, SynExpr e1, Range mQmark, SynExpr e2, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Expr>, UnscopedTyparEnv> TcExprsWithFlexes(TcFileState cenv, TcEnv env, Range m, UnscopedTyparEnv tpenv, FSharpList`1<bool> flexes, FSharpList`1<TType> argTys, FSharpList`1<SynExpr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Expr>, UnscopedTyparEnv> TcExprsNoFlexes(TcFileState cenv, TcEnv env, Range m, UnscopedTyparEnv tpenv, FSharpList`1<TType> argTys, FSharpList`1<SynExpr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckSuperInit(TcFileState cenv, TType objTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Expr, TType, UnscopedTyparEnv> TcExprUndelayedNoType(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcPropagatingExprLeafThenConvert(TcFileState cenv, OverallTy overallTy, TType actualTy, TcEnv env, Range m, FSharpFunc`2<Unit, Tuple`2<Expr, UnscopedTyparEnv>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, b> TcPossiblyPropagatingExprLeafThenConvert(FSharpFunc`2<TType, bool> isPropagating, TcFileState cenv, OverallTy overallTy, TcEnv env, Range m, FSharpFunc`2<TType, Tuple`2<Expr, b>> processExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, b> TcNonPropagatingExprLeafThenConvert(TcFileState cenv, OverallTy overallTy, TcEnv env, Range m, FSharpFunc`2<Unit, Tuple`3<Expr, TType, b>> processExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr TcAdjustExprForTypeDirectedConversions(TcFileState cenv, OverallTy overallTy, TType actualTy, TcEnv env, Range m, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcNonControlFlowExpr(TcEnv env, FSharpFunc`2<TcEnv, Tuple`2<Expr, UnscopedTyparEnv>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprUndelayed(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprMatch(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synInputExpr, DebugPointAtBinding spMatch, FSharpList`1<SynMatchClause> synClauses);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprMatchLambda(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isExnMatch, Range mArg, FSharpList`1<SynMatchClause> clauses, DebugPointAtBinding spMatch, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprTypeAnnotated(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synBodyExpr, SynType synType, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprTypeTest(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synInnerExpr, SynType tgtTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprUpcast(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr, SynExpr synInnerExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprDowncast(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr, SynExpr synInnerExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprLazy(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synInnerExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTupleIsCorrectLength(TcGlobals g, TcEnv env, Range m, TType tupleTy, FSharpList`1<a> args, FSharpFunc`2<FSharpList`1<TType>, Unit> tcArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprTuple(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isExplicitStruct, FSharpList`1<SynExpr> args, Range m);
    internal static TcEnv getInitEnv@5928(TcEnv env, bool isArray, FSharpRef`1<bool> first, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprArrayOrList(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isArray, FSharpList`1<SynExpr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprObjectExpr(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynType synObjTy, FSharpOption`1<Tuple`2<SynExpr, FSharpOption`1<Ident>>> argopt, FSharpList`1<SynBinding> binds, FSharpList`1<SynInterfaceImpl> extraImpls, Range mNewExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprRecord(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, FSharpOption`1<Tuple`5<SynType, SynExpr, Range, FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>>, Range>> inherits, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<Range, FSharpOption`1<Position>>>> withExprOpt, FSharpList`1<SynExprRecordField> synRecdFields, Range mWholeExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprWhileLoop(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, DebugPointAtWhile spWhile, SynExpr synGuardExpr, SynExpr synBodyExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprIntegerForLoop(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, DebugPointAtFor spFor, DebugPointAtInOrTo spTo, Ident id, SynExpr start, bool dir, SynExpr finish, SynExpr body, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprTryWith(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synBodyExpr, FSharpList`1<SynMatchClause> synWithClauses, Range mWithToLast, Range mTryToLast, DebugPointAtTry spTry, DebugPointAtWith spWith);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprTryFinally(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synBodyExpr, SynExpr synFinallyExpr, Range mTryToLast, DebugPointAtTry spTry, DebugPointAtFinally spFinally);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprJoinIn(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr1, Range mInToken, SynExpr synExpr2, Range mAll);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprSequential(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr, DebugPointAtSequential _sp, bool dir, SynExpr synExpr1, SynExpr synExpr2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprSequentialOrImplicitYield(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, DebugPointAtSequential sp, SynExpr synExpr1, SynExpr synExpr2, SynExpr otherExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprStaticOptimization(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<SynStaticOptimizationConstraint> constraints, SynExpr synExpr2, SynExpr expr3, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprDotSet(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr1, SynLongIdent synLongId, SynExpr synExpr2, Range mStmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprDotNamedIndexedPropertySet(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr1, SynLongIdent synLongId, SynExpr synExpr2, SynExpr expr3, Range mStmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprLongIdentSet(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynLongIdent synLongId, SynExpr synExpr2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprNamedIndexPropertySet(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynLongIdent synLongId, SynExpr synExpr1, SynExpr synExpr2, Range mStmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprTraitCall(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<SynType> synTypes, SynMemberSig synMemberSig, SynExpr arg, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprUnionCaseFieldGet(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr1, FSharpList`1<Ident> longId, int fieldNum, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprUnionCaseFieldSet(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synExpr1, FSharpList`1<Ident> longId, int fieldNum, SynExpr synExpr2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcExprILAssembly(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, object ilInstrs, FSharpList`1<SynType> synTyArgs, FSharpList`1<SynExpr> synArgs, FSharpList`1<SynType> synRetTys, Range m);
    internal static FSharpOption`1<SynExpr> RewriteRangeExpr(SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcIteratedLambdas(TcFileState cenv, bool isFirst, TcEnv env, OverallTy overallTy, FSharpSet`1<string> takenNames, UnscopedTyparEnv tpenv, SynExpr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcTyparExprThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynTypar synTypar, Range m, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<SynExpr, bool, Range> |IndexArgOptionalFromEnd|(TcFileState cenv, SynExpr indexArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecodedIndexArg DecodeIndexArg(TcFileState cenv, SynExpr indexArg);
    internal static FSharpList`1<SynExpr> |IndexerArgs|(SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcIndexerThen(TcFileState cenv, TcEnv env, OverallTy overallTy, Range mWholeExpr, Range mDot, UnscopedTyparEnv tpenv, FSharpOption`1<Tuple`2<SynExpr, Range>> setInfo, SynExpr synLeftExpr, FSharpList`1<SynExpr> indexArgs, FSharpList`1<DelayedItem> delayed);
    internal static SynExpr rewriteReverseExpr@6309(FSharpOption`1<SynExpr> synLeftExprOpt, int rank, SynExpr offset, Range range);
    internal static SynExpr mkSynSomeExpr@6320(Range m, SynExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<SynExpr> ExpandIndexArgs(TcFileState cenv, FSharpOption`1<SynExpr> synLeftExprOpt, FSharpList`1<SynExpr> indexArgs);
    internal static SynExpr MakeIndexParam@6393(TcFileState cenv, FSharpList`1<SynExpr> expandedIndexArgs, FSharpList`1<SynExpr> indexArgs, Range idxRange, FSharpOption`1<SynExpr> setSliceArrayOption);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`3<FSharpList`1<string>, string, FSharpList`1<SynExpr>>> info$cont@6429(FSharpOption`1<Tuple`2<SynExpr, Range>> setInfo, FSharpList`1<SynExpr> expandedIndexArgs, FSharpList`1<string> sliceOpPath, FSharpList`1<DecodedIndexArg> indexArgs, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcIndexingThen(TcFileState cenv, TcEnv env, OverallTy overallTy, Range mWholeExpr, Range mDot, UnscopedTyparEnv tpenv, FSharpOption`1<Tuple`2<SynExpr, Range>> setInfo, FSharpOption`1<SynExpr> synLeftExprOpt, Expr expr, TType exprTy, FSharpList`1<SynExpr> expandedIndexArgs, FSharpList`1<SynExpr> indexArgs, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcNewExpr(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, TType objTy, FSharpOption`1<Range> mObjTyOpt, bool superInit, SynExpr arg, Range mWholeExprOrObjTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcCtorCall(bool isNaked, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, OverallTy overallTy, TType objTy, FSharpOption`1<Range> mObjTyOpt, Item item, bool superInit, FSharpList`1<SynExpr> args, Range mWholeCall, FSharpList`1<DelayedItem> delayed, FSharpOption`1<AfterResolution> afterTcOverloadResolutionOpt);
    internal static bool fieldNameUnbound@6627(FSharpList`1<Tuple`2<string, Expr>> fldsList, string name2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcRecordConstruction(TcFileState cenv, TType overallTy, bool isObjExpr, TcEnv env, UnscopedTyparEnv tpenv, FSharpOption`1<Tuple`3<Expr, Val, Expr>> withExprInfoOpt, TType objTy, IEnumerable`1<Tuple`2<string, SynExpr>> fldsList, Range m);
    internal static Tuple`2<string, SynValInfo> lookPat@6708(NormalizedBindingRhs rhsExpr, Range mBinding, SynPat pat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, SynValInfo> GetNameAndSynValInfoOfObjExprBinding(c _cenv, d _env, NormalizedBinding b);
    internal static string getSignature@6735(TcFileState cenv, TcEnv env, Range mBinding, MethInfo absSlot);
    internal static string getDetails@6736(TcFileState cenv, TcGlobals g, Range mBinding, MethInfo absSlot);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<bool, FSharpList`1<Typar>, TType>> FreshenObjExprAbstractSlot(TcFileState cenv, TcEnv env, TType implTy, FSharpList`1<Tuple`2<Tuple`2<string, e>, MethInfo>> virtNameAndArityPairs, NormalizedBinding bind, FSharpList`1<Attrib> bindAttribs, string bindName, FSharpList`1<Tuple`2<f, MethInfo>> absSlots);
    internal static Tuple`3<NormalizedBindingRhs, Ident, SynMemberFlags> lookPat@6794-1(TcFileState cenv, Range mBinding, NormalizedBindingRhs bindingRhs, FSharpOption`1<SynMemberFlags> memberFlagsOpt, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`5<Ident, SynMemberFlags, TType, FSharpList`1<Attrib>, Expr>, UnscopedTyparEnv> TcObjectExprBinding(TcFileState cenv, TcEnv env, TType implTy, UnscopedTyparEnv tpenv, FSharpOption`1<Tuple`3<bool, FSharpList`1<Typar>, TType>> absSlotInfo, NormalizedBinding bind);
    internal static bool func2@1-4(Tuple`2<string, FSharpList`1<int>> bkey, string y0, FSharpList`1<int> y1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`6<Range, TType, FSharpList`1<RequiredSlot>, FSharpMap`2<string, FSharpList`1<RequiredSlot>>, FSharpList`1<OverrideInfo>, FSharpList`1<Tuple`2<OverrideInfo, Tuple`5<FSharpOption`1<Val>, Val, FSharpList`1<FSharpList`1<Val>>, FSharpList`1<Attrib>, Expr>>>>>, UnscopedTyparEnv> ComputeObjectExprOverrides(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<Tuple`3<Range, TType, FSharpList`1<SynBinding>>> impls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckSuperType(TcFileState cenv, TType ty, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcObjectExpr(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, TType objTy, TType realObjTy, FSharpOption`1<Tuple`2<SynExpr, FSharpOption`1<Ident>>> argopt, FSharpList`1<SynBinding> binds, FSharpList`1<Tuple`3<Range, TType, FSharpList`1<SynBinding>>> extraImpls, Range mObjTy, Range mNewExpr, Range mWholeExpr);
    internal static bool isFormat@7051(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcConstStringExpr(TcFileState cenv, OverallTy overallTy, TcEnv env, Range m, UnscopedTyparEnv tpenv, string s, LiteralArgumentType literalType);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcFormatStringExpr$cont@7094(TcFileState cenv, TcEnv env, Range m, UnscopedTyparEnv tpenv, string fmtString, LiteralArgumentType formatStringLiteralType, TcGlobals g, TType aty, TType bty, TType cty, TType dty, TType ety, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcFormatStringExpr(TcFileState cenv, OverallTy overallTy, TcEnv env, Range m, UnscopedTyparEnv tpenv, string fmtString, LiteralArgumentType formatStringLiteralType);
    [CompilerGeneratedAttribute]
internal static FSharpChoice`2<Tuple`2<bool, MethInfo>, MethInfo> stringKind$cont@7169(TcFileState cenv, OverallTy overallTy, TcEnv env, Range m, TcGlobals g, TType printerTy, TType printerArgTy, TType printerResidueTy, TType printerResultTy, TType formatTy, MethInfo newFormatMethod, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static string printfFormatString$cont@7207(Range m, SynInterpolatedStringPart _arg17, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcInterpolatedStringExpr(TcFileState cenv, OverallTy overallTy, TcEnv env, Range m, UnscopedTyparEnv tpenv, FSharpList`1<SynInterpolatedStringPart> parts);
    [CompilerGeneratedAttribute]
internal static SynExpr expr$cont@7341(Range m, TcGlobals g, string suffix, string s, string modName, ResultOrException`1<FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcConstExpr(TcFileState cenv, OverallTy overallTy, TcEnv env, Range m, UnscopedTyparEnv tpenv, SynConst c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcAssertExpr(TcFileState cenv, OverallTy overallTy, TcEnv env, Range m, UnscopedTyparEnv tpenv, SynExpr x);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`2<string, SynExpr>> fldsList$cont@7421(TcFileState cenv, TType overallTy, TcEnv env, Range mWholeExpr, TcGlobals g, FSharpList`1<Tuple`2<Tuple`2<FSharpList`1<Ident>, Ident>, FSharpOption`1<SynExpr>>> flds, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcRecdExpr(TcFileState cenv, TType overallTy, TcEnv env, UnscopedTyparEnv tpenv, FSharpOption`1<Tuple`5<SynType, SynExpr, Range, FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>>, Range>> inherits, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<Range, FSharpOption`1<Position>>>> withExprOpt, FSharpList`1<SynExprRecordField> synRecdFields, Range mWholeExpr);
    internal static void CheckAnonRecdExprDuplicateFields(Ident[] elems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcAnonRecdExpr(TcFileState cenv, TType overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isStruct, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<Range, FSharpOption`1<Position>>>> optOrigSynExpr, FSharpList`1<Tuple`3<SynLongIdent, FSharpOption`1<Range>, SynExpr>> unsortedFieldIdsAndSynExprsGiven, Range mWholeExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcNewAnonRecdExpr(TcFileState cenv, TType overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isStruct, FSharpList`1<Tuple`3<SynLongIdent, FSharpOption`1<Range>, SynExpr>> unsortedFieldIdsAndSynExprsGiven, Range mWholeExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcCopyAndUpdateAnonRecdExpr(TcFileState cenv, TType overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool isStruct, Tuple`2<SynExpr, Tuple`2<Range, FSharpOption`1<Position>>> _arg3, FSharpList`1<Tuple`3<SynLongIdent, FSharpOption`1<Range>, SynExpr>> unsortedFieldIdsAndSynExprsGiven, Range mWholeExpr);
    internal static FSharpValueOption`1<Tuple`3<MethInfo, MethInfo, bool>> tryGetOptimizeSpanMethodsAux@7696(TcFileState cenv, TcEnv env, TcGlobals g, Range m, TType ty, bool isReadOnlySpan);
    internal static FSharpValueOption`1<Tuple`3<MethInfo, MethInfo, bool>> tryGetOptimizeSpanMethods@7708(TcFileState cenv, TcEnv env, TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcForEachExpr(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, bool seqExprOnly, bool isFromSource, SynPat synPat, SynExpr synEnumExpr, SynExpr synBodyExpr, Range mWholeExpr, DebugPointAtFor spFor, DebugPointAtInOrTo spIn, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcQuotationExpr(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynExpr _oper, bool raw, SynExpr ast, bool isFromQueryExpression, Range m);
    internal static void propagate@7885(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, ApplicableExpr expr, FSharpList`1<DelayedItem> delayed, TcGlobals g, bool isAddrOf, FSharpList`1<DelayedItem> delayedList, Range mExpr, TType exprTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void Propagate(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, ApplicableExpr expr, TType exprTy, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> PropagateThenTcDelayed(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, Range mExpr, ApplicableExpr expr, TType exprTy, ExprAtomicFlag atomicFlag, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcDelayed(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, Range mExpr, ApplicableExpr expr, TType exprTy, ExprAtomicFlag atomicFlag, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<DelayedItem> delayRest(FSharpList`1<Ident> rest, Range mPrior, FSharpList`1<DelayedItem> delayed);
    internal static SynExpr stripParens@8050(SynExpr expr);
    internal static Ident check@8057-7(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, TcGlobals g, Range m, FSharpOption`1<OverallTy> overallTyOpt, FSharpOption`1<Ident> resultOpt, SynExpr expr, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr TcNameOfExpr(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynExpr synArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr TcNameOfExprResult(TcFileState cenv, Ident lastIdent, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAdjacentListExpr(bool isSugar, ExprAtomicFlag atomicFlag, FSharpOption`1<SynExpr> synLeftExprOpt, SynExpr synArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcApplicationThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, Range mExprAndArg, FSharpOption`1<SynExpr> synLeftExprOpt, ApplicableExpr leftExpr, TType exprTy, SynExpr synArg, ExprAtomicFlag atomicFlag, bool isSugar, FSharpList`1<DelayedItem> delayed);
    internal static TypeNameResolutionInfo GetLongIdentTypeNameInfo(FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcLongIdentThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, SynLongIdent _arg4, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<TType> tinstEnclosing, Item item, Range mItem, FSharpList`1<Ident> rest, AfterResolution afterResolution, FSharpOption`1<TType> staticTyOpt, FSharpList`1<DelayedItem> delayed);
    internal static FSharpFunc`2<s, FSharpFunc`2<FSharpList`1<t>, t>> mkConstrApp@8391(Range mItem);
    internal static FSharpOption`1<FSharpList`1<SynExpr>> |FittedArgs|_|@8405(int numArgTys, SynExpr arg);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynExpr> args$cont@8432-1(TcFileState cenv, TcEnv env, Item item, TcGlobals g, AccessorDomain ad, FSharpList`1<TType> argTys, FSharpList`1<Ident> argNames, int numArgTys, FSharpList`1<SynExpr> args, FSharpList`1<SynExpr> unnamedArgs, FSharpList`1<Tuple`3<bool, Ident, SynExpr>> namedCallerArgs, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcUnionCaseOrExnCaseOrActivePatternResultItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, Item item, UnscopedTyparEnv tpenv, Range mItem, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcTypeItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, string nm, TType ty, UnscopedTyparEnv tpenv, Range mItem, FSharpList`1<TType> tinstEnclosing, FSharpList`1<DelayedItem> delayed);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcMethodItemThen$cont@8588(TcFileState cenv, OverallTy overallTy, TcEnv env, string methodName, FSharpList`1<MethInfo> minfos, UnscopedTyparEnv tpenv, Range mItem, AfterResolution afterResolution, FSharpOption`1<TType> staticTyOpt, AccessorDomain ad, FSharpList`1<DelayedItem> otherDelayed, Range mExprAndTypeArgs, FSharpOption`1<MethInfo> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcMethodItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, Item item, string methodName, FSharpList`1<MethInfo> minfos, UnscopedTyparEnv tpenv, Range mItem, AfterResolution afterResolution, FSharpOption`1<TType> staticTyOpt, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcCtorItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, Item item, string nm, FSharpList`1<MethInfo> minfos, FSharpList`1<TType> tinstEnclosing, UnscopedTyparEnv tpenv, Range mItem, AfterResolution afterResolution, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcTraitItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, FSharpOption`1<Expr> objOpt, TraitConstraintInfo traitInfo, UnscopedTyparEnv tpenv, Range mItem, FSharpList`1<DelayedItem> delayed);
    [CompilerGeneratedAttribute]
internal static bool func2@1-5(FSharpOption`1<SynExpr> option);
    internal static bool isSimpleArgument@8769(SynExpr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcImplicitOpItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, Ident id, FSharpRef`1<FSharpOption`1<TraitConstraintSln>> sln, UnscopedTyparEnv tpenv, Range mItem, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcDelegateCtorItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, TType ty, FSharpList`1<TType> tinstEnclosing, UnscopedTyparEnv tpenv, Range mItem, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcValueItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, ValRef vref, UnscopedTyparEnv tpenv, Range mItem, AfterResolution afterResolution, FSharpList`1<DelayedItem> delayed);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcPropertyItemThen$cont@8970(TcFileState cenv, OverallTy overallTy, TcEnv env, string nm, FSharpList`1<PropInfo> pinfos, Range mItem, AfterResolution afterResolution, FSharpOption`1<TType> staticTyOpt, TcGlobals g, AccessorDomain ad, PropInfo pinfo, FSharpOption`1<FSharpList`1<TType>> tyArgsOpt, UnscopedTyparEnv tpenv, FSharpList`1<DelayedItem> delayed, FSharpList`1<SynExpr> args, FSharpList`1<DelayedItem> otherDelayed, Range mStmt, SynExpr expr2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcPropertyItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, string nm, FSharpList`1<PropInfo> pinfos, UnscopedTyparEnv tpenv, Range mItem, AfterResolution afterResolution, FSharpOption`1<TType> staticTyOpt, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcILFieldItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, ILFieldInfo finfo, UnscopedTyparEnv tpenv, Range mItem, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcRecdFieldItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, RecdFieldInfo rfinfo, UnscopedTyparEnv tpenv, Range mItem, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<ExprAtomicFlag, FSharpOption`1<Tuple`2<FSharpList`1<SynType>, Range>>, FSharpList`1<SynExpr>, FSharpList`1<DelayedItem>, g> GetSynMemberApplicationArgs(FSharpList`1<DelayedItem> delayed, g tpenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<FSharpList`1<TType>>, UnscopedTyparEnv> TcMemberTyArgsOpt(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, FSharpOption`1<Tuple`2<FSharpList`1<SynType>, Range>> tyArgsOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<ExprAtomicFlag, FSharpOption`1<FSharpList`1<TType>>, FSharpList`1<SynExpr>, FSharpList`1<DelayedItem>, UnscopedTyparEnv> GetMemberApplicationArgs(FSharpList`1<DelayedItem> delayed, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcLookupThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, Range mObjExpr, Expr objExpr, TType objExprTy, FSharpList`1<Ident> longId, FSharpList`1<DelayedItem> delayed, Range mExprAndLongId);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcLookupItemThen$cont@9175(TcFileState cenv, OverallTy overallTy, TcEnv env, Expr objExpr, Range mItem, AfterResolution afterResolution, TcGlobals g, AccessorDomain ad, FSharpList`1<Expr> objArgs, Range mExprAndItem, FSharpList`1<PropInfo> pinfos, string nm, PropInfo pinfo, FSharpOption`1<FSharpList`1<TType>> tyArgsOpt, UnscopedTyparEnv tpenv, FSharpList`1<DelayedItem> delayed, ExprAtomicFlag atomicFlag, FSharpList`1<SynExpr> args, FSharpList`1<DelayedItem> otherDelayed, Range mStmt, SynExpr expr2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcLookupItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, Range mObjExpr, Expr objExpr, TType objExprTy, FSharpList`1<DelayedItem> delayed, Item item, Range mItem, FSharpList`1<Ident> rest, AfterResolution afterResolution);
    internal static Expr bindObjArgs@9308(Range mItem, FSharpOption`1<Tuple`2<Expr, TType>> objDetails, FSharpFunc`2<FSharpList`1<Expr>, Expr> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcEventItemThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, Range mItem, Range mExprAndItem, FSharpOption`1<Tuple`2<Expr, TType>> objDetails, EventInfo einfo, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcMethodApplicationThen(TcFileState cenv, TcEnv env, OverallTy overallTy, FSharpOption`1<TType> objTyOpt, UnscopedTyparEnv tpenv, FSharpOption`1<FSharpList`1<TType>> callerTyArgs, FSharpList`1<Expr> objArgs, Range m, Range mItem, string methodName, AccessorDomain ad, Mutates mut, bool isProp, FSharpList`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> meths, AfterResolution afterResolution, ValUseFlag isSuperInit, FSharpList`1<SynExpr> args, ExprAtomicFlag atomicFlag, FSharpOption`1<TType> staticTyOpt, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GetNewInferenceTypeForMethodArg(TcFileState cenv, h env, i tpenv, SynExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CalledMethHasSingleArgumentGroupOfThisLength(int n, MethInfo calledMeth);
    internal static bool isSimpleFormalArg(ParamAttribs info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<TType>> GenerateMatchingSimpleArgumentTypes(TcFileState cenv, MethInfo calledMeth, Range mItem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<TType>>, TType> UnifyMatchingSimpleArgumentTypes(TcFileState cenv, TcEnv env, TType exprTy, MethInfo calledMeth, Range mMethExpr, Range mItem);
    internal static Tuple`3<SynExpr, TType, Range> MakeUnnamedCallerArgInfo@9466(TcFileState cenv, TcEnv env, j tpenv, SynExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpOption`1<Tuple`2<FSharpList`1<FSharpList`1<Tuple`3<SynExpr, TType, Range>>>, FSharpList`1<FSharpList`1<Tuple`5<Ident, bool, SynExpr, TType, Range>>>>>, FSharpOption`1<SynExpr>, OverallTy> TcMethodApplication_SplitSynArguments(TcFileState cenv, TcEnv env, j tpenv, bool isProp, FSharpList`1<MethInfo> candidates, OverallTy exprTy, FSharpList`1<SynExpr> curriedCallerArgs, Range mItem);
    internal static CalledMeth`1<SynExpr> makeOneCalledMeth@9585(TcFileState cenv, TcEnv env, FSharpOption`1<FSharpList`1<TType>> tyArgsOpt, AccessorDomain ad, FSharpOption`1<TType> objTyOpt, bool isCheckingAttributeCall, FSharpList`1<TType> callerObjArgTys, Range mMethExpr, Range mItem, FSharpOption`1<TType> staticTyOpt, CallerArgs`1<SynExpr> callerArgs, MethInfo minfo, FSharpOption`1<PropInfo> pinfoOpt, bool usesParamArrayConversion);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<OperationResult`1<bool>, FSharpList`1<CalledMeth`1<SynExpr>>> TcMethodApplication_UniqueOverloadInference(TcFileState cenv, TcEnv env, OverallTy exprTy, FSharpOption`1<FSharpList`1<TType>> tyArgsOpt, AccessorDomain ad, FSharpOption`1<TType> objTyOpt, bool isCheckingAttributeCall, FSharpList`1<TType> callerObjArgTys, string methodName, FSharpOption`1<Tuple`2<FSharpList`1<FSharpList`1<Tuple`3<SynExpr, TType, Range>>>, FSharpList`1<FSharpList`1<Tuple`5<Ident, bool, SynExpr, TType, Range>>>>> curriedCallerArgsOpt, IEnumerable`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> candidateMethsAndProps, FSharpList`1<MethInfo> candidates, Range mMethExpr, Range mItem, FSharpOption`1<TType> staticTyOpt);
    internal static FSharpList`1<FSharpList`1<FSharpOption`1<string>>> paramNamesIfFeatureEnabled@9625(TcGlobals g, MethInfo meth);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<FSharpList`1<FSharpList`1<CallerArg`1<Expr>>>, FSharpList`1<FSharpList`1<CallerNamedArg`1<Expr>>>, FSharpOption`1<FSharpList`1<FSharpList`1<Val>>>, OverallTy, UnscopedTyparEnv> TcMethodApplication_CheckArguments(TcFileState cenv, TcEnv env, OverallTy exprTy, FSharpOption`1<Tuple`2<FSharpList`1<FSharpList`1<Tuple`3<SynExpr, TType, Range>>>, FSharpList`1<FSharpList`1<Tuple`5<Ident, bool, SynExpr, TType, Range>>>>> curriedCallerArgsOpt, FSharpList`1<MethInfo> candidates, FSharpList`1<CalledMeth`1<SynExpr>> preArgumentTypeCheckingCalledMethGroup, FSharpList`1<TType> callerObjArgTys, AccessorDomain ad, Range mMethExpr, Range mItem, UnscopedTyparEnv tpenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TcAdhocChecksOnLibraryMethods(TcFileState cenv, TcEnv env, bool isInstance, CalledMeth`1<k> finalCalledMeth, MethInfo finalCalledMethInfo, IEnumerable`1<Expr> objArgs, Range mMethExpr, Range mItem);
    [CompilerGeneratedAttribute]
internal static void finalCalledMeth$cont@9830(TcFileState cenv, TcGlobals g, Item unrefinedItem, CalledMeth`1<Expr> result, FSharpFunc`2<Tuple`3<MethInfo, FSharpOption`1<PropInfo>, FSharpList`1<Tuple`2<Typar, TType>>>, Unit> callSink, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`3<Expr, FSharpList`1<CallerNamedArg`1<Expr>>, FSharpList`1<DelayedItem>>, UnscopedTyparEnv> TcMethodApplication(bool isCheckingAttributeCall, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, FSharpOption`1<FSharpList`1<TType>> tyArgsOpt, FSharpList`1<Expr> objArgs, Range mMethExpr, Range mItem, string methodName, FSharpOption`1<TType> objTyOpt, AccessorDomain ad, Mutates mut, bool isProp, FSharpList`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> calledMethsAndProps, AfterResolution afterResolution, ValUseFlag isSuperInit, FSharpList`1<SynExpr> curriedCallerArgs, OverallTy exprTy, FSharpOption`1<TType> staticTyOpt, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpOption`1<FSharpFunc`2<Expr, Expr>>, Expr, Range> TcSetterArgExpr(TcFileState cenv, TcEnv env, DisplayEnv denv, Expr objExpr, AccessorDomain ad, AssignedItemSetter`1<Expr> assignedSetter, bool calledFromConstructor);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<CallerArg`1<Expr>>>, Tuple`2<Tuple`2[], UnscopedTyparEnv>> TcUnnamedMethodArgs(TcFileState cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, UnscopedTyparEnv tpenv, FSharpList`1<FSharpList`1<CallerArg`1<SynExpr>>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CallerArg`1<Expr>, Tuple`2<Tuple`2[], UnscopedTyparEnv>> TcUnnamedMethodArg(TcFileState cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, UnscopedTyparEnv tpenv, int i, int j, CallerArg`1<SynExpr> _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<CallerNamedArg`1<Expr>>>, Tuple`2<Tuple`2[], UnscopedTyparEnv>> TcMethodNamedArgs(TcFileState cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, UnscopedTyparEnv tpenv, FSharpList`1<FSharpList`1<CallerNamedArg`1<SynExpr>>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CallerNamedArg`1<Expr>, Tuple`2<Tuple`2[], UnscopedTyparEnv>> TcMethodNamedArg(TcFileState cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, UnscopedTyparEnv tpenv, CallerNamedArg`1<SynExpr> _arg6);
    internal static void loop@10095-67(TcFileState cenv, TcEnv env, Range mArg, TcGlobals g, TType[][] prefixOfLambdaArgsForEachOverload, int numLambdaVars, TType callerLambdaTy, int lambdaVarNum);
    [CompilerGeneratedAttribute]
internal static void TcMethodArg$cont@10084(TcFileState cenv, TcEnv env, ArgumentAnalysis[] lambdaPropagationInfoForArg, Range mArg, TType callerArgTy, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CallerArg`1<Expr>, Tuple`2<Tuple`2[], UnscopedTyparEnv>> TcMethodArg(TcFileState cenv, TcEnv env, Tuple`2[] lambdaPropagationInfo, UnscopedTyparEnv tpenv, ArgumentAnalysis[] lambdaPropagationInfoForArg, CallerArg`1<SynExpr> _arg7);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcNewDelegateThen(TcFileState cenv, OverallTy overallTy, TcEnv env, UnscopedTyparEnv tpenv, Range mDelTy, Range mExprAndArg, TType delegateTy, SynExpr synArg, ExprAtomicFlag atomicFlag, FSharpList`1<DelayedItem> delayed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr bindLetRec(FSharpList`1<Binding> binds, Range m, Expr e);
    internal static void CheckRecursiveBindingIds(IEnumerable`1<SynBinding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, UnscopedTyparEnv> TcLinearExprs(FSharpFunc`2<OverallTy, FSharpFunc`2<TcEnv, FSharpFunc`2<UnscopedTyparEnv, FSharpFunc`2<SynExpr, Tuple`2<Expr, UnscopedTyparEnv>>>>> bodyChecker, TcFileState cenv, TcEnv env, OverallTy overallTy, UnscopedTyparEnv tpenv, bool isCompExpr, SynExpr synExpr, FSharpFunc`2<Tuple`2<Expr, UnscopedTyparEnv>, Tuple`2<Expr, UnscopedTyparEnv>> cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Expr, UnscopedTyparEnv> TcAndPatternCompileMatchClauses(Range mExpr, Range mMatch, ActionOnFailure actionOnFailure, TcFileState cenv, FSharpOption`1<Expr> inputExprOpt, TType inputTy, OverallTy resultTy, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<SynMatchClause> synClauses);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<Pattern, FSharpOption`1<Expr>, FSharpList`1<Val>, TcEnv, UnscopedTyparEnv> TcMatchPattern(TcFileState cenv, TType inputTy, TcEnv env, UnscopedTyparEnv tpenv, SynPat synPat, FSharpOption`1<SynExpr> synWhenExprOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<MatchClause>, UnscopedTyparEnv> TcMatchClauses(TcFileState cenv, TType inputTy, OverallTy resultTy, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<SynMatchClause> clauses);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MatchClause, UnscopedTyparEnv> TcMatchClause(TcFileState cenv, TType inputTy, OverallTy resultTy, TcEnv env, bool isFirst, UnscopedTyparEnv tpenv, SynMatchClause synMatchClause);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<StaticOptimization, UnscopedTyparEnv> TcStaticOptimizationConstraint(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynStaticOptimizationConstraint c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkConvToNativeInt(TcGlobals g, Expr e, Range m);
    internal static FSharpOption`1<Expr> tryBuildGetPinnableReferenceCall@10326(TcFileState cenv, TcEnv env, TType overallPatTy, Expr fixedExpr, TType overallExprTy, Range mBinding, TcGlobals g, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void TcAndBuildFixedExpr$cont@10389(Expr fixedExpr, Range mBinding, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr TcAndBuildFixedExpr(TcFileState cenv, TcEnv env, TType overallPatTy, Expr fixedExpr, TType overallExprTy, Range mBinding);
    internal static FSharpList`1<Attrib> TcAttrs@10498(TcFileState cenv, Range mBinding, TcEnv envinner, AttributeTargets attrTgt, AttributeTargets tgt, bool isRet, FSharpList`1<SynAttribute> attrs);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, UnscopedTyparEnv> f@614-9(TcFileState cenv, FSharpOption`1<Val> safeThisValOpt, SafeInitData safeInitInfo, SynPat pat, DebugPointAtBinding debugPoint, PrelimValReprInfo prelimValReprInfo, UnscopedTyparEnv tpenv, TcEnv envinner, bool isCtor, FSharpRef`1<SynExpr> rhsExpr, FSharpRef`1<TType> overallExprTy, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CheckedBindingInfo, UnscopedTyparEnv> TcNormalizedBinding(DeclKind declKind, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, TType overallTy, FSharpOption`1<Val> safeThisValOpt, SafeInitData safeInitInfo, FSharpList`1<Typar> enclosingDeclaredTypars, ExplicitTyparInfo explicitTyparInfo, NormalizedBinding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, FSharpOption`1<Const>> TcLiteral(TcFileState cenv, TType overallTy, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<Attrib> attrs, SynExpr synLiteralValExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ExplicitTyparInfo, UnscopedTyparEnv> TcBindingTyparDecls(bool alwaysRigid, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, SynValTyparDecls _arg8);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ExplicitTyparInfo, UnscopedTyparEnv> TcNonrecBindingTyparDecls(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, NormalizedBinding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CheckedBindingInfo, UnscopedTyparEnv> TcNonRecursiveBinding(DeclKind declKind, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, TType ty, SynBinding binding);
    internal static ResultOrException`1<Tuple`2<TType, UnscopedTyparEnv>> try1@10787(TcFileState cenv, TcEnv env, Range mAttr, FSharpList`1<Ident> typath, Ident tyid, string n);
    [CompilerGeneratedAttribute]
internal static bool contains@1-11(string d, a e, FSharpList`1<string> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<AttributeTargets, Attrib>>, bool> TcAttributeEx(bool canFail, TcFileState cenv, TcEnv env, AttributeTargets attrTgt, AttributeTargets attrEx, SynAttribute synAttr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<AttributeTargets, Attrib>>, bool> TcAttributesWithPossibleTargetsEx(bool canFail, TcFileState cenv, TcEnv env, AttributeTargets attrTgt, AttributeTargets attrEx, FSharpList`1<SynAttribute> synAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Attrib>, bool> TcAttributesMaybeFailEx(bool canFail, TcFileState cenv, TcEnv env, AttributeTargets attrTgt, AttributeTargets attrEx, FSharpList`1<SynAttribute> synAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<AttributeTargets, Attrib>>, bool> TcAttributesWithPossibleTargets(bool canFail, TcFileState cenv, TcEnv env, AttributeTargets attrTgt, FSharpList`1<SynAttribute> synAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Attrib>, FSharpFunc`2<Unit, FSharpList`1<Attrib>>> TcAttributesCanFail(TcFileState cenv, TcEnv env, AttributeTargets attrTgt, FSharpList`1<SynAttribute> synAttribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Attrib> TcAttributes(TcFileState cenv, TcEnv env, AttributeTargets attrTgt, FSharpList`1<SynAttribute> synAttribs);
    internal static Tuple`2<Expr, s> mkSequentialBind@11039(Range m, Expr rhsExpr, Tuple`2<Expr, s> tupledArg);
    internal static Tuple`2<Expr, s> mkRhsBind@11081(Range m, DebugPointAtBinding debugPoint, Expr rhsExpr, Val patternInputTmp, Tuple`2<Expr, s> tupledArg);
    internal static Tuple`2<Expr, TType> mkPatBind@11088(TcFileState cenv, DeclKind declKind, TcGlobals g, ParentRef altActualParent, TcEnv env, TType tauTy, Range m, FSharpList`1<Typar> generalizedTypars, Expr rhsExpr, Val patternInputTmp, Pattern checkedPat2, FSharpList`1<Val> allValsDefinedByPattern, Expr bodyExpr, TType bodyExprTy);
    internal static Tuple`2<Expr, TType> mkCleanup@11102(TcFileState cenv, bool isUse, TcGlobals g, DisplayEnv denv, TcEnv env, Range m, bool isFixed, Val patternInputTmp, Pattern checkedPat2, FSharpList`1<Val> allValsDefinedByPattern, Expr bodyExpr, TType bodyExprTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpFunc`2<Tuple`2<Expr, TType>, Tuple`2<Expr, TType>>, TcEnv, UnscopedTyparEnv> TcLetBinding(TcFileState cenv, bool isUse, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, UnscopedTyparEnv tpenv, FSharpList`1<SynBinding> synBinds, Range synBindsRange, Range scopem);
    internal static FSharpList`1<ModuleOrNamespaceContents> stripLets@11133(FSharpList`1<ModuleOrNamespaceContents> acc, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<ModuleOrNamespaceContents>, TcEnv, UnscopedTyparEnv> TcLetBindings(TcFileState cenv, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, UnscopedTyparEnv tpenv, FSharpList`1<SynBinding> binds, Range bindsm, Range scopem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMemberFlags(FSharpOption`1<a> intfSlotTyOpt, NewSlotsOK newslotsOK, OverridesOK overridesOK, SynMemberFlags memberFlags, Range m);
    internal static void ApplyTypesFromArgumentPatterns(TcFileState cenv, TcEnv env, bool optionalArgsOK, TType ty, Range m, UnscopedTyparEnv tpenv, NormalizedBindingRhs _arg9, FSharpOption`1<SynMemberFlags> memberFlagsOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ComputeIsComplete(FSharpList`1<Typar> enclosingDeclaredTypars, FSharpList`1<Typar> declaredTypars, TType ty);
    internal static bool methInfosEquivByNameAndSig@11211(TcFileState cenv, Range m, TcGlobals g, FSharpList`1<MethInfo> meths);
    internal static FSharpList`1<s> raiseGenericArityMismatch@11235(TcFileState cenv, TcEnv envinner, Range m, Ident memberId, FSharpList`1<MethInfo> dispatchSlots, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<TType>, FSharpList`1<Typar>> ApplyAbstractSlotInference$cont@11219-1(TcFileState cenv, TcEnv envinner, TType argsAndRetTy, Range m, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, Ident memberId, FSharpList`1<Tuple`2<Typar, TType>> renaming, FSharpOption`1<Tuple`2<TType, SlotImplSet>> intfSlotTyOpt, SynValInfo valSynData, SynMemberFlags memberFlags, TcGlobals g, AccessorDomain ad, Tuple`2<TType, FSharpOption`1<SlotImplSet>> typToSearchForAbstractMembers, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpList`1<TType>, FSharpList`1<Typar>> ApplyAbstractSlotInference$cont@11211(TcFileState cenv, TcEnv envinner, TType argsAndRetTy, Range m, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, Ident memberId, FSharpList`1<Tuple`2<Typar, TType>> renaming, FSharpOption`1<Tuple`2<TType, SlotImplSet>> intfSlotTyOpt, SynValInfo valSynData, SynMemberFlags memberFlags, FSharpList`1<Attrib> attribs, TcGlobals g, AccessorDomain ad, Tuple`2<TType, FSharpOption`1<SlotImplSet>> typToSearchForAbstractMembers, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, FSharpList`1<Typar>> ApplyAbstractSlotInference(TcFileState cenv, TcEnv envinner, FSharpOption`1<Val> _arg10, TType argsAndRetTy, Range m, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, Ident memberId, TType tcrefObjTy, FSharpList`1<Tuple`2<Typar, TType>> renaming, FSharpOption`1<Tuple`2<TType, SlotImplSet>> intfSlotTyOpt, SynValInfo valSynData, SynMemberFlags memberFlags, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForNonAbstractInterface(TcGlobals g, DeclKind declKind, EntityRef tcref, SynMemberFlags memberFlags, bool isMemberStatic, Range m);
    internal static Tuple`8<TcEnv, l, Ident, FSharpOption`1<o>, FSharpOption`1<PrelimMemberInfo>, FSharpOption`1<m>, FSharpOption`1<m>, Tuple`6<FSharpOption`1<Val>, FSharpList`1<Typar>, FSharpOption`1<Val>, ExplicitTyparInfo, n, FSharpList`1<Typar>>> AnalyzeRecursiveStaticMemberOrValDecl(TcFileState cenv, TcEnv envinner, l tpenv, DeclKind declKind, SynValTyparDecls synTyparDecls, NewSlotsOK newslotsOK, OverridesOK overridesOK, FSharpOption`1<MemberOrValContainerInfo> tcrefContainerInfo, FSharpOption`1<m> vis1, Ident id, FSharpOption`1<m> vis2, FSharpList`1<Typar> declaredTypars, FSharpOption`1<SynMemberFlags> memberFlagsOpt, FSharpOption`1<Ident> thisIdOpt, FSharpList`1<Attrib> bindingAttribs, SynValInfo valSynInfo, TType ty, n bindingRhs, Range mBinding, ExplicitTyparInfo explicitTyparInfo);
    internal static Tuple`8<TcEnv, p, Ident, FSharpOption`1<Ident>, FSharpOption`1<PrelimMemberInfo>, FSharpOption`1<q>, FSharpOption`1<q>, Tuple`6<FSharpOption`1<r>, FSharpList`1<Typar>, FSharpOption`1<Val>, ExplicitTyparInfo, NormalizedBindingRhs, FSharpList`1<Typar>>> AnalyzeRecursiveInstanceMemberDecl(TcFileState cenv, TcEnv envinner, p tpenv, DeclKind declKind, SynValTyparDecls synTyparDecls, SynValInfo valSynInfo, ExplicitTyparInfo explicitTyparInfo, NewSlotsOK newslotsOK, OverridesOK overridesOK, FSharpOption`1<q> vis1, Ident thisId, Ident memberId, FSharpOption`1<Ident> toolId, bool isTransformedProperty, FSharpList`1<Attrib> bindingAttribs, FSharpOption`1<q> vis2, FSharpOption`1<MemberOrValContainerInfo> tcrefContainerInfo, FSharpOption`1<SynMemberFlags> memberFlagsOpt, TType ty, NormalizedBindingRhs bindingRhs, Range mBinding);
    internal static Tuple`8<TcEnv, UnscopedTyparEnv, Ident, FSharpOption`1<Ident>, FSharpOption`1<PrelimMemberInfo>, FSharpOption`1<SynAccess>, FSharpOption`1<SynAccess>, Tuple`6<FSharpOption`1<Val>, FSharpList`1<Typar>, FSharpOption`1<Val>, ExplicitTyparInfo, NormalizedBindingRhs, FSharpList`1<Typar>>> analyzeRecursiveDeclPat@11596(TcFileState cenv, TcEnv envinner, DeclKind declKind, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, FSharpOption`1<Ident> thisIdOpt, SynValInfo valSynInfo, bool isTransformedProperty, ExplicitTyparInfo explicitTyparInfo, NewSlotsOK newslotsOK, OverridesOK overridesOK, FSharpOption`1<SynAccess> vis1, FSharpList`1<Attrib> bindingAttribs, FSharpOption`1<MemberOrValContainerInfo> tcrefContainerInfo, FSharpOption`1<SynMemberFlags> memberFlagsOpt, TType ty, NormalizedBindingRhs bindingRhs, Range mBinding, UnscopedTyparEnv tpenv, SynPat pat);
    internal static Tuple`8<TcEnv, UnscopedTyparEnv, Ident, FSharpOption`1<Ident>, FSharpOption`1<PrelimMemberInfo>, FSharpOption`1<SynAccess>, FSharpOption`1<SynAccess>, Tuple`6<FSharpOption`1<Val>, FSharpList`1<Typar>, FSharpOption`1<Val>, ExplicitTyparInfo, NormalizedBindingRhs, FSharpList`1<Typar>>> AnalyzeRecursiveDecl(TcFileState cenv, TcEnv envinner, UnscopedTyparEnv tpenv, DeclKind declKind, SynValTyparDecls synTyparDecls, FSharpList`1<Typar> declaredTypars, FSharpOption`1<Ident> thisIdOpt, SynValInfo valSynInfo, bool isTransformedProperty, ExplicitTyparInfo explicitTyparInfo, NewSlotsOK newslotsOK, OverridesOK overridesOK, FSharpOption`1<SynAccess> vis1, SynPat declPattern, FSharpList`1<Attrib> bindingAttribs, FSharpOption`1<MemberOrValContainerInfo> tcrefContainerInfo, FSharpOption`1<SynMemberFlags> memberFlagsOpt, TType ty, NormalizedBindingRhs bindingRhs, Range mBinding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<PreCheckingRecursiveBinding>, FSharpList`1<Val>>, Tuple`2<UnscopedTyparEnv, int>> AnalyzeAndMakeAndPublishRecursiveValue(OverridesOK overridesOK, bool isGeneratedEventVal, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, int recBindIdx, NormalizedRecBindingDefn _arg11);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<PreCheckingRecursiveBinding>, FSharpList`1<Val>, Tuple`2<UnscopedTyparEnv, int>> AnalyzeAndMakeAndPublishRecursiveValues(OverridesOK overridesOK, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<NormalizedRecBindingDefn> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<TcEnv, FSharpList`1<PostGeneralizationRecursiveBinding>, FSharpList`1<PreGeneralizationRecursiveBinding>, UnscopedTyparEnv, FSharpMap`2<long, PreCheckingRecursiveBinding>> TcLetrecBinding(TcFileState cenv, TcEnv envRec, Range scopem, FSharpList`1<Typar> extraGeneralizableTypars, FSharpOption`1<TType> reqdThisValTyOpt, TcEnv envNonRec, FSharpList`1<PostGeneralizationRecursiveBinding> generalizedRecBinds, FSharpList`1<PreGeneralizationRecursiveBinding> preGeneralizationRecBinds, UnscopedTyparEnv tpenv, FSharpMap`2<long, PreCheckingRecursiveBinding> uncheckedRecBindsTable, PreCheckingRecursiveBinding rbind);
    internal static Tuple`2<FSharpList`1<PreGeneralizationRecursiveBinding>, FSharpList`1<PreGeneralizationRecursiveBinding>> loop@11894-69(TcGlobals g, Set`2<Typar, IComparer`1<Typar>> freeInEnv, Lazy`1<FreeTyvars> freeInUncheckedRecBinds, FSharpList`1<PreGeneralizationRecursiveBinding> preGeneralizationRecBinds, FSharpList`1<PreGeneralizationRecursiveBinding> frozenBindings);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<TcEnv, FSharpList`1<PostGeneralizationRecursiveBinding>, FSharpList`1<PreGeneralizationRecursiveBinding>, UnscopedTyparEnv, FSharpMap`2<long, PreCheckingRecursiveBinding>> TcIncrementalLetRecGeneralization(TcFileState cenv, Range scopem, TcEnv envNonRec, FSharpList`1<PostGeneralizationRecursiveBinding> generalizedRecBinds, FSharpList`1<PreGeneralizationRecursiveBinding> preGeneralizationRecBinds, UnscopedTyparEnv tpenv, FSharpMap`2<long, PreCheckingRecursiveBinding> uncheckedRecBindsTable);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> TcLetrecComputeAndGeneralizeGenericTyparsForBinding(TcFileState cenv, DisplayEnv denv, Set`2<Typar, IComparer`1<Typar>> freeInEnv, PreGeneralizationRecursiveBinding pgrbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> TcLetrecComputeSupportForBinding(TcFileState cenv, PreGeneralizationRecursiveBinding pgrbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PostGeneralizationRecursiveBinding TcLetrecGeneralizeBinding(TcFileState cenv, DisplayEnv denv, FSharpList`1<Typar> generalizedTypars, PreGeneralizationRecursiveBinding pgrbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Binding> TcLetrecComputeCtorSafeThisValBind(TcFileState cenv, FSharpOption`1<Val> safeThisValOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeCheckSafeInitField(TcGlobals g, FSharpList`1<TType> tinst, FSharpOption`1<Val> thisValOpt, RecdFieldRef rfref, Expr reqExpr, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeCheckSafeInit(TcGlobals g, FSharpList`1<TType> tinst, SafeInitData safeInitInfo, Expr reqExpr, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PostSpecialValsRecursiveBinding TcLetrecAdjustMemberForSpecialVals(TcFileState cenv, PostGeneralizationRecursiveBinding pgrbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PreInitializationGraphEliminationBinding FixupLetrecBind(TcFileState cenv, DisplayEnv denv, FSharpList`1<Typar> generalizedTyparsForRecursiveBlock, PostSpecialValsRecursiveBinding bind);
    internal static FSharpList`1<Typar> unionGeneralizedTypars(FSharpList`1<FSharpList`1<Typar>> typarSets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<Binding>, TcEnv, UnscopedTyparEnv> TcLetrecBindings(OverridesOK overridesOK, TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, FSharpList`1<RecDefnBindingInfo> binds, Range bindsm, Range scopem);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PublishArguments(TcFileState cenv, TcEnv env, Val vspec, SynValSig synValSig, int numEnclosingTypars);
    internal static Tuple`2<FSharpList`1<Val>, UnscopedTyparEnv> TcAndPublishValSpec(TcFileState cenv, TcEnv env, ContainerInfo containerInfo, DeclKind declKind, FSharpOption`1<SynMemberFlags> memFlagsOpt, UnscopedTyparEnv tpenv, SynValSig synValSig);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckFormatStrings : object {
    internal static int lowestDefaultPriority { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType copyAndFixupFormatTypar(TcGlobals g, Range m, Typar tp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_lowestDefaultPriority();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFlexibleFormatTypar(TcGlobals g, Range m, FSharpList`1<TType> tys, TType dfltTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFlexibleIntFormatTypar(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFlexibleDecimalFormatTypar(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFlexibleFloatFormatTypar(TcGlobals g, Range m);
    internal static string escapeDotnetFormatString(IEnumerable`1<char> str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<int> |PrefixedBy|_|(string prefix, string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`3<int, string, Range>>, int> makeFmts(FormatStringCheckContext context, FSharpList`1<Range> fragRanges, string fmt);
    internal static FSharpList`1<TType> parseLoop@280(Range m, TcGlobals g, bool isInterpolated, bool isFormattableString, FSharpOption`1<FormatStringCheckContext> context, TType printerArgTy, TType printerResidueTy, int len, List`1<Tuple`2<Range, int>> specifierLocations, StringBuilder dotnetFormatString, List`1<TType> percentATys, FSharpRef`1<int> dotnetFormatStringInterpolationHoleCount, FSharpRef`1<string> fmt, FSharpRef`1<int> delimLen, FSharpList`1<Tuple`2<FSharpOption`1<int>, TType>> acc, int i, int fragLine, int fragCol, FSharpList`1<Tuple`3<int, int, Range>> fragments);
    internal static void checkOtherFlags@360(FormatInfoRegister info, a c);
    internal static int requireAndSkipInterpolationHoleFormat@371(int len, StringBuilder dotnetFormatString, FormatInfoRegister info, FSharpOption`1<int> widthValue, FSharpRef`1<int> dotnetFormatStringInterpolationHoleCount, FSharpRef`1<string> fmt, int i);
    internal static void collectSpecifierLocation@385(Range m, FSharpOption`1<FormatStringCheckContext> context, List`1<Tuple`2<Range, int>> specifierLocations, int fragCol, bool widthArg, bool precisionArg, int fragLine, int fragCol@385, int numStdArgs);
    internal static FSharpList`1<TType> parseSpecifier@312(Range m, TcGlobals g, bool isInterpolated, bool isFormattableString, FSharpOption`1<FormatStringCheckContext> context, TType printerArgTy, TType printerResidueTy, int len, List`1<Tuple`2<Range, int>> specifierLocations, StringBuilder dotnetFormatString, List`1<TType> percentATys, FSharpRef`1<int> dotnetFormatStringInterpolationHoleCount, FSharpRef`1<string> fmt, FSharpRef`1<int> delimLen, FSharpList`1<Tuple`2<FSharpOption`1<int>, TType>> acc, int i, int fragLine, int fragCol, FSharpList`1<Tuple`3<int, int, Range>> fragments);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<TType>, FSharpList`1<Tuple`2<Range, int>>, string, TType[]> parseFormatStringInternal(Range m, FSharpList`1<Range> fragRanges, TcGlobals g, bool isInterpolated, bool isFormattableString, FSharpOption`1<FormatStringCheckContext> context, string fmt, TType printerArgTy, TType printerResidueTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<TType>, TType, TType, TType[], FSharpList`1<Tuple`2<Range, int>>, string> ParseFormatString(Range m, FSharpList`1<Range> fragmentRanges, TcGlobals g, bool isInterpolated, bool isFormattableString, FSharpOption`1<FormatStringCheckContext> formatStringCheckContext, string fmt, TType printerArgTy, TType printerResidueTy, TType printerResultTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> TryCountFormatStringArguments(Range m, TcGlobals g, bool isInterpolated, string fmt, TType printerArgTy, TType printerResidueTy);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckIncrementalClasses : object {
    [CompilationMappingAttribute("9")]
internal static int TcClassRewriteStackGuardDepth { get; }
    internal static int get_TcClassRewriteStackGuardDepth();
    internal static StaticCtorInfo TcStaticImplicitCtorInfo_Phase2A(TcFileState cenv, TcEnv env, EntityRef tcref, Range m, FSharpList`1<Typar> copyOfTyconTypars);
    internal static IncrClassCtorInfo TcImplicitCtorInfo_Phase2A(TcFileState cenv, TcEnv env, UnscopedTyparEnv tpenv, EntityRef tcref, FSharpOption`1<SynAccess> vis, FSharpList`1<SynAttribute> attrs, FSharpList`1<SynSimplePat> spats, FSharpOption`1<Ident> thisIdOpt, FSharpOption`1<Val> baseValOpt, SafeInitData safeInitInfo, Range m, FSharpList`1<Typar> copyOfTyconTypars, TType objTy, TType thisTy, PreXmlDoc xmlDoc);
    internal static RecdField MakeIncrClassField(TcGlobals g, CompilationPath cpath, FSharpList`1<Tuple`2<Typar, TType>> formalTyparInst, Val v, bool isStatic, RecdFieldRef rfref);
    internal static void reportIfUnused@308(Val v, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static IncrClassValRepr repr$cont@340(StaticCtorInfo staticCtorInfo, bool isStatic, TcEnv env, FSharpOption`1<IncrClassCtorInfo> ctorInfoOpt, TcFileState cenv, TcGlobals g, Val v, EntityRef tcref, string nm, ValReprInfo arity, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Tuple`2<bool, FSharpFunc`2<Expr, Expr>>, FSharpList`1<Binding>> TransBind$cont@685(TcGlobals g, FSharpOption`1<Val> thisValOpt, Range m, FSharpList`1<Typar> freeChoiceTypars, DebugPointAtBinding spBind, Expr rhsExpr, bool isPriorToSuperInit, IncrClassValRepr matchValue, Unit unitVar);
    internal static FSharpFunc`2<Binding, Tuple`2<Tuple`2<bool, FSharpFunc`2<Expr, Expr>>, FSharpList`1<Binding>>> TransBind@669(SafeInitData safeStaticInitInfo, FSharpOption`1<Tuple`3<IncrClassCtorInfo, Expr, bool>> instanceInfo, TcFileState cenv, TcGlobals g, FSharpOption`1<Val> thisValOpt, Range m, FSharpList`1<Typar> freeChoiceTypars, FSharpList`1<TType> thisTyInst, IncrClassReprInfo reps);
    internal static Tuple`2<Tuple`3<FSharpList`1<Tuple`2<bool, FSharpFunc`2<Expr, Expr>>>, FSharpList`1<Tuple`2<bool, FSharpFunc`2<Expr, Expr>>>, FSharpList`1<Binding>>, IncrClassReprInfo> TransTrueDec@757(StaticCtorInfo staticCtorInfo, SafeInitData safeStaticInitInfo, FSharpOption`1<Tuple`3<IncrClassCtorInfo, Expr, bool>> instanceInfo, TcEnv env, TcFileState cenv, TcGlobals g, FSharpOption`1<Val> thisValOpt, FSharpOption`1<IncrClassCtorInfo> ctorInfoOpt, Range m, FSharpList`1<Typar> freeChoiceTypars, FSharpList`1<TType> thisTyInst, Set`2<Val, IComparer`1<Val>> staticForcedFieldVars, Set`2<Val, IComparer`1<Val>> instanceForcedFieldVars, bool isCtorArg, IncrClassReprInfo reps, IncrClassBindingGroup dec);
    internal static Tuple`4<FSharpOption`1<Expr>, FSharpOption`1<Expr>, FSharpList`1<Binding>, IncrClassReprInfo> MakeCtorForIncrClassConstructionPhase2C(TcFileState cenv, TcEnv env, StaticCtorInfo staticCtorInfo, FSharpOption`1<Tuple`3<IncrClassCtorInfo, Expr, bool>> instanceInfo, FSharpList`1<IncrClassConstructionBindingsPhase2C> decs, FSharpList`1<Binding> memberBinds, FSharpList`1<Typar> generalizedTyparsForRecursiveBlock, SafeInitData safeStaticInitInfo);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckPatterns : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pattern mkNilListPat(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Pattern mkConsListPat(TcGlobals g, TType ty, Pattern ph, Pattern pt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> UnifyRefTupleType(ContextInfo contextInfo, TcFileState cenv, DisplayEnv denv, Range m, TType ty, FSharpList`1<a> ps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Ident> TryAdjustHiddenVarNameToCompGenName(TcFileState cenv, TcEnv env, Ident id, FSharpOption`1<FSharpRef`1<SynSimplePatAlternativeIdInfo>> altNameRefCellOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, TcPatLinearEnv> TcSimplePat(bool optionalArgsOK, CheckConstraints checkConstraints, TcFileState cenv, TType ty, TcEnv env, TcPatLinearEnv patEnv, SynSimplePat p);
    internal static bool isOptArg@126(SynSimplePat pat);
    internal static void ValidateOptArgOrder(SynSimplePats synSimplePats);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<string>, TcPatLinearEnv> TcSimplePats(TcFileState cenv, bool optionalArgsOK, CheckConstraints checkConstraints, TType ty, TcEnv env, TcPatLinearEnv patEnv, SynSimplePats synSimplePats);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<string>, TcPatLinearEnv> TcSimplePatsOfUnknownType(TcFileState cenv, bool optionalArgsOK, CheckConstraints checkConstraints, TcEnv env, UnscopedTyparEnv tpenv, SynSimplePats synSimplePats);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpFunc`2<TcPatPhase2Input, PatternValBinding>, FSharpMap`2<string, PrelimVal1>, FSharpSet`1<string>> TcPatBindingName(TcFileState cenv, TcEnv env, Ident id, TType ty, bool isMemberThis, FSharpOption`1<SynAccess> vis1, FSharpOption`1<PrelimValReprInfo> valReprInfo, TcPatValFlags vFlags, FSharpMap`2<string, PrelimVal1> names, FSharpSet`1<string> takenNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatAndRecover(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, FSharpOption`1<PrelimValReprInfo> valReprInfo, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, SynPat synPat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPat(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, FSharpOption`1<PrelimValReprInfo> valReprInfo, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, SynPat synPat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcConstPat(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, SynConst synConst, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatNamedAs(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, FSharpOption`1<PrelimValReprInfo> valReprInfo, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, SynPat synInnerPat, Ident id, bool isMemberThis, FSharpOption`1<SynAccess> vis, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatUnnamedAs(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, SynPat pat1, SynPat pat2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatNamed(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, Ident id, TType ty, bool isMemberThis, FSharpOption`1<SynAccess> vis, FSharpOption`1<PrelimValReprInfo> valReprInfo, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatIsInstance(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, FSharpOption`1<PrelimValReprInfo> valReprInfo, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType srcTy, SynPat synPat, SynType synTargetTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatAttributed(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, SynPat innerPat, FSharpList`1<SynAttributeList> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatOr(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, SynPat pat1, SynPat pat2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatAnds(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, FSharpList`1<SynPat> pats, Range m);
    internal static FSharpFunc`2<a, Pattern> phase2@423(Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatTuple(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, bool isExplicitStruct, FSharpList`1<SynPat> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatArrayOrList(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, bool isArray, FSharpList`1<SynPat> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcRecordPat(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, FSharpList`1<Tuple`3<Tuple`2<FSharpList`1<Ident>, Ident>, FSharpOption`1<Range>, SynPat>> fieldPats, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcNullPat(TcFileState cenv, TcEnv env, TcPatLinearEnv patEnv, TType ty, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckNoArgsForLiteral(SynArgPats args, Range m);
    internal static FSharpList`1<SynPat> GetSynArgPatterns(SynArgPats args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpFunc`2<TcPatPhase2Input, Pattern>>, TcPatLinearEnv> TcArgPats(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, SynArgPats args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNameOf(TcFileState cenv, TcEnv env, AccessorDomain ad, Range m, Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatLongIdent(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, AccessorDomain ad, FSharpOption`1<PrelimValReprInfo> valReprInfo, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, SynLongIdent longDotId, FSharpOption`1<SynValTyparDecls> tyargs, SynArgPats args, FSharpOption`1<SynAccess> vis, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatLongIdentNewDef(WarnOnUpperFlag warnOnUpperForId, WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, AccessorDomain ad, FSharpOption`1<PrelimValReprInfo> valReprInfo, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, FSharpOption`1<SynAccess> vis, Ident id, SynArgPats args, Range m);
    [CompilerGeneratedAttribute]
internal static Tuple`3<FSharpFunc`2<Range, FSharpFunc`2<FSharpList`1<Pattern>, Pattern>>, FSharpList`1<TType>, FSharpList`1<RecdField>> ApplyUnionCaseOrExn$cont@570-1(Range m, TcFileState cenv, TcEnv env, TType overallTy, Item item, TcGlobals g, AccessorDomain ad, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpFunc`2<Range, FSharpFunc`2<FSharpList`1<Pattern>, Pattern>>, FSharpList`1<TType>, FSharpList`1<RecdField>> ApplyUnionCaseOrExn(Range m, TcFileState cenv, TcEnv env, TType overallTy, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatLongIdentUnionCaseOrExnCase(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, AccessorDomain ad, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, Range mLongId, Item item, SynArgPats args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatLongIdentILField(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, Range mLongId, ILFieldInfo finfo, SynArgPats args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatLongIdentRecdField(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, Range mLongId, RecdFieldInfo rfinfo, SynArgPats args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<TcPatPhase2Input, Pattern>, TcPatLinearEnv> TcPatLongIdentLiteral(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv patEnv, TType ty, Range mLongId, ValRef vref, SynArgPats args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpFunc`2<TcPatPhase2Input, Pattern>>, TcPatLinearEnv> TcPatterns(WarnOnUpperFlag warnOnUpper, TcFileState cenv, TcEnv env, TcPatValFlags vFlags, TcPatLinearEnv s, FSharpList`1<TType> argTys, FSharpList`1<SynPat> args);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CheckRecordSyntaxHelpers : object {
    internal static FSharpList`1<Tuple`2<a, FSharpOption`1<SynExpr>>> groupIfNested@30(FSharpList`1<Tuple`2<a, FSharpOption`1<SynExpr>>> res, FSharpList`1<Tuple`2<a, FSharpOption`1<SynExpr>>> xs);
    internal static FSharpList`1<Tuple`2<Tuple`2<FSharpList`1<Ident>, Ident>, FSharpOption`1<SynExpr>>> GroupUpdatesToNestedFields(FSharpList`1<Tuple`2<Tuple`2<FSharpList`1<Ident>, Ident>, FSharpOption`1<SynExpr>>> fields);
    internal static FSharpList`1<Ident> buildLid@63(FSharpList`1<Ident> res, Ident id, FSharpList`1<Ident> _arg1);
    internal static FSharpFunc`2<FSharpList`1<Tuple`2<Ident, Ident>>, FSharpList`1<Range>> calcLidSeparatorRanges@76(Range origSepRng);
    internal static Tuple`2<FSharpList`1<Ident>, FSharpList`1<Range>> upToId@62(Range origSepRng, Ident id, FSharpList`1<Ident> lidwd);
    internal static Range totalRange@88(Ident origId, Ident id);
    internal static Range rangeOfBlockSeperator@91(Ident id);
    internal static FSharpFunc`2<Ident, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<Range, FSharpOption`1<c>>>>> recdExprCopyInfo@61(FSharpList`1<Ident> ids, SynExpr withExpr0, Range sepRange, b withExpr2);
    internal static SynExpr synExprRecd@106(TcFileState cenv, TcEnv env, FSharpFunc`2<Ident, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<Range, FSharpOption`1<Position>>>>> copyInfo, Ident outerFieldId, FSharpList`1<Tuple`2<Ident, Item>> innerFields, SynExpr exprBeingAssigned);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<Ident>, Ident>, FSharpOption`1<SynExpr>> TransformAstForNestedUpdates(TcFileState cenv, TcEnv env, TType overallTy, FSharpList`1<Ident> lid, SynExpr exprBeingAssigned, SynExpr withExpr, Tuple`2<Range, a> withExpr_1);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.BackgroundCompiler : object {
    internal bool useSyntaxTreeCache;
    internal bool useChangeNotifications;
    internal FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot;
    internal bool suggestNamesForErrors;
    internal ParallelReferenceResolution parallelReferenceResolution;
    internal LegacyReferenceResolver legacyReferenceResolver;
    internal bool keepAssemblyContents;
    internal bool keepAllBackgroundSymbolUses;
    internal bool keepAllBackgroundResolutions;
    internal FSharpOption`1<FSharpFunc`2<string, FSharpAsync`1<FSharpOption`1<ISourceText>>>> getSource;
    internal bool enablePartialTypeChecking;
    internal bool enableBackgroundItemKeyStoreAndSemanticClassification;
    internal bool captureIdentifiersWhenParsing;
    internal FSharpRef`1<BackgroundCompiler> self;
    internal FSharpEvent`1<Tuple`2<string, FSharpProjectOptions>> beforeFileChecked;
    internal FSharpEvent`1<Tuple`2<string, FSharpProjectOptions>> fileParsed;
    internal FSharpEvent`1<Tuple`2<string, FSharpProjectOptions>> fileChecked;
    internal FSharpEvent`1<FSharpProjectOptions> projectChecked;
    internal MruCache`3<AnyCallerThreadToken, FSharpProjectOptions, LoadClosure> scriptClosureCache;
    internal FrameworkImportsCache frameworkTcImportsCache;
    internal DependencyProvider dependencyProviderForScripts;
    internal Lock`1<ParseCacheLockToken> parseCacheLock;
    internal MruCache`3<ParseCacheLockToken, Tuple`3<string, long, FSharpParsingOptions>, FSharpParseFileResults> parseFileCache;
    internal MruCache`3<ParseCacheLockToken, Tuple`3<string, long, FSharpProjectOptions>, GraphNode`1<Tuple`4<FSharpParseFileResults, FSharpCheckFileResults, long, DateTime>>> checkFileInProjectCache;
    internal object gate;
    internal MruCache`3<AnyCallerThreadToken, FSharpProjectOptions, GraphNode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>>> incrementalBuildersCache;
    internal static int actualParseFileCount;
    internal static int actualCheckFileCount;
    internal static int init@185-1;
    internal int init@185;
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> BeforeBackgroundFileCheck { get; }
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> FileParsed { get; }
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> FileChecked { get; }
    internal IEvent`2<FSharpHandler`1<FSharpProjectOptions>, FSharpProjectOptions> ProjectChecked { get; }
    internal FrameworkImportsCache FrameworkImportsCache { get; }
    internal static int ActualParseFileCount { get; }
    internal static int ActualCheckFileCount { get; }
    public BackgroundCompiler(LegacyReferenceResolver legacyReferenceResolver, int projectCacheSize, bool keepAssemblyContents, bool keepAllBackgroundResolutions, FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot, bool suggestNamesForErrors, bool keepAllBackgroundSymbolUses, bool enableBackgroundItemKeyStoreAndSemanticClassification, bool enablePartialTypeChecking, ParallelReferenceResolution parallelReferenceResolution, bool captureIdentifiersWhenParsing, FSharpOption`1<FSharpFunc`2<string, FSharpAsync`1<FSharpOption`1<ISourceText>>>> getSource, bool useChangeNotifications, bool useSyntaxTreeCache);
    private static BackgroundCompiler();
    internal FSharpAsync`1<FSharpParseFileResults> ParseFile(string fileName, ISourceText sourceText, FSharpParsingOptions options, bool cache, bool flatErrors, string userOpName);
    internal NodeCode`1<FSharpParseFileResults> GetBackgroundParseResultsForFileInProject(string fileName, FSharpProjectOptions options, string userOpName);
    internal NodeCode`1<FSharpOption`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileResults>>> GetCachedCheckFileResult(IncrementalBuilder builder, string fileName, ISourceText sourceText, FSharpProjectOptions options);
    internal NodeCode`1<Tuple`4<FSharpParseFileResults, FSharpCheckFileResults, long, DateTime>> CheckOneFileImplAux(FSharpParseFileResults parseResults, ISourceText sourceText, string fileName, FSharpProjectOptions options, IncrementalBuilder builder, PartialCheckResults tcPrior, TcInfo tcInfo, FSharpDiagnostic[] creationDiags);
    internal NodeCode`1<FSharpCheckFileAnswer> CheckOneFileImpl(FSharpParseFileResults parseResults, ISourceText sourceText, string fileName, FSharpProjectOptions options, int fileVersion, IncrementalBuilder builder, PartialCheckResults tcPrior, TcInfo tcInfo, FSharpDiagnostic[] creationDiags);
    internal NodeCode`1<FSharpOption`1<FSharpCheckFileAnswer>> CheckFileInProjectAllowingStaleCachedResults(FSharpParseFileResults parseResults, string fileName, int fileVersion, ISourceText sourceText, FSharpProjectOptions options, string userOpName);
    internal NodeCode`1<FSharpCheckFileAnswer> CheckFileInProject(FSharpParseFileResults parseResults, string fileName, int fileVersion, ISourceText sourceText, FSharpProjectOptions options, string userOpName);
    internal NodeCode`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileAnswer>> ParseAndCheckFileInProject(string fileName, int fileVersion, ISourceText sourceText, FSharpProjectOptions options, string userOpName);
    internal NodeCode`1<Unit> NotifyFileChanged(string fileName, FSharpProjectOptions options, string userOpName);
    internal NodeCode`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileResults>> GetBackgroundCheckResultsForFileInProject(string fileName, FSharpProjectOptions options, string userOpName);
    internal NodeCode`1<IEnumerable`1<Range>> FindReferencesInFile(string fileName, FSharpProjectOptions options, FSharpSymbol symbol, bool canInvalidateProject, string userOpName);
    internal NodeCode`1<FSharpOption`1<SemanticClassificationView>> GetSemanticClassificationForFile(string fileName, FSharpProjectOptions options, string userOpName);
    internal FSharpOption`1<Tuple`3<FSharpParseFileResults, FSharpCheckFileResults, long>> TryGetRecentCheckResultsForFile(string fileName, FSharpProjectOptions options, FSharpOption`1<ISourceText> sourceText, string _userOpName);
    internal NodeCode`1<FSharpCheckProjectResults> ParseAndCheckProjectImpl(FSharpProjectOptions options, string userOpName);
    internal NodeCode`1<ProjectAssemblyDataResult> GetAssemblyData(FSharpProjectOptions options, string userOpName);
    internal FSharpOption`1<DateTime> TryGetLogicalTimeStampForProject(TimeStampCache cache, FSharpProjectOptions options);
    internal NodeCode`1<FSharpCheckProjectResults> ParseAndCheckProject(FSharpProjectOptions options, string userOpName);
    internal FSharpAsync`1<Tuple`2<FSharpProjectOptions, FSharpList`1<FSharpDiagnostic>>> GetProjectOptionsFromScript(string fileName, ISourceText sourceText, FSharpOption`1<bool> previewEnabled, FSharpOption`1<DateTime> loadedTimeStamp, FSharpOption`1<String[]> otherFlags, FSharpOption`1<bool> useFsiAuxLib, FSharpOption`1<bool> useSdkRefs, FSharpOption`1<string> sdkDirOverride, FSharpOption`1<bool> assumeDotNetFramework, FSharpOption`1<long> optionsStamp, string _userOpName);
    internal void InvalidateConfiguration(FSharpProjectOptions options, string userOpName);
    internal void ClearCache(IEnumerable`1<FSharpProjectOptions> options, string _userOpName);
    internal FSharpAsync`1<Unit> NotifyProjectCleaned(FSharpProjectOptions options, string userOpName);
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> get_BeforeBackgroundFileCheck();
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> get_FileParsed();
    internal IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> get_FileChecked();
    internal IEvent`2<FSharpHandler`1<FSharpProjectOptions>, FSharpProjectOptions> get_ProjectChecked();
    internal void ClearCaches();
    internal void DownsizeCaches();
    internal FrameworkImportsCache get_FrameworkImportsCache();
    internal static int get_ActualParseFileCount();
    internal static int get_ActualCheckFileCount();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<IProjectReference> getProjectReferences(FSharpProjectOptions options, string userOpName);
    [CompilerGeneratedAttribute]
internal NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>> CreateOneIncrementalBuilder(FSharpProjectOptions options, string userOpName);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<GraphNode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>>> tryGetBuilderNode(FSharpProjectOptions options);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>>> tryGetBuilder(FSharpProjectOptions options);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>>> tryGetSimilarBuilder(FSharpProjectOptions options);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>>> tryGetAnyBuilder(FSharpProjectOptions options);
    [CompilerGeneratedAttribute]
internal GraphNode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>> createBuilderNode(FSharpProjectOptions options, string userOpName, CancellationToken ct);
    [CompilerGeneratedAttribute]
internal NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>> createAndGetBuilder(FSharpProjectOptions options, string userOpName);
    [CompilerGeneratedAttribute]
internal NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>> getOrCreateBuilder(FSharpProjectOptions options, string userOpName);
    [CompilerGeneratedAttribute]
internal NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>> getSimilarOrCreateBuilder(FSharpProjectOptions options, string userOpName);
    [CompilerGeneratedAttribute]
internal NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>> getOrCreateBuilderWithInvalidationFlag(FSharpProjectOptions options, bool canInvalidateProject, string userOpName);
    [CompilerGeneratedAttribute]
internal NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>> getAnyBuilder(FSharpProjectOptions options, string userOpName);
    [CompilerGeneratedAttribute]
internal GraphNode`1<Tuple`4<FSharpParseFileResults, FSharpCheckFileResults, long, DateTime>> getCheckFileNode(FSharpParseFileResults parseResults, a sourceText, string fileName, FSharpProjectOptions options, b _fileVersion, IncrementalBuilder builder, PartialCheckResults tcPrior, TcInfo tcInfo, FSharpDiagnostic[] creationDiags);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.BoundModel : object {
    internal TcImports tcImports;
    internal TcGlobals tcGlobals;
    internal TcConfig tcConfig;
    internal FSharpOption`1<SyntaxTree> syntaxTreeOpt;
    internal TcInfo prevTcInfo;
    internal bool keepAssemblyContents;
    internal bool keepAllBackgroundSymbolUses;
    internal bool keepAllBackgroundResolutions;
    internal FSharpEvent`1<string> fileChecked;
    internal bool enableBackgroundItemKeyStoreAndSemanticClassification;
    internal FSharpEvent`1<string> beforeFileChecked;
    internal GraphNode`1<Tuple`2[]> Diagnostics@;
    internal GraphNode`1<TcInfo> TcInfo@;
    internal GraphNode`1<TcInfoExtras> TcInfoExtras@;
    internal GraphNode`1<Tuple`2[]> Diagnostics { get; }
    internal GraphNode`1<TcInfo> TcInfo { get; }
    internal GraphNode`1<TcInfoExtras> TcInfoExtras { get; }
    internal TcConfig TcConfig { get; }
    internal TcGlobals TcGlobals { get; }
    internal TcImports TcImports { get; }
    internal FSharpFunc`2<Unit, NodeCode`1<TcInfo>> GetOrComputeTcInfo { get; }
    internal FSharpFunc`2<Unit, NodeCode`1<TcInfoExtras>> GetOrComputeTcInfoExtras { get; }
    public BoundModel(TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, bool keepAssemblyContents, bool keepAllBackgroundResolutions, bool keepAllBackgroundSymbolUses, bool enableBackgroundItemKeyStoreAndSemanticClassification, FSharpEvent`1<string> beforeFileChecked, FSharpEvent`1<string> fileChecked, TcInfo prevTcInfo, FSharpOption`1<SyntaxTree> syntaxTreeOpt, FSharpOption`1<Tuple`2<GraphNode`1<TcInfo>, GraphNode`1<TcInfoExtras>>> tcStateOpt);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal GraphNode`1<Tuple`2[]> get_Diagnostics();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal GraphNode`1<TcInfo> get_TcInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal GraphNode`1<TcInfoExtras> get_TcInfoExtras();
    internal TcConfig get_TcConfig();
    internal TcGlobals get_TcGlobals();
    internal TcImports get_TcImports();
    internal FSharpOption`1<TcInfo> TryPeekTcInfo();
    internal FSharpOption`1<Tuple`2<TcInfo, TcInfoExtras>> TryPeekTcInfoWithExtras();
    internal FSharpFunc`2<Unit, NodeCode`1<TcInfo>> get_GetOrComputeTcInfo();
    internal FSharpFunc`2<Unit, NodeCode`1<TcInfoExtras>> get_GetOrComputeTcInfoExtras();
    internal NodeCode`1<Tuple`2<TcInfo, TcInfoExtras>> GetOrComputeTcInfoWithExtras();
    internal NodeCode`1<BoundModel> Next(SyntaxTree syntaxTree);
    internal NodeCode`1<BoundModel> Finish(FSharpList`1<Tuple`2[]> finalTcDiagnosticsRev, FSharpOption`1<TopAttribs> finalTopAttribs);
    internal static BoundModel Create(TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, bool keepAssemblyContents, bool keepAllBackgroundResolutions, bool keepAllBackgroundSymbolUses, bool enableBackgroundItemKeyStoreAndSemanticClassification, FSharpEvent`1<string> beforeFileChecked, FSharpEvent`1<string> fileChecked, TcInfo prevTcInfo, FSharpOption`1<SyntaxTree> syntaxTreeOpt);
    [CompilerGeneratedAttribute]
internal NodeCode`1<Tuple`5<TcInfo, TcResultsSinkImpl, FSharpOption`1<CheckedImplFile>, string, Tuple`2[]>> getTypeCheck(SyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
internal GraphNode`1<TcInfo> getTcInfo(GraphNode`1<Tuple`5<TcInfo, TcResultsSinkImpl, FSharpOption`1<CheckedImplFile>, string, Tuple`2[]>> typeCheck);
    [CompilerGeneratedAttribute]
internal GraphNode`1<TcInfoExtras> getTcInfoExtras(GraphNode`1<Tuple`5<TcInfo, TcResultsSinkImpl, FSharpOption`1<CheckedImplFile>, string, Tuple`2[]>> typeCheck);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.CompileHelpers : object {
    internal static Tuple`3<List`1<FSharpDiagnostic>, DiagnosticsLogger, IDiagnosticsLoggerProvider> mkCompilationDiagnosticsHandlers(bool flatErrors);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int tryCompile(DiagnosticsLogger diagnosticsLogger, FSharpFunc`2<StopProcessingExiter, Unit> f);
    internal static Tuple`2<FSharpDiagnostic[], int> compileFromArgs(CompilationThreadToken ctok, String[] argv, LegacyReferenceResolver legacyReferenceResolver, FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<FSharpFunc`2<Tuple`4<TcConfig, TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.CodeAnalysis.CompletionContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_Invalid;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_RangeOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_AttributeApplication;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_PatternType;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static CompletionContext Invalid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInvalid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsRecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static CompletionContext RangeOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsRangeOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsParameterList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static CompletionContext AttributeApplication { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAttributeApplication { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOpenDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static CompletionContext PatternType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPatternType { get; }
    private static CompletionContext();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.CodeAnalysis.CompletionContext")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CompletionContext(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static CompletionContext get_Invalid();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInvalid();
    [CompilationMappingAttribute("8", "1")]
internal static CompletionContext NewInherit(InheritanceContext _context, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> _path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInherit();
    [CompilationMappingAttribute("8", "2")]
internal static CompletionContext NewRecordField(RecordContext _context);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsRecordField();
    [CompilationMappingAttribute("8", "3")]
internal static CompletionContext get_RangeOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsRangeOperator();
    [CompilationMappingAttribute("8", "4")]
internal static CompletionContext NewParameterList(Position item1, HashSet`1<string> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsParameterList();
    [CompilationMappingAttribute("8", "5")]
internal static CompletionContext get_AttributeApplication();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAttributeApplication();
    [CompilationMappingAttribute("8", "6")]
internal static CompletionContext NewOpenDeclaration(bool _isOpenType);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOpenDeclaration();
    [CompilationMappingAttribute("8", "7")]
internal static CompletionContext get_PatternType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPatternType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompletionContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.DebugKeyStore : object {
    [CompilationMappingAttribute("9")]
internal static _DebugKeyStoreNoop DebugKeyStoreNoop { get; }
    internal static _DebugKeyStoreNoop get_DebugKeyStoreNoop();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CodeAnalysis.DelayedILModuleReader : object {
    internal string name@;
    internal object gate@;
    internal FSharpFunc`2<CancellationToken, FSharpOption`1<Stream>> getStream;
    internal ILModuleReader result;
    [CompilationMappingAttribute("4", "0")]
internal string name { get; }
    [CompilationMappingAttribute("4", "1")]
internal object gate { get; }
    public string OutputFile { get; }
    public DelayedILModuleReader(string name, FSharpFunc`2<CancellationToken, FSharpOption`1<Stream>> getStream);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object get_gate();
    public string get_OutputFile();
    internal Cancellable`1<FSharpOption`1<ILModuleReader>> TryGetILModuleReader();
}
[ExperimentalAttribute("This type is experimental and likely to be removed in the future.")]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.CodeAnalysis.DocumentSource : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DocumentSource _unique_FileSystem;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DocumentSource FileSystem { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFileSystem { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCustom { get; }
    private static DocumentSource();
    [CompilationMappingAttribute("8", "0")]
public static DocumentSource get_FileSystem();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFileSystem();
    [CompilationMappingAttribute("8", "1")]
public static DocumentSource NewCustom(FSharpFunc`2<string, FSharpAsync`1<FSharpOption`1<ISourceText>>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCustom();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.EnvMisc : object {
    [CompilationMappingAttribute("9")]
internal static int braceMatchCacheSize { get; }
    [CompilationMappingAttribute("9")]
internal static int parseFileCacheSize { get; }
    [CompilationMappingAttribute("9")]
internal static int checkFileInProjectCacheSize { get; }
    [CompilationMappingAttribute("9")]
internal static int projectCacheSizeDefault { get; }
    [CompilationMappingAttribute("9")]
internal static int frameworkTcImportsCacheStrongSize { get; }
    internal static int get_braceMatchCacheSize();
    internal static int get_parseFileCacheSize();
    internal static int get_checkFileInProjectCacheSize();
    internal static int get_projectCacheSizeDefault();
    internal static int get_frameworkTcImportsCacheStrongSize();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.CodeAnalysis.ExprTypingsResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprTypingsResult _unique_NoneBecauseTypecheckIsStaleAndTextChanged;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprTypingsResult _unique_NoneBecauseThereWereTypeErrors;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ExprTypingsResult _unique_None;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprTypingsResult NoneBecauseTypecheckIsStaleAndTextChanged { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoneBecauseTypecheckIsStaleAndTextChanged { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprTypingsResult NoneBecauseThereWereTypeErrors { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNoneBecauseThereWereTypeErrors { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ExprTypingsResult None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSome { get; }
    private static ExprTypingsResult();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.CodeAnalysis.ExprTypingsResult")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ExprTypingsResult(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static ExprTypingsResult get_NoneBecauseTypecheckIsStaleAndTextChanged();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoneBecauseTypecheckIsStaleAndTextChanged();
    [CompilationMappingAttribute("8", "1")]
internal static ExprTypingsResult get_NoneBecauseThereWereTypeErrors();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNoneBecauseThereWereTypeErrors();
    [CompilationMappingAttribute("8", "2")]
internal static ExprTypingsResult get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNone();
    [CompilationMappingAttribute("8", "3")]
internal static ExprTypingsResult NewSome(Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, Range> item1, TType item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSome();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.FrameworkImportsCache : object {
    internal object gate;
    internal AgedLookup`3<AnyCallerThreadToken, FrameworkImportsCacheKey, GraphNode`1<Tuple`2<TcGlobals, TcImports>>> frameworkTcImportsCache;
    public FrameworkImportsCache(int size);
    internal void Downsize();
    internal void Clear();
    internal GraphNode`1<Tuple`2<TcGlobals, TcImports>> GetNode(TcConfig tcConfig, FSharpList`1<AssemblyResolution> frameworkDLLs, FSharpList`1<AssemblyResolution> nonFrameworkResolutions);
    internal NodeCode`1<Tuple`4<TcGlobals, TcImports, FSharpList`1<AssemblyResolution>, FSharpList`1<UnresolvedAssemblyReference>>> Get(TcConfig tcConfig);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.CodeAnalysis.FrameworkImportsCacheKey : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> _resolvedpath;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string _assemblyName;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> _targetFrameworkDirectories;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string _fsharpBinaries;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal decimal _langVersion;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> resolvedpath { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string assemblyName { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> targetFrameworkDirectories { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string fsharpBinaries { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal decimal langVersion { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.FrameworkImportsCacheKey")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FrameworkImportsCacheKey(FSharpList`1<string> _resolvedpath, string _assemblyName, FSharpList`1<string> _targetFrameworkDirectories, string _fsharpBinaries, decimal _langVersion);
    [CompilationMappingAttribute("8", "0")]
internal static FrameworkImportsCacheKey NewFrameworkImportsCacheKey(FSharpList`1<string> _resolvedpath, string _assemblyName, FSharpList`1<string> _targetFrameworkDirectories, string _fsharpBinaries, decimal _langVersion);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> get_resolvedpath();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_assemblyName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> get_targetFrameworkDirectories();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_fsharpBinaries();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal decimal get_langVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FrameworkImportsCacheKey obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FrameworkImportsCacheKey obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[AutoSerializableAttribute("False")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CodeAnalysis.FSharpChecker : object {
    internal FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot;
    internal bool suggestNamesForErrors;
    internal LegacyReferenceResolver legacyReferenceResolver;
    internal bool captureIdentifiersWhenParsing;
    internal BackgroundCompiler backgroundCompiler;
    internal static Lazy`1<FSharpChecker> globalInstance;
    internal MruCache`3<AnyCallerThreadToken, Tuple`3<string, long, FSharpParsingOptions>, Tuple`2[]> braceMatchCache;
    internal static int init@1308-2;
    internal LegacyReferenceResolver ReferenceResolver { get; }
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> BeforeBackgroundFileCheck { get; }
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> FileParsed { get; }
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> FileChecked { get; }
    public IEvent`2<FSharpHandler`1<FSharpProjectOptions>, FSharpProjectOptions> ProjectChecked { get; }
    public static int ActualParseFileCount { get; }
    public static int ActualCheckFileCount { get; }
    [ObsoleteAttribute("Please create an instance of FSharpChecker using FSharpChecker.Create")]
public static FSharpChecker Instance { get; }
    internal FrameworkImportsCache FrameworkImportsCache { get; }
    internal FSharpChecker(LegacyReferenceResolver legacyReferenceResolver, int projectCacheSize, bool keepAssemblyContents, bool keepAllBackgroundResolutions, FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot, bool suggestNamesForErrors, bool keepAllBackgroundSymbolUses, bool enableBackgroundItemKeyStoreAndSemanticClassification, bool enablePartialTypeChecking, ParallelReferenceResolution parallelReferenceResolution, bool captureIdentifiersWhenParsing, FSharpOption`1<FSharpFunc`2<string, FSharpAsync`1<FSharpOption`1<ISourceText>>>> getSource, bool useChangeNotifications, bool useSyntaxTreeCache);
    private static FSharpChecker();
    internal static FSharpOption`1<ParallelReferenceResolution> getParallelReferenceResolutionFromEnvironment();
    public static FSharpChecker Create(FSharpOption`1<int> projectCacheSize, FSharpOption`1<bool> keepAssemblyContents, FSharpOption`1<bool> keepAllBackgroundResolutions, FSharpOption`1<LegacyReferenceResolver> legacyReferenceResolver, FSharpOption`1<FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>>> tryGetMetadataSnapshot, FSharpOption`1<bool> suggestNamesForErrors, FSharpOption`1<bool> keepAllBackgroundSymbolUses, FSharpOption`1<bool> enableBackgroundItemKeyStoreAndSemanticClassification, FSharpOption`1<bool> enablePartialTypeChecking, FSharpOption`1<bool> parallelReferenceResolution, FSharpOption`1<bool> captureIdentifiersWhenParsing, FSharpOption`1<DocumentSource> documentSource, FSharpOption`1<bool> useSyntaxTreeCache);
    internal LegacyReferenceResolver get_ReferenceResolver();
    public FSharpAsync`1<Tuple`2[]> MatchBraces(string fileName, ISourceText sourceText, FSharpParsingOptions options, FSharpOption`1<string> userOpName);
    [ObsoleteAttribute("Please pass FSharpParsingOptions to MatchBraces. If necessary generate FSharpParsingOptions from FSharpProjectOptions by calling checker.GetParsingOptionsFromProjectOptions(options)")]
public FSharpAsync`1<Tuple`2[]> MatchBraces(string fileName, string source, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public Tuple`2<FSharpParsingOptions, FSharpList`1<FSharpDiagnostic>> GetParsingOptionsFromProjectOptions(FSharpProjectOptions options);
    public FSharpAsync`1<FSharpParseFileResults> ParseFile(string fileName, ISourceText sourceText, FSharpParsingOptions options, FSharpOption`1<bool> cache, FSharpOption`1<string> userOpName);
    [ObsoleteAttribute("Please call checker.ParseFile instead.  To do this, you must also pass FSharpParsingOptions instead of FSharpProjectOptions. If necessary generate FSharpParsingOptions from FSharpProjectOptions by calling checker.GetParsingOptionsFromProjectOptions(options)")]
public FSharpAsync`1<FSharpParseFileResults> ParseFileInProject(string fileName, string source, FSharpProjectOptions options, FSharpOption`1<bool> cache, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpParseFileResults> GetBackgroundParseResultsForFileInProject(string fileName, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileResults>> GetBackgroundCheckResultsForFileInProject(string fileName, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpOption`1<Tuple`3<FSharpParseFileResults, FSharpCheckFileResults, long>> TryGetRecentCheckResultsForFile(string fileName, FSharpProjectOptions options, FSharpOption`1<ISourceText> sourceText, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpDiagnostic[], int>> Compile(String[] argv, FSharpOption`1<string> userOpName);
    public void InvalidateAll();
    internal void ClearCaches();
    public void ClearLanguageServiceRootCachesAndCollectAndFinalizeAllTransients();
    public void InvalidateConfiguration(FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public void ClearCache(IEnumerable`1<FSharpProjectOptions> options, FSharpOption`1<string> userOpName);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release")]
public FSharpAsync`1<Unit> NotifyProjectCleaned(FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    [ExperimentalAttribute("This FCS API is experimental and likely to be removed in the future.")]
public FSharpAsync`1<Unit> NotifyFileChanged(string fileName, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    [ObsoleteAttribute("This member should no longer be used, please use 'CheckFileInProject'")]
public FSharpAsync`1<FSharpOption`1<FSharpCheckFileAnswer>> CheckFileInProjectAllowingStaleCachedResults(FSharpParseFileResults parseResults, string fileName, int fileVersion, string source, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpCheckFileAnswer> CheckFileInProject(FSharpParseFileResults parseResults, string fileName, int fileVersion, ISourceText sourceText, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpParseFileResults, FSharpCheckFileAnswer>> ParseAndCheckFileInProject(string fileName, int fileVersion, ISourceText sourceText, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpCheckProjectResults> ParseAndCheckProject(FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<IEnumerable`1<Range>> FindBackgroundReferencesInFile(string fileName, FSharpProjectOptions options, FSharpSymbol symbol, FSharpOption`1<bool> canInvalidateProject, FSharpOption`1<bool> fastCheck, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<FSharpOption`1<SemanticClassificationView>> GetBackgroundSemanticClassificationForFile(string fileName, FSharpProjectOptions options, FSharpOption`1<string> userOpName);
    public FSharpAsync`1<Tuple`2<FSharpProjectOptions, FSharpList`1<FSharpDiagnostic>>> GetProjectOptionsFromScript(string fileName, ISourceText source, FSharpOption`1<bool> previewEnabled, FSharpOption`1<DateTime> loadedTimeStamp, FSharpOption`1<String[]> otherFlags, FSharpOption`1<bool> useFsiAuxLib, FSharpOption`1<bool> useSdkRefs, FSharpOption`1<bool> assumeDotNetFramework, FSharpOption`1<string> sdkDirOverride, FSharpOption`1<long> optionsStamp, FSharpOption`1<string> userOpName);
    public FSharpProjectOptions GetProjectOptionsFromCommandLineArgs(string projectFileName, String[] argv, FSharpOption`1<DateTime> loadedTimeStamp, FSharpOption`1<bool> isInteractive, FSharpOption`1<bool> isEditing);
    public Tuple`2<FSharpParsingOptions, FSharpList`1<FSharpDiagnostic>> GetParsingOptionsFromCommandLineArgs(FSharpList`1<string> sourceFiles, FSharpList`1<string> argv, FSharpOption`1<bool> isInteractive, FSharpOption`1<bool> isEditing);
    public Tuple`2<FSharpParsingOptions, FSharpList`1<FSharpDiagnostic>> GetParsingOptionsFromCommandLineArgs(FSharpList`1<string> argv, FSharpOption`1<bool> isInteractive, FSharpOption`1<bool> isEditing);
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> get_BeforeBackgroundFileCheck();
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> get_FileParsed();
    public IEvent`2<FSharpHandler`1<Tuple`2<string, FSharpProjectOptions>>, Tuple`2<string, FSharpProjectOptions>> get_FileChecked();
    public IEvent`2<FSharpHandler`1<FSharpProjectOptions>, FSharpProjectOptions> get_ProjectChecked();
    public static int get_ActualParseFileCount();
    public static int get_ActualCheckFileCount();
    public static FSharpChecker get_Instance();
    internal FrameworkImportsCache get_FrameworkImportsCache();
    public Tuple`2<FSharpTokenInfo[], FSharpTokenizerLexState> TokenizeLine(string line, FSharpTokenizerLexState state);
    public FSharpTokenInfo[][] TokenizeFile(string source);
    [CompilerGeneratedAttribute]
internal static ParallelReferenceResolution inferParallelReferenceResolution(FSharpOption`1<bool> parallelReferenceResolution);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.FSharpCheckerResultsSettings : object {
    [CompilationMappingAttribute("9")]
internal static int getToolTipTextSize { get; }
    [CompilationMappingAttribute("9")]
internal static int maxTypeCheckErrorsOutOfProjectContext { get; }
    [CompilationMappingAttribute("9")]
internal static string defaultFSharpBinariesDir { get; }
    internal static int get_getToolTipTextSize();
    internal static int get_maxTypeCheckErrorsOutOfProjectContext();
    internal static string get_defaultFSharpBinariesDir();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.CodeAnalysis.FSharpCheckFileAnswer : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpCheckFileAnswer _unique_Aborted;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpCheckFileAnswer Aborted { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAborted { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSucceeded { get; }
    private static FSharpCheckFileAnswer();
    [CompilationMappingAttribute("8", "0")]
public static FSharpCheckFileAnswer get_Aborted();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAborted();
    [CompilationMappingAttribute("8", "1")]
public static FSharpCheckFileAnswer NewSucceeded(FSharpCheckFileResults item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSucceeded();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpCheckFileAnswer obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CodeAnalysis.FSharpCheckFileResults : object {
    internal FSharpOption`1<TypeCheckInfo> scopeOptX;
    internal bool keepAssemblyContents;
    internal string fileName;
    internal FSharpDiagnostic[] errors;
    internal String[] dependencyFiles;
    internal FSharpOption`1<Tuple`2<TypeCheckInfo, FSharpOption`1<IncrementalBuilder>>> details;
    internal static FindDeclResult emptyFindDeclResult;
    internal static int init@2976;
    public FSharpDiagnostic[] Diagnostics { get; }
    public bool HasFullTypeCheckInfo { get; }
    public FSharpAssemblySignature PartialAssemblySignature { get; }
    public FSharpProjectContext ProjectContext { get; }
    public String[] DependencyFiles { get; }
    public FSharpOption`1<FSharpImplementationFileContents> ImplementationFile { get; }
    public FSharpOpenDeclaration[] OpenDeclarations { get; }
    internal FSharpCheckFileResults(string fileName, FSharpDiagnostic[] errors, FSharpOption`1<TypeCheckInfo> scopeOptX, String[] dependencyFiles, FSharpOption`1<IncrementalBuilder> builderX, bool keepAssemblyContents);
    private static FSharpCheckFileResults();
    public FSharpDiagnostic[] get_Diagnostics();
    public bool get_HasFullTypeCheckInfo();
    internal FSharpOption`1<TcImports> TryGetCurrentTcImports();
    public DeclarationListInfo GetDeclarationListInfo(FSharpOption`1<FSharpParseFileResults> parsedFileResults, int line, string lineText, PartialLongName partialName, FSharpOption`1<FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>>> getAllEntities, FSharpOption`1<Tuple`2<Position, FSharpOption`1<CompletionContext>>> completionContextAtPos);
    public FSharpList`1<FSharpList`1<FSharpSymbolUse>> GetDeclarationListSymbols(FSharpOption`1<FSharpParseFileResults> parsedFileResults, int line, string lineText, PartialLongName partialName, FSharpOption`1<FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>>> getAllEntities);
    public ToolTipText GetKeywordTooltip(FSharpList`1<string> names);
    public ToolTipText GetToolTip(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names, int tokenTag, FSharpOption`1<int> width);
    public ToolTipText GetDescription(FSharpSymbol symbol, FSharpList`1<Tuple`2<FSharpGenericParameter, FSharpType>> inst, bool displayFullName, Range range);
    public FSharpOption`1<string> GetF1Keyword(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names);
    public MethodGroup GetMethods(int line, int colAtEndOfNames, string lineText, FSharpOption`1<FSharpList`1<string>> names);
    public FindDeclResult GetDeclarationLocation(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names, FSharpOption`1<bool> preferFlag);
    public FSharpOption`1<FSharpSymbolUse> GetSymbolUseAtLocation(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names);
    public FSharpList`1<FSharpSymbolUse> GetSymbolUsesAtLocation(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names);
    public FSharpOption`1<FSharpList`1<FSharpSymbolUse>> GetMethodsAsSymbols(int line, int colAtEndOfNames, string lineText, FSharpList`1<string> names);
    internal FSharpOption`1<FSharpSymbol> GetSymbolAtLocation(int line, int colAtEndOfNames, string lineStr, FSharpList`1<string> names);
    [ObsoleteAttribute("This member has been replaced by GetFormatSpecifierLocationsAndArity, which returns both range and arity of specifiers")]
public Range[] GetFormatSpecifierLocations();
    public Tuple`2[] GetFormatSpecifierLocationsAndArity();
    public SemanticClassificationItem[] GetSemanticClassification(FSharpOption`1<Range> range);
    public FSharpAssemblySignature get_PartialAssemblySignature();
    public FSharpProjectContext get_ProjectContext();
    public String[] get_DependencyFiles();
    public IEnumerable`1<FSharpSymbolUse> GetAllUsesOfAllSymbolsInFile(FSharpOption`1<CancellationToken> cancellationToken);
    public FSharpSymbolUse[] GetUsesOfSymbolInFile(FSharpSymbol symbol, FSharpOption`1<CancellationToken> cancellationToken);
    internal EntityRef[] GetVisibleNamespacesAndModulesAtPoint(Position pos);
    internal bool IsRelativeNameResolvable(Position cursorPos, FSharpList`1<string> plid, Item item);
    public bool IsRelativeNameResolvableFromSymbol(Position cursorPos, FSharpList`1<string> plid, FSharpSymbol symbol);
    public FSharpOption`1<FSharpDisplayContext> GetDisplayContextForPos(Position cursorPos);
    public FSharpOption`1<ISourceText> GenerateSignature(FSharpOption`1<int> pageWidth);
    internal FSharpOption`1<int> CalculateSignatureHash();
    public FSharpOption`1<FSharpImplementationFileContents> get_ImplementationFile();
    public FSharpOpenDeclaration[] get_OpenDeclarations();
    public virtual string ToString();
    internal static FSharpCheckFileResults MakeEmpty(string fileName, FSharpDiagnostic[] creationErrors, bool keepAssemblyContents);
    internal static FSharpDiagnostic[] JoinErrors(bool isIncompleteTypeCheckEnvironment, FSharpDiagnostic[] creationErrors, FSharpDiagnostic[] parseErrors, FSharpDiagnostic[] tcErrors);
    internal static FSharpCheckFileResults Make(string mainInputFileName, string projectFileName, TcConfig tcConfig, TcGlobals tcGlobals, bool isIncompleteTypeCheckEnvironment, IncrementalBuilder builder, FSharpProjectOptions projectOptions, String[] dependencyFiles, FSharpDiagnostic[] creationErrors, FSharpDiagnostic[] parseErrors, FSharpDiagnostic[] tcErrors, bool keepAssemblyContents, ModuleOrNamespaceType ccuSigForFile, CcuThunk thisCcu, TcImports tcImports, AccessorDomain tcAccessRights, TcResolutions sResolutions, TcSymbolUses sSymbolUses, NameResolutionEnv sFallback, FSharpOption`1<LoadClosure> loadClosure, FSharpOption`1<CheckedImplFile> implFileOpt, OpenDeclaration[] openDeclarations);
    internal static Cancellable`1<FSharpCheckFileResults> CheckOneFile(FSharpParseFileResults parseResults, ISourceText sourceText, string mainInputFileName, string projectFileName, TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, TcState tcState, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, FSharpOption`1<LoadClosure> loadClosure, Tuple`2[] backgroundDiagnostics, bool isIncompleteTypeCheckEnvironment, FSharpProjectOptions projectOptions, IncrementalBuilder builder, String[] dependencyFiles, FSharpDiagnostic[] creationErrors, FSharpDiagnostic[] parseErrors, bool keepAssemblyContents, bool suggestNamesForErrors);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CodeAnalysis.FSharpCheckProjectResults : object {
    internal FSharpOption`1<TcConfig> tcConfigOption;
    internal string projectFileName;
    internal bool keepAssemblyContents;
    internal FSharpDiagnostic[] diagnostics;
    internal FSharpOption`1<Tuple`8<TcGlobals, TcImports, CcuThunk, ModuleOrNamespaceType, FSharpChoice`2<IncrementalBuilder, TcSymbolUses>, FSharpOption`1<TopAttribs>, FSharpFunc`2<Unit, FSharpOption`1<IRawFSharpAssemblyData>>, Tuple`5<ILAssemblyRef, AccessorDomain, FSharpOption`1<FSharpList`1<CheckedImplFile>>, String[], FSharpProjectOptions>>> details;
    public FSharpDiagnostic[] Diagnostics { get; }
    public bool HasCriticalErrors { get; }
    public FSharpAssemblySignature AssemblySignature { get; }
    internal Tuple`4<TcGlobals, CcuThunk, TcImports, FSharpList`1<CheckedImplFile>> TypedImplementationFiles { get; }
    public FSharpAssemblyContents AssemblyContents { get; }
    public FSharpProjectContext ProjectContext { get; }
    public String[] DependencyFiles { get; }
    internal string AssemblyFullName { get; }
    internal FSharpCheckProjectResults(string projectFileName, FSharpOption`1<TcConfig> tcConfigOption, bool keepAssemblyContents, FSharpDiagnostic[] diagnostics, FSharpOption`1<Tuple`8<TcGlobals, TcImports, CcuThunk, ModuleOrNamespaceType, FSharpChoice`2<IncrementalBuilder, TcSymbolUses>, FSharpOption`1<TopAttribs>, FSharpFunc`2<Unit, FSharpOption`1<IRawFSharpAssemblyData>>, Tuple`5<ILAssemblyRef, AccessorDomain, FSharpOption`1<FSharpList`1<CheckedImplFile>>, String[], FSharpProjectOptions>>> details);
    public FSharpDiagnostic[] get_Diagnostics();
    public bool get_HasCriticalErrors();
    public FSharpAssemblySignature get_AssemblySignature();
    internal Tuple`4<TcGlobals, CcuThunk, TcImports, FSharpList`1<CheckedImplFile>> get_TypedImplementationFiles();
    public FSharpAssemblyContents get_AssemblyContents();
    public FSharpAssemblyContents GetOptimizedAssemblyContents();
    public FSharpSymbolUse[] GetUsesOfSymbol(FSharpSymbol symbol, FSharpOption`1<CancellationToken> cancellationToken);
    public FSharpSymbolUse[] GetAllUsesOfAllSymbols(FSharpOption`1<CancellationToken> cancellationToken);
    public FSharpProjectContext get_ProjectContext();
    public String[] get_DependencyFiles();
    internal string get_AssemblyFullName();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal Tuple`8<TcGlobals, TcImports, CcuThunk, ModuleOrNamespaceType, FSharpChoice`2<IncrementalBuilder, TcSymbolUses>, FSharpOption`1<TopAttribs>, FSharpFunc`2<Unit, FSharpOption`1<IRawFSharpAssemblyData>>, Tuple`5<ILAssemblyRef, AccessorDomain, FSharpOption`1<FSharpList`1<CheckedImplFile>>, String[], FSharpProjectOptions>> getDetails();
    [CompilerGeneratedAttribute]
internal TcConfig getTcConfig();
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.FSharpFile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range Range@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSource Source@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Tuple`2<bool, bool> Flags@;
    [CompilationMappingAttribute("4", "0")]
internal Range Range { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpSource Source { get; }
    [CompilationMappingAttribute("4", "2")]
internal Tuple`2<bool, bool> Flags { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.FSharpFile")]
internal FSharpFile(Range range, FSharpSource source, Tuple`2<bool, bool> flags);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range get_Range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpSource get_Source();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Tuple`2<bool, bool> get_Flags();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpFile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.CodeAnalysis.FSharpInheritanceOrigin : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInheritanceOrigin _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInheritanceOrigin _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInheritanceOrigin _unique_Unknown;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static FSharpInheritanceOrigin Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static FSharpInheritanceOrigin Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static FSharpInheritanceOrigin Unknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnknown { get; }
    private static FSharpInheritanceOrigin();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.CodeAnalysis.FSharpInheritanceOrigin")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpInheritanceOrigin(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static FSharpInheritanceOrigin get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsClass();
    [CompilationMappingAttribute("8", "1")]
internal static FSharpInheritanceOrigin get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInterface();
    [CompilationMappingAttribute("8", "2")]
internal static FSharpInheritanceOrigin get_Unknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpInheritanceOrigin obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpInheritanceOrigin obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CodeAnalysis.FSharpParseFileResults : object {
    internal bool parseHadErrors;
    internal ParsedInput input;
    internal FSharpDiagnostic[] diagnostics;
    internal String[] dependencyFiles;
    public FSharpDiagnostic[] Diagnostics { get; }
    public bool ParseHadErrors { get; }
    public ParsedInput ParseTree { get; }
    public String[] DependencyFiles { get; }
    public string FileName { get; }
    internal FSharpParseFileResults(FSharpDiagnostic[] diagnostics, ParsedInput input, bool parseHadErrors, String[] dependencyFiles);
    public FSharpDiagnostic[] get_Diagnostics();
    public bool get_ParseHadErrors();
    public ParsedInput get_ParseTree();
    public FSharpOption`1<Range> TryRangeOfNameOfNearestOuterBindingContainingPos(Position pos);
    public FSharpOption`1<Tuple`2<Ident, int>> TryIdentOfPipelineContainingPosAndNumArgsApplied(Position pos);
    public bool IsPosContainedInApplication(Position pos);
    public bool IsTypeName(Range range);
    public FSharpOption`1<Range> TryRangeOfFunctionOrMethodBeingApplied(Position pos);
    public FSharpOption`1<FSharpList`1<Range>> GetAllArgumentsForFunctionApplicationAtPosition(Position pos);
    public FSharpOption`1<Tuple`3<Range, Range, Range>> TryRangeOfParenEnclosingOpEqualsGreaterUsage(Position opGreaterEqualPos);
    public FSharpOption`1<Range> TryRangeOfStringInterpolationContainingPos(Position pos);
    public FSharpOption`1<Range> TryRangeOfExprInYieldOrReturn(Position pos);
    public FSharpOption`1<Range> TryRangeOfRecordExpressionContainingPos(Position pos);
    public FSharpOption`1<Range> TryRangeOfRefCellDereferenceContainingPos(Position expressionPos);
    public FSharpOption`1<Range> TryRangeOfExpressionBeingDereferencedContainingPos(Position expressionPos);
    public FSharpOption`1<Range> TryRangeOfReturnTypeHint(Position symbolUseStart, FSharpOption`1<bool> skipLambdas);
    public FSharpOption`1<ParameterLocations> FindParameterLocations(Position pos);
    public bool IsPositionContainedInACurriedParameter(Position pos);
    public bool IsTypeAnnotationGivenAtPosition(Position pos);
    public bool IsPositionWithinTypeDefinition(Position pos);
    public bool IsBindingALambdaAtPosition(Position pos);
    public bool IsPositionWithinRecordDefinition(Position pos);
    internal NavigationItems GetNavigationItemsImpl();
    internal FSharpOption`1<Range> ValidateBreakpointLocationImpl(Position pos);
    public String[] get_DependencyFiles();
    public string get_FileName();
    public NavigationItems GetNavigationItems();
    public FSharpOption`1<Range> ValidateBreakpointLocation(Position pos);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.CodeAnalysis.FSharpParsingOptions : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] SourceFiles@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool ApplyLineDirectives@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> ConditionalDefines@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpDiagnosticOptions DiagnosticOptions@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string LangVersionText@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInteractive@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> IndentationAwareSyntax@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<bool> StrictIndentation@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool CompilingFSharpCore@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsExe@;
    [CompilationMappingAttribute("4", "0")]
public String[] SourceFiles { get; }
    [CompilationMappingAttribute("4", "1")]
public bool ApplyLineDirectives { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<string> ConditionalDefines { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpDiagnosticOptions DiagnosticOptions { get; }
    [CompilationMappingAttribute("4", "4")]
public string LangVersionText { get; }
    [CompilationMappingAttribute("4", "5")]
public bool IsInteractive { get; }
    [CompilationMappingAttribute("4", "6")]
public FSharpOption`1<bool> IndentationAwareSyntax { get; }
    [CompilationMappingAttribute("4", "7")]
public FSharpOption`1<bool> StrictIndentation { get; }
    [CompilationMappingAttribute("4", "8")]
public bool CompilingFSharpCore { get; }
    [CompilationMappingAttribute("4", "9")]
public bool IsExe { get; }
    internal string LastFileName { get; }
    public static FSharpParsingOptions Default { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.FSharpParsingOptions")]
public FSharpParsingOptions(String[] sourceFiles, bool applyLineDirectives, FSharpList`1<string> conditionalDefines, FSharpDiagnosticOptions diagnosticOptions, string langVersionText, bool isInteractive, FSharpOption`1<bool> indentationAwareSyntax, FSharpOption`1<bool> strictIndentation, bool compilingFSharpCore, bool isExe);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public String[] get_SourceFiles();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_ApplyLineDirectives();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_ConditionalDefines();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpDiagnosticOptions get_DiagnosticOptions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_LangVersionText();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInteractive();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<bool> get_IndentationAwareSyntax();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<bool> get_StrictIndentation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_CompilingFSharpCore();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExe();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpParsingOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal string get_LastFileName();
    public static FSharpParsingOptions get_Default();
    internal static FSharpParsingOptions FromTcConfig(TcConfig tcConfig, String[] sourceFiles, bool isInteractive);
    internal static FSharpParsingOptions FromTcConfigBuilder(TcConfigBuilder tcConfigB, String[] sourceFiles, bool isInteractive);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpParsingOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CodeAnalysis.FSharpProjectContext : object {
    internal CcuThunk thisCcu;
    internal FSharpProjectOptions projectOptions;
    internal FSharpList`1<FSharpAssembly> assemblies;
    internal AccessorDomain ad;
    public FSharpProjectOptions ProjectOptions { get; }
    public FSharpAccessibilityRights AccessibilityRights { get; }
    internal FSharpProjectContext(CcuThunk thisCcu, FSharpList`1<FSharpAssembly> assemblies, AccessorDomain ad, FSharpProjectOptions projectOptions);
    public FSharpProjectOptions get_ProjectOptions();
    public FSharpList`1<FSharpAssembly> GetReferencedAssemblies();
    public FSharpAccessibilityRights get_AccessibilityRights();
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.CodeAnalysis.FSharpProjectOptions : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string ProjectFileName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ProjectId@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] SourceFiles@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] OtherOptions@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpReferencedProject[] ReferencedProjects@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsIncompleteTypeCheckEnvironment@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool UseScriptResolutionRules@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal DateTime LoadTime@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpUnresolvedReferencesSet> UnresolvedReferences@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`3<Range, string, string>> OriginalLoadReferences@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<long> Stamp@;
    [CompilationMappingAttribute("4", "0")]
public string ProjectFileName { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<string> ProjectId { get; }
    [CompilationMappingAttribute("4", "2")]
public String[] SourceFiles { get; }
    [CompilationMappingAttribute("4", "3")]
public String[] OtherOptions { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpReferencedProject[] ReferencedProjects { get; }
    [CompilationMappingAttribute("4", "5")]
public bool IsIncompleteTypeCheckEnvironment { get; }
    [CompilationMappingAttribute("4", "6")]
public bool UseScriptResolutionRules { get; }
    [CompilationMappingAttribute("4", "7")]
public DateTime LoadTime { get; }
    [CompilationMappingAttribute("4", "8")]
public FSharpOption`1<FSharpUnresolvedReferencesSet> UnresolvedReferences { get; }
    [CompilationMappingAttribute("4", "9")]
public FSharpList`1<Tuple`3<Range, string, string>> OriginalLoadReferences { get; }
    [CompilationMappingAttribute("4", "10")]
public FSharpOption`1<long> Stamp { get; }
    internal string ProjectDirectory { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.FSharpProjectOptions")]
public FSharpProjectOptions(string projectFileName, FSharpOption`1<string> projectId, String[] sourceFiles, String[] otherOptions, FSharpReferencedProject[] referencedProjects, bool isIncompleteTypeCheckEnvironment, bool useScriptResolutionRules, DateTime loadTime, FSharpOption`1<FSharpUnresolvedReferencesSet> unresolvedReferences, FSharpList`1<Tuple`3<Range, string, string>> originalLoadReferences, FSharpOption`1<long> stamp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_ProjectFileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_ProjectId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public String[] get_SourceFiles();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public String[] get_OtherOptions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpReferencedProject[] get_ReferencedProjects();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIncompleteTypeCheckEnvironment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_UseScriptResolutionRules();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DateTime get_LoadTime();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<FSharpUnresolvedReferencesSet> get_UnresolvedReferences();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Tuple`3<Range, string, string>> get_OriginalLoadReferences();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<long> get_Stamp();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal static bool UseSameProject(FSharpProjectOptions options1, FSharpProjectOptions options2);
    internal static bool AreSameForChecking(FSharpProjectOptions options1, FSharpProjectOptions options2);
    internal string get_ProjectDirectory();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpProjectOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoComparisonAttribute]
[CustomEqualityAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.CodeAnalysis.FSharpReferencedProject : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFSharpReference { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPEReference { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsILModuleReference { get; }
    public string OutputFile { get; }
    [CompilationMappingAttribute("8", "0")]
public static FSharpReferencedProject NewFSharpReference(string _projectOutputFile, FSharpProjectOptions _options);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFSharpReference();
    [CompilationMappingAttribute("8", "1")]
public static FSharpReferencedProject NewPEReference(FSharpFunc`2<Unit, DateTime> _getStamp, DelayedILModuleReader _delayedReader);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPEReference();
    [CompilationMappingAttribute("8", "2")]
public static FSharpReferencedProject NewILModuleReference(string _projectOutputFile, FSharpFunc`2<Unit, DateTime> _getStamp, FSharpFunc`2<Unit, ILModuleReader> _getReader);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsILModuleReference();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public string get_OutputFile();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[AbstractClassAttribute]
[CompilationMappingAttribute("3")]
internal abstract class FSharp.Compiler.CodeAnalysis.FSharpSource : object {
    public string FilePath { get; }
    public DateTime TimeStamp { get; }
    public abstract virtual string get_FilePath();
    public abstract virtual DateTime get_TimeStamp();
    public abstract virtual FSharpAsync`1<TextContainer> GetTextContainer();
    internal static FSharpSource Create(string filePath, FSharpFunc`2<Unit, DateTime> getTimeStamp, FSharpFunc`2<Unit, FSharpAsync`1<FSharpOption`1<ISourceText>>> getSourceText);
    internal static FSharpSource CreateFromFile(string filePath);
    internal static FSharpSource CreateCopyFromFile(string filePath);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.FSharpSourceByteArray : FSharpSource {
    internal DateTime timeStamp;
    internal string filePath;
    internal Byte[] bytes;
    public string FilePath { get; }
    public DateTime TimeStamp { get; }
    public FSharpSourceByteArray(string filePath, DateTime timeStamp, Byte[] bytes);
    public virtual string get_FilePath();
    public virtual DateTime get_TimeStamp();
    public virtual FSharpAsync`1<TextContainer> GetTextContainer();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.FSharpSourceCustom : FSharpSource {
    internal FSharpFunc`2<Unit, DateTime> getTimeStamp;
    internal FSharpFunc`2<Unit, FSharpAsync`1<FSharpOption`1<ISourceText>>> getSourceText;
    internal string filePath;
    public string FilePath { get; }
    public DateTime TimeStamp { get; }
    public FSharpSourceCustom(string filePath, FSharpFunc`2<Unit, DateTime> getTimeStamp, FSharpFunc`2<Unit, FSharpAsync`1<FSharpOption`1<ISourceText>>> getSourceText);
    public virtual string get_FilePath();
    public virtual DateTime get_TimeStamp();
    public virtual FSharpAsync`1<TextContainer> GetTextContainer();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.FSharpSourceFromFile : FSharpSource {
    internal string filePath;
    public string FilePath { get; }
    public DateTime TimeStamp { get; }
    public FSharpSourceFromFile(string filePath);
    public virtual string get_FilePath();
    public virtual DateTime get_TimeStamp();
    public virtual FSharpAsync`1<TextContainer> GetTextContainer();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.FSharpSourceMemoryMappedFile : FSharpSource {
    internal DateTime timeStamp;
    internal FSharpFunc`2<Unit, Stream> openStream;
    internal string filePath;
    public string FilePath { get; }
    public DateTime TimeStamp { get; }
    public FSharpSourceMemoryMappedFile(string filePath, DateTime timeStamp, FSharpFunc`2<Unit, Stream> openStream);
    public virtual string get_FilePath();
    public virtual DateTime get_TimeStamp();
    public virtual FSharpAsync`1<TextContainer> GetTextContainer();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CodeAnalysis.FSharpSymbolUse : object {
    internal FSharpSymbol symbol;
    internal Range range;
    internal ItemOccurence itemOcc;
    internal FSharpList`1<Tuple`2<Typar, TType>> inst;
    internal DisplayEnv denv;
    public FSharpSymbol Symbol { get; }
    public FSharpList`1<Tuple`2<FSharpGenericParameter, FSharpType>> GenericArguments { get; }
    public FSharpDisplayContext DisplayContext { get; }
    internal bool IsDefinition { get; }
    public bool IsFromDefinition { get; }
    public bool IsFromPattern { get; }
    public bool IsFromType { get; }
    public bool IsFromAttribute { get; }
    public bool IsFromDispatchSlotImplementation { get; }
    public bool IsFromUse { get; }
    public bool IsFromComputationExpression { get; }
    public bool IsFromOpenStatement { get; }
    public string FileName { get; }
    public Range Range { get; }
    public bool IsPrivateToFileAndSignatureFile { get; }
    public bool IsPrivateToFile { get; }
    internal FSharpSymbolUse(DisplayEnv denv, FSharpSymbol symbol, FSharpList`1<Tuple`2<Typar, TType>> inst, ItemOccurence itemOcc, Range range);
    public FSharpSymbol get_Symbol();
    public FSharpList`1<Tuple`2<FSharpGenericParameter, FSharpType>> get_GenericArguments();
    public FSharpDisplayContext get_DisplayContext();
    internal bool get_IsDefinition();
    public bool get_IsFromDefinition();
    public bool get_IsFromPattern();
    public bool get_IsFromType();
    public bool get_IsFromAttribute();
    public bool get_IsFromDispatchSlotImplementation();
    public bool get_IsFromUse();
    public bool get_IsFromComputationExpression();
    public bool get_IsFromOpenStatement();
    public string get_FileName();
    public Range get_Range();
    public bool get_IsPrivateToFileAndSignatureFile();
    public bool get_IsPrivateToFile();
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
public class FSharp.Compiler.CodeAnalysis.FSharpUnresolvedReferencesSet : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<UnresolvedAssemblyReference> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<UnresolvedAssemblyReference> Item { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.FSharpUnresolvedReferencesSet")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpUnresolvedReferencesSet(FSharpList`1<UnresolvedAssemblyReference> item);
    [CompilationMappingAttribute("8", "0")]
internal static FSharpUnresolvedReferencesSet NewFSharpUnresolvedReferencesSet(FSharpList`1<UnresolvedAssemblyReference> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<UnresolvedAssemblyReference> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpUnresolvedReferencesSet obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.FsiInteractiveChecker : object {
    internal TcState tcState;
    internal TcImports tcImports;
    internal TcGlobals tcGlobals;
    internal TcConfig tcConfig;
    internal LegacyReferenceResolver legacyReferenceResolver;
    internal bool keepAssemblyContents;
    public FsiInteractiveChecker(LegacyReferenceResolver legacyReferenceResolver, TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, TcState tcState);
    internal Cancellable`1<Tuple`3<FSharpParseFileResults, FSharpCheckFileResults, FSharpCheckProjectResults>> ParseAndCheckInteraction(ISourceText sourceText, FSharpOption`1<string> userOpName);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.Helpers : object {
    internal static bool AreSameForParsing(Tuple`3<string, long, a> _arg1, Tuple`3<string, long, a> _arg2);
    internal static bool AreSimilarForParsing(Tuple`3<a, b, c> _arg1, Tuple`3<a, d, e> _arg2);
    internal static bool AreSameForChecking3(Tuple`3<string, long, FSharpProjectOptions> _arg1, Tuple`3<string, long, FSharpProjectOptions> _arg2);
    internal static bool AreSubsumable3(Tuple`3<string, a, FSharpProjectOptions> _arg1, Tuple`3<string, b, FSharpProjectOptions> _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool NamesContainAttribute(FSharpSymbol symbol, FSharpSet`1<string> names);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.Hosted.CompilationIssue : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Location Location@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Subcategory@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Code@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string File@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Text@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal CompilationIssueType Type@;
    [CompilationMappingAttribute("4", "0")]
internal Location Location { get; }
    [CompilationMappingAttribute("4", "1")]
internal string Subcategory { get; }
    [CompilationMappingAttribute("4", "2")]
internal string Code { get; }
    [CompilationMappingAttribute("4", "3")]
internal string File { get; }
    [CompilationMappingAttribute("4", "4")]
internal string Text { get; }
    [CompilationMappingAttribute("4", "5")]
internal CompilationIssueType Type { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.Hosted.CompilationIssue")]
internal CompilationIssue(Location location, string subcategory, string code, string file, string text, CompilationIssueType type);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Location get_Location();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_Subcategory();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_Code();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_File();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_Text();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CompilationIssueType get_Type();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CompilationIssue obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompilationIssue obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.CodeAnalysis.Hosted.CompilationIssueType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompilationIssueType _unique_Warning;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompilationIssueType _unique_Error;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static CompilationIssueType Warning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWarning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static CompilationIssueType Error { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsError { get; }
    private static CompilationIssueType();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.CodeAnalysis.Hosted.CompilationIssueType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CompilationIssueType(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static CompilationIssueType get_Warning();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWarning();
    [CompilationMappingAttribute("8", "1")]
internal static CompilationIssueType get_Error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CompilationIssueType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompilationIssueType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.Hosted.CompilationOutput : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FormattedDiagnostic[] Errors@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FormattedDiagnostic[] Warnings@;
    [CompilationMappingAttribute("4", "0")]
internal FormattedDiagnostic[] Errors { get; }
    [CompilationMappingAttribute("4", "1")]
internal FormattedDiagnostic[] Warnings { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.Hosted.CompilationOutput")]
internal CompilationOutput(FormattedDiagnostic[] errors, FormattedDiagnostic[] warnings);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FormattedDiagnostic[] get_Errors();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FormattedDiagnostic[] get_Warnings();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompilationOutput obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.CodeAnalysis.Hosted.CompilationResult : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSuccess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFailure { get; }
    [CompilationMappingAttribute("8", "0")]
internal static CompilationResult NewSuccess(FSharpList`1<CompilationIssue> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSuccess();
    [CompilationMappingAttribute("8", "1")]
internal static CompilationResult NewFailure(FailureDetails item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFailure();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CompilationResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompilationResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.Hosted.CompilerHelpers : object {
    internal static String[] parseCommandLine(string commandLine);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, String[], String[]> fscCompile(LegacyReferenceResolver legacyReferenceResolver, string directory, String[] args);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.Hosted.FailureDetails : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<CompilationIssue> Warnings@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<CompilationIssue> Errors@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpList`1<CompilationIssue> Warnings { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpList`1<CompilationIssue> Errors { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.Hosted.FailureDetails")]
internal FailureDetails(FSharpList`1<CompilationIssue> warnings, FSharpList`1<CompilationIssue> errors);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<CompilationIssue> get_Warnings();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<CompilationIssue> get_Errors();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FailureDetails obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FailureDetails obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.Hosted.FscCompiler : object {
    internal InProcCompiler compiler;
    internal Location emptyLocation;
    internal FSharpFunc`2<string, bool> errorRangesArg;
    internal FSharpFunc`2<string, bool> vsErrorsArg;
    internal FSharpFunc`2<string, bool> fscExeArg;
    public FscCompiler(LegacyReferenceResolver legacyReferenceResolver);
    internal Tuple`2<int, String[]> Compile(String[] args);
    [CompilerGeneratedAttribute]
internal CompilationIssue convert(FormattedDiagnostic issue);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.Hosted.InProcCompiler : object {
    internal LegacyReferenceResolver legacyReferenceResolver;
    public InProcCompiler(LegacyReferenceResolver legacyReferenceResolver);
    internal Tuple`2<bool, CompilationOutput> Compile(String[] argv);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.Hosted.InProcDiagnosticsLoggerProvider : object {
    internal List`1<FormattedDiagnostic> errors;
    internal List`1<FormattedDiagnostic> warnings;
    internal IDiagnosticsLoggerProvider Provider { get; }
    internal FormattedDiagnostic[] CapturedErrors { get; }
    internal FormattedDiagnostic[] CapturedWarnings { get; }
    internal IDiagnosticsLoggerProvider get_Provider();
    internal FormattedDiagnostic[] get_CapturedErrors();
    internal FormattedDiagnostic[] get_CapturedWarnings();
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.Hosted.Location : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int StartLine@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int StartColumn@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int EndLine@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int EndColumn@;
    [CompilationMappingAttribute("4", "0")]
internal int StartLine { get; }
    [CompilationMappingAttribute("4", "1")]
internal int StartColumn { get; }
    [CompilationMappingAttribute("4", "2")]
internal int EndLine { get; }
    [CompilationMappingAttribute("4", "3")]
internal int EndColumn { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.Hosted.Location")]
internal Location(int startLine, int startColumn, int endLine, int endColumn);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_StartLine();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_StartColumn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_EndLine();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_EndColumn();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Location obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Location obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.CodeAnalysis.ILegacyReferenceResolver {
    public string DotNetFrameworkReferenceAssembliesRootDirectory { get; }
    public abstract virtual string HighestInstalledNetFrameworkVersion();
    public abstract virtual string get_DotNetFrameworkReferenceAssembliesRootDirectory();
    public abstract virtual LegacyResolvedFile[] Resolve(LegacyResolutionEnvironment resolutionEnvironment, Tuple`2[] references, string targetFrameworkVersion, FSharpList`1<string> targetFrameworkDirectories, string targetProcessorArchitecture, string fsharpCoreDir, FSharpList`1<string> explicitIncludeDirs, string implicitIncludeDir, FSharpFunc`2<string, Unit> logMessage, FSharpFunc`2<bool, FSharpFunc`2<string, FSharpFunc`2<string, Unit>>> logDiagnostic);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.IncrementalBuild : object {
    [CompilationMappingAttribute("9")]
internal static bool injectCancellationFault { get; internal set; }
    internal static bool get_injectCancellationFault();
    internal static void set_injectCancellationFault(bool value);
    internal static IDisposable LocallyInjectCancellationFault();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.IncrementalBuilder : object {
    internal IncrementalBuilderInitialState initialState;
    internal BoundModel initialBoundModel;
    internal TcConfig tcConfig;
    internal FSharpList`1<FSharpFile> fileNames;
    internal FSharpEvent`1<string> beforeFileChecked;
    internal FSharpEvent`1<string> fileChecked;
    internal FSharpEvent`1<Unit> importsInvalidatedByTypeProvider;
    internal String[] allDependencies;
    internal DateTime defaultTimeStamp;
    internal FSharpEvent`1<string> fileParsed;
    internal FSharpEvent`1<Unit> projectChecked;
    internal SemaphoreSlim semaphore;
    internal IncrementalBuilderState currentState;
    internal TcConfig TcConfig { get; }
    internal IEvent`2<FSharpHandler`1<string>, string> FileParsed { get; }
    internal IEvent`2<FSharpHandler`1<string>, string> BeforeFileChecked { get; }
    internal IEvent`2<FSharpHandler`1<string>, string> FileChecked { get; }
    internal IEvent`2<FSharpHandler`1<Unit>, Unit> ProjectChecked { get; }
    internal IEvent`2<FSharpHandler`1<Unit>, Unit> ImportsInvalidatedByTypeProvider { get; }
    internal bool IsReferencesInvalidated { get; }
    internal String[] AllDependenciesDeprecated { get; }
    internal FSharpList`1<string> SourceFiles { get; }
    public IncrementalBuilder(IncrementalBuilderInitialState initialState, IncrementalBuilderState state);
    internal TcConfig get_TcConfig();
    internal IEvent`2<FSharpHandler`1<string>, string> get_FileParsed();
    internal IEvent`2<FSharpHandler`1<string>, string> get_BeforeFileChecked();
    internal IEvent`2<FSharpHandler`1<string>, string> get_FileChecked();
    internal IEvent`2<FSharpHandler`1<Unit>, Unit> get_ProjectChecked();
    internal IEvent`2<FSharpHandler`1<Unit>, Unit> get_ImportsInvalidatedByTypeProvider();
    internal bool get_IsReferencesInvalidated();
    internal String[] get_AllDependenciesDeprecated();
    internal NodeCode`1<Unit> PopulatePartialCheckingResults();
    internal FSharpOption`1<PartialCheckResults> GetCheckResultsBeforeFileInProjectEvenIfStale(string fileName);
    internal FSharpOption`1<PartialCheckResults> GetCheckResultsForFileInProjectEvenIfStale(string fileName);
    internal FSharpOption`1<PartialCheckResults> TryGetCheckResultsBeforeFileInProject(string fileName);
    internal bool AreCheckResultsBeforeFileInProjectReady(string fileName);
    internal NodeCode`1<PartialCheckResults> GetCheckResultsBeforeSlotInProject(int slotOfFile);
    internal NodeCode`1<PartialCheckResults> GetFullCheckResultsBeforeSlotInProject(int slotOfFile);
    internal NodeCode`1<PartialCheckResults> GetCheckResultsBeforeFileInProject(string fileName);
    internal NodeCode`1<PartialCheckResults> GetCheckResultsAfterFileInProject(string fileName);
    internal NodeCode`1<PartialCheckResults> GetFullCheckResultsBeforeFileInProject(string fileName);
    internal NodeCode`1<PartialCheckResults> GetFullCheckResultsAfterFileInProject(string fileName);
    internal NodeCode`1<PartialCheckResults> GetCheckResultsAfterLastFileInProject();
    internal NodeCode`1<Tuple`4<PartialCheckResults, ILAssemblyRef, ProjectAssemblyDataResult, FSharpOption`1<FSharpList`1<CheckedImplFile>>>> GetCheckResultsAndImplementationsForProject();
    internal NodeCode`1<Tuple`4<PartialCheckResults, ILAssemblyRef, ProjectAssemblyDataResult, FSharpOption`1<FSharpList`1<CheckedImplFile>>>> GetFullCheckResultsAndImplementationsForProject();
    internal DateTime GetLogicalTimeStampForFileInProject(string filename);
    internal DateTime GetLogicalTimeStampForFileInProject(int slotOfFile);
    internal DateTime GetLogicalTimeStampForProject(TimeStampCache cache);
    internal FSharpOption`1<int> TryGetSlotOfFileName(string fileName);
    internal int GetSlotOfFileName(string fileName);
    internal int GetSlotsCount();
    internal bool ContainsFile(string fileName);
    internal Tuple`4<ParsedInput, Range, string, Tuple`2[]> GetParseResultsForFile(string fileName);
    internal NodeCode`1<Unit> NotifyFileChanged(string fileName, DateTime timeStamp);
    internal FSharpList`1<string> get_SourceFiles();
    internal static NodeCode`1<Tuple`2<FSharpOption`1<IncrementalBuilder>, FSharpDiagnostic[]>> TryCreateIncrementalBuilderForProjectOptions(LegacyReferenceResolver legacyReferenceResolver, string defaultFSharpBinariesDir, FrameworkImportsCache frameworkTcImportsCache, FSharpOption`1<LoadClosure> loadClosureOpt, FSharpList`1<string> sourceFiles, FSharpList`1<string> commandLineArgs, FSharpList`1<IProjectReference> projectReferences, string projectDirectory, bool useScriptResolutionRules, bool keepAssemblyContents, bool keepAllBackgroundResolutions, FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot, bool suggestNamesForErrors, bool keepAllBackgroundSymbolUses, bool enableBackgroundItemKeyStoreAndSemanticClassification, bool enablePartialTypeChecking, FSharpOption`1<DependencyProvider> dependencyProvider, ParallelReferenceResolution parallelReferenceResolution, bool captureIdentifiersWhenParsing, FSharpOption`1<FSharpFunc`2<string, FSharpAsync`1<FSharpOption`1<ISourceText>>>> getSource, bool useChangeNotifications, bool useSyntaxTreeCache);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`2<BoundModel, DateTime>> tryGetSlot(IncrementalBuilderState state, int slot);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`2<BoundModel, DateTime>> tryGetBeforeSlot(IncrementalBuilderState state, int slot);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal NodeCode`1<FSharpOption`1<Tuple`2<BoundModel, DateTime>>> evalUpToTargetSlot(IncrementalBuilderState state, int targetSlot);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal DateTime MaxTimeStampInDependencies(IEnumerable`1<DateTime> stamps, int fileSlot);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal DateTime computeProjectTimeStamp(IncrementalBuilderState state, int fileSlot);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal NodeCode`1<Unit> setCurrentState(IncrementalBuilderState state, TimeStampCache cache, CancellationToken ct);
    [CompilerGeneratedAttribute]
internal NodeCode`1<Unit> checkFileTimeStamps(TimeStampCache cache);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.IncrementalBuilderEventTesting : object {
    [CompilationMappingAttribute("9")]
internal static FixedLengthMRU`1<IBEvent> MRU { get; }
    internal static FixedLengthMRU`1<IBEvent> get_MRU();
    internal static FSharpList`1<IBEvent> GetMostRecentIncrementalBuildEvents(int n);
    internal static int GetCurrentIncrementalBuildEventNum();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.IncrementalBuilderHelpers : object {
    internal static NodeCode`1<Tuple`2<BoundModel, Tuple`2[]>> CombineImportedAssembliesTask(string assemblyName, TcConfig tcConfig, TcConfigProvider tcConfigP, TcGlobals tcGlobals, TcImports frameworkTcImports, FSharpList`1<AssemblyResolution> nonFrameworkResolutions, FSharpList`1<UnresolvedAssemblyReference> unresolvedReferences, DependencyProvider dependencyProvider, FSharpOption`1<LoadClosure> loadClosureOpt, FSharpList`1<string> basicDependencies, bool keepAssemblyContents, bool keepAllBackgroundResolutions, bool keepAllBackgroundSymbolUses, bool enableBackgroundItemKeyStoreAndSemanticClassification, FSharpEvent`1<string> beforeFileChecked, FSharpEvent`1<string> fileChecked, FSharpEvent`1<Unit> importsInvalidatedByTypeProvider);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NodeCode`1<Tuple`4<ILAssemblyRef, ProjectAssemblyDataResult, FSharpOption`1<FSharpList`1<CheckedImplFile>>, BoundModel>> FinalizeTypeCheckTask(TcConfig tcConfig, TcGlobals tcGlobals, bool partialCheck, string assemblyName, string outfile, Tuple`2[] initialErrors, IEnumerable`1<GraphNode`1<BoundModel>> boundModels);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.IncrementalBuilderInitialState : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal BoundModel initialBoundModel@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Tuple`2[] initialErrors@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TcGlobals tcGlobals@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ImmutableArray`1<Tuple`2<FSharpChoice`2<string, IProjectReference>, FSharpFunc`2<TimeStampCache, DateTime>>> referencedAssemblies@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TcConfig tcConfig@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string outfile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string assemblyName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal LexResourceManager lexResourceManager@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FSharpFile> fileNames@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool enablePartialTypeChecking@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpEvent`1<string> beforeFileChecked@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpEvent`1<string> fileChecked@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpEvent`1<string> fileParsed@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpEvent`1<Unit> projectChecked@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpEvent`1<Unit> importsInvalidatedByTypeProvider@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] allDependencies@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal DateTime defaultTimeStamp@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool isImportsInvalidated@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool useChangeNotifications@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool useSyntaxTreeCache@;
    [CompilationMappingAttribute("4", "0")]
internal BoundModel initialBoundModel { get; }
    [CompilationMappingAttribute("4", "1")]
internal Tuple`2[] initialErrors { get; }
    [CompilationMappingAttribute("4", "2")]
internal TcGlobals tcGlobals { get; }
    [CompilationMappingAttribute("4", "3")]
internal ImmutableArray`1<Tuple`2<FSharpChoice`2<string, IProjectReference>, FSharpFunc`2<TimeStampCache, DateTime>>> referencedAssemblies { get; }
    [CompilationMappingAttribute("4", "4")]
internal TcConfig tcConfig { get; }
    [CompilationMappingAttribute("4", "5")]
internal string outfile { get; }
    [CompilationMappingAttribute("4", "6")]
internal string assemblyName { get; }
    [CompilationMappingAttribute("4", "7")]
internal LexResourceManager lexResourceManager { get; }
    [CompilationMappingAttribute("4", "8")]
internal FSharpList`1<FSharpFile> fileNames { get; }
    [CompilationMappingAttribute("4", "9")]
internal bool enablePartialTypeChecking { get; }
    [CompilationMappingAttribute("4", "10")]
internal FSharpEvent`1<string> beforeFileChecked { get; }
    [CompilationMappingAttribute("4", "11")]
internal FSharpEvent`1<string> fileChecked { get; }
    [CompilationMappingAttribute("4", "12")]
internal FSharpEvent`1<string> fileParsed { get; }
    [CompilationMappingAttribute("4", "13")]
internal FSharpEvent`1<Unit> projectChecked { get; }
    [CompilationMappingAttribute("4", "14")]
internal FSharpEvent`1<Unit> importsInvalidatedByTypeProvider { get; }
    [CompilationMappingAttribute("4", "15")]
internal String[] allDependencies { get; }
    [CompilationMappingAttribute("4", "16")]
internal DateTime defaultTimeStamp { get; }
    [CompilationMappingAttribute("4", "17")]
internal bool isImportsInvalidated { get; internal set; }
    [CompilationMappingAttribute("4", "18")]
internal bool useChangeNotifications { get; }
    [CompilationMappingAttribute("4", "19")]
internal bool useSyntaxTreeCache { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.IncrementalBuilderInitialState")]
internal IncrementalBuilderInitialState(BoundModel initialBoundModel, Tuple`2[] initialErrors, TcGlobals tcGlobals, ImmutableArray`1<Tuple`2<FSharpChoice`2<string, IProjectReference>, FSharpFunc`2<TimeStampCache, DateTime>>> referencedAssemblies, TcConfig tcConfig, string outfile, string assemblyName, LexResourceManager lexResourceManager, FSharpList`1<FSharpFile> fileNames, bool enablePartialTypeChecking, FSharpEvent`1<string> beforeFileChecked, FSharpEvent`1<string> fileChecked, FSharpEvent`1<string> fileParsed, FSharpEvent`1<Unit> projectChecked, FSharpEvent`1<Unit> importsInvalidatedByTypeProvider, String[] allDependencies, DateTime defaultTimeStamp, bool isImportsInvalidated, bool useChangeNotifications, bool useSyntaxTreeCache);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal BoundModel get_initialBoundModel();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Tuple`2[] get_initialErrors();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TcGlobals get_tcGlobals();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ImmutableArray`1<Tuple`2<FSharpChoice`2<string, IProjectReference>, FSharpFunc`2<TimeStampCache, DateTime>>> get_referencedAssemblies();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TcConfig get_tcConfig();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_outfile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_assemblyName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal LexResourceManager get_lexResourceManager();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<FSharpFile> get_fileNames();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_enablePartialTypeChecking();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpEvent`1<string> get_beforeFileChecked();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpEvent`1<string> get_fileChecked();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpEvent`1<string> get_fileParsed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpEvent`1<Unit> get_projectChecked();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpEvent`1<Unit> get_importsInvalidatedByTypeProvider();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal String[] get_allDependencies();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DateTime get_defaultTimeStamp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_isImportsInvalidated();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_useChangeNotifications();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_useSyntaxTreeCache();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void set_isImportsInvalidated(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal static IncrementalBuilderInitialState Create(BoundModel initialBoundModel, Tuple`2[] initialErrors, TcGlobals tcGlobals, IEnumerable`1<Tuple`2<FSharpChoice`2<string, IProjectReference>, FSharpFunc`2<TimeStampCache, DateTime>>> nonFrameworkAssemblyInputs, TcConfig tcConfig, string outfile, string assemblyName, LexResourceManager lexResourceManager, FSharpList`1<FSharpFile> sourceFiles, bool enablePartialTypeChecking, FSharpEvent`1<string> beforeFileChecked, FSharpEvent`1<string> fileChecked, FSharpEvent`1<Unit> importsInvalidatedByTypeProvider, String[] allDependencies, DateTime defaultTimeStamp, bool useChangeNotifications, bool useSyntaxTreeCache);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.IncrementalBuilderState : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Slot> slots@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ImmutableArray`1<DateTime> stampedReferencedAssemblies@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal GraphNode`1<BoundModel> initialBoundModel@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal GraphNode`1<Tuple`2<Tuple`4<ILAssemblyRef, ProjectAssemblyDataResult, FSharpOption`1<FSharpList`1<CheckedImplFile>>, BoundModel>, DateTime>> finalizedBoundModel@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpList`1<Slot> slots { get; }
    [CompilationMappingAttribute("4", "1")]
internal ImmutableArray`1<DateTime> stampedReferencedAssemblies { get; }
    [CompilationMappingAttribute("4", "2")]
internal GraphNode`1<BoundModel> initialBoundModel { get; }
    [CompilationMappingAttribute("4", "3")]
internal GraphNode`1<Tuple`2<Tuple`4<ILAssemblyRef, ProjectAssemblyDataResult, FSharpOption`1<FSharpList`1<CheckedImplFile>>, BoundModel>, DateTime>> finalizedBoundModel { get; }
    internal FSharpList`1<DateTime> stampedFileNames { get; }
    internal FSharpList`1<DateTime> logicalStampedFileNames { get; }
    internal FSharpList`1<GraphNode`1<BoundModel>> boundModels { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.IncrementalBuilderState")]
internal IncrementalBuilderState(FSharpList`1<Slot> slots, ImmutableArray`1<DateTime> stampedReferencedAssemblies, GraphNode`1<BoundModel> initialBoundModel, GraphNode`1<Tuple`2<Tuple`4<ILAssemblyRef, ProjectAssemblyDataResult, FSharpOption`1<FSharpList`1<CheckedImplFile>>, BoundModel>, DateTime>> finalizedBoundModel);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Slot> get_slots();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ImmutableArray`1<DateTime> get_stampedReferencedAssemblies();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal GraphNode`1<BoundModel> get_initialBoundModel();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal GraphNode`1<Tuple`2<Tuple`4<ILAssemblyRef, ProjectAssemblyDataResult, FSharpOption`1<FSharpList`1<CheckedImplFile>>, BoundModel>, DateTime>> get_finalizedBoundModel();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal FSharpList`1<DateTime> get_stampedFileNames();
    internal FSharpList`1<DateTime> get_logicalStampedFileNames();
    internal FSharpList`1<GraphNode`1<BoundModel>> get_boundModels();
    internal static IncrementalBuilderState Create(IncrementalBuilderInitialState initialState);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.IncrementalBuilderStateHelpers : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static GraphNode`1<BoundModel> createBoundModelGraphNode(GraphNode`1<BoundModel> prevBoundModel, SyntaxTree syntaxTree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static GraphNode`1<Tuple`2<Tuple`4<ILAssemblyRef, ProjectAssemblyDataResult, FSharpOption`1<FSharpList`1<CheckedImplFile>>, BoundModel>, DateTime>> createFinalizeBoundModelGraphNode(IncrementalBuilderInitialState initialState, IEnumerable`1<GraphNode`1<BoundModel>> boundModels);
    internal static Tuple`2<Slot, Tuple`2<a, GraphNode`1<BoundModel>>> update@977(GraphNode`1<BoundModel> prevNode, Slot slot, a newStatus);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalBuilderState computeStampedFileNames(IncrementalBuilderInitialState initialState, IncrementalBuilderState state, TimeStampCache cache);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalBuilderState computeStampedReferencedAssemblies(IncrementalBuilderInitialState initialState, IncrementalBuilderState state, bool canTriggerInvalidation, TimeStampCache cache);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.IncrementalBuildSyntaxTree : object {
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.CodeAnalysis.InheritanceContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Unknown;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static InheritanceContext Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static InheritanceContext Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static InheritanceContext Unknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnknown { get; }
    private static InheritanceContext();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.CodeAnalysis.InheritanceContext")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InheritanceContext(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static InheritanceContext get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsClass();
    [CompilationMappingAttribute("8", "1")]
internal static InheritanceContext get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInterface();
    [CompilationMappingAttribute("8", "2")]
internal static InheritanceContext get_Unknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InheritanceContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InheritanceContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.CodeAnalysis.IsResultObsolete : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Unit, bool> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Unit, bool> Item { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.IsResultObsolete")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IsResultObsolete(FSharpFunc`2<Unit, bool> item);
    [CompilationMappingAttribute("8", "0")]
internal static IsResultObsolete NewIsResultObsolete(FSharpFunc`2<Unit, bool> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Unit, bool> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.ItemKeyStore : object {
    internal TcGlobals tcGlobals;
    internal MemoryMappedFile mmf;
    internal long length;
    internal object debugStore;
    internal Byte[] rangeBuffer;
    internal bool isDisposed;
    internal object DebugStore { get; }
    public ItemKeyStore(MemoryMappedFile mmf, long length, TcGlobals tcGlobals, object debugStore);
    internal object get_DebugStore();
    internal Range ReadRange(BlobReader& reader);
    internal ReadOnlySpan`1<byte> ReadKeyString(BlobReader& reader);
    internal ReadOnlySpan`1<byte> ReadFirstKeyString();
    internal IEnumerable`1<Range> FindAll(Item item);
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
internal void checkDispose();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.ItemKeyStoreBuilder : object {
    internal TcGlobals tcGlobals;
    internal BlobBuilder b;
    internal _DebugKeyStoreNoop debug;
    public ItemKeyStoreBuilder(TcGlobals tcGlobals);
    internal void Write(Range m, Item item);
    internal FSharpOption`1<ItemKeyStore> TryBuildAndReset();
    [CompilerGeneratedAttribute]
internal void writeChar(char c);
    [CompilerGeneratedAttribute]
internal void writeUInt16(ushort i);
    [CompilerGeneratedAttribute]
internal void writeInt32(int i);
    [CompilerGeneratedAttribute]
internal void writeInt64(long i);
    [CompilerGeneratedAttribute]
internal void writeString(string str);
    [CompilerGeneratedAttribute]
internal void writeRange(Range m);
    [CompilerGeneratedAttribute]
internal void writeEntityRef(EntityRef eref);
    [CompilerGeneratedAttribute]
internal void writeILType(ILType ilTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void writeType(bool isStandalone, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void writeMeasure(bool isStandalone, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void writeTypar(bool isStandalone, Typar typar);
    [CompilerGeneratedAttribute]
internal void writeValRef(ValRef vref);
    [CompilerGeneratedAttribute]
internal void writeValue(ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void writeActivePatternCase(ActivePatternInfo apInfo, int index);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.ItemKeyTags : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string entityRef;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string typeTuple;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string typeAnonymousRecord;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string typeFunction;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string typeMeasure;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string typeUnionCase;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string typeMeasureVar;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string typeMeasureCon;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemValueMember;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemValue;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemUnionCase;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemActivePattern;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemExnCase;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemRecordField;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemAnonymousRecordField;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemNewDef;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemILField;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemEvent;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemProperty;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemTrait;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemTypeVar;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemModuleOrNamespace;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string itemDelegateCtor;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string parameters;
    private static ItemKeyTags();
}
[ClassAttribute]
[AllowNullLiteralAttribute]
[ObsoleteAttribute("This API is obsolete and not for external use")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CodeAnalysis.LegacyReferenceResolver : object {
    internal ILegacyReferenceResolver impl;
    internal ILegacyReferenceResolver Impl { get; }
    public LegacyReferenceResolver(ILegacyReferenceResolver impl);
    internal ILegacyReferenceResolver get_Impl();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.CodeAnalysis.LegacyResolutionEnvironment : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LegacyResolutionEnvironment _unique_CompilationAndEvaluation;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEditingOrCompilation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LegacyResolutionEnvironment CompilationAndEvaluation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCompilationAndEvaluation { get; }
    private static LegacyResolutionEnvironment();
    [CompilationMappingAttribute("8", "0")]
public static LegacyResolutionEnvironment NewEditingOrCompilation(bool _isEditing);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEditingOrCompilation();
    [CompilationMappingAttribute("8", "1")]
public static LegacyResolutionEnvironment get_CompilationAndEvaluation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCompilationAndEvaluation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(LegacyResolutionEnvironment obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LegacyResolutionEnvironment obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("5")]
public class FSharp.Compiler.CodeAnalysis.LegacyResolutionFailure : Exception {
    protected LegacyResolutionFailure(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.CodeAnalysis.LegacyResolvedFile : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string itemSpec@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<Tuple`2<string, string>, string> prepareToolTip@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string baggage@;
    [CompilationMappingAttribute("4", "0")]
public string itemSpec { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpFunc`2<Tuple`2<string, string>, string> prepareToolTip { get; }
    [CompilationMappingAttribute("4", "2")]
public string baggage { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.LegacyResolvedFile")]
public LegacyResolvedFile(string itemSpec, FSharpFunc`2<Tuple`2<string, string>, string> prepareToolTip, string baggage);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_itemSpec();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<Tuple`2<string, string>, string> get_prepareToolTip();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_baggage();
    public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.CodeAnalysis.NameResResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NameResResult _unique_Empty;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsMembers { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCancel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NameResResult Empty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsEmpty { get; }
    private static NameResResult();
    [CompilationMappingAttribute("8", "0")]
internal static NameResResult NewMembers(Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, Range> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsMembers();
    [CompilationMappingAttribute("8", "1")]
internal static NameResResult NewCancel(DisplayEnv item1, Range item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCancel();
    [CompilationMappingAttribute("8", "2")]
internal static NameResResult get_Empty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.ParseAndCheckFile : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IndentationAwareSyntaxStatus getLightSyntaxStatus(string fileName, FSharpParsingOptions options);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<a, token> createLexerFunction(string fileName, FSharpParsingOptions options, LexBuffer`1<char> lexbuf, DiagnosticsHandler errHandler, CancellationToken ct);
    internal static bool parenTokensBalance@2599(token t1, token t2);
    internal static void matchBraces@2619-1(List`1<Tuple`2<Range, Range>> matchingBraces, LexBuffer`1<char> lexbuf, FSharpFunc`2<LexBuffer`1<char>, token> lexfun, FSharpList`1<Tuple`3<token, int, Range>> stack);
    internal static Tuple`2[] matchBraces(ISourceText sourceText, string fileName, FSharpParsingOptions options, string userOpName, bool suggestNamesForErrors, CancellationToken ct);
    internal static Tuple`3<FSharpDiagnostic[], ParsedInput, bool> parseFile(ISourceText sourceText, string fileName, FSharpParsingOptions options, string userOpName, bool suggestNamesForErrors, bool flatErrors, bool identCapture, CancellationToken ct);
    internal static FSharpOption`1<string> fileOfBackgroundError@2755(PhasedDiagnostic diagnostic, a tupledArg1);
    internal static bool sameFile@2760(FSharpOption`1<string> file, string hashLoadInFile);
    [CompilerGeneratedAttribute]
internal static void ApplyLoadClosure$cont@2750(TcImports tcImports, FSharpOption`1<LoadClosure> loadClosure, Tuple`2[] backgroundDiagnostics, Unit unitVar);
    internal static void ApplyLoadClosure(TcConfig tcConfig, ParsedInput parsedMainInput, string mainInputFileName, FSharpOption`1<LoadClosure> loadClosure, TcImports tcImports, Tuple`2[] backgroundDiagnostics);
    internal static Cancellable`1<Tuple`2<FSharpDiagnostic[], TypeCheckInfo>> CheckOneFile(FSharpParseFileResults parseResults, ISourceText sourceText, string mainInputFileName, FSharpProjectOptions projectOptions, string projectFileName, TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, TcState tcState, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, FSharpOption`1<LoadClosure> loadClosure, Tuple`2[] backgroundDiagnostics, bool suggestNamesForErrors);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.ParseCacheLockToken : object {
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.PartialCheckResults : object {
    internal DateTime timeStamp;
    internal DateTime projectTimeStamp;
    internal BoundModel boundModel;
    internal TcImports TcImports { get; }
    internal TcGlobals TcGlobals { get; }
    internal TcConfig TcConfig { get; }
    internal DateTime TimeStamp { get; }
    internal DateTime ProjectTimeStamp { get; }
    public PartialCheckResults(BoundModel boundModel, DateTime timeStamp, DateTime projectTimeStamp);
    internal TcImports get_TcImports();
    internal TcGlobals get_TcGlobals();
    internal TcConfig get_TcConfig();
    internal DateTime get_TimeStamp();
    internal DateTime get_ProjectTimeStamp();
    internal FSharpOption`1<TcInfo> TryPeekTcInfo();
    internal FSharpOption`1<Tuple`2<TcInfo, TcInfoExtras>> TryPeekTcInfoWithExtras();
    internal NodeCode`1<TcInfo> GetOrComputeTcInfo();
    internal NodeCode`1<Tuple`2<TcInfo, TcInfoExtras>> GetOrComputeTcInfoWithExtras();
    internal NodeCode`1<FSharpOption`1<ItemKeyStore>> GetOrComputeItemKeyStoreIfEnabled();
    internal NodeCode`1<FSharpOption`1<SemanticClassificationKeyStore>> GetOrComputeSemanticClassificationIfEnabled();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.RawFSharpAssemblyDataBackedByLanguageService : object {
    internal ILAssemblyRef ilAssemRef;
    internal string assemblyName;
    internal FSharpList`1<Tuple`2<string, FSharpFunc`2<Unit, ReadOnlyByteMemory>>> sigData;
    internal FSharpList`1<string> autoOpenAttrs;
    internal FSharpList`1<string> ivtAttrs;
    public RawFSharpAssemblyDataBackedByLanguageService(TcConfig tcConfig, TcGlobals tcGlobals, CcuThunk generatedCcu, string outfile, TopAttribs topAttrs, string assemblyName, ILAssemblyRef ilAssemRef);
    private virtual override FSharpList`1<string> FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetAutoOpenAttributes();
    private virtual override FSharpList`1<string> FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetInternalsVisibleToAttributes();
    private virtual override FSharpOption`1<ILModuleDef> FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.TryGetILModuleDef();
    private virtual override FSharpList`1<Tuple`2<string, FSharpFunc`2<Unit, ReadOnlyByteMemory>>> FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetRawFSharpSignatureData(Range _m, string _ilShortAssemName, string _filename);
    private virtual override FSharpList`1<Tuple`2<string, FSharpFunc`2<Unit, ReadOnlyByteMemory>>> FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetRawFSharpOptimizationData(Range _m, string _ilShortAssemName, string _filename);
    private virtual override ILExportedTypesAndForwarders FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.GetRawTypeForwarders();
    private virtual override string FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.get_ShortAssemblyName();
    private virtual override ILScopeRef FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.get_ILScopeRef();
    private virtual override FSharpList`1<ILAssemblyRef> FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.get_ILAssemblyRefs();
    private virtual override bool FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.get_HasAnyFSharpSignatureDataAttribute();
    private virtual override bool FSharp.Compiler.CompilerConfig.IRawFSharpAssemblyData.get_HasMatchingFSharpSignatureDataAttribute();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.CodeAnalysis.RecordContext : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCopyOnUpdate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNew { get; }
    [CompilationMappingAttribute("8", "0")]
internal static RecordContext NewCopyOnUpdate(Range _range, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> _path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCopyOnUpdate();
    [CompilationMappingAttribute("8", "1")]
internal static RecordContext NewConstructor(string _typeName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsConstructor();
    [CompilationMappingAttribute("8", "2")]
internal static RecordContext NewNew(Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> _path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNew();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RecordContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.CodeAnalysis.ResolveOverloads : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ResolveOverloads _unique_Yes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ResolveOverloads _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ResolveOverloads Yes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static ResolveOverloads No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNo { get; }
    private static ResolveOverloads();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.CodeAnalysis.ResolveOverloads")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ResolveOverloads(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static ResolveOverloads get_Yes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
internal static ResolveOverloads get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ResolveOverloads obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ResolveOverloads obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.ScriptClosureCacheToken : object {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.SimulatedMSBuildReferenceResolver : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net45;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net451;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net452;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net46;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net461;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net462;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net47;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net471;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net472;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string Net48;
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> SupportedDesktopFrameworkVersions { get; }
    [CompilationMappingAttribute("9")]
internal static LegacyReferenceResolver SimulatedMSBuildResolver { get; }
    private static SimulatedMSBuildReferenceResolver();
    internal static FSharpList`1<string> get_SupportedDesktopFrameworkVersions();
    internal static LegacyReferenceResolver get_SimulatedMSBuildResolver();
    internal static FSharpList`1<string> GetPathToDotNetFrameworkImlpementationAssemblies@53(a _arg1);
    internal static void success@122(List`1<LegacyResolvedFile> results, string baggage, FSharpRef`1<bool> found, string path);
    internal static LegacyReferenceResolver getResolver();
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.Slot : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool HasSignature@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal DateTime Stamp@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal DateTime LogicalStamp@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SyntaxTree SyntaxTree@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool Notified@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal GraphNode`1<BoundModel> BoundModel@;
    [CompilationMappingAttribute("4", "0")]
internal bool HasSignature { get; }
    [CompilationMappingAttribute("4", "1")]
internal DateTime Stamp { get; }
    [CompilationMappingAttribute("4", "2")]
internal DateTime LogicalStamp { get; }
    [CompilationMappingAttribute("4", "3")]
internal SyntaxTree SyntaxTree { get; }
    [CompilationMappingAttribute("4", "4")]
internal bool Notified { get; }
    [CompilationMappingAttribute("4", "5")]
internal GraphNode`1<BoundModel> BoundModel { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.Slot")]
internal Slot(bool hasSignature, DateTime stamp, DateTime logicalStamp, SyntaxTree syntaxTree, bool notified, GraphNode`1<BoundModel> boundModel);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_HasSignature();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DateTime get_Stamp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DateTime get_LogicalStamp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SyntaxTree get_SyntaxTree();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_Notified();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal GraphNode`1<BoundModel> get_BoundModel();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal Slot Notify(DateTime timeStamp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Slot obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.SourceFileImpl : object {
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.TcInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TcState tcState@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TcEnv tcEnvAtEndOfFile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<TopAttribs> topAttribs@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<ModuleOrNamespaceType> latestCcuSigForFile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Tuple`2[]> tcDiagnosticsRev@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> tcDependencyFiles@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Tuple`2<string, QualifiedNameOfFile>> sigNameOpt@;
    [CompilationMappingAttribute("4", "0")]
internal TcState tcState { get; }
    [CompilationMappingAttribute("4", "1")]
internal TcEnv tcEnvAtEndOfFile { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpOption`1<TopAttribs> topAttribs { get; }
    [CompilationMappingAttribute("4", "4")]
internal FSharpOption`1<ModuleOrNamespaceType> latestCcuSigForFile { get; }
    [CompilationMappingAttribute("4", "5")]
internal FSharpList`1<Tuple`2[]> tcDiagnosticsRev { get; }
    [CompilationMappingAttribute("4", "6")]
internal FSharpList`1<string> tcDependencyFiles { get; }
    [CompilationMappingAttribute("4", "7")]
internal FSharpOption`1<Tuple`2<string, QualifiedNameOfFile>> sigNameOpt { get; }
    internal Tuple`2[] TcDiagnostics { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.TcInfo")]
internal TcInfo(TcState tcState, TcEnv tcEnvAtEndOfFile, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, FSharpOption`1<TopAttribs> topAttribs, FSharpOption`1<ModuleOrNamespaceType> latestCcuSigForFile, FSharpList`1<Tuple`2[]> tcDiagnosticsRev, FSharpList`1<string> tcDependencyFiles, FSharpOption`1<Tuple`2<string, QualifiedNameOfFile>> sigNameOpt);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TcState get_tcState();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TcEnv get_tcEnvAtEndOfFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> get_moduleNamesDict();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<TopAttribs> get_topAttribs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<ModuleOrNamespaceType> get_latestCcuSigForFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Tuple`2[]> get_tcDiagnosticsRev();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> get_tcDependencyFiles();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Tuple`2<string, QualifiedNameOfFile>> get_sigNameOpt();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal Tuple`2[] get_TcDiagnostics();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.CodeAnalysis.TcInfoExtras : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TcResolutions tcResolutions@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TcSymbolUses tcSymbolUses@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal OpenDeclaration[] tcOpenDeclarations@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<CheckedImplFile> latestImplFile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<ItemKeyStore> itemKeyStore@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<SemanticClassificationKeyStore> semanticClassificationKeyStore@;
    [CompilationMappingAttribute("4", "0")]
internal TcResolutions tcResolutions { get; }
    [CompilationMappingAttribute("4", "1")]
internal TcSymbolUses tcSymbolUses { get; }
    [CompilationMappingAttribute("4", "2")]
internal OpenDeclaration[] tcOpenDeclarations { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpOption`1<CheckedImplFile> latestImplFile { get; }
    [CompilationMappingAttribute("4", "4")]
internal FSharpOption`1<ItemKeyStore> itemKeyStore { get; }
    [CompilationMappingAttribute("4", "5")]
internal FSharpOption`1<SemanticClassificationKeyStore> semanticClassificationKeyStore { get; }
    internal TcSymbolUses TcSymbolUses { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.CodeAnalysis.TcInfoExtras")]
internal TcInfoExtras(TcResolutions tcResolutions, TcSymbolUses tcSymbolUses, OpenDeclaration[] tcOpenDeclarations, FSharpOption`1<CheckedImplFile> latestImplFile, FSharpOption`1<ItemKeyStore> itemKeyStore, FSharpOption`1<SemanticClassificationKeyStore> semanticClassificationKeyStore);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TcResolutions get_tcResolutions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TcSymbolUses get_tcSymbolUses();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal OpenDeclaration[] get_tcOpenDeclarations();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<CheckedImplFile> get_latestImplFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<ItemKeyStore> get_itemKeyStore();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SemanticClassificationKeyStore> get_semanticClassificationKeyStore();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal TcSymbolUses get_TcSymbolUses();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.CodeAnalysis.TextContainer : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextContainer _unique_OnDisk;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static TextContainer OnDisk { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOnDisk { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStream { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSourceText { get; }
    private static TextContainer();
    [CompilationMappingAttribute("8", "0")]
internal static TextContainer get_OnDisk();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOnDisk();
    [CompilationMappingAttribute("8", "1")]
internal static TextContainer NewStream(Stream item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStream();
    [CompilationMappingAttribute("8", "2")]
internal static TextContainer NewSourceText(ISourceText item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSourceText();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextContainer obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.CodeAnalysis.TypeCheckInfo : object {
    internal CcuThunk thisCcu;
    internal TcImports tcImports;
    internal AccessorDomain tcAccessRights;
    internal TcSymbolUses sSymbolUses;
    internal TcResolutions sResolutions;
    internal NameResolutionEnv sFallback;
    internal FSharpProjectOptions projectOptions;
    internal string projectFileName;
    internal OpenDeclaration[] openDeclarations;
    internal string mainInputFileName;
    internal FSharpOption`1<LoadClosure> loadClosure;
    internal FSharpOption`1<CheckedImplFile> implFileOpt;
    internal TcGlobals g;
    internal ModuleOrNamespaceType ccuSigForFile;
    internal AgedLookup`3<AnyCallerThreadToken, Tuple`4<int, int, string, FSharpOption`1<int>>, ToolTipText> getToolTipTextCache;
    internal ImportMap amap;
    internal InfoReader infoReader;
    internal NameResolver ncenv;
    internal SymbolEnv cenv;
    internal FSharpAssemblySignature PartialAssemblySignatureForFile { get; }
    internal AccessorDomain AccessRights { get; }
    internal FSharpProjectOptions ProjectOptions { get; }
    internal TcResolutions ScopeResolutions { get; }
    internal TcSymbolUses ScopeSymbolUses { get; }
    internal TcGlobals TcGlobals { get; }
    internal TcImports TcImports { get; }
    internal ModuleOrNamespaceType CcuSigForFile { get; }
    internal CcuThunk ThisCcu { get; }
    internal FSharpOption`1<CheckedImplFile> ImplementationFile { get; }
    internal OpenDeclaration[] OpenDeclarations { get; }
    internal SymbolEnv SymbolEnv { get; }
    public TypeCheckInfo(TcConfig _sTcConfig, TcGlobals g, ModuleOrNamespaceType ccuSigForFile, CcuThunk thisCcu, TcImports tcImports, AccessorDomain tcAccessRights, string projectFileName, string mainInputFileName, FSharpProjectOptions projectOptions, TcResolutions sResolutions, TcSymbolUses sSymbolUses, NameResolutionEnv sFallback, FSharpOption`1<LoadClosure> loadClosure, FSharpOption`1<CheckedImplFile> implFileOpt, OpenDeclaration[] openDeclarations);
    internal Tuple`2<Tuple`2<NameResolutionEnv, AccessorDomain>, Range> GetBestDisplayEnvForPos(Position cursorPos);
    internal FSharpList`1<EntityRef> GetVisibleNamespacesAndModulesAtPosition(Position cursorPos);
    internal bool IsRelativeNameResolvable(Position cursorPos, FSharpList`1<string> plid, Item item);
    internal bool IsRelativeNameResolvableFromSymbol(Position cursorPos, FSharpList`1<string> plid, FSharpSymbol symbol);
    internal DeclarationListInfo GetDeclarations(FSharpOption`1<FSharpParseFileResults> parseResultsOpt, int line, string lineStr, PartialLongName partialName, FSharpOption`1<Tuple`2<Position, FSharpOption`1<CompletionContext>>> completionContextAtPos, FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>> getAllEntities);
    internal FSharpList`1<FSharpList`1<FSharpSymbolUse>> GetDeclarationListSymbols(FSharpOption`1<FSharpParseFileResults> parseResultsOpt, int line, string lineStr, PartialLongName partialName, FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>> getAllEntities);
    internal ToolTipText GetReferenceResolutionStructuredToolTipText(int line, int col, FSharpOption`1<int> width);
    internal ToolTipText GetDescription(FSharpSymbol symbol, FSharpList`1<Tuple`2<FSharpGenericParameter, FSharpType>> inst, bool displayFullName, Range m);
    internal ToolTipText GetStructuredToolTipText(int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names, FSharpOption`1<int> width);
    internal FSharpOption`1<string> GetF1Keyword(int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names);
    internal MethodGroup GetMethods(int line, string lineStr, int colAtEndOfNames, FSharpOption`1<FSharpList`1<string>> namesOpt);
    internal FSharpOption`1<Tuple`3<FSharpList`1<Tuple`2<FSharpSymbol, ItemWithInst>>, DisplayEnv, Range>> GetMethodsAsSymbols(int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names);
    internal FindDeclResult GetDeclarationLocation(int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names, FSharpOption`1<bool> preferFlag);
    internal FSharpOption`1<Tuple`4<FSharpSymbol, ItemWithInst, DisplayEnv, Range>> GetSymbolUseAtLocation(int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names);
    internal FSharpList`1<Tuple`4<FSharpSymbol, ItemWithInst, DisplayEnv, Range>> GetSymbolUsesAtLocation(int line, string lineStr, int colAtEndOfNames, FSharpList`1<string> names);
    internal FSharpAssemblySignature get_PartialAssemblySignatureForFile();
    internal AccessorDomain get_AccessRights();
    internal FSharpProjectOptions get_ProjectOptions();
    internal FSharpList`1<FSharpAssembly> GetReferencedAssemblies();
    internal Tuple`2[] GetFormatSpecifierLocationsAndArity();
    internal SemanticClassificationItem[] GetSemanticClassification(FSharpOption`1<Range> range);
    internal TcResolutions get_ScopeResolutions();
    internal TcSymbolUses get_ScopeSymbolUses();
    internal TcGlobals get_TcGlobals();
    internal TcImports get_TcImports();
    internal ModuleOrNamespaceType get_CcuSigForFile();
    internal CcuThunk get_ThisCcu();
    internal FSharpOption`1<CheckedImplFile> get_ImplementationFile();
    internal OpenDeclaration[] get_OpenDeclarations();
    internal SymbolEnv get_SymbolEnv();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal Tuple`2<Tuple`2<NameResolutionEnv, AccessorDomain>, Range> GetBestEnvForPos(Position cursorPos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<ItemWithInst> FilterItemsForCtors(TypeNameResolutionFlag filterCtors, FSharpList`1<ItemWithInst> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal NameResResult ReturnItemsOfType(FSharpList`1<ItemWithInst> items, TcGlobals g, DisplayEnv denv, Range m, TypeNameResolutionFlag filterCtors);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal List`1<CapturedNameResolution> GetCapturedNameResolutions(Position endOfNamesPos, ResolveOverloads resolveOverloads);
    [CompilerGeneratedAttribute]
internal NameResResult GetPreciseItemsFromNameResolution(int line, int colAtEndOfNames, FSharpOption`1<a> membersByResidue, TypeNameResolutionFlag filterCtors, ResolveOverloads resolveOverloads);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<TType> TryGetTypeFromNameResolution(int line, int colAtEndOfNames, FSharpOption`1<a> membersByResidue, ResolveOverloads resolveOverloads);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<Item> CollectParameters(FSharpList`1<MethInfo> methods, ImportMap amap, Range m);
    [CompilerGeneratedAttribute]
internal NameResResult GetNamedParametersAndSettableFields(Position endOfExprPos);
    [CompilerGeneratedAttribute]
internal Tuple`2<bool, Tuple`4[]> GetExprTypingForPosition(Position endOfExprPos);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<Item>, DisplayEnv, Range>> GetRecdFieldsForCopyAndUpdateExpr(Range identRange, FSharpList`1<string> plid);
    [CompilerGeneratedAttribute]
internal ExprTypingsResult GetPreciseCompletionListFromExprTypings(FSharpParseFileResults parseResults, Position endOfExprPos, TypeNameResolutionFlag filterCtors);
    [CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, Range> GetEnvironmentLookupResolutions(NameResolutionEnv nenv, AccessorDomain ad, Range m, FSharpList`1<string> plid, TypeNameResolutionFlag filterCtors, bool showObsolete);
    [CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, Range> GetEnvironmentLookupResolutionsAtPosition(Position cursorPos, FSharpList`1<string> plid, TypeNameResolutionFlag filterCtors, bool showObsolete);
    [CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<ItemWithInst>, DisplayEnv, Range> GetClassOrRecordFieldsEnvironmentLookupResolutions(Position cursorPos, FSharpList`1<string> plid, bool fieldsOnly);
    [CompilerGeneratedAttribute]
internal bool IsInheritsCompletionCandidate(Item item);
    [CompilerGeneratedAttribute]
internal bool IsInterfaceCompletionCandidate(Item item);
    [CompilerGeneratedAttribute]
internal bool IsPatternCandidate(CompletionItem item);
    [CompilerGeneratedAttribute]
internal bool IsTypeCandidate(CompletionItem item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<a> FilterDeclItemsByResidue(FSharpFunc`2<a, Item> getItem, string residue, FSharpList`1<a> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<a>, a, b>> FilterRelevantItemsBy(FSharpFunc`2<a, Item> getItem, FSharpOption`1<string> exactMatchResidueOpt, FSharpFunc`2<a, bool> check, FSharpList`1<a> items, a denv, b m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<a>, b, c>> |FilterRelevantItems|_|(FSharpFunc`2<a, Item> getItem, FSharpOption`1<string> exactMatchResidueOpt, FSharpList`1<a> orig_0, b orig_1, c orig_2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<int> FindFirstNonWhitespacePosition(string lineStr, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal CompletionItem CompletionItem(FSharpValueOption`1<EntityRef> ty, FSharpValueOption`1<AssemblySymbol> assemblySymbol, ItemWithInst item);
    [CompilerGeneratedAttribute]
internal CompletionItem DefaultCompletionItem(ItemWithInst item);
    [CompilerGeneratedAttribute]
internal CompletionItem CompletionItemSuggestedName(string displayName);
    [CompilerGeneratedAttribute]
internal Item getItem(ItemWithInst x);
    [CompilerGeneratedAttribute]
internal Item getItem2(CompletionItem x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<CompletionItem> CreateCompletionItemForSuggestedPatternName(Position pos, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<CompletionItem> SuggestNameBasedOnType(TcGlobals g, Position pos, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpList`1<CompletionItem> SuggestNameForUnionCaseFieldPattern(TcGlobals g, Position caseIdPos, Position fieldPatternPos, UnionCaseInfo uci, FSharpChoice`2<FSharpOption`1<int>, string> indexOrName, bool isTheOnlyField, FSharpList`1<CompletionItem> completions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, Range>> GetOverridableMethods(Position pos, Range typeNameRange);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<FSharpList`1<CompletionItem>> GetUnionCaseFields(Range caseIdRange, FSharpList`1<string> alreadyReferencedFields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, Range>> GetCompletionsForUnionCaseField(Position pos, FSharpChoice`2<FSharpOption`1<int>, string> indexOrName, Range caseIdRange, bool isTheOnlyField, FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, Range>> declaredItems);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, a, b>> GetCompletionsForRecordField(Position pos, FSharpList`1<Tuple`2<string, Range>> referencedFields, FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, a, b>> declaredItems);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, Range>> GetDeclaredItems(FSharpOption`1<FSharpParseFileResults> parseResultsOpt, string lineStr, FSharpOption`1<FSharpList`1<string>> origLongIdentOpt, int colAtEndOfNamesAndResidue, FSharpOption`1<a> residueOpt, FSharpOption`1<int> lastDotPos, int line, int loc, TypeNameResolutionFlag filterCtors, ResolveOverloads resolveOverloads, bool isInRangeOperator, FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>> allSymbols);
    [CompilerGeneratedAttribute]
internal Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, Range> toCompletionItems(FSharpList`1<ItemWithInst> items, DisplayEnv denv, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, Range>> GetEnvironmentLookupResolutionsIncludingRecordFieldsAtPosition(Position cursorPos, FSharpList`1<string> plid, FSharpOption`1<Tuple`3<FSharpList`1<CompletionItem>, DisplayEnv, Range>> envItems);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`4<FSharpList`1<CompletionItem>, DisplayEnv, FSharpOption`1<CompletionContext>, Range>> GetDeclItemsForNamesAtPosition(FSharpOption`1<FSharpParseFileResults> parseResultsOpt, FSharpOption`1<FSharpList`1<string>> origLongIdentOpt, FSharpOption`1<string> residueOpt, FSharpOption`1<int> lastDotPos, int line, string lineStr, int colAtEndOfNamesAndResidue, TypeNameResolutionFlag filterCtors, ResolveOverloads resolveOverloads, FSharpOption`1<Tuple`2<Position, FSharpOption`1<CompletionContext>>> completionContextAtPos, FSharpFunc`2<Unit, FSharpList`1<AssemblySymbol>> getAllSymbols);
    [CompilerGeneratedAttribute]
internal bool IsValidSignatureFileItem(Item item);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.Utilities : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindFSharpStringAttribute(TcGlobals tcGlobals, BuiltinAttribInfo attribSpec, FSharpList`1<Attrib> attribs);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CodeAnalysis.ValueOption : object {
    internal static FSharpOption`1<a> toOption(FSharpValueOption`1<a> _arg1);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CompilerConfig : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpSigFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpMLCompatFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpImplFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpScriptFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> FSharpIndentationAwareSyntaxFileSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static bool FSharpExperimentalFeaturesEnabledAutomatically { get; }
    internal static FSharpList`1<string> get_FSharpSigFileSuffixes();
    internal static FSharpList`1<string> get_FSharpMLCompatFileSuffixes();
    internal static FSharpList`1<string> get_FSharpImplFileSuffixes();
    internal static FSharpList`1<string> get_FSharpScriptFileSuffixes();
    internal static FSharpList`1<string> get_FSharpIndentationAwareSyntaxFileSuffixes();
    internal static bool get_FSharpExperimentalFeaturesEnabledAutomatically();
    internal static FSharpOption`1<string> TryResolveFileUsingPaths(IEnumerable`1<string> paths, Range m, string fileName);
    internal static string ResolveFileUsingPaths(IEnumerable`1<string> paths, Range m, string fileName);
    internal static FSharpOption`1<int> GetWarningNumber(Range m, string warningNumber);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ComputeMakePathAbsolute(string implicitIncludeDir, string path);
    internal static string ext@870(TcConfigBuilder tcConfigB, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static bool contains@1-13(string absolutePath, a e, FSharpList`1<string> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-14(string path, a e, FSharpList`1<string> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-15(string dirName, a e, FSharpList`1<string> xs1);
    internal static Tuple`2<AssemblyReference, FSharpOption`1<string>> nameOfDll@1103(TcConfig this, AssemblyReference defaultCoreLibraryReference, AssemblyReference assemRef);
    internal static string GetFSharpCoreLibraryName();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CompilerDiagnostics : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Range> Exception.get_DiagnosticRange(Exception );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int Exception.get_DiagnosticNumber(Exception );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Range> PhasedDiagnostic.get_Range(PhasedDiagnostic );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int PhasedDiagnostic.get_Number(PhasedDiagnostic );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int PhasedDiagnostic.get_WarningLevel(PhasedDiagnostic );
    [CompilerGeneratedAttribute]
internal static bool contains@1-18(int n, a e, FSharpList`1<int> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PhasedDiagnostic.IsEnabled(PhasedDiagnostic x, FSharpDiagnosticSeverity severity, FSharpDiagnosticOptions options);
    [CompilerGeneratedAttribute]
internal static bool contains@1-19(int value, a e, FSharpList`1<int> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PhasedDiagnostic.ReportAsInfo(PhasedDiagnostic x, FSharpDiagnosticOptions options, FSharpDiagnosticSeverity severity);
    [CompilerGeneratedAttribute]
internal static bool contains@1-20(int value, a e, FSharpList`1<int> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-21(int n, a e, FSharpList`1<int> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-22(int n, a e, FSharpList`1<int> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PhasedDiagnostic.ReportAsWarning(PhasedDiagnostic x, FSharpDiagnosticOptions options, FSharpDiagnosticSeverity severity);
    [CompilerGeneratedAttribute]
internal static bool contains@1-23(int n, a e, FSharpList`1<int> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-24(int n, a e, FSharpList`1<int> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-25(int n, a e, FSharpList`1<int> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-26(int value, a e, FSharpList`1<int> xs1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PhasedDiagnostic.ReportAsError(PhasedDiagnostic x, FSharpDiagnosticOptions options, FSharpDiagnosticSeverity severity);
    internal static FSharpOption`1<string> |InvalidArgument|_|(Exception exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void OutputNameSuggestions(StringBuilder os, bool suggestNames, FSharpFunc`2<FSharpFunc`2<string, Unit>, Unit> suggestionsF, string idText);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void OutputTypesNotInEqualityRelationContextInfo(ContextInfo contextInfo, string ty1, string ty2, Range m, StringBuilder os, FSharpFunc`2<ContextInfo, Unit> fallback);
    [CompilerGeneratedAttribute]
internal static void Output$cont@746(StringBuilder os, FSharpList`1<TType> tl2, FSharpList`1<TType> tl1, Range m, ContextInfo contextInfo, string ty2, string ty1, string tpcs, int messageArgs_0, int messageArgs_2, Unit unitVar);
    internal static FSharpFunc`2<OverloadInformation, string> overloadMethodInfo@863(DisplayEnv displayEnv, Range m);
    internal static string formatOverloads@882(Range m, DisplayEnv denv, string nl, FSharpList`1<OverloadInformation> overloads);
    [CompilerGeneratedAttribute]
internal static void Output$cont@812-1(StringBuilder os, Range m, OverloadResolutionFailure failure, DisplayEnv denv, CallerArgs`1<Expr> callerArgs, Unit unitVar);
    internal static FSharpOption`1<Unit> |EndOfStructuredConstructToken|_|@1020(tokenId token);
    [CompilerGeneratedAttribute]
internal static string tokenIdToText$cont@1032(tokenId tid, Unit unitVar);
    internal static string tokenIdToText@1031(tokenId tid);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Expr|_|@1265(nonTerminalId nonTerminal);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Pattern|_|@1281(nonTerminalId nonTerminal);
    internal static FSharpOption`1<Unit> |NONTERM_Category_IfThenElse|_|@1289(nonTerminalId nonTerminal);
    internal static FSharpOption`1<Unit> |NONTERM_Category_SignatureFile|_|@1297(nonTerminalId nonTerminal);
    internal static FSharpOption`1<Unit> |NONTERM_Category_ImplementationFile|_|@1304(nonTerminalId nonTerminal);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Definition|_|@1311(nonTerminalId nonTerminal);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Type|_|@1320(nonTerminalId nonTerminal);
    internal static FSharpOption`1<Unit> |NONTERM_Category_Interaction|_|@1326(nonTerminalId nonTerminal);
    [CompilerGeneratedAttribute]
internal static bool foundInContext$cont@1353(StringBuilder os, FSharpList`1<nonTerminalId> prodIds, Unit unitVar);
    internal static string fix@1467(string s);
    [CompilerGeneratedAttribute]
internal static void Output$cont@1254-2(StringBuilder os, ParseErrorContext`1<token> ctxt, FSharpFunc`2<tokenId, string> tokenIdToText, FSharpOption`1<token> matchValue, Unit unitVar);
    internal static bool hasUnitTType_app@1530(TcGlobals g, FSharpList`1<TType> types);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void Exception.Output(Exception exn, StringBuilder os, bool suggestNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PhasedDiagnostic.OutputCore(PhasedDiagnostic x, StringBuilder os, bool flattenErrors, bool suggestNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string PhasedDiagnostic.FormatCore(PhasedDiagnostic x, bool flattenErrors, bool suggestNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PhasedDiagnostic PhasedDiagnostic.EagerlyFormatCore(PhasedDiagnostic x, bool suggestNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string SanitizeFileName(string fileName, string implicitIncludeDir);
    [CompilerGeneratedAttribute]
internal static FormattedDiagnosticLocation FormatDiagnosticLocation$cont@1996(TcConfig tcConfig, Range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FormattedDiagnosticLocation FormatDiagnosticLocation(TcConfig tcConfig, Range m);
    internal static void report@2071(TcConfig tcConfig, bool suggestNames, FSharpDiagnosticSeverity severity, List`1<FormattedDiagnostic> errors, PhasedDiagnostic diagnostic);
    internal static FormattedDiagnostic[] CollectFormattedDiagnostics(TcConfig tcConfig, FSharpDiagnosticSeverity severity, PhasedDiagnostic diagnostic, bool suggestNames);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PhasedDiagnostic.Output(PhasedDiagnostic diagnostic, StringBuilder buf, TcConfig tcConfig, FSharpDiagnosticSeverity severity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PhasedDiagnostic.OutputContext(PhasedDiagnostic diagnostic, StringBuilder buf, string prefix, FSharpFunc`2<string, FSharpFunc`2<int, string>> fileLineFunction);
    [CompilerGeneratedAttribute]
internal static void f@290-18(PhasedDiagnostic diagnostic, TcConfig tcConfig, FSharpDiagnosticSeverity severity, string prefix, FSharpFunc`2<string, FSharpFunc`2<int, string>> fileLineFunction, StringBuilder buf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PhasedDiagnostic.WriteWithContext(PhasedDiagnostic diagnostic, TextWriter os, string prefix, FSharpFunc`2<string, FSharpFunc`2<int, string>> fileLineFunction, TcConfig tcConfig, FSharpDiagnosticSeverity severity);
    internal static DiagnosticsLogger GetDiagnosticsLoggerFilteringByScopedPragmas(bool checkFile, FSharpList`1<ScopedPragma> scopedPragmas, FSharpDiagnosticOptions diagnosticOptions, DiagnosticsLogger diagnosticsLogger);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.CompilerEnvironment : object {
    internal static FSharpList`1<string> compilableExtensions;
    internal static FSharpList`1<string> singleFileProjectExtensions;
    internal static int init@1801-3;
    private static CompilerEnvironment();
    public static FSharpOption`1<string> BinFolderOfDefaultFSharpCompiler(FSharpOption`1<string> probePoint);
    public static FSharpList`1<string> DefaultReferencesForOrphanSources(bool assumeDotNetFramework);
    public static FSharpList`1<string> GetConditionalDefinesForEditing(FSharpParsingOptions parsingOptions);
    public static bool IsCheckerSupportedSubcategory(string subcategory);
    public static Guid GetDebuggerLanguageID();
    public static bool IsScriptFile(string fileName);
    public static bool IsCompilable(string file);
    public static bool MustBeSingleFileProject(string file);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CompilerGlobalState : object {
    [CompilationMappingAttribute("9")]
internal static long uniqueCount { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, long> newUnique { get; }
    [CompilationMappingAttribute("9")]
internal static long stampCount { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, long> newStamp { get; }
    internal static long get_uniqueCount();
    internal static void set_uniqueCount(long value);
    internal static FSharpFunc`2<Unit, long> get_newUnique();
    internal static long get_stampCount();
    internal static void set_stampCount(long value);
    internal static FSharpFunc`2<Unit, long> get_newStamp();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CompilerImports : object {
    internal static bool IsSignatureDataResource(ILResource r);
    internal static bool IsOptimizationDataResource(ILResource r);
    internal static ReadOnlyByteMemory decompressResource(ILResource r);
    internal static Tuple`2<string, FSharpFunc`2<Unit, ReadOnlyByteMemory>> GetResourceNameAndSignatureDataFunc(ILResource r);
    internal static Tuple`2<string, FSharpFunc`2<Unit, ReadOnlyByteMemory>> GetResourceNameAndOptimizationDataFunc(ILResource r);
    internal static bool IsReflectedDefinitionsResource(ILResource r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILResource PickleToResource(bool inMem, string file, TcGlobals g, bool compress, CcuThunk scope, string rName, FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> p, a x);
    internal static ILResource WriteSignatureData(TcConfig tcConfig, TcGlobals tcGlobals, Remap exportRemapping, CcuThunk ccu, string fileName, bool inMem);
    internal static ILResource WriteOptimizationData(TcConfig tcConfig, TcGlobals tcGlobals, string fileName, bool inMem, CcuThunk ccu, Lazy`1<ModuleInfo> modulInfo);
    internal static Tuple`2<FSharpList`1<ILAttribute>, FSharpList`1<ILResource>> EncodeSignatureData(TcConfig tcConfig, TcGlobals tcGlobals, Remap exportRemapping, CcuThunk generatedCcu, string outfile, bool isIncrementalBuild);
    internal static FSharpList`1<ILResource> EncodeOptimizationData(TcGlobals tcGlobals, TcConfig tcConfig, string outfile, Remap exportRemapping, Tuple`2<CcuThunk, a> data, bool isIncrementalBuild);
    internal static ILModuleReader OpenILBinary(string fileName, ReduceMemoryFlag reduceMemoryUsage, FSharpOption`1<string> pdbDirPath, bool shadowCopyReferences, FSharpFunc`2<Tuple`2<string, DateTime>, FSharpOption`1<Tuple`3<object, IntPtr, int>>> tryGetMetadataSnapshot);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@317-9(IEqualityComparer comp, ImportedBinary this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@317-14(ImportedBinary this, object obj, IEqualityComparer comp, Unit unitVar);
    internal static bool isHashRReference(Range r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<AssemblyResolution> TcConfig.TryResolveLibWithDirectories(TcConfig tcConfig, AssemblyReference r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<AssemblyResolution> TcConfig.ResolveLibWithDirectories(TcConfig tcConfig, CcuLoadFailureAction ccuLoadFailureAction, AssemblyReference r);
    internal static FSharpFunc`2<string, Unit> logMessage@460(TcConfig tcConfig, bool showMessages);
    internal static FSharpFunc`2<bool, FSharpFunc`2<string, FSharpFunc`2<string, Unit>>> logDiagnostic@466(b _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LegacyResolvedFile[] TcConfig.MsBuildResolve(TcConfig tcConfig, Tuple`2[] references, a _arg1, Range errorAndWarningRange, bool showMessages);
    internal static bool IsResolved@585(TcConfig tcConfig, Range errorAndWarningRange, ResolveAssemblyReferenceMode mode, FSharpList`1<AssemblyResolution> resultingResolutions, string originalName);
    internal static Tuple`2<FSharpList`1<AssemblyResolution>, FSharpList`1<UnresolvedAssemblyReference>> TcConfig.TryResolveLibsUsingMSBuildRules.Static(TcConfig tcConfig, FSharpList`1<AssemblyReference> originalReferences, Range errorAndWarningRange, ResolveAssemblyReferenceMode mode);
    internal static string GetNameOfILModule(ILModuleDef m);
    internal static ILScopeRef MakeScopeRefForILModule(ILModuleDef ilModule);
    internal static FSharpList`1<ILAttribute> GetCustomAttributesOfILModule(ILModuleDef ilModule);
    [CompilerGeneratedAttribute]
internal static bool contains@1-16(string ilShortAssemName, a e, FSharpList`1<string> xs1);
    [CompilerGeneratedAttribute]
internal static bool contains@1-17(string ilShortAssemName, a e, FSharpList`1<string> xs1);
    internal static FSharpOption`1<ImportedBinary> look@1259-10(string assemblyName, TcImports t);
    internal static FSharpOption`1<ImportedAssembly> look@1301-11(string assemblyName, TcImports t);
    internal static FSharpOption`1<ImportedAssembly> look@1335-12(string assemblyName, TcImports t);
    internal static void loop@1865-85(TcImports tcImportsStrong, TcConfig tcConfig, Range m, Entity entityToInjectInto, ResolutionEnvironment typeProviderEnvironment, Tainted`1<ITypeProvider> provider, Tainted`1<IProvidedNamespace> providedNamespace);
    internal static Lazy`1<ModuleInfo> fixupThunk@2059(TcImports tcImports, Range m, CompilationThreadToken ctok, PickledDataWithReferences`1<Lazy`1<ModuleInfo>> data, Unit unitVar0);
    internal static void fixupThunk@2117-2(TcImports tcImports, Range m, CompilationThreadToken ctok, PickledDataWithReferences`1<PickledCcuInfo> data, Unit unitVar0);
    internal static bool tryFile@2250(TcImports tcImports, Range m, CompilationThreadToken ctok, string speculativeFileName);
    internal static void reportAssemblyNotResolved@2516(string file, FSharpList`1<AssemblyReference> originalReferences);
    internal static Tuple`2<TcEnv, FSharpList`1<ImportedAssembly>> RequireReferences(CompilationThreadToken ctok, TcImports tcImports, TcEnv tcEnv, string thisAssemblyName, FSharpList`1<AssemblyResolution> resolutions);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CompilerOptions : object {
    [CompilationMappingAttribute("9")]
internal static string nl { get; }
    [CompilationMappingAttribute("9")]
internal static bool enableConsoleColoring { get; internal set; }
    internal static string tagString { get; }
    internal static string tagExe { get; }
    internal static string tagWinExe { get; }
    internal static string tagLibrary { get; }
    internal static string tagModule { get; }
    internal static string tagFile { get; }
    internal static string tagFileList { get; }
    internal static string tagDirList { get; }
    internal static string tagResInfo { get; }
    internal static string tagFullPDBOnlyPortable { get; }
    internal static string tagWarnList { get; }
    internal static string tagAddress { get; }
    internal static string tagAlgorithm { get; }
    internal static string tagInt { get; }
    internal static string tagPathMap { get; }
    internal static string tagNone { get; }
    internal static string tagLangVersionValues { get; }
    [CompilationMappingAttribute("9")]
internal static CompilerOption compilingFsLib20Flag { get; }
    [CompilationMappingAttribute("9")]
internal static CompilerOption compilingFsLib40Flag { get; }
    [CompilationMappingAttribute("9")]
internal static CompilerOption compilingFsLibNoBigIntFlag { get; }
    [CompilationMappingAttribute("9")]
internal static CompilerOption mlKeywordsFlag { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<TcConfig, FSharpFunc`2<string, Unit>> ReportTime { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<FSharpOption`1<Tuple`2<string, IDisposable>>> nPrev@2369 { get; }
    internal static FSharpList`1<CompilerOption> GetOptionsOfBlock(CompilerOptionBlock block);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompilerOptionBlock FilterCompilerOptionBlock(FSharpFunc`2<CompilerOption, bool> pred, CompilerOptionBlock block);
    internal static string compilerOptionUsage(CompilerOption _arg1);
    internal static string get_nl();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getCompilerOption(CompilerOption compilerOption, FSharpOption`1<int> width);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getPublicOptions(a heading, FSharpList`1<CompilerOption> opts, FSharpOption`1<int> width);
    internal static FSharpFunc`2<FSharpSet`1<string>, FSharpFunc`2<Tuple`2<string, a>, FSharpSet`1<string>>> consider@183(FSharpOption`1<int> width, StringBuilder sb, FSharpList`1<Tuple`2<string, FSharpList`1<CompilerOption>>> publicBlocks);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string GetCompilerOptionBlocks(FSharpList`1<CompilerOptionBlock> blocks, FSharpOption`1<int> width);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void dumpCompilerOption(string prefix, CompilerOption _arg1);
    internal static void dumpCompilerOptionBlock(CompilerOptionBlock _arg1);
    internal static void DumpCompilerOptionBlocks(FSharpList`1<CompilerOptionBlock> blocks);
    internal static bool isSlashOpt(string opt);
    [CompilerGeneratedAttribute]
internal static string opt$cont@284(string option, Unit unitVar);
    internal static Tuple`3<string, string, string> parseOption@266(string option);
    internal static string getOptionArg@300(CompilerOption compilerOption, string argString);
    internal static FSharpList`1<string> getOptionArgList@306(CompilerOption compilerOption, string argString);
    internal static string getSwitchOpt@313(string opt);
    internal static OptionSwitch getSwitch@324(string s);
    internal static void reportDeprecatedOption@367(FSharpOption`1<a> errOpt);
    internal static FSharpList`1<string> attempt@372(FSharpFunc`2<string, Unit> collectOtherArgument, FSharpList`1<CompilerOptionBlock> blocks, FSharpList`1<string> args, FSharpList`1<string> t, string opt, string option, string optToken, string argString, FSharpList`1<CompilerOption> l);
    internal static void processArg@332(FSharpFunc`2<string, Unit> collectOtherArgument, FSharpList`1<CompilerOptionBlock> blocks, FSharpList`1<CompilerOption> specs, FSharpList`1<string> args);
    internal static void ParseCompilerOptions(FSharpFunc`2<string, Unit> collectOtherArgument, FSharpList`1<CompilerOptionBlock> blocks, FSharpList`1<string> args);
    internal static bool get_enableConsoleColoring();
    internal static void set_enableConsoleColoring(bool value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a setFlag(FSharpFunc`2<bool, a> r, int n);
    internal static void SetOptimizeOff(TcConfigBuilder tcConfigB);
    internal static void SetOptimizeOn(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetOptimizeSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetTailcallSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetDeterministicSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetReferenceAssemblyOnlySwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetReferenceAssemblyOutSwitch(TcConfigBuilder tcConfigB, string outputPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddPathMapping(TcConfigBuilder tcConfigB, string pathPair);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void jitoptimizeSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void localoptimizeSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void crossOptimizeSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void splittingSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void callVirtSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void useHighEntropyVASwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilerGeneratedAttribute]
internal static void subSystemVersionSwitch$cont@633(TcConfigBuilder tcConfigB, string text, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void subSystemVersionSwitch(TcConfigBuilder tcConfigB, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetUseSdkSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetTarget(TcConfigBuilder tcConfigB, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetDebugSwitch(TcConfigBuilder tcConfigB, FSharpOption`1<string> dtype, OptionSwitch s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetEmbedAllSourceSwitch(TcConfigBuilder tcConfigB, OptionSwitch switch);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void setOutFileName(TcConfigBuilder tcConfigB, string path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagExe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagWinExe();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagLibrary();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagFileList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagDirList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagResInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagFullPDBOnlyPortable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagWarnList();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagAddress();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagAlgorithm();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagPathMap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagNone();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_tagLangVersionValues();
    internal static void PrintOptionInfo(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> inputFileFlagsBoth(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> inputFileFlagsFsiBase(TcConfigBuilder _tcConfigB);
    internal static string trimFS@774(string s);
    internal static FSharpOption`1<int> trimFStoInt@777(string s);
    internal static FSharpList`1<CompilerOption> errorsAndWarningsFlags(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> outputFileFlagsFsc(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> resourcesFlagsFsc(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<CompilerOption> codeGenerationFlags(bool isFsi, TcConfigBuilder tcConfigB);
    internal static CompilerOption mlCompatibilityFlag(TcConfigBuilder tcConfigB);
    internal static string GetLanguageVersions();
    internal static LanguageVersion setLanguageVersion(string specifiedVersion);
    internal static FSharpList`1<CompilerOption> languageFlags(TcConfigBuilder tcConfigB);
    internal static CompilerOption libFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption codePageFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption preferredUiLang(TcConfigBuilder tcConfigB);
    internal static CompilerOption utf8OutputFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption fullPathsFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption cliRootFlag(TcConfigBuilder _tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetTargetProfile(TcConfigBuilder tcConfigB, string v);
    internal static FSharpList`1<CompilerOption> advancedFlagsBoth(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompilerOption noFrameworkFlag(bool isFsc, TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> advancedFlagsFsi(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> advancedFlagsFsc(TcConfigBuilder tcConfigB);
    internal static CompilerOption testFlag(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> editorSpecificFlags(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> internalFlags(TcConfigBuilder tcConfigB);
    internal static CompilerOption compilingFsLibFlag(TcConfigBuilder tcConfigB);
    internal static CompilerOption get_compilingFsLib20Flag();
    internal static CompilerOption get_compilingFsLib40Flag();
    internal static CompilerOption get_compilingFsLibNoBigIntFlag();
    internal static CompilerOption get_mlKeywordsFlag();
    internal static CompilerOption gnuStyleErrorsFlag(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> deprecatedFlagsBoth(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> deprecatedFlagsFsi(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> deprecatedFlagsFsc(TcConfigBuilder tcConfigB);
    internal static string GetBannerText(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string GetHelpFsc(TcConfigBuilder tcConfigB, FSharpList`1<CompilerOptionBlock> blocks);
    internal static string GetVersion(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> miscFlagsBoth(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> miscFlagsFsc(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> abbreviatedFlagsBoth(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOption> abbreviatedFlagsFsc(TcConfigBuilder tcConfigB);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpSet`1<string> GetAbbrevFlagSet(TcConfigBuilder tcConfigB, bool isFsc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> PostProcessCompilerArgs(FSharpSet`1<string> abbrevArgs, String[] args);
    internal static FSharpList`1<CompilerOption> testingAndQAFlags(a _tcConfigB);
    internal static FSharpList`1<CompilerOptionBlock> GetCoreFscCompilerOptions(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOptionBlock> GetCoreServiceCompilerOptions(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<CompilerOptionBlock> GetCoreFsiCompilerOptions(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<string> CheckAndReportSourceFileDuplicates(List`1<string> sourceFiles);
    internal static FSharpList`1<string> ApplyCommandLineArgs(TcConfigBuilder tcConfigB, FSharpList`1<string> sourceFiles, FSharpList`1<string> argv);
    internal static void SimulateException(FSharpOption`1<string> simulateConfig);
    internal static FSharpFunc`2<TcConfig, FSharpFunc`2<string, Unit>> get_ReportTime();
    internal static FSharpRef`1<FSharpOption`1<Tuple`2<string, IDisposable>>> get_nPrev@2369();
    internal static void ignoreFailureOnMono1_1_16(FSharpFunc`2<Unit, Unit> f);
    internal static FSharpOption`1<Tuple`2<ConsoleColor, ConsoleColor>> foreBackColor();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T DoWithColor(ConsoleColor newColor, FSharpFunc`2<Unit, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T DoWithDiagnosticColor(FSharpDiagnosticSeverity severity, FSharpFunc`2<Unit, T> f);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.ConstraintSolver : object {
    [CompilationMappingAttribute("9")]
internal static Ident compgenId { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> BakedInTraitConstraintNames { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> arg@1-3 { get; }
    [CompilationMappingAttribute("9")]
internal static OperationResult`1<Unit> localAbortD { get; }
    internal static Ident get_compgenId();
    internal static Typar NewCompGenTypar(TyparKind kind, TyparRigidity rigid, TyparStaticReq staticReq, TyparDynamicReq dynamicReq, bool error);
    internal static Typar NewAnonTypar(TyparKind kind, Range m, TyparRigidity rigid, TyparStaticReq var, TyparDynamicReq dyn);
    internal static Typar NewNamedInferenceMeasureVar(a _m, TyparRigidity rigid, TyparStaticReq var, Ident id);
    internal static Typar NewInferenceMeasurePar();
    internal static Typar NewErrorTypar();
    internal static Typar NewErrorMeasureVar();
    internal static TType NewInferenceType(TcGlobals g);
    internal static TType NewErrorType();
    internal static Measure NewErrorMeasure();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType NewByRefKindInferenceType(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> NewInferenceTypes(TcGlobals g, FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar FreshenTypar(TcGlobals g, TyparRigidity rigid, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>> FreshenAndFixupTypars(TcGlobals g, Range m, TyparRigidity rigid, FSharpList`1<Typar> fctps, FSharpList`1<TType> tinst, FSharpList`1<Typar> tpsorig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>> FreshenTypeInst(TcGlobals g, Range m, FSharpList`1<Typar> tpsorig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> FreshenTypars(TcGlobals g, Range m, FSharpList`1<Typar> tpsorig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> FreshenMethInfo(Range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool occursCheck(TcGlobals g, Typar un, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNativeIntegerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsIntegerOrIntegerEnumTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNonDecimalNumericOrIntegralEnumType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNumericOrIntegralEnumType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsRelationalType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsCharOrStringType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsAddSubModType(string nm, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsBitwiseOpType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsBinaryOpOtherArgType(TcGlobals g, PermitWeakResolution permitWeakResolution, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsSignType(TcGlobals g, TType ty);
    internal static FSharpSet`1<string> get_BakedInTraitConstraintNames();
    internal static FSharpList`1<string> get_arg@1-3();
    internal static a CollectThenUndo(FSharpFunc`2<Trace, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`4<a, FSharpList`1<Exception>, Trace, b>> FilterEachThenUndo(FSharpFunc`2<Trace, FSharpFunc`2<a, OperationResult`1<b>>> f, FSharpList`1<a> meths);
    internal static string ShowAccessDomain(AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> IgnoreFailedMemberConstraintResolution(FSharpFunc`2<Unit, OperationResult`1<Unit>> f1, FSharpFunc`2<Exception, OperationResult`1<Unit>> f2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> PostponeOnFailedMemberConstraintResolution(ConstraintSolverEnv csenv, OptionalTrace trace, FSharpFunc`2<ConstraintSolverEnv, OperationResult`1<Unit>> f1, FSharpFunc`2<Exception, OperationResult`1<Unit>> f2);
    internal static OperationResult`1<Unit> get_localAbortD();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PreferUnifyTypar(Typar v1, Typar v2);
    internal static FSharpList`1<Tuple`2<Typar, b>> find@649-1(FSharpList`1<Tuple`2<Typar, b>> vs);
    internal static FSharpList`1<Tuple`2<Typar, a>> FindPreferredTypar(FSharpList`1<Tuple`2<Typar, a>> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SubstMeasure(Typar r, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> TransactStaticReq(ConstraintSolverEnv csenv, OptionalTrace trace, Typar tpr, TyparStaticReq req);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypStaticReqTypar(ConstraintSolverEnv csenv, OptionalTrace trace, TyparStaticReq req, Typar tpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypStaticReq(ConstraintSolverEnv csenv, OptionalTrace trace, TyparStaticReq req, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> TransactDynamicReq(OptionalTrace trace, Typar tpr, TyparDynamicReq req);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypDynamicReq(ConstraintSolverEnv csenv, OptionalTrace trace, TyparDynamicReq req, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> TransactIsCompatFlex(OptionalTrace trace, Typar tpr, bool req);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypIsCompatFlex(ConstraintSolverEnv csenv, OptionalTrace trace, bool req, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-4(ConstraintSolverEnv csenv, Typar v, Measure ms, FSharpOption`1<string> tpnmOpt, Unit _arg1);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-5(ConstraintSolverEnv csenv, Typar v, Measure ms, Unit _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SubstMeasureWarnIfRigid(ConstraintSolverEnv csenv, OptionalTrace trace, Typar v, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsRigid(ConstraintSolverEnv csenv, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> UnifyMeasureWithOne(ConstraintSolverEnv csenv, OptionalTrace trace, Measure ms);
    internal static Tuple`2<FSharpList`1<Typar>, FSharpOption`1<Typar>> simp@785(TcGlobals g, Measure ms, FSharpList`1<Typar> vars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpOption`1<Typar>> SimplifyMeasure(TcGlobals g, FSharpList`1<Typar> vars, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpList`1<Typar>> SimplifyMeasuresInType(TcGlobals g, bool resultFirst, FSharpList`1<Typar> generalizable, FSharpList`1<Typar> generalized, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpList`1<Typar>> SimplifyMeasuresInTypes(TcGlobals g, FSharpList`1<Typar> param_0, FSharpList`1<Typar> param_1, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpList`1<Typar>> SimplifyMeasuresInConstraint(TcGlobals g, FSharpList`1<Typar> param_0, FSharpList`1<Typar> param_1, TyparConstraint c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, FSharpList`1<Typar>> SimplifyMeasuresInConstraints(TcGlobals g, FSharpList`1<Typar> param_0, FSharpList`1<Typar> param_1, FSharpList`1<TyparConstraint> cs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational GetMeasureVarGcdInType(Typar v, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational GetMeasureVarGcdInTypes(Typar v, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> NormalizeExponentsInTypeScheme(FSharpList`1<Typar> uvars, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> SimplifyMeasuresInTypeScheme(TcGlobals g, bool resultFirst, FSharpList`1<Typar> generalizable, TType ty, FSharpList`1<TyparConstraint> constraints);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> CheckWarnIfRigid(ConstraintSolverEnv csenv, TType ty1, Typar r, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-6(OptionalTrace trace, Typar r, TType ty, Unit _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTyparEqualsTypePart1(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, TType ty1, Typar r, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> SolveTyparEqualsTypePart2$cont@974(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, Typar r, TType ty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTyparEqualsTypePart2(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, Typar r, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-4(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, Typar r, TcGlobals g, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-9(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, Typar r, TcGlobals g, Unit _arg5);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-8(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, Typar r, TcGlobals g, Unit _arg4);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-7(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, Typar r, TcGlobals g, Unit _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypMeetsTyparConstraints(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, Typar r);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-11(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, Typar r, Unit _arg10);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-10(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty1, TType ty, Unit _arg9);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTyparEqualsType(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty1, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-12(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpList`1<TType> tpTys, FSharpList`1<TType> tys, Unit _arg12);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTyparsEqualTypes(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpList`1<TType> tpTys, FSharpList`1<TType> tys);
    internal static FSharpChoice`4<FSharpList`1<l>, FSharpList`1<l>, Tuple`2<FSharpList`1<l>, FSharpList`1<l>>, Tuple`2<FSharpList`1<l>, FSharpList`1<l>>> |Subset|Superset|Overlap|CompletelyDifferent|@1070(Tuple`2<IEnumerable`1<l>, IEnumerable`1<l>> tupledArg);
    [CompilerGeneratedAttribute]
internal static string message$cont@1109(Tuple`2<FSharpList`1<string>, FSharpList`1<string>> missingFields, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> SolveAnonInfoEqualsAnonInfo$cont@1070-1(ConstraintSolverEnv csenv, Range m2, AnonRecdTypeInfo anonInfo1, AnonRecdTypeInfo anonInfo2, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-5(ConstraintSolverEnv csenv, Range m2, AnonRecdTypeInfo anonInfo1, AnonRecdTypeInfo anonInfo2, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> SolveAnonInfoEqualsAnonInfo$cont@1066(ConstraintSolverEnv csenv, Range m2, AnonRecdTypeInfo anonInfo1, AnonRecdTypeInfo anonInfo2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveAnonInfoEqualsAnonInfo(ConstraintSolverEnv csenv, Range m2, AnonRecdTypeInfo anonInfo1, AnonRecdTypeInfo anonInfo2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-13(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, FSharpList`1<TType> l2, FSharpList`1<TType> l1, Unit _arg17);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsType(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsTypeKeepAbbrevs(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsTypeKeepAbbrevsWithCxsln(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-14(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, FSharpList`1<TType> origl1, FSharpList`1<TType> origl2, FSharpList`1<TType> t2, FSharpList`1<TType> t1, Unit _arg20);
    internal static OperationResult`1<Unit> loop@1231-64(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, FSharpList`1<TType> origl1, FSharpList`1<TType> origl2, FSharpList`1<TType> l1, FSharpList`1<TType> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsTypeEqns(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, FSharpList`1<TType> origl1, FSharpList`1<TType> origl2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-15(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType rangeTy1, TType rangeTy2, Unit _arg22);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveFunTypeEqn(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType domainTy1, TType domainTy2, TType rangeTy1, TType rangeTy2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-16(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, int ndeep, FSharpList`1<TType> l2, FSharpList`1<TType> l1, Unit _arg23);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-17(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, int ndeep, TcGlobals g, bool canShortcut, TType tag2, TType tag1, Unit _arg25);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSubsumesType(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSubsumesTypeKeepAbbrevs(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTyparSubtypeOfType(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, Typar tp, TType ty1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> DepthCheck(int ndeep, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveDimensionlessNumericType(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty);
    internal static bool checkRuleAppliesInPreferenceToMethods@1471(PermitWeakResolution permitWeakResolution, TcGlobals g, FSharpList`1<Tuple`2<TType, MethInfo>> minfos, TType argTy1, TType argTy2);
    internal static bool checkRuleAppliesInPreferenceToMethods@1471-1(PermitWeakResolution permitWeakResolution, TcGlobals g, FSharpList`1<Tuple`2<TType, MethInfo>> minfos, TType argTy1, TType argTy2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-19(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, string nm, int ndeep, TType retTy, EntityRef tcref, Measure ms1, Measure ms2, Unit _arg32);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-20(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, string nm, int ndeep, TType retTy, EntityRef tcref, Measure ms2, Measure ms1, Unit _arg34);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-21(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType argTy1, Unit _arg36);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-22(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType argTy1, Unit _arg38);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-23(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, TcGlobals g, int ndeep, TType retTy, Unit _arg40);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-24(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType ty, Unit _arg43);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-25(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType argTy1, Unit _arg45);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-26(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, TcGlobals g, int ndeep, TType retTy, Unit _arg47);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> expr2@695-9(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, TcGlobals g, int ndeep, TType retTy, TType ty, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> expr2@695-8(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, TcGlobals g, int ndeep, TType retTy, TType ty, FSharpList`1<TType> argTys, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> expr2@695-11(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, TcGlobals g, int ndeep, TType ty, TType lastTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> expr2@695-10(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, TcGlobals g, int ndeep, TType ty, FSharpList`1<TType> argTys, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-28(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType argTy1, Unit _arg58);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-27(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType argTy1, Unit _arg57);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-30(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType argTy1, Unit _arg61);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-29(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType argTy1, Unit _arg60);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-31(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType argTy, Unit _arg66);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-32(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, EntityRef tcref, Measure ms1, Unit _arg69);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-33(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType argTy, Unit _arg72);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-35(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType argTy1, Unit _arg75);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-34(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, int ndeep, TType retTy, TType argTy2, TType argTy1, Unit _arg74);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-36(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, TcGlobals g, int ndeep, TType retTy, TType argTy1, Unit _arg77);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> SolveMemberConstraint$cont@1744(Range m2, string nm, Range m, DisplayEnv denv, FSharpList`1<TType> supportTys, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-37(FSharpList`1<TType> tinst, int i, AnonRecdTypeInfo anonInfo, Unit _arg80);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-38(RecdFieldInfo rfinfo, bool isSetProp, Unit _arg81);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-40(CalledMeth`1<Expr> calledMeth, MethInfo minfo, Unit _arg83);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TraitConstraintSolution> k@691-39(Range m2, string nm, SynMemberFlags memFlags, TcGlobals g, Range m, DisplayEnv denv, CalledMeth`1<Expr> calledMeth, MethInfo minfo, Unit _arg82);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<bool> expr2@695-7(ConstraintSolverEnv csenv, bool ignoreUnresolvedOverload, PermitWeakResolution permitWeakResolution, Range m2, OptionalTrace trace, FSharpList`1<TType> traitObjAndArgTys, string nm, SynMemberFlags memFlags, TcGlobals g, Range m, ImportMap amap, DisplayEnv denv, int ndeep, FSharpList`1<TType> supportTys, TraitConstraintInfo traitInfo, TType retTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<bool> expr2@695-6(ConstraintSolverEnv csenv, bool ignoreUnresolvedOverload, PermitWeakResolution permitWeakResolution, Range m2, OptionalTrace trace, FSharpList`1<TType> traitObjAndArgTys, string nm, SynMemberFlags memFlags, TcGlobals g, Range m, ImportMap amap, DisplayEnv denv, int ndeep, FSharpList`1<TType> supportTys, TraitConstraintInfo traitInfo, TType retTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<bool> k@691-18(ConstraintSolverEnv csenv, bool ignoreUnresolvedOverload, PermitWeakResolution permitWeakResolution, Range m2, OptionalTrace trace, FSharpList`1<TType> traitObjAndArgTys, FSharpList`1<TType> supportTys, FSharpRef`1<FSharpOption`1<TraitConstraintSln>> sln, FSharpOption`1<TType> retTy, string nm, SynMemberFlags memFlags, TcGlobals g, Range m, ImportMap amap, TypeEquivEnv aenv, DisplayEnv denv, int ndeep, Unit _arg27);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> SolveMemberConstraint(ConstraintSolverEnv csenv, bool ignoreUnresolvedOverload, PermitWeakResolution permitWeakResolution, int ndeep, Range m2, OptionalTrace trace, TraitConstraintInfo traitInfo);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-13(ConstraintSolverEnv csenv, bool ignoreUnresolvedOverload, OperationResult`1<Unit> errors, string nm, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-12(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, PermitWeakResolution permitWeakResolution, bool ignoreUnresolvedOverload, TraitConstraintInfo traitInfo, OperationResult`1<Unit> errors, string nm, FSharpList`1<Typar> supportTypars, FSharpList`1<Typar> frees, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> AddUnsolvedMemberConstraint(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, PermitWeakResolution permitWeakResolution, bool ignoreUnresolvedOverload, TraitConstraintInfo traitInfo, OperationResult`1<Unit> errors);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> RecordMemberConstraintSolution(ConstraintSolverState css, Range m, OptionalTrace trace, TraitConstraintInfo traitInfo, TraitConstraintSolution traitConstraintSln);
    [CompilerGeneratedAttribute]
internal static TraitConstraintSln MemberConstraintSolutionOfMethInfo$cont@1899(ConstraintSolverState css, MethInfo minfo, FSharpOption`1<TType> staticTyOpt, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TraitConstraintSln MemberConstraintSolutionOfMethInfo(ConstraintSolverState css, Range m, MethInfo minfo, FSharpList`1<TType> minst, FSharpOption`1<TType> staticTyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void TransactMemberConstraintSolution(TraitConstraintInfo traitInfo, OptionalTrace trace, TraitConstraintSln sln);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TType, MethInfo>> GetRelevantMethodsForTrait(ConstraintSolverEnv csenv, PermitWeakResolution permitWeakResolution, string nm, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> GetTyparSupportOfMemberConstraint(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TType, TType>> GetNominalSupportOfMemberConstraint(ConstraintSolverEnv csenv, string nm, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool SupportTypeHasInterfaceWithMatchingStaticAbstractMember(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo, Typar supportTyPar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool SupportTypeOfMemberConstraintIsSolved(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo, Typar supportTypar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> GetFreeTyparsOfMemberConstraint(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberConstraintIsReadyForWeakResolution(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberConstraintIsReadyForStrongResolution(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberConstraintSupportIsReadyForDeterminingOverloads(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool SupportOfMemberConstraintIsFullySolved(ConstraintSolverEnv csenv, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveRelevantMemberConstraints(ConstraintSolverEnv csenv, int ndeep, PermitWeakResolution permitWeakResolution, OptionalTrace trace, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> SolveRelevantMemberConstraintsForTypar(ConstraintSolverEnv csenv, int ndeep, PermitWeakResolution permitWeakResolution, OptionalTrace trace, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> AddMemberConstraint(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TraitConstraintInfo traitInfo, FSharpList`1<Typar> support, FSharpList`1<Typar> frees);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TraitsAreRelated(ConstraintSolverEnv csenv, bool retry, TraitConstraintInfo traitInfo1, TraitConstraintInfo traitInfo2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-41(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TcGlobals g, FSharpOption`1<TType> rty1, FSharpOption`1<TType> rty2, Unit _arg95);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-14(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TcGlobals g, FSharpOption`1<TType> rty1, FSharpList`1<TType> argTys1, FSharpOption`1<TType> rty2, FSharpList`1<TType> argTys2, Unit unitVar);
    internal static FSharpList`1<TType> collect@2151(TcGlobals g, ImportMap amap, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> EnforceConstraintConsistency(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, bool retry, TyparConstraint tpc1, TyparConstraint tpc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckConstraintImplication(ConstraintSolverEnv csenv, TyparConstraint tpc1, TyparConstraint tpc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckConstraintsImplication(ConstraintSolverEnv csenv, FSharpList`1<TyparConstraint> existingConstraints, TyparConstraint newConstraint);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-42(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, bool retry, FSharpList`1<TyparConstraint> allCxs, int i, FSharpList`1<TyparConstraint> rest, Unit _arg101);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> EnforceConstraintSetConsistency(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, bool retry, FSharpList`1<TyparConstraint> allCxs, int i, FSharpList`1<TyparConstraint> cxs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TyparConstraint> EliminateRedundantConstraints(ConstraintSolverEnv csenv, FSharpList`1<TyparConstraint> cxs, FSharpList`1<TyparConstraint> acc);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-16(ConstraintSolverEnv csenv, OptionalTrace trace, Typar tp, FSharpList`1<TyparConstraint> allCxs, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-15(ConstraintSolverEnv csenv, Range m2, OptionalTrace trace, Typar tp, TyparConstraint newConstraint, DisplayEnv denv, Range m, FSharpList`1<TyparConstraint> allCxs, FSharpRef`1<bool> impliedByExistingConstraints, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-43(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, Typar tp, TyparConstraint newConstraint, DisplayEnv denv, Range m, TcGlobals g, FSharpList`1<TyparConstraint> existingConstraints, FSharpList`1<TyparConstraint> allCxs, Unit _arg102);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> AddConstraint(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, Typar tp, TyparConstraint newConstraint);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeUseSupportsNull(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSupportsComparison(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSupportsEquality(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsEnum(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, TType underlying);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-44(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType bty, TType retTy, Unit _arg105);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsDelegate(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, TType aty, TType bty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsNonNullableValueType(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsUnmanaged(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> expr2@695-17(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, FSharpList`1<TType> choiceTys, Range m, Typar destTypar, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeChoice(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty, FSharpList`1<TType> choiceTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeIsReferenceType(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType ty);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> SolveTypeRequiresDefaultConstructor$cont@2533(ConstraintSolverEnv csenv, Range m2, TType origTy, TcGlobals g, ImportMap amap, Range m, DisplayEnv denv, TType ty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeRequiresDefaultConstructor(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType origTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeRequiresDefaultValue(ConstraintSolverEnv csenv, int ndeep, Range m2, OptionalTrace trace, TType origTy);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> k@691-51(TypeDirectedConversionUsed usesTDC1, TypeDirectedConversionUsed usesTDC2, TypeDirectedConversionUsed usesTDC3, TypeDirectedConversionUsed usesTDC4, TypeDirectedConversionUsed usesTDC5, TypeDirectedConversionUsed usesTDC6, TypeDirectedConversionUsed usesTDC7);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> k@691-50(bool alwaysCheckReturn, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> unifyTypes, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>>> subsumeOrConvertTypes, FSharpOption`1<OverallTy> reqdRetTyOpt, CalledMeth`1<a> calledMeth, TcGlobals g, FSharpList`1<CalledArg> unnamedCalledOutArgs, TypeDirectedConversionUsed usesTDC1, TypeDirectedConversionUsed usesTDC2, TypeDirectedConversionUsed usesTDC3, TypeDirectedConversionUsed usesTDC4, TypeDirectedConversionUsed usesTDC5, TypeDirectedConversionUsed usesTDC6);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> k@691-49(bool alwaysCheckReturn, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> unifyTypes, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>>> subsumeOrConvertTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CallerArg`1<a>, OperationResult`1<TypeDirectedConversionUsed>>> subsumeOrConvertArg, FSharpOption`1<OverallTy> reqdRetTyOpt, CalledMeth`1<a> calledMeth, TcGlobals g, ImportMap amap, Range m, FSharpList`1<AssignedItemSetter`1<a>> assignedItemSetters, FSharpList`1<CalledArg> unnamedCalledOutArgs, TypeDirectedConversionUsed usesTDC1, TypeDirectedConversionUsed usesTDC2, TypeDirectedConversionUsed usesTDC3, TypeDirectedConversionUsed usesTDC4, TypeDirectedConversionUsed usesTDC5);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> k@691-48(bool alwaysCheckReturn, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> unifyTypes, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>>> subsumeOrConvertTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CallerArg`1<a>, OperationResult`1<TypeDirectedConversionUsed>>> subsumeOrConvertArg, FSharpOption`1<OverallTy> reqdRetTyOpt, CalledMeth`1<a> calledMeth, TcGlobals g, ImportMap amap, Range m, FSharpList`1<AssignedItemSetter`1<a>> assignedItemSetters, FSharpList`1<CalledArg> unnamedCalledOutArgs, TypeDirectedConversionUsed usesTDC1, TypeDirectedConversionUsed usesTDC2, TypeDirectedConversionUsed usesTDC3, TypeDirectedConversionUsed usesTDC4);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> k@691-47(bool alwaysCheckReturn, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> unifyTypes, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>>> subsumeOrConvertTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CallerArg`1<a>, OperationResult`1<TypeDirectedConversionUsed>>> subsumeOrConvertArg, FSharpOption`1<OverallTy> reqdRetTyOpt, CalledMeth`1<a> calledMeth, TcGlobals g, ImportMap amap, Range m, FSharpList`1<AssignedItemSetter`1<a>> assignedItemSetters, FSharpList`1<CalledArg> unnamedCalledOutArgs, TypeDirectedConversionUsed usesTDC1, TypeDirectedConversionUsed usesTDC2, TypeDirectedConversionUsed usesTDC3);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> k@691-46(bool alwaysCheckReturn, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> unifyTypes, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>>> subsumeOrConvertTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CallerArg`1<a>, OperationResult`1<TypeDirectedConversionUsed>>> subsumeOrConvertArg, FSharpOption`1<OverallTy> reqdRetTyOpt, CalledMeth`1<a> calledMeth, TcGlobals g, ImportMap amap, Range m, FSharpList`1<AssignedItemSetter`1<a>> assignedItemSetters, FSharpList`1<CalledArg> unnamedCalledOutArgs, TypeDirectedConversionUsed usesTDC1, TypeDirectedConversionUsed usesTDC2);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> k@691-45(bool permitOptArgs, bool alwaysCheckReturn, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> unifyTypes, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> subsumeTypes, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>>> subsumeOrConvertTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CallerArg`1<a>, OperationResult`1<TypeDirectedConversionUsed>>> subsumeOrConvertArg, FSharpOption`1<OverallTy> reqdRetTyOpt, CalledMeth`1<a> calledMeth, TcGlobals g, ImportMap amap, Range m, MethInfo minfo, FSharpList`1<TType> callerObjArgTys, FSharpList`1<AssignedItemSetter`1<a>> assignedItemSetters, FSharpList`1<CalledArg> unnamedCalledOptArgs, FSharpList`1<CalledArg> unnamedCalledOutArgs, TypeDirectedConversionUsed usesTDC1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> CanMemberSigsMatchUpToCheck(ConstraintSolverEnv csenv, bool permitOptArgs, bool alwaysCheckReturn, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> unifyTypes, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>> subsumeTypes, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<TType, OperationResult`1<TypeDirectedConversionUsed>>>> subsumeOrConvertTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CallerArg`1<a>, OperationResult`1<TypeDirectedConversionUsed>>> subsumeOrConvertArg, FSharpOption`1<OverallTy> reqdRetTyOpt, CalledMeth`1<a> calledMeth);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<c> AddWrappedContextualSubsumptionReport(ConstraintSolverEnv csenv, int ndeep, Range m, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2, Exception res, FSharpFunc`2<Exception, b> wrapper);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeSubsumesTypeWithWrappedContextualReport(ConstraintSolverEnv csenv, int ndeep, Range m, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, FSharpOption`1<TType> origTy1, TType ty1, TType ty2, FSharpFunc`2<Exception, d> wrapper);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> SolveTypeEqualsTypeWithReport(ConstraintSolverEnv csenv, int ndeep, Range m, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType expectedTy, TType actualTy);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> k@691-52(CalledArg calledArg, CallerArg`1<T> callerArg, TcGlobals g, Range m, TypeDirectedConversionUsed usesTDC, TType calledArgTy, Unit _arg118);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> expr2@695-19(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, CalledArg calledArg, CallerArg`1<T> callerArg, TcGlobals g, Range m, TypeDirectedConversionUsed usesTDC, TType calledArgTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> expr2@695-18(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, CalledArg calledArg, CallerArg`1<T> callerArg, TcGlobals g, Range m, TypeDirectedConversionUsed usesTDC, TType calledArgTy, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> ArgsMustSubsumeOrConvert(ConstraintSolverEnv csenv, AccessorDomain ad, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, bool isConstraint, bool enforceNullableOptionalsKnownTypes, CalledArg calledArg, CallerArg`1<T> callerArg);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> expr2@695-21(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, CalledMeth`1<Expr> calledMeth, CalledArg calledArg, CallerArg`1<Expr> callerArg, TType callerArgTy, Range m, TypeDirectedConversionUsed usesTDC, TType calledArgTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> expr2@695-20(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, CalledMeth`1<Expr> calledMeth, CalledArg calledArg, CallerArg`1<Expr> callerArg, TType callerArgTy, Range m, TypeDirectedConversionUsed usesTDC, TType calledArgTy, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> ArgsMustSubsumeOrConvertWithContextualReport(ConstraintSolverEnv csenv, AccessorDomain ad, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, bool isConstraint, CalledMeth`1<Expr> calledMeth, CalledArg calledArg, CallerArg`1<Expr> callerArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> TypesEquiv(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> TypesMustSubsume(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, Range m, TType calledArgTy, TType callerArgTy);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> expr2@695-23(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, Range m, TType actualTy, TypeDirectedConversionUsed usesTDC, TType reqdTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> expr2@695-22(ConstraintSolverEnv csenv, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, Range m, TType actualTy, TypeDirectedConversionUsed usesTDC, TType reqdTy, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> ReturnTypesMustSubsumeOrConvert(ConstraintSolverEnv csenv, AccessorDomain ad, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, bool isConstraint, Range m, bool isMethodArg, TType reqdTy, TType actualTy);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> expr2@695-25(ConstraintSolverEnv csenv, TType callerArgTy, Range m, TypeDirectedConversionUsed usesTDC, TType calledArgTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> expr2@695-24(ConstraintSolverEnv csenv, TType callerArgTy, Range m, TypeDirectedConversionUsed usesTDC, TType calledArgTy, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> ArgsEquivOrConvert(ConstraintSolverEnv csenv, AccessorDomain ad, int ndeep, OptionalTrace trace, FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> cxsln, bool isConstraint, CalledArg calledArg, CallerArg`1<e> callerArg);
    [CompilerGeneratedAttribute]
internal static Exception ReportNoCandidatesError$cont@2896(string methodName, FSharpFunc`2<f, bool> isSequential, Range m, CalledMeth`1<f> cmeth, MethInfo minfo, int nReqd, int nActual, string signature, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<g> ReportNoCandidatesError(ConstraintSolverEnv csenv, int nUnnamedCallerArgs, int nNamedCallerArgs, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<f>> calledMethGroup, FSharpFunc`2<f, bool> isSequential);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<h> ReportNoCandidatesErrorExpr(ConstraintSolverEnv csenv, int callerArgCounts_0, int callerArgCounts_1, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<Expr>> calledMethGroup);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<i> ReportNoCandidatesErrorSynExpr(ConstraintSolverEnv csenv, int callerArgCounts_0, int callerArgCounts_1, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<SynExpr>> calledMethGroup);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TraitConstraintInfo, TraitConstraintSln>> AssumeMethodSolvesTrait(ConstraintSolverEnv csenv, FSharpOption`1<TraitConstraintInfo> cx, Range m, j trace, CalledMeth`1<k> calledMeth);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> k@691-53(ConstraintSolverEnv csenv, OptionalTrace trace, int ndeep, FSharpOption`1<TraitConstraintInfo> cx, AccessorDomain ad, bool permitOptArgs, FSharpOption`1<OverallTy> reqdRetTyOpt, TcGlobals g, Range m, OptionalTrace calledMethTrace, CalledMeth`1<Expr> calledMeth, Unit _arg129);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<CalledMeth`1<Expr>>, OperationResult`1<Unit>> ResolveOverloading(ConstraintSolverEnv csenv, OptionalTrace trace, string methodName, int ndeep, FSharpOption`1<TraitConstraintInfo> cx, CallerArgs`1<Expr> callerArgs, AccessorDomain ad, FSharpList`1<CalledMeth`1<Expr>> calledMethGroup, bool permitOptArgs, FSharpOption`1<OverallTy> reqdRetTyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception FailOverloading(ConstraintSolverEnv csenv, FSharpList`1<CalledMeth`1<Expr>> calledMethGroup, FSharpOption`1<OverallTy> reqdRetTyOpt, bool isOpConversion, CallerArgs`1<Expr> callerArgs, OverloadResolutionFailure overloadResolutionFailure, Range m);
    internal static FSharpFunc`2<T, FSharpFunc`2<T, int>> compareCond@3198(FSharpFunc`2<T, FSharpFunc`2<T, bool>> p);
    internal static int compareTypes@3202(ConstraintSolverEnv csenv, int ndeep, Range m, TType ty1, TType ty2);
    [CompilerGeneratedAttribute]
internal static int better$cont@3324-3(TcGlobals g, FSharpFunc`2<CalledArg, FSharpFunc`2<CalledArg, int>> compareArg, CalledMeth`1<l> candidate, CalledMeth`1<o> other, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int better$cont@3282-2(Range m, TcGlobals g, FSharpFunc`2<TType, FSharpFunc`2<TType, int>> compareTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CalledArg, int>> compareArg, CalledMeth`1<l> candidate, CalledMeth`1<o> other, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int better$cont@3260-1(ConstraintSolverEnv csenv, int ndeep, Range m, TcGlobals g, FSharpFunc`2<TType, FSharpFunc`2<TType, int>> compareTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CalledArg, int>> compareArg, CalledMeth`1<l> candidate, CalledMeth`1<o> other, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int better$cont@3246(ConstraintSolverEnv csenv, int ndeep, Range m, TcGlobals g, FSharpFunc`2<TType, FSharpFunc`2<TType, int>> compareTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CalledArg, int>> compareArg, CalledMeth`1<l> candidate, TypeDirectedConversionUsed usesTDC1, CalledMeth`1<o> other, TypeDirectedConversionUsed usesTDC2, int candidateWarnCount, int otherWarnCount, Unit unitVar);
    internal static int better@3237(ConstraintSolverEnv csenv, int ndeep, Range m, TcGlobals g, FSharpFunc`2<TType, FSharpFunc`2<TType, int>> compareTypes, FSharpFunc`2<CalledArg, FSharpFunc`2<CalledArg, int>> compareArg, CalledMeth`1<l> candidate, FSharpList`1<m> candidateWarnings, n tupledArg2, TypeDirectedConversionUsed usesTDC1, CalledMeth`1<o> other, FSharpList`1<p> otherWarnings, q tupledArg2@3237, TypeDirectedConversionUsed usesTDC2);
    internal static FSharpList`1<OverloadInformation> getMethodSlotsAndErrors@3372(InfoReader infoReader, CalledMeth`1<Expr> methodSlot, FSharpList`1<l> errors);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpOption`1<CalledMeth`1<Expr>>, OperationResult`1<Unit>, OptionalTrace> GetMostApplicableOverload(ConstraintSolverEnv csenv, int ndeep, FSharpList`1<CalledMeth`1<Expr>> candidates, FSharpList`1<Tuple`4<CalledMeth`1<Expr>, FSharpList`1<Exception>, Trace, TypeDirectedConversionUsed>> applicableMeths, FSharpList`1<CalledMeth`1<Expr>> calledMethGroup, FSharpOption`1<OverallTy> reqdRetTyOpt, bool isOpConversion, CallerArgs`1<Expr> callerArgs, string methodName, FSharpOption`1<TraitConstraintInfo> cx, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<CalledMeth`1<Expr>>, OperationResult`1<Unit>> ResolveOverloadingForCall(DisplayEnv denv, ConstraintSolverState css, Range m, string methodName, CallerArgs`1<Expr> callerArgs, AccessorDomain ad, FSharpList`1<CalledMeth`1<Expr>> calledMethGroup, bool permitOptArgs, OverallTy reqdRetTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> UnifyUniqueOverloading(DisplayEnv denv, ConstraintSolverState css, Range m, int callerArgCounts_0, int callerArgCounts_1, string methodName, AccessorDomain ad, FSharpList`1<CalledMeth`1<SynExpr>> calledMethGroup, OverallTy reqdRetTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void UpdateStaticReqOfTypar(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, Typar typar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EliminateConstraintsForGeneralizedTypars(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, FSharpList`1<Typar> generalizedTypars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeEqualsType(ContextInfo contextInfo, DisplayEnv denv, ConstraintSolverState css, Range m, TType expected, TType actual);
    internal static bool UndoIfFailed(FSharpFunc`2<Trace, OperationResult`1<a>> f);
    internal static bool UndoIfFailedOrWarnings(FSharpFunc`2<Trace, OperationResult`1<a>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeEqualsTypeUndoIfFailed(DisplayEnv denv, ConstraintSolverState css, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeEqualsTypeUndoIfFailedOrWarnings(DisplayEnv denv, ConstraintSolverState css, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeEqualsTypeMatchingOnlyUndoIfFailed(DisplayEnv denv, ConstraintSolverState css, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeMustSubsumeTypeUndoIfFailed(DisplayEnv denv, ConstraintSolverState css, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool AddCxTypeMustSubsumeTypeMatchingOnlyUndoIfFailed(DisplayEnv denv, ConstraintSolverState css, Range m, Set`2<Typar, IComparer`1<Typar>> extraRigidTypars, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSubsumeType(ContextInfo contextInfo, DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxMethodConstraint(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeUseSupportsNull(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSupportComparison(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSupportEquality(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeMustSupportDefaultCtor(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsReferenceType(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsValueType(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsUnmanaged(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsEnum(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty, TType underlying);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTypeIsDelegate(DisplayEnv denv, ConstraintSolverState css, Range m, OptionalTrace trace, TType ty, TType aty, TType bty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddCxTyparDefaultsTo(DisplayEnv denv, ConstraintSolverState css, Range m, ContextInfo ctxtInfo, Typar tp, int ridx, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SolveTypeAsError(DisplayEnv denv, ConstraintSolverState css, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ApplyTyparDefaultAtPriority(DisplayEnv denv, ConstraintSolverState css, int priority, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ConstraintSolverState CreateCodegenState(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<bool> k@691-54(TraitConstraintInfo traitInfo, bool _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> CodegenWitnessExprForTraitConstraintWillRequireWitnessArgs(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Range m, TraitConstraintInfo traitInfo);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<FSharpOption`1<Expr>> k@691-55(TcGlobals g, ImportMap amap, Range m, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs, bool _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<FSharpOption`1<Expr>> CodegenWitnessExprForTraitConstraint(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Range m, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<FSharpList`1<FSharpChoice`2<TraitConstraintInfo, Expr>>> k@691-56(TcGlobals g, ImportMap amap, Range m, FSharpList`1<TraitConstraintInfo> traitInfos, Unit _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<FSharpList`1<FSharpChoice`2<TraitConstraintInfo, Expr>>> CodegenWitnessesForTyparInst(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Range m, FSharpList`1<Typar> typars, FSharpList`1<TType> tyargs);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<FSharpChoice`2<TraitConstraintInfo, Expr>> k@691-57(TcGlobals g, ImportMap amap, Range m, TraitConstraintInfo traitInfo, bool _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<FSharpChoice`2<TraitConstraintInfo, Expr>> CodegenWitnessArgForTraitConstraint(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Range m, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ChooseTyparSolutionAndSolve(ConstraintSolverState css, DisplayEnv denv, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDeclaredTypars(DisplayEnv denv, ConstraintSolverState css, Range m, FSharpList`1<Typar> typars1, FSharpList`1<Typar> typars2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CanonicalizePartialInferenceProblem(ConstraintSolverState css, DisplayEnv denv, Range m, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsApplicableMethApprox(TcGlobals g, ImportMap amap, Range m, MethInfo minfo, TType availObjTy);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.CreateILModule : object {
    internal static StrongNameSigningInfo GetStrongNameSigningInfo(bool delaysign, bool publicsign, FSharpOption`1<Byte[]> signer, FSharpOption`1<string> container);
    internal static StrongNameSigningInfo ValidateKeySigningAttributes(TcConfig tcConfig, TcGlobals tcGlobals, TopAttribs topAttrs);
    internal static FSharpOption`1<ILStrongNameSigner> GetStrongNameSigner(StrongNameSigningInfo signingInfo);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.DependencyManager.AssemblyResolutionProbe : MulticastDelegate {
    public AssemblyResolutionProbe(object object, IntPtr method);
    public virtual IEnumerable`1<string> Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object objects);
    public virtual IEnumerable`1<string> EndInvoke(IAsyncResult result);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.DependencyManager.AssemblyResolveHandler : object {
    internal FSharpOption`1<IDisposable> handler;
    internal AssemblyResolveHandler(FSharpOption`1<AssemblyResolutionProbe> assemblyProbingPaths);
    public AssemblyResolveHandler(AssemblyResolutionProbe assemblyProbingPaths);
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.DependencyManager.AssemblyResolveHandlerCoreclr : object {
    internal FSharpOption`1<AssemblyResolutionProbe> assemblyProbingPaths;
    internal MethodInfo loadFromAssemblyPathMethod;
    internal EventInfo eventInfo;
    internal Delegate handler;
    internal object defaultAssemblyLoadContext;
    internal int init@15;
    public AssemblyResolveHandlerCoreclr(FSharpOption`1<AssemblyResolutionProbe> assemblyProbingPaths);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Assembly ResolveAssemblyNetStandard(T ctxt, AssemblyName assemblyName);
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.DependencyManager.AssemblyResolveHandlerDeskTop : object {
    internal FSharpOption`1<AssemblyResolutionProbe> assemblyProbingPaths;
    internal ResolveEventHandler handler;
    public AssemblyResolveHandlerDeskTop(FSharpOption`1<AssemblyResolutionProbe> assemblyProbingPaths);
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
internal Assembly resolveAssemblyNET(AssemblyName assemblyName);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.DependencyManager.DependencyProvider : object {
    internal bool useResultsCache;
    internal NativeDllResolveHandler dllResolveHandler;
    internal IDisposable assemblyResolveHandler;
    internal Lazy`1<FSharpList`1<string>> assemblySearchPaths;
    internal FSharpOption`1<FSharpMap`2<string, IDependencyManagerProvider>> registeredDependencyManagers;
    internal ConcurrentDictionary`2<Tuple`8<string, string, Tuple`2[], string, string, string, string, Tuple`1<string>>, FSharpResult`2<IResolveDependenciesResult, Tuple`2<int, string>>> cache;
    internal DependencyProvider(FSharpOption`1<AssemblyResolutionProbe> assemblyProbingPaths, FSharpOption`1<NativeResolutionProbe> nativeProbingRoots, bool useResultsCache);
    public DependencyProvider(AssemblyResolutionProbe assemblyProbingPaths, NativeResolutionProbe nativeProbingRoots);
    public DependencyProvider(AssemblyResolutionProbe assemblyProbingPaths, NativeResolutionProbe nativeProbingRoots, bool useResultsCache);
    public DependencyProvider(NativeResolutionProbe nativeProbingRoots, bool useResultsCache);
    public DependencyProvider(NativeResolutionProbe nativeProbingRoots);
    public String[] GetRegisteredDependencyManagerHelpText(IEnumerable`1<string> compilerTools, string outputDir, ResolvingErrorReport errorReport);
    public void ClearResultsCache(IEnumerable`1<string> compilerTools, string outputDir, ResolvingErrorReport errorReport);
    public Tuple`2<int, string> CreatePackageManagerUnknownError(IEnumerable`1<string> compilerTools, string outputDir, string packageManagerKey, ResolvingErrorReport reportError);
    public Tuple`2<string, IDependencyManagerProvider> TryFindDependencyManagerInPath(IEnumerable`1<string> compilerTools, string outputDir, ResolvingErrorReport reportError, string path);
    public IDependencyManagerProvider TryFindDependencyManagerByKey(IEnumerable`1<string> compilerTools, string outputDir, ResolvingErrorReport reportError, string key);
    public IResolveDependenciesResult Resolve(IDependencyManagerProvider packageManager, string scriptExt, IEnumerable`1<Tuple`2<string, string>> packageManagerTextLines, ResolvingErrorReport reportError, string executionTfm, string executionRid, string implicitIncludeDir, string mainScriptName, string fileName, int timeout);
    private virtual override void System.IDisposable.Dispose();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal IEnumerable`1<Assembly> enumerateDependencyManagerAssemblies(IEnumerable`1<string> compilerTools, ResolvingErrorReport reportError);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpMap`2<string, IDependencyManagerProvider> RegisteredDependencyManagers(IEnumerable`1<string> compilerTools, FSharpOption`1<string> outputDir, ResolvingErrorReport reportError);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.DependencyManager.ErrorReportType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ErrorReportType _unique_Warning;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ErrorReportType _unique_Error;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ErrorReportType Warning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWarning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ErrorReportType Error { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsError { get; }
    private static ErrorReportType();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.DependencyManager.ErrorReportType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ErrorReportType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static ErrorReportType get_Warning();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWarning();
    [CompilationMappingAttribute("8", "1")]
public static ErrorReportType get_Error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ErrorReportType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ErrorReportType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AllowNullLiteralAttribute]
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.DependencyManager.IDependencyManagerProvider {
    public string Name { get; }
    public string Key { get; }
    public String[] HelpMessages { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Key();
    public abstract virtual String[] get_HelpMessages();
    public abstract virtual void ClearResultsCache();
    public abstract virtual IResolveDependenciesResult ResolveDependencies(string scriptDir, string mainScriptName, string scriptName, string scriptExt, IEnumerable`1<Tuple`2<string, string>> packageManagerTextLines, string tfm, string rid, int timeout);
}
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.DependencyManager.IResolveDependenciesResult {
    public bool Success { get; }
    public String[] StdOut { get; }
    public String[] StdError { get; }
    public IEnumerable`1<string> Resolutions { get; }
    public IEnumerable`1<string> SourceFiles { get; }
    public IEnumerable`1<string> Roots { get; }
    public abstract virtual bool get_Success();
    public abstract virtual String[] get_StdOut();
    public abstract virtual String[] get_StdError();
    public abstract virtual IEnumerable`1<string> get_Resolutions();
    public abstract virtual IEnumerable`1<string> get_SourceFiles();
    public abstract virtual IEnumerable`1<string> get_Roots();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.DependencyManager.NativeDllResolveHandler : object {
    internal FSharpOption`1<NativeDllResolveHandlerCoreClr> handler;
    internal NativeDllResolveHandler(FSharpOption`1<NativeResolutionProbe> nativeProbingRoots);
    public NativeDllResolveHandler(NativeResolutionProbe nativeProbingRoots);
    internal void RefreshPathsInEnvironment(IEnumerable`1<string> roots);
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.DependencyManager.NativeDllResolveHandlerCoreClr : object {
    internal FSharpOption`1<NativeResolutionProbe> nativeProbingRoots;
    internal ProbingPathsStore probingPaths;
    internal MethodInfo nativeLibraryTryLoad;
    internal Func`3<Assembly, string, IntPtr> handler;
    internal EventInfo eventInfo;
    internal object defaultAssemblyLoadContext;
    public NativeDllResolveHandlerCoreClr(FSharpOption`1<NativeResolutionProbe> nativeProbingRoots);
    internal void RefreshPathsInEnvironment(IEnumerable`1<string> roots);
    internal void Dispose();
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
internal IntPtr loadNativeLibrary(a path);
    [CompilerGeneratedAttribute]
internal String[] probingFileNames(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal IntPtr resolveUnmanagedDll(Assembly _arg1, string name);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.DependencyManager.NativeResolutionProbe : MulticastDelegate {
    public NativeResolutionProbe(object object, IntPtr method);
    public virtual IEnumerable`1<string> Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object objects);
    public virtual IEnumerable`1<string> EndInvoke(IAsyncResult result);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.DependencyManager.Option : object {
    internal static FSharpOption`1<string> ofString(string s);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.DependencyManager.ProbingPathsStore : object {
    internal ConcurrentBag`1<string> addedPaths;
    internal static string AppendPathSeparator(string p);
    internal static void RemoveProbeFromProcessPath(string probePath);
    internal void AddProbeToProcessPath(string probePath);
    internal void RefreshPathsInEnvironment(IEnumerable`1<string> roots);
    internal void Dispose();
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.DependencyManager.ReflectionDependencyManagerProvider : object {
    internal FSharpOption`1<MethodInfo> resolveDepsExWithTimeout;
    internal FSharpOption`1<MethodInfo> resolveDepsExWithScriptInfoAndTimeout;
    internal FSharpOption`1<MethodInfo> resolveDepsEx;
    internal FSharpOption`1<MethodInfo> resolveDeps;
    internal FSharpOption`1<MethodInfo> clearResultCache;
    internal object instance;
    internal FSharpFunc`2<object, string> nameProperty@166;
    internal FSharpFunc`2<object, string> keyProperty@167;
    internal FSharpFunc`2<object, String[]> helpMessagesProperty@169;
    public ReflectionDependencyManagerProvider(Type theType, PropertyInfo nameProperty, PropertyInfo keyProperty, FSharpOption`1<PropertyInfo> helpMessagesProperty, FSharpOption`1<MethodInfo> resolveDeps, FSharpOption`1<MethodInfo> resolveDepsEx, FSharpOption`1<MethodInfo> resolveDepsExWithTimeout, FSharpOption`1<MethodInfo> resolveDepsExWithScriptInfoAndTimeout, FSharpOption`1<MethodInfo> clearResultCache, FSharpOption`1<string> outputDir, bool useResultsCache);
    internal static FSharpOption`1<FSharpFunc`2<Unit, IDependencyManagerProvider>> InstanceMaker(Type theType, FSharpOption`1<string> outputDir, bool useResultsCache);
    internal static IResolveDependenciesResult MakeResultFromObject(object result);
    internal static IResolveDependenciesResult MakeResultFromFields(bool success, String[] stdOut, String[] stdError, IEnumerable`1<string> resolutions, IEnumerable`1<string> sourceFiles, IEnumerable`1<string> roots);
    private virtual override string FSharp.Compiler.DependencyManager.IDependencyManagerProvider.get_Name();
    private virtual override string FSharp.Compiler.DependencyManager.IDependencyManagerProvider.get_Key();
    private virtual override void FSharp.Compiler.DependencyManager.IDependencyManagerProvider.ClearResultsCache();
    private virtual override String[] FSharp.Compiler.DependencyManager.IDependencyManagerProvider.get_HelpMessages();
    private virtual override IResolveDependenciesResult FSharp.Compiler.DependencyManager.IDependencyManagerProvider.ResolveDependencies(string scriptDir, string mainScriptName, string scriptName, string scriptExt, IEnumerable`1<Tuple`2<string, string>> packageManagerTextLines, string tfm, string rid, int timeout);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.DependencyManager.ReflectionHelper : object {
    internal static string dependencyManagerPattern { get; }
    internal static string dependencyManagerAttributeName { get; }
    internal static string resolveDependenciesMethodName { get; }
    internal static string clearResultsCacheMethodName { get; }
    internal static string namePropertyName { get; }
    internal static string keyPropertyName { get; }
    internal static string helpMessagesPropertyName { get; }
    [CompilationMappingAttribute("9")]
internal static IEnumerable`1<string> seqEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dependencyManagerPattern();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dependencyManagerAttributeName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_resolveDependenciesMethodName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_clearResultsCacheMethodName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_namePropertyName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_keyPropertyName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_helpMessagesPropertyName();
    internal static IEnumerable`1<string> get_seqEmpty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool assemblyHasAttribute(Assembly theAssembly, string attributeName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<object> getAttributeNamed(Type theType, string attributeName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<PropertyInfo> getInstanceProperty(Type theType, string propertyName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethodInfo> getInstanceMethod(Type theType, Type[] parameterTypes, string methodName);
    internal static Exception stripTieWrapper(Exception e);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.DependencyManager.ResolvingErrorReport : MulticastDelegate {
    public ResolvingErrorReport(object object, IntPtr method);
    public virtual void Invoke(ErrorReportType , int , string );
    public virtual IAsyncResult BeginInvoke(ErrorReportType , int , string , AsyncCallback callback, object objects);
    public virtual void EndInvoke(IAsyncResult result);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Detuple : object {
    [CompilationMappingAttribute("9")]
internal static int DetupleRewriteStackGuardDepth { get; }
    internal static int get_DetupleRewriteStackGuardDepth();
    internal static FSharpOption`1<Tuple`5<Expr, TType, FSharpList`1<TType>, FSharpList`1<Expr>, Range>> |TyappAndApp|_|(Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val mkLocalVal(Range m, string name, TType ty, FSharpOption`1<ValReprInfo> valReprInfo);
    internal static FSharpList`1<FSharpList`1<ArgReprInfo>> ValReprInfoForTS(TupleStructure ts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TupleStructure andTS(TupleStructure ts, TupleStructure tsB);
    internal static TupleStructure checkTS(TupleStructure _arg1);
    internal static TupleStructure uncheckedExprTS(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TupleStructure uncheckedTypeTS(TcGlobals g, TType ty);
    internal static Tuple`2<Tuple`2<Expr, TType>, FSharpList`1<Val>> rebuild@423-3(TcGlobals g, Range m, FSharpList`1<Val> vs, TupleStructure ts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr rebuildTS(TcGlobals g, Range m, TupleStructure ts, FSharpList`1<Val> vs);
    internal static FSharpList`1<TupleStructure> minimalCallPattern(FSharpList`1<TupleStructure> callPattern);
    internal static FSharpList`1<TupleStructure> andCPs@461(FSharpList`1<TupleStructure> cpA, FSharpList`1<TupleStructure> cpB);
    internal static FSharpList`1<TupleStructure> commonCallPattern(FSharpList`1<FSharpList`1<TupleStructure>> callPatterns);
    internal static FSharpList`1<TupleStructure> siteCP(a _accessors, b _inst, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Transform mkTransform(TcGlobals g, Val f, Range m, FSharpList`1<Typar> tps, FSharpList`1<TType> x1Ntys, TType retTy, FSharpList`1<TupleStructure> callPattern, FSharpList`1<Tuple`2<FSharpList`1<TType>, FSharpList`1<Val>>> tyfringes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TupleStructure, FSharpList`1<TType>> zipTupleStructureAndType(TcGlobals g, TupleStructure ts, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TupleStructure>, FSharpList`1<TType>> zipTupleStructuresAndTypes(TcGlobals g, FSharpList`1<TupleStructure> tss, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TupleStructure>, FSharpList`1<Tuple`2<FSharpList`1<TType>, FSharpList`1<Val>>>> zipCallPatternArgTys(Range m, TcGlobals g, FSharpList`1<TupleStructure> callPattern, FSharpList`1<FSharpList`1<Val>> vss);
    internal static TupleStructure trimTsByAccess@608(FSharpList`1<accessor> accessors, TupleStructure ts);
    internal static FSharpFunc`2<TupleStructure, FSharpFunc`2<Tuple`3<FSharpList`1<accessor>, a, b>, TupleStructure>> trim@620();
    internal static TupleStructure trimTsByVal@616(Results z, TupleStructure ts, Val v);
    internal static FSharpFunc`2<TupleStructure, FSharpFunc`2<FSharpList`1<Val>, TupleStructure>> trimTsByFormal@623(FSharpFunc`2<Results, FSharpFunc`2<TupleStructure, FSharpFunc`2<Val, TupleStructure>>> trimTsByVal, Results z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TupleStructure> decideFormalSuggestedCP(TcGlobals g, Results z, FSharpList`1<TType> tys, FSharpList`1<FSharpList`1<Val>> vss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Val, Transform>> decideTransform(TcGlobals g, Results z, Val v, FSharpList`1<FSharpList`1<TupleStructure>> callPatterns, Range m, FSharpList`1<Typar> tps, FSharpList`1<FSharpList`1<Val>> vss, TType retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eligibleVal(TcGlobals g, Range m, Val v);
    internal static FSharpFunc`2<Val, FSharpFunc`2<FSharpList`1<Tuple`3<a, b, FSharpList`1<Expr>>>, FSharpOption`1<Tuple`2<Val, Transform>>>> selectTransform@692(TcGlobals g, Results z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Val, Transform, IComparer`1<Val>> determineTransforms(TcGlobals g, Results z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static env suffixE(env env, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> newLocalN(env env, a i, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, Expr> noEffectExpr(env env, FSharpList`1<Binding> bindings, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Expr>> buildProjections(env env, FSharpList`1<Binding> bindings, Expr x, FSharpList`1<TType> xtys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Expr>> collapseArg(env env, FSharpList`1<Binding> bindings, TupleStructure ts, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Expr>> collapseArgs(env env, FSharpList`1<Binding> bindings, int n, FSharpList`1<TupleStructure> callPattern, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLets(FSharpList`1<Binding> binds, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr fixupApp(penv penv, Expr fx, TType fty, FSharpList`1<TType> tys, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Val>> transFormal(TransformedFormal ybi, FSharpList`1<Val> xi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> transRebind(TransformedFormal ybi, FSharpList`1<Val> xi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding passBind(penv penv, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> postTransformExpr(penv penv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CheckedImplFile passImplFile(penv penv, CheckedImplFile assembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CheckedImplFile DetupleImplFile(CcuThunk ccu, TcGlobals g, CheckedImplFile expr);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.DiagnosticMessage : object {
    [CompilationMappingAttribute("9")]
internal static Type funTyC { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object mkFunctionValue(Type[] tys, FSharpFunc`2<object, object> impl);
    internal static Type get_funTyC();
    internal static bool isNamedType(Type ty);
    internal static bool isFunctionType(Type ty1);
    internal static Tuple`2<Type, Type[]> destFunTy(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object buildFunctionForOneArgPat(Type ty, FSharpFunc`2<Type, FSharpFunc`2<object, object>> impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object capture1(string fmt, int i, FSharpList`1<object> args, Type ty, FSharpFunc`2<FSharpList`1<object>, FSharpFunc`2<Type, FSharpFunc`2<int, object>>> go);
    internal static object capture@73-6(string messageString, string fmt, int len, FSharpList`1<object> args, Type ty, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T createMessageString(string messageString, PrintfFormat`4<T, Unit, string, string> fmt);
    internal static ResourceString`1<T> DeclareResourceString(string messageID, PrintfFormat`4<T, Unit, string, string> fmt);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.DiagnosticResolutionHints : object {
    internal static int maxSuggestions { get; }
    internal static double minThresholdForSuggestions { get; }
    internal static double highConfidenceThreshold { get; }
    internal static int minStringLengthForSuggestion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_maxSuggestions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double get_minThresholdForSuggestions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static double get_highConfidenceThreshold();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_minStringLengthForSuggestion();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsInEditDistanceProximity(string idText, string suggestion);
    internal static string DemangleOperator(string nm);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Diagnostics.Activity : object {
    [CompilationMappingAttribute("9")]
internal static ActivitySource activitySource { get; }
    internal static string rootID@60(Activity act);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string Activity.get_RootId(Activity );
    internal static int depth@66(Activity act, int acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int Activity.get_Depth(Activity );
    internal static ActivitySource get_activitySource();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IDisposable start(string name, IEnumerable`1<Tuple`2<string, string>> tags);
    internal static IDisposable startNoTags(string name);
    internal static void addEvent(string name);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Diagnostics.ActivityNames : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string FscSourceName;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
public static string ProfiledSourceName;
    [CompilationMappingAttribute("9")]
public static String[] AllRelevantNames { get; }
    private static ActivityNames();
    public static String[] get_AllRelevantNames();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Diagnostics.CompilationDiagnosticLogger : DiagnosticsLogger {
    internal FSharpOption`1<FSharpFunc`2<PhasedDiagnostic, PhasedDiagnostic>> preprocess;
    internal FSharpDiagnosticOptions options;
    internal int errorCount;
    internal List`1<Tuple`2<PhasedDiagnostic, FSharpDiagnosticSeverity>> diagnostics;
    public int ErrorCount { get; }
    public CompilationDiagnosticLogger(string debugName, FSharpDiagnosticOptions options, FSharpOption`1<FSharpFunc`2<PhasedDiagnostic, PhasedDiagnostic>> preprocess);
    public virtual void DiagnosticSink(PhasedDiagnostic diagnostic, FSharpDiagnosticSeverity severity);
    public virtual int get_ErrorCount();
    internal Tuple`2[] GetDiagnostics();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Diagnostics.CompilerDiagnostics : object {
    public static string GetErrorMessage(FSharpDiagnosticKind diagnosticKind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> GetSuggestedNames(FSharpFunc`2<FSharpFunc`2<string, Unit>, Unit> suggestionsF, string unresolvedIdentifier);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Diagnostics.DiagnosticHelpers : object {
    internal static FSharpList`1<FSharpDiagnostic> ReportDiagnostic(FSharpDiagnosticOptions options, bool allErrors, string mainInputFileName, Tuple`2<int, int> fileInfo, PhasedDiagnostic diagnostic, FSharpDiagnosticSeverity severity, bool suggestNames, bool flatErrors, FSharpOption`1<SymbolEnv> symbolEnv);
    internal static FSharpDiagnostic[] CreateDiagnostics(FSharpDiagnosticOptions options, bool allErrors, string mainInputFileName, IEnumerable`1<Tuple`2<PhasedDiagnostic, FSharpDiagnosticSeverity>> diagnostics, bool suggestNames, bool flatErrors, FSharpOption`1<SymbolEnv> symbolEnv);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Diagnostics.DiagnosticsScope : object {
    internal FSharpList`1<FSharpDiagnostic> diags;
    internal IDisposable unwindBP;
    internal IDisposable unwindEL;
    internal FSharpList`1<FSharpDiagnostic> Errors { get; }
    internal FSharpList`1<FSharpDiagnostic> Diagnostics { get; }
    public DiagnosticsScope(bool flatErrors);
    internal FSharpList`1<FSharpDiagnostic> get_Errors();
    internal FSharpList`1<FSharpDiagnostic> get_Diagnostics();
    internal FSharpOption`1<string> TryGetFirstErrorText();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T Protect(Range m, FSharpFunc`2<Unit, T> f, FSharpFunc`2<string, T> err);
    private virtual override void System.IDisposable.Dispose();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Diagnostics.ExtendedData : object {
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Diagnostics.FSharpDiagnostic : object {
    internal string subcategory;
    internal FSharpDiagnosticSeverity severity;
    internal string numberPrefix;
    internal string message;
    internal Range m;
    internal FSharpOption`1<IFSharpDiagnosticExtendedData> extendedData;
    internal int errorNum;
    public Range Range { get; }
    public FSharpDiagnosticSeverity Severity { get; }
    public string Message { get; }
    public string Subcategory { get; }
    public int ErrorNumber { get; }
    public string ErrorNumberPrefix { get; }
    public string ErrorNumberText { get; }
    public Position Start { get; }
    public Position End { get; }
    public int StartLine { get; }
    public int EndLine { get; }
    public int StartColumn { get; }
    public int EndColumn { get; }
    public string FileName { get; }
    [ExperimentalAttribute("This FCS API is experimental and subject to change.")]
public FSharpOption`1<IFSharpDiagnosticExtendedData> ExtendedData { get; }
    internal FSharpDiagnostic(Range m, FSharpDiagnosticSeverity severity, string message, string subcategory, int errorNum, string numberPrefix, FSharpOption`1<IFSharpDiagnosticExtendedData> extendedData);
    public Range get_Range();
    public FSharpDiagnosticSeverity get_Severity();
    public string get_Message();
    public string get_Subcategory();
    public int get_ErrorNumber();
    public string get_ErrorNumberPrefix();
    public string get_ErrorNumberText();
    public Position get_Start();
    public Position get_End();
    public int get_StartLine();
    public int get_EndLine();
    public int get_StartColumn();
    public int get_EndColumn();
    public string get_FileName();
    public FSharpOption`1<IFSharpDiagnosticExtendedData> get_ExtendedData();
    internal FSharpDiagnostic WithStart(Position newStart);
    internal FSharpDiagnostic WithEnd(Position newEnd);
    public virtual string ToString();
    internal static FSharpDiagnostic CreateFromException(PhasedDiagnostic diagnostic, FSharpDiagnosticSeverity severity, Range fallbackRange, bool suggestNames, bool flatErrors, FSharpOption`1<SymbolEnv> symbolEnv);
    internal static FSharpDiagnostic CreateFromExceptionAndAdjustEof(PhasedDiagnostic diagnostic, FSharpDiagnosticSeverity severity, Range fallbackRange, Tuple`2<int, int> lastPosInFile, bool suggestNames, bool flatErrors, FSharpOption`1<SymbolEnv> symbolEnv);
    public static string NewlineifyErrorString(string message);
    public static string NormalizeErrorString(string text);
    public static FSharpDiagnostic Create(FSharpDiagnosticSeverity severity, string message, int number, Range range, FSharpOption`1<string> numberPrefix, FSharpOption`1<string> subcategory);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Diagnostics.FSharpDiagnosticKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpDiagnosticKind _unique_AddIndexerDot;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpDiagnosticKind _unique_RemoveIndexerDot;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpDiagnosticKind AddIndexerDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAddIndexerDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsReplaceWithSuggestion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpDiagnosticKind RemoveIndexerDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRemoveIndexerDot { get; }
    private static FSharpDiagnosticKind();
    [CompilationMappingAttribute("8", "0")]
public static FSharpDiagnosticKind get_AddIndexerDot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAddIndexerDot();
    [CompilationMappingAttribute("8", "1")]
public static FSharpDiagnosticKind NewReplaceWithSuggestion(string _suggestion);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsReplaceWithSuggestion();
    [CompilationMappingAttribute("8", "2")]
public static FSharpDiagnosticKind get_RemoveIndexerDot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRemoveIndexerDot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpDiagnosticKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpDiagnosticKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.Diagnostics.FSharpDiagnosticOptions : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int WarnLevel@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool GlobalWarnAsError@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<int> WarnOff@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<int> WarnOn@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<int> WarnAsError@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<int> WarnAsWarn@;
    [CompilationMappingAttribute("4", "0")]
public int WarnLevel { get; }
    [CompilationMappingAttribute("4", "1")]
public bool GlobalWarnAsError { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpList`1<int> WarnOff { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpList`1<int> WarnOn { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpList`1<int> WarnAsError { get; }
    [CompilationMappingAttribute("4", "5")]
public FSharpList`1<int> WarnAsWarn { get; }
    public static FSharpDiagnosticOptions Default { get; }
    public bool CheckXmlDocs { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Diagnostics.FSharpDiagnosticOptions")]
public FSharpDiagnosticOptions(int warnLevel, bool globalWarnAsError, FSharpList`1<int> warnOff, FSharpList`1<int> warnOn, FSharpList`1<int> warnAsError, FSharpList`1<int> warnAsWarn);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_WarnLevel();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_GlobalWarnAsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<int> get_WarnOff();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<int> get_WarnOn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<int> get_WarnAsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<int> get_WarnAsWarn();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpDiagnosticOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static FSharpDiagnosticOptions get_Default();
    public bool get_CheckXmlDocs();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpDiagnosticOptions obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpDiagnosticSeverity _unique_Hidden;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpDiagnosticSeverity _unique_Info;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpDiagnosticSeverity _unique_Warning;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpDiagnosticSeverity _unique_Error;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpDiagnosticSeverity Hidden { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHidden { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpDiagnosticSeverity Info { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpDiagnosticSeverity Warning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWarning { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpDiagnosticSeverity Error { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsError { get; }
    private static FSharpDiagnosticSeverity();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Diagnostics.FSharpDiagnosticSeverity")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpDiagnosticSeverity(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpDiagnosticSeverity get_Hidden();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHidden();
    [CompilationMappingAttribute("8", "1")]
public static FSharpDiagnosticSeverity get_Info();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfo();
    [CompilationMappingAttribute("8", "2")]
public static FSharpDiagnosticSeverity get_Warning();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWarning();
    [CompilationMappingAttribute("8", "3")]
public static FSharpDiagnosticSeverity get_Error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpDiagnosticSeverity obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpDiagnosticSeverity obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.DiagnosticsLogger : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<string, Unit>, Unit> NoSuggestions { get; }
    [CompilationMappingAttribute("9")]
internal static Exiter QuitProcessExiter { get; }
    [CompilationMappingAttribute("9")]
internal static DiagnosticsLogger DiscardErrorsLogger { get; }
    [CompilationMappingAttribute("9")]
internal static DiagnosticsLogger AssertFalseDiagnosticsLogger { get; }
    [CompilationMappingAttribute("9")]
internal static OperationResult`1<Unit> CompleteD { get; }
    [CompilationMappingAttribute("9")]
internal static TrackErrorsBuilder trackErrors { get; }
    [CompilationMappingAttribute("9")]
internal static string stringThatIsAProxyForANewlineInFlatErrors { get; }
    internal static Exception findOriginalException(Exception err);
    internal static FSharpFunc`2<FSharpFunc`2<string, Unit>, Unit> get_NoSuggestions();
    internal static FSharpOption`1<Unit> |StopProcessing|_|(Exception exn);
    internal static Exception StopProcessing();
    internal static Exception Error(Tuple`2<int, string> _arg1, Range m);
    internal static Exception ErrorWithSuggestions(Tuple`2<int, string> _arg1, Range m, string id, FSharpFunc`2<FSharpFunc`2<string, Unit>, Unit> suggestions);
    internal static Exception ErrorEnabledWithLanguageFeature(Tuple`2<int, string> _arg1, Range m, bool enabledByLangFeature);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T protectAssemblyExploration(T dflt, FSharpFunc`2<Unit, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T protectAssemblyExplorationF(FSharpFunc`2<Tuple`2<string, string>, T> dflt, FSharpFunc`2<Unit, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T protectAssemblyExplorationNoReraise(T dflt1, T dflt2, FSharpFunc`2<Unit, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception AttachRange(Range m, Exception exn);
    internal static Exiter get_QuitProcessExiter();
    internal static DiagnosticsLogger get_DiscardErrorsLogger();
    internal static DiagnosticsLogger get_AssertFalseDiagnosticsLogger();
    internal static IDisposable UseBuildPhase(BuildPhase phase);
    internal static IDisposable UseTransformedDiagnosticsLogger(FSharpFunc`2<DiagnosticsLogger, a> transformer);
    internal static IDisposable UseDiagnosticsLogger(DiagnosticsLogger newLogger);
    internal static void SetThreadBuildPhaseNoUnwind(BuildPhase phase);
    internal static void SetThreadDiagnosticsLoggerNoUnwind(DiagnosticsLogger diagnosticsLogger);
    internal static void errorR(Exception exn);
    internal static void warning(Exception exn);
    internal static void informationalWarning(Exception exn);
    internal static T error(Exception exn);
    internal static T simulateError(PhasedDiagnostic diagnostic);
    internal static void diagnosticSink(PhasedDiagnostic diagnostic, FSharpDiagnosticSeverity severity);
    internal static void errorSink(PhasedDiagnostic diagnostic);
    internal static void warnSink(PhasedDiagnostic diagnostic);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void errorRecovery(Exception exn, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void stopProcessingRecovery(Exception exn, Range m);
    internal static void errorRecoveryNoRange(Exception exn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void deprecatedWithError(string s, Range m);
    internal static void libraryOnlyError(Range m);
    internal static void libraryOnlyWarning(Range m);
    internal static void deprecatedOperator(Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void mlCompatWarning(string s, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void mlCompatError(string s, Range m);
    [DebuggerStepThroughAttribute]
internal static T suppressErrorReporting(FSharpFunc`2<Unit, T> f);
    [DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T conditionallySuppressErrorReporting(bool cond, FSharpFunc`2<Unit, T> f);
    internal static void ReportWarnings(FSharpList`1<a> warns);
    internal static T CommitOperationResult(OperationResult`1<T> res);
    internal static void RaiseOperationResult(OperationResult`1<Unit> res);
    internal static OperationResult`1<T> ErrorD(Exception err);
    internal static OperationResult`1<Unit> WarnD(Exception err);
    internal static OperationResult`1<Unit> get_CompleteD();
    internal static OperationResult`1<T> ResultD(T x);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<Exception>, T>> CheckNoErrorsAndGetWarnings(OperationResult`1<T> res);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<b> bind(FSharpFunc`2<T, OperationResult`1<b>> f, OperationResult`1<T> res);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> IterateD(FSharpFunc`2<T, OperationResult`1<Unit>> f, FSharpList`1<T> xs);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> WhileD(FSharpFunc`2<Unit, bool> gd, FSharpFunc`2<Unit, OperationResult`1<Unit>> body);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<FSharpList`1<b>> MapD_loop(FSharpFunc`2<a, OperationResult`1<b>> f, FSharpList`1<b> acc, FSharpList`1<a> xs);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<FSharpList`1<b>> MapD(FSharpFunc`2<T, OperationResult`1<b>> f, FSharpList`1<T> xs);
    internal static TrackErrorsBuilder get_trackErrors();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> OptionD(FSharpFunc`2<T, OperationResult`1<Unit>> f, FSharpOption`1<T> xs);
    internal static OperationResult`1<Unit> loop@713-28(FSharpFunc`2<int, FSharpFunc`2<T, OperationResult`1<Unit>>> f, FSharpList`1<T> xs, int i);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> IterateIdxD(FSharpFunc`2<int, FSharpFunc`2<T, OperationResult`1<Unit>>> f, FSharpList`1<T> xs);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> Iterate2D(FSharpFunc`2<T, FSharpFunc`2<b, OperationResult`1<Unit>>> f, FSharpList`1<T> xs, FSharpList`1<b> ys);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<T> TryD(FSharpFunc`2<Unit, OperationResult`1<T>> f, FSharpFunc`2<Exception, OperationResult`1<T>> g);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<Unit> f@658-1(int nDeep, FSharpFunc`2<int, OperationResult`1<bool>> body, bool x);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<Unit> RepeatWhileD(int nDeep, FSharpFunc`2<int, OperationResult`1<bool>> body);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> AtLeastOneD(FSharpFunc`2<T, OperationResult`1<bool>> f, FSharpList`1<T> l);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<bool> AtLeastOne2D(FSharpFunc`2<T, FSharpFunc`2<b, OperationResult`1<bool>>> f, FSharpList`1<T> xs, FSharpList`1<b> ys);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<b> MapReduceD(FSharpFunc`2<T, OperationResult`1<b>> mapper, b zero, FSharpFunc`2<b, FSharpFunc`2<b, b>> reducer, FSharpList`1<T> l);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<c> MapReduce2D(FSharpFunc`2<T, FSharpFunc`2<T2, OperationResult`1<c>>> mapper, c zero, FSharpFunc`2<c, FSharpFunc`2<c, c>> reducer, FSharpList`1<T> xs, FSharpList`1<T2> ys);
    internal static string get_stringThatIsAProxyForANewlineInFlatErrors();
    internal static string NewlineifyErrorString(string message);
    internal static string NormalizeErrorString(string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception languageFeatureError(LanguageVersion langVersion, LanguageFeature langFeature, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Exception> tryLanguageFeatureErrorAux(LanguageVersion langVersion, LanguageFeature langFeature, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkLanguageFeatureError(LanguageVersion langVersion, LanguageFeature langFeature, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkLanguageFeatureAndRecover(LanguageVersion langVersion, LanguageFeature langFeature, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Exception> tryLanguageFeatureErrorOption(LanguageVersion langVersion, LanguageFeature langFeature, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T languageFeatureNotSupportedInLibraryError(LanguageFeature langFeature, Range m);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Driver : object {
    internal static DiagnosticsLogger ConsoleDiagnosticsLogger(TcConfigBuilder tcConfigB, Exiter exiter);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CapturingDiagnosticsLogger.CommitDelayedDiagnostics(CapturingDiagnosticsLogger x, IDiagnosticsLoggerProvider diagnosticsLoggerProvider, TcConfigBuilder tcConfigB, Exiter exiter);
    internal static void AbortOnError(DiagnosticsLogger diagnosticsLogger, Exiter exiter);
    internal static Tuple`4<TcState, TopAttribs, FSharpList`1<CheckedImplFile>, TcEnv> TypeCheck(CompilationThreadToken ctok, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, DiagnosticsLogger diagnosticsLogger, string assemblyName, TcEnv tcEnv0, FSharpList`1<OpenDeclaration> openDecls0, FSharpList`1<ParsedInput> inputs, Exiter exiter);
    [CompilerGeneratedAttribute]
internal static bool contains@1-27(string fileName, a e, FSharpList`1<string> xs1);
    internal static void AddIfNotPresent@213(FSharpRef`1<FSharpList`1<string>> allSources, string fileName);
    [CompilerGeneratedAttribute]
internal static void AppendClosureInformation$cont@219(TcConfigBuilder tcConfigB, LexResourceManager lexResourceManager, DependencyProvider dependencyProvider, TcConfig tcConfig, string fileName, FSharpRef`1<FSharpList`1<string>> allSources, Unit unitVar);
    internal static void AppendClosureInformation@217(TcConfigBuilder tcConfigB, LexResourceManager lexResourceManager, DependencyProvider dependencyProvider, TcConfig tcConfig, FSharpRef`1<FSharpList`1<string>> allSources, string fileName);
    internal static FSharpList`1<string> AdjustForScriptCompile(TcConfigBuilder tcConfigB, FSharpList`1<string> commandLineSourceFiles, LexResourceManager lexResourceManager, DependencyProvider dependencyProvider);
    internal static void SetProcessThreadLocals(TcConfigBuilder tcConfigB);
    internal static FSharpList`1<string> ProcessCommandLineFlags(TcConfigBuilder tcConfigB, FSharpOption`1<int> lcidFromCodePage, String[] argv);
    internal static void copyFileIfDifferent@401(string src, string dest);
    internal static void CopyFSharpCore(string outFile, FSharpList`1<AssemblyReference> referencedDlls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILVersionInfo> TryFindVersionAttribute(TcGlobals g, string attrib, string attribName, FSharpList`1<Attrib> attribs, bool deterministic);
    internal static FSharpOption`1<ParallelReferenceResolution> getParallelReferenceResolutionFromEnvironment();
    internal static FSharpFunc`2<a, FSharpOption`1<b>> tryGetMetadataSnapshot@498();
    internal static Args`1<Tuple`8<CompilationThreadToken, TcGlobals, TcImports, TcImports, CcuThunk, FSharpList`1<CheckedImplFile>, TopAttribs, Tuple`7<TcConfig, string, FSharpOption`1<string>, string, DiagnosticsLogger, Exiter, FSharpList`1<ILSourceDocument>>>> main1(CompilationThreadToken ctok, String[] argv, LegacyReferenceResolver legacyReferenceResolver, bool bannerAlreadyPrinted, ReduceMemoryFlag reduceMemoryUsage, CopyFSharpCoreFlag defaultCopyFSharpCore, Exiter exiter, IDiagnosticsLoggerProvider diagnosticsLoggerProvider, DisposablesTracker disposables);
    internal static Args`1<Tuple`8<a, TcConfig, TcImports, c, b, DiagnosticsLogger, CcuThunk, Tuple`8<d, FSharpList`1<CheckedImplFile>, TopAttribs, e, string, FSharpOption`1<ILVersionInfo>, StrongNameSigningInfo, Tuple`2<Exiter, g>>>> main2(Args`1<Tuple`8<a, b, TcImports, c, CcuThunk, FSharpList`1<CheckedImplFile>, TopAttribs, Tuple`7<TcConfig, d, e, string, f, Exiter, g>>> _arg1);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<int> refAssemblySignatureHash$cont@895(FSharpList`1<CheckedImplFile> typedImplFiles, TopAttribs topAttrs, b tcGlobals, TcConfig tcConfig, FSharpList`1<ILResource> optDataResources, Unit unitVar);
    internal static Args`1<Tuple`8<a, TcConfig, TcImports, b, DiagnosticsLogger, CcuThunk, string, Tuple`8<CheckedAssemblyAfterOptimization, TopAttribs, c, d, FSharpList`1<ILAttribute>, FSharpList`1<ILResource>, FSharpList`1<ILResource>, Tuple`6<e, f, string, Exiter, g, FSharpOption`1<int>>>>> main3(Args`1<Tuple`8<a, TcConfig, TcImports, TcImports, b, DiagnosticsLogger, CcuThunk, Tuple`8<string, FSharpList`1<CheckedImplFile>, TopAttribs, c, d, e, f, Tuple`2<Exiter, g>>>> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Args`1<Tuple`8<CompilationThreadToken, TcConfig, TcImports, TcGlobals, b, FSharpFunc`2<ILModuleDef, ILModuleDef>, string, Tuple`6<FSharpOption`1<c>, ILModuleDef, d, Exiter, e, f>>> main4(FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<a> dynamicAssemblyCreator, Args`1<Tuple`8<CompilationThreadToken, TcConfig, TcImports, TcGlobals, b, CcuThunk, string, Tuple`8<CheckedAssemblyAfterOptimization, TopAttribs, FSharpOption`1<c>, string, FSharpList`1<ILAttribute>, FSharpList`1<ILResource>, FSharpList`1<ILResource>, Tuple`6<FSharpOption`1<ILVersionInfo>, d, string, Exiter, e, f>>>> _arg1);
    internal static Args`1<Tuple`8<a, b, c, d, DiagnosticsLogger, f, g, Tuple`5<h, i, Exiter, j, k>>> main5(Args`1<Tuple`8<a, b, c, d, DiagnosticsLogger, FSharpFunc`2<e, f>, g, Tuple`6<h, e, i, Exiter, j, k>>> _arg1);
    [CompilerGeneratedAttribute]
internal static void main6$cont@1141(TcGlobals tcGlobals, TcConfig tcConfig, StrongNameSigningInfo signingInfo, FSharpOption`1<int> refAssemblySignatureHash, ILModuleDef ilxMainModule, FSharpList`1<ILSourceDocument> ilSourceDocs, Exiter exiter, string outfile, FSharpOption`1<string> pdbfile, FSharpFunc`2<ILAssemblyRef, ILAssemblyRef> normalizeAssemblyRefs, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void main6(FSharpOption`1<FSharpFunc`2<Tuple`4<TcConfig, TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator, Args`1<Tuple`8<CompilationThreadToken, TcConfig, TcImports, TcGlobals, DiagnosticsLogger, ILModuleDef, string, Tuple`5<FSharpOption`1<string>, StrongNameSigningInfo, Exiter, FSharpList`1<ILSourceDocument>, FSharpOption`1<int>>>> _arg1);
    internal static void CompileFromCommandLineArguments(CompilationThreadToken ctok, String[] argv, LegacyReferenceResolver legacyReferenceResolver, bool bannerAlreadyPrinted, ReduceMemoryFlag reduceMemoryUsage, CopyFSharpCoreFlag defaultCopyFSharpCore, Exiter exiter, IDiagnosticsLoggerProvider loggerProvider, FSharpOption`1<FSharpFunc`2<TcImports, Unit>> tcImportsCapture, FSharpOption`1<FSharpFunc`2<Tuple`4<TcConfig, TcGlobals, string, ILModuleDef>, Unit>> dynamicAssemblyCreator);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.AssemblyContent : object {
    internal static FSharpOption`1<String[]> getNamespace@112(String[] idents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnresolvedSymbol UnresolvedSymbol(FSharpOption`1<String[]> topRequireQualifiedAccessParent, String[] cleanedIdents, string fullName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<AssemblySymbol> createEntity(FSharpOption`1<String[]> ns, Parent parent, FSharpEntity entity);
    internal static AssemblySymbol processIdents@161(FSharpOption`1<String[]> ns, Parent parent, FSharpOption`1<String[]> topRequireQualifiedAccessParent, FSharpOption`1<String[]> autoOpenParent, FSharpMemberOrFunctionOrValue func, string fullName, String[] idents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<AssemblySymbol> traverseMemberFunctionAndValues(FSharpOption`1<String[]> ns, Parent parent, IEnumerable`1<FSharpMemberOrFunctionOrValue> membersFunctionsAndValues);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<AssemblySymbol> traverseEntity(AssemblyContentType contentType, Parent parent, FSharpEntity entity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<AssemblySymbol> GetAssemblySignatureContent(AssemblyContentType contentType, FSharpAssemblySignature signature);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<AssemblySymbol> getAssemblySignaturesContent(AssemblyContentType contentType, FSharpList`1<FSharpAssembly> assemblies);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpList`1<AssemblySymbol> GetAssemblyContent(FSharpFunc`2<FSharpFunc`2<IAssemblyContentCache, FSharpList`1<AssemblySymbol>>, FSharpList`1<AssemblySymbol>> withCache, AssemblyContentType contentType, FSharpOption`1<string> fileName, FSharpList`1<FSharpAssembly> assemblies);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.EditorServices.AssemblyContentCacheEntry : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal DateTime FileWriteTime@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal AssemblyContentType ContentType@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<AssemblySymbol> Symbols@;
    [CompilationMappingAttribute("4", "0")]
internal DateTime FileWriteTime { get; }
    [CompilationMappingAttribute("4", "1")]
internal AssemblyContentType ContentType { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpList`1<AssemblySymbol> Symbols { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.AssemblyContentCacheEntry")]
internal AssemblyContentCacheEntry(DateTime fileWriteTime, AssemblyContentType contentType, FSharpList`1<AssemblySymbol> symbols);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DateTime get_FileWriteTime();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal AssemblyContentType get_ContentType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<AssemblySymbol> get_Symbols();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.AssemblyContentType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AssemblyContentType _unique_Public;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AssemblyContentType _unique_Full;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static AssemblyContentType Public { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPublic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static AssemblyContentType Full { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFull { get; }
    private static AssemblyContentType();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.AssemblyContentType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal AssemblyContentType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static AssemblyContentType get_Public();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPublic();
    [CompilationMappingAttribute("8", "1")]
public static AssemblyContentType get_Full();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFull();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(AssemblyContentType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AssemblyContentType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.AssemblySymbol : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FullName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] CleanedIdents@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> Namespace@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> NearestRequireQualifiedAccessParent@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> TopRequireQualifiedAccessParent@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> AutoOpenParent@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSymbol Symbol@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<LookupType, EntityKind> Kind@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UnresolvedSymbol UnresolvedSymbol@;
    [CompilationMappingAttribute("4", "0")]
public string FullName { get; }
    [CompilationMappingAttribute("4", "1")]
public String[] CleanedIdents { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<String[]> Namespace { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<String[]> NearestRequireQualifiedAccessParent { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpOption`1<String[]> TopRequireQualifiedAccessParent { get; }
    [CompilationMappingAttribute("4", "5")]
public FSharpOption`1<String[]> AutoOpenParent { get; }
    [CompilationMappingAttribute("4", "6")]
public FSharpSymbol Symbol { get; }
    [CompilationMappingAttribute("4", "7")]
public FSharpFunc`2<LookupType, EntityKind> Kind { get; }
    [CompilationMappingAttribute("4", "8")]
public UnresolvedSymbol UnresolvedSymbol { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.AssemblySymbol")]
public AssemblySymbol(string fullName, String[] cleanedIdents, FSharpOption`1<String[]> namespace, FSharpOption`1<String[]> nearestRequireQualifiedAccessParent, FSharpOption`1<String[]> topRequireQualifiedAccessParent, FSharpOption`1<String[]> autoOpenParent, FSharpSymbol symbol, FSharpFunc`2<LookupType, EntityKind> kind, UnresolvedSymbol unresolvedSymbol);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public String[] get_CleanedIdents();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<String[]> get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<String[]> get_NearestRequireQualifiedAccessParent();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<String[]> get_TopRequireQualifiedAccessParent();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<String[]> get_AutoOpenParent();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSymbol get_Symbol();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpFunc`2<LookupType, EntityKind> get_Kind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public UnresolvedSymbol get_UnresolvedSymbol();
    public virtual string ToString();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.CodeGenerationUtils : object {
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> keywordSet { get; }
    internal static FSharpSet`1<string> get_keywordSet();
    internal static int getAvailableIndex@67(FSharpSet`1<int> indexes, int idx);
    [CompilerGeneratedAttribute]
internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> normalizeArgName$cont@61(FSharpMap`2<string, FSharpSet`1<int>> namesWithIndices, string nm, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> normalizeArgName(FSharpMap`2<string, FSharpSet`1<int>> namesWithIndices, string nm);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.CompletionContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_Invalid;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_RangeOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_AttributeApplication;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_Type;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_UnionCaseFieldsDeclaration;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionContext _unique_TypeAbbreviationOrSingleCaseUnion;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext Invalid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInvalid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext RangeOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRangeOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParameterList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext AttributeApplication { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAttributeApplication { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpenDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext UnionCaseFieldsDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnionCaseFieldsDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionContext TypeAbbreviationOrSingleCaseUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeAbbreviationOrSingleCaseUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPattern { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethodOverride { get; }
    private static CompletionContext();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.CompletionContext")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CompletionContext(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static CompletionContext get_Invalid();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInvalid();
    [CompilationMappingAttribute("8", "1")]
public static CompletionContext NewInherit(InheritanceContext _context, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> _path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInherit();
    [CompilationMappingAttribute("8", "2")]
public static CompletionContext NewRecordField(RecordContext _context);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecordField();
    [CompilationMappingAttribute("8", "3")]
public static CompletionContext get_RangeOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRangeOperator();
    [CompilationMappingAttribute("8", "4")]
public static CompletionContext NewParameterList(Position item1, HashSet`1<string> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParameterList();
    [CompilationMappingAttribute("8", "5")]
public static CompletionContext get_AttributeApplication();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAttributeApplication();
    [CompilationMappingAttribute("8", "6")]
public static CompletionContext NewOpenDeclaration(bool _isOpenType);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpenDeclaration();
    [CompilationMappingAttribute("8", "7")]
public static CompletionContext get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "8")]
public static CompletionContext get_UnionCaseFieldsDeclaration();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnionCaseFieldsDeclaration();
    [CompilationMappingAttribute("8", "9")]
public static CompletionContext get_TypeAbbreviationOrSingleCaseUnion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeAbbreviationOrSingleCaseUnion();
    [CompilationMappingAttribute("8", "10")]
public static CompletionContext NewPattern(PatternContext _context);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPattern();
    [CompilationMappingAttribute("8", "11")]
public static CompletionContext NewMethodOverride(Range _enclosingTypeNameRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethodOverride();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompletionContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.EditorServices.CompletionItem : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ItemWithInst ItemWithInst@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal CompletionItemKind Kind@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOwnMember@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int MinorPriority@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<EntityRef> Type@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<UnresolvedSymbol> Unresolved@;
    [CompilationMappingAttribute("4", "0")]
internal ItemWithInst ItemWithInst { get; }
    [CompilationMappingAttribute("4", "1")]
internal CompletionItemKind Kind { get; }
    [CompilationMappingAttribute("4", "2")]
internal bool IsOwnMember { get; }
    [CompilationMappingAttribute("4", "3")]
internal int MinorPriority { get; }
    [CompilationMappingAttribute("4", "4")]
internal FSharpOption`1<EntityRef> Type { get; }
    [CompilationMappingAttribute("4", "5")]
internal FSharpOption`1<UnresolvedSymbol> Unresolved { get; }
    internal Item Item { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.CompletionItem")]
internal CompletionItem(ItemWithInst itemWithInst, CompletionItemKind kind, bool isOwnMember, int minorPriority, FSharpOption`1<EntityRef> type, FSharpOption`1<UnresolvedSymbol> unresolved);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ItemWithInst get_ItemWithInst();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CompletionItemKind get_Kind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOwnMember();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_MinorPriority();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<EntityRef> get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<UnresolvedSymbol> get_Unresolved();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal Item get_Item();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.CompletionItemKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_SuggestedName;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Event;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Argument;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_CustomOperation;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static CompletionItemKind _unique_Other;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind SuggestedName { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSuggestedName { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Event { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Argument { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArgument { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind CustomOperation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCustomOperation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static CompletionItemKind Other { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOther { get; }
    private static CompletionItemKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.CompletionItemKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal CompletionItemKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static CompletionItemKind get_SuggestedName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSuggestedName();
    [CompilationMappingAttribute("8", "1")]
public static CompletionItemKind get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "2")]
public static CompletionItemKind get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "3")]
public static CompletionItemKind NewMethod(bool _isExtension);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "4")]
public static CompletionItemKind get_Event();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute("8", "5")]
public static CompletionItemKind get_Argument();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArgument();
    [CompilationMappingAttribute("8", "6")]
public static CompletionItemKind get_CustomOperation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCustomOperation();
    [CompilationMappingAttribute("8", "7")]
public static CompletionItemKind get_Other();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOther();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(CompletionItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CompletionItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.DeclarationListHelpers : object {
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> ToolTipFault { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static ToolTipText emptyToolTip { get; }
    internal static FSharpOption`1<string> get_ToolTipFault();
    internal static void set_ToolTipFault(FSharpOption`1<string> value);
    internal static ToolTipText get_emptyToolTip();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ToolTipElement FormatOverloadsToList(InfoReader infoReader, Range m, DisplayEnv denv, ItemWithInst item, IEnumerable`1<MethInfo> minfos, FSharpOption`1<FSharpSymbol> symbol, FSharpOption`1<int> width);
    internal static IPartialEqualityComparer`1<CompletionItem> CompletionItemDisplayPartialEquality(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<CompletionItem> RemoveDuplicateCompletionItems(TcGlobals g, FSharpList`1<CompletionItem> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<CompletionItem> RemoveExplicitlySuppressedCompletionItems(TcGlobals g, FSharpList`1<CompletionItem> items);
    internal static FSharpList`1<EntityRef> RemoveDuplicateModuleRefs(FSharpList`1<EntityRef> modrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout OutputFullName(bool displayFullName, FSharpFunc`2<a, FSharpOption`1<b>> ppF, FSharpFunc`2<a, Layout> fnF, a r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ToolTipElement FormatItemDescriptionToToolTipElement(bool displayFullName, InfoReader infoReader, AccessorDomain ad, Range m, DisplayEnv denv, ItemWithInst item, FSharpOption`1<FSharpSymbol> symbol, FSharpOption`1<int> width);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ToolTipElement FormatStructuredDescriptionOfItem(bool isDecl, InfoReader infoReader, AccessorDomain ad, Range m, DisplayEnv denv, ItemWithInst item, FSharpOption`1<FSharpSymbol> symbol, FSharpOption`1<int> width);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.DeclarationListInfo : object {
    internal bool isForType;
    internal bool isError;
    internal DeclarationListItem[] declarations;
    internal static String[] fsharpNamespace;
    internal static DeclarationListInfo empty;
    internal static int init@1065;
    public DeclarationListItem[] Items { get; }
    public bool IsForType { get; }
    public bool IsError { get; }
    public static DeclarationListInfo Empty { get; }
    internal DeclarationListInfo(DeclarationListItem[] declarations, bool isForType, bool isError);
    private static DeclarationListInfo();
    public DeclarationListItem[] get_Items();
    public bool get_IsForType();
    public bool get_IsError();
    internal static DeclarationListInfo Create(InfoReader infoReader, AccessorDomain ad, Range m, DisplayEnv denv, FSharpFunc`2<Item, FSharpAccessibility> getAccessibility, FSharpList`1<CompletionItem> items, FSharpOption`1<String[]> currentNamespace, bool isAttributeApplicationContext);
    internal static DeclarationListInfo Error(string message);
    public static DeclarationListInfo get_Empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static bool isOperatorItem(string name, FSharpList`1<CompletionItem> items);
    [CompilerGeneratedAttribute]
internal static bool isActivePatternItem(FSharpList`1<CompletionItem> items);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.DeclarationListItem : object {
    internal string textInDeclList;
    internal string textInCode;
    internal int priority;
    internal FSharpOption`1<string> namespaceToOpen;
    internal CompletionItemKind kind;
    internal bool isResolved;
    internal bool isOwnMember;
    internal FSharpChoice`2<Tuple`5<FSharpList`1<CompletionItem>, InfoReader, AccessorDomain, Range, DisplayEnv>, ToolTipText> info;
    internal FSharpGlyph glyph;
    internal string fullName;
    internal FSharpAccessibility accessibility;
    [ObsoleteAttribute("Renamed to NameInList - this is the text to appear in the declaration list, while NameInCode is the text inserted on completion.")]
public string Name { get; }
    public string NameInList { get; }
    public string NameInCode { get; }
    public ToolTipText Description { get; }
    public FSharpGlyph Glyph { get; }
    public FSharpAccessibility Accessibility { get; }
    public CompletionItemKind Kind { get; }
    public bool IsOwnMember { get; }
    public int MinorPriority { get; }
    public string FullName { get; }
    public bool IsResolved { get; }
    public FSharpOption`1<string> NamespaceToOpen { get; }
    internal DeclarationListItem(string textInDeclList, string textInCode, string fullName, FSharpGlyph glyph, FSharpChoice`2<Tuple`5<FSharpList`1<CompletionItem>, InfoReader, AccessorDomain, Range, DisplayEnv>, ToolTipText> info, FSharpAccessibility accessibility, CompletionItemKind kind, bool isOwnMember, int priority, bool isResolved, FSharpOption`1<string> namespaceToOpen);
    public string get_Name();
    public string get_NameInList();
    public string get_NameInCode();
    public ToolTipText get_Description();
    public FSharpGlyph get_Glyph();
    public FSharpAccessibility get_Accessibility();
    public CompletionItemKind get_Kind();
    public bool get_IsOwnMember();
    public int get_MinorPriority();
    public string get_FullName();
    public bool get_IsResolved();
    public FSharpOption`1<string> get_NamespaceToOpen();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.DescriptionListsImpl : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFunction(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string printCanonicalizedTypeName(TcGlobals g, DisplayEnv denv, TType tauTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodGroupItemParameter PrettyParamOfRecdField(TcGlobals g, DisplayEnv denv, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodGroupItemParameter PrettyParamOfUnionCaseField(TcGlobals g, DisplayEnv denv, FSharpFunc`2<int, FSharpFunc`2<RecdField, bool>> isGenerated, int i, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<MethodGroupItemParameter>, Layout, Layout> PrettyParamsOfParamDatas(TcGlobals g, DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> typarInst, FSharpList`1<ParamData> paramDatas, TType paramTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<MethodGroupItemParameter>, Layout, Layout> PrettyParamsOfTypes(TcGlobals g, DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> typarInst, FSharpList`1<TType> paramTys, TType retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodGroupItemParameter[] StaticParamsOfItem(InfoReader infoReader, Range m, DisplayEnv denv, Item item);
    internal static Tuple`2<FSharpList`1<MethodGroupItemParameter>, Layout> getPrettyParamsOfTypes@708(ItemWithInst item, TcGlobals g, DisplayEnv denv, ValRef vref, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<MethodGroupItemParameter>, Layout> PrettyParamsAndReturnTypeOfItem(InfoReader infoReader, Range m, DisplayEnv denv, ItemWithInst item);
    internal static FSharpGlyph reprToGlyph@885(TyconRepresentation repr);
    internal static FSharpGlyph typeToGlyph@911(DisplayEnv denv, TType ty);
    [CompilerGeneratedAttribute]
internal static FSharpGlyph GlyphOfItem$cont@953(EntityRef tcref, Unit unitVar);
    internal static FSharpGlyph GlyphOfItem(DisplayEnv denv, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> SelectMethodGroupItems(TcGlobals g, Range m, Item item);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.EntityCache : object {
    internal Dictionary`2<string, AssemblyContentCacheEntry> dic;
    public void Clear();
    public T Locking(FSharpFunc`2<IAssemblyContentCache, T> f);
    private virtual override FSharpOption`1<AssemblyContentCacheEntry> FSharp.Compiler.EditorServices.IAssemblyContentCache.TryGet(string assembly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override void FSharp.Compiler.EditorServices.IAssemblyContentCache.Set(string assembly, AssemblyContentCacheEntry entry);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.EntityKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static EntityKind _unique_Attribute;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static EntityKind _unique_Type;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static EntityKind Attribute { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAttribute { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static EntityKind Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFunctionOrValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    private static EntityKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.EntityKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal EntityKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static EntityKind get_Attribute();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAttribute();
    [CompilationMappingAttribute("8", "1")]
public static EntityKind get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "2")]
public static EntityKind NewFunctionOrValue(bool _isActivePattern);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFunctionOrValue();
    [CompilationMappingAttribute("8", "3")]
public static EntityKind NewModule(ModuleKind item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(EntityKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(EntityKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.EntityModule : object {
    internal static String[] loop@164-97(String[] targetNs, String[] sourceNs, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] getRelativeNamespace(String[] targetNs, String[] sourceNs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] cutAutoOpenModules(FSharpOption`1<String[]> autoOpenParent, String[] candidateNs);
    internal static String[] getRelativeNs@224(String[] targetScope, FSharpOption`1<String[]> targetNamespace, FSharpOption`1<String[]> candidateNamespace, String[] ns);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<InsertionContextEntity> tryCreate$cont@236-1(String[] targetScope, FSharpOption`1<String[]> targetNamespace, FSharpOption`1<String[]> candidateNamespace, int identCount, String[] relativeNs, String[] fullOpenableNs, String[] restIdents, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<InsertionContextEntity> tryCreate$cont@212(String[] targetScope, FSharpOption`1<String[]> targetNamespace, FSharpOption`1<String[]> requiresQualifiedAccessParent, FSharpOption`1<String[]> candidateNamespace, String[] candidate, FSharpOption`1<String[]> autoOpenParent, String[] parts, Unit unitVar);
    internal static InsertionContextEntity[] tryCreate(FSharpOption`1<String[]> targetNamespace, String[] targetScope, MaybeUnresolvedIdent[] partiallyQualifiedName, FSharpOption`1<String[]> requiresQualifiedAccessParent, FSharpOption`1<String[]> autoOpenParent, FSharpOption`1<String[]> candidateNamespace, String[] candidate);
}
[SealedAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
public abstract class FSharp.Compiler.EditorServices.FindDeclExternalParam : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsParam { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsByref { get; }
    public bool IsByRef { get; }
    public FindDeclExternalType ParameterType { get; }
    [CompilationMappingAttribute("8", "0")]
internal static FindDeclExternalParam NewParam(FindDeclExternalType _parameterType);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsParam();
    [CompilationMappingAttribute("8", "1")]
internal static FindDeclExternalParam NewByref(FindDeclExternalType _parameterType);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsByref();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FindDeclExternalParam obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_IsByRef();
    public FindDeclExternalType get_ParameterType();
    public static FindDeclExternalParam Create(FindDeclExternalType parameterType, bool isByRef);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FindDeclExternalParam obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.FindDeclExternalParamModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FindDeclExternalParam> tryOfILType(String[] typeVarNames, ILType _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<FindDeclExternalParam>> tryOfILTypes(String[] typeVarNames, FSharpList`1<ILType> ilTypes);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{ToDebuggerDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.EditorServices.FindDeclExternalSymbol : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.FindDeclExternalSymbol")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FindDeclExternalSymbol(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FindDeclExternalSymbol NewType(string _fullName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "1")]
public static FindDeclExternalSymbol NewConstructor(string _typeName, FSharpList`1<FindDeclExternalParam> _args);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstructor();
    [CompilationMappingAttribute("8", "2")]
public static FindDeclExternalSymbol NewMethod(string _typeName, string _name, FSharpList`1<FindDeclExternalParam> _paramSyms, int _genericArity);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "3")]
public static FindDeclExternalSymbol NewField(string _typeName, string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "4")]
public static FindDeclExternalSymbol NewEvent(string _typeName, string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute("8", "5")]
public static FindDeclExternalSymbol NewProperty(string _typeName, string _name);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FindDeclExternalSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    internal string ToDebuggerDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FindDeclExternalSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.EditorServices.FindDeclExternalType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPointer { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeVar { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.FindDeclExternalType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FindDeclExternalType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FindDeclExternalType NewType(string _fullName, FSharpList`1<FindDeclExternalType> _genericArgs);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "1")]
public static FindDeclExternalType NewArray(FindDeclExternalType _inner);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArray();
    [CompilationMappingAttribute("8", "2")]
public static FindDeclExternalType NewPointer(FindDeclExternalType _inner);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPointer();
    [CompilationMappingAttribute("8", "3")]
public static FindDeclExternalType NewTypeVar(string _typeName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeVar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FindDeclExternalType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FindDeclExternalType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.FindDeclExternalTypeModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FindDeclExternalType> tryOfILType(String[] typeVarNames, ILType ilType);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.FindDeclFailureReason : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FindDeclFailureReason _unique_NoSourceCode;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FindDeclFailureReason NoSourceCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoSourceCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProvidedType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProvidedMember { get; }
    private static FindDeclFailureReason();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.FindDeclFailureReason")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FindDeclFailureReason(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FindDeclFailureReason NewUnknown(string _message);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknown();
    [CompilationMappingAttribute("8", "1")]
public static FindDeclFailureReason get_NoSourceCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoSourceCode();
    [CompilationMappingAttribute("8", "2")]
public static FindDeclFailureReason NewProvidedType(string _typeName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProvidedType();
    [CompilationMappingAttribute("8", "3")]
public static FindDeclFailureReason NewProvidedMember(string _memberName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProvidedMember();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FindDeclFailureReason obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FindDeclFailureReason obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.EditorServices.FindDeclResult : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDeclNotFound { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDeclFound { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExternalDecl { get; }
    [CompilationMappingAttribute("8", "0")]
public static FindDeclResult NewDeclNotFound(FindDeclFailureReason item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDeclNotFound();
    [CompilationMappingAttribute("8", "1")]
public static FindDeclResult NewDeclFound(Range _location);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDeclFound();
    [CompilationMappingAttribute("8", "2")]
public static FindDeclResult NewExternalDecl(string _assembly, FindDeclExternalSymbol _externalSym);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExternalDecl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FindDeclResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.FSharpGlyph : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Constant;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Delegate;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Enum;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_EnumMember;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Event;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Method;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_OverridenMethod;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_NameSpace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Struct;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Typedef;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Type;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Union;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Variable;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_ExtensionMethod;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_Error;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpGlyph _unique_TypeParameter;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Constant { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstant { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Delegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Enum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph EnumMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnumMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Event { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Exception { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Method { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph OverridenMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOverridenMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph NameSpace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNameSpace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Struct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStruct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Typedef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypedef { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Union { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Variable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVariable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph ExtensionMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExtensionMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph Error { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsError { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpGlyph TypeParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeParameter { get; }
    private static FSharpGlyph();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.FSharpGlyph")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpGlyph(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpGlyph get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "1")]
public static FSharpGlyph get_Constant();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstant();
    [CompilationMappingAttribute("8", "2")]
public static FSharpGlyph get_Delegate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDelegate();
    [CompilationMappingAttribute("8", "3")]
public static FSharpGlyph get_Enum();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnum();
    [CompilationMappingAttribute("8", "4")]
public static FSharpGlyph get_EnumMember();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnumMember();
    [CompilationMappingAttribute("8", "5")]
public static FSharpGlyph get_Event();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute("8", "6")]
public static FSharpGlyph get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "7")]
public static FSharpGlyph get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "8")]
public static FSharpGlyph get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "9")]
public static FSharpGlyph get_Method();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "10")]
public static FSharpGlyph get_OverridenMethod();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOverridenMethod();
    [CompilationMappingAttribute("8", "11")]
public static FSharpGlyph get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "12")]
public static FSharpGlyph get_NameSpace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNameSpace();
    [CompilationMappingAttribute("8", "13")]
public static FSharpGlyph get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "14")]
public static FSharpGlyph get_Struct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStruct();
    [CompilationMappingAttribute("8", "15")]
public static FSharpGlyph get_Typedef();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypedef();
    [CompilationMappingAttribute("8", "16")]
public static FSharpGlyph get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "17")]
public static FSharpGlyph get_Union();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnion();
    [CompilationMappingAttribute("8", "18")]
public static FSharpGlyph get_Variable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVariable();
    [CompilationMappingAttribute("8", "19")]
public static FSharpGlyph get_ExtensionMethod();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExtensionMethod();
    [CompilationMappingAttribute("8", "20")]
public static FSharpGlyph get_Error();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsError();
    [CompilationMappingAttribute("8", "21")]
public static FSharpGlyph get_TypeParameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeParameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpGlyph obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpGlyph obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.EditorServices.FSharpInheritanceOrigin : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInheritanceOrigin _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInheritanceOrigin _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInheritanceOrigin _unique_Unknown;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static FSharpInheritanceOrigin Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static FSharpInheritanceOrigin Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static FSharpInheritanceOrigin Unknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnknown { get; }
    private static FSharpInheritanceOrigin();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.FSharpInheritanceOrigin")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpInheritanceOrigin(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static FSharpInheritanceOrigin get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsClass();
    [CompilationMappingAttribute("8", "1")]
internal static FSharpInheritanceOrigin get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInterface();
    [CompilationMappingAttribute("8", "2")]
internal static FSharpInheritanceOrigin get_Unknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpInheritanceOrigin obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpInheritanceOrigin obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.EditorServices.FSharpModule : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] Idents@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range Range@;
    [CompilationMappingAttribute("4", "0")]
internal String[] Idents { get; }
    [CompilationMappingAttribute("4", "1")]
internal Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.FSharpModule")]
internal FSharpModule(String[] idents, Range range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal String[] get_Idents();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range get_Range();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpModule obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoComparisonAttribute]
[NoEqualityAttribute]
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.EditorServices.IAssemblyContentCache {
    public abstract virtual FSharpOption`1<AssemblyContentCacheEntry> TryGet(string );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual void Set(string , AssemblyContentCacheEntry );
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.InheritanceContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static InheritanceContext _unique_Unknown;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InheritanceContext Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InheritanceContext Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static InheritanceContext Unknown { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknown { get; }
    private static InheritanceContext();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.InheritanceContext")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal InheritanceContext(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static InheritanceContext get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "1")]
public static InheritanceContext get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "2")]
public static InheritanceContext get_Unknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknown();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InheritanceContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InheritanceContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.InsertionContext : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ScopeKind ScopeKind@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Position Pos@;
    [CompilationMappingAttribute("4", "0")]
public ScopeKind ScopeKind { get; }
    [CompilationMappingAttribute("4", "1")]
public Position Pos { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.InsertionContext")]
public InsertionContext(ScopeKind scopeKind, Position pos);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ScopeKind get_ScopeKind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Position get_Pos();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InsertionContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.InsertionContextEntity : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FullRelativeName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Qualifier@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> Namespace@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FullDisplayName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string LastIdent@;
    [CompilationMappingAttribute("4", "0")]
public string FullRelativeName { get; }
    [CompilationMappingAttribute("4", "1")]
public string Qualifier { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<string> Namespace { get; }
    [CompilationMappingAttribute("4", "3")]
public string FullDisplayName { get; }
    [CompilationMappingAttribute("4", "4")]
public string LastIdent { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.InsertionContextEntity")]
public InsertionContextEntity(string fullRelativeName, string qualifier, FSharpOption`1<string> namespace, string fullDisplayName, string lastIdent);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_FullRelativeName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Qualifier();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_FullDisplayName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_LastIdent();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(InsertionContextEntity obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InsertionContextEntity obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.EditorServices.InterfaceData : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsObjExpr { get; }
    public Range Range { get; }
    public String[] TypeParameters { get; }
    [CompilationMappingAttribute("8", "0")]
public static InterfaceData NewInterface(SynType _interfaceType, FSharpOption`1<FSharpList`1<SynMemberDefn>> _memberDefns);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "1")]
public static InterfaceData NewObjExpr(SynType _objType, FSharpList`1<SynBinding> _bindings);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsObjExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
    public String[] get_TypeParameters();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.InterfaceStubGenerator : object {
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@152-21(IEqualityComparer comp, Context this, Unit unitVar);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<T>, T>> |AllAndLast|_|(FSharpList`1<T> xs);
    internal static string getTypeParameterName(FSharpGenericParameter typar);
    internal static string bracket(string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatType(Context ctx, FSharpType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> formatArgUsage(Context ctx, bool hasTypeAnnotation, FSharpMap`2<string, FSharpSet`1<int>> namesWithIndices, FSharpParameter arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> formatArgsUsage(Context ctx, bool hasTypeAnnotation, FSharpMemberOrFunctionOrValue v, FSharpList`1<FSharpList`1<a>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<FSharpParameter>>, string> getArgTypes(Context ctx, FSharpMemberOrFunctionOrValue v);
    internal static string normalizePropertyName(FSharpMemberOrFunctionOrValue v);
    internal static bool isEventMember(FSharpMemberOrFunctionOrValue m);
    internal static Tuple`2<string, FSharpMap`2<string, FSharpSet`1<int>>> getParamArgs@314(bool verboseMode, FSharpList`1<FSharpList`1<FSharpParameter>> argInfos, Context ctx, FSharpMemberOrFunctionOrValue v);
    internal static string buildUsage@339(bool verboseMode, Context ctx, FSharpMemberOrFunctionOrValue v, FSharpList`1<FSharpList`1<FSharpParameter>> argInfos);
    internal static Tuple`4<string, FSharpList`1<string>, FSharpList`1<FSharpList`1<FSharpParameter>>, string> preprocess@338(bool verboseMode, Context ctx, FSharpMemberOrFunctionOrValue v);
    internal static FSharpFunc`2<ColumnIndentedTextWriter, Unit> closeDeclaration@372(bool verboseMode, string returnType);
    internal static FSharpFunc`2<ColumnIndentedTextWriter, Unit> writeImplementation@381(bool verboseMode, Context ctx);
    [CompilerGeneratedAttribute]
internal static void formatMember$cont@394(Context ctx, MemberInfo m, bool verboseMode, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void formatMember$cont@457-2(Context ctx, bool verboseMode, FSharpMemberOrFunctionOrValue v, string usage, string retType, FSharpList`1<FSharpList`1<FSharpParameter>> argInfos, FSharpFunc`2<ColumnIndentedTextWriter, Unit> writeImplementation, ColumnIndentedTextWriter writer, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void formatMember$cont@437-1(Context ctx, MemberInfo m, bool verboseMode, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void formatMember(Context ctx, MemberInfo m, bool verboseMode);
    internal static FSharpType getNonAbbreviatedType(FSharpType ty);
    internal static FSharpOption`1<FSharpType> |MemberFunctionType|_|(FSharpType ty);
    internal static FSharpOption`1<FSharpType> |TypeOfMember|_|(FSharpMemberOrFunctionOrValue m);
    internal static IEnumerable`1<Tuple`2<FSharpEntity, IEnumerable`1<Tuple`2<FSharpGenericParameter, FSharpType>>>> getInterfaces(FSharpEntity e);
    public static IEnumerable`1<Tuple`2<FSharpMemberOrFunctionOrValue, IEnumerable`1<Tuple`2<FSharpGenericParameter, FSharpType>>>> GetInterfaceMembers(FSharpEntity entity);
    public static bool HasNoInterfaceMember(FSharpEntity entity);
    internal static FSharpOption`1<Tuple`2<string, Range>> |LongIdentPattern|_|(SynPat _arg1);
    internal static FSharpOption`1<Tuple`2<string, Range>> |MemberNameAndRange|_|(SynBinding _arg1);
    public static FSharpList`1<Tuple`2<string, Range>> GetMemberNameAndRanges(InterfaceData interfaceData);
    internal static string normalizeEventName(FSharpMemberOrFunctionOrValue m);
    internal static FSharpOption`1<FSharpList`1<string>> formatMemberSignature@611(FSharpDisplayContext displayContext, FSharpSymbolUse symbolUse);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<FSharpList`1<string>> func1@1-31(FSharpDisplayContext displayContext, FSharpOption`1<FSharpSymbolUse> option);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<string> func2@1-14(FSharpOption`1<FSharpList`1<string>> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpAsync`1<FSharpSet`1<string>> GetImplementedMemberSignatures(FSharpFunc`2<Tuple`2<string, Range>, FSharpOption`1<FSharpSymbolUse>> getMemberByLocation, FSharpDisplayContext displayContext, InterfaceData interfaceData);
    public static bool IsInterface(FSharpEntity entity);
    internal static void formatMembers@728(int indentation, string objectIdent, FSharpDisplayContext displayContext, bool verboseMode, String[] lines, ColumnIndentedTextWriter writer, FSharpMap`2<string, string> instantiations, Context ctx, FSharpSet`1<string> duplicatedMembers, FSharpList`1<Tuple`2<FSharpMemberOrFunctionOrValue, a>> members);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string FormatInterface(int startColumn, int indentation, String[] typeInstances, string objectIdent, string methodBody, FSharpDisplayContext displayContext, FSharpSet`1<string> excludedMemberSignatures, FSharpEntity e, bool verboseMode);
    internal static FSharpOption`1<InterfaceData> walkSynModuleOrNamespace@765-6(Position pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynModuleOrNamespace _arg1);
    internal static FSharpOption`1<InterfaceData> walkSynTypeDefn@787-1(Position pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynTypeDefn _arg2);
    internal static FSharpOption`1<InterfaceData> walkSynTypeDefnRepr@794-1(Position pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynTypeDefnRepr typeDefnRepr);
    internal static FSharpOption`1<InterfaceData> walkBinding@830-3(Position pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynBinding _arg3);
    internal static FSharpOption`1<InterfaceData> walkExpr@832-11(Position pos, FSharpFunc`2<SynModuleDecl, FSharpOption`1<InterfaceData>> walkSynModuleDecl, FSharpFunc`2<SynMemberDefn, FSharpOption`1<InterfaceData>> walkSynMemberDefn, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<InterfaceData> TryFindInterfaceDeclaration(Position pos, ParsedInput parsedInput);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.LookupType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LookupType _unique_Fuzzy;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static LookupType _unique_Precise;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LookupType Fuzzy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFuzzy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static LookupType Precise { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPrecise { get; }
    private static LookupType();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.LookupType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal LookupType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static LookupType get_Fuzzy();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFuzzy();
    [CompilationMappingAttribute("8", "1")]
public static LookupType get_Precise();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPrecise();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(LookupType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LookupType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.MaybeUnresolvedIdent : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Ident@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool Resolved@;
    [CompilationMappingAttribute("4", "0")]
public string Ident { get; }
    [CompilationMappingAttribute("4", "1")]
public bool Resolved { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.MaybeUnresolvedIdent")]
public MaybeUnresolvedIdent(string ident, bool resolved);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Ident();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_Resolved();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(MaybeUnresolvedIdent obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MaybeUnresolvedIdent obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.MethodGroup : object {
    internal string name;
    internal static ConditionalWeakTable`2<ItemWithInst, MethodGroupItem[]> methodOverloadsCache;
    internal static MethodGroup empty;
    internal MethodGroupItem[] methods;
    internal static int init@1258-1;
    public string MethodName { get; }
    public MethodGroupItem[] Methods { get; }
    internal static MethodGroup Empty { get; }
    internal MethodGroup(string name, MethodGroupItem[] unsortedMethods);
    private static MethodGroup();
    public string get_MethodName();
    public MethodGroupItem[] get_Methods();
    internal static MethodGroup Create(InfoReader infoReader, AccessorDomain ad, Range m, DisplayEnv denv, FSharpList`1<ItemWithInst> items);
    internal static MethodGroup get_Empty();
}
[SealedAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.MethodGroupItem : object {
    internal FSharpXmlDoc xmlDoc;
    internal MethodGroupItemParameter[] staticParameters;
    internal TaggedText[] returnType;
    internal MethodGroupItemParameter[] parameters;
    internal bool hasParameters;
    internal bool hasParamArrayArg;
    internal ToolTipText description;
    public ToolTipText Description { get; }
    public FSharpXmlDoc XmlDoc { get; }
    public TaggedText[] ReturnTypeText { get; }
    public MethodGroupItemParameter[] Parameters { get; }
    public bool HasParameters { get; }
    public bool HasParamArrayArg { get; }
    public MethodGroupItemParameter[] StaticParameters { get; }
    internal MethodGroupItem(ToolTipText description, FSharpXmlDoc xmlDoc, TaggedText[] returnType, MethodGroupItemParameter[] parameters, bool hasParameters, bool hasParamArrayArg, MethodGroupItemParameter[] staticParameters);
    public ToolTipText get_Description();
    public FSharpXmlDoc get_XmlDoc();
    public TaggedText[] get_ReturnTypeText();
    public MethodGroupItemParameter[] get_Parameters();
    public bool get_HasParameters();
    public bool get_HasParamArrayArg();
    public MethodGroupItemParameter[] get_StaticParameters();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.MethodGroupItemParameter : object {
    internal string name;
    internal bool isOptional;
    internal TaggedText[] display;
    internal string canonicalTypeTextForSorting;
    public string ParameterName { get; }
    public string CanonicalTypeTextForSorting { get; }
    public TaggedText[] Display { get; }
    public bool IsOptional { get; }
    internal MethodGroupItemParameter(string name, string canonicalTypeTextForSorting, TaggedText[] display, bool isOptional);
    public string get_ParameterName();
    public string get_CanonicalTypeTextForSorting();
    public TaggedText[] get_Display();
    public bool get_IsOptional();
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.ModuleKind : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAutoOpen@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool HasModuleSuffix@;
    [CompilationMappingAttribute("4", "0")]
public bool IsAutoOpen { get; }
    [CompilationMappingAttribute("4", "1")]
public bool HasModuleSuffix { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.ModuleKind")]
public ModuleKind(bool isAutoOpen, bool hasModuleSuffix);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAutoOpen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_HasModuleSuffix();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ModuleKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ModuleKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
public abstract class FSharp.Compiler.EditorServices.NavigableContainer : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsContainer { get; }
    public string FullName { get; }
    public NavigableContainerType Type { get; }
    public string Name { get; }
    [CompilationMappingAttribute("8", "0")]
internal static NavigableContainer NewFile(string _fileName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFile();
    [CompilationMappingAttribute("8", "1")]
internal static NavigableContainer NewContainer(NavigableContainerType _containerType, FSharpList`1<string> _nameParts, NavigableContainer _parent);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsContainer();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NavigableContainer obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public string get_FullName();
    public NavigableContainerType get_Type();
    public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NavigableContainer obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.NavigableContainerType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableContainerType _unique_File;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableContainerType _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableContainerType _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableContainerType _unique_Type;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableContainerType _unique_Exception;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableContainerType File { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableContainerType Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableContainerType Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableContainerType Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableContainerType Exception { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    private static NavigableContainerType();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.NavigableContainerType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NavigableContainerType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static NavigableContainerType get_File();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFile();
    [CompilationMappingAttribute("8", "1")]
public static NavigableContainerType get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "2")]
public static NavigableContainerType get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "3")]
public static NavigableContainerType get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "4")]
public static NavigableContainerType get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NavigableContainerType obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NavigableContainerType obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.NavigableItem : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string Name@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool NeedsBackticks@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range Range@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSignature@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal NavigableItemKind Kind@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal NavigableContainer Container@;
    [CompilationMappingAttribute("4", "0")]
public string Name { get; }
    [CompilationMappingAttribute("4", "1")]
public bool NeedsBackticks { get; }
    [CompilationMappingAttribute("4", "2")]
public Range Range { get; }
    [CompilationMappingAttribute("4", "3")]
public bool IsSignature { get; }
    [CompilationMappingAttribute("4", "4")]
public NavigableItemKind Kind { get; }
    [CompilationMappingAttribute("4", "5")]
public NavigableContainer Container { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.NavigableItem")]
public NavigableItem(string name, bool needsBackticks, Range range, bool isSignature, NavigableItemKind kind, NavigableContainer container);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_NeedsBackticks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_Range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSignature();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public NavigableItemKind get_Kind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public NavigableContainer get_Container();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NavigableItem obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.NavigableItemKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_ModuleAbbreviation;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_Exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_Type;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_ModuleValue;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_Constructor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_Member;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_EnumCase;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigableItemKind _unique_UnionCase;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind ModuleAbbreviation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleAbbreviation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind Exception { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind ModuleValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind Constructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind Member { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind EnumCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnumCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigableItemKind UnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnionCase { get; }
    private static NavigableItemKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.NavigableItemKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NavigableItemKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static NavigableItemKind get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "1")]
public static NavigableItemKind get_ModuleAbbreviation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleAbbreviation();
    [CompilationMappingAttribute("8", "2")]
public static NavigableItemKind get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "3")]
public static NavigableItemKind get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "4")]
public static NavigableItemKind get_ModuleValue();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleValue();
    [CompilationMappingAttribute("8", "5")]
public static NavigableItemKind get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "6")]
public static NavigableItemKind get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "7")]
public static NavigableItemKind get_Constructor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstructor();
    [CompilationMappingAttribute("8", "8")]
public static NavigableItemKind get_Member();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMember();
    [CompilationMappingAttribute("8", "9")]
public static NavigableItemKind get_EnumCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnumCase();
    [CompilationMappingAttribute("8", "10")]
public static NavigableItemKind get_UnionCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnionCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NavigableItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NavigableItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.NavigateTo : object {
    internal static string convertToDisplayName@731(string name);
    internal static void addLongIdent@739(List`1<NavigableItem> result, NavigableItemKind kind, FSharpList`1<Ident> lid, bool isSignature, NavigableContainer container);
    internal static void addIdent@753(List`1<NavigableItem> result, NavigableItemKind kind, Ident id, bool isSignature, NavigableContainer container);
    internal static NavigableContainer addExceptionRepr@773(List`1<NavigableItem> result, SynExceptionDefnRepr exnRepr, bool isSig, NavigableContainer container);
    internal static NavigableContainer addComponentInfo@778(List`1<NavigableItem> result, NavigableContainerType containerType, NavigableItemKind kind, SynComponentInfo info, bool isSig, NavigableContainer container);
    internal static void addField@788(List`1<NavigableItem> result, SynField synField, bool isSig, NavigableContainer container);
    internal static FSharpFunc`2<NavigableContainer, Unit> addEnumCase@795(FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynEnumCase inp, bool isSig);
    internal static NavigableItemKind mapMemberKind@803(SynMemberKind mk);
    internal static void addBinding@812(List`1<NavigableItem> result, SynBinding synBinding, FSharpOption`1<NavigableItemKind> itemKind, NavigableContainer container);
    internal static void walkSigFileInput@841(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, ParsedSigFileInput file);
    internal static void walkSynModuleOrNamespaceSig@846(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynModuleOrNamespaceSig inp, NavigableContainer container);
    internal static void walkSynModuleSigDecl@862(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynModuleSigDecl decl, NavigableContainer container);
    internal static void walkSynTypeDefnSig@879(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynTypeDefnSig inp, NavigableContainer container);
    internal static void walkSynMemberSig@893(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynMemberSig synMemberSig, NavigableContainer container);
    internal static void walkImplFileInput@901(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, ParsedImplFileInput inp);
    internal static void walkSynModuleOrNamespace@905(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynModuleOrNamespace inp, NavigableContainer container);
    internal static void walkSynModuleDecl@921(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynModuleDecl decl, NavigableContainer container);
    internal static void walkSynTypeDefn@946(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynTypeDefn inp, NavigableContainer container);
    internal static void walkSynTypeDefnRepr@954(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynTypeDefnRepr typeDefnRepr, NavigableContainer container);
    internal static void walkSynTypeDefnSimpleRepr@962(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynTypeDefnSimpleRepr repr, bool isSig, NavigableContainer container);
    internal static void walkSynMemberDefn@980(List`1<NavigableItem> result, FSharpFunc`2<NavigableItemKind, FSharpFunc`2<Ident, FSharpFunc`2<bool, FSharpFunc`2<NavigableContainer, Unit>>>> addIdent, SynMemberDefn memberDefn, NavigableContainer container);
    public static NavigableItem[] GetNavigableItems(ParsedInput parsedInput);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.Navigation : object {
    [CompilationMappingAttribute("9")]
internal static NavigationItems empty { get; }
    public static NavigationItems getNavigation(ParsedInput parsedInput);
    internal static NavigationItems get_empty();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.NavigationEntityKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationEntityKind _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationEntityKind _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationEntityKind _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationEntityKind _unique_Exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationEntityKind _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationEntityKind _unique_Record;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationEntityKind _unique_Enum;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationEntityKind _unique_Union;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationEntityKind Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationEntityKind Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationEntityKind Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationEntityKind Exception { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationEntityKind Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationEntityKind Record { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationEntityKind Enum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationEntityKind Union { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnion { get; }
    private static NavigationEntityKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.NavigationEntityKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NavigationEntityKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static NavigationEntityKind get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "1")]
public static NavigationEntityKind get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "2")]
public static NavigationEntityKind get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "3")]
public static NavigationEntityKind get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "4")]
public static NavigationEntityKind get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "5")]
public static NavigationEntityKind get_Record();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute("8", "6")]
public static NavigationEntityKind get_Enum();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnum();
    [CompilationMappingAttribute("8", "7")]
public static NavigationEntityKind get_Union();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NavigationEntityKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NavigationEntityKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.NavigationImpl : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Tuple`2<NavigationItem, int>>, Range> rangeOfDecls { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range unionRangesChecked(Range r1, Range r2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range rangeOfDecls2(FSharpFunc`2<a, NavigationItem> f, FSharpList`1<a> decls);
    internal static FSharpFunc`2<FSharpList`1<Tuple`2<NavigationItem, int>>, Range> get_rangeOfDecls();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range moduleRange(Range idm, FSharpList`1<Tuple`3<NavigationItem, a, b>> others);
    internal static Range fldspecRange(SynUnionCaseKind fldspec);
    internal static int addItemName@132(Dictionary`2<string, int> names, string name);
    internal static string uniqueName@141(Dictionary`2<string, int> names, string name, int idx);
    internal static Tuple`3<NavigationItem, int, a> createDeclLid@146(Dictionary`2<string, int> names, string baseName, FSharpList`1<Ident> lid, NavigationItemKind kind, FSharpGlyph baseGlyph, Range m, Range mBody, a nested, NavigationEntityKind enclosingEntityKind, FSharpOption`1<SynAccess> access);
    internal static Tuple`3<NavigationItem, int, a> createDecl@151(Dictionary`2<string, int> names, string baseName, Ident id, NavigationItemKind kind, FSharpGlyph baseGlyph, Range m, Range mBody, a nested, NavigationEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
    internal static Tuple`3<NavigationItem, int, a> createTypeDecl@156(Dictionary`2<string, int> names, string baseName, FSharpList`1<Ident> lid, FSharpGlyph baseGlyph, Range m, Range mBody, a nested, NavigationEntityKind enclosingEntityKind, FSharpOption`1<SynAccess> access);
    internal static Tuple`2<NavigationItem, int> createMemberLid@160(Dictionary`2<string, int> names, FSharpList`1<Ident> lid, NavigationItemKind kind, FSharpGlyph baseGlyph, Range m, NavigationEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
    internal static Tuple`2<NavigationItem, int> createMember@164-1(Dictionary`2<string, int> names, Ident id, NavigationItemKind kind, FSharpGlyph baseGlyph, Range m, NavigationEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`2<NavigationItem, int>> processBinding$cont@180(Dictionary`2<string, int> names, NavigationEntityKind enclosingEntityKind, bool isAbstract, Range m, FSharpList`1<Ident> lid, SynMemberFlags flags, FSharpOption`1<SynAccess> access, Unit unitVar);
    internal static FSharpList`1<Tuple`2<NavigationItem, int>> processBinding@169(Dictionary`2<string, int> names, bool isMember, NavigationEntityKind enclosingEntityKind, bool isAbstract, SynBinding synBinding);
    internal static FSharpList`1<Tuple`3<NavigationItem, int, a>> processExnDefnRepr@226(Dictionary`2<string, int> names, FSharpFunc`2<bool, FSharpFunc`2<NavigationEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<NavigationItem, int>>>>>> processBinding, string baseName, a nested, SynExceptionDefnRepr synExnRepr);
    internal static FSharpList`1<Tuple`3<NavigationItem, int, FSharpList`1<Tuple`2<NavigationItem, int>>>> processExnDefn@236(Dictionary`2<string, int> names, FSharpFunc`2<bool, FSharpFunc`2<NavigationEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<NavigationItem, int>>>>>> processBinding, string baseName, SynExceptionDefn synExnDefn);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`3<NavigationItem, int, FSharpList`1<Tuple`2<NavigationItem, int>>>> processTycon$cont@262(Dictionary`2<string, int> names, string baseName, SynTypeDefnRepr repr, Range m, FSharpList`1<Ident> lid, FSharpOption`1<SynAccess> access, FSharpList`1<Tuple`2<NavigationItem, int>> topMembers, Unit unitVar);
    internal static FSharpList`1<Tuple`3<NavigationItem, int, FSharpList`1<Tuple`2<NavigationItem, int>>>> processTycon@241(Dictionary`2<string, int> names, FSharpFunc`2<bool, FSharpFunc`2<NavigationEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<NavigationItem, int>>>>>> processBinding, string baseName, SynTypeDefn synTypeDefn);
    internal static Tuple`2<Range, FSharpList`1<Tuple`2<NavigationItem, int>>> processMembers@321(Dictionary`2<string, int> names, FSharpFunc`2<bool, FSharpFunc`2<NavigationEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<NavigationItem, int>>>>>> processBinding, FSharpList`1<SynMemberDefn> members, NavigationEntityKind enclosingEntityKind);
    internal static FSharpList`1<Tuple`2<NavigationItem, int>> processNestedDeclarations@357(Dictionary`2<string, int> names, IEnumerable`1<SynModuleDecl> decls);
    internal static FSharpList`1<Tuple`3<NavigationItem, int, FSharpList`1<Tuple`2<NavigationItem, int>>>> processNavigationTopLevelDeclarations@369(Dictionary`2<string, int> names, FSharpFunc`2<bool, FSharpFunc`2<NavigationEntityKind, FSharpFunc`2<bool, FSharpFunc`2<SynBinding, FSharpList`1<Tuple`2<NavigationItem, int>>>>>> processBinding, string baseName, FSharpList`1<SynModuleDecl> decls);
    internal static NavigationItems getNavigationFromImplFile(FSharpList`1<SynModuleOrNamespace> modules);
    internal static int addItemName@455-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string name);
    internal static string uniqueName@460-4(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string name, int idx);
    internal static Tuple`3<NavigationItem, int, a> createDeclLid@465-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, FSharpList`1<Ident> lid, NavigationItemKind kind, FSharpGlyph baseGlyph, Range m, Range mBody, a nested, NavigationEntityKind enclosingEntityKind, FSharpOption`1<SynAccess> access);
    internal static Tuple`3<NavigationItem, int, a> createTypeDecl@470-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, FSharpList`1<Ident> lid, FSharpGlyph baseGlyph, Range m, Range mBody, a nested, NavigationEntityKind enclosingEntityKind, FSharpOption`1<SynAccess> access);
    internal static Tuple`3<NavigationItem, int, a> createDecl@473-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, Ident id, NavigationItemKind kind, FSharpGlyph baseGlyph, Range m, Range mBody, a nested, NavigationEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
    internal static Tuple`2<NavigationItem, int> createMember@478-2(FSharpRef`1<FSharpMap`2<string, int>> nameMap, Ident id, NavigationItemKind kind, FSharpGlyph baseGlyph, Range m, NavigationEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
    internal static FSharpList`1<Tuple`3<NavigationItem, int, a>> processExnRepr@482(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, a nested, SynExceptionDefnRepr inp);
    internal static FSharpList`1<Tuple`3<NavigationItem, int, FSharpList`1<Tuple`2<NavigationItem, int>>>> processExnSig@490(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, SynExceptionSig inp);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Tuple`3<NavigationItem, int, FSharpList`1<Tuple`2<NavigationItem, int>>>> processTycon$cont@512-1(string baseName, SynTypeDefnSigRepr repr, Range m, FSharpList`1<Ident> lid, FSharpOption`1<SynAccess> access, FSharpList`1<Tuple`2<NavigationItem, int>> topMembers, FSharpRef`1<FSharpMap`2<string, int>> nameMap, Unit unitVar);
    internal static FSharpList`1<Tuple`3<NavigationItem, int, FSharpList`1<Tuple`2<NavigationItem, int>>>> processTycon@495-1(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, SynTypeDefnSig inp);
    internal static FSharpList`1<Tuple`2<NavigationItem, int>> processSigMembers@556(FSharpRef`1<FSharpMap`2<string, int>> nameMap, FSharpList`1<SynMemberSig> members);
    internal static FSharpList`1<Tuple`2<NavigationItem, int>> processNestedSigDeclarations@568(FSharpRef`1<FSharpMap`2<string, int>> nameMap, IEnumerable`1<SynModuleSigDecl> decls);
    internal static FSharpList`1<Tuple`3<NavigationItem, int, FSharpList`1<Tuple`2<NavigationItem, int>>>> processNavigationTopLevelSigDeclarations@579(FSharpRef`1<FSharpMap`2<string, int>> nameMap, string baseName, FSharpList`1<SynModuleSigDecl> decls);
    internal static NavigationItems getNavigationFromSigFile(FSharpList`1<SynModuleOrNamespaceSig> modules);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.NavigationItem : object {
    internal string uniqueName;
    internal bool singleTopLevel;
    internal Range range;
    internal string logicalName;
    internal NavigationItemKind kind;
    internal bool isAbstract;
    internal FSharpGlyph glyph;
    internal NavigationEntityKind enclosingEntityKind;
    internal Range bodyRange@50;
    internal FSharpOption`1<SynAccess> access;
    internal Range bodyRange { get; }
    public string UniqueName { get; }
    public string LogicalName { get; }
    public FSharpGlyph Glyph { get; }
    public NavigationItemKind Kind { get; }
    public Range Range { get; }
    public Range BodyRange { get; }
    public bool IsSingleTopLevel { get; }
    public NavigationEntityKind EnclosingEntityKind { get; }
    public bool IsAbstract { get; }
    public FSharpOption`1<SynAccess> Access { get; }
    internal NavigationItem(string uniqueName, string logicalName, NavigationItemKind kind, FSharpGlyph glyph, Range range, Range bodyRange, bool singleTopLevel, NavigationEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
    internal Range get_bodyRange();
    public string get_UniqueName();
    public string get_LogicalName();
    public FSharpGlyph get_Glyph();
    public NavigationItemKind get_Kind();
    public Range get_Range();
    public Range get_BodyRange();
    public bool get_IsSingleTopLevel();
    public NavigationEntityKind get_EnclosingEntityKind();
    public bool get_IsAbstract();
    public FSharpOption`1<SynAccess> get_Access();
    internal NavigationItem WithUniqueName(string uniqueName);
    internal static NavigationItem Create(string name, NavigationItemKind kind, FSharpGlyph glyph, Range range, Range bodyRange, bool singleTopLevel, NavigationEntityKind enclosingEntityKind, bool isAbstract, FSharpOption`1<SynAccess> access);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.NavigationItemKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_ModuleFile;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_Exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_Type;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_Method;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NavigationItemKind _unique_Other;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind ModuleFile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleFile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind Exception { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind Method { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static NavigationItemKind Other { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOther { get; }
    private static NavigationItemKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.NavigationItemKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NavigationItemKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static NavigationItemKind get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "1")]
public static NavigationItemKind get_ModuleFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleFile();
    [CompilationMappingAttribute("8", "2")]
public static NavigationItemKind get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "3")]
public static NavigationItemKind get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "4")]
public static NavigationItemKind get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "5")]
public static NavigationItemKind get_Method();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "6")]
public static NavigationItemKind get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "7")]
public static NavigationItemKind get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "8")]
public static NavigationItemKind get_Other();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOther();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NavigationItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NavigationItemKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.NavigationItems : object {
    internal NavigationTopLevelDeclaration[] declarations;
    public NavigationTopLevelDeclaration[] Declarations { get; }
    internal NavigationItems(NavigationTopLevelDeclaration[] declarations);
    public NavigationTopLevelDeclaration[] get_Declarations();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.NavigationTopLevelDeclaration : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal NavigationItem Declaration@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal NavigationItem[] Nested@;
    [CompilationMappingAttribute("4", "0")]
public NavigationItem Declaration { get; }
    [CompilationMappingAttribute("4", "1")]
public NavigationItem[] Nested { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.NavigationTopLevelDeclaration")]
public NavigationTopLevelDeclaration(NavigationItem declaration, NavigationItem[] nested);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public NavigationItem get_Declaration();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public NavigationItem[] get_Nested();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.OpenStatementInsertionPoint : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OpenStatementInsertionPoint _unique_TopLevel;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static OpenStatementInsertionPoint _unique_Nearest;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static OpenStatementInsertionPoint TopLevel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTopLevel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static OpenStatementInsertionPoint Nearest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNearest { get; }
    private static OpenStatementInsertionPoint();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.OpenStatementInsertionPoint")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal OpenStatementInsertionPoint(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static OpenStatementInsertionPoint get_TopLevel();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTopLevel();
    [CompilationMappingAttribute("8", "1")]
public static OpenStatementInsertionPoint get_Nearest();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNearest();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(OpenStatementInsertionPoint obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OpenStatementInsertionPoint obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.Option : object {
    internal static FSharpOption`1<FSharpList`1<a>> ofOptionList(FSharpList`1<FSharpOption`1<a>> xs);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.ParameterLocations : object {
    internal Position openParenLocation;
    internal Range longIdRange;
    internal FSharpList`1<string> longId;
    internal bool isThereACloseParen;
    internal FSharpList`1<TupledArgumentLocation> argRanges;
    internal Position[] tupleEndLocations@29;
    internal FSharpOption`1[] namedParamNames@32-1;
    public FSharpList`1<string> LongId { get; }
    public Position LongIdStartLocation { get; }
    public Position LongIdEndLocation { get; }
    public Position OpenParenLocation { get; }
    public Position[] TupleEndLocations { get; }
    public bool IsThereACloseParen { get; }
    public FSharpOption`1[] NamedParamNames { get; }
    public TupledArgumentLocation[] ArgumentLocations { get; }
    internal ParameterLocations(FSharpList`1<string> longId, Range longIdRange, Position openParenLocation, FSharpList`1<TupledArgumentLocation> argRanges, FSharpList`1<Position> tupleEndLocations, bool isThereACloseParen, FSharpList`1<FSharpOption`1<string>> namedParamNames);
    public FSharpList`1<string> get_LongId();
    public Position get_LongIdStartLocation();
    public Position get_LongIdEndLocation();
    public Position get_OpenParenLocation();
    public Position[] get_TupleEndLocations();
    public bool get_IsThereACloseParen();
    public FSharpOption`1[] get_NamedParamNames();
    public TupledArgumentLocation[] get_ArgumentLocations();
    public static FSharpOption`1<ParameterLocations> Find(Position pos, ParsedInput parseTree);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.ParameterLocationsImpl : object {
    internal static bool isStaticArg(SynType _arg1);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<string>, Range>> digOutIdentFromFuncExpr(SynExpr synExpr);
    internal static FSharpOption`1<string> digOutIdentFromStaticArg(SynType _arg1);
    internal static FSharpOption`1<string> getNamedParamName(SynExpr e);
    internal static FSharpList`1<string> getTypeName(SynType synType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FindResult, FSharpOption`1<c>> handleSingleArg(FSharpFunc`2<SynExpr, FSharpOption`1<a>> traverseSynExpr, Position pos, SynExpr synExpr, Range parenRange, FSharpOption`1<b> rpRangeOpt);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FindResult, FSharpOption`1<FSharpOption`1<a>>> searchSynArgExpr$cont@150(FSharpFunc`2<SynExpr, FSharpOption`1<a>> traverseSynExpr, Position pos, SynExpr expr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FindResult, FSharpOption`1<FSharpOption`1<a>>> searchSynArgExpr(FSharpFunc`2<SynExpr, FSharpOption`1<a>> traverseSynExpr, Position pos, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ParameterLocations> |StaticParameters|_|(Position pos, SynType _arg1);
    internal static FSharpOption`1<ParameterLocations> traverseInput(Position pos, ParsedInput parseTree);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.EditorServices.Parent : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> Namespace@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> ThisRequiresQualifiedAccess@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> TopRequiresQualifiedAccess@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> AutoOpen@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<String[]> WithModuleSuffix@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsModule@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpOption`1<String[]> Namespace { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> ThisRequiresQualifiedAccess { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> TopRequiresQualifiedAccess { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpOption`1<String[]> AutoOpen { get; }
    [CompilationMappingAttribute("4", "4")]
internal FSharpOption`1<String[]> WithModuleSuffix { get; }
    [CompilationMappingAttribute("4", "5")]
internal bool IsModule { get; }
    internal static Parent Empty { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.Parent")]
internal Parent(FSharpOption`1<String[]> namespace, FSharpFunc`2<bool, FSharpOption`1<String[]>> thisRequiresQualifiedAccess, FSharpFunc`2<bool, FSharpOption`1<String[]>> topRequiresQualifiedAccess, FSharpOption`1<String[]> autoOpen, FSharpOption`1<String[]> withModuleSuffix, bool isModule);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<String[]> get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> get_ThisRequiresQualifiedAccess();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<bool, FSharpOption`1<String[]>> get_TopRequiresQualifiedAccess();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<String[]> get_AutoOpen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<String[]> get_WithModuleSuffix();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsModule();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal static Parent get_Empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] RewriteParentIdents(FSharpOption`1<String[]> parentIdents, String[] idents);
    internal String[] FixParentModuleSuffix(String[] idents);
    internal FSharpOption`1<Tuple`2<string, String[]>> FormatEntityFullName(FSharpEntity entity);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.ParsedInput : object {
    [CompilationMappingAttribute("9")]
internal static HashSet`1<string> emptyStringSet { get; }
    [CompilationMappingAttribute("9")]
internal static Regex insideAttributeApplicationRegex { get; }
    internal static FSharpList`1<SynExpr> collect@268-8(SynExpr expr, FSharpList`1<SynExpr> acc);
    internal static FSharpOption`1<FSharpList`1<SynExpr>> |Sequentials|_|(SynExpr expr);
    internal static HashSet`1<string> get_emptyStringSet();
    internal static Tuple`2<bool, Range> CheckLongIdent@281(Position pos, FSharpList`1<Ident> longIdent);
    public static FSharpOption`1<Range> GetRangeOfExprLeftOfDot(Position pos, ParsedInput parsedInput);
    internal static FSharpList`1<string> getLidParts@408(Position pos, FSharpList`1<Ident> lid);
    internal static FSharpOption`1<FSharpList`1<string>> TryGetExpression@417(Position pos, bool foundCandidate, SynExpr expr);
    public static FSharpOption`1<string> TryFindExpressionIslandInPosition(Position pos, ParsedInput parsedInput);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Position, bool>> traverseLidOrElse(Position pos, FSharpOption`1<SynExpr> optExprIfLeftOfLongId, SynLongIdent lidwd);
    internal static FSharpFunc`2<b, FSharpFunc`2<FSharpFunc`2<a, c>, Tuple`2<b, FSharpFunc`2<Unit, c>>>> dive@486-3(a x);
    internal static FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<Tuple`2<Range, FSharpFunc`2<Unit, FSharpOption`1<b>>>>, FSharpOption`1<b>>> pick@487-7(Position pos, Range x);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Position, bool>> VisitExpr$cont@510(Position pos, FSharpFunc`2<SynExpr, FSharpOption`1<Tuple`2<Position, bool>>> traverseSynExpr, SynExpr expr, FSharpFunc`2<SynExpr, FSharpOption`1<Tuple`2<Position, bool>>> defaultTraverse, FSharpFunc`2<SynExpr, FSharpFunc`2<FSharpList`1<Tuple`2<Range, FSharpFunc`2<Unit, FSharpOption`1<Tuple`2<Position, bool>>>>>, FSharpOption`1<Tuple`2<Position, bool>>>> pick, Unit unitVar);
    public static FSharpOption`1<Tuple`2<Position, bool>> TryFindExpressionASTLeftOfDotLeftOfCursor(Position pos, ParsedInput parsedInput);
    internal static FSharpList`1<SynPat> |ConstructorPats|@598(SynArgPats pats);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<EntityKind> f@605-24(FSharpFunc`2<FSharpOption`1<EntityKind>, FSharpFunc`2<SynExpr, FSharpOption`1<EntityKind>>> walkExprWithKind, FSharpOption`1<EntityKind> parentKind, FSharpList`1<SynExprRecordField> fields, Unit _arg10);
    public static FSharpOption`1<EntityKind> GetEntityKind(Position pos, ParsedInput parsedInput);
    internal static Regex get_insideAttributeApplicationRegex();
    internal static FSharpFunc`2<SynAttribute, FSharpOption`1<Unit>> |SynAttr|_|@1006(string name);
    internal static Tuple`3<bool, bool, bool> getKind@1013(bool isClass, bool isInterface, bool isStruct, FSharpList`1<SynAttribute> attrs);
    internal static FSharpChoice`5<Unit, Unit, Unit, Unit, Unit> |Class|Interface|Struct|Unknown|Invalid|(FSharpList`1<SynAttribute> synAttributes);
    internal static FSharpOption`1<CompletionContext> GetCompletionContextForInheritSynMember(SynComponentInfo compInfo, SynTypeDefnKind typeDefnKind, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> completionPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |Operator|_|(string name, SynExpr e);
    internal static bool isAtRangeOp(FSharpList`1<SyntaxNode> p);
    internal static FSharpOption`1<Ident> |Setter|_|(SynExpr e);
    internal static HashSet`1<string> findSetters(SynExpr argList);
    internal static Position endOfLastIdent(SynLongIdent lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Position endOfClosingTokenOrLastIdent(FSharpOption`1<Range> mClosing, SynLongIdent lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Position endOfClosingTokenOrIdent(FSharpOption`1<Range> mClosing, Ident id);
    internal static FSharpOption`1<Tuple`2<Position, HashSet`1<string>>> |NewObjectOrMethodCall|_|(SynExpr e);
    internal static bool loop@1141-98(Position pos, SynExpr current, FSharpList`1<SynExpr> elements, FSharpList`1<Range> commas);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOnTheRightOfComma(Position pos, FSharpList`1<SynExpr> elements, FSharpList`1<Range> commas, SynExpr current);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Position, HashSet`1<string>>> |PartOfParameterList|_|(Position pos, FSharpOption`1<SynExpr> precedingArgument, FSharpList`1<SyntaxNode> path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<string>, FSharpOption`1<string>>> parseLidAux(Position pos, FSharpList`1<string> plid, FSharpList`1<Ident> parts, FSharpList`1<Range> dots);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<string>, FSharpOption`1<string>>> parseLid(Position pos, SynLongIdent _arg1);
    internal static string cutLeadingAttributes@1210(string str);
    internal static bool isLongIdent@1217(string lid);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<CompletionContext> TryGetCompletionContextOfAttributes$cont@1245(Position pos, string lineStr, Unit unitVar);
    internal static FSharpOption`1<CompletionContext> TryGetCompletionContextOfAttributes(Position pos, string lineStr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<CompletionContext> TryGetCompletionContextInPattern(bool suppressIdentifierCompletions, SynPat pat, FSharpOption`1<PatternContext> previousContext, Position pos);
    internal static RecordContext contextFromTreePath@1447(FSharpList`1<SyntaxNode> path, FSharpOption`1<SynLongIdent> field, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> completionPath);
    internal static FSharpOption`1<CompletionContext> overrideContext@1506(FSharpList`1<SyntaxNode> path);
    public static FSharpOption`1<CompletionContext> TryGetCompletionContext(Position pos, ParsedInput parsedInput, string lineStr);
    public static String[] GetFullNameOfSmallestModuleOrNamespaceAtPoint(Position pos, ParsedInput parsedInput);
    internal static FSharpList`1<SynPat> |ConstructorPats|(SynArgPats pats);
    internal static void addLongIdent@1742-3(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, FSharpList`1<Ident> longIdent);
    internal static void addLongIdentWithDots@1746(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynLongIdent value);
    internal static void addIdent@1756-2(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, Ident ident);
    internal static void walkImplFileInput@1759-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, ParsedImplFileInput file);
    internal static void walkSynModuleOrNamespace@1762-3(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynModuleOrNamespace _arg1);
    internal static void walkAttribute@1766-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynAttribute attr);
    internal static void walkTyparDecl@1770-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynTyparDecl _arg2);
    internal static void walkTypeConstraint@1775-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynTypeConstraint cx);
    internal static void walkPat@1796(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynPat pat);
    internal static void walkTypar@1825-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynTypar _arg3);
    internal static void walkBinding@1827-2(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynBinding _arg4);
    internal static void walkInterfaceImpl@1835-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynInterfaceImpl _arg5);
    internal static void walkType@1837-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynType synType);
    internal static void walkClause@1868-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynMatchClause _arg6);
    internal static void walkSimplePats@1873(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynSimplePats spats);
    internal static void walkExpr@1877-10(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynExpr expr);
    internal static void walkMeasure@2028(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynMeasure measure);
    internal static void walkSimplePat@2044-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynSimplePat spat);
    internal static void walkField@2054-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynField _arg7);
    internal static void walkValSig@2058-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynValSig _arg8);
    internal static void walkMemberSig@2066-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynMemberSig membSig);
    internal static void walkMember@2087-2(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynMemberDefn memb);
    internal static void walkEnumCase@2113-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynEnumCase _arg9);
    internal static void walkUnionCaseType@2115-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynUnionCaseKind kind);
    internal static void walkUnionCase@2120-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynUnionCase _arg10);
    internal static void walkTypeDefnSimple@2124-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynTypeDefnSimpleRepr typeDefn);
    internal static void walkComponentInfo@2132-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, bool isTypeExtensionOrAlias, SynComponentInfo compInfo);
    internal static void walkTypeDefnRepr@2144-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynTypeDefnRepr inp);
    internal static void walkTypeDefnSigRepr@2150-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynTypeDefnSigRepr inp);
    internal static void walkTypeDefn@2156-1(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynTypeDefn typeDefn);
    internal static void walkSynModuleDecl@2172-2(Dictionary`2<Position, FSharpList`1<Ident>> identsByEndPos, SynModuleDecl decl);
    internal static IDictionary`2<Position, FSharpList`1<Ident>> getLongIdents(ParsedInput parsedInput);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<FSharpList`1<Ident>> GetLongIdentAt(ParsedInput parsedInput, Position pos);
    internal static void addModule@2215(List`1<FSharpModule> modules, FSharpList`1<Ident> longIdent, Range range);
    internal static void doRange@2222(int currentLine, OpenStatementInsertionPoint insertionPoint, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, Position, bool>>> result, ScopeKind kind, FSharpList`1<Ident> scope, int line, int col);
    internal static FSharpOption`1<int> getMinColumn@2256(FSharpList`1<SynModuleDecl> decls);
    internal static void walkImplFileInput@2271-2(int currentLine, OpenStatementInsertionPoint insertionPoint, List`1<FSharpModule> modules, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, Position, bool>>> result, FSharpRef`1<FSharpOption`1<String[]>> ns, ParsedImplFileInput file);
    internal static void walkSynModuleOrNamespace@2274-4(int currentLine, OpenStatementInsertionPoint insertionPoint, List`1<FSharpModule> modules, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, Position, bool>>> result, FSharpRef`1<FSharpOption`1<String[]>> ns, FSharpList`1<Ident> parent, SynModuleOrNamespace modul);
    internal static FSharpFunc`2<SynModuleDecl, Unit> walkSynModuleDecl@2303-3(int currentLine, OpenStatementInsertionPoint insertionPoint, List`1<FSharpModule> modules, FSharpRef`1<FSharpOption`1<Tuple`3<Scope, Position, bool>>> result, FSharpRef`1<FSharpOption`1<String[]>> ns, FSharpList`1<Ident> parent);
    [CompilerGeneratedAttribute]
internal static String[] clo0@2327-642(IEnumerable`1<string> ident);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Tuple`3<Scope, FSharpOption`1<String[]>, Position>>, FSharpList`1<FSharpModule>> tryFindNearestPointAndModules(int currentLine, ParsedInput ast, OpenStatementInsertionPoint insertionPoint);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static InsertionContext findBestPositionToInsertOpenDeclaration(FSharpList`1<FSharpModule> modules, Scope scope, Position pos, String[] entity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpFunc`2<Tuple`4<FSharpOption`1<String[]>, FSharpOption`1<String[]>, FSharpOption`1<String[]>, String[]>, Tuple`2[]> TryFindInsertionContext(int currentLine, ParsedInput parsedInput, MaybeUnresolvedIdent[] partiallyQualifiedName, OpenStatementInsertionPoint insertionPoint);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Position AdjustInsertionPoint(FSharpFunc`2<int, string> getLineStr, InsertionContext ctx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static InsertionContext FindNearestPointToInsertOpenDeclaration(int currentLine, ParsedInput parsedInput, String[] entity, OpenStatementInsertionPoint insertionPoint);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.PartialLongName : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<string> QualifyingIdents@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string PartialIdent@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int EndColumn@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<int> LastDotPos@;
    [CompilationMappingAttribute("4", "0")]
public FSharpList`1<string> QualifyingIdents { get; }
    [CompilationMappingAttribute("4", "1")]
public string PartialIdent { get; }
    [CompilationMappingAttribute("4", "2")]
public int EndColumn { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<int> LastDotPos { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.PartialLongName")]
public PartialLongName(FSharpList`1<string> qualifyingIdents, string partialIdent, int endColumn, FSharpOption`1<int> lastDotPos);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_QualifyingIdents();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_PartialIdent();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<int> get_LastDotPos();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PartialLongName obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static PartialLongName Empty(int endColumn);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PartialLongName obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.PatternContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PatternContext _unique_Other;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPositionalUnionCaseField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamedUnionCaseField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnionCaseFieldIdentifier { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecordFieldIdentifier { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static PatternContext Other { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOther { get; }
    private static PatternContext();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.PatternContext")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PatternContext(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static PatternContext NewPositionalUnionCaseField(FSharpOption`1<int> _fieldIndex, bool _isTheOnlyField, Range _caseIdRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPositionalUnionCaseField();
    [CompilationMappingAttribute("8", "1")]
public static PatternContext NewNamedUnionCaseField(string _fieldName, Range _caseIdRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamedUnionCaseField();
    [CompilationMappingAttribute("8", "2")]
public static PatternContext NewUnionCaseFieldIdentifier(FSharpList`1<string> _referencedFields, Range _caseIdRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnionCaseFieldIdentifier();
    [CompilationMappingAttribute("8", "3")]
public static PatternContext NewRecordFieldIdentifier(FSharpList`1<Tuple`2<string, Range>> _referencedFields);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecordFieldIdentifier();
    [CompilationMappingAttribute("8", "4")]
public static PatternContext get_Other();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOther();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PatternContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.QuickParse : object {
    public static int MagicalAdjustmentConstant { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<String[]> expected { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static int get_MagicalAdjustmentConstant();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static int CorrectIdentifierToken(string tokenText, int tokenTag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isValidStrippedName(ReadOnlySpan`1<char> name, int idx);
    internal static bool isValidActivePatternName(string name);
    internal static FSharpOption`1<char> |Char|_|@95(string lineStr, int p);
    internal static FSharpOption`1<Unit> |IsLongIdentifierPartChar|_|@101(char c);
    internal static FSharpOption`1<Unit> |IsIdentifierPartChar|_|@104(char c);
    internal static int searchLeft@107(string lineStr, int p);
    internal static int searchRight@114(string lineStr, int p);
    internal static FSharpOption`1<Tuple`2<int, int>> walkOutsideBackticks@122(string lineStr, int index, int i);
    internal static FSharpOption`1<Tuple`2<int, int>> walkInsideBackticks@138(string lineStr, int index, int i, int start);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<string, int, bool>> GetCompleteIdentifierIslandImplAux(string lineStr, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<string, int, bool>> GetCompleteIdentifierIslandImpl(string lineStr, int index);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Tuple`3<string, int, bool>> GetCompleteIdentifierIsland(bool tolerateJustAfter, string lineStr, int index);
    internal static Tuple`2<FSharpList`1<string>, a> PushName@231(string lineStr, int right, int pos, a residue, FSharpList`1<string> prior, Unit unitVar0);
    internal static Tuple`2<FSharpList`1<string>, a> InLeadingIdentifier@230(string lineStr, int pos, int right, Tuple`2<FSharpList`1<string>, a> tupledArg2);
    internal static Tuple`2<FSharpList`1<string>, string> NameAndResidue@244(string lineStr, int startResidue, int right, int pos, Unit unitVar0);
    internal static Tuple`2<FSharpList`1<string>, string> InName@243(string lineStr, int pos, int startResidue, int right);
    internal static Tuple`2<FSharpList`1<string>, string> InResidue@256(string lineStr, int pos, int right);
    internal static Tuple`2<FSharpList`1<string>, string> GetPartialLongNameAux(string lineStr, int index);
    public static Tuple`2<FSharpList`1<string>, string> GetPartialLongName(string lineStr, int index);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@274-61(EatCommentCallContext this, EatCommentCallContext obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@274-62(IComparer comp, EatCommentCallContext this, EatCommentCallContext objTemp, Unit unitVar);
    internal static bool IsEndOfComment@291(string lineStr, int index, int pos);
    internal static bool IsStartOfComment@294(string lineStr, int index, int pos);
    internal static PartialLongName SkipWhitespaceBeforeDotIdentifier@299(string lineStr, int index, int pos, string ident, FSharpList`1<string> current, bool throwAwayNext, FSharpOption`1<int> lastDotPos);
    internal static PartialLongName EatComment@311(string lineStr, int index, int nesting, int pos, EatCommentCallContext callContext, FSharpOption`1<int> lastDotPos);
    internal static PartialLongName InUnquotedIdentifier@332(string lineStr, int index, int left, int pos, FSharpList`1<string> current, bool throwAwayNext, FSharpOption`1<int> lastDotPos);
    internal static PartialLongName InQuotedIdentifier@354(string lineStr, int index, int left, int pos, FSharpList`1<string> current, bool throwAwayNext, FSharpOption`1<int> lastDotPos);
    internal static PartialLongName AtStartOfIdentifier@374(string lineStr, int index, int pos, FSharpList`1<string> current, bool throwAwayNext, FSharpOption`1<int> lastDotPos);
    internal static PartialLongName GetPartialLongNameExAux(string lineStr, int index);
    public static PartialLongName GetPartialLongNameEx(string lineStr, int index);
    internal static FSharpList`1<String[]> get_expected();
    public static bool TestMemberOrOverrideDeclaration(FSharpTokenInfo[] tokens);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.RecordContext : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static RecordContext _unique_Empty;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCopyOnUpdate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static RecordContext Empty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNew { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDeclaration { get; }
    private static RecordContext();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.RecordContext")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal RecordContext(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static RecordContext NewCopyOnUpdate(Range _range, Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> _path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCopyOnUpdate();
    [CompilationMappingAttribute("8", "1")]
public static RecordContext NewConstructor(string _typeName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstructor();
    [CompilationMappingAttribute("8", "2")]
public static RecordContext get_Empty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEmpty();
    [CompilationMappingAttribute("8", "3")]
public static RecordContext NewNew(Tuple`2<FSharpList`1<string>, FSharpOption`1<string>> _path, bool _isFirstField);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNew();
    [CompilationMappingAttribute("8", "4")]
public static RecordContext NewDeclaration(bool _isInIdentifier);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDeclaration();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RecordContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.ScopeKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_TopModule;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_NestedModule;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_OpenDeclaration;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ScopeKind _unique_HashDirective;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind TopModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTopModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind NestedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNestedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind OpenDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpenDeclaration { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ScopeKind HashDirective { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashDirective { get; }
    private static ScopeKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.EditorServices.ScopeKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ScopeKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static ScopeKind get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "1")]
public static ScopeKind get_TopModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTopModule();
    [CompilationMappingAttribute("8", "2")]
public static ScopeKind get_NestedModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNestedModule();
    [CompilationMappingAttribute("8", "3")]
public static ScopeKind get_OpenDeclaration();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpenDeclaration();
    [CompilationMappingAttribute("8", "4")]
public static ScopeKind get_HashDirective();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashDirective();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ScopeKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ScopeKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[StructAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.SemanticClassificationItem : ValueType {
    internal Range Range@;
    internal SemanticClassificationType Type@;
    [CompilationMappingAttribute("4", "0")]
public Range Range { get; }
    [CompilationMappingAttribute("4", "1")]
public SemanticClassificationType Type { get; }
    public SemanticClassificationItem(Tuple`2<Range, SemanticClassificationType> _arg1);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_Range();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SemanticClassificationType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SemanticClassificationItem obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.EditorServices.SemanticClassificationKeyStore : object {
    internal MemoryMappedFile mmf;
    internal long length;
    internal bool isDisposed;
    public SemanticClassificationKeyStore(MemoryMappedFile mmf, long length);
    internal SemanticClassificationView GetView();
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
internal void checkDispose();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.EditorServices.SemanticClassificationKeyStoreBuilder : object {
    internal BlobBuilder b;
    internal void WriteAll(SemanticClassificationItem[] semanticClassification);
    internal FSharpOption`1<SemanticClassificationKeyStore> TryBuildAndReset();
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.EditorServices.SemanticClassificationType : Enum {
    public int value__;
    public static SemanticClassificationType ReferenceType;
    public static SemanticClassificationType ValueType;
    public static SemanticClassificationType UnionCase;
    public static SemanticClassificationType UnionCaseField;
    public static SemanticClassificationType Function;
    public static SemanticClassificationType Property;
    public static SemanticClassificationType MutableVar;
    public static SemanticClassificationType Module;
    public static SemanticClassificationType Namespace;
    public static SemanticClassificationType Printf;
    public static SemanticClassificationType ComputationExpression;
    public static SemanticClassificationType IntrinsicFunction;
    public static SemanticClassificationType Enumeration;
    public static SemanticClassificationType Interface;
    public static SemanticClassificationType TypeArgument;
    public static SemanticClassificationType Operator;
    public static SemanticClassificationType DisposableType;
    public static SemanticClassificationType DisposableTopLevelValue;
    public static SemanticClassificationType DisposableLocalValue;
    public static SemanticClassificationType Method;
    public static SemanticClassificationType ExtensionMethod;
    public static SemanticClassificationType ConstructorForReferenceType;
    public static SemanticClassificationType ConstructorForValueType;
    public static SemanticClassificationType Literal;
    public static SemanticClassificationType RecordField;
    public static SemanticClassificationType MutableRecordField;
    public static SemanticClassificationType RecordFieldAsFunction;
    public static SemanticClassificationType Exception;
    public static SemanticClassificationType Field;
    public static SemanticClassificationType Event;
    public static SemanticClassificationType Delegate;
    public static SemanticClassificationType NamedArgument;
    public static SemanticClassificationType Value;
    public static SemanticClassificationType LocalValue;
    public static SemanticClassificationType Type;
    public static SemanticClassificationType TypeDef;
    public static SemanticClassificationType Plaintext;
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.EditorServices.SemanticClassificationView : object {
    internal MemoryMappedFile mmf;
    internal long length;
    internal Byte[] buffer;
    internal SemanticClassificationView(MemoryMappedFile mmf, long length);
    internal SemanticClassificationItem ReadItem(BlobReader& reader);
    public void ForEach(FSharpFunc`2<SemanticClassificationItem, Unit> f);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.SimplifyNames : object {
    internal static int getPlidLength(FSharpList`1<string> plid);
    internal static int projection@1(FSharpSymbolUse symbolUse, FSharpList`1<string> tupledArg1, int tupledArg2, string tupledArg3);
    internal static FSharpList`1<string> loop@351-103(FSharpCheckFileResults checkFileResults, FSharpSymbolUse symbolUse, Position posAtStartOfName, FSharpList`1<string> rest, FSharpList`1<string> current);
    internal static FSharpList`1<string> getNecessaryPlid@350(FSharpCheckFileResults checkFileResults, FSharpSymbolUse symbolUse, Position posAtStartOfName, FSharpList`1<string> plid);
    public static FSharpAsync`1<IEnumerable`1<SimplifiableRange>> getSimplifiableNames(FSharpCheckFileResults checkFileResults, FSharpFunc`2<int, string> getSourceLineStr);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.SourceFileImpl : object {
    internal static bool IsSignatureFile(string file);
    internal static FSharpList`1<string> GetImplicitConditionalDefinesForEditing(bool isInteractive);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.Structure : object {
    internal static Range longIdentRange(FSharpList`1<Ident> longId);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range rangeOfTypeArgsElse(Range other, FSharpList`1<SynTyparDecl> typeArgs);
    [CompilerGeneratedAttribute]
internal static void parseExpr$cont@357(List`1<ScopeRange> acc, SynExpr expr, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void parseExpr$cont@373-1(List`1<ScopeRange> acc, Range mWhole, Range withRange, Range tryRange, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void parseExpr$cont@410-2(List`1<ScopeRange> acc, SynExprIfThenElseTrivia trivia, SynExpr thenExpr, DebugPointAtBinding spIfToThen, Range r, SynExpr ifExpr, Unit unitVar);
    internal static void parseExpr@227(List`1<ScopeRange> acc, SynExpr expr);
    internal static SynPat getLastPat@478(SynPat x);
    internal static void parseMatchClause@477(List`1<ScopeRange> acc, SynMatchClause clause);
    internal static void attrListRange@502(List`1<ScopeRange> acc, FSharpList`1<SynAttribute> attrs, Unit unitVar0);
    internal static void parseAttributes@501(List`1<ScopeRange> acc, FSharpList`1<SynAttributeList> _arg1);
    [CompilerGeneratedAttribute]
internal static void parseBinding$cont@529(List`1<ScopeRange> acc, SynBinding binding, FSharpOption`1<SynMemberFlags> memberFlags, Unit unitVar);
    internal static void parseBinding@523(List`1<ScopeRange> acc, SynBinding binding);
    internal static void parseBindings@545(List`1<ScopeRange> acc, FSharpList`1<SynBinding> sqs);
    internal static void parseExprInterface@549(List`1<ScopeRange> acc, SynInterfaceImpl intf);
    internal static void parseExprInterfaces@555(List`1<ScopeRange> acc, FSharpList`1<SynInterfaceImpl> intfs);
    internal static FSharpFunc`2<SynMemberDefn, Unit> parseSynMemberDefn@559(List`1<ScopeRange> acc, Range objectModelRange);
    internal static void parseSimpleRepr@628(List`1<ScopeRange> acc, SynTypeDefnSimpleRepr simple);
    internal static void parseTypeDefn@651(List`1<ScopeRange> acc, SynTypeDefn typeDefn);
    internal static FSharpList`1<FSharpList`1<Range>> loop@676-99(String[] sourceLines, FSharpList`1<Range> input, FSharpList`1<FSharpList`1<Range>> res, FSharpList`1<Range> currentBulk);
    internal static FSharpList`1<FSharpList`1<Range>> groupConsecutiveDecls@675(String[] sourceLines, FSharpList`1<Range> input);
    internal static FSharpFunc`2<FSharpList`1<SynModuleDecl>, Unit> getConsecutiveModuleDecls@674(String[] sourceLines, List`1<ScopeRange> acc, Scope scope, FSharpFunc`2<SynModuleDecl, FSharpOption`1<Range>> predicate);
    internal static void group@741(List`1<ScopeRange> acc, FSharpList`1<ConditionalDirectiveTrivia> directives, FSharpList`1<ConditionalDirectiveTrivia> stack, String[] sourceLines);
    internal static void collectConditionalDirectives@740(List`1<ScopeRange> acc, FSharpList`1<ConditionalDirectiveTrivia> directives, String[] sourceLines);
    internal static void parseDeclaration@798(List`1<ScopeRange> acc, FSharpFunc`2<FSharpList`1<SynModuleDecl>, Unit> collectOpens, SynModuleDecl decl);
    internal static void parseModuleOrNamespace@828(List`1<ScopeRange> acc, FSharpFunc`2<FSharpList`1<SynModuleDecl>, Unit> collectOpens, FSharpFunc`2<FSharpList`1<SynModuleDecl>, Unit> collectHashDirectives, SynModuleOrNamespace _arg4);
    internal static FSharpOption`1<CommentType> |Comment|_|@843(string line);
    internal static Tuple`3<int, FSharpOption`1<CommentList>, FSharpList`1<CommentList>> loop@849-101(Tuple`3<int, FSharpOption`1<CommentList>, FSharpList`1<CommentList>> state, FSharpList`1<string> lines, int lineNum);
    internal static FSharpFunc`2<String[], Unit> getCommentRanges@848(List`1<ScopeRange> acc, IEnumerable`1<CommentTrivia> trivia);
    internal static Range lastMemberSigRangeElse@927(Range r, FSharpList`1<SynMemberSig> memberSigs);
    internal static Range lastTypeDefnSigRangeElse@938(Range range, FSharpList`1<SynTypeDefnSig> typeSigs);
    internal static Range lastModuleSigDeclRangeElse@945(Range range, FSharpList`1<SynModuleSigDecl> sigDecls);
    internal static void parseSynMemberDefnSig@957(List`1<ScopeRange> acc, SynMemberSig inp);
    internal static Tuple`2<Range, Range> makeRanges@978(Range r, FSharpList`1<Ident> longId, FSharpList`1<SynTyparDecl> typeArgs, FSharpList`1<SynMemberSig> memberSigs);
    internal static void parseTypeDefnSig@970(List`1<ScopeRange> acc, SynTypeDefnSig typeDefn);
    internal static FSharpList`1<FSharpList`1<Range>> loop@1014-102(FSharpList`1<Range> input, FSharpList`1<FSharpList`1<Range>> res, FSharpList`1<Range> currentBulk);
    internal static FSharpList`1<FSharpList`1<Range>> groupConsecutiveSigDecls@1013(FSharpList`1<Range> input);
    internal static FSharpFunc`2<FSharpList`1<SynModuleSigDecl>, Unit> getConsecutiveSigModuleDecls@1012(List`1<ScopeRange> acc, Scope scope, FSharpFunc`2<SynModuleSigDecl, FSharpOption`1<Range>> predicate);
    internal static void collectSigHashDirectives@1060(List`1<ScopeRange> acc, FSharpList`1<SynModuleSigDecl> decls);
    internal static void parseModuleSigDeclaration@1074(List`1<ScopeRange> acc, FSharpFunc`2<FSharpList`1<SynModuleSigDecl>, Unit> collectSigOpens, SynModuleSigDecl decl);
    internal static void parseModuleOrNamespaceSigs@1098(List`1<ScopeRange> acc, FSharpFunc`2<FSharpList`1<SynModuleSigDecl>, Unit> collectSigOpens, SynModuleOrNamespaceSig moduleSig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<ScopeRange> getOutliningRanges(String[] sourceLines, ParsedInput parsedInput);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.SynExprAppLocationsImpl : object {
    internal static FSharpList`1<Range> loop@445-94(FSharpList`1<SynExpr> exprs, FSharpList`1<Range> ranges);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<FSharpList`1<Range>>, FSharpOption`1<FSharpOption`1<a>>> searchSynArgExpr(FSharpFunc`2<SynExpr, FSharpOption`1<a>> traverseSynExpr, SynExpr expr, FSharpList`1<Range> ranges);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<Range>> getAllCurriedArgsAtPosition(Position pos, ParsedInput parseTree);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.TcResolutionsExtensions : object {
    internal static Tuple`6<Item, ItemOccurence, DisplayEnv, NameResolutionEnv, AccessorDomain, Range> |CNR|(CapturedNameResolution cnr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDisposableTy(TcGlobals g, ImportMap amap, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isValRefDisposable(TcGlobals g, ImportMap amap, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructTyconRef(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isValRefMutable(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdFieldMutable(TcGlobals g, RecdFieldInfo rfinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SemanticClassificationType reprToClassificationType(TcGlobals g, TyconRepresentation repr, EntityRef tcref);
    internal static FSharpOption`1<Unit> |LegitTypeOccurence|_|@148(ItemOccurence occ);
    internal static FSharpOption`1<Unit> |KeywordIntrinsicValue|_|@158(TcGlobals g, ValRef vref);
    internal static FSharpOption`1<Unit> |EnumCaseFieldInfo|_|@171(RecdFieldInfo rfinfo);
    internal static CapturedNameResolution[] takeCustomBuilder@181(CapturedNameResolution[] cnrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SemanticClassificationItem[] TcResolutions.GetSemanticClassification(TcResolutions sResolutions, TcGlobals g, ImportMap amap, Tuple`2[] formatSpecifierLocations, FSharpOption`1<Range> range);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.EditorServices.ToolTipElement : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ToolTipElement _unique_None;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ToolTipElement None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGroup { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCompositionError { get; }
    private static ToolTipElement();
    [CompilationMappingAttribute("8", "0")]
public static ToolTipElement get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilationMappingAttribute("8", "1")]
public static ToolTipElement NewGroup(FSharpList`1<ToolTipElementData> _elements);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGroup();
    [CompilationMappingAttribute("8", "2")]
public static ToolTipElement NewCompositionError(string _errorText);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCompositionError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public static ToolTipElement Single(TaggedText[] layout, FSharpXmlDoc xml, FSharpOption`1<FSharpList`1<TaggedText[]>> typeMapping, FSharpOption`1<string> paramName, FSharpOption`1<TaggedText[]> remarks, FSharpOption`1<FSharpSymbol> symbol);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ToolTipElement obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.ToolTipElementData : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpSymbol> Symbol@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TaggedText[] MainDescription@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpXmlDoc XmlDoc@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<TaggedText[]> TypeMapping@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<TaggedText[]> Remarks@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<string> ParamName@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<FSharpSymbol> Symbol { get; }
    [CompilationMappingAttribute("4", "1")]
public TaggedText[] MainDescription { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpXmlDoc XmlDoc { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpList`1<TaggedText[]> TypeMapping { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpOption`1<TaggedText[]> Remarks { get; }
    [CompilationMappingAttribute("4", "5")]
public FSharpOption`1<string> ParamName { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.ToolTipElementData")]
public ToolTipElementData(FSharpOption`1<FSharpSymbol> symbol, TaggedText[] mainDescription, FSharpXmlDoc xmlDoc, FSharpList`1<TaggedText[]> typeMapping, FSharpOption`1<TaggedText[]> remarks, FSharpOption`1<string> paramName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<FSharpSymbol> get_Symbol();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TaggedText[] get_MainDescription();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpXmlDoc get_XmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<TaggedText[]> get_TypeMapping();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<TaggedText[]> get_Remarks();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<string> get_ParamName();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal static ToolTipElementData Create(TaggedText[] layout, FSharpXmlDoc xml, FSharpOption`1<FSharpList`1<TaggedText[]>> typeMapping, FSharpOption`1<string> paramName, FSharpOption`1<TaggedText[]> remarks, FSharpOption`1<FSharpSymbol> symbol);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ToolTipElementData obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.ToolTipText : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ToolTipElement> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ToolTipElement> Item { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.ToolTipText")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ToolTipText(FSharpList`1<ToolTipElement> item);
    [CompilationMappingAttribute("8", "0")]
public static ToolTipText NewToolTipText(FSharpList`1<ToolTipElement> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ToolTipElement> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ToolTipText obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.TupledArgumentLocation : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNamedArgument@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range ArgumentRange@;
    [CompilationMappingAttribute("4", "0")]
public bool IsNamedArgument { get; }
    [CompilationMappingAttribute("4", "1")]
public Range ArgumentRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.TupledArgumentLocation")]
public TupledArgumentLocation(bool isNamedArgument, Range argumentRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamedArgument();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_ArgumentRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TupledArgumentLocation obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.EditorServices.UnresolvedSymbol : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FullName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string DisplayName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal String[] Namespace@;
    [CompilationMappingAttribute("4", "0")]
public string FullName { get; }
    [CompilationMappingAttribute("4", "1")]
public string DisplayName { get; }
    [CompilationMappingAttribute("4", "2")]
public String[] Namespace { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.UnresolvedSymbol")]
public UnresolvedSymbol(string fullName, string displayName, String[] namespace);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public String[] get_Namespace();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(UnresolvedSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnresolvedSymbol obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.UnusedDeclarations : object {
    internal static bool isPotentiallyUnusedDeclaration(FSharpSymbol symbol);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Range> getUnusedDeclarationRanges(IEnumerable`1<FSharpSymbolUse> symbolsUses, bool isScript);
    public static FSharpAsync`1<IEnumerable`1<Range>> getUnusedDeclarations(FSharpCheckFileResults checkFileResults, bool isScriptFile);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.UnusedOpens : object {
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<FSharpSymbol> symbolHash { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpSymbol, FSharpFunc`2<FSharpSymbol, bool>> equality@1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`3<FSharpSymbol, FSharpSymbol, bool> eq@1 { get; }
    [CompilationMappingAttribute("9")]
internal static IEqualityComparer`1<FSharpEntity> entityHash { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpEntity, FSharpFunc`2<FSharpEntity, bool>> equality@1-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`3<FSharpEntity, FSharpEntity, bool> eq@1-1 { get; }
    internal static IEqualityComparer`1<FSharpSymbol> get_symbolHash();
    internal static FSharpFunc`2<FSharpSymbol, FSharpFunc`2<FSharpSymbol, bool>> get_equality@1();
    internal static FSharpFunc`3<FSharpSymbol, FSharpSymbol, bool> get_eq@1();
    internal static OpenedModule[] getModuleAndItsAutoOpens@67(bool isNestedAutoOpen, FSharpEntity modul);
    internal static OpenStatement[] getOpenStatements(FSharpOpenDeclaration[] openDeclarations);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpSymbolUse[] filterSymbolUses(FSharpFunc`2<int, string> getSourceLineStr, IEnumerable`1<FSharpSymbolUse> symbolUses);
    internal static Tuple`2<FSharpSymbolUse[], FSharpSymbolUse[]> splitSymbolUses(FSharpSymbolUse[] symbolUses);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOpenStatementUsed(FSharpSymbolUse[] symbolUses2, Dictionary`2<FSharpEntity, FSharpList`1<Range>> symbolUsesRangesByDeclaringEntity, Dictionary`2<FSharpEntity, FSharpList`1<Range>> usedModules, OpenStatement openStatement);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpList`1<OpenStatement>> filterOpenStatementsIncremental(FSharpSymbolUse[] symbolUses2, Dictionary`2<FSharpEntity, FSharpList`1<Range>> symbolUsesRangesByDeclaringEntity, FSharpList`1<OpenStatement> openStatements, Dictionary`2<FSharpEntity, FSharpList`1<Range>> usedModules, FSharpList`1<OpenStatement> acc);
    internal static IEqualityComparer`1<FSharpEntity> get_entityHash();
    internal static FSharpFunc`2<FSharpEntity, FSharpFunc`2<FSharpEntity, bool>> get_equality@1-1();
    internal static FSharpFunc`3<FSharpEntity, FSharpEntity, bool> get_eq@1-1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<FSharpList`1<Range>> filterOpenStatements(FSharpSymbolUse[] symbolUses1, FSharpSymbolUse[] symbolUses2, OpenStatement[] openStatements);
    public static FSharpAsync`1<FSharpList`1<Range>> getUnusedOpens(FSharpCheckFileResults checkFileResults, FSharpFunc`2<int, string> getSourceLineStr);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.EditorServices.XmlDocable : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _line;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _indent;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<string> _paramNames;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int line { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int indent { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> paramNames { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.EditorServices.XmlDocable")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal XmlDocable(int _line, int _indent, FSharpList`1<string> _paramNames);
    [CompilationMappingAttribute("8", "0")]
public static XmlDocable NewXmlDocable(int _line, int _indent, FSharpList`1<string> _paramNames);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_line();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_indent();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<string> get_paramNames();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(XmlDocable obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(XmlDocable obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.XmlDocComment : object {
    public static FSharpOption`1<int> IsBlank(string s);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.EditorServices.XmlDocParser : object {
    public static FSharpList`1<XmlDocable> GetXmlDocables(ISourceText sourceText, ParsedInput input);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.EditorServices.XmlDocParsing : object {
    internal static FSharpList`1<SynPat> |ConstructorPats|(SynArgPats _arg1);
    internal static FSharpList`1<string> digNamesFrom(SynPat pat);
    internal static FSharpList`1<string> getParamNames(SynBinding binding);
    internal static int indentOf@67(ISourceText sourceText, int lineNum);
    internal static FSharpList`1<XmlDocable> getXmlDocablesSynModuleDecl@79(ISourceText sourceText, SynModuleDecl decl);
    internal static FSharpList`1<XmlDocable> getXmlDocablesSynModuleOrNamespace@117(ISourceText sourceText, SynModuleOrNamespace inp);
    internal static FSharpList`1<XmlDocable> getXmlDocablesSynTypeDefn@121(ISourceText sourceText, SynTypeDefn typeDefn);
    internal static FSharpList`1<XmlDocable> getXmlDocablesSynMemberDefn@148(ISourceText sourceText, SynMemberDefn inp);
    internal static FSharpList`1<XmlDocable> getXmlDocablesInput@211(ISourceText sourceText, ParsedInput input);
    internal static FSharpList`1<XmlDocable> getXmlDocablesImpl(ISourceText sourceText, ParsedInput input);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Features : object {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.FindUnsolved : object {
    [CompilationMappingAttribute("9")]
internal static int FindUnsolvedStackGuardDepth { get; }
    internal static int get_FindUnsolvedStackGuardDepth();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTy(cenv cenv, a _env, Range mFallback, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTypeInst(cenv cenv, a env, Range mFallback, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accExpr(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accMethods(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, FSharpList`1<ObjExprMethod> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accMethod(cenv cenv, env env, FSharpOption`1<Val> _baseValOpt, ObjExprMethod _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accIntfImpls(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, Range mFallback, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accIntfImpl(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, Range mFallback, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accOp(cenv cenv, env env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTraitInfo(cenv cenv, env env, Range mFallback, TraitConstraintInfo _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accLambdas(cenv cenv, env env, ValReprInfo valReprInfo, Expr expr, TType exprTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accExprs(cenv cenv, env env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTargets(cenv cenv, env env, Range m, TType ty, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTarget(cenv cenv, env env, Range _m, TType _ty, DecisionTreeTarget _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accDTree(cenv cenv, env env, DecisionTree dtree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accSwitch(cenv cenv, env env, Expr e, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accDiscrim(cenv cenv, env env, DecisionTreeTest d, Range mFallback);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accAttrib(cenv cenv, env env, Attrib _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accAttribs(cenv cenv, env env, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accValReprInfo(cenv cenv, env env, ValReprInfo _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accArgReprInfo(cenv cenv, env env, ArgReprInfo argInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accVal(cenv cenv, env env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accBind(cenv cenv, env env, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accBinds(cenv cenv, env env, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTycon(cenv cenv, env env, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accTycons(cenv cenv, env env, FSharpList`1<Entity> tycons);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accModuleOrNamespaceDefs(cenv cenv, env env, FSharpList`1<ModuleOrNamespaceContents> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accModuleOrNamespaceDef(cenv cenv, env env, ModuleOrNamespaceContents def);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accModuleOrNamespaceBinds(cenv cenv, env env, FSharpList`1<ModuleOrNamespaceBinding> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void accModuleOrNamespaceBind(cenv cenv, env env, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> UnsolvedTyparsOfModuleDef(TcGlobals g, ImportMap amap, DisplayEnv denv, ModuleOrNamespaceContents mdef, FSharpList`1<Attrib> extraAttribs);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.FxResolver : object {
    internal bool useSdkRefs;
    internal Range rangeForErrors;
    internal string projectDir;
    internal bool isInteractive;
    internal bool assumeDotNetFramework;
    internal Lock`1<FxResolverLockToken> fxlock;
    internal static ConcurrentDictionary`2<string, FSharpResult`2<string, Exception>> desiredDotNetSdkVersionForDirectoryCache;
    internal Lazy`1<Tuple`2<FSharpOption`1<string>, FSharpList`1<Exception>>> trySdkDir;
    internal Lazy`1<Tuple`2<string, FSharpList`1<Exception>>> implementationAssemblyDir;
    internal string getFSharpCoreLibraryName;
    internal string getFsiLibraryName;
    internal Lazy`1<Tuple`2<Tuple`2<FSharpOption`1<string>, FSharpOption`1<string>>, FSharpList`1<Exception>>> tryNetCoreRefsPackDirectoryRoot;
    internal Lazy`1<Tuple`2<FSharpOption`1<string>, FSharpList`1<Exception>>> trySdkRefsPackDirectory;
    internal static HashSet`1<string> systemAssemblies;
    internal static int init@33;
    public FxResolver(bool assumeDotNetFramework, string projectDir, bool useSdkRefs, bool isInteractive, Range rangeForErrors, FSharpOption`1<string> sdkDirOverride);
    private static FxResolver();
    internal static HashSet`1<string> GetSystemAssemblies();
    internal static bool IsReferenceAssemblyPackDirectoryApprox(string dirName);
    internal FSharpOption`1<string> TryGetSdkDir();
    internal Tuple`2<string, string> GetTfmAndRid();
    internal static void ClearStaticCaches();
    internal FSharpOption`1<string> GetFrameworkRefsPackDirectory();
    internal FSharpResult`2<string, Exception> TryGetDesiredDotNetSdkVersionForDirectory();
    internal Tuple`2<FSharpList`1<string>, bool> GetDefaultReferences(bool useFsiAuxLib);
    [CompilerGeneratedAttribute]
internal static void RequireFxResolverLock(FxResolverLockToken _fxtok, T _thingProtected);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`3<int, String[], String[]> executeProcess(string pathToExe, string arguments, FSharpOption`1<string> workingDir, int timeout);
    [CompilerGeneratedAttribute]
internal FSharpResult`2<string, Exception> tryGetDesiredDotNetSdkVersionForDirectoryInfo();
    [CompilerGeneratedAttribute]
internal Tuple`2<FSharpOption`1<string>, FSharpList`1<Exception>> tryGetDesiredDotNetSdkVersionForDirectory();
    [CompilerGeneratedAttribute]
internal a replayWarnings(a res, FSharpList`1<Exception> warnings);
    [CompilerGeneratedAttribute]
internal Tuple`2<FSharpOption`1<string>, FSharpList`1<Exception>> tryGetSdkDir();
    [CompilerGeneratedAttribute]
internal string getRunningImplementationAssemblyDir();
    [CompilerGeneratedAttribute]
internal Tuple`2<string, FSharpList`1<Exception>> getImplementationAssemblyDir();
    [CompilerGeneratedAttribute]
internal string getFSharpCoreImplementationReference();
    [CompilerGeneratedAttribute]
internal string getFsiLibraryImplementationReference();
    [CompilerGeneratedAttribute]
internal FSharpOption`1<string> getSystemValueTupleImplementationReference();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal FSharpOption`1<DirectoryInfo> tryGetVersionedSubDirectory(string path, string version);
    [CompilerGeneratedAttribute]
internal Tuple`2<Tuple`2<FSharpOption`1<string>, FSharpOption`1<string>>, FSharpList`1<Exception>> tryGetNetCoreRefsPackDirectoryRoot();
    [CompilerGeneratedAttribute]
internal string getTfmNumber(string v);
    [CompilerGeneratedAttribute]
internal string tryGetRunningTfm();
    [CompilerGeneratedAttribute]
internal Tuple`2<FSharpOption`1<string>, FSharpList`1<Exception>> tryGetSdkRefsPackDirectory();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> getDependenciesOf(FSharpList`1<string> assemblyReferences);
    [CompilerGeneratedAttribute]
internal string tryGetTfmFromSdkDir(string sdkDir);
    [CompilerGeneratedAttribute]
internal FSharpList`1<string> getDotNetFrameworkDefaultReferences(bool useFsiAuxLib);
    [CompilerGeneratedAttribute]
internal FSharpList`1<string> getDotNetCoreImplementationReferences(bool useFsiAuxLib);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.FxResolverLockToken : object {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.GraphChecking.DependencyResolution : object {
    internal static FSharpOption`1<TrieNode> visit@8-80(TrieNode currentNode, FSharpList`1<string> path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TrieNode> queryTriePartial(TrieNode trie, FSharpList`1<string> path);
    internal static QueryTrieNodeResult mapNodeToQueryResult(FSharpOption`1<TrieNode> node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueryTrieNodeResult queryTrie(TrieNode trie, FSharpList`1<string> path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueryTrieNodeResult queryTrieDual(TrieNode trie, FSharpList`1<string> path1, FSharpList`1<string> path2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FileContentQueryState processNamespaceDeclaration(TrieNode trie, FSharpList`1<string> path, FileContentQueryState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FileContentQueryState processOpenPath(TrieNode trie, FSharpList`1<string> path, FileContentQueryState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FileContentQueryState processIdentifier(QueryTrieNodeResult queryResult, FileContentQueryState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FileContentQueryState processStateEntry(TrieNode trie, FileContentQueryState state, FileContentEntry entry);
    internal static TrieNode find@146-2(TrieNode node, FSharpList`1<string> path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Int32[] collectGhostDependencies(int fileIndex, TrieNode trie, FileContentQueryState result);
    internal static Int32[] findDependencies@192(FilePairMap filePairs, TrieNode trie, FSharpList`1[] fileContents, FileInProject file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<IReadOnlyDictionary`2<int, Int32[]>, TrieNode> mkGraph(FilePairMap filePairs, FileInProject[] files);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.GraphChecking.FileContent : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FileName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Idx@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FileContentEntry[] Content@;
    [CompilationMappingAttribute("4", "0")]
internal string FileName { get; }
    [CompilationMappingAttribute("4", "1")]
internal int Idx { get; }
    [CompilationMappingAttribute("4", "2")]
internal FileContentEntry[] Content { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.GraphChecking.FileContent")]
internal FileContent(string fileName, int idx, FileContentEntry[] content);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Idx();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FileContentEntry[] get_Content();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FileContent obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FileContent obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.GraphChecking.FileContentEntry : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTopLevelNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOpenStatement { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPrefixedIdentifier { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNestedModule { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.GraphChecking.FileContentEntry")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FileContentEntry(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static FileContentEntry NewTopLevelNamespace(FSharpList`1<string> _path, FSharpList`1<FileContentEntry> _content);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTopLevelNamespace();
    [CompilationMappingAttribute("8", "1")]
internal static FileContentEntry NewOpenStatement(FSharpList`1<string> _path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsOpenStatement();
    [CompilationMappingAttribute("8", "2")]
internal static FileContentEntry NewPrefixedIdentifier(FSharpList`1<string> _path);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPrefixedIdentifier();
    [CompilationMappingAttribute("8", "3")]
internal static FileContentEntry NewNestedModule(string _name, FSharpList`1<FileContentEntry> _nestedContent);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNestedModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FileContentEntry obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FileContentEntry obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.GraphChecking.FileContentMapping : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<U> collectFromOption(FSharpFunc`2<T, FSharpList`1<U>> mapping, FSharpOption`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> longIdentToPath(bool skipLast, FSharpList`1<Ident> longId);
    internal static FSharpList`1<FileContentEntry> visitLongIdent(FSharpList`1<Ident> lid);
    internal static FSharpList`1<FileContentEntry> visitLongIdentForModuleAbbrev(FSharpList`1<Ident> lid);
    internal static FSharpList`1<FileContentEntry> visitSynAttribute(SynAttribute a);
    internal static FSharpList`1<FileContentEntry> visitSynAttributeList(SynAttributeList attributes);
    internal static FSharpList`1<FileContentEntry> visitSynModuleDecl(SynModuleDecl decl);
    internal static FSharpList`1<FileContentEntry> visitSynModuleSigDecl(SynModuleSigDecl md);
    internal static FSharpList`1<FileContentEntry> visitSynUnionCase(SynUnionCase _arg1);
    internal static FSharpList`1<FileContentEntry> visitSynEnumCase(SynEnumCase _arg2);
    internal static FSharpList`1<FileContentEntry> visitSynTypeDefn(SynTypeDefn _arg3);
    internal static FSharpList`1<FileContentEntry> visitSynTypeDefnSig(SynTypeDefnSig _arg4);
    internal static FSharpList`1<FileContentEntry> visitSynValSig(SynValSig _arg5);
    internal static FSharpList`1<FileContentEntry> visitSynField(SynField _arg6);
    internal static FSharpList`1<FileContentEntry> visitSynMemberDefn(SynMemberDefn md);
    internal static FSharpList`1<FileContentEntry> visitSynInterfaceImpl(SynInterfaceImpl _arg7);
    internal static FSharpList`1<FileContentEntry> visit@232-5(SynType t, FSharpFunc`2<FSharpList`1<FileContentEntry>, FSharpList`1<FileContentEntry>> continuation);
    internal static FSharpList`1<FileContentEntry> visitSynType(SynType t);
    internal static FSharpList`1<FileContentEntry> visitSynValTyparDecls(SynValTyparDecls _arg8);
    internal static FSharpList`1<FileContentEntry> visitSynTyparDecls(SynTyparDecls td);
    internal static FSharpList`1<FileContentEntry> visitSynTyparDecl(SynTyparDecl _arg9);
    internal static FSharpList`1<FileContentEntry> visitSynTypeConstraint(SynTypeConstraint tc);
    internal static FSharpList`1<FileContentEntry> finalContinuation@457(FSharpFunc`2<FSharpList`1<FileContentEntry>, FSharpList`1<FileContentEntry>> continuation, SynPat pat, FSharpList`1<SynExprAndBang> andBangs, IEnumerable`1<FSharpList`1<FileContentEntry>> nodes);
    internal static FSharpList`1<FileContentEntry> visit@309-13(SynExpr e, FSharpFunc`2<FSharpList`1<FileContentEntry>, FSharpList`1<FileContentEntry>> continuation);
    internal static FSharpList`1<FileContentEntry> visitSynExpr(SynExpr e);
    internal static FSharpList`1<FileContentEntry> finalContinuation@569-1(FSharpFunc`2<FSharpList`1<FileContentEntry>, FSharpList`1<FileContentEntry>> continuation, FSharpList`1<FileContentEntry> lids, IEnumerable`1<FSharpList`1<FileContentEntry>> nodes);
    internal static FSharpList`1<FileContentEntry> visit@525-73(SynPat p, FSharpFunc`2<FSharpList`1<FileContentEntry>, FSharpList`1<FileContentEntry>> continuation);
    internal static FSharpList`1<FileContentEntry> visitPat(SynPat p);
    internal static FSharpList`1<FileContentEntry> visitSynArgPats(SynArgPats argPat);
    internal static FSharpList`1<FileContentEntry> visitSynSimplePat(SynSimplePat pat);
    internal static FSharpList`1<FileContentEntry> visitSynSimplePats(SynSimplePats pats);
    internal static FSharpList`1<FileContentEntry> visitSynMatchClause(SynMatchClause _arg10);
    internal static FSharpList`1<FileContentEntry> visitBinding(SynBinding _arg11);
    internal static FSharpList`1<FileContentEntry> visitSynBindingReturnInfo(SynBindingReturnInfo _arg12);
    internal static FSharpList`1<FileContentEntry> visitSynMemberSig(SynMemberSig ms);
    internal static FSharpList`1<FileContentEntry> mkFileContent(FileInProject f);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.GraphChecking.FileContentQueryState : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<FSharpList`1<string>> OwnNamespace@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<FSharpList`1<string>> OpenedNamespaces@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<int> FoundDependencies@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int CurrentFile@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpSet`1<int> KnownFiles@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpOption`1<FSharpList`1<string>> OwnNamespace { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpSet`1<FSharpList`1<string>> OpenedNamespaces { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpSet`1<int> FoundDependencies { get; }
    [CompilationMappingAttribute("4", "3")]
internal int CurrentFile { get; }
    [CompilationMappingAttribute("4", "4")]
internal FSharpSet`1<int> KnownFiles { get; }
    internal FSharpSet`1<FSharpList`1<string>> OpenNamespaces { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.GraphChecking.FileContentQueryState")]
internal FileContentQueryState(FSharpOption`1<FSharpList`1<string>> ownNamespace, FSharpSet`1<FSharpList`1<string>> openedNamespaces, FSharpSet`1<int> foundDependencies, int currentFile, FSharpSet`1<int> knownFiles);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<FSharpList`1<string>> get_OwnNamespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpSet`1<FSharpList`1<string>> get_OpenedNamespaces();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpSet`1<int> get_FoundDependencies();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_CurrentFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpSet`1<int> get_KnownFiles();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FileContentQueryState obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FileContentQueryState Create(int fileIndex, FSharpSet`1<int> knownFiles, FSharpSet`1<int> filesAtRoot);
    internal FileContentQueryState AddOwnNamespace(FSharpList`1<string> ns, FSharpOption`1<FSharpSet`1<int>> files);
    internal FileContentQueryState AddDependencies(FSharpSet`1<int> files);
    internal FileContentQueryState AddOpenNamespace(FSharpList`1<string> path, FSharpOption`1<FSharpSet`1<int>> files);
    internal FSharpSet`1<FSharpList`1<string>> get_OpenNamespaces();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FileContentQueryState obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.GraphChecking.FileInProject : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Idx@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FileName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ParsedInput ParsedInput@;
    [CompilationMappingAttribute("4", "0")]
internal int Idx { get; }
    [CompilationMappingAttribute("4", "1")]
internal string FileName { get; }
    [CompilationMappingAttribute("4", "2")]
internal ParsedInput ParsedInput { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.GraphChecking.FileInProject")]
internal FileInProject(int idx, string fileName, ParsedInput parsedInput);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Idx();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedInput get_ParsedInput();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.GraphChecking.FilePairMap : object {
    internal FSharpMap`2<int, int> sigToImpl;
    internal FSharpMap`2<int, int> implToSig;
    public FilePairMap(FileInProject[] files);
    internal int GetSignatureIndex(int implementationIndex);
    internal int GetImplementationIndex(int signatureIndex);
    internal bool HasSignature(int implementationIndex);
    internal FSharpOption`1<int> TryGetSignatureIndex(int implementationIndex);
    internal bool IsSignature(int index);
    [CompilerGeneratedAttribute]
internal Tuple`2<FSharpMap`2<a, b>, FSharpMap`2<b, a>> buildBiDirectionalMaps(Tuple`2[] pairs);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.GraphChecking.Finisher`3 : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Node _node;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<State, Tuple`2<Result, State>> _finisher;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Node node { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<State, Tuple`2<Result, State>> finisher { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.GraphChecking.Finisher`3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Finisher`3(Node _node, FSharpFunc`2<State, Tuple`2<Result, State>> _finisher);
    [CompilationMappingAttribute("8", "0")]
internal static Finisher`3<Node, State, Result> NewFinisher(Node _node, FSharpFunc`2<State, Tuple`2<Result, State>> _finisher);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Node get_node();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<State, Tuple`2<Result, State>> get_finisher();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.GraphChecking.Graph : object {
    internal static IReadOnlyDictionary`2<Node, Node[]> make(IEnumerable`1<Tuple`2<Node, Node[]>> nodeDeps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IReadOnlyDictionary`2<U, U[]> map(FSharpFunc`2<T, U> f, IReadOnlyDictionary`2<T, T[]> graph);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IReadOnlyDictionary`2<Node, Node[]> addIfMissing(IEnumerable`1<Node> nodes, IReadOnlyDictionary`2<Node, Node[]> graph);
    internal static void dfs@35(IReadOnlyDictionary`2<Node, Node[]> graph, HashSet`1<Node> visited, Node node);
    internal static Node[] transitiveDeps@32(IReadOnlyDictionary`2<Node, Node[]> graph, Node node);
    internal static IReadOnlyDictionary`2<Node, Node[]> transitive(IReadOnlyDictionary`2<Node, Node[]> graph);
    internal static IReadOnlyDictionary`2<Node, Node[]> reverse(IReadOnlyDictionary`2<Node, Node[]> originalGraph);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void printCustom(IReadOnlyDictionary`2<Node, Node[]> graph, FSharpFunc`2<Node, string> nodePrinter);
    internal static void print(IReadOnlyDictionary`2<Node, Node[]> graph);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void serialiseToMermaid(string path, IReadOnlyDictionary`2<Tuple`2<int, string>, Tuple`2[]> graph);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.GraphChecking.GraphProcessing : object {
    internal static GraphNode`2<Item, Result> makeNode@46(IReadOnlyDictionary`2<Item, Item[]> graph, IReadOnlyDictionary`2<Item, Item[]> transitiveDeps, IReadOnlyDictionary`2<Item, Item[]> dependants, Item item);
    internal static GraphNode`2[] lookupMany@72(IReadOnlyDictionary`2<Item, GraphNode`2<Item, Result>> nodes, Item[] items);
    internal static void setExn@96(CancellationTokenSource localCts, object lockObj, FSharpRef`1<FSharpOption`1<Tuple`2<Item, Exception>>> exn, FSharpOption`1<Tuple`2<Item, Exception>> newExn);
    internal static void incrementProcessedNodesCount@107(CancellationTokenSource localCts, IReadOnlyDictionary`2<Item, GraphNode`2<Item, Result>> nodes, IncrementableInt processedCount, Unit unitVar0);
    internal static void queueNode@111(FSharpFunc`2<FSharpFunc`2<Item, ProcessedNode`2<Item, Result>>, FSharpFunc`2<NodeInfo`1<Item>, Result>> work, CancellationTokenSource localCts, CancellationTokenSource cts, IReadOnlyDictionary`2<Item, GraphNode`2<Item, Result>> nodes, FSharpFunc`2<Item, ProcessedNode`2<Item, Result>> getItemPublicNode, IncrementableInt processedCount, object lockObj, FSharpRef`1<FSharpOption`1<Tuple`2<Item, Exception>>> exn, GraphNode`2<Item, Result> node);
    internal static void processNode@123(FSharpFunc`2<FSharpFunc`2<Item, ProcessedNode`2<Item, Result>>, FSharpFunc`2<NodeInfo`1<Item>, Result>> work, CancellationTokenSource localCts, CancellationTokenSource cts, IReadOnlyDictionary`2<Item, GraphNode`2<Item, Result>> nodes, FSharpFunc`2<Item, ProcessedNode`2<Item, Result>> getItemPublicNode, IncrementableInt processedCount, object lockObj, FSharpRef`1<FSharpOption`1<Tuple`2<Item, Exception>>> exn, GraphNode`2<Item, Result> node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2[] processGraph(IReadOnlyDictionary`2<Item, Item[]> graph, FSharpFunc`2<FSharpFunc`2<Item, ProcessedNode`2<Item, Result>>, FSharpFunc`2<NodeInfo`1<Item>, Result>> work, CancellationToken parentCt);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.GraphChecking.QueryTrieNodeResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static QueryTrieNodeResult _unique_NodeDoesNotExist;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static QueryTrieNodeResult _unique_NodeDoesNotExposeData;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static QueryTrieNodeResult NodeDoesNotExist { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNodeDoesNotExist { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static QueryTrieNodeResult NodeDoesNotExposeData { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNodeDoesNotExposeData { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNodeExposesData { get; }
    private static QueryTrieNodeResult();
    [CompilationMappingAttribute("8", "0")]
internal static QueryTrieNodeResult get_NodeDoesNotExist();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNodeDoesNotExist();
    [CompilationMappingAttribute("8", "1")]
internal static QueryTrieNodeResult get_NodeDoesNotExposeData();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNodeDoesNotExposeData();
    [CompilationMappingAttribute("8", "2")]
internal static QueryTrieNodeResult NewNodeExposesData(FSharpSet`1<int> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNodeExposesData();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(QueryTrieNodeResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(QueryTrieNodeResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.GraphChecking.TrieMapping : object {
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> autoOpenShapes { get; }
    internal static FSharpSet`1<string> get_autoOpenShapes();
    internal static bool isAutoOpenAttribute(SynAttribute attribute);
    internal static bool isAnyAttributeAutoOpen(FSharpList`1<SynAttributeList> attributes);
    internal static bool doesFileExposeContentToTheRoot(ParsedInput ast);
    internal static void mergeTrieNodesAux@63(TrieNode root, KeyValuePair`2<string, TrieNode> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TrieNode mergeTrieNodes(int defaultChildSize, TrieNode[] tries);
    internal static Dictionary`2<TKey, TValue> mkDictFromKeyValuePairs(FSharpList`1<KeyValuePair`2<TKey, TValue>> items);
    internal static a visit@140-3(FSharpFunc`2<int, FSharpFunc`2<Decl, FSharpOption`1<KeyValuePair`2<string, TrieNode>>>> mkTrieForDeclaration, int idx, FSharpList`1<SynAttributeList> attributes, bool hasTypesOrAutoOpenNestedModules, FSharpList`1<Decl> decls, bool isNamespace, FSharpFunc`2<Dictionary`2<string, TrieNode>, a> continuation, FSharpList`1<Ident> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TrieNode processSynModuleOrNamespace(FSharpFunc`2<int, FSharpFunc`2<Decl, FSharpOption`1<KeyValuePair`2<string, TrieNode>>>> mkTrieForDeclaration, int idx, FSharpList`1<Ident> name, FSharpList`1<SynAttributeList> attributes, SynModuleOrNamespaceKind kind, bool hasTypesOrAutoOpenNestedModules, FSharpList`1<Decl> decls);
    internal static TrieNode mkTrieNodeFor(FileInProject file);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<KeyValuePair`2<string, TrieNode>> mkTrieForSynModuleDecl(int fileIndex, SynModuleDecl decl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<KeyValuePair`2<string, TrieNode>> mkTrieForSynModuleSigDecl(int fileIndex, SynModuleSigDecl decl);
    internal static TrieNode mkTrie(FileInProject[] files);
    internal static string getName@312(TrieNodeInfo node);
    internal static string toBoxList@318(FileInProject[] filesInProject, MermaidBoxPos boxPos, HashSet`1<int> files);
    internal static void printNode@333(FileInProject[] filesInProject, StringBuilder sb, TrieNode parent, TrieNode node);
    internal static void traverse@361(FileInProject[] filesInProject, StringBuilder sb, HashSet`1<TrieNodeInfo> discovered, TrieNode v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void serializeToMermaid(string path, FileInProject[] filesInProject, TrieNode trie);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.GraphChecking.TrieNode : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TrieNodeInfo Current@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Dictionary`2<string, TrieNode> Children@;
    [CompilationMappingAttribute("4", "0")]
internal TrieNodeInfo Current { get; }
    [CompilationMappingAttribute("4", "1")]
internal Dictionary`2<string, TrieNode> Children { get; }
    internal FSharpSet`1<int> Files { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.GraphChecking.TrieNode")]
internal TrieNode(TrieNodeInfo current, Dictionary`2<string, TrieNode> children);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TrieNodeInfo get_Current();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Dictionary`2<string, TrieNode> get_Children();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal FSharpSet`1<int> get_Files();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrieNode obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.GraphChecking.TrieNodeInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsRoot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNamespace { get; }
    internal FSharpSet`1<int> Files { get; }
    [CompilationMappingAttribute("8", "0")]
internal static TrieNodeInfo NewRoot(HashSet`1<int> _files);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsRoot();
    [CompilationMappingAttribute("8", "1")]
internal static TrieNodeInfo NewModule(string _name, int _file);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsModule();
    [CompilationMappingAttribute("8", "2")]
internal static TrieNodeInfo NewNamespace(string _name, HashSet`1<int> _filesThatExposeTypes, HashSet`1<int> _filesDefiningNamespaceWithoutTypes);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNamespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal FSharpSet`1<int> get_Files();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrieNodeInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.IlxGen : object {
    [DebuggerBrowsableAttribute("0")]
internal static T1065706_274Bytes@ field1065707@;
    [CompilationMappingAttribute("9")]
internal static int IlxGenStackGuardDepth { get; }
    internal static string debugDisplayMethodName { get; }
    internal static bool useHiddenInitCode { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr iLdcZero { get; }
    [CompilationMappingAttribute("9")]
internal static string mainMethName { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<TextWriter, Unit> reports { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> CountClosure { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> CountMethodDef { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> CountStaticFieldDef { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Unit, Unit> CountCallFuncInstructions { get; }
    [CompilationMappingAttribute("9")]
internal static sequel discard { get; }
    [CompilationMappingAttribute("9")]
internal static sequel discardAndReturnVoid { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILType> Push0 { get; }
    internal static bool compileSequenceExpressions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Type, object> defaultOf { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<MethodInfo> gminfo@11761 { get; }
    private static IlxGen();
    internal static int get_IlxGenStackGuardDepth();
    internal static FSharpList`1<TType> DropErasedTyargs(FSharpList`1<TType> tys);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_debugDisplayMethodName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_useHiddenInitCode();
    internal static ILInstr get_iLdcZero();
    internal static FSharpList`1<Tuple`3<string, string, a>> ChooseParamNames(FSharpList`1<Tuple`3<string, string, a>> fieldNamesAndTypes);
    internal static bool CheckCodeDoesSomething(ILCode code);
    internal static Tuple`2<string, Set`2<string, IComparer`1<string>>> chooseName@108(Set`2<string, IComparer`1<string>> names, Tuple`2<string, FSharpOption`1<int>> tupledArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> ChooseFreeVarNames(FSharpList`1<string> takenNames, FSharpList`1<string> ts);
    internal static bool IsILTypeByref(ILType inp);
    internal static string get_mainMethName();
    internal static FSharpFunc`2<TextWriter, Unit> get_reports();
    internal static void set_reports(FSharpFunc`2<TextWriter, Unit> value);
    internal static void AddReport(FSharpFunc`2<TextWriter, Unit> f);
    internal static void ReportStatistics(TextWriter oc);
    internal static FSharpFunc`2<Unit, Unit> NewCounter(string nm);
    internal static FSharpFunc`2<Unit, Unit> get_CountClosure();
    internal static FSharpFunc`2<Unit, Unit> get_CountMethodDef();
    internal static FSharpFunc`2<Unit, Unit> get_CountStaticFieldDef();
    internal static FSharpFunc`2<Unit, Unit> get_CountCallFuncInstructions();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTypeOfExpr(cenv cenv, Range m, ILType ilTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool useCallVirt(cenv cenv, ILBoxity boxity, ILMethodSpec mspec, bool isBaseCall);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@363-44(CompileLocation this, CompileLocation obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@363-45(IComparer comp, CompileLocation this, CompileLocation objTemp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string mkTopName(FSharpOption`1<string> ns, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompileLocation CompLocForFragment(string fragName, CcuThunk ccu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompileLocation CompLocForSubModuleOrNamespace(CompileLocation cloc, Entity submod);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompileLocation CompLocForFixedPath(string fragName, string qname, CompilationPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeRef NestedTypeRefForCompLoc(CompileLocation cloc, string n);
    internal static string CleanUpGeneratedTypeName(string nm);
    internal static CompileLocation CompLocForInitClass(CompileLocation cloc);
    internal static CompileLocation CompLocForPrivateImplementationDetails(CompileLocation cloc);
    internal static ILTypeRef TypeRefForCompLoc(CompileLocation cloc);
    internal static ILMemberAccess ComputeMemberAccess(bool hidden);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefAccess ComputeTypeAccess(ILTypeRef tref, bool hidden);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenTyAppAux(cenv cenv, Range m, TypeReprEnv tyenv, CompiledTypeRepr repr, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenILTyAppAux(cenv cenv, Range m, TypeReprEnv tyenv, ILTypeRef tref, ILBoxity boxity, FSharpOption`1<ILType> ilTypeOpt, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenNamedTyAppAux(cenv cenv, Range m, TypeReprEnv tyenv, PtrsOK ptrsOK, EntityRef tcref, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenTypeAux(cenv cenv, Range m, TypeReprEnv tyenv, VoidNotOK voidOK, PtrsOK ptrsOK, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxUnionCaseField[] GenUnionCaseRef(cenv cenv, Range m, TypeReprEnv tyenv, int i, RecdField[] fspecs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxUnionRef GenUnionRef(cenv cenv, Range m, EntityRef tcref);
    [CompilerGeneratedAttribute]
internal static IlxUnionHasHelpers ComputeUnionHasHelpers$cont@743(TcGlobals g, EntityRef tcref, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxUnionHasHelpers ComputeUnionHasHelpers(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<IlxUnionSpec, int> GenUnionCaseSpec(cenv cenv, Range m, TypeReprEnv tyenv, UnionCaseRef ucref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenType(cenv cenv, Range m, TypeReprEnv tyenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenReturnType(cenv cenv, Range m, TypeReprEnv tyenv, FSharpOption`1<TType> returnTyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenParamType(cenv cenv, Range m, TypeReprEnv tyenv, bool isSlotSig, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> GenTypeArgs(cenv cenv, Range m, TypeReprEnv tyenv, FSharpList`1<TType> tyargs);
    internal static ILFieldSpec GenFieldSpecForStaticField(bool isInteractive, TcGlobals g, ILType ilContainerTy, Val vspec, string nm, Range m, CompileLocation cloc, ILType ilTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec GenRecdFieldRef(Range m, cenv cenv, TypeReprEnv tyenv, RecdFieldRef rfref, FSharpList`1<TType> tyargs);
    internal static sequel get_discard();
    internal static sequel get_discardAndReturnVoid();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv SetIsInLoop(bool isInLoop, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv EnvForTypars(FSharpList`1<Typar> tps, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv EnvForTycon(Entity tps, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddTyparsToEnv(FSharpList`1<Typar> typars, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddSignatureRemapInfo(a _msg, SignatureRepackageInfo rpi, SignatureHidingInfo mhi, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForVal(TcGlobals g, Val v, Lazy`1<ValStorage> s, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForLocalVals(TcGlobals g, FSharpList`1<Tuple`2<Val, ValStorage>> vals, IlxGenEnv eenv);
    internal static IlxGenEnv RemoveTemplateReplacement(IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddTemplateReplacement(IlxGenEnv eenv, EntityRef tcref, ILTypeRef ftyvs, FSharpList`1<Typar> ilTy, FSharpList`1<Tuple`2<Typar, TType>> inst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForLocalWitness(IlxGenEnv eenv, TraitWitnessInfo w, ValStorage s);
    internal static IlxGenEnv ForceInitLocals(IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage StorageForVal(Range m, Val v, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ComputeGenerateWitnesses(TcGlobals g, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ValStorage> TryStorageForWitness(TcGlobals _g, IlxGenEnv eenv, TraitWitnessInfo w);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<ILMethodSpec, ILMethodSpec, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpList`1<ArgReprInfo>, ArgReprInfo, Tuple`3<FSharpList`1<TraitWitnessInfo>, FSharpList`1<TType>, FSharpOption`1<TType>>> GetMethodSpecForMemberVal(cenv cenv, ValMemberInfo memberInfo, ValRef vref);
    internal static ILFieldSpec generate@1451(Val vspec, string nm, Range m, bool isInteractive, ILType ilTyForProperty, ILType ilTy, TcGlobals g, CompileLocation cloc, Unit unitVar0);
    internal static ILFieldSpec ComputeFieldSpecForVal(FSharpOption`1<IlxGenIntraAssemblyInfo> optIntraAssemblyInfo, bool isInteractive, TcGlobals g, ILType ilTyForProperty, Val vspec, string nm, Range m, CompileLocation cloc, ILType ilTy, ILMethodRef ilGetterMethRef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage ComputeStorageForFSharpValue(cenv amap, TcGlobals g, CompileLocation cloc, FSharpOption`1<IlxGenIntraAssemblyInfo> optIntraAssemblyInfo, OptionalShadowLocal optShadowLocal, bool isInteractive, TType returnTy, ValRef vref, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage ComputeStorageForFSharpMember(cenv cenv, ValReprInfo valReprInfo, ValMemberInfo memberInfo, ValRef vref, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage ComputeStorageForFSharpFunctionOrFSharpExtensionMember(cenv cenv, CompileLocation cloc, ValReprInfo valReprInfo, ValRef vref, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsFSharpValCompiledAsMethod(TcGlobals g, Val v);
    internal static ValStorage ComputeStorageForValWithValReprInfo(cenv cenv, TcGlobals g, FSharpOption`1<IlxGenIntraAssemblyInfo> optIntraAssemblyInfo, bool isInteractive, OptionalShadowLocal optShadowLocal, ValRef vref, CompileLocation cloc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv ComputeAndAddStorageForLocalValWithValReprInfo(cenv cenv, TcGlobals g, IlxGenIntraAssemblyInfo intraAssemblyFieldTable, bool isInteractive, OptionalShadowLocal optShadowLocal, CompileLocation cloc, Val v, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValStorage ComputeStorageForNonLocalVal(cenv cenv, TcGlobals g, CompileLocation cloc, EntityRef modref, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForNonLocalModuleOrNamespaceRef(cenv cenv, TcGlobals g, CompileLocation cloc, IlxGenEnv acc, EntityRef modref, Entity modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddStorageForExternalCcu(cenv cenv, TcGlobals g, IlxGenEnv eenv, CcuThunk ccu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForLocalModuleOrNamespaceType(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, a eenv, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForTycon(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, Entity tycon, a eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AddDebugImportsToEnv(cenv cenv, IlxGenEnv eenv, FSharpList`1<OpenDeclaration> openDecls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForModuleOrNamespaceContents(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, a eenv, ModuleOrNamespaceContents x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a AddBindingsForModuleOrNamespaceBinding(FSharpFunc`2<CompileLocation, FSharpFunc`2<Val, FSharpFunc`2<a, a>>> allocVal, CompileLocation cloc, ModuleOrNamespaceBinding x, a eenv);
    internal static IlxGenEnv AddIncrementalLocalAssemblyFragmentToIlxGenEnv(cenv cenv, bool isIncrementalFragment, TcGlobals g, CcuThunk ccu, string fragName, IlxGenIntraAssemblyInfo intraAssemblyInfo, IlxGenEnv eenv, FSharpList`1<CheckedImplFile> implFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILDebugPoint GenILSourceMarker(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILDebugPoint> GenPossibleILDebugRange(cenv cenv, Range m);
    internal static FSharpList`1<b> HashRangeSorted(IDictionary`2<a, Tuple`2<int, b>> ht);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<b> MergeOptions(a m, FSharpOption`1<b> o1, FSharpOption`1<b> o2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDef MergePropertyPair(a m, ILPropertyDef pd, ILPropertyDef pdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AddPropertyDefToHash(Range m, Dictionary`2<PropKey, Tuple`2<int, ILPropertyDef>> ht, ILPropertyDef pdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILPropertyDef> MergePropertyDefs(Range m, FSharpList`1<a> ilPropertyDefs);
    internal static FSharpList`1<ILType> get_Push0();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr FeeFeeInstr(cenv cenv, ILSourceDocument doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenString(cenv cenv, CodeGenBuffer cgbuf, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenConstArray(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ILType ilElementType, a[] data, FSharpFunc`2<ByteBuffer, FSharpFunc`2<a, Unit>> write);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`7<FSharpList`1<ILLocal>, int, Dictionary`2<int, int>, ILInstr[], FSharpList`1<ILExceptionSpec>, FSharpList`1<ILLocalDebugInfo>, bool> CodeGenThen(cenv cenv, AssemblyBuilder mgbuf, FSharpList`1<Tuple`2<ValRef, BranchCallItem>> entryPointInfo, string methodName, IlxGenEnv eenv, int alreadyUsedArgs, FSharpOption`1<Val> selfArgOpt, FSharpFunc`2<CodeGenBuffer, FSharpFunc`2<IlxGenEnv, Unit>> codeGenFunction, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ILInstr[], ILMethodBody> CodeGenMethod(cenv cenv, AssemblyBuilder mgbuf, FSharpList`1<Tuple`2<ValRef, BranchCallItem>> entryPointInfo, string methodName, IlxGenEnv eenv, int alreadyUsedArgs, FSharpOption`1<Val> selfArgOpt, FSharpFunc`2<CodeGenBuffer, FSharpFunc`2<IlxGenEnv, Unit>> codeGenFunction, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Mark, Mark> StartDelayedLocalScope(string nm, CodeGenBuffer cgbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Mark, Mark> StartLocalScope(string nm, CodeGenBuffer cgbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a LocalScope(string nm, CodeGenBuffer cgbuf, FSharpFunc`2<Tuple`2<Mark, Mark>, a> f);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_compileSequenceExpressions();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, FSharpOption`1<Range>> ComputeDebugPointForBinding(TcGlobals g, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool GenExprPreSteps(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExprAux(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExprs(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodBody CodeGenMethodForExpr(cenv cenv, AssemblyBuilder mgbuf, FSharpList`1<Tuple`2<ValRef, BranchCallItem>> entryPointInfo, string methodName, IlxGenEnv eenv, int alreadyUsedArgs, FSharpOption`1<Val> selfArgOpt, Expr expr0, sequel sequel0);
    internal static Tuple`7<g, h, n, j, k, l, m> change3rdOutOf7@3075(g tupledArg0, h tupledArg1, i tupledArg2, j tupledArg3, k tupledArg4, l tupledArg5, m tupledArg6, n newA3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<ILMethodBody> DelayCodeGenMethodForExpr(cenv cenv, AssemblyBuilder mgbuf, FSharpList`1<Tuple`2<ValRef, BranchCallItem>> args_0, string args_1, IlxGenEnv eenv, int args_3, FSharpOption`1<Val> args_4, Expr args_5, sequel args_6);
    internal static FSharpOption`1<sequel> sequelAfterDiscard(sequel sequel);
    internal static sequel sequelIgnoringEndScopesAndDiscard(sequel sequel);
    internal static sequel sequelIgnoreEndScopes(sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSequelEndScopes(CodeGenBuffer cgbuf, sequel sequel);
    internal static string StringOfSequel(sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSequel(cenv cenv, CompileLocation cloc, CodeGenBuffer cgbuf, sequel sequel);
    internal static void emitInt64Constant@3199(CodeGenBuffer cgbuf, ILType ilTy, long i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenConstant(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Const c, Range m, TType ty, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenUnitTy(cenv cenv, IlxGenEnv eenv, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUnit(cenv cenv, IlxGenEnv eenv, Range m, CodeGenBuffer cgbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUnitThenSequel(cenv cenv, IlxGenEnv eenv, Range m, CompileLocation cloc, CodeGenBuffer cgbuf, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocTuple(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TupInfo tupInfo, FSharpList`1<Expr> args, FSharpList`1<TType> argTys, Range m, sequel sequel);
    internal static Expr getCompiledTupleItem@3283(cenv cenv, IlxGenEnv eenv, bool tupInfo, TcGlobals g, Expr e, FSharpList`1<TType> tys, int n, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetTupleField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TupInfo tupInfo, Expr e, FSharpList`1<TType> tys, int n, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocExn(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, EntityRef c, FSharpList`1<Expr> args, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocUnionCaseCore(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, UnionCaseRef c, FSharpList`1<TType> tyargs, int n, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocUnionCase(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, UnionCaseRef c, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m, sequel sequel);
    [CompilerGeneratedAttribute]
internal static FakeUnit func1@1-26(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<ILType> stackAfterJoin, sequel sequelAfterJoin, Mark afterJoin, FakeUnit _arg1);
    [CompilerGeneratedAttribute]
internal static FakeUnit func1@1-27(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, sequel sequel, FSharpList`1<TType> tyargs, Range m, UnionCaseRef c, FSharpList`1<Expr> argsFront, FakeUnit _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeUnit GenLinearExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr expr, sequel sequel, bool preSteps, FSharpFunc`2<FakeUnit, FakeUnit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocRecd(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecordConstructionInfo ctorInfo, EntityRef tcref, FSharpList`1<TType> argTys, FSharpList`1<Expr> args, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAllocAnonRecd(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, AnonRecdTypeInfo anonInfo, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetAnonRecdField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, AnonRecdTypeInfo anonInfo, Expr e, FSharpList`1<TType> tyargs, int n, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenNewArraySimple(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Expr> elems, TType elemTy, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenNewArray(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Expr> elems, TType elemTy, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenCoerce(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, TType tgtTy, Range m, TType srcTy, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenReraise(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType retTy, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetExnField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, EntityRef ecref, int fieldNum, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetExnField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, EntityRef ecref, int fieldNum, Expr e2, Range m, sequel sequel);
    internal static ICodeGen`1<Mark> UnionCodeGen(CodeGenBuffer cgbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUnionCaseProof(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, UnionCaseRef ucref, FSharpList`1<TType> tyargs, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetUnionCaseField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, UnionCaseRef ucref, FSharpList`1<TType> tyargs, int n, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetUnionCaseFieldAddr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, UnionCaseRef ucref, FSharpList`1<TType> tyargs, int n, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetUnionCaseTag(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, EntityRef tcref, FSharpList`1<TType> tyargs, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetUnionCaseField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, UnionCaseRef ucref, FSharpList`1<TType> tyargs, int n, Expr e2, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetRecdFieldAddr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, RecdFieldRef f, FSharpList`1<TType> tyargs, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetStaticFieldAddr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef f, FSharpList`1<TType> tyargs, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetRecdField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, RecdFieldRef f, FSharpList`1<TType> tyargs, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetRecdField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e1, RecdFieldRef f, FSharpList`1<TType> tyargs, Expr e2, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetStaticField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef f, FSharpList`1<TType> tyargs, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetStaticField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef f, FSharpList`1<TType> tyargs, Expr e2, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenFieldGet(bool isStatic, cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef rfref, FSharpList`1<TType> tyargs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenFieldStore(bool isStatic, cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, RecdFieldRef rfref, FSharpList`1<TType> tyargs, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUntupledArgsDiscardingLoneUnit(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, int numObjArgs, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> curriedArgInfos, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenUntupledArgExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, FSharpList`1<Tuple`2<TType, ArgReprInfo>> argInfos, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenWitnessArgFromTraitInfo(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenWitnessArgFromWitnessInfo(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, TraitWitnessInfo witnessInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenWitnessArgsFromWitnessInfos(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, IEnumerable`1<TraitWitnessInfo> witnessInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenWitnessArgs(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, FSharpList`1<Typar> tps, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsBranchTailcall(cenv cenv, IlxGenEnv eenv, ValRef v, FSharpList`1<TType> tyargs, FSharpList`1<a> curriedArgs, sequel sequel);
    [CompilerGeneratedAttribute]
internal static int numArgs$cont@4091(FSharpList`1<Expr> curriedArgs, int numObjArgs, int numMethodArgs, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> curriedArgInfos, Unit unitVar);
    internal static Expr |OptionalCoerce|@4135(Expr x);
    internal static Expr |OptionalTyapp|@4140(Expr x);
    internal static FSharpList`1<ILType> mkFormalParams@4169(FSharpList`1<TType> gparams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenApp(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr f, TType fty, FSharpList`1<TType> tyargs, FSharpList`1<Expr> curriedArgs, Range m, sequel sequel);
    internal static ILTailcall CanTailcall(bool hasStructObjArg, FSharpOption`1<TType> ccallInfo, bool withinSEH, bool hasByrefArg, bool mustGenerateUnitAfterCall, bool isDllImport, bool isSelfInit, bool makesNoCriticalTailcalls, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<string> ChooseWitnessInfoNames(FSharpList`1<string> takenNames, FSharpList`1<TraitWitnessInfo> witnessInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ILParameter>, FSharpList`1<Tuple`2<TraitWitnessInfo, ValStorage>>> ArgStorageForWitnessInfos(cenv cenv, IlxGenEnv eenv, FSharpList`1<string> takenNames, int pretakenArgs, Range m, FSharpList`1<TraitWitnessInfo> witnessInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<IlxClosureFreeVar>, FSharpList`1<Tuple`2<TraitWitnessInfo, ValStorage>>> FreeVarStorageForWitnessInfos(cenv cenv, IlxGenEnv eenv, FSharpList`1<string> takenNames, ILType ilCloTyInner, Range m, FSharpList`1<TraitWitnessInfo> witnessInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> IsLocalErasedTyLambda(IlxGenEnv eenv, Val v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsNamedLocalTypeFuncVal(TcGlobals g, Val v, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<ILParameter>, FSharpList`1<TraitWitnessInfo>, IlxGenEnv> AddDirectTyparWitnessParams(cenv cenv, IlxGenEnv eenv, IlxClosureInfo cloinfo, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GenNamedLocalTyFuncCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType ty, IlxClosureInfo cloinfo, FSharpList`1<TType> tyargs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenCurriedArgsAndIndirectCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType funcTy, FSharpList`1<TType> tyargs, FSharpList`1<Expr> curriedArgs, Range m, sequel sequel);
    internal static bool check@4581-12(IlxClosureApps x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenIndirectCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType funcTy, FSharpList`1<TType> tyargs, FSharpList`1<Expr> curriedArgs, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<FSharpOption`1<Tuple`2<int, ILType>>, IlxGenEnv, Tuple`2<FSharpList`1<ILType>, FSharpList`1<int>>, Tuple`2<int, int>, Mark> GenTry(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Mark scopeMarks_0, Mark scopeMarks_1, Expr e1, Range m, TType resultTy, DebugPointAtTry spTry);
    internal static bool check@4668-13(FSharpFunc`2<DecisionTreeCase, bool> checkDecisionTreeCase, Expr expr);
    internal static bool checkDecisionTree@4686-2(FSharpFunc`2<DecisionTreeCase, bool> checkDecisionTreeCase, DecisionTree dtree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool eligibleForFilter(cenv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTryWith(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e1, Val valForFilter, Expr filterExpr, Val valForHandler, Expr handlerExpr, Range m, TType resTy, DebugPointAtTry spTry, DebugPointAtWith spWith, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTryFinally(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr bodyExpr, Expr handlerExpr, Range m, TType resTy, DebugPointAtTry spTry, DebugPointAtFinally spFinally, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenIntegerForLoop(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, DebugPointAtFor spFor, DebugPointAtInOrTo spTo, Val v, Expr e1, ForLoopStyle dir, Expr e2, Expr loopBody, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenWhileLoop(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, DebugPointAtWhile spWhile, Expr condExpr, Expr bodyExpr, Range m, sequel sequel);
    internal static void err@5055-5(Range m, ILInstr i, string s);
    internal static ILFieldSpec modFieldSpec@5058(FSharpList`1<ILType> ilTyArgs, ILFieldSpec fspec);
    internal static bool anyfpType@5176(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenAsmCode(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<ILInstr> il, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, FSharpList`1<TType> returnTys, Range m, sequel sequel);
    internal static Expr mkList@5268(Range m, TcGlobals g, TType ty, FSharpList`1<Expr> els);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenQuotation(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr ast, FSharpRef`1<FSharpOption`1<Tuple`2<Tuple`4<FSharpList`1<ILTypeRef>, FSharpList`1<TType>, FSharpList`1<Expr>, ExprData>, Tuple`4<FSharpList`1<ILTypeRef>, FSharpList`1<TType>, FSharpList`1<Expr>, ExprData>>>> qdataCell, Range m, TType ety, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenILCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, bool virt, bool valu, bool newobj, ValUseFlag valUseFlags, bool isDllImport, ILMethodRef ilMethRef, FSharpList`1<TType> enclArgTys, FSharpList`1<TType> methArgTys, FSharpList`1<Expr> argExprs, FSharpList`1<TType> returnTys, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CommitCallSequel(cenv cenv, IlxGenEnv eenv, Range m, CompileLocation cloc, CodeGenBuffer cgbuf, bool mustGenerateUnitAfterCall, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeNotSupportedExnExpr(cenv cenv, IlxGenEnv eenv, Expr argExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTraitCall(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs, Range m, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetAddrOfRefCellField(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Expr e, TType ty, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetValAddr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef v, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetByref(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef v, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetByref(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef v, Expr e, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenDefaultValue(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, TType ty, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILGenericParameterDef GenGenericParam(cenv cenv, IlxGenEnv eenv, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILParameter GenSlotParam(Range m, cenv cenv, IlxGenEnv eenv, SlotParam slotParam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ILType, FSharpList`1<ILParameter>, ILReturn> GenFormalSlotsig(Range m, cenv cenv, IlxGenEnv eenv, SlotSig slotsig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILOverridesSpec GenOverridesSpec(cenv cenv, IlxGenEnv eenv, SlotSig slotsig, Range m, bool isInstance);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILReturn GenFormalReturnType(Range m, cenv cenv, IlxGenEnv eenvFormal, FSharpOption`1<TType> returnTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotParam instSlotParam(FSharpList`1<Tuple`2<Typar, TType>> inst, SlotParam _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ILParameter>, ILReturn> GenActualSlotsig(Range m, cenv cenv, IlxGenEnv eenv, SlotSig _arg2, FSharpList`1<Typar> methTyparsOfOverridingMethod, FSharpList`1<Val> methodParams);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string GenNameOfOverridingMethod(cenv cenv, bool useMethodImpl, SlotSig slotsig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, FSharpFunc`2<Tuple`2<ILType, FSharpList`1<Typar>>, ILMethodImplDef>> GenMethodImpl(cenv cenv, IlxGenEnv eenv, bool useMethodImpl, SlotSig slotsig, Range m, bool isInstance);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv bindBaseOrThisVarOpt(cenv cenv, IlxGenEnv eenv, FSharpOption`1<Val> baseValOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef renameMethodDef(string nameOfOverridingMethod, ILMethodDef mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Tuple`3<bool, FSharpFunc`2<Tuple`2<ILType, FSharpList`1<Typar>>, ILMethodImplDef>, FSharpList`1<Typar>>, ILMethodDef>> GenObjectExprMethod(cenv cenv, IlxGenEnv eenvinner, CodeGenBuffer cgbuf, bool useMethodImpl, ObjExprMethod tmethod);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenStructStateMachine(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, LoweredStateMachine res, sequel sequel);
    internal static FSharpList`1<Tuple`2<FSharpOption`1<ILMethodImplDef>, ILMethodDef>> genMethodAndOptionalMethodImpl@6254(cenv cenv, CodeGenBuffer cgbuf, ILType ilTyForOverriding, IlxGenEnv eenvinner, ObjExprMethod tmethod, bool useMethodImpl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenObjectExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, Expr objExpr, TType baseType, FSharpOption`1<Val> baseValOpt, Expr basecall, FSharpList`1<ObjExprMethod> overrides, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> interfaceImpls, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSequenceExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, ValRef nextEnumeratorValRef, ValRef pcvref, ValRef currvref, FSharpList`1<ValRef> stateVars, Expr generateNextExpr, Expr closeExpr, Expr checkCloseExpr, TType seqElemTy, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILTypeDef> GenClosureTypeDefs(cenv cenv, ILTypeRef tref, FSharpList`1<ILGenericParameterDef> ilGenParams, FSharpList`1<ILAttribute> attrs, IlxClosureFreeVar[] ilCloAllFreeVars, IlxClosureLambdas ilCloLambdas, ILMethodBody ilCtorBody, FSharpList`1<ILMethodDef> mdefs, FSharpList`1<ILMethodImplDef> mimpls, ILType ext, FSharpList`1<ILType> ilIntfTys, FSharpOption`1<IlxClosureSpec> cloSpec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILTypeDef> GenStaticDelegateClosureTypeDefs(cenv cenv, ILTypeRef tref, FSharpList`1<ILGenericParameterDef> ilGenParams, FSharpList`1<ILAttribute> attrs, IlxClosureFreeVar[] ilCloAllFreeVars, IlxClosureLambdas ilCloLambdas, ILMethodBody ilCtorBody, FSharpList`1<ILMethodDef> mdefs, FSharpList`1<ILMethodImplDef> mimpls, ILType ext, FSharpList`1<ILType> ilIntfTys, FSharpOption`1<IlxClosureSpec> staticCloInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILGenericParameterDef> GenGenericParams(cenv cenv, IlxGenEnv eenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILType> GenGenericArgs(Range m, TypeReprEnv tyenv, FSharpList`1<Typar> tps);
    internal static Tuple`2<ILType, IlxClosureLambdas> strip@6636-13(IlxClosureLambdas lambdas);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<IlxClosureInfo, ILTypeRef, FSharpList`1<ILTypeDef>> GenClosureAsLocalTypeFunction(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<ValRef> thisVars, Expr expr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<IlxClosureInfo, ILTypeRef, FSharpList`1<ILTypeDef>> GenClosureAsFirstClassFunction(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<ValRef> thisVars, Range m, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<IlxClosureInfo, Range> GenLambdaClosure(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, bool isLocalTypeFunc, FSharpList`1<ValRef> thisVars, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenClosureAlloc(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, IlxClosureInfo cloinfo, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLambda(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, bool isLocalTypeFunc, FSharpList`1<ValRef> thisVars, Expr expr, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenTypeOfVal(cenv cenv, IlxGenEnv eenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenFreevar(cenv cenv, Range m, IlxGenEnv eenvouter, TypeReprEnv tyenvinner, Val fv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<Typar>, FSharpList`1<TraitWitnessInfo>, FSharpList`1<Val>, ILTypeRef, IlxClosureFreeVar[], IlxGenEnv> GetIlxClosureFreeVars(cenv cenv, Range m, FSharpList`1<ValRef> thisVars, ILBoxity boxity, IlxGenEnv eenvouter, FSharpList`1<string> takenNames, Expr expr);
    internal static Tuple`4<FSharpList`1<FSharpList`1<Typar>>, FSharpList`1<Val>, Expr, TType> getCallStructure@6913(bool isLocalTypeFunc, TcGlobals g, FSharpList`1<FSharpList`1<Typar>> tvacc, FSharpList`1<Val> vacc, Expr e, TType ety);
    internal static Tuple`2<IlxClosureLambdas, IlxGenEnv> getClosureArgs@6932(cenv cenv, Range m, TcGlobals g, TType returnTy, IlxGenEnv eenv, int numArgs, FSharpList`1<FSharpList`1<Typar>> tvsl, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<IlxClosureInfo, Expr, IlxGenEnv> GetIlxClosureInfo(cenv cenv, Range m, ILBoxity boxity, bool isLocalTypeFunc, bool canUseStaticField, FSharpList`1<ValRef> thisVars, IlxGenEnv eenvouter, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenDelegateExpr(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, Expr expr, ObjExprMethod _arg3, Range m, sequel sequel);
    internal static bool ExprIsTraitCall(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExprIndicatesGenericStaticConstrainedCall(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExprRequiresWitness(cenv cenv, Range m, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenStaticOptimization(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<StaticOptimization> staticConditions, Expr e2, Expr e3, Range m, sequel sequel);
    internal static bool IsSequelImmediate(sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<sequel, Mark, FSharpList`1<ILType>, sequel> GenJoinPoint(cenv cenv, CodeGenBuffer cgbuf, string pos, IlxGenEnv eenv, TType ty, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeUnit GenDecisionTreeAndTargets(cenv cenv, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, DecisionTree tree, DecisionTreeTarget[] targets, sequel sequel, FSharpFunc`2<FakeUnit, FakeUnit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeUnit GenPostponedDecisionTreeTargets(cenv cenv, CodeGenBuffer cgbuf, FSharpList`1<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>> targetInfos, FSharpList`1<ILType> stackAtTargets, sequel sequel, FSharpFunc`2<FakeUnit, FakeUnit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeUnit GenDecisionTreeAndTargetsInner(cenv cenv, CodeGenBuffer cgbuf, FSharpOption`1<Mark> inplabOpt, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, DecisionTree tree, DecisionTreeTarget[] targets, FSharpRef`1<int> targetCounts_0, Dictionary`2<int, int> targetCounts_1, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel, FSharpFunc`2<Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>>, FakeUnit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b GetTarget(b[] targets, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>>, FSharpOption`1<Tuple`3<IlxGenEnv, Expr, sequel>>> GenDecisionTreeSuccess(cenv cenv, CodeGenBuffer cgbuf, FSharpOption`1<Mark> inplabOpt, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, FSharpList`1<Expr> es, int targetIdx, DecisionTreeTarget[] targets, FSharpRef`1<int> targetNext, Dictionary`2<int, int> targetCounts, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<IlxGenEnv, Expr, sequel> GenDecisionTreeTarget(cenv cenv, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, Mark targetMarkBeforeBinds, Mark targetMarkAfterBinds, IlxGenEnv eenvAtTarget, Expr successExpr, FSharpList`1<Val> vs, FSharpList`1<Expr> es, FSharpOption`1<FSharpList`1<bool>> stateVarFlagsOpt, Mark startMark, Mark endMark, sequel sequel);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<int, int> func2@1-7(int e1);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<int, int> func2@1-8(int e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeUnit GenDecisionTreeSwitch(cenv cenv, CodeGenBuffer cgbuf, FSharpOption`1<Mark> inplabOpt, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, Expr e, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> defaultTargetOpt, Range switchm, DecisionTreeTarget[] targets, FSharpRef`1<int> targetCounts_0, Dictionary`2<int, int> targetCounts_1, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel, FSharpFunc`2<Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>>, FakeUnit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeUnit GenDecisionTreeCases(cenv cenv, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, IlxGenEnv eenv, FSharpOption`1<DecisionTree> defaultTargetOpt, DecisionTreeTarget[] targets, FSharpRef`1<int> targetCounts_0, Dictionary`2<int, int> targetCounts_1, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel, FSharpList`1<Mark> caseLabels, FSharpList`1<DecisionTreeCase> cases, FSharpFunc`2<Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>>, FakeUnit> contf);
    internal static FSharpOption`1<bool> |BoolExpr|_|(Expr _arg37);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FakeUnit GenDecisionTreeTest(cenv cenv, CompileLocation cloc, CodeGenBuffer cgbuf, FSharpList`1<ILType> stackAtTargets, Expr e, FSharpOption`1<Tuple`3<int, FSharpList`1<ILType>, FSharpChoice`2<Tuple`3<bool, IlxUnionSpec, int>, ILInstr>>> tester, bool isNullTest, IlxGenEnv eenv, DecisionTree successTree, DecisionTree failureTree, DecisionTreeTarget[] targets, FSharpRef`1<int> targetCounts_0, Dictionary`2<int, int> targetCounts_1, Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>> targetInfos, sequel sequel, FSharpFunc`2<Map`3<int, Tuple`2<Tuple`8<Mark, Mark, IlxGenEnv, Expr, FSharpList`1<Val>, FSharpList`1<Expr>, FSharpOption`1<FSharpList`1<bool>>, Tuple`2<Mark, Mark>>, bool>, IComparer`1<int>>, FakeUnit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLetRecFixup(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, IlxClosureSpec ilxCloSpec, Expr e, ILFieldSpec ilField, Expr e2, c _m);
    internal static FSharpFunc`2<FSharpOption`1<Val>, FSharpFunc`2<Expr, FSharpFunc`2<FSharpFunc`2<Expr, Expr>, FSharpFunc`2<Expr, Unit>>>> computeFixupsForOneRecursiveVar@8068(cenv cenv, CodeGenBuffer cgbuf, Range m, IlxGenEnv eenv, Val boundv, Set`2<Val, IComparer`1<Val>> forwardReferenceSet, FSharpRef`1<FSharpList`1<Tuple`3<Val, Val, FSharpFunc`2<Unit, Unit>>>> fixups);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLetRecBindings(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Binding> allBinds, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenLetRec(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Binding> binds, Expr body, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenDebugPointForBind(cenv cenv, CodeGenBuffer cgbuf, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenBinding(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Binding bind, bool isStateVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMemberAccess ComputeMethodAccessRestrictedBySig(IlxGenEnv eenv, Val vspec);
    internal static bool canTarget@8376(FSharpOption`1<AttributeTargets> targets, AttributeTargets goal);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenBindingAfterDebugPoint(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Binding bind, bool isStateVar, FSharpOption`1<Mark> startMarkOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GetStoreValCtxt(CodeGenBuffer cgbuf, IlxGenEnv eenv, Val vspec);
    internal static ILNativeType decodeUnmanagedType@8547(Range m, AttributeDecoder decoder, int unmanagedType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<ILNativeType>, FSharpList`1<Attrib>> GenMarshal(cenv cenv, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<bool, bool, bool, FSharpOption`1<ILFieldInit>, FSharpOption`1<ILNativeType>, FSharpList`1<Attrib>> GenParamAttribs(cenv cenv, TType paramTy, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILParameter> GenParams(cenv cenv, IlxGenEnv eenv, Range m, ILMethodSpec mspec, FSharpList`1<TraitWitnessInfo> witnessInfos, FSharpList`1<ArgReprInfo> argInfos, FSharpList`1<TType> methArgTys, FSharpOption`1<FSharpList`1<Val>> implValsOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILReturn GenReturnInfo(cenv cenv, IlxGenEnv eenv, FSharpOption`1<TType> returnTy, ILType ilRetTy, ArgReprInfo retInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILPropertyDef GenPropertyForMethodDef(bool compileAsInstance, ILTypeRef tref, ILMethodDef mdef, Val v, ValMemberInfo memberInfo, FSharpList`1<ILType> ilArgTys, ILType ilPropTy, ILAttributes ilAttrs, FSharpOption`1<string> compiledName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILEventDef GenEventForProperty(cenv cenv, IlxGenEnv eenvForMeth, ILMethodSpec mspec, Val v, FSharpList`1<ILAttribute> ilAttrsThatGoOnPrimaryItem, Range m, TType returnTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> ComputeMethodImplNameFixupForMemberBinding(cenv cenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpFunc`2<d, ILMethodDef>> ComputeFlagFixupsForMemberBinding(cenv cenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<bool, bool, bool, bool, FSharpList`1<Attrib>> ComputeMethodImplAttribs(cenv cenv, Val _v, FSharpList`1<Attrib> attrs);
    internal static FSharpList`1<FSharpFunc`2<g, ILMethodDef>> flagFixups@9215();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenMethodForBinding(cenv cenv, AssemblyBuilder mgbuf, IlxGenEnv eenv, Val v, ILMethodSpec mspec, bool hasWitnessEntry, bool generateWitnessArgs, ILMemberAccess access, FSharpList`1<Typar> ctps, FSharpList`1<Typar> mtps, FSharpList`1<TraitWitnessInfo> witnessInfos, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> curriedArgInfos, FSharpList`1<ArgReprInfo> paramInfos, FSharpList`1<TType> argTys, ArgReprInfo retInfo, ValReprInfo valReprInfo, FSharpOption`1<Val> ctorThisValOpt, FSharpOption`1<Val> baseValOpt, FSharpList`1<Typar> methLambdaTypars, FSharpList`1<Val> methLambdaVars, Expr methLambdaBody, TType returnTy);
    internal static Tuple`2<bool, MethodBody> GenPInvokeMethod(string nm, string dll, FSharpList`1<AttribNamedArg> namedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenBindings(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, FSharpList`1<Binding> binds, FSharpOption`1<FSharpList`1<bool>> stateVarFlagsOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetVal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef vref, Expr e, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetValRefAndSequel(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, ValRef v, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, Range, sequel>> storeSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetVal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, ValRef v, Range m, sequel sequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenBindingRhs(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Val vspec, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CommitStartScope(CodeGenBuffer cgbuf, FSharpOption`1<Mark> startMarkOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitInitLocal(CodeGenBuffer cgbuf, ILType ty, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitSetLocal(CodeGenBuffer cgbuf, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitGetLocal(CodeGenBuffer cgbuf, ILType ty, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitSetStaticField(CodeGenBuffer cgbuf, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitGetStaticFieldAddr(CodeGenBuffer cgbuf, ILType ty, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitGetStaticField(CodeGenBuffer cgbuf, ILType ty, ILFieldSpec fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenSetStorage(Range m, CodeGenBuffer cgbuf, ValStorage storage);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CommitGetStorageSequel(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, TType ty, FSharpOption`1<Tuple`2<e, FSharpRef`1<NamedLocalIlxClosureInfo>>> localCloInfo, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, Range, sequel>> storeSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetStorageAndSequel(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, TType ty, ILType ilTy, ValStorage storage, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, Range, sequel>> storeSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetLocalVals(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenvouter, Range m, FSharpList`1<Val> fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetLocalVal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, Val vspec, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, Range, sequel>> storeSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenGetLocalVRef(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, ValRef vref, FSharpOption`1<Tuple`4<FSharpList`1<TType>, FSharpList`1<Expr>, Range, sequel>> storeSequel);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenStoreVal(CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<int, bool, IlxGenEnv> AllocLocal(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, bool compgen, string v, ILType ty, bool isFixed, Mark scopeMarks_0, Mark scopeMarks_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ValStorage, IlxGenEnv> AllocLocalVal(cenv cenv, CodeGenBuffer cgbuf, Val v, IlxGenEnv eenv, FSharpOption`1<Expr> repr, Mark scopeMarks_0, Mark scopeMarks_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AllocStorageForBind(cenv cenv, CodeGenBuffer cgbuf, Mark scopeMarks_0, Mark scopeMarks_1, IlxGenEnv eenv, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AllocStorageForBinds(cenv cenv, CodeGenBuffer cgbuf, Mark scopeMarks_0, Mark scopeMarks_1, IlxGenEnv eenv, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<ValStorage>, IlxGenEnv> AllocValForBind(cenv cenv, CodeGenBuffer cgbuf, Mark scopeMarks_0, Mark scopeMarks_1, IlxGenEnv eenv, Binding _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv AllocValReprWithinExpr(cenv cenv, CodeGenBuffer cgbuf, Mark endMark, CompileLocation cloc, Val v, IlxGenEnv eenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<ILType>, FSharpList`1<int>>, IlxGenEnv> EmitSaveStack(cenv cenv, CodeGenBuffer cgbuf, IlxGenEnv eenv, Range m, Mark scopeMarks_0, Mark scopeMarks_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void EmitRestoreStack(CodeGenBuffer cgbuf, FSharpList`1<ILType> savedStack, FSharpList`1<int> savedStackLocals);
    [CompilerGeneratedAttribute]
internal static ILAttribElem GenAttribArg$cont@9771(ILType ilArgTy, Range m, Const c, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribElem GenAttribArg(cenv amap, TcGlobals g, IlxGenEnv eenv, Expr x, ILType ilArgTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute GenAttr(cenv cenv, TcGlobals g, IlxGenEnv eenv, Attrib _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILAttribute> GenAttrs(cenv cenv, IlxGenEnv eenv, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILAttribute> GenCompilationArgumentCountsAttr(cenv cenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILSecurityDecl> CreatePermissionSets(cenv cenv, IlxGenEnv eenv, FSharpList`1<Attrib> securityAttributes);
    [CompilerGeneratedAttribute]
internal static bool contains@1-12(string value, a e, FSharpList`1<string> xs1);
    internal static void GenTypeDefForCompLoc(cenv cenv, IlxGenEnv eenv, AssemblyBuilder mgbuf, CompileLocation cloc, bool hidden, FSharpList`1<Attrib> attribs, ILTypeInit initTrigger, bool eliminateIfEmpty, bool addAtEnd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenImplFileContents(cenv cenv, CodeGenBuffer cgbuf, QualifiedNameOfFile qname, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, ModuleOrNamespaceType mty, ModuleOrNamespaceContents def);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv GenModuleOrNamespaceContents(cenv cenv, CodeGenBuffer cgbuf, QualifiedNameOfFile qname, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, ModuleOrNamespaceContents x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenModuleBinding(cenv cenv, CodeGenBuffer cgbuf, QualifiedNameOfFile qname, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, Range m, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv GenImplFile(cenv cenv, AssemblyBuilder mgbuf, FSharpOption`1<FSharpList`1<Attrib>> mainInfoOpt, IlxGenEnv eenv, CheckedImplFileAfterOptimization implFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenForceWholeFileInitializationAsPartOfCCtor(cenv cenv, AssemblyBuilder mgbuf, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, ILTypeRef tref, FSharpOption`1<ILDebugImports> imports, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodDef GenEqualsOverrideCallingIComparable(cenv cenv, EntityRef tcref, ILType ilThisTy, f _ilThatTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldInit GenFieldInit(Range m, Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILParameter> GenWitnessParams(cenv cenv, IlxGenEnv eenv, Range m, FSharpList`1<TraitWitnessInfo> witnessInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<ILMethodDef>, FSharpList`1<ILPropertyDef>, FSharpList`1<ILEventDef>> GenAbstractBinding(cenv cenv, IlxGenEnv eenv, ILTypeRef tref, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILMethodDef> GenToStringMethod(cenv cenv, IlxGenEnv eenv, ILType ilThisTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ILMethodDef> GenPrintingMethod(cenv cenv, IlxGenEnv eenv, string methName, ILType ilThisTy, Range m);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ILAttribute> defaultMemberAttrs$cont@10632(TcGlobals g, ValRef vref, string name, FSharpOption`1<ValMemberInfo> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<ILMethodDef> methodDefs$cont@10903(IlxGenEnv eenv, TcGlobals g, ILType ilThisTy, bool isStatic, bool isPropHidden, ILType ilPropType, string ilFieldName, RecdField fspec, Unit unitVar);
    internal static void validateExplicit@11239(Range m, ILTypeDef tdef, ILFieldDef fdef);
    internal static void validateSequential@11252(Range m, ILFieldDef fdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenTypeDef(cenv cenv, AssemblyBuilder mgbuf, List`1<FSharpFunc`2<ILFieldSpec, FSharpFunc`2<FSharpList`1<ILInstr>, FSharpFunc`2<FSharpList`1<ILInstr>, Unit>>>> lazyInitInfo, IlxGenEnv eenv, Range m, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void GenExnDef(cenv cenv, AssemblyBuilder mgbuf, IlxGenEnv eenv, Range m, Entity exnc);
    [CompilerGeneratedAttribute]
internal static void f@432-17(FSharpFunc`2[] genMeths);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CodegenAssembly(cenv cenv, IlxGenEnv eenv, AssemblyBuilder mgbuf, FSharpList`1<CheckedImplFileAfterOptimization> implFiles);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IlxGenEnv GetEmptyIlxGenEnv(TcGlobals g, CcuThunk ccu);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`2<FSharpList`1<ILTypeRef>, Byte[]>> GenerateResourcesForQuotations$cont@11656(FSharpList`1<Tuple`2<Tuple`2<string, Val>, Expr>> reflectedDefinitions, cenv cenv, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<FSharpList`1<ILTypeRef>, Byte[]>> GenerateResourcesForQuotations(FSharpList`1<Tuple`2<Tuple`2<string, Val>, Expr>> reflectedDefinitions, cenv cenv);
    internal static IlxGenResults GenerateCode(cenv cenv, AnonTypeGenerationTable anonTypeTable, IlxGenEnv eenv, CheckedAssemblyAfterOptimization _arg1, FSharpList`1<Attrib> assemAttribs, FSharpList`1<Attrib> moduleAttribs);
    internal static FSharpFunc`2<Type, object> get_defaultOf();
    internal static Lazy`1<MethodInfo> get_gminfo@11761();
    internal static Type objTyp@11777(cenv cenv, ExecutionContext ctxt, Val v, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<object, Type>> LookupGeneratedValue(cenv cenv, ExecutionContext ctxt, IlxGenEnv eenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SetGeneratedValue(ExecutionContext ctxt, IlxGenEnv eenv, bool isForced, Val v, object value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ClearGeneratedValue(ExecutionContext ctxt, IlxGenEnv eenv, Val v);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.IlxGenSupport : object {
    internal static ILMethodDef mkLdfldMethodDef(string ilMethName, ILMemberAccess iLAccess, bool isStatic, ILType ilTy, string ilFieldName, ILType ilPropType, FSharpList`1<ILAttribute> customAttrs);
    internal static ILAttribute mkFlagsAttribute(TcGlobals g);
    internal static ILTypeDef mkLocalPrivateAttributeWithDefaultConstructor(TcGlobals g, string name);
    internal static ILPropertyDef mkILNonGenericInstanceProperty(string name, ILType ilType, PropertyAttributes propertyAttribute, ILAttributes customAttributes, FSharpOption`1<ILMethodRef> getMethod, FSharpOption`1<ILMethodRef> setMethod);
    internal static ILTypeDef mkLocalPrivateAttributeWithPropertyConstructors(TcGlobals g, string name, FSharpOption`1<FSharpList`1<Tuple`2<string, ILType>>> attrProperties);
    internal static ILTypeDef mkLocalPrivateInt32Enum(TcGlobals g, ILTypeRef tref, Tuple`2[] values);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute getPotentiallyEmbedableAttribute(TcGlobals g, BuiltinAttribInfo info);
    internal static ILAttribute GetReadOnlyAttribute(TcGlobals g);
    internal static ILAttribute GetIsUnmanagedAttribute(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ILAttribute> GenReadOnlyAttributeIfNecessary(TcGlobals g, TType ty);
    internal static ILType GetDynamicallyAccessedMemberTypes(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute GetDynamicDependencyAttribute(TcGlobals g, int memberTypes, ILType ilType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType GenReadOnlyModReqIfNecessary(TcGlobals g, TType ty, ILType ilTy);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Import : object {
    internal static bool isResolved@71(ImportMap env, Range m, ILAssemblyRef assemblyRef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanImportILScopeRef(ImportMap env, Range m, ILScopeRef scoref);
    internal static CcuResolutionResult findCcu@89(ImportMap env, Range m, ILAssemblyRef assemblyRef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ImportTypeRefData(ImportMap env, Range m, ILScopeRef scoref, String[] path, string typeName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ImportILTypeRefUncached(ImportMap env, Range m, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ImportILTypeRef(ImportMap env, Range m, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanImportILTypeRef(ImportMap env, Range m, ILTypeRef tref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportILType(ImportMap env, Range m, FSharpList`1<TType> tinst, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanImportILType(ImportMap env, Range m, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ImportProvidedNamedType(ImportMap env, Range m, Tainted`1<ProvidedType> st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType ImportProvidedTypeAsILType(ImportMap env, Range m, Tainted`1<ProvidedType> st);
    internal static Measure conv@344-2(Range m, TcGlobals g, Typar tp, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportProvidedType(ImportMap env, Range m, Tainted`1<ProvidedType> st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodRef ImportProvidedMethodBaseAsILMethodRef(ImportMap env, Range m, Tainted`1<ProvidedMethodBase> mbase);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> ImportILGenericParameters(FSharpFunc`2<Unit, ImportMap> amap, Range m, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<ILGenericParameterDef> gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> multisetDiscriminateAndMap(FSharpFunc`2<Key, FSharpFunc`2<FSharpList`1<Tuple`2<FSharpList`1<Key>, Value>>, a>> nodef, FSharpFunc`2<Value, a> tipf, FSharpList`1<Tuple`2<FSharpList`1<Key>, Value>> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity ImportILTypeDef(FSharpFunc`2<Unit, ImportMap> amap, Range m, ILScopeRef scoref, CompilationPath cpath, FSharpList`1<ILTypeDef> enc, string nm, ILTypeDef tdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType ImportILTypeDefList(FSharpFunc`2<Unit, ImportMap> amap, Range m, CompilationPath cpath, FSharpList`1<ILTypeDef> enc, FSharpList`1<Tuple`2<FSharpList`1<string>, Tuple`2<string, Lazy`1<Tuple`2<ILScopeRef, ILPreTypeDef>>>>> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType ImportILTypeDefs(FSharpFunc`2<Unit, ImportMap> amap, Range m, ILScopeRef scoref, CompilationPath cpath, FSharpList`1<ILTypeDef> enc, ILTypeDefs tdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType ImportILAssemblyMainTypeDefs(FSharpFunc`2<Unit, ImportMap> amap, Range m, ILScopeRef scoref, ILModuleDef modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ModuleOrNamespaceType> ImportILAssemblyExportedType(FSharpFunc`2<Unit, ImportMap> amap, Range m, FSharpFunc`2<ILScopeRef, ILModuleDef> auxModLoader, ILScopeRef scoref, ILExportedTypeOrForwarder exportedType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ModuleOrNamespaceType> ImportILAssemblyExportedTypes(FSharpFunc`2<Unit, ImportMap> amap, Range m, FSharpFunc`2<ILScopeRef, ILModuleDef> auxModLoader, ILScopeRef scoref, ILExportedTypesAndForwarders exportedTypes);
    internal static ModuleOrNamespaceType ImportILAssemblyTypeDefs(FSharpFunc`2<Unit, ImportMap> amap, Range m, FSharpFunc`2<ILScopeRef, ILModuleDef> auxModLoader, ILAssemblyRef aref, ILModuleDef mainmod);
    internal static CcuTypeForwarderTree addToTree@607(CcuTypeForwarderTree tree, FSharpList`1<string> path, string item, Lazy`1<EntityRef> value);
    internal static CcuTypeForwarderTree mkTreeWith@622(FSharpList`1<string> path, string item, Lazy`1<EntityRef> value);
    internal static FSharpFunc`2<CcuTypeForwarderTree, CcuTypeForwarderTree> addNested@636(Range m, FSharpFunc`2<Unit, ImportMap> amap, ILExportedTypeOrForwarder exportedType, ILNestedExportedTypes nets, FSharpList`1<string> enc);
    internal static CcuTypeForwarderTable ImportILAssemblyTypeForwarders(FSharpFunc`2<Unit, ImportMap> amap, Range m, ILExportedTypesAndForwarders exportedTypes);
    internal static CcuThunk ImportILAssembly(FSharpFunc`2<Unit, ImportMap> amap, Range m, FSharpFunc`2<ILScopeRef, ILModuleDef> auxModuleLoader, FSharpOption`1<IXmlDocumentationInfoLoader> xmlDocInfoLoader, ILScopeRef ilScopeRef, string sourceDir, FSharpOption`1<string> fileName, ILModuleDef ilModule, IEvent`2<FSharpHandler`1<string>, string> invalidateCcu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType RescopeAndImportILType(ILScopeRef scoref, ImportMap amap, Range m, FSharpList`1<TType> importInst, ILType ilTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanRescopeAndImportILType(ILScopeRef scoref, ImportMap amap, Range m, ILType ilTy);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.InfoReader : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> SelectImmediateMemberVals(TcGlobals g, FSharpOption`1<string> optFilter, FSharpFunc`2<ValMemberInfo, FSharpFunc`2<ValRef, FSharpOption`1<a>>> f, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkFilter(FSharpOption`1<string> optFilter, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethInfo> TrySelectMemberVal(TcGlobals g, FSharpOption`1<string> optFilter, TType ty, FSharpOption`1<ulong> pri, a _membInfo, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetImmediateIntrinsicMethInfosOfTypeAux(FSharpOption`1<string> optFilter, AccessorDomain ad, TcGlobals g, ImportMap amap, Range m, TType origTy, TType metadataTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetImmediateIntrinsicMethInfosOfType(FSharpOption`1<string> optFilter, AccessorDomain ad, TcGlobals g, ImportMap amap, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TraitConstraintInfo> GetImmediateTraitsInfosOfType(FSharpOption`1<string> optFilter, TcGlobals g, TType ty);
    [CompilerGeneratedAttribute]
internal static int hasher@1(PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> GetImmediateIntrinsicPropInfosOfTypeAux(FSharpOption`1<string> optFilter, AccessorDomain ad, TcGlobals g, ImportMap amap, Range m, TType origTy, TType metadataTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> GetImmediateIntrinsicPropInfosOfType(FSharpOption`1<string> optFilter, AccessorDomain ad, TcGlobals g, ImportMap amap, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsIndexerType(TcGlobals g, ImportMap amap, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> GetMostSpecificItemsByType(TcGlobals g, ImportMap amap, FSharpFunc`2<a, FSharpOption`1<Tuple`2<TType, Range>>> f, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TType, MethInfo>> GetMostSpecificMethodInfosByMethInfoSig(TcGlobals g, ImportMap amap, Range m, TType ty, MethInfo minfo, FSharpList`1<Tuple`2<TType, MethInfo>> minfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, FSharpList`1<Tuple`2<TType, MethInfo>>> FilterMostSpecificMethInfoSets(TcGlobals g, ImportMap amap, Range m, FSharpMap`2<string, FSharpList`1<Tuple`2<TType, MethInfo>>> minfoSets);
    internal static IndexedList`1<a> loop@540-50(FSharpFunc`2<a, string> nmf, FSharpFunc`2<a, FSharpFunc`2<a, bool>> keepTest, FSharpList`1<FSharpList`1<a>> itemLists);
    internal static FSharpList`1<FSharpList`1<a>> loop@551-51(FSharpFunc`2<a, string> nmf, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<a>, bool>> keepTest, FSharpList`1<FSharpList`1<a>> itemLists, IndexedList`1<a> indexedItemsInSubTypes);
    internal static bool equivVirts@566(FSharpFunc`2<a, bool> isVirt, FSharpFunc`2<a, FSharpFunc`2<a, bool>> equivSigs, a x, a y);
    internal static FSharpFunc`2<a, bool> equivNewSlots@593(FSharpFunc`2<a, bool> isNewSlot, FSharpFunc`2<a, FSharpFunc`2<a, bool>> equivSigs, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkLanguageFeatureRuntimeAndRecover(InfoReader infoReader, LanguageFeature langFeature, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetIntrinsicConstructorInfosOfType(InfoReader infoReader, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> ExcludeHiddenOfMethInfos(TcGlobals g, ImportMap amap, Range m, FSharpList`1<FSharpList`1<MethInfo>> minfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> ExcludeHiddenOfPropInfos(TcGlobals g, ImportMap amap, Range m, FSharpList`1<FSharpList`1<PropInfo>> pinfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<MethInfo>> GetIntrinsicMethInfoSetsOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<PropInfo>> GetIntrinsicPropInfoSetsOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> GetIntrinsicMethInfosOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> GetIntrinsicPropInfosOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<HierarchyItem> TryFindIntrinsicNamedItemOfType(InfoReader infoReader, string nm, AccessorDomain ad, bool includeConstraints, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> TryFindIntrinsicMethInfo(InfoReader infoReader, Range m, AccessorDomain ad, string nm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> TryFindIntrinsicPropInfo(InfoReader infoReader, Range m, AccessorDomain ad, string nm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, FSharpList`1<Tuple`2<TType, MethInfo>>> GetIntrinisicMostSpecificOverrideMethInfoSetsOfType(InfoReader infoReader, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SigOfFunctionForDelegate GetSigOfFunctionForDelegate(InfoReader infoReader, TType delTy, Range m, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TType, TType>> TryDestStandardDelegateType(InfoReader infoReader, Range m, AccessorDomain ad, TType delTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsStandardEventInfo(InfoReader infoReader, Range m, AccessorDomain ad, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ArgsTypeOfEventInfo(InfoReader infoReader, Range m, AccessorDomain ad, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType PropTypeOfEventInfo(InfoReader infoReader, Range m, AccessorDomain ad, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<FSharpOption`1<string>, FSharpList`1<Typar>, ILTypeInfo>> TryFindMetadataInfoOfExternalEntityRef(InfoReader infoReader, Range m, EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<XmlDoc> TryFindXmlDocByAssemblyNameAndSig(InfoReader infoReader, string assemblyName, string xmlDocSig);
    internal static FSharpOption`1<string> libFileOfEntityRef(EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfEntityRef(InfoReader infoReader, Range m, EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfScopedValRef(TcGlobals g, EntityRef tcref, ValRef vref);
    internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfRecdFieldRef(RecdFieldRef rfref);
    internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfUnionCaseRef(UnionCaseRef ucref);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfMethInfo$cont@1138(InfoReader infoReader, Range m, MethInfo minfo, ImportMap amap, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfMethInfo(InfoReader infoReader, Range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfProp(InfoReader infoReader, Range m, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfEvent(InfoReader infoReader, Range m, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> GetXmlDocSigOfILFieldInfo(InfoReader infoReader, Range m, ILFieldInfo finfo);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Infos : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.IsFSharpEventProperty(ValRef x, TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.get_IsVirtualMember(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.get_IsDispatchSlotMember(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.get_IsDefiniteFSharpOverrideMember(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.IsFSharpExplicitInterfaceImplementation(ValRef vref, TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<SlotSig> ValRef.get_ImplementedSlotSignatures(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> GetCompiledReturnTyOfProvidedMethodInfo(ImportMap amap, Range m, Tainted`1<ProvidedMethodBase> mi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig ReparentSlotSigToUseMethodTypars(TcGlobals g, Range m, ValRef ovByMethValRef, SlotSig slotsig);
    internal static SlotParam MakeSlotParam(TType ty, ArgReprInfo argInfo);
    internal static SlotSig MakeSlotSig(string nm, TType ty, FSharpList`1<Typar> ctps, FSharpList`1<Typar> mtps, FSharpList`1<FSharpList`1<SlotParam>> paraml, FSharpOption`1<TType> retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpOption`1<TType>, FSharpList`1<TType>> AnalyzeTypeOfMemberVal(bool isCSharpExt, TcGlobals g, TType ty, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GetObjTypeOfInstanceExtensionMethod(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> GetArgInfosOfMember(bool isCSharpExt, TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> GetInstantiationForMemberVal(TcGlobals g, bool isCSharpExt, TType ty, ValRef vref, FSharpList`1<TType> methTyArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> GetInstantiationForPropertyVal(TcGlobals g, TType ty, ValRef vref);
    internal static bool HasExternalInit(ILMethodRef mref);
    internal static OptionalArgCallerSideValue analyze@205(TcGlobals g, ILParameter ilParam, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParamAttribs CrackParamAttribsInfo(TcGlobals g, TType ty, ArgReprInfo argInfo);
    [CompilerGeneratedAttribute]
internal static ILFieldInit FromProvidedObj$cont@349(Range m, object v, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldInit ILFieldInit.FromProvidedObj.Static(Range m, object v);
    internal static OptionalArgCallerSideValue analyze@379-1(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OptionalArgInfo OptionalArgInfoOfProvidedParameter(ImportMap amap, Range m, Tainted`1<ProvidedParameterInfo> provParam);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tainted`1<ProvidedMethodBase> GetAndSanityCheckProviderMethod(Range m, Tainted`1<T> mi, FSharpFunc`2<T, ProvidedMethodInfo> get, FSharpFunc`2<Tuple`2<string, string>, Tuple`2<int, string>> err);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tainted`1<ProvidedMethodBase> ArbitraryMethodInfoOfPropertyInfo(Tainted`1<ProvidedPropertyInfo> pi, Range m);
    internal static ParamNameAndType func1@1-8(TType tupledArg0, ArgReprInfo tupledArg1);
    internal static bool optVrefEq@2000(TcGlobals g, FSharpOption`1<ValRef> _arg10, FSharpOption`1<ValRef> _arg11);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyConformsToIDelegateEvent(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception nonStandardEventError(string nm, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType FindDelegateTypeOfPropertyEvent(TcGlobals g, ImportMap amap, string nm, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CompiledSig CompiledSigOfMeth(TcGlobals g, ImportMap amap, Range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfosEquivByPartialSig(Erasure erasureFlag, bool ignoreFinal, TcGlobals g, ImportMap amap, Range m, MethInfo minfo, MethInfo minfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfosEquivByNameAndPartialSig(Erasure erasureFlag, bool ignoreFinal, TcGlobals g, ImportMap amap, Range m, MethInfo minfo, MethInfo minfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PropInfosEquivByNameAndPartialSig(Erasure erasureFlag, TcGlobals g, ImportMap amap, Range m, PropInfo pinfo, PropInfo pinfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MethInfosEquivByNameAndSig(Erasure erasureFlag, bool ignoreFinal, TcGlobals g, ImportMap amap, Range m, MethInfo minfo, MethInfo minfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool PropInfosEquivByNameAndSig(Erasure erasureFlag, TcGlobals g, ImportMap amap, Range m, PropInfo pinfo, PropInfo pinfo2);
    internal static FSharpList`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> SettersOfPropInfos(FSharpList`1<PropInfo> pinfos);
    internal static FSharpList`1<Tuple`2<MethInfo, FSharpOption`1<PropInfo>>> GettersOfPropInfos(FSharpList`1<PropInfo> pinfos);
    internal static FSharpOption`1<Tuple`2<ValRef, ValRef>> |DifferentGetterAndSetter|_|(PropInfo pinfo);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.InnerLambdasToTopLevelFuncs : object {
    internal static bool verboseTLR { get; }
    [CompilationMappingAttribute("9")]
internal static int InnerLambdasToTopLevelFunctionsStackGuardDepth { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<BindingGroupSharingSameReqdItems> fclassOrder { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<ReqdItem> reqdItemOrder { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_verboseTLR();
    internal static int get_InnerLambdasToTopLevelFunctionsStackGuardDepth();
    internal static a internalError(string str);
    internal static FSharpList`1<b> collect@51-3(Tree`1<b> tr, FSharpList`1<b> acc);
    internal static FSharpList`1<a> fringeTR(Tree`1<a> tr);
    internal static Tuple`5<Expr, TType, FSharpList`1<TType>, a, b> destApp(Expr f, TType fty, FSharpList`1<TType> tys, a args, b m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDelayedRepr(Val f, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val mkLocalNameTypeArity(bool compgen, Range m, string name, TType ty, FSharpOption`1<ValReprInfo> valReprInfo);
    internal static Set`2<Val, IComparer`1<Val>> GetValsBoundUnderMustInline(Results xinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsRefusedTLR(TcGlobals g, Val f);
    internal static bool IsMandatoryTopLevel(Val f);
    internal static IComparer`1<BindingGroupSharingSameReqdItems> get_fclassOrder();
    internal static IComparer`1<ReqdItem> get_reqdItemOrder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsArityMet(ValRef vref, int wf, FSharpList`1<TType> tys, FSharpList`1<a> args);
    internal static Map`3<Val, Val, IComparer`1<Val>> carrierMapFor@702(Map`3<Val, BindingGroupSharingSameReqdItems, IComparer`1<Val>> fclassM, Map`3<BindingGroupSharingSameReqdItems, Map`3<Val, Val, IComparer`1<Val>>, IComparer`1<BindingGroupSharingSameReqdItems>> carrierMaps, Val f);
    internal static Expr aenvExprFor@754(ReqdItemsForDefn env, Map`3<Val, Val, IComparer`1<Val>> cmap, Val v);
    internal static FSharpFunc`2<BindingGroupSharingSameReqdItems, Tuple`2<Tuple`2<BindingGroupSharingSameReqdItems, PackedReqdItems>, Map`3<BindingGroupSharingSameReqdItems, Map`3<Val, Val, IComparer`1<Val>>, IComparer`1<BindingGroupSharingSameReqdItems>>>> packEnv@697(TcGlobals g, Map`3<Val, BindingGroupSharingSameReqdItems, IComparer`1<Val>> fclassM, Set`2<Val, IComparer`1<Val>> topValS, Map`3<BindingGroupSharingSameReqdItems, ReqdItemsForDefn, IComparer`1<BindingGroupSharingSameReqdItems>> reqdItemsMap, Map`3<BindingGroupSharingSameReqdItems, Map`3<Val, Val, IComparer`1<Val>>, IComparer`1<BindingGroupSharingSameReqdItems>> carrierMaps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<BindingGroupSharingSameReqdItems, PackedReqdItems, IComparer`1<BindingGroupSharingSameReqdItems>> FlatEnvPacks(TcGlobals g, Map`3<Val, BindingGroupSharingSameReqdItems, IComparer`1<Val>> fclassM, Set`2<Val, IComparer`1<Val>> topValS, FSharpList`1<a> declist, Map`3<BindingGroupSharingSameReqdItems, ReqdItemsForDefn, IComparer`1<BindingGroupSharingSameReqdItems>> reqdItemsMap);
    internal static Val createFHat@819(TcGlobals g, Map`3<Val, int, IComparer`1<Val>> arityM, Map`3<Val, a, IComparer`1<Val>> fclassM, Map`3<a, PackedReqdItems, IComparer`1<a>> envPackM, Val f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Val, Val, IComparer`1<Val>> CreateNewValuesForTLR(TcGlobals g, Set`2<Val, IComparer`1<Val>> tlrS, Map`3<Val, int, IComparer`1<Val>> arityM, Map`3<Val, a, IComparer`1<Val>> fclassM, Map`3<a, PackedReqdItems, IComparer`1<a>> envPackM);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CheckedImplFile MakeTopLevelRepresentationDecisions(CcuThunk ccu, TcGlobals g, CheckedImplFile expr);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Interactive.ControlledExecution : object {
    internal bool isInteractive;
    internal FSharpValueOption`1<CancellationTokenSource> cts;
    internal FSharpValueOption`1<Thread> thread;
    internal static FSharpOption`1<MethodInfo> ceRun;
    internal static FSharpOption`1<MethodInfo> threadResetAbort;
    internal static int init@19;
    public ControlledExecution(bool isInteractive);
    private static ControlledExecution();
    internal void Run(Action action);
    internal void TryAbort();
    internal void ResetAbort();
    internal static Exception StripTargetInvocationException(Exception exn);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Interactive.CtrlBreakHandlers : object {
    internal static string interuptCommand { get; }
    [CompilationMappingAttribute("9")]
internal static Byte[] lineInteruptCommand { get; }
    internal static int connectionTimeout { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_interuptCommand();
    internal static Byte[] get_lineInteruptCommand();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_connectionTimeout();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Interactive.Shell : object {
    [CompilationMappingAttribute("9")]
internal static Lazy`1<string> scriptingSymbolsPath { get; }
    [CompilationMappingAttribute("9")]
internal static string path@1676-5 { get; }
    [CompilationMappingAttribute("9")]
internal static AppDomain eventTarget@1700 { get; }
    internal static string dynamicCcuName { get; }
    internal static Layout makeListL@609(FSharpList`1<Layout> itemLs);
    internal static string prune@823(string text);
    [CompilerGeneratedAttribute]
internal static void f@139-25(FsiStdinSyphon syphon, TcConfig tcConfig, PhasedDiagnostic diagnostic, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void DiagnosticsLogger.AbortOnError(DiagnosticsLogger x, FsiConsoleOutput fsiConsoleOutput);
    internal static string directoryName(string s);
    internal static string getFsiCommandLine@984(Unit unitVar0);
    internal static IDisposable SetCurrentUICultureForThread(FSharpOption`1<int> lcid);
    internal static void InstallErrorLoggingOnThisThread(DiagnosticsLogger diagnosticsLogger);
    internal static void SetServerCodePages(FsiCommandLineOptions fsiOptions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a WithImplicitHome(TcConfigBuilder tcConfigB, string dir, FSharpFunc`2<Unit, a> f);
    internal static ILTypeRef ConvReflectionTypeToILTypeRef(Type reflectionTy);
    internal static Type get@1577-2(Type typ);
    internal static FSharpList`1<ILType> ConvReflectionTypeToILType(Type reflectionTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Entity, Val, CheckedImplFile> mkBoundValueTypedImpl(TcGlobals tcGlobals, Range m, string moduleName, string name, TType ty);
    internal static Lazy`1<string> get_scriptingSymbolsPath();
    internal static string get_path@1676-5();
    internal static void deleteScriptingSymbols();
    internal static AppDomain get_eventTarget@1700();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_dynamicCcuName();
    internal static string getName@2414-1(bool useFullName, AssemblyName assemblyName);
    internal static SynBinding mkBind@2559(Range m, SynPat pat, SynExpr expr);
    internal static FSharpList`1<ILMethodRef> loop@1881-104(ILScopeRef ilScopeRef, FSharpList`1<ILTypeDef> enc, ILTypeDef tdef);
    [CompilerGeneratedAttribute]
internal static void f@2042-26(FsiDynamicCompiler this, DiagnosticsLogger diagnosticsLogger, FSharpRef`1<FSharpList`1<FSharpFunc`2<Unit, FSharpOption`1<Exception>>>> execs, Unit unitVar0);
    internal static FSharpOption`1<Tuple`2<string, Attrib>> tryGetEntryPoint@2153(TcGlobals tcGlobals, Binding _arg1);
    internal static FSharpOption`1<Tuple`2<string, Attrib>> findEntryPointInContents@2157(TcGlobals tcGlobals, FSharpFunc`2<ModuleOrNamespaceBinding, FSharpOption`1<Tuple`2<string, Attrib>>> findEntryPointInBinding, ModuleOrNamespaceContents _arg2);
    internal static Tuple`2<FSharpList`1<ImportedAssembly>, TType> import@2355(TcImports tcImports, TcGlobals tcGlobals, ImportMap amap, FSharpList`1<ImportedAssembly> ccuinfos, ILType ilTy);
    internal static Tuple`2<FsiDynamicCompilerState, TType> addTypeToEnvironment@2379(FsiDynamicCompiler this, Type reflectionTy, TcImports tcImports, TcGlobals tcGlobals, ImportMap amap, FSharpList`1<ImportedAssembly> prevCcuinfos, FsiDynamicCompilerState state, ILType ilTy);
    internal static void raiseCtrlC@3157(FsiInterruptController controller, int pauseMilliseconds, Unit unitVar0);
    internal static Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus> run@4160-1(FsiInteractionProcessor processor, DiagnosticsLogger diagnosticsLogger, CompilationThreadToken ctok, LexFilter tokenizer, FsiDynamicCompilerState istate);
    internal static FsiDynamicCompilerState consume@4184-1(FsiInteractionProcessor processor, DiagnosticsLogger diagnosticsLogger, CompilationThreadToken ctok, FsiDynamicCompilerState istate, FSharpList`1<Tuple`2<string, bool>> sourceFiles);
    internal static void loop@4315-105(FsiInteractionProcessor processor, DiagnosticsLogger diagnosticsLogger, FSharpFunc`2<FSharpFunc`2<CompilationThreadToken, FSharpFunc`2<FsiDynamicCompilerState, Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus>>>, FSharpFunc`2<FsiDynamicCompilerState, Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus>>> runCodeOnMainThread, LexFilter currTokenizer);
    internal static FSharpFunc`2<a, token> lexerWhichSavesLastToken@3706(LexFilter tokenizer, FSharpRef`1<token> lastToken);
    internal static Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus> loop@3853-106(FsiInteractionProcessor this, DiagnosticsLogger diagnosticsLogger, CompilationThreadToken ctok, FsiDynamicCompilerState istate, InteractionGroup action);
    internal static Tuple`2<FsiDynamicCompilerState, FsiInteractionStepStatus> loop@4002-109(FsiInteractionProcessor this, DiagnosticsLogger diagnosticsLogger, CompilationThreadToken ctok, FSharpOption`1<FsiValue> lastResult, FsiDynamicCompilerState istate);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void SpawnThread(string name, FSharpFunc`2<Unit, Unit> f);
    internal static void SpawnInteractiveServer(FsiEvaluationSessionHostConfig fsi, FsiCommandLineOptions fsiOptions, FsiConsoleOutput fsiConsoleOutput);
    internal static void runLoop@4434(FsiInterruptController fsiInterruptController, FsiConsoleOutput fsiConsoleOutput, FsiEvaluationSessionHostConfig fsi, Unit unitVar0);
    internal static void DriveFsiEventLoop(FsiEvaluationSessionHostConfig fsi, FsiInterruptController fsiInterruptController, FsiConsoleOutput fsiConsoleOutput);
    internal static Byte[] loop@5149-110(CompilerInputStream this, int count, Unit unitVar0);
}
[DefaultMemberAttribute("Item")]
[ExperimentalAttribute("This FCS API/Type is experimental and subject to change.")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.IO.ByteArrayMemory : ByteMemory {
    internal int offset;
    internal int length;
    internal Byte[] bytes;
    public byte Item { get; public set; }
    public int Length { get; }
    public ByteArrayMemory(Byte[] bytes, int offset, int length);
    public virtual byte get_Item(int i);
    public virtual void set_Item(int i, byte v);
    public virtual int get_Length();
    public virtual Byte[] ReadAllBytes();
    public virtual Byte[] ReadBytes(int pos, int count);
    public virtual int ReadInt32(int pos);
    public virtual ushort ReadUInt16(int pos);
    public virtual string ReadUtf8String(int pos, int count);
    public virtual ByteMemory Slice(int pos, int count);
    public virtual void CopyTo(Stream stream);
    public virtual void Copy(int srcOffset, Byte[] dest, int destOffset, int count);
    public virtual Byte[] ToArray();
    public virtual Stream AsStream();
    public virtual Stream AsReadOnlyStream();
    [CompilerGeneratedAttribute]
internal void checkCount(int count);
}
[SealedAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.IO.ByteBuffer : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool useArrayPool@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool isDisposed@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Byte[] bbArray@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int bbCurrent@;
    [CompilationMappingAttribute("4", "0")]
internal bool useArrayPool { get; }
    [CompilationMappingAttribute("4", "1")]
internal bool isDisposed { get; internal set; }
    [CompilationMappingAttribute("4", "2")]
internal Byte[] bbArray { get; internal set; }
    [CompilationMappingAttribute("4", "3")]
internal int bbCurrent { get; internal set; }
    internal int Position { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.IO.ByteBuffer")]
internal ByteBuffer(bool useArrayPool, bool isDisposed, Byte[] bbArray, int bbCurrent);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_useArrayPool();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_isDisposed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Byte[] get_bbArray();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_bbCurrent();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void set_isDisposed(bool value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void set_bbArray(Byte[] value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void set_bbCurrent(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ByteBuffer obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal void CheckDisposed();
    internal void Ensure(int newSize);
    internal ReadOnlyMemory`1<byte> AsMemory();
    internal void EmitIntAsByte(int i);
    internal void EmitByte(byte b);
    internal void EmitIntsAsBytes(Int32[] arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal void FixupInt32(int pos, int value);
    internal void EmitInt32(int n);
    internal void EmitBytes(Byte[] i);
    internal void EmitMemory(ReadOnlyMemory`1<byte> i);
    internal void EmitByteMemory(ReadOnlyByteMemory i);
    internal void EmitInt32AsUInt16(int n);
    internal void EmitBoolAsByte(bool b);
    internal void EmitUInt16(ushort x);
    internal void EmitInt64(long x);
    internal int get_Position();
    internal static ByteBuffer Create(int capacity, FSharpOption`1<bool> useArrayPool);
    private virtual override void System.IDisposable.Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ByteBuffer obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DefaultMemberAttribute("Item")]
[AbstractClassAttribute]
[ExperimentalAttribute("This FCS API/Type is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
public abstract class FSharp.Compiler.IO.ByteMemory : object {
    public byte Item { get; public set; }
    public int Length { get; }
    public static ByteMemory Empty { get; }
    public abstract virtual byte get_Item(int );
    public abstract virtual void set_Item(int , byte );
    public abstract virtual int get_Length();
    public abstract virtual Byte[] ReadAllBytes();
    public abstract virtual Byte[] ReadBytes(int pos, int count);
    public abstract virtual int ReadInt32(int pos);
    public abstract virtual ushort ReadUInt16(int pos);
    public abstract virtual string ReadUtf8String(int pos, int count);
    public abstract virtual ByteMemory Slice(int pos, int count);
    public abstract virtual void CopyTo(Stream );
    public abstract virtual void Copy(int srcOffset, Byte[] dest, int destOffset, int count);
    public abstract virtual Byte[] ToArray();
    public abstract virtual Stream AsStream();
    public abstract virtual Stream AsReadOnlyStream();
    public ReadOnlyByteMemory AsReadOnly();
    public static ByteMemory get_Empty();
    public static ByteMemory FromMemoryMappedFile(MemoryMappedFile mmf);
    public static ByteMemory FromUnsafePointer(IntPtr addr, int length, object holder);
    public static ByteMemory FromArray(Byte[] bytes, int offset, int length);
    public static ByteMemory FromArray(Byte[] bytes);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.IO.Bytes : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int get(Byte[] b, int n);
    internal static Byte[] zeroCreate(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void blit(Byte[] a, int b, Byte[] c, int d, int e);
    internal static Byte[] ofInt32Array(Int32[] arr);
    internal static Byte[] stringAsUtf8NullTerminated(string s);
    internal static Byte[] stringAsUnicodeNullTerminated(string s);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.IO.ByteStorage : object {
    internal FSharpFunc`2<Unit, ReadOnlyByteMemory> getByteMemory;
    internal WeakReference`1<ByteMemory> cached;
    public ByteStorage(FSharpFunc`2<Unit, ReadOnlyByteMemory> getByteMemory);
    internal ReadOnlyByteMemory GetByteMemory();
    internal static ByteStorage FromByteArray(Byte[] bytes);
    internal static ByteStorage FromByteMemory(ReadOnlyByteMemory bytes);
    internal static ByteStorage FromByteMemoryAndCopy(ReadOnlyByteMemory bytes, bool useBackingMemoryMappedFile);
    internal static ByteStorage FromMemoryAndCopy(ReadOnlyMemory`1<byte> bytes, bool useBackingMemoryMappedFile);
    internal static ByteStorage FromByteArrayAndCopy(Byte[] bytes, bool useBackingMemoryMappedFile);
    [CompilerGeneratedAttribute]
internal ReadOnlyByteMemory getAndCache();
}
[SealedAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.IO.ByteStream : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ReadOnlyByteMemory bytes@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int pos@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int max@;
    [CompilationMappingAttribute("4", "0")]
internal ReadOnlyByteMemory bytes { get; }
    [CompilationMappingAttribute("4", "1")]
internal int pos { get; internal set; }
    [CompilationMappingAttribute("4", "2")]
internal int max { get; }
    internal bool IsEOF { get; }
    internal int Position { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.IO.ByteStream")]
internal ByteStream(ReadOnlyByteMemory bytes, int pos, int max);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ReadOnlyByteMemory get_bytes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_pos();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_max();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void set_pos(int value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal bool get_IsEOF();
    internal byte ReadByte();
    internal string ReadUtf8String(int n);
    internal static ByteStream FromBytes(ReadOnlyByteMemory b, int start, int length);
    internal ReadOnlyByteMemory ReadBytes(int n);
    internal int get_Position();
}
[ExperimentalAttribute("This FCS API/Type is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.IO.DefaultAssemblyLoader : object {
    private virtual override Assembly FSharp.Compiler.IO.IAssemblyLoader.AssemblyLoadFrom(string fileName);
    private virtual override Assembly FSharp.Compiler.IO.IAssemblyLoader.AssemblyLoad(AssemblyName assemblyName);
}
[ExperimentalAttribute("This FCS API/Type is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.IO.DefaultFileSystem : object {
    internal FSharpRef`1<DefaultFileSystem> this;
    internal int init@516;
    public IAssemblyLoader AssemblyLoader { get; }
    public virtual IAssemblyLoader get_AssemblyLoader();
    public virtual Stream OpenFileForReadShim(string filePath, FSharpOption`1<bool> useMemoryMappedFile, FSharpOption`1<bool> shouldShadowCopy);
    public virtual Stream OpenFileForWriteShim(string filePath, FSharpOption`1<FileMode> fileMode, FSharpOption`1<FileAccess> fileAccess, FSharpOption`1<FileShare> fileShare);
    public virtual string GetFullPathShim(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public virtual string GetFullFilePathInDirectoryShim(string dir, string fileName);
    public virtual bool IsPathRootedShim(string path);
    public virtual string NormalizePathShim(string path);
    public virtual bool IsInvalidPathShim(string path);
    public virtual string GetTempPathShim();
    public virtual string GetDirectoryNameShim(string path);
    public virtual DateTime GetLastWriteTimeShim(string fileName);
    public virtual DateTime GetCreationTimeShim(string path);
    public virtual void CopyShim(string src, string dest, bool overwrite);
    public virtual bool FileExistsShim(string fileName);
    public virtual void FileDeleteShim(string fileName);
    public virtual string DirectoryCreateShim(string path);
    public virtual bool DirectoryExistsShim(string path);
    public virtual void DirectoryDeleteShim(string path);
    public virtual IEnumerable`1<string> EnumerateFilesShim(string path, string pattern);
    public virtual IEnumerable`1<string> EnumerateDirectoriesShim(string path);
    public virtual bool IsStableFileHeuristic(string fileName);
    public virtual string ChangeExtensionShim(string path, string extension);
    private virtual override IAssemblyLoader FSharp.Compiler.IO.IFileSystem.get_AssemblyLoader();
    private virtual override Stream FSharp.Compiler.IO.IFileSystem.OpenFileForReadShim(string filePath, FSharpOption`1<bool> useMemoryMappedFile, FSharpOption`1<bool> shouldShadowCopy);
    private virtual override Stream FSharp.Compiler.IO.IFileSystem.OpenFileForWriteShim(string filePath, FSharpOption`1<FileMode> fileMode, FSharpOption`1<FileAccess> fileAccess, FSharpOption`1<FileShare> fileShare);
    private virtual override string FSharp.Compiler.IO.IFileSystem.GetFullPathShim(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private virtual override string FSharp.Compiler.IO.IFileSystem.GetFullFilePathInDirectoryShim(string dir, string fileName);
    private virtual override bool FSharp.Compiler.IO.IFileSystem.IsPathRootedShim(string path);
    private virtual override string FSharp.Compiler.IO.IFileSystem.NormalizePathShim(string path);
    private virtual override bool FSharp.Compiler.IO.IFileSystem.IsInvalidPathShim(string path);
    private virtual override string FSharp.Compiler.IO.IFileSystem.GetTempPathShim();
    private virtual override string FSharp.Compiler.IO.IFileSystem.GetDirectoryNameShim(string s);
    private virtual override DateTime FSharp.Compiler.IO.IFileSystem.GetLastWriteTimeShim(string fileName);
    private virtual override DateTime FSharp.Compiler.IO.IFileSystem.GetCreationTimeShim(string path);
    private virtual override void FSharp.Compiler.IO.IFileSystem.CopyShim(string src, string dest, bool overwrite);
    private virtual override bool FSharp.Compiler.IO.IFileSystem.FileExistsShim(string fileName);
    private virtual override void FSharp.Compiler.IO.IFileSystem.FileDeleteShim(string fileName);
    private virtual override string FSharp.Compiler.IO.IFileSystem.DirectoryCreateShim(string path);
    private virtual override bool FSharp.Compiler.IO.IFileSystem.DirectoryExistsShim(string path);
    private virtual override void FSharp.Compiler.IO.IFileSystem.DirectoryDeleteShim(string path);
    private virtual override IEnumerable`1<string> FSharp.Compiler.IO.IFileSystem.EnumerateFilesShim(string path, string pattern);
    private virtual override IEnumerable`1<string> FSharp.Compiler.IO.IFileSystem.EnumerateDirectoriesShim(string path);
    private virtual override bool FSharp.Compiler.IO.IFileSystem.IsStableFileHeuristic(string fileName);
    private virtual override string FSharp.Compiler.IO.IFileSystem.ChangeExtensionShim(string path, string extension);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.IO.FileSystemAutoOpens : object {
    [CompilationMappingAttribute("9")]
public static IFileSystem FileSystem { get; public set; }
    public static IFileSystem get_FileSystem();
    public static void set_FileSystem(IFileSystem value);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.IO.FileSystemUtils : object {
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> checkPathForIllegalChars { get; }
    [CompilationMappingAttribute("9")]
internal static HashSet`1<char> chars@401 { get; }
    internal static FSharpFunc`2<string, Unit> get_checkPathForIllegalChars();
    internal static HashSet`1<char> get_chars@401();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkSuffix(string path, string suffix);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool hasExtensionWithValidate(bool validate, string s);
    internal static bool hasExtension(string path);
    internal static string chopExtension(string path);
    internal static string fileNameOfPath(string path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string fileNameWithoutExtensionWithValidate(bool validate, string path);
    internal static string fileNameWithoutExtension(string path);
    internal static string trimQuotes(string path);
    internal static bool isDll(string fileName);
}
[ExperimentalAttribute("This FCS API/Type is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.IO.IAssemblyLoader {
    public abstract virtual Assembly AssemblyLoadFrom(string fileName);
    public abstract virtual Assembly AssemblyLoad(AssemblyName assemblyName);
}
[ExperimentalAttribute("This FCS API/Type is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.IO.IFileSystem {
    public IAssemblyLoader AssemblyLoader { get; }
    public abstract virtual IAssemblyLoader get_AssemblyLoader();
    public abstract virtual Stream OpenFileForReadShim(string filePath, FSharpOption`1<bool> useMemoryMappedFile, FSharpOption`1<bool> shouldShadowCopy);
    public abstract virtual Stream OpenFileForWriteShim(string filePath, FSharpOption`1<FileMode> fileMode, FSharpOption`1<FileAccess> fileAccess, FSharpOption`1<FileShare> fileShare);
    public abstract virtual string GetFullPathShim(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual string GetFullFilePathInDirectoryShim(string dir, string fileName);
    public abstract virtual bool IsPathRootedShim(string path);
    public abstract virtual string NormalizePathShim(string path);
    public abstract virtual bool IsInvalidPathShim(string path);
    public abstract virtual string GetTempPathShim();
    public abstract virtual string GetDirectoryNameShim(string path);
    public abstract virtual DateTime GetLastWriteTimeShim(string fileName);
    public abstract virtual DateTime GetCreationTimeShim(string path);
    public abstract virtual void CopyShim(string src, string dest, bool overwrite);
    public abstract virtual bool FileExistsShim(string fileName);
    public abstract virtual void FileDeleteShim(string fileName);
    public abstract virtual string DirectoryCreateShim(string path);
    public abstract virtual bool DirectoryExistsShim(string path);
    public abstract virtual void DirectoryDeleteShim(string path);
    public abstract virtual IEnumerable`1<string> EnumerateFilesShim(string path, string pattern);
    public abstract virtual IEnumerable`1<string> EnumerateDirectoriesShim(string path);
    public abstract virtual bool IsStableFileHeuristic(string fileName);
    public abstract virtual string ChangeExtensionShim(string path, string extension);
}
[CompilationMappingAttribute("5")]
internal class FSharp.Compiler.IO.IllegalFileNameChar : Exception {
    internal string Data0@;
    internal char Data1@;
    [CompilationMappingAttribute("4", "0")]
internal string Data0 { get; }
    [CompilationMappingAttribute("4", "1")]
internal char Data1 { get; }
    internal IllegalFileNameChar(string data0, char data1);
    protected IllegalFileNameChar(SerializationInfo info, StreamingContext context);
    internal string get_Data0();
    internal char get_Data1();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.IO.MemoryMappedFileExtensions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MemoryMappedFile> trymmf(long length, FSharpFunc`2<MemoryMappedViewStream, Unit> copyTo);
    internal static FSharpOption`1<MemoryMappedFile> MemoryMappedFile.TryFromByteMemory.Static(ReadOnlyByteMemory bytes);
    internal static FSharpOption`1<MemoryMappedFile> MemoryMappedFile.TryFromMemory.Static(ReadOnlyMemory`1<byte> bytes);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.IO.MemoryMappedStream : Stream {
    internal MemoryMappedFile mmf;
    internal MemoryMappedViewStream viewStream;
    internal MemoryMappedViewStream ViewStream { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public MemoryMappedStream(MemoryMappedFile mmf, long length);
    internal MemoryMappedViewStream get_ViewStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long v);
    public virtual long get_Length();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Finalize();
    private virtual override void System.IDisposable.Dispose();
}
[DefaultMemberAttribute("Item")]
[ExperimentalAttribute("This FCS API/Type is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.IO.RawByteMemory : ByteMemory {
    internal int length;
    internal object holder;
    internal IntPtr addr;
    public byte Item { get; public set; }
    public int Length { get; }
    public RawByteMemory(Byte* addr, int length, object holder);
    public virtual byte get_Item(int i);
    public virtual void set_Item(int i, byte v);
    public virtual int get_Length();
    public virtual Byte[] ReadAllBytes();
    public virtual Byte[] ReadBytes(int pos, int count);
    public virtual int ReadInt32(int pos);
    public virtual ushort ReadUInt16(int pos);
    public virtual string ReadUtf8String(int pos, int count);
    public virtual ByteMemory Slice(int pos, int count);
    public virtual void CopyTo(Stream stream);
    public virtual void Copy(int srcOffset, Byte[] dest, int destOffset, int count);
    public virtual Byte[] ToArray();
    public virtual Stream AsStream();
    public virtual Stream AsReadOnlyStream();
    [CompilerGeneratedAttribute]
internal void check(int i);
    [CompilerGeneratedAttribute]
internal void checkCount(int count);
}
[DefaultMemberAttribute("Item")]
[StructAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.IO.ReadOnlyByteMemory : ValueType {
    internal ByteMemory bytes;
    internal byte Item { get; }
    internal int Length { get; }
    internal ByteMemory Underlying { get; }
    public ReadOnlyByteMemory(ByteMemory bytes);
    internal byte get_Item(int i);
    internal int get_Length();
    internal Byte[] ReadAllBytes();
    internal Byte[] ReadBytes(int pos, int count);
    internal int ReadInt32(int pos);
    internal ushort ReadUInt16(int pos);
    internal string ReadUtf8String(int pos, int count);
    internal ReadOnlyByteMemory Slice(int pos, int count);
    internal void CopyTo(Stream stream);
    internal void Copy(int srcOffset, Byte[] dest, int destOffset, int count);
    internal Byte[] ToArray();
    internal Stream AsStream();
    internal ByteMemory get_Underlying();
}
[ExperimentalAttribute("This FCS API/Type is experimental and subject to change.")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.IO.SafeUnmanagedMemoryStream : UnmanagedMemoryStream {
    internal object holder;
    internal bool isDisposed;
    public SafeUnmanagedMemoryStream(Byte* addr, long length, object holder);
    public SafeUnmanagedMemoryStream(Byte* addr, long length, long capacity, FileAccess access, object holder);
    public virtual void Dispose(bool disposing);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.IO.StreamExtensions : object {
    [CompilationMappingAttribute("9")]
internal static Encoding utf8noBOM { get; }
    internal static Encoding get_utf8noBOM();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TextWriter Stream.GetWriter(Stream s, FSharpOption`1<Encoding> encoding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Stream.WriteAllLines(Stream s, IEnumerable`1<string> contents, FSharpOption`1<Encoding> encoding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Stream.Write(Stream s, a data);
    internal static StreamReader getSource@772(Stream s, FSharpOption`1<int> codePage, bool retryLocked, int retryNumber);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static StreamReader Stream.GetReader(Stream s, FSharpOption`1<int> codePage, FSharpOption`1<bool> retryLocked);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] Stream.ReadBytes(Stream s, int start, int len);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Byte[] Stream.ReadAllBytes(Stream );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static string Stream.ReadAllText(Stream s, FSharpOption`1<Encoding> encoding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<string> Stream.ReadLines(Stream s, FSharpOption`1<Encoding> encoding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static String[] Stream.ReadAllLines(Stream s, FSharpOption`1<Encoding> encoding);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void Stream.WriteAllText(Stream s, string text);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ByteMemory Stream.AsByteMemory(Stream );
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Lexer : object {
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063429@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063430@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063431@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063432@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063433@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063434@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063435@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063436@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063437@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063438@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063439@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063440@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063441@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063442@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063443@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063444@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063445@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063446@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063447@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063448@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063449@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063450@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063451@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063452@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063453@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063454@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063455@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063456@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063457@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063458@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063459@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063460@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063461@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063462@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063463@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063464@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063465@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063466@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063467@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063468@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063469@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063470@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063471@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063472@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063473@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063474@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063475@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063476@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063477@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063478@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063479@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063480@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063481@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063482@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063483@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063484@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063485@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063486@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063487@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063488@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063489@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063490@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063491@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063492@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063493@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063494@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063495@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063496@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063497@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063498@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063499@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063500@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063501@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063502@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063503@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063504@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063505@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063506@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063507@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063508@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063509@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063510@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063511@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063512@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063513@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063514@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063515@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063516@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063517@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063518@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063519@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063520@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063521@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063522@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063523@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063524@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063525@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063526@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063527@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063528@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063529@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063530@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063531@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063532@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063533@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063534@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063535@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063536@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063537@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063538@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063539@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063540@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063541@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063542@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063543@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063544@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063545@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063546@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063547@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063548@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063549@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063550@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063551@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063552@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063553@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063554@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063555@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063556@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063557@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063558@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063559@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063560@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063561@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063562@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063563@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063564@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063565@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063566@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063567@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063568@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063569@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063570@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063571@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063572@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063573@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063574@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063575@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063576@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063577@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063578@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063579@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063580@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063581@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063582@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063583@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063584@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063585@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063586@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063587@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063588@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063589@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063590@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063591@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063592@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063593@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063594@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063595@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063596@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063597@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063598@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063599@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063600@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063601@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063602@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063603@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063604@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063605@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063606@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063607@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063608@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063609@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063610@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063611@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063612@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063613@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063614@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063615@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063616@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063617@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063618@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063619@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063620@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063621@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063622@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063623@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063624@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063625@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063626@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063627@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063628@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063629@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063630@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063631@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063632@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063633@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063634@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063635@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063636@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063637@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063638@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063639@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063640@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063641@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063642@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063643@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063644@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063645@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063646@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063647@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063648@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063649@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063650@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063651@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063652@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063653@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063654@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063655@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063656@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063657@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063658@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063659@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063660@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063661@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063662@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063663@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063664@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063665@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063666@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063667@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063668@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063669@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063670@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063671@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063672@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063673@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063674@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063675@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063676@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063677@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063678@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063679@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063680@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063681@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063682@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063683@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063684@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063685@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063686@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063687@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063688@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063689@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063690@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063691@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063692@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063693@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063694@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063695@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063696@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063697@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063698@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063699@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063700@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063701@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063702@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063703@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063704@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063705@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063706@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063707@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063708@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063709@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063710@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063711@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063712@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063713@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063714@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063715@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063716@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063717@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063718@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063719@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063720@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063721@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063722@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063723@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063724@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063725@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063726@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063727@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063728@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063729@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063730@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063731@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063732@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063733@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063734@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063735@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063736@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063737@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063738@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063739@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063740@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063741@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063742@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063743@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063744@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063745@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063746@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063747@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063748@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063749@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063750@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063751@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063752@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063753@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063754@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063755@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063756@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063757@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063758@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063759@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063760@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063761@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063762@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063763@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063764@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063765@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063766@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063767@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063768@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063769@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063770@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063771@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063772@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063773@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063774@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063775@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063776@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063777@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063778@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063779@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063780@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063781@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063782@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063783@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063784@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063785@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063786@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063787@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063788@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063789@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063790@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063791@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063792@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063793@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063794@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063795@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063796@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063797@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063798@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063799@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063800@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063801@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063802@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063803@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063804@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063805@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063806@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063807@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063808@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063809@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063810@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063811@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063812@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063813@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063814@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063815@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063816@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063817@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063818@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063819@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063820@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063821@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063822@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063823@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063824@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063825@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063826@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063827@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063828@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063829@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063830@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063831@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063832@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063833@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063834@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063835@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063836@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063837@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063838@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063839@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063840@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063841@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063842@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063843@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063844@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063845@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063846@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063847@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063848@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063849@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063850@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063851@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063852@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063853@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063854@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063855@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063856@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063857@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063858@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063859@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063860@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063861@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063862@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063863@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063864@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063865@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063866@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063867@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063868@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063869@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063870@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063871@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063872@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063873@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063874@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063875@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063876@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063877@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063878@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063879@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063880@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063881@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063882@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063883@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063884@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063885@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063886@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063887@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063888@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063889@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063890@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063891@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063892@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063893@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063894@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063895@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063896@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063897@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063898@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063899@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063900@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063901@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063902@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063903@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063904@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063905@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063906@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063907@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063908@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063909@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063910@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063911@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063912@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063913@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063914@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063915@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063916@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063917@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063918@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063919@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063920@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063921@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063922@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063923@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063924@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063925@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063926@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063927@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063928@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063929@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063930@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063931@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063932@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063933@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063934@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063935@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063936@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063937@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063938@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063939@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063940@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063941@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063942@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063943@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063944@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063945@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063946@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063947@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063948@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063949@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063950@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063951@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063952@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063953@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063954@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063955@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063956@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063957@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063958@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063959@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063960@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063961@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063962@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063963@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063964@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063965@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063966@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063967@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063968@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063969@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063970@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063971@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063972@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063973@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063974@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063975@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063976@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063977@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063978@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063979@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063980@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063981@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063982@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063983@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063984@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063985@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063986@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063987@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063988@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063989@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063990@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063991@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063992@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063993@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063994@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063995@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063996@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063997@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063998@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1063999@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064000@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064001@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064002@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064003@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064004@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064005@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064006@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064007@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064008@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064009@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064010@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064011@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064012@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064013@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064014@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064015@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064016@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064017@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064018@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064019@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064020@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064021@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064022@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064023@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064024@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064025@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064026@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064027@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064028@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064029@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064030@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064031@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064032@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064033@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064034@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064035@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064036@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064037@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064038@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064039@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064040@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064041@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064042@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064043@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064044@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064045@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064046@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064047@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064048@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064049@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064050@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064051@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064052@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064053@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064054@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064055@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064056@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064057@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064058@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064059@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064060@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064061@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064062@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064063@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064064@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064065@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064066@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064067@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064068@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064069@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064070@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064071@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064072@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064073@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064074@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064075@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064076@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064077@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064078@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064079@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064080@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064081@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064082@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064083@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064084@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064085@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064086@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064087@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064088@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064089@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064090@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064091@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064092@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064093@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064094@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064095@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064096@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064097@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064098@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064099@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064100@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064101@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064102@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064103@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064104@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064105@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064106@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064107@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064108@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064109@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064110@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064111@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064112@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064113@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064114@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064115@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064116@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064117@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064118@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064119@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064120@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064121@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064122@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064123@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064124@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064125@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064126@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064127@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064128@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064129@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064130@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064131@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064132@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064133@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064134@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064135@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064136@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064137@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064138@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064139@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064140@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064141@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064142@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064143@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064144@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064145@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064146@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064147@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064148@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064149@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064150@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064151@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064152@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064153@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064154@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064155@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064156@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064157@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064158@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064159@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064160@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064161@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064162@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064163@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064164@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064165@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064166@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064167@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064168@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064169@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064170@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064171@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064172@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064173@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064174@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064175@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064176@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064177@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064178@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064179@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064180@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064181@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064182@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064183@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064184@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064185@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064186@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064187@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064188@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064189@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064190@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064191@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064192@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064193@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064194@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064195@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064196@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064197@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064198@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064199@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064200@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064201@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064202@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064203@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064204@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064205@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064206@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064207@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064208@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064209@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064210@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064211@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064212@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064213@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064214@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064215@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064216@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064217@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064218@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064219@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064220@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064221@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064222@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064223@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064224@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064225@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064226@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064227@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064228@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064229@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064230@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064231@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064232@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064233@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064234@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064235@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064236@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064237@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064238@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064239@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064240@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064241@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064242@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064243@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064244@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064245@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064246@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064247@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064248@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064249@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064250@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064251@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064252@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064253@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064254@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064255@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064256@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064257@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064258@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063428_318Bytes@ field1064259@;
    [DebuggerBrowsableAttribute("0")]
internal static T1064260_1662Bytes@ field1064261@;
    [CompilationMappingAttribute("9")]
internal static UInt16[][] trans { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] actions { get; }
    [CompilationMappingAttribute("9")]
internal static UnicodeTables _fslex_tables { get; }
    private static Lexer();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string lexemeTrimBoth(LexBuffer`1<char> lexbuf, int n, int m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a fail(LexArgs args, LexBuffer`1<char> lexbuf, int msg_0, string msg_1, a dflt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int getSign32(string s, Int32& p, int l);
    internal static bool isOXB(char c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool is0OXB(string s, int p, int l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static char get0OXB(string s, Int32& p, int l);
    internal static int parseInt32(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int lexemeTrimRightToInt32(LexArgs args, LexBuffer`1<char> lexbuf, int n);
    internal static void checkExprOp(LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ByteBuffer, LexerStringFinisher, Range> startString(LexArgs args, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void trySaveXmlDoc(LexBuffer`1<char> lexbuf, FSharpOption`1<Tuple`2<Range, StringBuilder>> buff);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void tryAppendXmlDoc(FSharpOption`1<Tuple`2<Range, StringBuilder>> buff, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a shouldStartLine(LexArgs args, LexBuffer`1<char> lexbuf, Range m, int err_0, string err_1, a tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a shouldStartFile(LexArgs args, LexBuffer`1<char> lexbuf, Range m, int err_0, string err_1, a tok);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<bool, LexerIfdefExpression> evalIfDefExpression(Position startPos, bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, LexArgs args, FSharpFunc`2<string, bool> lookup, string lexed);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static float evalFloat(LexArgs args, LexBuffer`1<char> lexbuf);
    internal static UInt16[][] get_trans();
    internal static UInt16[] get_actions();
    internal static UnicodeTables get__fslex_tables();
    internal static a _fslex_dummy();
    [CompilerGeneratedAttribute]
internal static token token$cont@611(LexArgs args, bool skip, LexBuffer`1<char> lexbuf, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static token token$cont@634-1(LexArgs args, bool skip, LexBuffer`1<char> lexbuf, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static token token$cont@678-2(LexArgs args, bool skip, LexBuffer`1<char> lexbuf, Unit unitVar);
    internal static Tuple`2<int, FSharpOption`1<string>> parseLeadingDirective@746(LexBuffer`1<char> lexbuf, string s, int n);
    internal static Tuple`2<int, FSharpOption`1<string>> parseLeadingWhitespace@750(LexBuffer`1<char> lexbuf, string s, int n);
    internal static Tuple`2<int, FSharpOption`1<string>> parseLineNumber@754(LexBuffer`1<char> lexbuf, string s, int start, int n);
    internal static FSharpOption`1<string> parseWhitespaceBeforeFile@766(LexBuffer`1<char> lexbuf, string s, int n);
    internal static string parseFile@771(LexBuffer`1<char> lexbuf, string s, int start, int n);
    [CompilerGeneratedAttribute]
internal static bool contains@1-5(string id, a e, FSharpList`1<string> xs1);
    [CompilerGeneratedAttribute]
internal static token token$cont@988-3(LexArgs args, bool skip, LexBuffer`1<char> lexbuf, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token token(LexArgs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilerGeneratedAttribute]
internal static bool contains@1-6(string id, a e, FSharpList`1<string> xs1);
    [CompilerGeneratedAttribute]
internal static token ifdefSkip$cont@1080(int n, LexArgs args, bool skip, LexBuffer`1<char> lexbuf, string lexed, Range m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static token ifdefSkip$cont@1103-1(int n, LexArgs args, bool skip, LexBuffer`1<char> lexbuf, string lexed, Range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token ifdefSkip(int n, Range m, LexArgs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token endline(LexerEndlineContinuation cont, LexArgs args, bool skip, LexBuffer`1<char> lexbuf);
    internal static token result@1213(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf, Range m, LexerStringKind kind, LexArgs args, Unit unitVar0);
    internal static token result@1268-1(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf, Range m, LexerStringKind kind, LexArgs args, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token singleQuoteString(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf);
    internal static token result@1384-2(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf, Range m, LexerStringKind kind, LexArgs args, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token verbatimString(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf);
    internal static token result@1503-3(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf, Range m, LexerStringKind kind, LexArgs args, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token tripleQuoteString(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf);
    internal static token result@1559-4(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf, Range m, LexerStringKind kind, LexArgs args, Unit unitVar0);
    internal static token result@1624-5(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf, Range m, LexerStringKind kind, LexArgs args, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token extendedInterpolatedString(Tuple`5<ByteBuffer, LexerStringFinisher, Range, LexerStringKind, LexArgs> sargs, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token singleLineComment(Tuple`5<FSharpOption`1<Tuple`2<Range, StringBuilder>>, int, Range, Range, LexArgs> cargs, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token comment(Tuple`3<int, Range, LexArgs> cargs, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token stringInComment(int n, Range m, LexArgs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token verbatimStringInComment(int n, Range m, LexArgs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token tripleQuoteStringInComment(int n, Range m, LexArgs args, bool skip, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token mlOnly(Range m, LexArgs args, bool skip, LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.LexFilter : object {
    internal static bool forceDebug { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_forceDebug();
    internal static string stringOfPos(Position pos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputPos(TextWriter os, Position pos);
    internal static string warningStringOfPosition(Position pos);
    internal static bool isInfix(token token);
    internal static int infixTokenLength(token token);
    internal static FSharpOption`1<Unit> |TokenLExprParen|_|(token token);
    internal static FSharpOption`1<Unit> |TokenRExprParen|_|(token token);
    internal static bool isIfBlockContinuator(token token);
    internal static bool isMatchBlockContinuator(token token);
    internal static bool isTryBlockContinuator(token token);
    internal static bool isThenBlockContinuator(token token);
    internal static bool isDoContinuator(token token);
    internal static bool isInterfaceContinuator(token token);
    internal static bool isNamespaceContinuator(token token);
    internal static bool isTypeContinuator(token token);
    internal static bool isForLoopContinuator(token token);
    internal static bool isWhileBlockContinuator(token token);
    internal static bool isLetContinuator(token token);
    internal static bool isTypeSeqBlockElementContinuator(token token);
    internal static bool isSeqBlockElementContinuator(token token);
    internal static bool isWithAugmentBlockContinuator(token token);
    internal static bool isAtomicExprEndToken(token token);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool parenTokensBalance(token token1, token token2);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<token> afterOp$cont@542(FSharpList`1<char> afterAngles, string s, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<FSharpFunc`2[], FSharpOption`1<token>>> |TyparsCloseOp|_|$cont@521(FSharpList`1<char> angles, FSharpList`1<char> afterAngles, Unit unitVar);
    internal static FSharpOption`1<Tuple`2<FSharpFunc`2[], FSharpOption`1<token>>> |TyparsCloseOp|_|(string txt);
    internal static bool check@722-1(FSharpList`1<Context> s);
    internal static PositionWithColumn undentationLimit@746(LexFilterImpl this, Context newCtxt, bool strict, FSharpList`1<Context> stack);
    internal static bool scanAhead@1065(LexFilterImpl this, bool indentation, Position tokenEndPos, FSharpRef`1<FSharpList`1<Tuple`2<TokenTup, bool>>> stack, int nParen);
    internal static bool isSameLine@1271(LexFilterImpl this, Position tokenStartPos, token token, Unit unitVar0);
    internal static bool isControlFlowOrNotSameLine@1276(LexFilterImpl this, Position tokenStartPos, token token, Unit unitVar0);
    internal static bool loop@1288-35(LexFilterImpl this, Unit unitVar0);
    internal static bool isLongIdentEquals@1284(LexFilterImpl this, token token);
    internal static Range getLastTokenEndRange@1318(TokenTup tokenTup, Unit unitVar0);
    internal static token insertTokenFromPrevPosToCurrentPos@1322(LexFilterImpl this, TokenTup tokenTup, token tok);
    internal static token insertToken@1332(LexFilterImpl this, TokenTup tokenTup, token tok);
    internal static bool thereIsACtxtMemberBodyOnTheStackAndWeShouldPopStackForUpcomingMember@1375(FSharpList`1<Context> ctxtStack);
    internal static FSharpOption`1<token> endTokenForACtxt@1388(TokenTup tokenTup, Context ctxt);
    internal static bool tokenForcesHeadContextClosure@1417(LexFilterImpl this, token token, FSharpList`1<Context> stack);
    internal static bool nextOuterMostInterestingContextIsNamespaceOrModule@1450(FSharpList`1<Context> offsideStack);
    internal static void insertComingSoonTokens@1442(LexFilterImpl this, TokenTup tokenTup, Position tokenStartPos, string keywordName, token comingSoon, token isHere);
    internal static void delayMergedToken@2562(LexFilterImpl this, TokenTup tokenTup, TokenTup nextTokenTup, token tok);
    internal static void noMerge@2571(LexFilterImpl this, TokenTup tokenTup, TokenTup nextTokenTup, Unit unitVar0);
    [CompilerGeneratedAttribute]
internal static void rulesForBothSoftWhiteAndHardWhite$cont@2586(LexFilterImpl this, TokenTup tokenTup, bool plus, TokenTup nextTokenTup, Unit unitVar);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Lexhelp : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int StringCapacity;
    internal static string stdinMockFileName { get; }
    private static Lexhelp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_stdinMockFileName();
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@58-5(IEqualityComparer comp, LexArgs this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@58-8(LexArgs this, LexArgs that, IEqualityComparer comp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@58-9(LexArgs this, LexArgs obj, Unit unitVar);
    internal static LexArgs mkLexargs(FSharpList`1<string> conditionalDefines, IndentationAwareSyntaxStatus indentationSyntaxStatus, LexResourceManager resourceManager, FSharpList`1<Tuple`2<LexerIfdefStackEntry, Range>> ifdefStack, DiagnosticsLogger diagnosticsLogger, PathMap pathMap, bool applyLineDirectives);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a reusingLexbufForParsing(LexBuffer`1<char> lexbuf, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void resetLexbufPos(string fileName, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a usingLexbufForParsing(LexBuffer`1<char> lexbuf, string fileName, FSharpFunc`2<LexBuffer`1<char>, a> f);
    internal static string stringBufferAsString(ByteBuffer buf);
    [CompilerGeneratedAttribute]
internal static byte initializer@1-3(ReadOnlyMemory`1<byte> bytes, int i);
    internal static Byte[] stringBufferAsBytes(ByteBuffer buf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addUnicodeString(ByteBuffer buf, string x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addUnicodeChar(ByteBuffer buf, int c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void addByteChar(ByteBuffer buf, char c);
    internal static bool stringBufferIsBytes(ByteBuffer buf);
    internal static void newline(LexBuffer`1<a> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void advanceColumnBy(LexBuffer`1<a> lexbuf, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static char trigraph(char c1, char c2, char c3);
    internal static int digit(char d);
    internal static int hexdigit(char d);
    internal static ushort unicodeGraphShort(string s);
    internal static ushort hexGraphShort(string s);
    internal static LongUnicodeLexResult unicodeGraphLong(string s);
    internal static char escape(char c);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.LowerCalls : object {
    [CompilationMappingAttribute("9")]
internal static int LowerCallsRewriteStackGuardDepth { get; }
    internal static int get_LowerCallsRewriteStackGuardDepth();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> InterceptExpr(TcGlobals g, FSharpFunc`2<Expr, Expr> cont, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CheckedImplFile LowerImplFile(TcGlobals g, CheckedImplFile assembly);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.LowerComputedCollectionExpressions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildDisposableCleanup(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, InfoReader infoReader, Range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCollectorMethod(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, InfoReader infoReader, Range m, string name, Expr collExpr, FSharpList`1<Expr> args);
    [CompilerGeneratedAttribute]
internal static FSharpResult`2<Tuple`2<bool, Expr>, Unit> ConvertSeqExprCode$cont@107(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Range m, InfoReader infoReader, Val v, DebugPointAtInOrTo spIn, Range mIn, Range mFor, Expr inp, Expr bodyExpr, FSharpResult`2<Tuple`2<bool, Expr>, Unit> resBody, Unit unitVar);
    internal static FSharpResult`2<Tuple`2<bool, Expr>, Unit> ConvertSeqExprCode@64-15(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Range m, InfoReader infoReader, Expr collExpr, bool isUninteresting, bool isTailcall, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> LowerComputedListOrArraySeqExpr(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Range m, TType collectorTy, Expr overallSeqExpr);
    internal static Expr |OptionalCoerce|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, TType>> |OptionalSeq|_|(TcGlobals g, ImportMap amap, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Range>> |SeqToList|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Range>> |SeqToArray|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> LowerComputedListOrArrayExpr(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Expr overallExpr);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.LowerLocalMutables : object {
    [CompilationMappingAttribute("9")]
internal static int AutoboxRewriteStackGuardDepth { get; }
    internal static int get_AutoboxRewriteStackGuardDepth();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideEscapes(FSharpList`1<Val> syntacticArgs, Expr body);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpFunc`2<a, FSharpList`1<a>>> snoc@44();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideLambda(FSharpOption`1<FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>>> exprF, cenv cenv, ValReprInfo valReprInfo, Expr expr, TType exprTy, Set`2<Val, IComparer`1<Val>> z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideExprOp(FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>> exprF, FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>> noInterceptF, Set`2<Val, IComparer`1<Val>> z, Expr expr, TOp op, FSharpList`1<a> tyargs, FSharpList`1<Expr> args);
    internal static FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Tuple`2<a, FSharpList`1<ObjExprMethod>>, Set`2<Val, IComparer`1<Val>>>> CheckInterfaceImpl@99(FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<ObjExprMethod, Set`2<Val, IComparer`1<Val>>>> CheckMethod);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideExpr(cenv cenv, FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>> exprF, FSharpFunc`2<Set`2<Val, IComparer`1<Val>>, FSharpFunc`2<Expr, Set`2<Val, IComparer`1<Val>>>> noInterceptF, Set`2<Val, IComparer`1<Val>> z, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideBinding(cenv cenv, Set`2<Val, IComparer`1<Val>> z, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideBindings(cenv cenv, Set`2<Val, IComparer`1<Val>> z, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> DecideImplFile(TcGlobals g, ImportMap amap, CheckedImplFile implFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TransformExpr(TcGlobals g, ValMap`1<Tuple`2<a, Expr>> heapValMap, FSharpFunc`2<Expr, Expr> exprF, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Binding> TransformBinding(TcGlobals g, ValMap`1<Tuple`2<Val, a>> heapValMap, FSharpFunc`2<Expr, Expr> exprF, Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CheckedImplFile TransformImplFile(TcGlobals g, ImportMap amap, CheckedImplFile implFile);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.LowerSequenceExpressions : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr callNonOverloadedILMethod(TcGlobals g, ImportMap amap, Range m, string methName, TType ty, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsPossibleSequenceExpr(TcGlobals g, Expr overallExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyConfirmsToSeq(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |SeqElemTy|_|(TcGlobals g, ImportMap amap, Range m, TType ty);
    internal static LoweredSeqFirstPhaseResult RepresentBindingAsLocal@99(Binding bind, LoweredSeqFirstPhaseResult resBody, Range m);
    internal static Expr addDebugPoint@118(DebugPointAtBinding sp, Expr e);
    internal static LoweredSeqFirstPhaseResult RepresentBindingAsStateMachineLocal@113(Binding bind, LoweredSeqFirstPhaseResult resBody, Range m);
    internal static LoweredSeqFirstPhaseResult RepresentBindingsAsLifted@138(FSharpFunc`2<Expr, Expr> mkBinds, LoweredSeqFirstPhaseResult resBody);
    internal static Expr addTryDebugPoint@293(DebugPointAtTry spTry, Expr e);
    internal static Expr addFinallyDebugPoint@297(DebugPointAtFinally spFinally, Expr e);
    internal static FSharpOption`1<LoweredSeqFirstPhaseResult> ConvertSeqExprCode@150(TcGlobals g, ImportMap amap, bool isWholeExpr, bool isTailCall, int noDisposeContinuationLabel, int currentDisposeContinuationLabel, Expr expr);
    internal static DecisionTree mkGotoLabelTarget@592(Range m, MatchBuilder mbuilder, int lab);
    internal static Expr addJumpTable@590(TcGlobals g, Range m, int initLabel, int noDisposeContinuationLabel, Expr pcExpr, FSharpList`1<int> pcs, int pcDone, FSharpMap`2<int, int> pc2lab, bool isDisposal, Expr expr);
    internal static Expr handleExceptionsInDispose@623(TcGlobals g, Range m, Expr pcExpr, int pcDone, Expr disposalExpr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`8<ValRef, ValRef, ValRef, FSharpList`1<ValRef>, Expr, Expr, Expr, Tuple`2<TType, Range>>> ConvertSequenceExprToObject$cont@542(TcGlobals g, TType ty, Range m, int initLabel, int noDisposeContinuationLabel, FSharpOption`1<LoweredSeqFirstPhaseResult> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`8<ValRef, ValRef, ValRef, FSharpList`1<ValRef>, Expr, Expr, Expr, Tuple`2<TType, Range>>> ConvertSequenceExprToObject(TcGlobals g, ImportMap amap, Expr overallExpr);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.LowerStateMachines : object {
    [CompilationMappingAttribute("9")]
internal static int LowerStateMachineStackGuardDepth { get; }
    internal static bool sm_verbose { get; }
    internal static int get_LowerStateMachineStackGuardDepth();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_sm_verbose();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Expr>, Expr> |OptionalResumeAtExpr|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StateMachineConversionFirstPhaseResult RepresentBindingAsTopLevelOrLocal(Binding bind, StateMachineConversionFirstPhaseResult res2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StateMachineConversionFirstPhaseResult RepresentBindingAsThis(Binding bind, StateMachineConversionFirstPhaseResult res2, a _m);
    internal static Expr addDebugPoint@80-1(DebugPointAtBinding sp, Expr innerExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StateMachineConversionFirstPhaseResult RepresentBindingAsStateVar(TcGlobals g, Binding bind, StateMachineConversionFirstPhaseResult resBody, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isExpandVar(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStateMachineBindingVar(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpOption`1<Expr>> IsStateMachineExpr(TcGlobals g, Expr overallExpr);
    internal static LoweredStateMachineResult fallback@850(FSharpOption`1<Expr> altExprOpt, string msg);
    internal static DecisionTree mkGotoLabelTarget@419-1(Range m, MatchBuilder mbuilder, int lab);
    internal static Expr recreate@549(LowerStateMachine this, Expr noneBranchExpr, Range m, FSharpOption`1<int> reenterLabOpt, Expr e1, Expr e2);
    internal static Expr recreate@571-1(Range m, FSharpOption`1<int> contLabOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LoweredStateMachineResult LowerStateMachineExpr(TcGlobals g, Expr overallExpr);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.MethodCalls : object {
    internal static CalledArg CalledArg(ValueTuple`2<int, int> pos, bool isParamArray, OptionalArgInfo optArgInfo, CallerInfo callerInfo, bool isInArg, bool isOutArg, FSharpOption`1<Ident> nameOpt, ReflectedArgInfo reflArgInfo, TType calledArgTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType AdjustDelegateTy(InfoReader infoReader, TType actualTy, TType reqdTy, Range m);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`3<MethInfo, TType, Tuple`3<TType, TType, FSharpFunc`2<DisplayEnv, Unit>>>> TryFindRelevantImplicitConversion$cont@183(InfoReader infoReader, AccessorDomain ad, TType reqdTy, TType actualTy, Range m, TcGlobals g, ImportMap amap, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<MethInfo, TType, Tuple`3<TType, TType, FSharpFunc`2<DisplayEnv, Unit>>>> TryFindRelevantImplicitConversion(InfoReader infoReader, AccessorDomain ad, TType reqdTy, TType actualTy, Range m);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> f@658-6(TypeDirectedConversionUsed zero, FSharpFunc`2<TypeDirectedConversionUsed, FSharpFunc`2<TypeDirectedConversionUsed, TypeDirectedConversionUsed>> reducer, FSharpList`1<TypeDirectedConversionUsed> res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> MapCombineTDCD(FSharpFunc`2<a, OperationResult`1<TypeDirectedConversionUsed>> mapper, FSharpList`1<a> xs);
    [CompilerGeneratedAttribute]
internal static OperationResult`1<TypeDirectedConversionUsed> f@658-7(TypeDirectedConversionUsed zero, FSharpFunc`2<TypeDirectedConversionUsed, FSharpFunc`2<TypeDirectedConversionUsed, TypeDirectedConversionUsed>> reducer, FSharpList`1<TypeDirectedConversionUsed> res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static OperationResult`1<TypeDirectedConversionUsed> MapCombineTDC2D(FSharpFunc`2<a, FSharpFunc`2<b, OperationResult`1<TypeDirectedConversionUsed>>> mapper, FSharpList`1<a> xs, FSharpList`1<b> ys);
    internal static FSharpFunc`2<DisplayEnv, Exception> warn@262(InfoReader infoReader, bool isMethodArg, TType reqdTy, TType actualTy, Range m, TypeDirectedConversion info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TType, TypeDirectedConversionUsed, FSharpOption`1<Tuple`3<TType, TType, FSharpFunc`2<DisplayEnv, Unit>>>> AdjustRequiredTypeForTypeDirectedConversions(InfoReader infoReader, AccessorDomain ad, bool isMethodArg, bool isConstraint, TType reqdTy, TType actualTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TType, TypeDirectedConversionUsed, FSharpOption`1<Tuple`3<TType, TType, FSharpFunc`2<DisplayEnv, Unit>>>> AdjustCalledArgTypeForTypeDirectedConversionsAndAutoQuote(InfoReader infoReader, AccessorDomain ad, TType callerArgTy, TType calledArgTy, CalledArg calledArg, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TType, TypeDirectedConversionUsed, FSharpOption`1<Tuple`3<TType, TType, FSharpFunc`2<DisplayEnv, Unit>>>> AdjustCalledArgTypeForOptionals(InfoReader infoReader, AccessorDomain ad, bool enforceNullableOptionalsKnownTypes, CalledArg calledArg, TType calledArgTy, CallerArg`1<a> callerArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<TType, TypeDirectedConversionUsed, FSharpOption`1<Tuple`3<TType, TType, FSharpFunc`2<DisplayEnv, Unit>>>> AdjustCalledArgType(InfoReader infoReader, AccessorDomain ad, bool isConstraint, bool enforceNullableOptionalsKnownTypes, CalledArg calledArg, CallerArg`1<a> callerArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<CalledArg>> MakeCalledArgs(ImportMap amap, Range m, MethInfo minfo, FSharpList`1<TType> minst);
    internal static bool isOpt@560(CalledArg x);
    internal static bool isOut@561(CalledMeth`1<T> this, CalledArg x);
    internal static FSharpList`1<Ident> NamesOfCalledArgs(FSharpList`1<CalledArg> calledArgs);
    internal static int loop@840-52(SynExpr e);
    internal static int InferLambdaArgsForLambdaPropagation(SynExpr origRhsExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArgumentAnalysis ExamineArgumentForLambdaPropagation(InfoReader infoReader, AccessorDomain ad, bool noEagerConstraintApplication, AssignedCalledArg`1<SynExpr> arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<FSharpList`1<ArgumentAnalysis>>, FSharpList`1<FSharpList`1<Tuple`2<Ident, ArgumentAnalysis>>>>> ExamineMethodForLambdaPropagation(TcGlobals g, Range m, CalledMeth`1<SynExpr> meth, AccessorDomain ad);
    internal static bool IsBaseCall(FSharpList`1<Expr> objArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> ComputeConstrainedCallInfo(TcGlobals g, ImportMap amap, Range m, FSharpOption`1<TType> staticTyOpt, FSharpList`1<Expr> args, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, a> TakeObjAddrForMethodCall(TcGlobals g, ImportMap amap, MethInfo minfo, Mutates isMutable, Range m, FSharpOption`1<TType> staticTyOpt, FSharpList`1<Expr> objArgs, FSharpFunc`2<FSharpOption`1<TType>, FSharpFunc`2<FSharpList`1<Expr>, Tuple`2<Expr, a>>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildILMethInfoCall(TcGlobals g, ImportMap amap, Range m, bool isProp, ILMethInfo minfo, ValUseFlag valUseFlags, FSharpList`1<TType> minst, bool direct, FSharpList`1<Expr> args);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, Tuple`2<FSharpList`1<Expr>, TType>> BuildFSharpMethodApp$cont@1010(TcGlobals g, Range m, TType fty, FSharpList`1<Expr> args, int arity, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildFSharpMethodApp(TcGlobals g, Range m, ValRef vref, Expr vExpr, TType vexprty, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildFSharpMethodCall(TcGlobals g, Range m, TType ty, ValRef vref, ValUseFlag valUseFlags, FSharpList`1<TType> minst, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeMethInfoCall(ImportMap amap, Range m, MethInfo minfo, FSharpList`1<TType> minst, FSharpList`1<Expr> args, FSharpOption`1<TType> staticTyOpt);
    internal static FSharpOption`1<ValRef> TryImportProvidedMethodBaseAsLibraryIntrinsic(ImportMap amap, Range m, Tainted`1<ProvidedMethodBase> mbase);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, TType> BuildMethodCall$cont@1159-1(TcGlobals g, Range m, bool isProp, MethInfo minfo, FSharpList`1<TType> minst, FSharpList`1<Expr> allArgs, ValUseFlag valUseFlags, Tainted`1<ProvidedMethodBase> providedMeth, ImportMap amap, TType enclTy, bool isStruct, bool isCtor, bool useCallvirt, bool isProtected, TType exprTy, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, TType> BuildMethodCall$cont@1135(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, Range m, bool isProp, MethInfo minfo, FSharpList`1<TType> minst, bool direct, FSharpList`1<Expr> allArgs, ValUseFlag valUseFlags, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> BuildMethodCall(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, Mutates isMutable, Range m, bool isProp, MethInfo minfo, ValUseFlag valUseFlags, FSharpList`1<TType> minst, FSharpList`1<Expr> objArgs, FSharpList`1<Expr> args, FSharpOption`1<TType> staticTyOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILFieldStaticChecks(TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, Range m, ILFieldInfo finfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ILFieldInstanceChecks(TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, ILFieldInfo finfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void MethInfoChecks(TcGlobals g, ImportMap amap, bool isInstance, FSharpOption`1<a> tyargsOpt, FSharpList`1<Expr> objArgs, AccessorDomain ad, Range m, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr BuildObjCtorCall(TcGlobals g, Range m);
    internal static Expr BuildNewDelegateExpr(FSharpOption`1<EventInfo> eventInfoOpt, TcGlobals g, ImportMap amap, TType delegateTy, MethInfo delInvokeMeth, FSharpList`1<TType> delArgTys, Expr delFuncExpr, TType delFuncTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CoerceFromFSharpFuncToDelegate(TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, TType callerArgTy, Range m, Expr callerArgExpr, TType delegateTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr AdjustExprForTypeDirectedConversions(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, TType reqdTy, TType actualTy, Range m, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<a>, Expr> AdjustCallerArgExpr(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, bool isOutArg, TType calledArgTy, ReflectedArgInfo reflArgInfo, TType callerArgTy, Range m, Expr callerArgExpr);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpFunc`2<Expr, Expr>, Expr> GetDefaultExpressionForCallerSideOptionalArg$cont@1418(FSharpFunc`2<Range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, TcGlobals g, CalledArg calledArg, TType currCalledArgTy, FSharpOption`1<string> eCallerMemberName, Range mMethExpr, ILFieldInit fieldInit, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<Expr, Expr>, Expr> GetDefaultExpressionForCallerSideOptionalArg(FSharpFunc`2<Range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, TcGlobals g, CalledArg calledArg, TType currCalledArgTy, OptionalArgCallerSideValue currDfltVal, FSharpOption`1<string> eCallerMemberName, Range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr GetDefaultExpressionForCalleeSideOptionalArg(TcGlobals g, CalledArg calledArg, FSharpOption`1<string> eCallerMemberName, Range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<Expr, Expr>, AssignedCalledArg`1<Expr>> GetDefaultExpressionForOptionalArg(FSharpFunc`2<Range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, TcGlobals g, CalledArg calledArg, FSharpOption`1<string> eCallerMemberName, Range mItem, Range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AssignedCalledArg`1<Expr> AdjustCallerArgForOptional(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, FSharpFunc`2<Range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, FSharpOption`1<string> eCallerMemberName, InfoReader infoReader, AccessorDomain ad, AssignedCalledArg`1<Expr> assignedArg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<AssignedCalledArg`1<Expr>>, FSharpFunc`2<Expr, Expr>, FSharpList`1<AssignedCalledArg`1<Expr>>, FSharpList`1<AssignedCalledArg`1<Expr>>> AdjustCallerArgsForOptionals(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, FSharpFunc`2<Range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, FSharpOption`1<string> eCallerMemberName, InfoReader infoReader, AccessorDomain ad, CalledMeth`1<Expr> calledMeth, Range mItem, Range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<AssignedCalledArg`1<Expr>>, FSharpList`1<Expr>, FSharpList`1<Binding>> AdjustOutCallerArgs(TcGlobals g, CalledMeth`1<a> calledMeth, Range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpOption`1<a>>, FSharpList`1<AssignedCalledArg`1<Expr>>> AdjustParamArrayCallerArgs(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, TcGlobals g, ImportMap amap, InfoReader infoReader, AccessorDomain ad, CalledMeth`1<Expr> calledMeth, Range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<FSharpFunc`2<Expr, Expr>, FSharpList`1<Expr>, FSharpList`1<FSharpOption`1<b>>, FSharpList`1<AssignedCalledArg`1<Expr>>, FSharpList`1<Expr>, FSharpFunc`2<Expr, Expr>, FSharpList`1<FSharpOption`1<c>>, Tuple`2<FSharpList`1<Expr>, FSharpList`1<Binding>>> AdjustCallerArgs(FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, FSharpFunc`2<Range, FSharpFunc`2<ILFieldInit, Const>> tcFieldInit, FSharpOption`1<string> eCallerMemberName, InfoReader infoReader, AccessorDomain ad, CalledMeth`1<Expr> calledMeth, FSharpList`1<Expr> objArgs, FSharpOption`1<a> lambdaVars, Range mItem, Range mMethExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecdFieldInstanceChecks(TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, RecdFieldInfo rfinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckRecdFieldMutation(Range m, DisplayEnv denv, RecdFieldInfo rfinfo);
    [CompilerGeneratedAttribute]
internal static FSharpChoice`5<Tuple`3<MethInfo, FSharpList`1<TType>, FSharpOption`1<TType>>, Tuple`3<FSharpList`1<TType>, RecdFieldRef, bool>, Tuple`3<AnonRecdTypeInfo, FSharpList`1<TType>, int>, Expr, Unit> sln$cont@2118(ImportMap amap, TcGlobals g, Range m, FSharpOption`1<TraitConstraintSln> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Expr> GenWitnessExpr$cont@2148(ImportMap amap, TcGlobals g, Range m, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs, FSharpChoice`5<Tuple`3<MethInfo, FSharpList`1<TType>, FSharpOption`1<TType>>, Tuple`3<FSharpList`1<TType>, RecdFieldRef, bool>, Tuple`3<AnonRecdTypeInfo, FSharpList`1<TType>, int>, Expr, Unit> sln, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Expr> GenWitnessExpr$cont@2192-1(TcGlobals g, Range m, FSharpList`1<Expr> argExprs, FSharpChoice`5<Tuple`3<MethInfo, FSharpList`1<TType>, FSharpOption`1<TType>>, Tuple`3<FSharpList`1<TType>, RecdFieldRef, bool>, Tuple`3<AnonRecdTypeInfo, FSharpList`1<TType>, int>, Expr, Unit> sln, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> GenWitnessExpr(ImportMap amap, TcGlobals g, Range m, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpChoice`2<TraitConstraintInfo, Expr> GenWitnessExprLambda(ImportMap amap, TcGlobals g, Range m, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpChoice`2<TraitConstraintInfo, Expr>> GenWitnessArgs(ImportMap amap, TcGlobals g, Range m, FSharpList`1<TraitConstraintInfo> traitInfos);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.MethodOverrides : object {
    [CompilerGeneratedAttribute]
internal static void FinalTypeDefinitionChecksAtEndOfInferenceScope$cont@901(Entity tycon, TcResultsSink sink, NameResolutionEnv nenv, bool isImplementation, InfoReader infoReader, DisplayEnv denv, TcGlobals g, Unit unitVar);
    internal static void FinalTypeDefinitionChecksAtEndOfInferenceScope(InfoReader infoReader, NameResolutionEnv nenv, TcResultsSink sink, bool isImplementation, DisplayEnv denv, Entity tycon);
    internal static Tuple`2<FSharpList`1<MethInfo>, FSharpList`1<MethInfo>> GetAbstractMethInfosForSynMethodDecl(InfoReader infoReader, AccessorDomain ad, Ident memberName, Range bindm, Tuple`2<TType, FSharpOption`1<SlotImplSet>> typToSearchForAbstractMembers, SynValInfo valSynData, SynMemberFlags memberFlags, FindMemberFlag findFlag);
    internal static FSharpList`1<PropInfo> GetAbstractPropInfosForSynPropertyDecl(InfoReader infoReader, AccessorDomain ad, Ident memberName, Range bindm, Tuple`2<TType, FSharpOption`1<SlotImplSet>> typToSearchForAbstractMembers);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.NameResolution : object {
    internal static FSharpList`1<TType> emptyTypeInst { get; }
    internal static FSharpList`1<TType> emptyEnclosingTypeInst { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<UnionCaseRef> UnionCaseRefsInTycon(EntityRef modref, Entity tycon);
    internal static FSharpList`1<UnionCaseRef> UnionCaseRefsInModuleOrNamespace(EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Entity> TryFindTypeWithUnionCase(EntityRef modref, Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Entity> TryFindTypeWithRecdField(EntityRef modref, Ident id);
    internal static bool hasStructAttribute@95(TcGlobals g, ValRef vref, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ActivePatternElemRef> ActivePatternElemsOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ValRef> TryMkValRefInModRef(EntityRef modref, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ActivePatternElemRef> ActivePatternElemsOfVal(TcGlobals g, EntityRef modref, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, ActivePatternElemRef> ActivePatternElemsOfModuleOrNamespace(TcGlobals g, EntityRef modref);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpList`1<TType> get_emptyTypeInst();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpList`1<TType> get_emptyEnclosingTypeInst();
    internal static int valRefHash(ValRef vref);
    internal static ItemWithInst ItemWithNoInst(Item item);
    internal static Tuple`2<Item, FSharpList`1<Tuple`2<Typar, TType>>> |ItemWithInst|(ItemWithInst x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTyconRefUsedForCSharpStyleExtensionMembers(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTypeUsedForCSharpStyleExtensionMembers(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMethInfoPlainCSharpStyleExtensionMember(TcGlobals g, Range m, bool isEnclExtTy, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpOption`1<EntityRef>> GetTyconRefForExtensionMembers(MethInfo minfo, Entity deref, ImportMap amap, Range m, TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpChoice`2<Tuple`2<EntityRef, ExtensionMember>, ExtensionMember>> GetCSharpStyleIndexedExtensionMembersForTyconRef(ImportMap amap, Range m, EntityRef tcrefOfStaticClass);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> IntrinsicPropInfosOfTypeInScope(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> SelectPropInfosFromExtMembers(InfoReader infoReader, AccessorDomain ad, FSharpOption`1<string> optFilter, TType declaringTy, Range m, IEnumerable`1<ExtensionMember> extMemInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> ExtensionPropInfosOfTypeInScope(ResultCollectionSettings collectionSettings, InfoReader infoReader, NameResolutionEnv nenv, FSharpOption`1<string> optFilter, LookupIsInstance isInstanceFilter, AccessorDomain ad, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PropInfo> AllPropInfosOfTypeInScope(ResultCollectionSettings collectionSettings, InfoReader infoReader, NameResolutionEnv nenv, FSharpOption`1<string> optFilter, AccessorDomain ad, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> IntrinsicMethInfosOfType(InfoReader infoReader, FSharpOption`1<string> optFilter, AccessorDomain ad, AllowMultiIntfInstantiations allowMultiIntfInst, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<MethInfo> TrySelectExtensionMethInfoOfILExtMem(Range m, ImportMap amap, TType apparentTy, EntityRef actualParent, MethInfo minfo, ulong pri);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<MethInfo> SelectMethInfosFromExtMembers$cont@725(InfoReader infoReader, FSharpOption`1<string> optFilter, TType apparentTy, Range m, TcGlobals g, ExtensionMember emem, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> SelectMethInfosFromExtMembers(InfoReader infoReader, FSharpOption`1<string> optFilter, TType apparentTy, Range m, IEnumerable`1<ExtensionMember> extMemInfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> ExtensionMethInfosOfTypeInScope(ResultCollectionSettings collectionSettings, InfoReader infoReader, NameResolutionEnv nenv, FSharpOption`1<string> optFilter, LookupIsInstance isInstanceFilter, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<MethInfo> AllMethInfosOfTypeInScope(ResultCollectionSettings collectionSettings, InfoReader infoReader, NameResolutionEnv nenv, FSharpOption`1<string> optFilter, AccessorDomain ad, FindMemberFlag findFlag, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Item> AddValRefsToItems(BulkAdd bulkAddMode, FSharpMap`2<string, Item> eUnqualifiedItems, ValRef[] vrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconRefMultiMap`1<ExtensionMember> AddValRefToExtensionMembers(ulong pri, TyconRefMultiMap`1<ExtensionMember> eIndexedExtensionMembers, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddFakeNamedValRefToNameEnv(string nm, NameResolutionEnv nenv, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddFakeNameToNameEnv(string nm, NameResolutionEnv nenv, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Item> AddValRefsToActivePatternsNameEnv(TcGlobals g, FSharpMap`2<string, Item> ePatItems, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddValRefsToNameEnvWithPriority(TcGlobals g, BulkAdd bulkAddMode, ulong pri, NameResolutionEnv nenv, ValRef[] vrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddValRefToNameEnv(TcGlobals g, NameResolutionEnv nenv, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddActivePatternResultTagsToNameEnv(ActivePatternInfo apinfo, NameResolutionEnv nenv, TType apOverallTy, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<NameArityPair, EntityRef> AddTyconsByDemangledNameAndArity(BulkAdd bulkAddMode, EntityRef[] tcrefs, FSharpMap`2<NameArityPair, EntityRef> tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LayeredMultiMap`2<string, EntityRef> AddTyconByAccessNames(BulkAdd bulkAddMode, EntityRef[] tcrefs, LayeredMultiMap`2<string, EntityRef> tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Item> AddUnionCases1(FSharpMap`2<string, Item> tab, FSharpList`1<UnionCaseRef> ucrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Item> AddUnionCases2(BulkAdd bulkAddMode, FSharpMap`2<string, Item> eUnqualifiedItems, FSharpList`1<UnionCaseRef> ucrefs);
    internal static void CheckForDirectReferenceToGeneratedType(EntityRef tcref, PermitDirectReferenceToGeneratedType genOk, Range m);
    internal static EntityRef AddEntityForProvidedType(ImportMap amap, EntityRef modref, ResolutionEnvironment resolutionEnvironment, Tainted`1<ProvidedType> st, Range m);
    internal static FSharpList`1<EntityRef> ResolveProvidedTypeNameInEntity(ImportMap amap, Range m, string typeName, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Entity> LookupTypeNameInEntityHaveArity(string nm, TypeNameResolutionStaticArgsInfo typeNameResInfo, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> LookupTypeNameNoArity(string nm, FSharpMap`2<NameArityPair, a> byDemangledNameAndArity, LayeredMultiMap`2<string, a> byAccessNames);
    internal static FSharpList`1<EntityRef> LookupTypeNameInEntityMaybeHaveArity(ImportMap amap, Range m, AccessorDomain ad, string nm, TypeNameResolutionStaticArgsInfo staticResInfo, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, FSharpList`1<EntityRef>> GetNestedTyconRefsOfType(InfoReader infoReader, ImportMap amap, AccessorDomain ad, FSharpOption`1<string> optFilter, TypeNameResolutionStaticArgsInfo staticResInfo, bool checkForGenerated, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType MakeNestedType(NameResolver ncenv, FSharpList`1<TType> tinst, Range m, EntityRef tcrefNested);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> GetNestedTypesOfType(AccessorDomain ad, NameResolver ncenv, FSharpOption`1<string> optFilter, TypeNameResolutionStaticArgsInfo staticResInfo, bool checkForGenerated, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<KeyValuePair`2<string, Item>> ChooseMethInfosForNameEnv(TcGlobals g, Range m, TType ty, FSharpList`1<MethInfo> minfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<KeyValuePair`2<string, Item>> ChoosePropInfosForNameEnv(TcGlobals g, TType ty, FSharpList`1<PropInfo> pinfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<KeyValuePair`2<string, Item>> ChooseFSharpFieldInfosForNameEnv(TcGlobals g, TType ty, FSharpList`1<RecdFieldInfo> rfinfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<KeyValuePair`2<string, Item>> ChooseILFieldInfosForNameEnv(TcGlobals g, TType ty, FSharpList`1<ILFieldInfo> finfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<KeyValuePair`2<string, Item>> ChooseEventInfosForNameEnv(TcGlobals g, TType ty, FSharpList`1<EventInfo> einfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddStaticContentOfTypeToNameEnv(TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, NameResolutionEnv nenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddNestedTypesOfTypeToNameEnv(InfoReader infoReader, ImportMap amap, AccessorDomain ad, Range m, NameResolutionEnv nenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddTyconRefsWithEnclosingTypeInstToNameEnv(BulkAdd bulkAddMode, bool ownDefinition, TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, bool root, NameResolutionEnv nenv, FSharpList`1<TType> tinstEnclosing, FSharpList`1<EntityRef> tcrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddStaticPartsOfTypeToNameEnv(ImportMap amap, Range m, NameResolutionEnv nenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddStaticPartsOfTyconRefToNameEnv(BulkAdd bulkAddMode, bool ownDefinition, TcGlobals g, ImportMap amap, Range m, NameResolutionEnv nenv, FSharpOption`1<FSharpList`1<TType>> tinstOpt, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanAutoOpenTyconRef(TcGlobals g, Range m, EntityRef tcref);
    [CompilerGeneratedAttribute]
internal static Item f@1420-5(EntityRef tcref, FSharpOption`1<Item> prev);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddPartsOfTyconRefToNameEnv(BulkAdd bulkAddMode, bool ownDefinition, TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, NameResolutionEnv nenv, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddTyconRefsToNameEnv(BulkAdd bulkAddMode, bool ownDefinition, TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, bool root, NameResolutionEnv nenv, FSharpList`1<EntityRef> tcrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddExceptionDeclsToNameEnv(BulkAdd bulkAddMode, NameResolutionEnv nenv, EntityRef ecref);
    internal static FSharpFunc`2<FSharpList`1<a>, FSharpFunc`2<FSharpList`1<a>, FSharpList`1<a>>> add@1422-4();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleAbbrevToNameEnv(Ident id, NameResolutionEnv nenv, FSharpList`1<EntityRef> modrefs);
    internal static FSharpList`1<EntityRef> MakeNestedModuleRefs(EntityRef modref);
    internal static FSharpMap`2<string, FSharpList`1<EntityRef>> addModrefs@1440(ImportMap amap, Range m, AccessorDomain ad, FSharpMap`2<string, EntityRef> modrefsMap, FSharpMap`2<string, FSharpList`1<EntityRef>> tab);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleOrNamespaceRefsToNameEnv(TcGlobals g, ImportMap amap, Range m, bool root, AccessorDomain ad, NameResolutionEnv nenv, FSharpList`1<EntityRef> modrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleOrNamespaceContentsToNameEnv(TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, bool root, NameResolutionEnv nenv, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleOrNamespaceRefsContentsToNameEnv(TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, bool root, NameResolutionEnv nenv, FSharpList`1<EntityRef> modrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddTypeContentsToNameEnv(TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, NameResolutionEnv nenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleOrNamespaceRefContentsToNameEnv(TcGlobals g, ImportMap amap, AccessorDomain ad, Range m, bool root, NameResolutionEnv nenv, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddModuleOrNamespaceRefToNameEnv(TcGlobals g, ImportMap amap, Range m, bool root, AccessorDomain ad, NameResolutionEnv nenv, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameResolutionEnv AddDeclaredTyparsToNameEnv(CheckForDuplicateTyparFlag check, NameResolutionEnv nenv, FSharpList`1<Typar> typars);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType FreshenTycon(NameResolver ncenv, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType FreshenTyconWithEnclosingTypeInst(NameResolver ncenv, Range m, FSharpList`1<TType> tinstEnclosing, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseInfo FreshenUnionCaseRef(NameResolver ncenv, Range m, UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdFieldInfo FreshenRecdFieldRef(NameResolver ncenv, Range m, RecdFieldRef rfref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ResolveUnqualifiedItem(NameResolver ncenv, NameResolutionEnv nenv, Range m, Item res);
    internal static ResultOrException`1<FSharpList`1<a>> OneResult(ResultOrException`1<a> res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<a>> AddResults(ResultOrException`1<FSharpList`1<a>> res1, ResultOrException`1<FSharpList`1<a>> res2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<b>> CollectResults(FSharpFunc`2<a, ResultOrException`1<b>> f, FSharpList`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<b>> CollectAtMostOneResult(FSharpFunc`2<a, ResultOrException`1<b>> f, FSharpList`1<a> inputs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpList`1<a>, ResultOrException`1<FSharpList`1<b>>> CollectResults2(ResultCollectionSettings resultCollectionSettings, FSharpFunc`2<a, ResultOrException`1<b>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<b>> MapResults(FSharpFunc`2<a, b> f, ResultOrException`1<FSharpList`1<a>> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<a> AtMostOneResult(Range m, ResultOrException`1<FSharpList`1<a>> res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<a>> AtMostOneResultQuery(FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<a>>> query2, ResultOrException`1<FSharpList`1<a>> res1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<EntityRef> LookupTypeNameInEnvHaveArity(FullyQualifiedFlag fq, string nm, int numTyArgs, NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<EntityRef> LookupTypeNameInEnvNoArity(FullyQualifiedFlag fq, string nm, NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<EntityRef> LookupTypeNameInEnvMaybeHaveArity(FullyQualifiedFlag fq, string nm, TypeNameResolutionInfo typeNameResInfo, NameResolutionEnv nenv);
    internal static FSharpOption`1<Tuple`2<string, EntityRef>> |RecordFieldUse|_|(Item item);
    internal static FSharpOption`1<Tuple`2<int, UnionCaseRef>> |UnionCaseFieldUse|_|(Item item);
    internal static FSharpOption`1<ILFieldInfo> |ILFieldUse|_|(Item item);
    internal static FSharpOption`1<PropInfo> |PropertyUse|_|(Item item);
    internal static FSharpOption`1<ValRef> |FSharpPropertyUse|_|(Item item);
    internal static FSharpOption`1<MethInfo> |MethodUse|_|(Item item);
    internal static FSharpOption`1<ValRef> |FSharpMethodUse|_|(Item item);
    internal static FSharpOption`1<EntityRef> |EntityUse|_|(Item item);
    internal static FSharpOption`1<EventInfo> |EventUse|_|(Item item);
    internal static FSharpOption`1<ValRef> |FSharpEventUse|_|(Item item);
    internal static FSharpOption`1<UnionCaseRef> |UnionCaseUse|_|(Item item);
    internal static FSharpOption`1<ValRef> |ValUse|_|(Item item);
    internal static FSharpOption`1<Tuple`3<Range, Range, int>> |ActivePatternCaseUse|_|(Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int tyconRefDefnHash(TcGlobals _g, EntityRef eref1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyconRefDefnEq(TcGlobals g, EntityRef eref1, EntityRef eref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int valRefDefnHash(TcGlobals _g, ValRef vref1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valRefDefnEq(TcGlobals g, ValRef vref1, ValRef vref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool unionCaseRefDefnEq(TcGlobals g, UnionCaseRef uc1, UnionCaseRef uc2);
    [CompilerGeneratedAttribute]
internal static bool ItemsAreEffectivelyEqual$cont@1865(TcGlobals g, Typar tp2, Typar tp1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool ItemsAreEffectivelyEqual$cont@1858-1(TcGlobals g, Item orig, Item other, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ItemsAreEffectivelyEqual(TcGlobals g, Item orig, Item other);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ItemsAreEffectivelyEqualHash(TcGlobals g, Item orig);
    internal static IDisposable WithNewTypecheckResultsSink(ITypecheckResultsSink newSink, TcResultsSink sink);
    internal static IDisposable TemporarilySuspendReportingTypecheckResultsToSink(TcResultsSink sink);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallEnvSink(TcResultsSink sink, Range scopem, NameResolutionEnv nenv, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallNameResolutionSink(TcResultsSink sink, Range m, NameResolutionEnv nenv, Item item, FSharpList`1<Tuple`2<Typar, TType>> tpinst, ItemOccurence occurenceType, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallMethodGroupNameResolutionSink(TcResultsSink sink, Range m, NameResolutionEnv nenv, Item item, Item itemMethodGroup, FSharpList`1<Tuple`2<Typar, TType>> tpinst, ItemOccurence occurenceType, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallNameResolutionSinkReplacing(TcResultsSink sink, Range m, NameResolutionEnv nenv, Item item, FSharpList`1<Tuple`2<Typar, TType>> tpinst, ItemOccurence occurenceType, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallExprHasTypeSink(TcResultsSink sink, Range m, NameResolutionEnv nenv, TType ty, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CallOpenDeclarationSink(TcResultsSink sink, OpenDeclaration openDeclaration);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckAllTyparsInferrable(ImportMap amap, Range m, Item item);
    internal static FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>> CheckForTypeLegitimacyAndMultipleGenericTypeAmbiguities(FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>> tcrefs, TypeNameResolutionInfo typeNameResInfo, PermitDirectReferenceToGeneratedType genOk, Range m);
    internal static FSharpFunc`2<IEnumerable`1<EntityRef>, Exception> notFoundAux@2376(ImportMap amap, Range m, AccessorDomain ad, Ident id, int depth, FSharpFunc`2<string, string> error);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>> namespaceNotFound@2395(ImportMap amap, Range m, AccessorDomain ad, FSharpRef`1<FSharpOption`1<Tuple`2<Range, ResultOrException`1<FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>>>>> namespaceNotFoundErrorCache, EntityRef modref, ModuleOrNamespaceType mty, Ident id, int depth);
    internal static void notifyNameResolution@2407(TcResultsSink sink, NameResolutionEnv nenv, AccessorDomain ad, bool isOpenDecl, EntityRef modref, Range m);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>> look@2415-9(TcResultsSink sink, ImportMap amap, Range m, NameResolutionEnv nenv, AccessorDomain ad, bool isOpenDecl, FSharpRef`1<FSharpOption`1<Tuple`2<Range, ResultOrException`1<FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>>>>> namespaceNotFoundErrorCache, int depth, EntityRef modref, FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<int, EntityRef, ModuleOrNamespaceType>>> ResolveLongIdentAsModuleOrNamespace(TcResultsSink sink, ImportMap amap, Range m, bool first, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, bool isOpenDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<a>> ResolveLongIdentAsModuleOrNamespaceThen(TcResultsSink sink, ResultCollectionSettings atMostOne, ImportMap amap, Range m, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, bool isOpenDecl, FSharpFunc`2<ResolutionInfo, FSharpFunc`2<int, FSharpFunc`2<Range, FSharpFunc`2<EntityRef, FSharpFunc`2<ModuleOrNamespaceType, FSharpFunc`2<Ident, FSharpFunc`2<FSharpList`1<Ident>, ResultOrException`1<a>>>>>>>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`2<a, Item>> ResolveObjectConstructorPrim(NameResolver ncenv, DisplayEnv edenv, a resInfo, Range m, AccessorDomain ad, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Item> ResolveObjectConstructor(NameResolver ncenv, DisplayEnv denv, Range m, AccessorDomain ad, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<UnionCaseInfo> TryFindUnionCaseOfType(TcGlobals g, TType ty, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Item> TryFindAnonRecdFieldOfType(TcGlobals g, TType ty, string nm);
    internal static string DisplayNameCoreMangled(PropInfo pinfo);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Item> DecodeFSharpEvent$cont@2543(FSharpList`1<PropInfo> pinfos, AccessorDomain ad, TcGlobals g, NameResolver ncenv, Range m, PropInfo pinfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Item> DecodeFSharpEvent(FSharpList`1<PropInfo> pinfos, AccessorDomain ad, TcGlobals g, NameResolver ncenv, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HashSet`1<string> GetRecordLabelsForType(TcGlobals g, NameResolutionEnv nenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> CheckNestedTypesOfType(NameResolver ncenv, ResolutionInfo resInfo, AccessorDomain ad, string nm, TypeNameResolutionInfo typeNameResInfo, Range m, TType ty);
    [CompilerGeneratedAttribute]
internal static void errorTextF$cont@2714(TcGlobals g, Range m, EntityRef tcref, FSharpOption`1<FSharpList`1<RecdFieldRef>> alternative, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> ResolveLongIdentInTypePrim(NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, ResolutionInfo resInfo, int depth, Range m, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, FindMemberFlag findFlag, TypeNameResolutionInfo typeNameResInfo, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> ResolveLongIdentInNestedTypes(NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, ResolutionInfo resInfo, int depth, Ident id, Range m, AccessorDomain ad, Ident id2, FSharpList`1<Ident> rest, FindMemberFlag findFlag, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Item, FSharpList`1<Ident>> ResolveLongIdentInType(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, Range m, AccessorDomain ad, Ident id, FindMemberFlag findFlag, TypeNameResolutionInfo typeNameResInfo, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> ResolveLongIdentInTyconRef(NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, ResolutionInfo resInfo, int depth, Range m, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, TypeNameResolutionInfo typeNameResInfo, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> ResolveLongIdentInTyconRefs(ResultCollectionSettings atMostOne, NameResolver ncenv, NameResolutionEnv nenv, LookupKind lookupKind, int depth, Range m, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, TypeNameResolutionInfo typeNameResInfo, Range idRange, FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>> tcrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<EntityRef> |AccessibleEntityRef|_|(ImportMap amap, Range m, AccessorDomain ad, EntityRef modref, Entity mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>> ResolveExprLongIdentInModuleOrNamespace(NameResolver ncenv, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad, ResolutionInfo resInfo, int depth, Range m, EntityRef modref, ModuleOrNamespaceType mty, Ident id, FSharpList`1<Ident> rest);
    internal static ResultOrException`1<FSharpList`1<Tuple`2<ResolutionInfo, Item>>> ChooseTyconRefInExpr(NameResolver ncenv, Range m, AccessorDomain ad, NameResolutionEnv nenv, Ident id, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>> tcrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>> ResolveUnqualifiedTyconRefs(NameResolutionEnv nenv, FSharpList`1<EntityRef> tcrefs);
    internal static bool canSuggestThisItem@2934(NameResolver ncenv, Item item);
    internal static bool ValIsInEnv@3056(FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, string nm);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> moduleSearch@3069-1(TcResultsSink sink, NameResolver ncenv, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, Ident id, FSharpList`1<Ident> rest, bool isOpenDecl, Range m, AccessorDomain ad, Unit unitVar1);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>>> tyconSearch@3075-3(NameResolver ncenv, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, Ident id, FSharpList`1<Ident> rest, LookupKind lookupKind, Range m, AccessorDomain ad);
    internal static void suggestEverythingInScope@3108(NameResolver ncenv, FullyQualifiedFlag fullyQualified, AccessorDomain ad, NameResolutionEnv nenv, Range m, FSharpFunc`2<string, Unit> addToBuffer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`3<FSharpList`1<TType>, Item, FSharpList`1<Ident>>> ResolveExprLongIdentPrim(TcResultsSink sink, NameResolver ncenv, bool first, FullyQualifiedFlag fullyQualified, Range m, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, Ident id, FSharpList`1<Ident> rest, bool isOpenDecl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`3<FSharpList`1<TType>, Item, FSharpList`1<Ident>>> ResolveExprLongIdent(TcResultsSink sink, NameResolver ncenv, Range m, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<Ident> lid);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<a>>>>> ctorSearch@3185(NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, Range m, Lazy`1<FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>>> tcrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>> ResolvePatternLongIdentInModuleOrNamespace(NameResolver ncenv, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, AccessorDomain ad, ResolutionInfo resInfo, int depth, Range m, EntityRef modref, ModuleOrNamespaceType mty, Ident id, FSharpList`1<Ident> rest);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>>> moduleSearch@3273-5(TcResultsSink sink, NameResolver ncenv, FullyQualifiedFlag fullyQualified, Range m, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, Ident id, FSharpList`1<Ident> rest, AccessorDomain ad);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>>>> tyconSearch@3277-5(NameResolver ncenv, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, Ident id, FSharpList`1<Ident> rest, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ResolvePatternLongIdentPrim(TcResultsSink sink, NameResolver ncenv, FullyQualifiedFlag fullyQualified, WarnOnUpperFlag warnOnUpper, bool newDef, Range m, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, Ident id, FSharpList`1<Ident> rest, ExtraDotAfterIdentifier extraDotAtTheEnd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ResolvePatternLongIdent(TcResultsSink sink, NameResolver ncenv, WarnOnUpperFlag warnOnUpper, bool newDef, Range m, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo numTyArgsOpt, FSharpList`1<Ident> lid, ExtraDotAfterIdentifier extraDotAtTheEnd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ResolveNestedTypeThroughAbbreviation(NameResolver ncenv, EntityRef tcref, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`2<ResolutionInfo, EntityRef>> ResolveTypeLongIdentInTyconRefPrim(NameResolver ncenv, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad, ResolutionInfo resInfo, PermitDirectReferenceToGeneratedType genOk, int depth, Range m, EntityRef tcref, Ident id, FSharpList`1<Ident> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ResolveTypeLongIdentInTyconRef(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad, Range m, EntityRef tcref, FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception SuggestTypeLongIdentInModuleOrNamespace(int depth, EntityRef modref, ImportMap amap, AccessorDomain ad, Range m, Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>>> ResolveTypeLongIdentInModuleOrNamespace(TcResultsSink sink, NameResolutionEnv nenv, NameResolver ncenv, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad, PermitDirectReferenceToGeneratedType genOk, ResolutionInfo resInfo, int depth, Range m, EntityRef modref, ModuleOrNamespaceType _mty, Ident id, FSharpList`1<Ident> rest);
    internal static ResultOrException`1<FSharpList`1<Tuple`2<ResolutionInfo, EntityRef>>> modulSearchFailed@3501(TcResultsSink sink, NameResolver ncenv, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, Ident id, FSharpList`1<Ident> rest, PermitDirectReferenceToGeneratedType genOk, TypeNameResolutionInfo typeNameResInfo, Range m2, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`2<ResolutionInfo, EntityRef>> ResolveTypeLongIdentPrim(TcResultsSink sink, NameResolver ncenv, ItemOccurence occurence, bool first, FullyQualifiedFlag fullyQualified, Range m, NameResolutionEnv nenv, AccessorDomain ad, Ident id, FSharpList`1<Ident> rest, TypeNameResolutionStaticArgsInfo staticResInfo, PermitDirectReferenceToGeneratedType genOk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`2<ResolutionInfo, EntityRef>> ResolveTypeLongIdentAux(TcResultsSink sink, NameResolver ncenv, ItemOccurence occurence, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, AccessorDomain ad, FSharpList`1<Ident> lid, TypeNameResolutionStaticArgsInfo staticResInfo, PermitDirectReferenceToGeneratedType genOk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`2<FSharpList`1<TType>, EntityRef>> ResolveTypeLongIdent(TcResultsSink sink, NameResolver ncenv, ItemOccurence occurence, FullyQualifiedFlag fullyQualified, NameResolutionEnv nenv, AccessorDomain ad, FSharpList`1<Ident> lid, TypeNameResolutionStaticArgsInfo staticResInfo, PermitDirectReferenceToGeneratedType genOk);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`3<ResolutionInfo, FieldResolution, FSharpList`1<Ident>>> ResolveFieldInModuleOrNamespace(NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, ResolutionInfo resInfo, int depth, Range m, EntityRef modref, ModuleOrNamespaceType _mty, Ident id, FSharpList`1<Ident> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static HashSet`1<string> SuggestOtherLabelsOfSameRecordType(TcGlobals g, NameResolutionEnv nenv, TType ty, Ident id, FSharpList`1<Ident> allFields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Exception SuggestLabelsOfRelatedRecords(TcGlobals g, NameResolutionEnv nenv, Ident id, FSharpList`1<Ident> allFields);
    internal static FSharpList`1<Tuple`2<ResolutionInfo, FieldResolution>> lookup@3660-2(NameResolver ncenv, NameResolutionEnv nenv, Ident id, FSharpList`1<Ident> allFields, TcGlobals g, Range m, Unit unitVar0);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, FieldResolution, FSharpList`1<Ident>>>>> tyconSearch@3696-9(NameResolver ncenv, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<Ident> lid, AccessorDomain ad);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<ResolutionInfo, FieldResolution, FSharpList`1<Ident>>>> modulSearch@3709-6(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, Range m, FSharpList`1<Ident> lid, AccessorDomain ad, Unit unitVar1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<ResolutionInfo, FieldResolution>> ResolveFieldPrim(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, TType ty, FSharpList`1<Ident> mp, Ident id, FSharpList`1<Ident> allFields);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FieldResolution> ResolveField(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, TType ty, FSharpList`1<Ident> mp, Ident id, FSharpList`1<Ident> allFields);
    internal static FSharpList`1<Ident> otherRecordFields@3756(NameResolutionEnv nenv, TType ty);
    internal static ResultOrException`1<FSharpList`1<Item>> lookupField@3747(NameResolver ncenv, NameResolutionEnv nenv, TcGlobals g, TType ty, Ident id);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<Ident, Item, FSharpList`1<Ident>>>> fieldSearch@3798(NameResolver ncenv, NameResolutionEnv nenv, TType recdTy, FSharpList`1<Ident> lid, TcGlobals g, Unit unitVar0);
    internal static FSharpFunc`2<Unit, ResultOrException`1<FSharpList`1<Tuple`3<Ident, Item, FSharpList`1<Ident>>>>> tyconSearch@3805-13(NameResolver ncenv, NameResolutionEnv nenv, FSharpList`1<Ident> lid, TypeNameResolutionInfo typeNameResInfo, AccessorDomain ad);
    internal static ResultOrException`1<FSharpList`1<Tuple`3<Ident, Item, FSharpList`1<Ident>>>> moduleOrNsSearch@3822(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, FSharpList`1<Ident> lid, AccessorDomain ad, Unit unitVar1);
    internal static FSharpList`1<Tuple`2<Ident, Item>> nestedFieldSearch@3851(NameResolver ncenv, NameResolutionEnv nenv, TcGlobals g, FSharpList`1<Tuple`2<Ident, Item>> fields, TType parentTy, FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Ident>, FSharpList`1<Tuple`2<Ident, Item>>> ResolveNestedField(TcResultsSink sink, NameResolver ncenv, NameResolutionEnv nenv, AccessorDomain ad, TType recdTy, FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<ResolutionInfo, Item, FSharpList`1<Ident>> ResolveExprDotLongIdent(NameResolver ncenv, Range m, AccessorDomain ad, NameResolutionEnv nenv, TType ty, Ident id, FSharpList`1<Ident> rest, TypeNameResolutionInfo typeNameResInfo, FindMemberFlag findFlag);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range ComputeItemRange(Range wholem, FSharpList`1<Ident> lid, FSharpList`1<a> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item FilterMethodGroups(NameResolver ncenv, Range itemRange, Item item, bool staticOnly);
    internal static bool NeedsWorkAfterResolution(Item namedItem);
    internal static void callSink@3976(TcResultsSink sink, AccessorDomain ad, NameResolutionEnv nenv, Range itemRange, Item item, bool isFakeIdents, Item refinedItem, FSharpList`1<Tuple`2<Typar, TType>> tpinst);
    [CompilerGeneratedAttribute]
internal static ResultOrException`1<Tuple`5<FSharpList`1<TType>, Item, Range, FSharpList`1<Ident>, AfterResolution>> ResolveLongIdentAsExprAndComputeRange$cont@3960(TcResultsSink sink, NameResolver ncenv, Range wholem, AccessorDomain ad, NameResolutionEnv nenv, FSharpList`1<Ident> lid, ResultOrException`1<Tuple`3<FSharpList`1<TType>, Item, FSharpList`1<Ident>>> matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<Tuple`5<FSharpList`1<TType>, Item, Range, FSharpList`1<Ident>, AfterResolution>> ResolveLongIdentAsExprAndComputeRange(TcResultsSink sink, NameResolver ncenv, Range wholem, AccessorDomain ad, NameResolutionEnv nenv, TypeNameResolutionInfo typeNameResInfo, FSharpList`1<Ident> lid);
    internal static FSharpOption`1<Unit> |NonOverridable|_|(Item namedItem);
    internal static Tuple`4<ResolutionInfo, Item, FSharpList`1<Ident>, Range> resolveExpr@4018(NameResolver ncenv, Range wholem, AccessorDomain ad, NameResolutionEnv nenv, TType ty, FSharpList`1<Ident> lid, TypeNameResolutionInfo typeNameResInfo, FindMemberFlag findFlag);
    internal static void callSink@4046-1(TcResultsSink sink, NameResolver ncenv, AccessorDomain ad, NameResolutionEnv nenv, bool staticOnly, Item unrefinedItem, Range itemRange, Item refinedItem, FSharpList`1<Tuple`2<Typar, TType>> tpinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<Item, Range, FSharpList`1<Ident>, AfterResolution> ResolveExprDotLongIdentAndComputeRange(TcResultsSink sink, NameResolver ncenv, Range wholem, AccessorDomain ad, NameResolutionEnv nenv, TType ty, FSharpList`1<Ident> lid, TypeNameResolutionInfo typeNameResInfo, FindMemberFlag findFlag, bool staticOnly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> FakeInstantiationGenerator(Range _m, FSharpList`1<Typar> gps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsTyconUnseenObsoleteSpec(AccessorDomain ad, TcGlobals g, ImportMap amap, Range m, EntityRef x, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsValUnseen(AccessorDomain ad, TcGlobals g, a m, ValRef v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsUnionCaseUnseen(AccessorDomain ad, TcGlobals g, ImportMap amap, Range m, UnionCaseRef ucref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ItemIsUnseen(AccessorDomain ad, TcGlobals g, ImportMap amap, Range m, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ItemOfTyconRef(NameResolver ncenv, Range m, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Item ItemOfTy(TcGlobals g, TType x);
    internal static bool IsInterestingModuleName(string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> PartialResolveLookupInModuleOrNamespaceAsModuleOrNamespaceThen(FSharpFunc`2<EntityRef, FSharpList`1<a>> f, FSharpList`1<string> plid, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> PartialResolveLongIdentAsModuleOrNamespaceThen(NameResolutionEnv nenv, FSharpList`1<string> plid, FSharpFunc`2<EntityRef, FSharpList`1<a>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolveRecordOrClassFieldsOfType(NameResolver ncenv, Range m, AccessorDomain ad, TType ty, bool statics);
    internal static FSharpFunc`2<MethInfo, bool> minfoFilter@4246(ResolveCompletionTargets completionTargets, Range m, AccessorDomain ad, bool statics, TType ty, TcGlobals g, ImportMap amap, Set`2<string, IComparer`1<string>> suppressedMethNames);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<MethInfo> minfos$cont@4311(ResolveCompletionTargets completionTargets, Range m, AccessorDomain ad, bool statics, TType ty, TcGlobals g, ImportMap amap, FSharpList`1<string> pinfoMethNames, FSharpList`1<string> einfoMethNames, FSharpList`1<Item> pinfoItems, FSharpList`1<MethInfo> minfos, Unit unitVar);
    internal static FSharpMap`2<string, FSharpList`1<MethInfo>> partitionl@4357(FSharpList`1<MethInfo> l, FSharpMap`2<string, FSharpList`1<MethInfo>> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolveCompletionsInType(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets completionTargets, Range m, AccessorDomain ad, bool statics, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType FullTypeOfPropInfo(TcGlobals g, ImportMap amap, Range m, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentInType(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets isApplicableMeth, Range m, AccessorDomain ad, bool statics, FSharpList`1<string> plid, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Item> InfosForTyconConstructors(NameResolver ncenv, Range m, AccessorDomain ad, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EntityRefContainsSomethingAccessible(NameResolver ncenv, Range m, AccessorDomain ad, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<EntityRef> GetVisibleNamespacesAndModulesAtPoint(NameResolver ncenv, NameResolutionEnv nenv, FullyQualifiedFlag fullyQualified, Range m, AccessorDomain ad);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> GetAccessibleSubModules(TcGlobals g, NameResolver ncenv, EntityRef modref, Range m, AccessorDomain ad);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Item> ResolvePartialLongIdentInModuleOrNamespace$cont@4553(NameResolver ncenv, Range m, AccessorDomain ad, EntityRef modref, TcGlobals g, ModuleOrNamespaceType mty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentInModuleOrNamespace(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets isApplicableMeth, Range m, AccessorDomain ad, EntityRef modref, FSharpList`1<string> plid, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> TryToResolveLongIdentAsType(NameResolver ncenv, NameResolutionEnv nenv, Range m, FSharpList`1<string> plid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentPrim(NameResolver ncenv, NameResolutionEnv nenv, ResolveCompletionTargets isApplicableMeth, FullyQualifiedFlag fullyQualified, Range m, AccessorDomain ad, FSharpList`1<string> plid, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdent(NameResolver ncenv, NameResolutionEnv nenv, FSharpFunc`2<MethInfo, FSharpFunc`2<TType, bool>> isApplicableMeth, Range m, AccessorDomain ad, FSharpList`1<string> plid, bool allowObsolete);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentInModuleOrNamespaceForRecordFields(NameResolver ncenv, a nenv, Range m, AccessorDomain ad, EntityRef modref, FSharpList`1<string> plid, bool allowObsolete);
    internal static FSharpList`1<Item> getRecordFieldsInScope(NameResolutionEnv nenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentToClassOrRecdFields(NameResolver ncenv, NameResolutionEnv nenv, Range m, AccessorDomain ad, FSharpList`1<string> plid, bool allowObsolete, bool fieldsOnly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Item> ResolvePartialLongIdentToClassOrRecdFieldsImpl(NameResolver ncenv, NameResolutionEnv nenv, FullyQualifiedFlag fullyQualified, Range m, AccessorDomain ad, FSharpList`1<string> plid, bool allowObsolete, bool fieldsOnly);
    internal static FSharpFunc`2<MethInfo, bool> minfoFilter@4951-2(Range m, AccessorDomain ad, bool statics, TType ty, TcGlobals g, ImportMap amap, Set`2<string, IComparer`1<string>> suppressedMethNames);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<MethInfo> minfos$cont@5005-1(Range m, AccessorDomain ad, bool statics, TType ty, TcGlobals g, ImportMap amap, FSharpList`1<string> pinfoMethNames, FSharpList`1<string> einfoMethNames, FSharpList`1<Item> pinfoItems, FSharpList`1<MethInfo> minfos, Unit unitVar);
    internal static FSharpMap`2<string, FSharpList`1<MethInfo>> partitionl@5047-1(FSharpList`1<MethInfo> l, FSharpMap`2<string, FSharpList`1<MethInfo>> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Item> ResolveCompletionsInTypeForItem(NameResolver ncenv, NameResolutionEnv nenv, Range m, AccessorDomain ad, bool statics, TType ty, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Item> ResolvePartialLongIdentInTypeForItem(NameResolver ncenv, NameResolutionEnv nenv, Range m, AccessorDomain ad, bool statics, FSharpList`1<string> plid, Item item, TType ty);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Item> ResolvePartialLongIdentInModuleOrNamespaceForItem$cont@5116(NameResolver ncenv, Range m, AccessorDomain ad, EntityRef modref, Item item, TcGlobals g, ModuleOrNamespaceType mty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Item> ResolvePartialLongIdentInModuleOrNamespaceForItem(NameResolver ncenv, NameResolutionEnv nenv, Range m, AccessorDomain ad, EntityRef modref, FSharpList`1<string> plid, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<a> PartialResolveLookupInModuleOrNamespaceAsModuleOrNamespaceThenLazy(FSharpFunc`2<EntityRef, IEnumerable`1<a>> f, FSharpList`1<string> plid, EntityRef modref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<a> PartialResolveLongIdentAsModuleOrNamespaceThenLazy(NameResolutionEnv nenv, FSharpList`1<string> plid, FSharpFunc`2<EntityRef, IEnumerable`1<a>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<Item> GetCompletionForItem(NameResolver ncenv, NameResolutionEnv nenv, Range m, AccessorDomain ad, FSharpList`1<string> plid, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsItemResolvable(NameResolver ncenv, NameResolutionEnv nenv, Range m, AccessorDomain ad, FSharpList`1<string> plid, Item item);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.NicePrint : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutTyparConstraint(DisplayEnv denv, Typar x_0, TyparConstraint x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputType(DisplayEnv denv, StringBuilder os, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutType(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputTypars(DisplayEnv denv, TaggedText nm, StringBuilder os, FSharpList`1<Typar> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputTyconRef(DisplayEnv denv, StringBuilder os, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutTyconRef(DisplayEnv denv, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutConst(TcGlobals g, TType ty, Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfMemberSig(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> x_0, string x_1, FSharpList`1<Typar> x_2, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> x_3, TType x_4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<TType, Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, Layout>> prettyLayoutOfUncurriedSig(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> argInfos, FSharpList`1<Tuple`2<TType, ArgReprInfo>> tau);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Layout, Layout, Layout> prettyLayoutsOfUnresolvedOverloading(DisplayEnv denv, FSharpList`1<Tuple`2<TType, ArgReprInfo>> argInfos, TType retTy, IEnumerable`1<TType> genericParameters);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout dataExprL(DisplayEnv denv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputValOrMember(DisplayEnv denv, InfoReader infoReader, StringBuilder os, ValRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringValOrMember(DisplayEnv denv, InfoReader infoReader, ValRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, Layout> layoutQualifiedValOrMember(DisplayEnv denv, InfoReader infoReader, FSharpList`1<Tuple`2<Typar, TType>> typarInst, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputQualifiedValOrMember(DisplayEnv denv, InfoReader infoReader, StringBuilder os, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outputQualifiedValSpec(DisplayEnv denv, InfoReader infoReader, StringBuilder os, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfQualifiedValOrMember(DisplayEnv denv, InfoReader infoReader, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void formatMethInfoToBufferFreeStyle(InfoReader infoReader, Range m, DisplayEnv denv, StringBuilder buf, MethInfo d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, Layout> prettyLayoutOfMethInfoFreeStyle(InfoReader infoReader, Range m, DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> typarInst, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfPropInfoFreeStyle(TcGlobals g, ImportMap amap, Range m, DisplayEnv denv, PropInfo d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfMethInfo(InfoReader infoReader, Range m, DisplayEnv denv, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfMethInfoFSharpStyle(InfoReader infoReader, Range m, DisplayEnv denv, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string multiLineStringOfMethInfos(InfoReader infoReader, Range m, DisplayEnv denv, FSharpList`1<MethInfo> minfos);
    [CompilerGeneratedAttribute]
internal static void f@284-4(TcGlobals g, ImportMap amap, Range m, DisplayEnv denv, PropInfo pinfo, StringBuilder buf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfPropInfo(TcGlobals g, ImportMap amap, Range m, DisplayEnv denv, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string multiLineStringOfPropInfos(TcGlobals g, ImportMap amap, Range m, DisplayEnv denv, FSharpList`1<PropInfo> pinfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfParamData(DisplayEnv denv, ParamData paramData);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutOfParamData(DisplayEnv denv, ParamData paramData);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutExnDef(DisplayEnv denv, InfoReader infoReader, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfTyparConstraints(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TyparConstraint>> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutTyconDefn(DisplayEnv denv, InfoReader infoReader, AccessorDomain ad, Range m, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutEntityDefn(DisplayEnv denv, InfoReader infoReader, AccessorDomain ad, Range m, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutUnionCases(DisplayEnv denv, InfoReader infoReader, EntityRef enclosingTcref, FSharpList`1<RecdField> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isGeneratedUnionCaseField(int pos, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isGeneratedExceptionField(a pos, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfTyparConstraint(DisplayEnv denv, Typar tpc_0, TyparConstraint tpc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfTy(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfType(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfTrait(DisplayEnv denv, TraitConstraintInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfTypeNoCx(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfTypar(DisplayEnv denv, Typar x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string prettyStringOfTy(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string prettyStringOfTyNoCx(DisplayEnv denv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfRecdField(DisplayEnv denv, InfoReader infoReader, EntityRef enclosingTcref, RecdField x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfUnionCase(DisplayEnv denv, InfoReader infoReader, EntityRef enclosingTcref, UnionCase x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfExnDef(DisplayEnv denv, InfoReader infoReader, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfFSAttrib(DisplayEnv denv, Attrib x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string stringOfILAttrib(DisplayEnv denv, ILType x_0, FSharpList`1<ILAttribElem> x_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string fqnOfEntityRef(TcGlobals g, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutImpliedSignatureOfModuleOrNamespace(bool showHeader, DisplayEnv denv, InfoReader infoReader, AccessorDomain ad, Range m, ModuleOrNamespaceContents contents);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, Layout> prettyLayoutOfValOrMember(DisplayEnv denv, InfoReader infoReader, FSharpList`1<Tuple`2<Typar, TType>> typarInst, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfValOrMemberNoInst(DisplayEnv denv, InfoReader infoReader, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout prettyLayoutOfMemberNoInstShort(DisplayEnv denv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout layoutOfValReturnType(DisplayEnv denv, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Tuple`2<Typar, TType>>, Tuple`2<FSharpList`1<TType>, TType>, Tuple`2<FSharpList`1<Layout>, Layout>, Layout> prettyLayoutOfInstAndSig(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> x_0, FSharpList`1<TType> x_1, TType x_2);
    internal static string makeName@2795(DisplayEnv denv, TType t);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, string, string> minimalStringsOfTwoTypes$cont@2780-1(DisplayEnv denv, TType ty2, TType ty1, FSharpList`1<Tuple`2<Typar, TyparConstraint>> tpcs, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`3<string, string, string> minimalStringsOfTwoTypes$cont@2761(DisplayEnv denv, TType ty2, TType ty1, FSharpList`1<Tuple`2<Typar, TyparConstraint>> tpcs, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<string, string, string> minimalStringsOfTwoTypes(DisplayEnv denv, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<string, string> minimalStringsOfTwoValues(DisplayEnv denv, InfoReader infoReader, ValRef vref1, ValRef vref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string minimalStringOfType(DisplayEnv denv, TType ty);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.OptimizeInputs : object {
    [CompilationMappingAttribute("9")]
internal static int showTermFileCount { get; internal set; }
    internal static int get_showTermFileCount();
    internal static void set_showTermFileCount(int value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void PrintWholeAssemblyImplementation(TcConfig tcConfig, string outfile, string header, FSharpList`1<CheckedImplFile> expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv AddExternalCcuToOptimizationEnv(TcGlobals tcGlobals, IncrementalOptimizationEnv optEnv, ImportedAssembly ccuinfo);
    internal static IncrementalOptimizationEnv GetInitialOptimizationEnv(TcImports tcImports, TcGlobals tcGlobals);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<CheckedImplFileAfterOptimization, Lazy`1<ModuleInfo>>>, IncrementalOptimizationEnv> optimizeFilesSequentially(IncrementalOptimizationEnv optEnv, PhaseInfo[] phases, FSharpList`1<CheckedImplFile> implFiles);
    internal static FSharpFunc`2<PhaseInputs, Tuple`2<CheckedImplFile, PhaseContext>> addPhaseDiagnostics@348(FSharpFunc`2<PhaseInputs, Tuple`2<CheckedImplFile, PhaseContext>> f, Phase info);
    internal static void addPhase@363(List`1<PhaseInfo> phases, string name, FSharpFunc`2<PhaseInputs, Tuple`2<CheckedImplFile, PhaseContext>> phaseFunc);
    internal static Tuple`3<CheckedAssemblyAfterOptimization, Lazy`1<ModuleInfo>, IncrementalOptimizationEnv> ApplyAllOptimizations(TcConfig tcConfig, TcGlobals tcGlobals, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, string outfile, ImportMap importMap, bool isIncrementalFragment, IncrementalOptimizationEnv optEnv, CcuThunk ccu, FSharpList`1<CheckedImplFile> implFiles);
    internal static IlxAssemblyGenerator CreateIlxAssemblyGenerator(TcConfig _tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, CcuThunk generatedCcu);
    internal static IlxGenResults GenerateIlxCode(IlxGenBackend ilxBackend, bool isInteractiveItExpr, TcConfig tcConfig, TopAttribs topAttrs, CheckedAssemblyAfterOptimization optimizedImpls, string fragName, IlxAssemblyGenerator ilxGenerator);
    internal static ILScopeRef normalizeAssemblyRefByName@612(TcImports tcImports, CompilationThreadToken ctok, ILScopeRef scoref, string nm);
    internal static FSharpFunc`2<ILScopeRef, ILScopeRef> NormalizeAssemblyRefs(CompilationThreadToken ctok, ILGlobals ilGlobals, TcImports tcImports);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string GetGeneratedILModuleName(CompilerTarget t, string s);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Optimizer : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int callSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int forAndWhileLoopSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int tryWithSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int tryFinallySize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int closureTotalSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int methodDefnTotalSize;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int minDepthForASizeNode;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool jitOptDefault;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool localOptDefault;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool crossAssemblyOptimizationDefault;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static bool debugPointsForPipeRightDefault;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int localVarSize;
    [CompilationMappingAttribute("9")]
internal static int OptimizerStackGuardDepth { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<ILInstr> i_ldlen { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<ModuleInfo> EmptyModuleInfo { get; }
    [CompilationMappingAttribute("9")]
internal static ValInfo UnknownValInfo { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Summary`1<ExprValueInfo>>> NoExprs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> AbstractOptimizationInfoToEssentials { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> abstractLazyModulInfo@1399-1 { get; }
    private static Optimizer();
    internal static int get_OptimizerStackGuardDepth();
    internal static FSharpList`1<ILInstr> get_i_ldlen();
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@210-40(Summary`1<Info> this, Summary`1<Info> obj, int n, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@210-41(Summary`1<Info> this, Summary`1<Info> objTemp, int n, Unit unitVar);
    internal static int SizeOfValueInfos(ExprValueInfo[] arr);
    internal static int SizeOfValueInfo(ExprValueInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprValueInfo MakeValueInfoWithCachedSize(int vdepth, ExprValueInfo v);
    internal static ExprValueInfo bound@260(int depth, ExprValueInfo x);
    internal static ExprValueInfo BoundValueInfoBySize(ExprValueInfo vinfo);
    internal static bool IsPartialExprVal(ExprValueInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInlineValueIsComplete(Val v, ExprValueInfo res);
    internal static Lazy`1<ModuleInfo> get_EmptyModuleInfo();
    internal static Lazy`1<ModuleInfo> UnionOptimizationInfos(IEnumerable`1<Lazy`1<ModuleInfo>> minfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<ModuleInfo> FindOrCreateModuleInfo(a n, FSharpMap`2<a, Lazy`1<ModuleInfo>> ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<ModuleInfo> FindOrCreateGlobalModuleInfo(a n, FSharpMap`2<a, Lazy`1<ModuleInfo>> ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleInfo BindValueInSubModuleFSharpCore(String[] mp, int i, Val v, ValInfo vval, ModuleInfo ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, Lazy`1<ModuleInfo>> BindValueInModuleForFslib(string n, String[] mp, int i, Val v, ValInfo vval, FSharpMap`2<string, Lazy`1<ModuleInfo>> ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<a, Lazy`1<ModuleInfo>> BindValueInGlobalModuleForFslib(a n, String[] mp, int i, Val v, ValInfo vval, FSharpMap`2<a, Lazy`1<ModuleInfo>> ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindValueForFslib(NonLocalValOrMemberRef nlvref, Val v, ValInfo vval, IncrementalOptimizationEnv env);
    internal static ValInfo get_UnknownValInfo();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a BindInternalLocalVal(cenv cenv, Val v, ValInfo vval, a env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindExternalLocalVal(cenv cenv, Val v, ValInfo vval, IncrementalOptimizationEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindValsInModuleOrNamespace(cenv cenv, Lazy`1<ModuleInfo> mval, IncrementalOptimizationEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindTypar(Typar tyv, TypeValueInfo typeinfo, IncrementalOptimizationEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindTyparsToUnknown(FSharpList`1<Typar> tps, IncrementalOptimizationEnv env);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IncrementalOptimizationEnv BindCcu(CcuThunk ccu, Lazy`1<ModuleInfo> mval, IncrementalOptimizationEnv env, TcGlobals _g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValInfo GetInfoForLocalValue(cenv cenv, IncrementalOptimizationEnv env, Val v, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ModuleInfo> TryGetInfoForEntity(ModuleInfo sv, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ModuleInfo> TryGetInfoForPath(ModuleInfo sv, String[] p, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ModuleInfo> TryGetInfoForNonLocalEntityRef(IncrementalOptimizationEnv env, NonLocalEntityRef nleref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValInfo GetInfoForNonLocalVal(cenv cenv, IncrementalOptimizationEnv env, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValInfo GetInfoForVal(cenv cenv, IncrementalOptimizationEnv env, Range m, ValRef vref);
    internal static ExprValueInfo stripValue(ExprValueInfo _arg1);
    internal static FSharpOption`1<Const> |StripConstValue|_|(ExprValueInfo ev);
    internal static FSharpOption`1<Tuple`5<long, int, int, Expr, TType>> |StripLambdaValue|_|(ExprValueInfo ev);
    internal static FSharpOption`1<ExprValueInfo[]> destTupleValue(ExprValueInfo ev);
    internal static FSharpOption`1<ExprValueInfo[]> destRecdValue(ExprValueInfo ev);
    internal static FSharpOption`1<Tuple`2<UnionCaseRef, ExprValueInfo[]>> |StripUnionCaseValue|_|(ExprValueInfo ev);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@803(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@803-1(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@803-2(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@803-3(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@803-4(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerBinaryOp$cont@803-5(TcGlobals g, Const c2, Const c1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<ExprValueInfo> IntegerUnaryOp$cont@774(TcGlobals g, Const c, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@863(TcGlobals g, ExprValueInfo a, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static ExprValueInfo mkAssemblyCodeValueInfo$cont@1237-1(TcGlobals g, TType ty, bool a, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprValueInfo mkAssemblyCodeValueInfo(TcGlobals g, FSharpList`1<ILInstr> instrs, FSharpList`1<ExprValueInfo> argvals, FSharpList`1<TType> tys);
    internal static int AddTotalSizes(FSharpList`1<Summary`1<a>> l);
    internal static int AddFunctionSizes(FSharpList`1<Summary`1<a>> l);
    internal static bool OrEffects(FSharpList`1<Summary`1<a>> l);
    internal static bool OrTailcalls(FSharpList`1<Summary`1<a>> l);
    internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Summary`1<ExprValueInfo>>> get_NoExprs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Summary`1<b> CombineValueInfos(FSharpList`1<Summary`1<a>> einfos, b res);
    internal static ExprValueInfo abstractExprInfo@1322(bool isAssemblyBoundary, FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> abstractLazyModulInfo, FSharpFunc`2<Entity, bool> hiddenTycon, FSharpFunc`2<Entity, bool> hiddenTyconRepr, FSharpFunc`2<Val, bool> hiddenVal, FSharpFunc`2<RecdFieldRef, bool> hiddenRecdField, FSharpFunc`2<UnionCaseRef, bool> hiddenUnionCase, ExprValueInfo ivalue);
    internal static ModuleInfo abstractModulInfo@1380(bool isAssemblyBoundary, FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> abstractLazyModulInfo, FSharpFunc`2<Entity, bool> hiddenTycon, FSharpFunc`2<Entity, bool> hiddenTyconRepr, FSharpFunc`2<Val, bool> hiddenVal, FSharpFunc`2<RecdFieldRef, bool> hiddenRecdField, FSharpFunc`2<UnionCaseRef, bool> hiddenUnionCase, ModuleInfo ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> AbstractLazyModulInfoByHiding(bool isAssemblyBoundary, SignatureHidingInfo mhi);
    internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> get_AbstractOptimizationInfoToEssentials();
    internal static ModuleInfo abstractModulInfo@1395-3(ModuleInfo ss);
    internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> get_abstractLazyModulInfo@1399-1();
    internal static ExprValueInfo abstractExprInfo@1414-1(FSharpList`1<Typar> boundTyVars, FSharpList`1<Val> boundVars, ExprValueInfo ivalue);
    internal static ModuleInfo abstractModulInfo@1461-6(FSharpList`1<Typar> boundTyVars, FSharpList`1<Val> boundVars, ModuleInfo ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprValueInfo AbstractExprInfoByVars(FSharpList`1<Val> boundVars, FSharpList`1<Typar> boundTyVars, ExprValueInfo ivalue);
    internal static ExprValueInfo remapExprInfo@1472(TcGlobals g, Remap tmenv, ExprValueInfo ivalue);
    internal static ModuleInfo remapModulInfo@1488(TcGlobals g, Remap tmenv, FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> remapLazyModulInfo, ModuleInfo ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Lazy`1<ModuleInfo>, Lazy`1<ModuleInfo>> RemapOptimizationInfo(TcGlobals g, Remap tmenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Lazy`1<ModuleInfo> AbstractAndRemapModulInfo(TcGlobals g, SignatureRepackageInfo repackage, SignatureHidingInfo hidden, Lazy`1<ModuleInfo> info);
    internal static bool IsTyFuncValRefExpr(Expr _arg1);
    internal static bool IsSmallConstExpr(Expr x);
    internal static ExprValueInfo ValueOfExpr(Expr expr);
    internal static bool IsMutableStructuralBindingForTupleElement(ValRef vref);
    internal static bool IsMutableForOutArg(ValRef vref);
    internal static bool IsKnownOnlyMutableBeforeUse(ValRef vref);
    internal static bool IsDiscardableEffectExpr(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValueIsUsedOrHasEffect(cenv cenv, FSharpFunc`2<Unit, Set`2<Val, IComparer`1<Val>>> fvs, Binding b, Summary`1<a> binfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Summary`1<a>>> SplitValuesByIsUsedOrHasEffect(cenv cenv, FSharpFunc`2<Unit, Set`2<Val, IComparer`1<Val>>> fvs, FSharpList`1<Tuple`2<Binding, Summary`1<a>>> x);
    internal static bool IlAssemblyCodeInstrHasEffect(ILInstr i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExprHasEffect(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExprsHaveEffect(TcGlobals g, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool BindingsHaveEffect(TcGlobals g, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool BindingHasEffect(TcGlobals g, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool OpHasEffect(TcGlobals g, Range m, TOp op);
    internal static bool IsUniqueUse@1683(Val vspec1, Val vspec2, FSharpList`1<Expr> args);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<Expr>, FSharpList`1<Expr>>> GetImmediateUseContext@1690(TcGlobals g, Val vspec1, FSharpList`1<Expr> rargsl, FSharpList`1<Expr> argsr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryEliminateBinding(cenv cenv, a _env, Binding bind, Expr e2, b _m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, int> TryEliminateLet(cenv cenv, a env, Binding bind, Expr e2, Range m);
    internal static FSharpOption`1<Tuple`3<ValRef, FSharpList`1<TType>, FSharpList`1<Expr>>> |KnownValApp|_|(Expr expr);
    internal static FSharpOption`1<Tuple`5<Expr, bool, DecisionTree, DecisionTree, Range>> |TDBoolSwitch|_|(DecisionTree dtree);
    internal static FSharpOption`1<bool> |ConstantBoolTarget|_|(DecisionTreeTarget target);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<int, int> CountBoolLogicTree(DecisionTreeTarget[] targets, int costOuterCaseTree, int costOuterDefaultTree, bool testBool, DecisionTree tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree RewriteBoolLogicTree(DecisionTreeTarget[] targets, DecisionTree outerCaseTree, DecisionTree outerDefaultTree, bool testBool, DecisionTree tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTreeCase RewriteBoolLogicCase(DecisionTreeTarget[] data_0, DecisionTree data_1, DecisionTree data_2, bool data_3, DecisionTreeCase _arg1);
    internal static Expr CombineBoolLogic(Expr expr);
    internal static bool CanExpandStructuralBinding(Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> MakeStructuralBindingTempVal(Val v, a i, Expr arg, TType argTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Binding> MakeStructuralBindingTemp(Val v, a i, Expr arg, TType argTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Binding> MakeMutableStructuralBindingForTupleElement(Val v, int i, Expr arg, TType argTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr ExpandStructuralBindingRaw(cenv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> RearrangeTupleBindings(Expr expr, FSharpFunc`2<Expr, Expr> fin);
    internal static FSharpOption`1<Expr> dive@1963(TcGlobals g, Range m, Lazy`1<Tuple`4<a, b, c, FSharpList`1<ValRef>>> requisites, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryRewriteBranchingTupleBinding(TcGlobals g, Val v, Expr rhs, DebugPointAtBinding tgtSeqPtOpt, Expr body, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr ExpandStructuralBinding(cenv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, FSharpOption`1<TType>>> |QueryRun|_|(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`4<ValRef, FSharpList`1<TType>, Expr, FSharpList`1<Expr>>> |AnyInstanceMethodApp|_|(Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<FSharpList`1<TType>, Expr, FSharpList`1<Expr>>> |InstanceMethodApp|_|(TcGlobals g, ValRef expectedValRef, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TType, Expr>> |QuerySourceEnumerable|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<TType, TType, TType, Expr, Expr>> |QueryFor|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<TType, TType, Expr>> |QueryYield|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<TType, TType, Expr>> |QueryYieldFrom|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<TType, TType, TType, Expr, Expr>> |QuerySelect|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TType, TType>> |QueryZero|_|(TcGlobals g, Expr _arg1);
    internal static Tuple`2<FSharpList`1<Expr>, FSharpFunc`2<FSharpList`1<Expr>, Expr>> |AnyRefTupleTrans|(Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, FSharpFunc`2<Expr, Expr>>> |AnyQueryBuilderOpTrans|_|(TcGlobals g, Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> tryRewriteToSeqCombinators(TcGlobals g, Expr e);
    internal static FSharpOption`1<Tuple`2<Expr, FSharpOption`1<Tuple`2<TType, TType>>>> loopOuter@2206(TcGlobals g, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryDetectQueryQuoteAndRun(cenv cenv, Expr expr);
    internal static bool IsILMethodRefSystemStringConcat(ILMethodRef mref);
    internal static bool IsILMethodRefSystemStringConcatArray(ILMethodRef mref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsDebugPipeRightExpr(cenv cenv, Expr expr);
    internal static Tuple`4<h, i, FSharpList`1<Expr>, j> doData@2327-5(cenv cenv, IncrementalOptimizationEnv env, h data0, i data1, FSharpList`1<Expr> data2, j data3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExpr(cenv cenv, IncrementalOptimizationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeObjectExpr(cenv cenv, IncrementalOptimizationEnv env, TType ty, FSharpOption`1<Val> baseValOpt, Expr basecall, FSharpList`1<ObjExprMethod> overrides, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> iimpls, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<ObjExprMethod>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeMethods(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<Val> baseValOpt, FSharpList`1<ObjExprMethod> methods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ObjExprMethod, Summary`1<ExprValueInfo>> OptimizeMethod(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<Val> baseValOpt, ObjExprMethod tmethod);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeInterfaceImpls(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<Val> baseValOpt, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> iimpls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<TType, FSharpList`1<ObjExprMethod>>, Summary`1<ExprValueInfo>> OptimizeInterfaceImpl(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<Val> baseValOpt, TType ty, FSharpList`1<ObjExprMethod> overrides);
    internal static FSharpList`1<Expr> optimizeArg@2459(Expr argExpr, FSharpList`1<Expr> accArgs);
    internal static FSharpList`1<Expr> optimizeArgs@2478(FSharpList`1<Expr> args, FSharpList`1<Expr> accArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> MakeOptimizedSystemStringConcatCall(cenv cenv, IncrementalOptimizationEnv env, Range m, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprOp(cenv cenv, IncrementalOptimizationEnv env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprOpReductions(cenv cenv, IncrementalOptimizationEnv env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprOpReductionsAfter(cenv cenv, IncrementalOptimizationEnv env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> argsR, FSharpList`1<Summary`1<ExprValueInfo>> arginfos, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprOpFallback(cenv cenv, IncrementalOptimizationEnv env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> argsR, Range m, FSharpList`1<Summary`1<ExprValueInfo>> arginfos, ExprValueInfo valu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeConst(cenv cenv, IncrementalOptimizationEnv env, Expr expr, Const c, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ExprValueInfo> TryOptimizeRecordFieldGet(cenv cenv, IncrementalOptimizationEnv _env, Summary`1<ExprValueInfo> e1info, RecdFieldRef r, FSharpList`1<TType> _tinst, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ExprValueInfo> TryOptimizeTupleFieldGet(cenv cenv, IncrementalOptimizationEnv _env, TupInfo _tupInfo, Summary`1<ExprValueInfo> e1info, FSharpList`1<TType> tys, int n, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ExprValueInfo> TryOptimizeUnionCaseGet(cenv cenv, IncrementalOptimizationEnv _env, Summary`1<ExprValueInfo> e1info, UnionCaseRef cspec, FSharpList`1<TType> _tys, int n, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeFastIntegerForLoop(cenv cenv, IncrementalOptimizationEnv env, DebugPointAtFor spFor, DebugPointAtInOrTo spTo, Val v, Expr e1, ForLoopStyle dir, Expr e2, Expr e3, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeLetRec(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<Binding> binds, Expr bodyExpr, Range m);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-9(cenv cenv, Range m, SequentialOpKind flag, Summary`1<ExprValueInfo> e1info, Expr e1R, Expr e2R, Summary`1<ExprValueInfo> e2info);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-10(cenv cenv, Range m, IncrementalOptimizationEnv env, Summary`1<ExprValueInfo> bindingInfo, Binding bindR, Expr bodyR, Summary`1<ExprValueInfo> bodyInfo);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-12(cenv cenv, IncrementalOptimizationEnv env, TType ty, DebugPointAtBinding spMatch, Range mExpr, Range m, DecisionTree dtreeR, Summary`1<ExprValueInfo> dinfo, Summary`1<ExprValueInfo> tg1info, DecisionTreeTarget tg1, Expr e2, Summary`1<ExprValueInfo> e2info);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-13(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<TType> tyargs, TOp op, Range m, FSharpList`1<Expr> argsHeadR, FSharpList`1<Summary`1<ExprValueInfo>> argsHeadInfosR, Expr argLastR, Summary`1<ExprValueInfo> argLastInfo);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> func1@1-14(DebugPointAtLeafExpr m, Expr tupledArg0, Summary`1<ExprValueInfo> tupledArg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeLinearExpr(cenv cenv, IncrementalOptimizationEnv env, Expr expr, FSharpFunc`2<Tuple`2<Expr, Summary`1<ExprValueInfo>>, Tuple`2<Expr, Summary`1<ExprValueInfo>>> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeTryFinally(cenv cenv, IncrementalOptimizationEnv env, DebugPointAtTry spTry, DebugPointAtFinally spFinally, Expr e1, Expr e2, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeTryWith(cenv cenv, IncrementalOptimizationEnv env, Expr e1, Val vf, Expr ef, Val vh, Expr eh, Range m, TType ty, DebugPointAtTry spTry, DebugPointAtWith spWith);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeWhileLoop(cenv cenv, IncrementalOptimizationEnv env, DebugPointAtWhile spWhile, SpecialWhileLoopMarker marker, Expr e1, Expr e2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeTraitCall(cenv cenv, IncrementalOptimizationEnv env, TraitConstraintInfo traitInfo, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CopyExprForInlining(cenv cenv, bool isInlineIfLambda, Expr expr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryOptimizeVal(cenv cenv, IncrementalOptimizationEnv env, FSharpOption`1<ValRef> vOpt, bool mustInline, bool inlineIfLambda, ExprValueInfo valInfoForVal, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryOptimizeValInfo(cenv cenv, IncrementalOptimizationEnv env, Range m, Summary`1<ExprValueInfo> vinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Summary`1<ExprValueInfo> AddValEqualityInfo(a g, b m, ValRef v, Summary`1<ExprValueInfo> info);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeVal(cenv cenv, IncrementalOptimizationEnv env, Expr expr, ValRef v, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<EntityRef, FSharpList`1<TType>> StripToNominalTyconRef(cenv cenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanDevirtualizeApplication(cenv cenv, ValRef v, ValRef vref, TType ty, FSharpList`1<c> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpFunc`2<Expr, Expr>, FSharpList`1<Expr>> TakeAddressOfStructArgumentIfNeeded(cenv cenv, ValRef vref, TType ty, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> DevirtualizeApplication(cenv cenv, IncrementalOptimizationEnv env, ValRef vref, TType ty, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Summary`1<ExprValueInfo>>> TryDevirtualizeApplication(cenv cenv, IncrementalOptimizationEnv env, Expr f, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Summary`1<ExprValueInfo>>> TryInlineApplication(cenv cenv, IncrementalOptimizationEnv env, Summary`1<ExprValueInfo> finfo, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m);
    internal static Tuple`2<FSharpList`1<Expr>, FSharpFunc`2<FSharpList`1<Expr>, Expr>> strip@3453-2(TcGlobals g, Expr f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpChoice`2<Expr, Tuple`2<Expr, FSharpFunc`2<Expr, Expr>>> StripPreComputationsFromComputedFunction(TcGlobals g, Expr f0, FSharpList`1<Expr> args, FSharpFunc`2<Expr, FSharpFunc`2<FSharpList`1<Expr>, Expr>> mkApp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeFuncInApplication(cenv cenv, IncrementalOptimizationEnv env, Expr f0, Range mWithArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeApplication(cenv cenv, IncrementalOptimizationEnv env, Expr f0, TType f0ty, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Tuple`4<FSharpList`1<Range>, TType, Expr, Range>>> getPipes(TcGlobals g, Expr expr, FSharpList`1<Tuple`4<FSharpList`1<Range>, TType, Expr, Range>> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeDebugPipeRights(cenv cenv, IncrementalOptimizationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeFSharpDelegateInvoke(cenv cenv, IncrementalOptimizationEnv env, Expr delInvokeRef, Expr delExpr, TType delInvokeTy, Expr delInvokeArg, Range m);
    [CompilerGeneratedAttribute]
internal static void OptimizeLambdas$cont@3764(cenv cenv, Summary`1<ExprValueInfo> bodyinfo, Val v, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeLambdas(FSharpOption`1<Val> vspec, cenv cenv, IncrementalOptimizationEnv env, ValReprInfo valReprInfo, Expr expr, TType exprTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeNewDelegateExpr(cenv cenv, IncrementalOptimizationEnv env, long lambdaId, FSharpList`1<Val> vsl, Expr body, FSharpFunc`2<Expr, Expr> remake);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeExprsThenReshapeAndConsiderSplits(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<Tuple`2<ExprValueInfo, Expr>> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Expr>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeExprsThenConsiderSplits(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprThenReshapeAndConsiderSplit(cenv cenv, IncrementalOptimizationEnv env, ExprValueInfo shape, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<DecisionTreeTarget>, FSharpList`1<Summary`1<ExprValueInfo>>> OptimizeDecisionTreeTargets(cenv cenv, IncrementalOptimizationEnv env, Range m, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr ReshapeExpr(cenv cenv, ExprValueInfo shape, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeExprThenConsiderSplit(cenv cenv, IncrementalOptimizationEnv env, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ComputeSplitToMethodCondition(bool flag, int threshold, cenv cenv, IncrementalOptimizationEnv env, Expr e, Summary`1<d> einfo);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> ConsiderSplitToMethod$cont@3887(IncrementalOptimizationEnv env, Expr e, Summary`1<ExprValueInfo> einfo, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> ConsiderSplitToMethod(bool flag, int threshold, cenv cenv, IncrementalOptimizationEnv env, Expr e, Summary`1<ExprValueInfo> einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeMatch(cenv cenv, IncrementalOptimizationEnv env, DebugPointAtBinding spMatch, Range mExpr, DecisionTree dtree, DecisionTreeTarget[] targets, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> OptimizeMatchPart2(cenv cenv, DebugPointAtBinding spMatch, Range mExpr, DecisionTree dtreeR, FSharpList`1<DecisionTreeTarget> targetsR, Summary`1<ExprValueInfo> dinfo, FSharpList`1<Summary`1<ExprValueInfo>> tinfos, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Summary`1<ExprValueInfo> CombineMatchInfos(Summary`1<e> dinfo, Summary`1<f> tinfo);
    internal static Tuple`2<Expr, Summary`1<ExprValueInfo>> RebuildOptimizedMatch(DebugPointAtBinding spMatch, Range mExpr, Range m, TType ty, DecisionTree dtree, FSharpList`1<DecisionTreeTarget> tgs, Summary`1<ExprValueInfo> dinfo, FSharpList`1<Summary`1<ExprValueInfo>> tinfos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTreeTarget, Summary`1<ExprValueInfo>> OptimizeDecisionTreeTarget(cenv cenv, IncrementalOptimizationEnv env, Range _m, DecisionTreeTarget _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, Summary`1<ExprValueInfo>> OptimizeDecisionTree(cenv cenv, IncrementalOptimizationEnv env, Range m, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryOptimizeDecisionTreeTest(cenv cenv, DecisionTreeTest test, ExprValueInfo vinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, Summary`1<ExprValueInfo>> OptimizeSwitch(cenv cenv, IncrementalOptimizationEnv env, Expr e, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, Summary`1<ExprValueInfo>> OptimizeSwitchFallback(cenv cenv, IncrementalOptimizationEnv env, Expr eR, Summary`1<ExprValueInfo> einfo, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt, Range m);
    internal static ExprValueInfo cut@4054(cenv cenv, ExprValueInfo ivalue);
    [CompilerGeneratedAttribute]
internal static bool einfo$cont@4106(TcGlobals g, ValRef nvref, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<Binding, Summary`1<ExprValueInfo>>, IncrementalOptimizationEnv> OptimizeBinding(cenv cenv, bool isRec, IncrementalOptimizationEnv env, Binding _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>, IncrementalOptimizationEnv> OptimizeBindings(cenv cenv, bool isRec, IncrementalOptimizationEnv env, FSharpList`1<Binding> xs);
    internal static ModuleOrNamespaceType elimModTy@4177(Set`2<Val, IComparer`1<Val>> deadSet, ModuleOrNamespaceType mtyp);
    internal static void elimModSpec@4185(Set`2<Val, IComparer`1<Val>> deadSet, Entity mspec);
    internal static ModuleOrNamespaceContents elimModuleDefn@4189(Set`2<Val, IComparer`1<Val>> deadSet, FSharpFunc`2<ModuleOrNamespaceBinding, FSharpOption`1<ModuleOrNamespaceBinding>> elimModuleBinding, ModuleOrNamespaceContents x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceContents, Lazy`1<ModuleInfo>> OptimizeModuleExprWithSig(cenv cenv, IncrementalOptimizationEnv env, ModuleOrNamespaceType mty, ModuleOrNamespaceContents def);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<ModuleOrNamespaceContents, Lazy`1<ModuleInfo>>, Tuple`2<IncrementalOptimizationEnv, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>>>> OptimizeModuleContents(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>> bindInfosColl, ModuleOrNamespaceContents input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<ModuleOrNamespaceBinding, FSharpChoice`2<Tuple`2<Binding, Summary`1<ExprValueInfo>>, Tuple`2<string, Lazy`1<ModuleInfo>>>>>, Tuple`2<IncrementalOptimizationEnv, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>>>> OptimizeModuleBindings(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>> bindInfosColl, FSharpList`1<ModuleOrNamespaceBinding> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<ModuleOrNamespaceBinding, FSharpChoice`2<Tuple`2<Binding, Summary`1<ExprValueInfo>>, Tuple`2<string, Lazy`1<ModuleInfo>>>>, Tuple`2<IncrementalOptimizationEnv, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>>>> OptimizeModuleBinding(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>> bindInfosColl, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<FSharpList`1<ModuleOrNamespaceContents>, Lazy`1<ModuleInfo>>, Tuple`2<IncrementalOptimizationEnv, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>>>> OptimizeModuleDefs(cenv cenv, IncrementalOptimizationEnv env, FSharpList`1<FSharpList`1<Tuple`2<Binding, Summary`1<ExprValueInfo>>>> bindInfosColl, FSharpList`1<ModuleOrNamespaceContents> defs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<IncrementalOptimizationEnv, CheckedImplFile, Lazy`1<ModuleInfo>, SignatureHidingInfo> OptimizeImplFileInternal(cenv cenv, IncrementalOptimizationEnv env, bool isIncrementalFragment, bool fsiMultiAssemblyEmit, SignatureHidingInfo hidden, CheckedImplFile implFile);
    internal static Tuple`2<Tuple`4<IncrementalOptimizationEnv, CheckedImplFile, Lazy`1<ModuleInfo>, SignatureHidingInfo>, FSharpFunc`2<bool, FSharpFunc`2<Expr, Expr>>> OptimizeImplFile(OptimizationSettings settings, CcuThunk ccu, TcGlobals tcGlobals, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, ImportMap importMap, IncrementalOptimizationEnv optEnv, bool isIncrementalFragment, bool fsiMultiAssemblyEmit, bool emitTailcalls, SignatureHidingInfo hidden, CheckedImplFile mimpls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ExprValueInfo(ExprValueInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ModuleInfo(ModuleInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_LazyModuleInfo(Lazy`1<ModuleInfo> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_CcuOptimizationInfo(Lazy`1<ModuleInfo> x, WriterState st);
    internal static ExprValueInfo loop@4381-83(ReaderState st);
    internal static ExprValueInfo u_ExprInfo(ReaderState st);
    internal static ValInfo u_ValInfo(ReaderState st);
    internal static ModuleInfo u_ModuleInfo(ReaderState st);
    internal static Lazy`1<ModuleInfo> u_LazyModuleInfo(ReaderState st);
    internal static Lazy`1<ModuleInfo> u_CcuOptimizationInfo(ReaderState st);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.ParseAndCheckInputs : object {
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> ValidSuffixes { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<QualifiedNameOfFile> qnameOrder { get; }
    internal static string CanonicalizeFilename(string fileName);
    internal static bool IsScript(string fileName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile QualFileNameOfModuleName(Range m, string fileName, FSharpList`1<Ident> modname);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile QualFileNameOfFilename(Range m, string fileName);
    internal static QualifiedNameOfFile ComputeQualifiedNameOfFileFromUniquePath(Range m, FSharpList`1<string> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile QualFileNameOfSpecs(string fileName, FSharpList`1<SynModuleOrNamespaceSig> specs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile QualFileNameOfImpls(string fileName, FSharpList`1<SynModuleOrNamespace> specs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QualifiedNameOfFile PrependPathToQualFileName(FSharpList`1<Ident> x, QualifiedNameOfFile _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynModuleOrNamespace PrependPathToImpl(FSharpList`1<Ident> x, SynModuleOrNamespace _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynModuleOrNamespaceSig PrependPathToSpec(FSharpList`1<Ident> x, SynModuleOrNamespaceSig _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParsedInput PrependPathToInput(FSharpList`1<Ident> x, ParsedInput inp);
    internal static bool IsValidAnonModuleName(string modname);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Ident> ComputeAnonModuleName(bool check, FSharpOption`1<string> defaultNamespace, string fileName, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool FileRequiresModuleOrNamespaceDecl(bool isLast, bool isExe, string fileName);
    [CompilerGeneratedAttribute]
internal static SynModuleOrNamespace PostParseModuleImpl$cont@132(ParsedImplFileFragment impl, Unit unitVar);
    internal static SynModuleOrNamespace PostParseModuleImpl(a _i, FSharpOption`1<string> defaultNamespace, Tuple`2<bool, bool> isLastCompiland, string fileName, ParsedImplFileFragment impl);
    [CompilerGeneratedAttribute]
internal static SynModuleOrNamespaceSig PostParseModuleSpec$cont@177(ParsedSigFileFragment intf, Unit unitVar);
    internal static SynModuleOrNamespaceSig PostParseModuleSpec(a _i, FSharpOption`1<string> defaultNamespace, Tuple`2<bool, bool> isLastCompiland, string fileName, ParsedSigFileFragment intf);
    internal static FSharpList`1<ScopedPragma> GetScopedPragmasForHashDirective(ParsedHashDirective hd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<CommentTrivia> collectCodeComments(LexBuffer`1<char> lexbuf, FSharpList`1<Range> tripleSlashComments);
    internal static ParsedInput PostParseModuleImpls(FSharpOption`1<string> defaultNamespace, string fileName, Tuple`2<bool, bool> isLastCompiland, ParsedImplFile _arg1, LexBuffer`1<char> lexbuf, FSharpList`1<Range> tripleSlashComments, FSharpSet`1<string> identifiers);
    internal static ParsedInput PostParseModuleSpecs(FSharpOption`1<string> defaultNamespace, string fileName, Tuple`2<bool, bool> isLastCompiland, ParsedSigFile _arg1, LexBuffer`1<char> lexbuf, FSharpList`1<Range> tripleSlashComments, FSharpSet`1<string> identifiers);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<QualifiedNameOfFile, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>>> DeduplicateModuleName(FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, string fileName, QualifiedNameOfFile qualNameOfFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ParsedInput, FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>>> DeduplicateParsedInputModuleName(FSharpMap`2<string, FSharpMap`2<string, QualifiedNameOfFile>> moduleNamesDict, ParsedInput input);
    internal static ParsedInput ParseInput(FSharpFunc`2<LexBuffer`1<char>, token> lexer, FSharpDiagnosticOptions diagnosticOptions, DiagnosticsLogger diagnosticsLogger, LexBuffer`1<char> lexbuf, FSharpOption`1<string> defaultNamespace, string fileName, Tuple`2<bool, bool> isLastCompiland, bool identCapture, FSharpOption`1<string> userOpName);
    internal static void ShowAllTokensAndExit(FSharpFunc`2<Unit, token> tokenizer, LexBuffer`1<char> lexbuf, Exiter exiter);
    internal static a TestInteractionParserAndExit(FSharpFunc`2<Unit, token> tokenizer, LexBuffer`1<char> lexbuf, Exiter exiter);
    internal static FSharpList`1<SynModuleSigDecl> flattenSpecs@548(FSharpList`1<SynModuleSigDecl> specs);
    internal static FSharpList`1<SynModuleDecl> flattenDefns@554(FSharpList`1<SynModuleDecl> specs);
    internal static void ReportParsingStatistics(ParsedInput res);
    internal static ParsedInput EmptyParsedInput(string fileName, Tuple`2<bool, bool> isLastCompiland);
    internal static ParsedInput ParseOneInputLexbuf(TcConfig tcConfig, LexResourceManager lexResourceManager, LexBuffer`1<char> lexbuf, string fileName, Tuple`2<bool, bool> isLastCompiland, DiagnosticsLogger diagnosticsLogger);
    internal static FSharpList`1<string> get_ValidSuffixes();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void checkInputFile(TcConfig tcConfig, string fileName);
    internal static ParsedInput parseInputStreamAux(TcConfig tcConfig, LexResourceManager lexResourceManager, string fileName, Tuple`2<bool, bool> isLastCompiland, DiagnosticsLogger diagnosticsLogger, bool retryLocked, Stream stream);
    internal static ParsedInput parseInputSourceTextAux(TcConfig tcConfig, LexResourceManager lexResourceManager, string fileName, Tuple`2<bool, bool> isLastCompiland, DiagnosticsLogger diagnosticsLogger, ISourceText sourceText);
    internal static ParsedInput parseInputFileAux(TcConfig tcConfig, LexResourceManager lexResourceManager, string fileName, Tuple`2<bool, bool> isLastCompiland, DiagnosticsLogger diagnosticsLogger, bool retryLocked);
    internal static ParsedInput ParseOneInputStream(TcConfig tcConfig, LexResourceManager lexResourceManager, string fileName, Tuple`2<bool, bool> isLastCompiland, DiagnosticsLogger diagnosticsLogger, bool retryLocked, Stream stream);
    internal static ParsedInput ParseOneInputSourceText(TcConfig tcConfig, LexResourceManager lexResourceManager, string fileName, Tuple`2<bool, bool> isLastCompiland, DiagnosticsLogger diagnosticsLogger, ISourceText sourceText);
    internal static ParsedInput ParseOneInputFile(TcConfig tcConfig, LexResourceManager lexResourceManager, string fileName, Tuple`2<bool, bool> isLastCompiland, DiagnosticsLogger diagnosticsLogger, bool retryLocked);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b UseMultipleDiagnosticLoggers(FSharpList`1<a> inputs, DiagnosticsLogger diagnosticsLogger, FSharpOption`1<FSharpFunc`2<PhasedDiagnostic, PhasedDiagnostic>> eagerFormat, FSharpFunc`2<FSharpList`1<Tuple`2<a, CapturingDiagnosticsLogger>>, b> f);
    internal static FSharpList`1<Tuple`2<ParsedInput, string>> ParseInputFilesInParallel(TcConfig tcConfig, LexResourceManager lexResourceManager, FSharpList`1<string> sourceFiles, DiagnosticsLogger delayLogger, bool retryLocked);
    internal static FSharpList`1<Tuple`2<ParsedInput, string>> ParseInputFilesSequential(TcConfig tcConfig, LexResourceManager lexResourceManager, FSharpList`1<string> sourceFiles, DiagnosticsLogger diagnosticsLogger, bool retryLocked);
    internal static FSharpList`1<Tuple`2<ParsedInput, string>> ParseInputFiles(TcConfig tcConfig, LexResourceManager lexResourceManager, FSharpList`1<string> sourceFiles, DiagnosticsLogger diagnosticsLogger, bool retryLocked);
    internal static T ProcessDependencyManagerDirective@872(FSharpFunc`2<T, FSharpFunc`2<Tuple`3<Range, string, Directive>, T>> hashReferenceF, bool canHaveScriptMetaCommands, Directive directive, FSharpList`1<string> args, Range m, T state);
    internal static T ProcessMetaCommand@886(FSharpFunc`2<T, FSharpFunc`2<Tuple`2<Range, string>, T>> nowarnF, FSharpFunc`2<T, FSharpFunc`2<Tuple`2<Range, string>, Unit>> loadSourceF, FSharpFunc`2<T, FSharpFunc`2<Tuple`3<Range, string, Directive>, T>> hashReferenceF, TcConfigBuilder tcConfig, string pathOfMetaCommandSource, bool canHaveScriptMetaCommands, T state, ParsedHashDirective hash);
    internal static void WarnOnIgnoredSpecDecls@944(FSharpList`1<SynModuleSigDecl> decls);
    internal static void WarnOnIgnoredImplDecls@952(FSharpList`1<SynModuleDecl> decls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T ProcessMetaCommandsFromInput(FSharpFunc`2<T, FSharpFunc`2<Tuple`2<Range, string>, T>> nowarnF, FSharpFunc`2<T, FSharpFunc`2<Tuple`3<Range, string, Directive>, T>> hashReferenceF, FSharpFunc`2<T, FSharpFunc`2<Tuple`2<Range, string>, Unit>> loadSourceF, TcConfigBuilder tcConfig, ParsedInput inp, string pathOfMetaCommandSource, T state0);
    internal static FSharpFunc`2<Unit, FSharpFunc`2<Tuple`3<a, b, c>, Unit>> addReference@998();
    internal static FSharpFunc`2<Unit, FSharpFunc`2<Tuple`2<a, b>, Unit>> addLoadedSource@999();
    internal static TcConfig ApplyNoWarnsToTcConfig(TcConfig tcConfig, ParsedInput inp, string pathOfMetaCommandSource);
    internal static FSharpFunc`2<Unit, FSharpFunc`2<a, Unit>> getWarningNumber@1006();
    internal static TcConfig ApplyMetaCommandsFromInputToTcConfig(TcConfig tcConfig, ParsedInput inp, string pathOfMetaCommandSource, DependencyProvider dependencyProvider);
    internal static Tuple`2<TcEnv, FSharpList`1<OpenDeclaration>> GetInitialTcEnv(string assemblyName, Range initm, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals);
    internal static void CheckSimulateException(TcConfig tcConfig);
    internal static IComparer`1<QualifiedNameOfFile> get_qnameOrder();
    internal static TcState GetInitialTcState(Range m, string ccuName, TcConfig tcConfig, TcGlobals tcGlobals, TcImports tcImports, TcEnv tcEnv0, FSharpList`1<OpenDeclaration> openDecls0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceType, TcState> AddCheckResultsToTcState(TcGlobals tcGlobals, ImportMap amap, bool hadSig, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcResultsSink tcSink, TcEnv tcImplEnv, QualifiedNameOfFile qualNameOfFile, ModuleOrNamespaceType implFileSigType, TcState tcState);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>, TcState>> SkippedImplFilePlaceholder$cont@1229(TcState tcState, TcImports tcImports, TcGlobals tcGlobals, ParsedInput input, Unit unitVar);
    internal static FSharpOption`1<Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>, TcState>> SkippedImplFilePlaceholder(TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, TcState tcState, ParsedInput input);
    internal static Cancellable`1<Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>, TcState>> CheckOneInput(FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcResultsSink tcSink, TcState tcState, ParsedInput input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>, TcState> CheckOneInputEntry(CompilationThreadToken ctok, FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcState tcState, ParsedInput input);
    internal static Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpList`1<T>, FSharpList`1<U>>, TcState> CheckMultipleInputsFinish(FSharpList`1<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<T>, U>> results, TcState tcState);
    internal static Cancellable`1<Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpList`1<CheckedImplFile>, FSharpList`1<ModuleOrNamespaceType>>, TcState>> CheckOneInputAndFinish(FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcResultsSink tcSink, TcState tcState, ParsedInput input);
    internal static Tuple`3<TcState, FSharpList`1<CheckedImplFile>, Entity> CheckClosedInputSetFinish(FSharpList`1<CheckedImplFile> declaredImpls, TcState tcState);
    internal static Tuple`2<FSharpList`1<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>>, TcState> CheckMultipleInputsSequential(CompilationThreadToken ctok, FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcState tcState, FSharpList`1<ParsedInput> inputs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<Finisher`3<NodeToTypeCheck, TcState, Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>>> CheckOneInputWithCallback(NodeToTypeCheck node, FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcResultsSink tcSink, TcState tcState, ParsedInput inp, bool _arg1_8);
    internal static FSharpFunc`2<TcState, Tuple`2<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>, TcState>> AddSignatureResultToTcImplEnv(TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcResultsSink tcSink, TcState tcState, ParsedInput input);
    internal static NodeToTypeCheck[] mapDependencies@1760(FilePairMap filePairs, int idx, Int32[] deps);
    internal static Finisher`3<NodeToTypeCheck, Tuple`2<TcState, bool>, Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>> processArtificialImplFile@1818(TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, NodeToTypeCheck node, ParsedInput input, TcState currentTcState, bool _arg21);
    internal static Finisher`3<NodeToTypeCheck, Tuple`2<TcState, bool>, Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>> processFile@1838(bool priorErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, NodeToTypeCheck node, ParsedInput input, DiagnosticsLogger logger, TcState currentTcState, bool _arg31);
    internal static Tuple`2<FSharpList`1<Tuple`4<TcEnv, TopAttribs, FSharpOption`1<CheckedImplFile>, ModuleOrNamespaceType>>, TcState> CheckMultipleInputsUsingGraphMode(a ctok, FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcState tcState, FSharpFunc`2<PhasedDiagnostic, PhasedDiagnostic> eagerFormat, FSharpList`1<ParsedInput> inputs);
    internal static Tuple`4<TcState, TopAttribs, FSharpList`1<CheckedImplFile>, TcEnv> CheckClosedInputSet(CompilationThreadToken ctok, FSharpFunc`2<Unit, bool> checkForErrors, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals, FSharpOption`1<FSharpList`1<Ident>> prefixPathOpt, TcState tcState, FSharpFunc`2<PhasedDiagnostic, PhasedDiagnostic> eagerFormat, FSharpList`1<ParsedInput> inputs);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.ParseHelpers : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string warningStringOfCoords(int line, int column);
    internal static string warningStringOfPos(Position p);
    internal static Position posOfLexPosition(Position p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range mkSynRange(Position p1, Position p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range LexBuffer`1.get_LexemeRange(LexBuffer`1<Char> );
    internal static Range lhs(IParseState parseState);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range rhs2(IParseState parseState, int i, int j);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range rhs(IParseState parseState, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynArgNameGenerator IParseState.get_SynArgNameGenerator(IParseState );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IParseState.ResetSynArgNameGenerator(IParseState );
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@168-35(LexerIfdefExpression this, LexerIfdefExpression obj, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool LexerIfdefEval(FSharpFunc`2<string, bool> lookup, LexerIfdefExpression _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILInstr[] ParseAssemblyCodeInstructions(string s, bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILType ParseAssemblyCodeType(string s, bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, Range m);
    internal static PreXmlDoc grabXmlDocAtRangeStart(IParseState parseState, FSharpList`1<SynAttributeList> optAttributes, Range range);
    internal static PreXmlDoc grabXmlDoc(IParseState parseState, FSharpList`1<SynAttributeList> optAttributes, int elemIdx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void reportParseErrorAt(Range m, Tuple`2<int, string> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a raiseParseErrorAt(Range m, Tuple`2<int, string> s);
    internal static FSharpChoice`3<Range, Range, Unit> |GetIdent|SetIdent|OtherIdent|(FSharpOption`1<Ident> ident);
    internal static string go@499-6(Range mBindLhs, SynPat p);
    internal static FSharpList`1<SynArgInfo> adjustValueArg@576(FSharpList`1<SynArgInfo> valueArg);
    internal static FSharpOption`1<SynAccess> mergeLidVisOuter@655(Range mWholeBindLhs, FSharpOption`1<SynAccess> lidVisOuter, FSharpOption`1<SynAccess> lidVisInner);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynPat> args$cont@676(Range m, Ident id, FSharpList`1<SynPat> args, Unit unitVar);
    internal static Tuple`2<SynPat, FSharpOption`1<Ident>> go@665-7(Range mWholeBindLhs, FSharpOption`1<SynAccess> lidVisOuter, SynLongIdent lidOuter, SynPat p);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`2<SynMemberDefn, FSharpOption`1<Ident>>> tryMkSynMemberDefnMember$cont@535(Range mWhole, SynPat propertyNameBindingPat, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>> optPropertyType, Range rangeStart, PreXmlDoc xmlDoc, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>> optReturnType, Range mExpr, SynExpr expr, SynPat bindingPat, bool optInline, SynBindingTrivia trivia, FSharpOption`1<SynAccess> vis, Range mBindLhs, bool isInline, FSharpList`1<SynAttributeList> attrs, FSharpOption`1<SynMemberKind> memberKind, FSharpFunc`2<SynMemberKind, SynMemberFlags> memFlagsBuilder, Unit unitVar);
    internal static FSharpOption`1<Tuple`2<SynMemberDefn, FSharpOption`1<Ident>>> tryMkSynMemberDefnMember@444(FSharpOption`1<Range> opt_inline, Range mWhole, SynPat propertyNameBindingPat, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>> optPropertyType, FSharpOption`1<SynAccess> visNoLongerUsed, FSharpList`1<SynAttributeList> attrs, Range rangeStart, PreXmlDoc xmlDoc, FSharpFunc`2<SynMemberKind, SynMemberFlags> memFlagsBuilder, SynLeadingKeyword leadingKeyword, FSharpRef`1<bool> hasGet, FSharpRef`1<bool> hasSet, FSharpOption`1<Range> mOptInline, FSharpList`1<SynAttributeList> optAttrs, Tuple`2<SynPat, Range> tupledArg2, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>> optReturnType, FSharpOption`1<Range> mEquals, SynExpr expr, Range mExpr);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynMemberDefn> mkSynMemberDefnGetSet$cont@731(FSharpOption`1<Range> opt_inline, Range mWith, FSharpOption`1<Tuple`2<SynMemberDefn, FSharpOption`1<Ident>>> matchValue, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynMemberDefn> mkSynMemberDefnGetSet$cont@759-1(FSharpOption`1<Range> opt_inline, Range mWith, FSharpOption`1<Range> mAnd, Range mWhole, SynPat propertyNameBindingPat, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>> optPropertyType, FSharpOption`1<SynAccess> visNoLongerUsed, FSharpList`1<SynAttributeList> attrs, Range rangeStart, PreXmlDoc xmlDoc, Tuple`7<FSharpOption`1<Range>, FSharpList`1<SynAttributeList>, Tuple`2<SynPat, Range>, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>>, FSharpOption`1<Range>, SynExpr, Range> s, Tuple`7<FSharpOption`1<Range>, FSharpList`1<SynAttributeList>, Tuple`2<SynPat, Range>, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>>, FSharpOption`1<Range>, SynExpr, Range> g, FSharpFunc`2<SynMemberKind, SynMemberFlags> memFlagsBuilder, SynLeadingKeyword leadingKeyword, FSharpRef`1<bool> hasGet, FSharpRef`1<bool> hasSet, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<SynMemberDefn> mkSynMemberDefnGetSet(IParseState parseState, FSharpOption`1<Range> opt_inline, Range mWith, FSharpList`1<Tuple`7<FSharpOption`1<Range>, FSharpList`1<SynAttributeList>, Tuple`2<SynPat, Range>, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>>, FSharpOption`1<Range>, SynExpr, Range>> classDefnMemberGetSetElements, FSharpOption`1<Range> mAnd, Range mWhole, SynPat propertyNameBindingPat, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>> optPropertyType, FSharpOption`1<SynAccess> visNoLongerUsed, FSharpFunc`2<SynMemberKind, SynMemberFlags> flagsBuilderAndLeadingKeyword, SynLeadingKeyword leadingKeyword, FSharpList`1<SynAttributeList> attrs, Range rangeStart);
    internal static SynExpr take@824(Range mFull, SynExpr inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr adjustHatPrefixToTyparLookup(Range mFull, SynExpr rightExpr);
    internal static SynType mkSynTypeTuple(FSharpList`1<SynTupleTypeSegment> elementTypes);
    internal static void debugPrint(a s);
    internal static SynExpr exprFromParseError(SynExpr e);
    internal static SynPat patFromParseError(SynPat e);
    internal static FSharpList`1<SynExprRecordField> run@880(FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>> lastSep, Tuple`2<SynLongIdent, bool> name, FSharpOption`1<Range> mEquals, FSharpOption`1<SynExpr> value, FSharpList`1<Tuple`2<Tuple`3<Tuple`2<SynLongIdent, bool>, FSharpOption`1<Range>, FSharpOption`1<SynExpr>>, FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>>>> l, FSharpList`1<SynExprRecordField> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<SynExprRecordField> rebindRanges(Tuple`3<Tuple`2<SynLongIdent, bool>, FSharpOption`1<Range>, FSharpOption`1<SynExpr>> first, FSharpList`1<Tuple`2<Tuple`3<Tuple`2<SynLongIdent, bool>, FSharpOption`1<Range>, FSharpOption`1<SynExpr>>, FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>>>> fields, FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>> lastSep);
    internal static Tuple`2<SynLongIdent, bool> mkUnderscoreRecdField(Range m);
    internal static Tuple`2<SynLongIdent, bool> mkRecdField(SynLongIdent lidwd);
    internal static SynBinding mkSynDoBinding(FSharpOption`1<SynAccess> vis, Range mDo, SynExpr expr, Range m);
    internal static SynModuleDecl mkSynExprDecl(SynExpr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynPat addAttribs(FSharpList`1<SynAttributeList> attrs, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range unionRangeWithPos(Range r, Position p);
    internal static void checkEndOfFileError(LexerContinuation t);
    internal static SynMemberDefn mkClassMemberLocalBindings(bool isStatic, FSharpOption`1<Range> initialRangeOpt, FSharpList`1<SynAttributeList> attrs, FSharpOption`1<SynAccess> vis, BindingSet _arg1);
    internal static SynExpr mkLocalBindings(Range mWhole, BindingSet _arg1, FSharpOption`1<Range> mIn, SynExpr body);
    internal static FSharpList`1<SynModuleDecl> mkDefnBindings(Range mWhole, BindingSet _arg1, FSharpList`1<SynAttributeList> attrs, FSharpOption`1<SynAccess> vis, Range attrsm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Ident idOfPat(IParseState parseState, Range m, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> checkForMultipleAugmentations(Range m, FSharpList`1<a> a1, FSharpList`1<a> a2);
    internal static Range rangeOfLongIdent(FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynLeadingKeyword appendValToLeadingKeyword(Range mVal, SynLeadingKeyword leadingKeyword);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynUnionCase mkSynUnionCase(FSharpList`1<SynAttributeList> attributes, FSharpOption`1<SynAccess> access, SynIdent id, SynUnionCaseKind kind, Range mDecl, Tuple`2<PreXmlDoc, Range> xmlDoc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynMemberDefn mkAutoPropDefn(Range mVal, FSharpOption`1<SynAccess> access, Ident ident, FSharpOption`1<SynType> typ, FSharpOption`1<Range> mEquals, SynExpr expr, FSharpOption`1<Range> accessors, Tuple`2<SynMemberKind, FSharpOption`1<GetSetKeywords>> accessors_1, PreXmlDoc xmlDoc, FSharpList`1<SynAttributeList> attribs, FSharpFunc`2<SynMemberKind, SynMemberFlags> flags, SynLeadingKeyword leadingKeyword, Range rangeStart);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynMemberDefn mkValField(Range mVal, Range mRhs, bool mut, FSharpOption`1<SynAccess> access, Ident ident, SynType typ, PreXmlDoc xmlDoc, Range rangeStart, FSharpList`1<SynAttributeList> attribs, FSharpOption`1<Range> mStaticOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynField mkSynField(IParseState parseState, FSharpOption`1<Ident> idOpt, SynType t, bool isMutable, FSharpOption`1<SynAccess> vis, FSharpList`1<SynAttributeList> attributes, bool isStatic, Range mWhole, FSharpOption`1<SynLeadingKeyword> leadingKeyword);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Parser : object {
    [DebuggerBrowsableAttribute("0")]
internal static T1063382_33764Bytes@ field1063383@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063384_660Bytes@ field1063385@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063386_17624Bytes@ field1063387@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063388_4130Bytes@ field1063389@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063390_91848Bytes@ field1063391@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063388_4130Bytes@ field1063392@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063393_2438Bytes@ field1063394@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063393_2438Bytes@ field1063395@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063388_4130Bytes@ field1063396@;
    internal static int _fsyacc_endOfInputTag { get; }
    internal static int _fsyacc_tagOfErrorTerminal { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_gotos { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_sparseGotoTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableRowOffsets { get; }
    internal static int _fsyacc_action_rows { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_reductionSymbolCounts { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_productionToNonTerminalTable { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_immediateActions { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpFunc`2[]> _fsyacc_reductions { get; }
    [CompilationMappingAttribute("9")]
internal static Tables`1<token> tables { get; }
    private static Parser();
    internal static FSharpOption`1<FSharpFunc`2<ParseErrorContext`1<a>, Unit>> parse_error_rich();
    internal static int tagOfToken(token t);
    internal static tokenId tokenTagToTokenId(int tokenIdx);
    internal static nonTerminalId prodIdxToNonTerminal(int prodIdx);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_endOfInputTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_tagOfErrorTerminal();
    internal static string token_to_string(token t);
    internal static object _fsyacc_dataOfToken(token t);
    internal static UInt16[] get__fsyacc_gotos();
    internal static UInt16[] get__fsyacc_sparseGotoTableRowOffsets();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableElements();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_action_rows();
    internal static UInt16[] get__fsyacc_actionTableElements();
    internal static UInt16[] get__fsyacc_actionTableRowOffsets();
    internal static UInt16[] get__fsyacc_reductionSymbolCounts();
    internal static UInt16[] get__fsyacc_productionToNonTerminalTable();
    internal static UInt16[] get__fsyacc_immediateActions();
    internal static Lazy`1<FSharpFunc`2[]> get__fsyacc_reductions();
    internal static SynMemberKind getSetAdjuster@953(SynMemberKind getSet, SynValInfo arity);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynModuleDecl> _fsyacc_reductions$cont@1322(IParseState parseState, FSharpList`1<SynAttributeList> _1, FSharpOption`1<SynAccess> _2, FSharpChoice`2<FSharpList`1<Ident>, Tuple`2<FSharpList`1<SynModuleDecl>, FSharpOption`1<Range>>> _5, FSharpOption`1<SynAccess> vis, FSharpList`1<Ident> path, bool isRec, FSharpList`1<SynAttributeList> attribs2, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<SynModuleDecl> _fsyacc_reductions$cont@1332-1(IParseState parseState, FSharpList`1<SynAttributeList> _1, FSharpChoice`2<FSharpList`1<Ident>, Tuple`2<FSharpList`1<SynModuleDecl>, FSharpOption`1<Range>>> _5, FSharpOption`1<SynAccess> vis, FSharpList`1<Ident> path, Range mModule, bool isRec, FSharpList`1<SynAttributeList> attribs2, PreXmlDoc xmlDoc, Unit unitVar);
    internal static SynMemberKind getSetAdjuster@2033-1(SynMemberKind getSet, SynValInfo arity);
    internal static FSharpFunc`2<PreXmlDoc, FSharpFunc`2<FSharpList`1<SynAttributeList>, FSharpFunc`2<FSharpOption`1<SynAccess>, FSharpFunc`2<SynLeadingKeyword, FSharpFunc`2<a, SynBinding>>>>> attrLocalBindingBuilder@3173(FSharpList`1<SynAttributeList> _1, FSharpFunc`2<PreXmlDoc, FSharpFunc`2<FSharpList`1<SynAttributeList>, FSharpFunc`2<FSharpOption`1<SynAccess>, FSharpFunc`2<SynLeadingKeyword, SynBinding>>>> localBindingBuilder);
    internal static FSharpList`1<a> clauses@4047-2(Range mExpr);
    internal static Tables`1<token> get_tables();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParsedSigFile signatureFile(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParsedImplFile implementationFile(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParsedScriptInteraction interaction(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr typedSequentialExprEOF(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynType typEOF(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.PatternMatchCompilation : object {
    internal static string notNullText { get; }
    internal static string otherSubtypeText { get; }
    [CompilationMappingAttribute("9")]
internal static Boolean[] singleFalseInvestigationPoint { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> BindSubExprOfInput(TcGlobals g, ImportMap amap, FSharpList`1<Typar> gtps, PatternValBinding _arg2, Range m, SubExprOfInput _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr GetSubExprOfInput(TcGlobals g, FSharpList`1<a> gtps, FSharpList`1<TType> tyargs, FSharpList`1<Tuple`2<Typar, TType>> tinst, SubExprOfInput _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool pathEq(Path p1, Path p2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_notNullText();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_otherSubtypeText();
    internal static Const ilFieldToTastConst(ILFieldInit lit);
    internal static Tuple`2<Expr, CounterExampleType> go@208-9(TcGlobals g, Range m, Path path, FSharpFunc`2<TType, Tuple`2<Expr, CounterExampleType>> tm);
    internal static Tuple`2<FSharpList`1<Expr>, CounterExampleType> mkOneKnown@232(TcGlobals g, Range m, FSharpFunc`2<TType, Tuple`2<Expr, CounterExampleType>> tm, int n, FSharpList`1<TType> tys);
    internal static FSharpList`1<Expr> mkUnknowns@235(TcGlobals g, Range m, FSharpList`1<TType> tys);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, CounterExampleType> tm$cont@270-1(TcGlobals g, Range m, TType ty, FSharpSet`1<Const> consts, FSharpOption`1<Const> c', Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Expr, CounterExampleType> tm$cont@244(TcGlobals g, Range m, TType ty, FSharpList`1<DecisionTreeTest> rest, Const c, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, CounterExampleType> RefuteDiscrimSet(TcGlobals g, Range m, Path path, FSharpList`1<DecisionTreeTest> discrims);
    internal static string MaxStrings@344(string s1, string s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr CombineRefutations(TcGlobals g, Expr refutation1, Expr refutation2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<string, bool, CounterExampleType>> ShowCounterExample(TcGlobals g, DisplayEnv denv, Range m, FSharpList`1<RefutedSet> refuted);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isMemOfActives(Path p1, FSharpList`1<Active> actives);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SubExprOfInput, Pattern> lookupActive(Path x, FSharpList`1<Active> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Active> removeActive(Path x, FSharpList`1<Active> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Implication computeWhatSuccessfulTypeTestImpliesAboutNullTest(TcGlobals g, TType tgtTy1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Implication computeWhatFailingTypeTestImpliesAboutNullTest(TcGlobals g, TType tgtTy1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Implication computeWhatSuccessfulNullTestImpliesAboutTypeTest(TcGlobals g, TType tgtTy2);
    [CompilerGeneratedAttribute]
internal static Implication computeWhatSuccessfulTypeTestImpliesAboutTypeTest$cont@551(TcGlobals g, ImportMap amap, Range m, TType tgtTy1, TType tgtTy2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Implication computeWhatSuccessfulTypeTestImpliesAboutTypeTest(TcGlobals g, ImportMap amap, Range m, TType tgtTy1, TType tgtTy2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Implication computeWhatFailingTypeTestImpliesAboutTypeTest(TcGlobals g, ImportMap amap, Range m, TType tgtTy1, TType tgtTy2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<DecisionTreeTest> getDiscrimOfPattern(TcGlobals g, FSharpList`1<Tuple`2<Typar, TType>> tpinst, Pattern t);
    internal static Const constOfDiscrim(DecisionTreeTest discrim);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool discrimsEq(TcGlobals g, DecisionTreeTest d1, DecisionTreeTest d2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDiscrimSubsumedBy(TcGlobals g, ImportMap amap, Range m, DecisionTreeTest discrim, DecisionTreeTest taken);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<EdgeDiscrim>, FSharpList`1<a>> chooseSimultaneousEdgeSet(FSharpList`1<DecisionTreeTest> prev, FSharpFunc`2<FSharpList`1<DecisionTreeTest>, FSharpFunc`2<a, FSharpOption`1<EdgeDiscrim>>> f, FSharpList`1<a> l);
    internal static bool canCompactConstantClass(Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool discrimWithinSimultaneousClass(TcGlobals g, ImportMap amap, Range m, DecisionTreeTest discrim, FSharpList`1<DecisionTreeTest> prev);
    internal static bool canInvestigate(Pattern pat);
    internal static Active choose@729-4(FSharpList`1<Active> l);
    internal static Active ChooseInvestigationPointLeftToRight(FSharpList`1<Frontier> frontiers);
    internal static FSharpOption`1<Unit> |ConstNeedsDefaultCase|_|(Const c);
    internal static FSharpList`1<FSharpList`1<DecisionTreeCase>> compactify@855(FSharpOption`1<FSharpList`1<DecisionTreeCase>> curr, FSharpList`1<DecisionTreeCase> edges);
    [CompilerGeneratedAttribute]
internal static DecisionTree BuildSwitch$cont@789(TcGlobals g, Expr expr, FSharpList`1<DecisionTreeCase> edges, FSharpOption`1<DecisionTree> dflt, Range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree BuildSwitch(FSharpOption`1<a> inpExprOpt, TcGlobals g, Expr expr, FSharpList`1<DecisionTreeCase> edges, FSharpOption`1<DecisionTree> dflt, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Frontier> mkFrontiers(FSharpList`1<Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>>> investigations, int clauseNumber);
    internal static Boolean[] get_singleFalseInvestigationPoint();
    internal static Boolean[] investigationPoints(Pattern inpPat);
    internal static Pattern erasePartialPatterns(Pattern inpPat);
    internal static FSharpList`1<Pattern> erasePartials(FSharpList`1<Pattern> inps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ReportUnusedTargets(FSharpList`1<MatchClause> clauses, DecisionTree dtree);
    internal static bool isPatternDisjunctive(Pattern inpPat);
    internal static FSharpOption`1<MethInfo> findMethInfo@1056(TcGlobals g, ImportMap amap, InfoReader infoReader, Range mMatch, TType ty, bool isInstance, string name, FSharpList`1<TType> sigTys);
    [CompilerGeneratedAttribute]
internal static Expr throwExpr$cont@1056(TcGlobals g, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mMatch, Val origInputVal, TType resultTy, Unit unitVar);
    internal static Expr throwExpr@1045(TcGlobals g, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mMatch, ActionOnFailure actionOnFailure, Val origInputVal, TType resultTy, Unit unitVar0);
    internal static MatchClause getIncompleteMatchClause@1023(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, Val origInputVal, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, FSharpList`1<RefutedSet> refuted);
    internal static MatchClause GetClause@1126(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, Val origInputVal, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, int i, FSharpList`1<RefutedSet> refuted);
    internal static DecisionTree InvestigateFrontiers@1148(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, FSharpList`1<RefutedSet> refuted, FSharpList`1<Frontier> frontiers);
    internal static DecisionTree CompileSuccessPointAndGuard@1187(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, int i, FSharpList`1<RefutedSet> refuted, ValMap`1<Expr> valMap, FSharpList`1<Frontier> rest);
    internal static Tuple`2<FSharpList`1<EdgeDiscrim>, FSharpList`1<Frontier>> ChooseSimultaneousEdges@1208(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, FSharpList`1<Frontier> frontiers, Path path);
    internal static bool IsCopyableInputExpr@1224(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, Expr origInputExpr);
    [CompilerGeneratedAttribute]
internal static Tuple`2<FSharpOption`1<Expr>, FSharpOption`1<Binding>> ChoosePreBinder$cont@1293(TcGlobals g, Range mMatch, FSharpList`1<Typar> origInputValTypars, Val origInputVal, SubExprOfInput subexpr, FSharpList`1<TType> resTys, Range m, bool isStructRetTy, ActivePatternInfo apinfo, Expr activePatExpr, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, Unit unitVar);
    internal static Tuple`2<FSharpOption`1<Expr>, FSharpOption`1<Binding>> ChoosePreBinder@1229(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, FSharpList`1<EdgeDiscrim> simulSetOfEdgeDiscrims, SubExprOfInput subexpr);
    internal static Tuple`2<FSharpList`1<DecisionTreeCase>, FSharpList`1<DecisionTreeTest>> CompileSimultaneousSet@1314(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, FSharpList`1<Frontier> frontiers, Path path, FSharpList`1<RefutedSet> refuted, SubExprOfInput subexpr, FSharpList`1<EdgeDiscrim> simulSetOfEdgeDiscrims, FSharpOption`1<Expr> inpExprOpt);
    internal static bool isRefuted@1386(TcGlobals g, ImportMap amap, Range mExpr, Path path, FSharpList`1<DecisionTreeTest> simulSetOfDiscrims, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, Frontier _arg1);
    internal static FSharpOption`1<DecisionTree> CompileFallThroughTree@1382(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, FSharpList`1<Frontier> fallthroughPathFrontiers, Path path, FSharpList`1<RefutedSet> refuted, FSharpList`1<DecisionTreeCase> simulSetOfCases);
    internal static FSharpList`1<Frontier> mkSubFrontiers@1421(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, ValMap`1<Expr> valMap, int i, Tuple`2<Expr, Val> ve, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, a path, FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>>> subAccess, FSharpList`1<Active> subActive, FSharpList`1<Pattern> argpats, FSharpFunc`2<a, FSharpFunc`2<int, Path>> pathBuilder);
    internal static FSharpFunc`2<int, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<a, Expr>>> subAccess@1439(TcGlobals g, Range mExpr, FSharpOption`1<Expr> inpExprOpt, FSharpList`1<TType> resTys, Range m, int idx, int aparity);
    internal static FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<b, Expr>>> subAccess@1459-2(TcGlobals g, Range mExpr, FSharpOption`1<Expr> inpExprOpt, FSharpList`1<TType> resTys, bool isStructRetTy);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Frontier> GenerateNewFrontiersAfterSuccessfulInvestigation$cont@1434(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpOption`1<Expr> inpExprOpt, Frontier frontier, Path path, int iInvestigated, DecisionTreeTest discrim, ValMap`1<Expr> valMap, int i, Pattern patAtActive, Tuple`2<Expr, Val> ve, FSharpList`1<Active> newActives, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Frontier> GenerateNewFrontiersAfterSuccessfulInvestigation$cont@1533-1(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpOption`1<Expr> inpExprOpt, Frontier frontier, Path path, DecisionTreeTest discrim, ValMap`1<Expr> valMap, int i, Tuple`2<Expr, Val> ve, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>> accessf, FSharpList`1<Active> newActives, TType tgtTy1, FSharpOption`1<Pattern> pbindOpt, Range m, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, Unit unitVar);
    internal static FSharpFunc`2<Frontier, FSharpList`1<Frontier>> GenerateNewFrontiersAfterSuccessfulInvestigation@1413(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, FSharpList`1<DecisionTreeTest> taken, FSharpOption`1<Expr> inpExprOpt, FSharpOption`1<Expr> resPostBindOpt, InvestigationPoint investigation);
    internal static Active mkSubActive@1606-1(Path inpPath, Tuple`2<Expr, Val> inpExprAndVal, FSharpFunc`2<Path, FSharpFunc`2<a, Path>> pathBuilder, FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>>> subAccess, a j, Pattern p');
    internal static FSharpFunc`2<a, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>>> subAccess@1626-6(TcGlobals g, Range mExpr, FSharpFunc`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpFunc`2<Expr, Expr>> inpAccess, FSharpList`1<TType> tinst, RecdFieldRef fref);
    internal static FSharpList`1<Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>>> BindProjectionPattern@1602(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, Active inpActive, Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>> activeState);
    internal static FSharpList`1<Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>>> BindProjectionPatterns@1649(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnIncomplete, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> _origInputExprOpt, TType resultTy, MatchBuilder matchBuilder, List`1<CounterExampleType> warningsGenerated, MatchClause[] clausesA, int nClauses, FSharpFunc`2<SubExprOfInput, Expr> GetSubExprOfInput, FSharpFunc`2<Pattern, FSharpOption`1<DecisionTreeTest>> getDiscrimOfPattern, FSharpRef`1<FSharpOption`1<MatchClause>> firstIncompleteMatchClauseWithThrowExpr, FSharpList`1<Active> actives, Tuple`2<FSharpList`1<Active>, ValMap`1<Expr>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, FSharpList`1<DecisionTreeTarget>> CompilePatternBasic(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnUnused, bool warnOnIncomplete, ActionOnFailure actionOnFailure, Val origInputVal, FSharpList`1<Typar> origInputValTypars, FSharpOption`1<Expr> _origInputExprOpt, FSharpList`1<MatchClause> clauses, TType inputTy, TType resultTy);
    internal static bool isProblematicClause(MatchClause clause);
    internal static Tuple`2<DecisionTree, FSharpList`1<DecisionTreeTarget>> atMostOneProblematicClauseAtATime@1747(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> origInputExprOpt, TType inputTy, TType resultTy, FSharpList`1<MatchClause> clauses);
    internal static Tuple`2<DecisionTree, FSharpList`1<DecisionTreeTarget>> doGroupWithAtMostOneProblematic@1755(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, ActionOnFailure actionOnFailure, FSharpList`1<Typar> origInputValTypars, Val origInputVal, FSharpOption`1<Expr> origInputExprOpt, TType inputTy, TType resultTy, FSharpList`1<MatchClause> group, FSharpList`1<MatchClause> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, FSharpList`1<DecisionTreeTarget>> CompilePattern(TcGlobals g, DisplayEnv denv, ImportMap amap, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal, InfoReader infoReader, Range mExpr, Range mMatch, bool warnOnUnused, ActionOnFailure actionOnFailure, Val origInputVal, FSharpList`1<Typar> origInputValTypars, FSharpOption`1<Expr> origInputExprOpt, FSharpList`1<MatchClause> clausesL, TType inputTy, TType resultTy);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.PostTypeCheckSemanticChecks : object {
    [CompilationMappingAttribute("9")]
internal static int PostInferenceChecksStackGuardDepth { get; }
    internal static int get_PostInferenceChecksStackGuardDepth();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static env BindTypar(env env, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static env BindTypars(TcGlobals g, env env, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static env BindArgVals(env env, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsValLocal(env env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit GetLimitVal(cenv cenv, env env, Range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit GetLimitValByRef(cenv cenv, env env, Range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void LimitVal(cenv cenv, Val v, Limit limit);
    internal static bool parentHasSignatureFile@304(Val v, Unit unitVar0);
    internal static bool topLevelBindingHiddenBySignatureFile@303(Val v, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void BindVal(cenv cenv, env env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void BindVals(cenv cenv, env env, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void RecordAnonRecdInfo(cenv cenv, AnonRecdTypeInfo anonInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeDeep(cenv cenv, FSharpFunc`2<TType, Unit> visitTy, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> visitTyconRefOpt, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> visitAppTyOpt, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> visitTraitSolutionOpt, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> visitTyparOpt, TcGlobals g, env env, bool isInner, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypesDeep(cenv cenv, FSharpFunc`2<TType, Unit> f_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> f_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> f_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> f_3, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> f_4, TcGlobals g, env env, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypesDeepNoInner(cenv cenv, FSharpFunc`2<TType, Unit> f_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> f_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> f_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> f_3, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> f_4, TcGlobals g, env env, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeConstraintDeep(cenv cenv, FSharpFunc`2<TType, Unit> f_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> f_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> f_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> f_3, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> f_4, TcGlobals g, env env, TyparConstraint x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTraitInfoDeep(cenv cenv, FSharpFunc`2<TType, Unit> f_0, FSharpOption`1<FSharpFunc`2<bool, FSharpFunc`2<EntityRef, Unit>>> f_1, FSharpOption`1<FSharpFunc`2<Tuple`2<EntityRef, FSharpList`1<TType>>, Unit>> f_2, FSharpOption`1<FSharpFunc`2<TraitConstraintSln, Unit>> visitTraitSolutionOpt, FSharpOption`1<FSharpFunc`2<Tuple`2<env, Typar>, Unit>> f_4, TcGlobals g, env env, TraitConstraintInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForByrefLikeType(cenv cenv, env env, Range m, TType ty, FSharpFunc`2<Unit, Unit> check);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForByrefType(cenv cenv, env env, TType ty, FSharpFunc`2<Unit, Unit> check);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FreeVars> CheckEscapes(cenv cenv, bool allowProtected, Range m, FSharpList`1<Val> syntacticArgs, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility AccessInternalsVisibleToAsInternal(CompilationPath thisCompPath, FSharpList`1<CompilationPath> internalsVisibleToPaths, Accessibility access);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeForAccess(cenv cenv, env env, FSharpFunc`2<Unit, string> objName, Accessibility valAcc, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void WarnOnWrongTypeForAccess(cenv cenv, env env, FSharpFunc`2<Unit, string> objName, Accessibility valAcc, Range m, TType ty);
    internal static PermitByRefExpr mkArgsPermit(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PermitByRefExpr> mkArgsForAppliedVal(bool isBaseCall, ValRef vref, FSharpList`1<a> argsl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PermitByRefExpr> mkArgsForAppliedExpr(bool isBaseCall, FSharpList`1<a> argsl, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeAux(PermitByRefType permitByRefLike, cenv cenv, env env, Range m, TType ty, FSharpFunc`2<Unit, Unit> onInnerByrefError);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckType(PermitByRefType permitByRefLike, cenv cenv, env env, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeInstNoByrefs(cenv cenv, env env, Range m, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTypeInstNoInnerByrefs(cenv cenv, env env, Range m, FSharpList`1<TType> tyargs);
    internal static Expr |OptionalCoerce|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckNoReraise(cenv cenv, FSharpOption`1<FreeVars> freesOpt, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpliceOperator(TcGlobals g, ValRef v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TTypeEquality compareTypesWithRegardToTypeVariablesAndMeasures(TcGlobals g, a amap, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMultipleInterfaceInstantiations(cenv cenv, TType ty, FSharpList`1<TType> interfaces, bool isObjectExpression, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValRef(cenv cenv, env env, ValRef v, Range m, PermitByRefExpr ctxt);
    [CompilerGeneratedAttribute]
internal static void CheckValUse$cont@807(env env, ValRef vref, ValUseFlag vFlags, Range m, PermitByRefExpr ctxt, TcGlobals g, Limit limit, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckValUse(cenv cenv, env env, ValRef vref, ValUseFlag vFlags, Range m, PermitByRefExpr ctxt);
    [CompilerGeneratedAttribute]
internal static void CheckForOverAppliedExceptionRaisingPrimitive$cont@877-1(TcGlobals g, FSharpList`1<Expr> argsl, Range funcRange, ValRef failwithfFunc, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void CheckForOverAppliedExceptionRaisingPrimitive$cont@862(TcGlobals g, Expr f, FSharpList`1<Expr> argsl, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForOverAppliedExceptionRaisingPrimitive(cenv cenv, Expr expr);
    [CompilerGeneratedAttribute]
internal static void CheckCallLimitArgs$cont@907(env env, Range m, Limit limitArgs, PermitByRefExpr ctxt, bool isReturnLimitedByRef, bool isReturnLimitedSpanLike, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckCallLimitArgs(cenv cenv, env env, Range m, TType returnTy, Limit limitArgs, PermitByRefExpr ctxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckCallWithReceiver(cenv cenv, env env, Range m, TType returnTy, FSharpList`1<Expr> args, FSharpList`1<PermitByRefExpr> ctxts, PermitByRefExpr ctxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprLinear(cenv cenv, env env, Expr expr, PermitByRefExpr ctxt, FSharpFunc`2<Limit, Limit> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TryCheckResumableCodeConstructs(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExpr(cenv cenv, env env, Expr origExpr, PermitByRefExpr ctxt);
    internal static Tuple`4<FSharpList`1<ILTypeRef>, FSharpList`1<TType>, FSharpList`1<Expr>, ExprData> doData@1235-2(cenv cenv, Expr ast, TcGlobals g, bool suppressWitnesses);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckQuoteExpr(cenv cenv, env env, Expr ast, FSharpRef`1<FSharpOption`1<Tuple`2<Tuple`4<FSharpList`1<ILTypeRef>, FSharpList`1<TType>, FSharpList`1<Expr>, ExprData>, Tuple`4<FSharpList`1<ILTypeRef>, FSharpList`1<TType>, FSharpList`1<Expr>, ExprData>>>> savedConv, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckStructStateMachineExpr(cenv cenv, env env, Expr expr, TType info_0, Tuple`2<Val, Expr> info_1, Tuple`3<Val, Val, Expr> info_2, Tuple`2<Val, Expr> info_3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckObjectExpr(cenv cenv, env env, TType ty, FSharpOption`1<Val> basev, Expr superInitCall, FSharpList`1<ObjExprMethod> overrides, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> iimpls, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckFSharpBaseCall(cenv cenv, env env, Expr expr, ValRef v, Expr f, TType _fty, FSharpList`1<TType> tyargs, ValRef baseVal, FSharpList`1<Expr> rest, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckILBaseCall(cenv cenv, env env, ILMethodRef ilMethRef, FSharpList`1<TType> enclTypeInst, FSharpList`1<TType> methInst, FSharpList`1<TType> retTypes, FSharpList`1<TType> tyargs, ValRef baseVal, FSharpList`1<Expr> rest, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckSpliceApplication(cenv cenv, env env, FSharpList`1<TType> tinst, Expr arg, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckApplication(cenv cenv, env env, Expr expr, Expr f, FSharpList`1<TType> tyargs, FSharpList`1<Expr> argsl, Range m, PermitByRefExpr ctxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckLambda(cenv cenv, env env, Expr expr, FSharpList`1<Val> argvs, Range m, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckTyLambda(cenv cenv, env env, Expr expr, FSharpList`1<Typar> tps, Range m, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckMatch(cenv cenv, env env, PermitByRefExpr ctxt, DecisionTree dtree, DecisionTreeTarget[] targets, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckLetRec(cenv cenv, env env, FSharpList`1<Binding> binds, Expr bodyExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckStaticOptimization(cenv cenv, env env, FSharpList`1<StaticOptimization> constraints, Expr e2, Expr e3, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMethods(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, TType ty, FSharpList`1<ObjExprMethod> methods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMethod(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, TType ty, ObjExprMethod _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInterfaceImpls(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInterfaceImpl(cenv cenv, env env, FSharpOption`1<Val> baseValOpt, TType overrides_0, FSharpList`1<ObjExprMethod> overrides_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckNoResumableStmtConstructs(cenv cenv, env _env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprOp(cenv cenv, env env, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m, PermitByRefExpr ctxt, Expr expr);
    [CompilerGeneratedAttribute]
internal static void CheckLambdas$cont@1779(bool isTop, cenv cenv, TcGlobals g, Range m, FSharpList`1<Typar> tps, TType bodyTy, env env, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckLambdas(bool isTop, FSharpOption`1<Val> memberVal, cenv cenv, env env, bool inlined, ValReprInfo valReprInfo, bool alwaysCheckNoReraise, Expr expr, Range mOrig, TType ety, PermitByRefExpr ctxt);
    internal static PermitByRefExpr argArity@1814(PermitByRefExpr[] ctxts, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprs(cenv cenv, env env, FSharpList`1<Expr> exprs, FSharpList`1<PermitByRefExpr> ctxts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprsNoByRefLike(cenv cenv, env env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprsPermitByRefLike(cenv cenv, env env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprPermitByRefLike(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckExprPermitReturnableByRef(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckDecisionTreeTargets(cenv cenv, env env, DecisionTreeTarget[] targets, PermitByRefExpr ctxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckDecisionTreeTarget(cenv cenv, env env, PermitByRefExpr ctxt, DecisionTreeTarget _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTree(cenv cenv, env env, DecisionTree dtree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTreeSwitch(cenv cenv, env env, Expr inpExpr, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTreeTest(cenv cenv, env env, Range m, DecisionTreeTest discrim);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAttrib(cenv cenv, env env, Attrib _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAttribExpr(cenv cenv, env env, AttribExpr _arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAttribArgExpr(cenv cenv, env env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckAttribs(cenv cenv, env env, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValInfo(cenv cenv, env env, ValReprInfo _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckArgInfo(cenv cenv, env env, ArgReprInfo argInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValSpecAux(PermitByRefType permitByRefLike, cenv cenv, env env, Val v, FSharpFunc`2<Unit, Unit> onInnerByrefError);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckValSpec(PermitByRefType permitByRefLike, cenv cenv, env env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility AdjustAccess(bool isHidden, FSharpFunc`2<Unit, CompilationPath> cpath, Accessibility access);
    [CompilerGeneratedAttribute]
internal static void CheckBinding$cont@2032(cenv cenv, Val v, Expr bindRhs, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Limit CheckBinding(cenv cenv, env env, bool alwaysCheckNoReraise, PermitByRefExpr ctxt, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckBindings(cenv cenv, env env, FSharpList`1<Binding> binds);
    [CompilerGeneratedAttribute]
internal static void check$cont@2156(Val v, EntityRef tcref, string kind, string nm, Unit unitVar);
    internal static void check@2138-5(Val v, EntityRef tcref, bool hasDefaultAugmentation, string kind, bool skipValCheck, string nm);
    [CompilerGeneratedAttribute]
internal static void CheckModuleBinding$cont@2130(cenv cenv, Val v, TcGlobals g, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckModuleBinding(cenv cenv, env env, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckRecdField(bool isUnion, cenv cenv, env env, Entity tycon, RecdField rfield);
    [CompilerGeneratedAttribute]
internal static bool contains@1-8(string value, a e, FSharpList`1<string> xs1);
    internal static bool methodUniquenessIncludesReturnType@2279(FSharpList`1<string> namesOfMethodsThatMayDifferOnlyInReturnType, MethInfo minfo);
    internal static bool MethInfosEquivWrtUniqueness@2280(cenv cenv, TcGlobals g, FSharpList`1<string> namesOfMethodsThatMayDifferOnlyInReturnType, Erasure eraseFlag, Range m, MethInfo minfo, MethInfo minfo2);
    internal static FSharpList`1<a> getHash@2291(Dictionary`2<string, FSharpList`1<a>> hash, string nm);
    internal static FSharpList`1<MethInfo> getOtherMethods@2306(Dictionary`2<string, FSharpList`1<MethInfo>> hashOfImmediateMeths, MethInfo minfo);
    internal static bool IsAbstractDefaultPair2@2324(MethInfo minfo, MethInfo minfo2);
    internal static FSharpFunc`2<MethInfo, bool> checkForDup@2326(cenv cenv, TcGlobals g, FSharpList`1<string> namesOfMethodsThatMayDifferOnlyInReturnType, MethInfo minfo, Range m, Erasure erasureFlag);
    internal static FSharpFunc`2<PropInfo, bool> checkForDup@2389-2(cenv cenv, TcGlobals g, PropInfo pinfo, Range m, Erasure erasureFlag);
    internal static FSharpFunc`2<MethInfo, bool> checkForDup@2436-4(cenv cenv, TcGlobals g, MethInfo minfo, Range m, Erasure erasureFlag);
    internal static FSharpFunc`2<MethInfo, bool> checkForDup@2451-6(cenv cenv, TcGlobals g, MethInfo minfo, Range m, Erasure erasureFlag);
    [CompilerGeneratedAttribute]
internal static void CheckEntityDefn$cont@2426-1(cenv cenv, TcGlobals g, Range m, FSharpList`1<MethInfo> allVirtualMethsInParent, FSharpList`1<MethInfo> immediateMeths, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static void CheckEntityDefn$cont@2271(cenv cenv, Entity tycon, TcGlobals g, Range m, TType ty, Unit unitVar);
    internal static void visitType@2494-3(cenv cenv, Entity tycon, env env, Accessibility access, TType ty);
    [CompilerGeneratedAttribute]
internal static void CheckEntityDefn$cont@2526-2(cenv cenv, Entity tycon, TcGlobals g, Range m, TType ty, env env, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckEntityDefn(cenv cenv, env env, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckEntityDefns(cenv cenv, env env, FSharpList`1<Entity> tycons);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDefnsInModule(cenv cenv, env env, FSharpList`1<ModuleOrNamespaceContents> mdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckNothingAfterEntryPoint(cenv cenv, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDefnInModule(cenv cenv, env env, ModuleOrNamespaceContents mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckModuleSpec(cenv cenv, env env, ModuleOrNamespaceBinding mbind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckImplFileContents(cenv cenv, env env, ModuleOrNamespaceType implFileTy, ModuleOrNamespaceContents implFileContents);
    internal static void resolve@2627(FSharpOption`1<EntityRef> _arg1);
    internal static Tuple`2<bool, FSharpMap`2<long, AnonRecdTypeInfo>> CheckImplFile(TcGlobals g, ImportMap amap, bool reportErrors, InfoReader infoReader, FSharpList`1<CompilationPath> internalsVisibleToPaths, CcuThunk viewCcu, FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcValF, DisplayEnv denv, ModuleOrNamespaceType implFileTy, ModuleOrNamespaceContents implFileContents, FSharpList`1<Attrib> extraAttribs, Tuple`2<bool, bool> isLastCompiland, bool isInternalTestSpanStackReferring);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.PPLexer : object {
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063398@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063399@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063400@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063401@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063402@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063403@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063404@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063405@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063406@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063407@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063408@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063409@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063410@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063411@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063412@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063413@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063414@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063415@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063416@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063417@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063418@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063419@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063420@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063421@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063422@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063423@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063424@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063397_318Bytes@ field1063425@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063426_56Bytes@ field1063427@;
    [CompilationMappingAttribute("9")]
internal static UInt16[][] trans { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] actions { get; }
    [CompilationMappingAttribute("9")]
internal static UnicodeTables _fslex_tables { get; }
    private static PPLexer();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token fail(LexArgs args, LexBuffer`1<char> lexbuf, int e_0, string e_1);
    internal static UInt16[][] get_trans();
    internal static UInt16[] get_actions();
    internal static UnicodeTables get__fslex_tables();
    internal static a _fslex_dummy();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static token tokenstream(LexArgs args, LexBuffer`1<char> lexbuf);
    internal static token rest(LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.PPParser : object {
    [DebuggerBrowsableAttribute("0")]
internal static T1063367_92Bytes@ field1063368@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063369_10Bytes@ field1063370@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063371_168Bytes@ field1063372@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063373_62Bytes@ field1063374@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063375_344Bytes@ field1063376@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063373_62Bytes@ field1063377@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063378_38Bytes@ field1063379@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063378_38Bytes@ field1063380@;
    [DebuggerBrowsableAttribute("0")]
internal static T1063373_62Bytes@ field1063381@;
    [CompilationMappingAttribute("9")]
internal static LexerIfdefExpression dummy { get; }
    internal static int _fsyacc_endOfInputTag { get; }
    internal static int _fsyacc_tagOfErrorTerminal { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_gotos { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_sparseGotoTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_stateToProdIdxsTableRowOffsets { get; }
    internal static int _fsyacc_action_rows { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableElements { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_actionTableRowOffsets { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_reductionSymbolCounts { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_productionToNonTerminalTable { get; }
    [CompilationMappingAttribute("9")]
internal static UInt16[] _fsyacc_immediateActions { get; }
    [CompilationMappingAttribute("9")]
internal static Lazy`1<FSharpFunc`2[]> _fsyacc_reductions { get; }
    [CompilationMappingAttribute("9")]
internal static Tables`1<token> tables { get; }
    private static PPParser();
    internal static LexerIfdefExpression get_dummy();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LexerIfdefExpression fail(IParseState ps, int i, int e_0, string e_1);
    internal static int tagOfToken(token t);
    internal static tokenId tokenTagToTokenId(int tokenIdx);
    internal static nonTerminalId prodIdxToNonTerminal(int prodIdx);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_endOfInputTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_tagOfErrorTerminal();
    internal static string token_to_string(token t);
    internal static object _fsyacc_dataOfToken(token t);
    internal static UInt16[] get__fsyacc_gotos();
    internal static UInt16[] get__fsyacc_sparseGotoTableRowOffsets();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableElements();
    internal static UInt16[] get__fsyacc_stateToProdIdxsTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get__fsyacc_action_rows();
    internal static UInt16[] get__fsyacc_actionTableElements();
    internal static UInt16[] get__fsyacc_actionTableRowOffsets();
    internal static UInt16[] get__fsyacc_reductionSymbolCounts();
    internal static UInt16[] get__fsyacc_productionToNonTerminalTable();
    internal static UInt16[] get__fsyacc_immediateActions();
    internal static Lazy`1<FSharpFunc`2[]> get__fsyacc_reductions();
    internal static Tables`1<token> get_tables();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LexerIfdefExpression start(FSharpFunc`2<LexBuffer`1<char>, token> lexer, LexBuffer`1<char> lexbuf);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.QuotationPickler : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int PickleBufferCapacity;
    internal static string SerializedReflectedDefinitionsResourceNameBase { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ExprData, Byte[]> pickle { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Tuple`2<MethodBaseData, ExprData>>, Byte[]> PickleDefns { get; }
    private static QuotationPickler();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b mkRLinear(FSharpFunc`2<Tuple`2<a, b>, b> mk, FSharpList`1<a> vs, b body);
    internal static TypeData mkVarTy(int v);
    internal static TypeData mkFunTy(TypeData x1, TypeData x2);
    internal static TypeData mkArrayTy(int n, TypeData x);
    internal static TypeData mkILNamedTy(NamedTypeData r, FSharpList`1<TypeData> l);
    internal static ExprData mkVar(int v);
    internal static ExprData mkHole(TypeData v, int idx);
    internal static ExprData mkApp(ExprData a, ExprData b);
    internal static ExprData mkLambda(ValData a, ExprData b);
    internal static ExprData mkQuote(ExprData a);
    internal static ExprData mkQuoteRaw40(ExprData a);
    internal static ExprData mkCond(ExprData x1, ExprData x2, ExprData x3);
    internal static ExprData mkModuleValueApp(NamedTypeData tcref, string nm, bool isProp, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkModuleValueWApp(NamedTypeData tcref, string nm, bool isProp, string nmW, int nWitnesses, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkTuple(TypeData ty, FSharpList`1<ExprData> x);
    internal static ExprData mkLet(Tuple`2<ValData, ExprData> _arg1, ExprData b);
    internal static ExprData mkUnit();
    internal static ExprData mkNull(TypeData ty);
    internal static ExprData mkLetRecRaw(ExprData e1);
    internal static ExprData mkLetRec(FSharpList`1<Tuple`2<ValData, ExprData>> ves, ExprData body);
    internal static ExprData mkRecdMk(NamedTypeData n, FSharpList`1<TypeData> tys, FSharpList`1<ExprData> args);
    internal static ExprData mkRecdGet(NamedTypeData d1, string d2, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkRecdSet(NamedTypeData d1, string d2, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkUnion(NamedTypeData d1, string d2, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkUnionFieldGet(NamedTypeData d1, string d2, int d3, FSharpList`1<TypeData> tyargs, ExprData arg);
    internal static ExprData mkUnionCaseTagTest(NamedTypeData d1, string d2, FSharpList`1<TypeData> tyargs, ExprData arg);
    internal static ExprData mkTupleGet(TypeData ty, int n, ExprData e);
    internal static ExprData mkCoerce(TypeData ty, ExprData arg);
    internal static ExprData mkTypeTest(TypeData ty, ExprData arg);
    internal static ExprData mkAddressOf(ExprData arg);
    internal static ExprData mkAddressSet(ExprData arg1, ExprData arg2);
    internal static ExprData mkVarSet(ExprData arg1, ExprData arg2);
    internal static ExprData mkDefaultValue(TypeData ty);
    internal static ExprData mkThisVar(TypeData ty);
    internal static ExprData mkNewArray(TypeData ty, FSharpList`1<ExprData> args);
    internal static ExprData mkBool(bool v, TypeData ty);
    internal static ExprData mkString(string v, TypeData ty);
    internal static ExprData mkSingle(float v, TypeData ty);
    internal static ExprData mkDouble(double v, TypeData ty);
    internal static ExprData mkChar(char v, TypeData ty);
    internal static ExprData mkSByte(sbyte v, TypeData ty);
    internal static ExprData mkByte(byte v, TypeData ty);
    internal static ExprData mkInt16(short v, TypeData ty);
    internal static ExprData mkUInt16(ushort v, TypeData ty);
    internal static ExprData mkInt32(int v, TypeData ty);
    internal static ExprData mkUInt32(UInt32 v, TypeData ty);
    internal static ExprData mkInt64(long v, TypeData ty);
    internal static ExprData mkUInt64(ulong v, TypeData ty);
    internal static ExprData mkSequential(ExprData e1, ExprData e2);
    internal static ExprData mkIntegerForLoop(ExprData x1, ExprData x2, ExprData x3);
    internal static ExprData mkWhileLoop(ExprData e1, ExprData e2);
    internal static ExprData mkTryFinally(ExprData e1, ExprData e2);
    internal static ExprData mkTryWith(ExprData e1, ValData vf, ExprData ef, ValData vh, ExprData eh);
    internal static ExprData mkDelegate(TypeData ty, ExprData e);
    internal static ExprData mkPropGet(Tuple`4<NamedTypeData, string, TypeData, FSharpList`1<TypeData>> d, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkPropSet(Tuple`4<NamedTypeData, string, TypeData, FSharpList`1<TypeData>> d, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkFieldGet(NamedTypeData d1, string d2, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkFieldSet(NamedTypeData d1, string d2, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkCtorCall(CtorData d, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkMethodCall(MethodData d, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkMethodCallW(MethodData d1, MethodData d2, int d3, FSharpList`1<TypeData> tyargs, FSharpList`1<ExprData> args);
    internal static ExprData mkAttributedExpression(ExprData e, ExprData attr);
    internal static bool isAttributedExpression(ExprData e);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_SerializedReflectedDefinitionsResourceNameBase();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_NamedType(NamedTypeData x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tycon(TypeCombOp x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_type(TypeData x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_types(FSharpList`1<TypeData> x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_varDecl(ValData v, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_recdFieldSpec(NamedTypeData v_0, string v_1, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ucaseSpec(NamedTypeData v_0, string v_1, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_MethodData(MethodData a, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_CtorData(CtorData a, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_PropInfoData(NamedTypeData a_0, string a_1, TypeData a_2, FSharpList`1<TypeData> a_3, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_CombOp(CombOp x, QuotationPickleOutState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_expr(ExprData x, QuotationPickleOutState st);
    internal static FSharpFunc`2<ExprData, Byte[]> get_pickle();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_MethodBase(MethodBaseData x, QuotationPickleOutState st);
    internal static FSharpFunc`2<FSharpList`1<Tuple`2<MethodBaseData, ExprData>>, Byte[]> get_PickleDefns();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.QuotationTranslator : object {
    [CompilationMappingAttribute("9")]
internal static bool verboseCReflect { get; }
    internal static bool get_verboseCReflect();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QuotationTranslationEnv BindFormalTypars(QuotationTranslationEnv env, FSharpList`1<Typar> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QuotationTranslationEnv BindVal(QuotationTranslationEnv env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QuotationTranslationEnv BindIsInstVal(QuotationTranslationEnv env, Val v, TType ty, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QuotationTranslationEnv BindSubstVal(QuotationTranslationEnv env, Val v, Expr e);
    internal static FSharpOption`1<Tuple`6<ValRef, ValUseFlag, Expr, TType, FSharpList`1<TType>, FSharpList`1<Expr>>> loop@171-65(TcGlobals g, Expr expr, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`6<ValRef, ValUseFlag, Expr, TType, FSharpList`1<TType>, FSharpList`1<Expr>>> |ModuleValueOrMemberUse|_|(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Unit> |SimpleArrayLoopUpperBound|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<Expr, TType, Expr>> |SimpleArrayLoopBody|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |ObjectInitializationCheck|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSplice(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData EmitDebugInfoIfNecessary(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, ExprData astExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ExprData> GetWitnessArgs(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, FSharpList`1<Typar> tps, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvWitnessInfo(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvExprCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvLdfld(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, ILFieldSpec fspec, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvUnionFieldGet(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, UnionCaseRef ucref, int n, FSharpList`1<TType> tyargs, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvClassOrRecdFieldGet(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, RecdFieldRef rfref, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvClassOrRecdFieldGetCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, RecdFieldRef rfref, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Tuple`2<ValData, ExprData>>, QuotationTranslationEnv> ConvLetBind(QuotationGenerationScope cenv, QuotationTranslationEnv env, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ExprData> ConvLValueArgs(QuotationGenerationScope cenv, QuotationTranslationEnv env, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvLValueExpr(QuotationGenerationScope cenv, QuotationTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvLValueExprCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvObjectModelCall(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, bool callInfo_0, bool callInfo_1, bool callInfo_2, NamedTypeData callInfo_3, FSharpList`1<TypeData> callInfo_4, FSharpList`1<TypeData> callInfo_5, TypeData callInfo_6, string callInfo_7, FSharpList`1<TType> callInfo_8, int callInfo_9, FSharpList`1<Expr> callInfo_10, FSharpList`1<ExprData> callInfo_11, FSharpList`1<FSharpList`1<Expr>> callInfo_12);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvObjectModelCallCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, bool isPropGet, bool isPropSet, bool isNewObj, NamedTypeData parentTyconR, FSharpList`1<TypeData> witnessArgTypesR, FSharpList`1<TypeData> methArgTypesR, TypeData methRetTypeR, string methName, FSharpList`1<TType> tyargs, int numGenericArgs, FSharpList`1<Expr> objArgs, FSharpList`1<ExprData> witnessArgsR, FSharpList`1<FSharpList`1<Expr>> untupledCurriedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvModuleValueApp(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, ValRef vref, FSharpList`1<TType> tyargs, FSharpList`1<ExprData> witnessArgs, FSharpList`1<FSharpList`1<Expr>> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvModuleValueAppCore(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, ValRef vref, FSharpList`1<TType> tyargs, FSharpList`1<ExprData> witnessArgsR, FSharpList`1<FSharpList`1<Expr>> curriedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ExprData> ConvExprs(QuotationGenerationScope cenv, QuotationTranslationEnv env, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvValRef(bool holeOk, QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, ValRef vref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvValRefCore(bool holeOk, QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, ValRef vref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<NamedTypeData, string> ConvUnionCaseRef(QuotationGenerationScope cenv, UnionCaseRef ucref, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<NamedTypeData, string> ConvRecdFieldRef(QuotationGenerationScope cenv, RecdFieldRef rfref, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValData ConvVal(QuotationGenerationScope cenv, QuotationTranslationEnv env, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int ConvTyparRef(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, Typar tp);
    internal static FSharpList`1<TType> FilterMeasureTyargs(FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeData ConvType(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TypeData> ConvTypes(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvConst(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, Const c, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvDecisionTree(QuotationGenerationScope cenv, QuotationTranslationEnv env, DecisionTreeTarget[] tgs, TypeData typR, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsILTypeRefStaticLinkLocal(QuotationGenerationScope cenv, Range m, ILTypeRef tr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NamedTypeData ConvILTypeRefUnadjusted(QuotationGenerationScope cenv, Range m, ILTypeRef tr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NamedTypeData ConvILTypeRef(QuotationGenerationScope cenv, ILTypeRef tr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeData ConvVoidType(QuotationGenerationScope cenv, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeData ConvILType(QuotationGenerationScope cenv, QuotationTranslationEnv env, Range m, ILType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> TryElimErasableTyconRef(QuotationGenerationScope cenv, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NamedTypeData ConvTyconRef(QuotationGenerationScope cenv, EntityRef tcref, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeData ConvReturnType(QuotationGenerationScope cenv, QuotationTranslationEnv envinner, Range m, FSharpOption`1<TType> retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExprData ConvExprPublic(QuotationGenerationScope cenv, bool suppressWitnesses, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MethodBaseData ConvMethodBase(QuotationGenerationScope cenv, QuotationTranslationEnv env, string methName, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MethodBaseData, ExprData> ConvReflectedDefinition(QuotationGenerationScope cenv, string methName, Val v, Expr e);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.ScriptClosure : object {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SignatureConformance : object {
    internal static FSharpFunc`2<Attrib, bool> attribsEq@78(Checker this, FSharpFunc`2<AttribExpr, FSharpFunc`2<AttribExpr, bool>> attribExprEq, FSharpFunc`2<AttribNamedArg, FSharpFunc`2<AttribNamedArg, bool>> attribNamedArgEq, Attrib attrib1);
    internal static FSharpFunc`2<Attrib, bool> attribsHaveSameTycon@85(Checker this, Attrib attrib1);
    internal static FSharpList`1<Attrib> check@93-4(Checker this, FSharpFunc`2<AttribExpr, FSharpFunc`2<AttribExpr, bool>> attribExprEq, FSharpFunc`2<AttribNamedArg, FSharpFunc`2<AttribNamedArg, bool>> attribNamedArgEq, FSharpList`1<Attrib> keptImplAttribsRev, FSharpList`1<Attrib> implAttribs, FSharpList`1<Attrib> sigAttribs);
    internal static FSharpList`1<TType> flatten@203(Checker this, Range m, FSharpList`1<TType> tys);
    internal static bool err@334(EntityRef implModRef, InfoReader infoReader, Val implVal, Val sigVal, DisplayEnv denv, FSharpFunc`2<Tuple`3<string, string, string>, string> f);
    internal static bool err@377-2(Checker this, InfoReader infoReader, Entity enclosingImplTycon, UnionCase implUnionCase, UnionCase sigUnionCase, FSharpFunc`2<Tuple`2<string, string>, string> f);
    internal static bool err@389-3(Checker this, InfoReader infoReader, Entity enclosingImplTycon, Entity enclosingSigTycon, RecdField implField, RecdField sigField, FSharpFunc`2<Tuple`2<string, string>, string> f);
    internal static bool reportNiceError@498(Range m, Entity implTycon, string k, FSharpList`1<string> s1, FSharpList`1<string> s2);
    internal static FSharpList`1<string> names@532-4(FSharpList`1<UnionCase> l);
    internal static void sigValHadNoMatchingImplementation@617(Checker this, Range m, InfoReader infoReader, EntityRef implModRef, Val fx, FSharpOption`1<Val> _closeActualVal);
    internal static bool valuesPartiallyMatch@625(Val av, Val fv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckNamesOfModuleOrNamespaceContents(DisplayEnv denv, InfoReader infoReader, EntityRef implModRef, ModuleOrNamespaceType signModType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CheckNamesOfModuleOrNamespace(DisplayEnv denv, InfoReader infoReader, EntityRef implModRef, ModuleOrNamespaceType signModType);
}
[CompilationMappingAttribute("7")]
internal static class Fsharp.Compiler.SignatureHash : object {
    internal static int hashModuleOrNameSpaceBinding@470(TcGlobals g, ObserverVisibility observer, ModuleOrNamespaceBinding monb);
    internal static int hashSingleModuleOrNamespaceContents@476(TcGlobals g, ObserverVisibility observer, ModuleOrNamespaceContents x);
    internal static int hashSingleModuleOrNameSpaceIncludingName@493(TcGlobals g, ObserverVisibility observer, Entity mspec, ModuleOrNamespaceContents def);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int calculateHashOfImpliedSignature(TcGlobals g, ObserverVisibility observer, ModuleOrNamespaceContents expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int calculateSignatureHashOfFiles(FSharpList`1<CheckedImplFile> files, TcGlobals g, ObserverVisibility observer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int calculateHashOfAssemblyTopAttributes(TopAttribs attrs, FSharpOption`1<ILPlatform> platform);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SR : object {
    [CompilationMappingAttribute("9")]
internal static Lazy`1<ResourceManager> resources { get; }
    internal static Lazy`1<ResourceManager> get_resources();
    internal static string GetString(string name);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.StaticLinking : object {
    [CompilationMappingAttribute("9")]
internal static bool debugStaticLinking { get; }
    internal static bool get_debugStaticLinking();
    internal static bool isProvided@175(FSharpOption`1<CcuThunk> ccu);
    internal static Tuple`2<ILModuleDef, FSharpFunc`2<ILScopeRef, ILScopeRef>> StaticLinkILModules(TcConfig tcConfig, ILGlobals ilGlobals, TcImports tcImports, ILModuleDef ilxMainModule, FSharpList`1<Tuple`2<FSharpOption`1<CcuThunk>, ILModuleDef>> dependentILModules);
    internal static Node dummyEntry@281(ILModuleDef ilxMainModule, string nm);
    [CompilerGeneratedAttribute]
internal static FSharpList`1<Tuple`2<FSharpOption`1<CcuThunk>, ILModuleDef>> FindDependentILModulesForStaticLinking$cont@279(TcImports tcImports, TcConfig tcConfig, ILModuleDef ilxMainModule, ILGlobals ilGlobals, CompilationThreadToken ctok, Unit unitVar);
    internal static FSharpList`1<Tuple`2<FSharpOption`1<CcuThunk>, ILModuleDef>> FindDependentILModulesForStaticLinking(CompilationThreadToken ctok, TcConfig tcConfig, TcImports tcImports, ILGlobals ilGlobals, ILModuleDef ilxMainModule);
    internal static FSharpList`1<Tuple`2<Tuple`3<FSharpOption`1<CcuThunk>, ILScopeRef, ILModuleDef>, Tuple`2<string, a>>> FindProviderGeneratedILModules(CompilationThreadToken ctok, TcImports tcImports, FSharpList`1<Tuple`2<ImportedBinary, a>> providerGeneratedAssemblies);
    internal static Tuple`3<FSharpList`1<a>, FSharpOption`1<a>, FSharpList`1<a>> loop@454-87(FSharpFunc`2<a, bool> p, FSharpList`1<a> xs, FSharpList`1<a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<a>, FSharpOption`1<a>, FSharpList`1<a>> trySplitFind(FSharpFunc`2<a, bool> p, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILTypeDefs implantTypeDef(ILGlobals ilGlobals, bool isNested, ILTypeDefs tdefs, FSharpList`1<string> enc, ILTypeDef td);
    internal static IEnumerable`1<Tuple`2<ILTypeRef, ILTypeDef>> loop@580-88(ILTypeRef ilOrigTyRef, ILTypeDef ilTypeDef);
    internal static ILTypeDef buildRelocatedGeneratedType@602(ILGlobals ilGlobals, IDictionary`2<ILTypeRef, ILTypeDef> allTypeDefsInProviderGeneratedAssemblies, ProviderGeneratedType _arg1);
    internal static ILTypeDefs rw@675(IDictionary`2<ILTypeRef, ProviderGeneratedType> ilOrigTyRefsForProviderGeneratedTypesToRelocate, ILScopeRef ilOrigScopeRef, FSharpList`1<string> enc, ILTypeDefs tdefs);
    internal static ILScopeRef validateTargetPlatform@712(bool isMscorlib, ILScopeRef scopeRef);
    internal static FSharpFunc`2<ILModuleDef, ILModuleDef> StaticLink(CompilationThreadToken ctok, TcConfig tcConfig, TcImports tcImports, TcGlobals tcGlobals);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.Symbols.E : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static E _unique_Unused;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsThisValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsBaseValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsApplication { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLambda { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTypeLambda { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsIfThenElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDecisionTree { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDecisionTreeSuccess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCall { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewObject { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLetRec { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsObjectExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFSharpFieldGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFSharpFieldSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewUnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewAnonRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAnonRecordGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseTag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnionCaseTest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTraitCall { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewTuple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTupleGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCoerce { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTypeTest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAddressSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsValueSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static E Unused { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnused { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDefaultValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsConst { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAddressOf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsSequential { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsIntegerForLoop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWhileLoop { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTryFinally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTryWith { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNewDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsILFieldGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsILFieldSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsILAsm { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWitnessArg { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDebugPoint { get; }
    private static E();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Symbols.E")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal E(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static E NewValue(FSharpMemberOrFunctionOrValue item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsValue();
    [CompilationMappingAttribute("8", "1")]
internal static E NewThisValue(FSharpType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsThisValue();
    [CompilationMappingAttribute("8", "2")]
internal static E NewBaseValue(FSharpType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsBaseValue();
    [CompilationMappingAttribute("8", "3")]
internal static E NewApplication(FSharpExpr item1, FSharpList`1<FSharpType> item2, FSharpList`1<FSharpExpr> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsApplication();
    [CompilationMappingAttribute("8", "4")]
internal static E NewLambda(FSharpMemberOrFunctionOrValue item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLambda();
    [CompilationMappingAttribute("8", "5")]
internal static E NewTypeLambda(FSharpList`1<FSharpGenericParameter> item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTypeLambda();
    [CompilationMappingAttribute("8", "6")]
internal static E NewQuote(FSharpExpr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsQuote();
    [CompilationMappingAttribute("8", "7")]
internal static E NewIfThenElse(FSharpExpr item1, FSharpExpr item2, FSharpExpr item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsIfThenElse();
    [CompilationMappingAttribute("8", "8")]
internal static E NewDecisionTree(FSharpExpr item1, FSharpList`1<Tuple`2<FSharpList`1<FSharpMemberOrFunctionOrValue>, FSharpExpr>> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDecisionTree();
    [CompilationMappingAttribute("8", "9")]
internal static E NewDecisionTreeSuccess(int item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDecisionTreeSuccess();
    [CompilationMappingAttribute("8", "10")]
internal static E NewCall(FSharpOption`1<FSharpExpr> item1, FSharpMemberOrFunctionOrValue item2, FSharpList`1<FSharpType> item3, FSharpList`1<FSharpType> item4, FSharpList`1<FSharpExpr> item5, FSharpList`1<FSharpExpr> item6);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCall();
    [CompilationMappingAttribute("8", "11")]
internal static E NewNewObject(FSharpMemberOrFunctionOrValue item1, FSharpList`1<FSharpType> item2, FSharpList`1<FSharpExpr> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewObject();
    [CompilationMappingAttribute("8", "12")]
internal static E NewLetRec(FSharpList`1<Tuple`3<FSharpMemberOrFunctionOrValue, FSharpExpr, DebugPointAtBinding>> item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLetRec();
    [CompilationMappingAttribute("8", "13")]
internal static E NewLet(Tuple`3<FSharpMemberOrFunctionOrValue, FSharpExpr, DebugPointAtBinding> item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLet();
    [CompilationMappingAttribute("8", "14")]
internal static E NewNewRecord(FSharpType item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewRecord();
    [CompilationMappingAttribute("8", "15")]
internal static E NewObjectExpr(FSharpType item1, FSharpExpr item2, FSharpList`1<FSharpObjectExprOverride> item3, FSharpList`1<Tuple`2<FSharpType, FSharpList`1<FSharpObjectExprOverride>>> item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsObjectExpr();
    [CompilationMappingAttribute("8", "16")]
internal static E NewFSharpFieldGet(FSharpOption`1<FSharpExpr> item1, FSharpType item2, FSharpField item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFSharpFieldGet();
    [CompilationMappingAttribute("8", "17")]
internal static E NewFSharpFieldSet(FSharpOption`1<FSharpExpr> item1, FSharpType item2, FSharpField item3, FSharpExpr item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFSharpFieldSet();
    [CompilationMappingAttribute("8", "18")]
internal static E NewNewUnionCase(FSharpType item1, FSharpUnionCase item2, FSharpList`1<FSharpExpr> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewUnionCase();
    [CompilationMappingAttribute("8", "19")]
internal static E NewNewAnonRecord(FSharpType item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewAnonRecord();
    [CompilationMappingAttribute("8", "20")]
internal static E NewAnonRecordGet(FSharpExpr item1, FSharpType item2, int item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAnonRecordGet();
    [CompilationMappingAttribute("8", "21")]
internal static E NewUnionCaseGet(FSharpExpr item1, FSharpType item2, FSharpUnionCase item3, FSharpField item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseGet();
    [CompilationMappingAttribute("8", "22")]
internal static E NewUnionCaseSet(FSharpExpr item1, FSharpType item2, FSharpUnionCase item3, FSharpField item4, FSharpExpr item5);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseSet();
    [CompilationMappingAttribute("8", "23")]
internal static E NewUnionCaseTag(FSharpExpr item1, FSharpType item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseTag();
    [CompilationMappingAttribute("8", "24")]
internal static E NewUnionCaseTest(FSharpExpr item1, FSharpType item2, FSharpUnionCase item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnionCaseTest();
    [CompilationMappingAttribute("8", "25")]
internal static E NewTraitCall(FSharpList`1<FSharpType> item1, string item2, SynMemberFlags item3, FSharpList`1<FSharpType> item4, FSharpList`1<FSharpType> item5, FSharpList`1<FSharpExpr> item6);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTraitCall();
    [CompilationMappingAttribute("8", "26")]
internal static E NewNewTuple(FSharpType item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewTuple();
    [CompilationMappingAttribute("8", "27")]
internal static E NewTupleGet(FSharpType item1, int item2, FSharpExpr item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTupleGet();
    [CompilationMappingAttribute("8", "28")]
internal static E NewCoerce(FSharpType item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCoerce();
    [CompilationMappingAttribute("8", "29")]
internal static E NewNewArray(FSharpType item1, FSharpList`1<FSharpExpr> item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewArray();
    [CompilationMappingAttribute("8", "30")]
internal static E NewTypeTest(FSharpType item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTypeTest();
    [CompilationMappingAttribute("8", "31")]
internal static E NewAddressSet(FSharpExpr item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAddressSet();
    [CompilationMappingAttribute("8", "32")]
internal static E NewValueSet(FSharpMemberOrFunctionOrValue item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsValueSet();
    [CompilationMappingAttribute("8", "33")]
internal static E get_Unused();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnused();
    [CompilationMappingAttribute("8", "34")]
internal static E NewDefaultValue(FSharpType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDefaultValue();
    [CompilationMappingAttribute("8", "35")]
internal static E NewConst(object item1, FSharpType item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsConst();
    [CompilationMappingAttribute("8", "36")]
internal static E NewAddressOf(FSharpExpr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAddressOf();
    [CompilationMappingAttribute("8", "37")]
internal static E NewSequential(FSharpExpr item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsSequential();
    [CompilationMappingAttribute("8", "38")]
internal static E NewIntegerForLoop(FSharpExpr item1, FSharpExpr item2, FSharpExpr item3, bool item4, DebugPointAtFor item5, DebugPointAtInOrTo item6);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsIntegerForLoop();
    [CompilationMappingAttribute("8", "39")]
internal static E NewWhileLoop(FSharpExpr item1, FSharpExpr item2, DebugPointAtWhile item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWhileLoop();
    [CompilationMappingAttribute("8", "40")]
internal static E NewTryFinally(FSharpExpr item1, FSharpExpr item2, DebugPointAtTry item3, DebugPointAtFinally item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTryFinally();
    [CompilationMappingAttribute("8", "41")]
internal static E NewTryWith(FSharpExpr item1, FSharpMemberOrFunctionOrValue item2, FSharpExpr item3, FSharpMemberOrFunctionOrValue item4, FSharpExpr item5, DebugPointAtTry item6, DebugPointAtWith item7);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTryWith();
    [CompilationMappingAttribute("8", "42")]
internal static E NewNewDelegate(FSharpType item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNewDelegate();
    [CompilationMappingAttribute("8", "43")]
internal static E NewILFieldGet(FSharpOption`1<FSharpExpr> item1, FSharpType item2, string item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsILFieldGet();
    [CompilationMappingAttribute("8", "44")]
internal static E NewILFieldSet(FSharpOption`1<FSharpExpr> item1, FSharpType item2, string item3, FSharpExpr item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsILFieldSet();
    [CompilationMappingAttribute("8", "45")]
internal static E NewILAsm(string item1, FSharpList`1<FSharpType> item2, FSharpList`1<FSharpExpr> item3);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsILAsm();
    [CompilationMappingAttribute("8", "46")]
internal static E NewWitnessArg(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWitnessArg();
    [CompilationMappingAttribute("8", "47")]
internal static E NewDebugPoint(DebugPointAtLeafExpr item1, FSharpExpr item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDebugPoint();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(E obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Symbols.EnvMisc2 : object {
    [CompilationMappingAttribute("9")]
internal static int maxMembers { get; }
    internal static int get_maxMembers();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Symbols.ExprTranslationImpl : object {
    internal static a wfail(string msg, Range m);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAbstractParameter : object {
    internal SlotParam info;
    internal SymbolEnv cenv;
    public FSharpOption`1<string> Name { get; }
    public FSharpType Type { get; }
    public bool IsInArg { get; }
    public bool IsOutArg { get; }
    public bool IsOptionalArg { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    internal FSharpAbstractParameter(SymbolEnv cenv, SlotParam info);
    public FSharpOption`1<string> get_Name();
    public FSharpType get_Type();
    public bool get_IsInArg();
    public bool get_IsOutArg();
    public bool get_IsOptionalArg();
    public IList`1<FSharpAttribute> get_Attributes();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAbstractSignature : object {
    internal SlotSig info;
    internal SymbolEnv cenv;
    public IList`1<IList`1<FSharpAbstractParameter>> AbstractArguments { get; }
    public FSharpType AbstractReturnType { get; }
    public IList`1<FSharpGenericParameter> DeclaringTypeGenericParameters { get; }
    public IList`1<FSharpGenericParameter> MethodGenericParameters { get; }
    public string Name { get; }
    public FSharpType DeclaringType { get; }
    internal FSharpAbstractSignature(SymbolEnv cenv, SlotSig info);
    public IList`1<IList`1<FSharpAbstractParameter>> get_AbstractArguments();
    public FSharpType get_AbstractReturnType();
    public IList`1<FSharpGenericParameter> get_DeclaringTypeGenericParameters();
    public IList`1<FSharpGenericParameter> get_MethodGenericParameters();
    public string get_Name();
    public FSharpType get_DeclaringType();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAccessibility : object {
    internal Accessibility a;
    internal bool isProtected@31;
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsInternal { get; }
    public bool IsProtected { get; }
    internal Accessibility Contents { get; }
    internal FSharpAccessibility(Accessibility a, FSharpOption`1<bool> isProtected);
    public bool get_IsPublic();
    public bool get_IsPrivate();
    public bool get_IsInternal();
    public bool get_IsProtected();
    internal Accessibility get_Contents();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool isInternalCompPath(CompilationPath x);
    [CompilerGeneratedAttribute]
internal FSharpChoice`3<Unit, Unit, Unit> |Public|Internal|Private|(Accessibility _arg1);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAccessibilityRights : object {
    internal CcuThunk thisCcu;
    internal AccessorDomain ad;
    internal CcuThunk ThisCcu { get; }
    internal AccessorDomain Contents { get; }
    internal FSharpAccessibilityRights(CcuThunk thisCcu, AccessorDomain ad);
    internal CcuThunk get_ThisCcu();
    internal AccessorDomain get_Contents();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpActivePatternCase : FSharpSymbol {
    internal FSharpOption`1<ValRef> valOpt;
    internal TType ty;
    internal int n;
    internal SymbolEnv cenv;
    internal ActivePatternInfo apinfo;
    public string Name { get; }
    public int Index { get; }
    public Range DeclarationLocation { get; }
    public FSharpActivePatternGroup Group { get; }
    public FSharpXmlDoc XmlDoc { get; }
    internal IList`1<string> ElaboratedXmlDoc { get; }
    public string XmlDocSig { get; }
    internal FSharpActivePatternCase(SymbolEnv cenv, ActivePatternInfo apinfo, TType ty, int n, FSharpOption`1<ValRef> valOpt, Item item);
    public string get_Name();
    public int get_Index();
    public Range get_DeclarationLocation();
    public FSharpActivePatternGroup get_Group();
    public FSharpXmlDoc get_XmlDoc();
    internal IList`1<string> get_ElaboratedXmlDoc();
    public string get_XmlDocSig();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpActivePatternGroup : object {
    internal FSharpOption`1<ValRef> valOpt;
    internal TType ty;
    internal SymbolEnv cenv;
    internal ActivePatternInfo apinfo;
    public FSharpOption`1<string> Name { get; }
    public IList`1<string> Names { get; }
    public bool IsTotal { get; }
    public FSharpType OverallType { get; }
    public FSharpOption`1<FSharpEntity> DeclaringEntity { get; }
    internal FSharpActivePatternGroup(SymbolEnv cenv, ActivePatternInfo apinfo, TType ty, FSharpOption`1<ValRef> valOpt);
    public FSharpOption`1<string> get_Name();
    public IList`1<string> get_Names();
    public bool get_IsTotal();
    public FSharpType get_OverallType();
    public FSharpOption`1<FSharpEntity> get_DeclaringEntity();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAnonRecordTypeDetails : object {
    internal SymbolEnv cenv;
    internal AnonRecdTypeInfo anonInfo;
    public FSharpAssembly Assembly { get; }
    public FSharpList`1<string> EnclosingCompiledTypeNames { get; }
    public string CompiledName { get; }
    public String[] SortedFieldNames { get; }
    internal FSharpAnonRecordTypeDetails(SymbolEnv cenv, AnonRecdTypeInfo anonInfo);
    public FSharpAssembly get_Assembly();
    public FSharpList`1<string> get_EnclosingCompiledTypeNames();
    public string get_CompiledName();
    public String[] get_SortedFieldNames();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAssembly : object {
    internal SymbolEnv cenv;
    internal CcuThunk ccu;
    internal CcuThunk RawCcuThunk { get; }
    public string QualifiedName { get; }
    public FSharpOption`1<string> FileName { get; }
    public string SimpleName { get; }
    public bool IsProviderGenerated { get; }
    public FSharpAssemblySignature Contents { get; }
    internal FSharpAssembly(SymbolEnv cenv, CcuThunk ccu);
    internal FSharpAssembly(TcGlobals tcGlobals, TcImports tcImports, CcuThunk ccu);
    internal CcuThunk get_RawCcuThunk();
    public string get_QualifiedName();
    public FSharpOption`1<string> get_FileName();
    public string get_SimpleName();
    public bool get_IsProviderGenerated();
    public FSharpAssemblySignature get_Contents();
    public virtual string ToString();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAssemblyContents : object {
    internal FSharpList`1<CheckedImplFile> mimpls;
    internal SymbolEnv cenv;
    public FSharpList`1<FSharpImplementationFileContents> ImplementationFiles { get; }
    internal FSharpAssemblyContents(SymbolEnv cenv, FSharpList`1<CheckedImplFile> mimpls);
    internal FSharpAssemblyContents(TcGlobals tcGlobals, CcuThunk thisCcu, FSharpOption`1<ModuleOrNamespaceType> thisCcuType, TcImports tcImports, FSharpList`1<CheckedImplFile> mimpls);
    public FSharpList`1<FSharpImplementationFileContents> get_ImplementationFiles();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAssemblySignature : object {
    internal FSharpOption`1<TopAttribs> topAttribs;
    internal FSharpOption`1<CcuThunk> optViewedCcu;
    internal ModuleOrNamespaceType mtyp;
    internal SymbolEnv cenv;
    public IList`1<FSharpEntity> Entities { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    internal FSharpAssemblySignature(SymbolEnv cenv, FSharpOption`1<TopAttribs> topAttribs, FSharpOption`1<CcuThunk> optViewedCcu, ModuleOrNamespaceType mtyp);
    internal FSharpAssemblySignature(SymbolEnv cenv, CcuThunk ccu);
    internal FSharpAssemblySignature(TcGlobals tcGlobals, CcuThunk thisCcu, ModuleOrNamespaceType thisCcuTyp, TcImports tcImports, FSharpOption`1<TopAttribs> topAttribs, ModuleOrNamespaceType contents);
    public IList`1<FSharpEntity> get_Entities();
    public IList`1<FSharpAttribute> get_Attributes();
    public FSharpOption`1<FSharpEntity> FindEntityByPath(FSharpList`1<string> path);
    public IEnumerable`1<FSharpEntity> TryGetEntities();
    public virtual string ToString();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpAttribute : object {
    internal SymbolEnv cenv;
    internal AttribInfo attrib;
    public FSharpEntity AttributeType { get; }
    public bool IsUnresolved { get; }
    public IList`1<Tuple`2<FSharpType, object>> ConstructorArguments { get; }
    public IList`1<Tuple`4<FSharpType, string, bool, object>> NamedArguments { get; }
    public Range Range { get; }
    internal FSharpAttribute(SymbolEnv cenv, AttribInfo attrib);
    public FSharpEntity get_AttributeType();
    public bool get_IsUnresolved();
    public IList`1<Tuple`2<FSharpType, object>> get_ConstructorArguments();
    public IList`1<Tuple`4<FSharpType, string, bool, object>> get_NamedArguments();
    public string Format(FSharpDisplayContext context);
    public Range get_Range();
    public virtual string ToString();
    public bool IsAttribute();
    [CompilerGeneratedAttribute]
internal object resolveArgObj(object arg);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpDelegateSignature : object {
    internal SlotSig info;
    internal SymbolEnv cenv;
    public IList`1<Tuple`2<FSharpOption`1<string>, FSharpType>> DelegateArguments { get; }
    public FSharpType DelegateReturnType { get; }
    internal FSharpDelegateSignature(SymbolEnv cenv, SlotSig info);
    public IList`1<Tuple`2<FSharpOption`1<string>, FSharpType>> get_DelegateArguments();
    public FSharpType get_DelegateReturnType();
    public virtual string ToString();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpDisplayContext : object {
    internal FSharpFunc`2<TcGlobals, DisplayEnv> denv;
    public static FSharpDisplayContext Empty { get; }
    internal FSharpDisplayContext(FSharpFunc`2<TcGlobals, DisplayEnv> denv);
    internal DisplayEnv Contents(TcGlobals g);
    public static FSharpDisplayContext get_Empty();
    public FSharpDisplayContext WithShortTypeNames(bool shortNames);
    public FSharpDisplayContext WithPrefixGenericParameters();
    public FSharpDisplayContext WithSuffixGenericParameters();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpEntity : FSharpSymbol {
    internal EntityRef entity;
    internal SymbolEnv cenv;
    internal EntityRef Entity { get; }
    public string LogicalName { get; }
    public string CompiledName { get; }
    internal string DisplayNameCore { get; }
    public string DisplayName { get; }
    public string AccessPath { get; }
    public FSharpOption`1<FSharpEntity> DeclaringEntity { get; }
    public FSharpOption`1<string> Namespace { get; }
    internal ILTypeRef CompiledRepresentation { get; }
    public string QualifiedName { get; }
    public string BasicQualifiedName { get; }
    public string FullName { get; }
    public FSharpOption`1<string> TryFullName { get; }
    public Range DeclarationLocation { get; }
    public IList`1<FSharpGenericParameter> GenericParameters { get; }
    public bool IsMeasure { get; }
    public bool IsAbstractClass { get; }
    public bool IsFSharpModule { get; }
    public bool HasFSharpModuleSuffix { get; }
    public bool IsValueType { get; }
    public bool IsArrayType { get; }
    public int ArrayRank { get; }
    public bool IsProvided { get; }
    public bool IsProvidedAndErased { get; }
    public bool IsStaticInstantiation { get; }
    public bool IsProvidedAndGenerated { get; }
    public bool IsClass { get; }
    public bool IsByRef { get; }
    public bool IsOpaque { get; }
    public bool IsInterface { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsFSharpExceptionDeclaration { get; }
    public bool IsUnresolved { get; }
    public bool IsFSharp { get; }
    public bool IsFSharpAbbreviation { get; }
    public bool IsFSharpRecord { get; }
    public bool IsFSharpUnion { get; }
    public bool HasAssemblyCodeRepresentation { get; }
    public FSharpDelegateSignature FSharpDelegateSignature { get; }
    public FSharpAccessibility Accessibility { get; }
    public FSharpAccessibility RepresentationAccessibility { get; }
    public IList`1<FSharpType> DeclaredInterfaces { get; }
    public IList`1<FSharpType> AllInterfaces { get; }
    public bool IsAttributeType { get; }
    internal bool IsDisposableType { get; }
    public FSharpOption`1<FSharpType> BaseType { get; }
    public bool UsesPrefixDisplay { get; }
    public bool IsNamespace { get; }
    public IList`1<FSharpMemberOrFunctionOrValue> MembersFunctionsAndValues { get; }
    public string XmlDocSig { get; }
    public FSharpXmlDoc XmlDoc { get; }
    internal IList`1<string> ElaboratedXmlDoc { get; }
    public IList`1<FSharpStaticParameter> StaticParameters { get; }
    public IList`1<FSharpEntity> NestedEntities { get; }
    public IList`1<FSharpUnionCase> UnionCases { get; }
    public IList`1<FSharpField> FSharpFields { get; }
    public FSharpType AbbreviatedType { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public FSharpList`1<string> AllCompilationPaths { get; }
    public FSharpList`1<FSharpActivePatternCase> ActivePatternCases { get; }
    internal FSharpEntity(SymbolEnv cenv, EntityRef entity);
    internal EntityRef get_Entity();
    public string get_LogicalName();
    public string get_CompiledName();
    internal string get_DisplayNameCore();
    public string get_DisplayName();
    public string get_AccessPath();
    public FSharpOption`1<FSharpEntity> get_DeclaringEntity();
    public FSharpOption`1<string> get_Namespace();
    internal ILTypeRef get_CompiledRepresentation();
    public string get_QualifiedName();
    public string get_BasicQualifiedName();
    public string get_FullName();
    public FSharpOption`1<string> get_TryFullName();
    public Range get_DeclarationLocation();
    public IList`1<FSharpGenericParameter> get_GenericParameters();
    public bool get_IsMeasure();
    public bool get_IsAbstractClass();
    public bool get_IsFSharpModule();
    public bool get_HasFSharpModuleSuffix();
    public bool get_IsValueType();
    public bool get_IsArrayType();
    public int get_ArrayRank();
    public bool get_IsProvided();
    public bool get_IsProvidedAndErased();
    public bool get_IsStaticInstantiation();
    public bool get_IsProvidedAndGenerated();
    public bool get_IsClass();
    public bool get_IsByRef();
    public bool get_IsOpaque();
    public bool get_IsInterface();
    public bool get_IsDelegate();
    public bool get_IsEnum();
    public bool get_IsFSharpExceptionDeclaration();
    public bool get_IsUnresolved();
    public bool get_IsFSharp();
    public bool get_IsFSharpAbbreviation();
    public bool get_IsFSharpRecord();
    public bool get_IsFSharpUnion();
    public bool get_HasAssemblyCodeRepresentation();
    public FSharpDelegateSignature get_FSharpDelegateSignature();
    public virtual FSharpAccessibility get_Accessibility();
    public FSharpAccessibility get_RepresentationAccessibility();
    public IList`1<FSharpType> get_DeclaredInterfaces();
    public IList`1<FSharpType> get_AllInterfaces();
    public bool get_IsAttributeType();
    internal bool get_IsDisposableType();
    public FSharpOption`1<FSharpType> get_BaseType();
    public bool get_UsesPrefixDisplay();
    public bool get_IsNamespace();
    public IList`1<FSharpMemberOrFunctionOrValue> get_MembersFunctionsAndValues();
    public string get_XmlDocSig();
    public FSharpXmlDoc get_XmlDoc();
    internal IList`1<string> get_ElaboratedXmlDoc();
    public IList`1<FSharpStaticParameter> get_StaticParameters();
    public IList`1<FSharpEntity> get_NestedEntities();
    public IList`1<FSharpUnionCase> get_UnionCases();
    public IList`1<FSharpField> get_FSharpFields();
    public FSharpType get_AbbreviatedType();
    public FSharpType AsType();
    public virtual IList`1<FSharpAttribute> get_Attributes();
    public FSharpList`1<string> get_AllCompilationPaths();
    public FSharpList`1<FSharpActivePatternCase> get_ActivePatternCases();
    public FSharpOption`1<string> TryGetFullName();
    public FSharpOption`1<string> TryGetFullDisplayName();
    public FSharpOption`1<string> TryGetFullCompiledName();
    public IEnumerable`1<FSharpEntity> GetPublicNestedEntities();
    public IList`1<FSharpMemberOrFunctionOrValue> TryGetMembersFunctionsAndValues();
    public FSharpOption`1<ISourceText> TryGetMetadataText();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool isResolvedAndFSharp();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal bool isResolved();
    [CompilerGeneratedAttribute]
internal void checkIsResolved();
    [CompilerGeneratedAttribute]
internal bool isDefinedInFSharpCore();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpExpr : object {
    internal TType ty;
    internal Range m;
    internal FSharpOption`1<FSharpFunc`2<Unit, FSharpExpr>> f;
    internal SymbolEnv cenv@146;
    internal E e@148;
    public Range Range { get; }
    public FSharpType Type { get; }
    internal SymbolEnv cenv { get; }
    internal E E { get; }
    public FSharpList`1<FSharpExpr> ImmediateSubExpressions { get; }
    internal FSharpExpr(SymbolEnv cenv, FSharpOption`1<FSharpFunc`2<Unit, FSharpExpr>> f, E e, Range m, TType ty);
    public Range get_Range();
    public FSharpType get_Type();
    internal SymbolEnv get_cenv();
    internal E get_E();
    public virtual string ToString();
    public FSharpList`1<FSharpExpr> get_ImmediateSubExpressions();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Symbols.FSharpExprConvert : object {
    internal static bool IsStaticInitializationField(RecdFieldRef rfref);
    internal static FSharpOption`1<Unit> |StaticInitializationCheck|_|(Expr e);
    internal static FSharpOption`1<Unit> |StaticInitializationCount|_|(Expr e);
    internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<Range, FSharpFunc`2<TType, FSharpFunc`2<Expr, Expr>>>>> |ILUnaryOp|_|(ILInstr e);
    internal static FSharpOption`1<Tuple`2<FSharpFunc`2<a, FSharpFunc`2<Range, FSharpFunc`2<TType, FSharpFunc`2<TType, FSharpFunc`2<TType, FSharpFunc`2<Expr, FSharpFunc`2<Expr, Expr>>>>>>>, bool>> |ILMulDivOp|_|(ILInstr e);
    internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<Range, FSharpFunc`2<TType, FSharpFunc`2<Expr, FSharpFunc`2<Expr, Expr>>>>>> |ILBinaryOp|_|(ILInstr e);
    internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<Range, FSharpFunc`2<TType, FSharpFunc`2<Expr, Expr>>>>> |ILConvertOp|_|(ILInstr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpFunc`2<a, FSharpFunc`2<Range, FSharpFunc`2<TType, FSharpFunc`2<Expr, Expr>>>>> |TTypeConvOp|_|(SymbolEnv cenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpType ConvILTypeRefApp(SymbolEnv cenv, Range m, ILTypeRef tref, FSharpList`1<TType> tyargs);
    [CompilerGeneratedAttribute]
internal static Expr exprOfExprAddr$cont@348(Expr expr, TcGlobals g, Range m, ILArrayShape shape, FSharpList`1<Expr> idxs, TType elemTy, Expr arr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr exprOfExprAddr(SymbolEnv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr Mk2(SymbolEnv cenv, Expr orig, E e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr ConvExpr(SymbolEnv cenv, ExprTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvExprLinear(SymbolEnv cenv, ExprTranslationEnv env, Expr expr, FSharpFunc`2<FSharpExpr, E> contF);
    [CompilerGeneratedAttribute]
internal static E func1@1-28(FSharpUnionCase mkR, FSharpType typR, FSharpExpr e1R, FSharpExpr e2R);
    [CompilerGeneratedAttribute]
internal static E func1@1-29(FSharpExpr dtreeR, FSharpList`1<Tuple`2<FSharpList`1<FSharpMemberOrFunctionOrValue>, FSharpExpr>> targetsR);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvExprPrimLinear(SymbolEnv cenv, ExprTranslationEnv env, Expr expr, FSharpFunc`2<E, E> contF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvModuleValueOrMemberUseLinear(SymbolEnv cenv, ExprTranslationEnv env, Expr expr, ValRef vref, ValUseFlag vFlags, FSharpList`1<TType> tyargs, FSharpList`1<Expr> curriedArgs, FSharpFunc`2<E, E> contF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpExpr> GetWitnessArgs(SymbolEnv cenv, ExprTranslationEnv env, ValRef vref, Range m, FSharpList`1<Typar> tps, FSharpList`1<TType> tyargs);
    internal static FSharpList`1<FSharpObjectExprOverride> ConvertMethods@607(SymbolEnv cenv, ExprTranslationEnv env, IEnumerable`1<ObjExprMethod> methods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvExprPrim(SymbolEnv cenv, ExprTranslationEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvWitnessInfoPrim(ExprTranslationEnv env, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr ConvWitnessInfo(SymbolEnv cenv, ExprTranslationEnv env, Range m, TraitConstraintInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<Tuple`3<FSharpMemberOrFunctionOrValue, FSharpExpr, DebugPointAtBinding>>, ExprTranslationEnv> ConvLetBind(SymbolEnv cenv, ExprTranslationEnv env, Binding bind);
    internal static E makeCall@993(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<TType> methTypeArgs, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> callArgs, bool isNewObj, FSharpMemberOrFunctionOrValue minfo);
    internal static E makeFSCall@996(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<TType> methTypeArgs, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> callArgs, TcGlobals g, bool isNewObj, TType enclosingTy, bool isMember, ValRef vr);
    internal static E makeFSExpr@1006(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<TType> methTypeArgs, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> callArgs, TcGlobals g, bool isNewObj, bool isPropGet, bool isProp, EntityRef tcref, FSharpOption`1<string> subClass, TType enclosingTy, bool isMember, ValRef vr);
    [CompilerGeneratedAttribute]
internal static E ConvILCall$cont@1141(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<TType> methTypeArgs, Range m, ILMethodRef ilMethRef, FSharpList`1<TType> enclTypeArgs, FSharpList`1<Expr> callArgs, TcGlobals g, bool isNewObj, bool isPropGet, bool isProp, EntityRef tcref, FSharpOption`1<string> subClass, TType enclosingTy, FSharpOption`1<string> memberParentName, string logicalName, bool isMember, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvILCall(SymbolEnv cenv, ExprTranslationEnv env, bool isNewObj, ValUseFlag valUseFlags, ILMethodRef ilMethRef, FSharpList`1<TType> enclTypeArgs, FSharpList`1<TType> methTypeArgs, FSharpList`1<Expr> callArgs, Range m);
    [CompilerGeneratedAttribute]
internal static E func1@1-30(FSharpList`1<FSharpExpr> witnessArgsR, FSharpMemberOrFunctionOrValue v, bool isNewObj, FSharpList`1<FSharpType> enclTyArgsR, FSharpList`1<FSharpType> methTyArgsR, FSharpOption`1<FSharpExpr> objR, FSharpList`1<FSharpExpr> callArgsR);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvObjectModelCallLinear(SymbolEnv cenv, ExprTranslationEnv env, bool isNewObj, FSharpMemberOrFunctionOrValue v, FSharpList`1<TType> enclTyArgs, FSharpList`1<TType> methTyArgs, FSharpList`1<FSharpExpr> witnessArgsR, FSharpList`1<Expr> callArgs, FSharpFunc`2<E, E> contF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpExpr> ConvExprs(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvExprsLinear(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<Expr> args, FSharpFunc`2<FSharpList`1<FSharpExpr>, E> contF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvTargetsLinear(SymbolEnv cenv, ExprTranslationEnv env, FSharpList`1<DecisionTreeTarget> tgs, FSharpFunc`2<FSharpList`1<Tuple`2<FSharpList`1<FSharpMemberOrFunctionOrValue>, FSharpExpr>>, E> contF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvValRef(SymbolEnv cenv, ExprTranslationEnv env, Range m, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMemberOrFunctionOrValue ConvVal(SymbolEnv cenv, Val v);
    [CompilerGeneratedAttribute]
internal static E ConvConst$cont@1239(SymbolEnv cenv, Const c, TType ty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvConst(SymbolEnv cenv, ExprTranslationEnv env, Range m, Const c, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr ConvDecisionTree(SymbolEnv cenv, ExprTranslationEnv env, TType dtreeRetTy, DecisionTree x, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvDecisionTreePrim(SymbolEnv cenv, ExprTranslationEnv env, TType dtreeRetTy, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static E ConvDecisionTreeCase(SymbolEnv cenv, ExprTranslationEnv env, Range m, Expr inpExpr, TType dtreeRetTy, DecisionTreeCase dcase, E acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpExpr ConvExprOnDemand(SymbolEnv cenv, ExprTranslationEnv env, Expr expr);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Symbols.FSharpExprPatterns : object {
    public static FSharpOption`1<FSharpMemberOrFunctionOrValue> |Value|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<object, FSharpType>> |Const|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpList`1<FSharpGenericParameter>, FSharpExpr>> |TypeLambda|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr>> |Lambda|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |Application|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpExpr, FSharpExpr>> |IfThenElse|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<Tuple`3<FSharpMemberOrFunctionOrValue, FSharpExpr, DebugPointAtBinding>, FSharpExpr>> |Let|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpList`1<Tuple`3<FSharpMemberOrFunctionOrValue, FSharpExpr, DebugPointAtBinding>>, FSharpExpr>> |LetRec|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpList`1<FSharpExpr>>> |NewRecord|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpList`1<FSharpExpr>>> |NewAnonRecord|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpType, FSharpUnionCase, FSharpList`1<FSharpExpr>>> |NewUnionCase|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpList`1<FSharpExpr>>> |NewTuple|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpType, int, FSharpExpr>> |TupleGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`5<FSharpOption`1<FSharpExpr>, FSharpMemberOrFunctionOrValue, FSharpList`1<FSharpType>, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |Call|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`6<FSharpOption`1<FSharpExpr>, FSharpMemberOrFunctionOrValue, FSharpList`1<FSharpType>, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>, FSharpList`1<FSharpExpr>>> |CallWithWitnesses|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpMemberOrFunctionOrValue, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |NewObject|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpType, FSharpField>> |FSharpFieldGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpType, int>> |AnonRecordGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpOption`1<FSharpExpr>, FSharpType, FSharpField, FSharpExpr>> |FSharpFieldSet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpExpr, FSharpType, FSharpUnionCase, FSharpField>> |UnionCaseGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpType>> |UnionCaseTag|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpType, FSharpUnionCase>> |UnionCaseTest|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpList`1<FSharpExpr>>> |NewArray|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpExpr>> |Coerce|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpExpr> |Quote|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpExpr>> |TypeTest|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> |Sequential|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<DebugPointAtLeafExpr, FSharpExpr>> |DebugPoint|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`6<FSharpExpr, FSharpExpr, FSharpExpr, bool, DebugPointAtFor, DebugPointAtInOrTo>> |FastIntegerForLoop|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpExpr, FSharpExpr, DebugPointAtWhile>> |WhileLoop|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpExpr, FSharpExpr, DebugPointAtTry, DebugPointAtFinally>> |TryFinally|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`7<FSharpExpr, FSharpMemberOrFunctionOrValue, FSharpExpr, FSharpMemberOrFunctionOrValue, FSharpExpr, DebugPointAtTry, DebugPointAtWith>> |TryWith|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpType, FSharpExpr>> |NewDelegate|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpType> |DefaultValue|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpExpr>> |AddressSet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpMemberOrFunctionOrValue, FSharpExpr>> |ValueSet|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpExpr> |AddressOf|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpType> |ThisValue|_|(FSharpExpr e);
    public static FSharpOption`1<FSharpType> |BaseValue|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<string, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |ILAsm|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`3<FSharpOption`1<FSharpExpr>, FSharpType, string>> |ILFieldGet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpOption`1<FSharpExpr>, FSharpType, string, FSharpExpr>> |ILFieldSet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`4<FSharpType, FSharpExpr, FSharpList`1<FSharpObjectExprOverride>, FSharpList`1<Tuple`2<FSharpType, FSharpList`1<FSharpObjectExprOverride>>>>> |ObjectExpr|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<FSharpExpr, FSharpList`1<Tuple`2<FSharpList`1<FSharpMemberOrFunctionOrValue>, FSharpExpr>>>> |DecisionTree|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`2<int, FSharpList`1<FSharpExpr>>> |DecisionTreeSuccess|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`5<FSharpExpr, FSharpType, FSharpUnionCase, FSharpField, FSharpExpr>> |UnionCaseSet|_|(FSharpExpr e);
    public static FSharpOption`1<Tuple`6<FSharpList`1<FSharpType>, string, SynMemberFlags, FSharpList`1<FSharpType>, FSharpList`1<FSharpType>, FSharpList`1<FSharpExpr>>> |TraitCall|_|(FSharpExpr e);
    public static FSharpOption`1<int> |WitnessArg|_|(FSharpExpr e);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpField : FSharpSymbol {
    internal FSharpFieldData d;
    internal SymbolEnv cenv;
    public FSharpOption`1<FSharpEntity> DeclaringEntity { get; }
    public bool IsUnresolved { get; }
    public bool IsMutable { get; }
    public bool IsLiteral { get; }
    public FSharpOption`1<object> LiteralValue { get; }
    public bool IsVolatile { get; }
    public bool IsDefaultValue { get; }
    public bool IsAnonRecordField { get; }
    public Tuple`3<FSharpAnonRecordTypeDetails, FSharpType[], int> AnonRecordFieldDetails { get; }
    public bool IsUnionCaseField { get; }
    public FSharpOption`1<FSharpUnionCase> DeclaringUnionCase { get; }
    public string XmlDocSig { get; }
    public FSharpXmlDoc XmlDoc { get; }
    internal IList`1<string> ElaboratedXmlDoc { get; }
    public FSharpType FieldType { get; }
    public bool IsStatic { get; }
    public string Name { get; }
    public bool IsCompilerGenerated { get; }
    public bool IsNameGenerated { get; }
    public Range DeclarationLocation { get; }
    public IList`1<FSharpAttribute> FieldAttributes { get; }
    public IList`1<FSharpAttribute> PropertyAttributes { get; }
    public FSharpAccessibility Accessibility { get; }
    internal FSharpFieldData V { get; }
    internal FSharpField(SymbolEnv cenv, FSharpFieldData d);
    internal FSharpField(SymbolEnv cenv, UnionCaseRef ucref, int n);
    internal FSharpField(SymbolEnv cenv, RecdFieldRef rfref);
    public FSharpOption`1<FSharpEntity> get_DeclaringEntity();
    public bool get_IsUnresolved();
    public bool get_IsMutable();
    public bool get_IsLiteral();
    public FSharpOption`1<object> get_LiteralValue();
    public bool get_IsVolatile();
    public bool get_IsDefaultValue();
    public bool get_IsAnonRecordField();
    public Tuple`3<FSharpAnonRecordTypeDetails, FSharpType[], int> get_AnonRecordFieldDetails();
    public bool get_IsUnionCaseField();
    public FSharpOption`1<FSharpUnionCase> get_DeclaringUnionCase();
    public string get_XmlDocSig();
    public FSharpXmlDoc get_XmlDoc();
    internal IList`1<string> get_ElaboratedXmlDoc();
    public FSharpType get_FieldType();
    public bool get_IsStatic();
    public string get_Name();
    public bool get_IsCompilerGenerated();
    public bool get_IsNameGenerated();
    public Range get_DeclarationLocation();
    public IList`1<FSharpAttribute> get_FieldAttributes();
    public IList`1<FSharpAttribute> get_PropertyAttributes();
    public virtual FSharpAccessibility get_Accessibility();
    internal FSharpFieldData get_V();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal void checkIsResolved();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.Symbols.FSharpFieldData : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAnonField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsILField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsRecdOrClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnion { get; }
    internal FSharpChoice`3<RecdField, ILFieldInfo, Tuple`4<AnonRecdTypeInfo, FSharpList`1<TType>, int, Range>> TryRecdField { get; }
    internal FSharpOption`1<EntityRef> TryDeclaringTyconRef { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Symbols.FSharpFieldData")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFieldData(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static FSharpFieldData NewAnonField(AnonRecdTypeInfo item1, FSharpList`1<TType> item2, int item3, Range item4);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAnonField();
    [CompilationMappingAttribute("8", "1")]
internal static FSharpFieldData NewILField(ILFieldInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsILField();
    [CompilationMappingAttribute("8", "2")]
internal static FSharpFieldData NewRecdOrClass(RecdFieldRef item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsRecdOrClass();
    [CompilationMappingAttribute("8", "3")]
internal static FSharpFieldData NewUnion(UnionCaseRef item1, int item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal FSharpChoice`3<RecdField, ILFieldInfo, Tuple`4<AnonRecdTypeInfo, FSharpList`1<TType>, int, Range>> get_TryRecdField();
    internal FSharpOption`1<EntityRef> get_TryDeclaringTyconRef();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpGenericParameter : FSharpSymbol {
    internal Typar v;
    internal SymbolEnv cenv;
    internal Range Range { get; }
    public string Name { get; }
    public Range DeclarationLocation { get; }
    public bool IsCompilerGenerated { get; }
    public bool IsMeasure { get; }
    public FSharpXmlDoc XmlDoc { get; }
    internal IList`1<string> ElaboratedXmlDoc { get; }
    public bool IsSolveAtCompileTime { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public IList`1<FSharpGenericParameterConstraint> Constraints { get; }
    internal Typar TypeParameter { get; }
    internal FSharpGenericParameter(SymbolEnv cenv, Typar v);
    internal Range get_Range();
    public string get_Name();
    public Range get_DeclarationLocation();
    public bool get_IsCompilerGenerated();
    public bool get_IsMeasure();
    public FSharpXmlDoc get_XmlDoc();
    internal IList`1<string> get_ElaboratedXmlDoc();
    public bool get_IsSolveAtCompileTime();
    public virtual IList`1<FSharpAttribute> get_Attributes();
    public IList`1<FSharpGenericParameterConstraint> get_Constraints();
    internal Typar get_TypeParameter();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ClassAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpGenericParameterConstraint : object {
    internal TyparConstraint cx;
    internal SymbolEnv cenv;
    public bool IsCoercesToConstraint { get; }
    public FSharpType CoercesToTarget { get; }
    public bool IsDefaultsToConstraint { get; }
    public FSharpGenericParameterDefaultsToConstraint DefaultsToConstraintData { get; }
    public bool IsSupportsNullConstraint { get; }
    public bool IsMemberConstraint { get; }
    public FSharpGenericParameterMemberConstraint MemberConstraintData { get; }
    public bool IsNonNullableValueTypeConstraint { get; }
    public bool IsReferenceTypeConstraint { get; }
    public bool IsSimpleChoiceConstraint { get; }
    public IList`1<FSharpType> SimpleChoices { get; }
    public bool IsRequiresDefaultConstructorConstraint { get; }
    public bool IsEnumConstraint { get; }
    public FSharpType EnumConstraintTarget { get; }
    public bool IsComparisonConstraint { get; }
    public bool IsEqualityConstraint { get; }
    public bool IsUnmanagedConstraint { get; }
    public bool IsDelegateConstraint { get; }
    public FSharpGenericParameterDelegateConstraint DelegateConstraintData { get; }
    internal FSharpGenericParameterConstraint(SymbolEnv cenv, TyparConstraint cx);
    public bool get_IsCoercesToConstraint();
    public FSharpType get_CoercesToTarget();
    public bool get_IsDefaultsToConstraint();
    public FSharpGenericParameterDefaultsToConstraint get_DefaultsToConstraintData();
    public bool get_IsSupportsNullConstraint();
    public bool get_IsMemberConstraint();
    public FSharpGenericParameterMemberConstraint get_MemberConstraintData();
    public bool get_IsNonNullableValueTypeConstraint();
    public bool get_IsReferenceTypeConstraint();
    public bool get_IsSimpleChoiceConstraint();
    public IList`1<FSharpType> get_SimpleChoices();
    public bool get_IsRequiresDefaultConstructorConstraint();
    public bool get_IsEnumConstraint();
    public FSharpType get_EnumConstraintTarget();
    public bool get_IsComparisonConstraint();
    public bool get_IsEqualityConstraint();
    public bool get_IsUnmanagedConstraint();
    public bool get_IsDelegateConstraint();
    public FSharpGenericParameterDelegateConstraint get_DelegateConstraintData();
    public virtual string ToString();
}
[ClassAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpGenericParameterDefaultsToConstraint : object {
    internal TType ty;
    internal int pri;
    internal SymbolEnv cenv;
    public int DefaultsToPriority { get; }
    public FSharpType DefaultsToTarget { get; }
    internal FSharpGenericParameterDefaultsToConstraint(SymbolEnv cenv, int pri, TType ty);
    public int get_DefaultsToPriority();
    public FSharpType get_DefaultsToTarget();
    public virtual string ToString();
}
[ClassAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpGenericParameterDelegateConstraint : object {
    internal TType tupledArgTy;
    internal TType retTy;
    internal SymbolEnv cenv;
    public FSharpType DelegateTupledArgumentType { get; }
    public FSharpType DelegateReturnType { get; }
    internal FSharpGenericParameterDelegateConstraint(SymbolEnv cenv, TType tupledArgTy, TType retTy);
    public FSharpType get_DelegateTupledArgumentType();
    public FSharpType get_DelegateReturnType();
    public virtual string ToString();
}
[ClassAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpGenericParameterMemberConstraint : FSharpSymbol {
    internal SymbolEnv cenv;
    internal FSharpList`1<TType> tys;
    internal FSharpOption`1<TType> retTy;
    internal string nm;
    internal SynMemberFlags flags;
    internal FSharpList`1<TType> atys;
    public IList`1<FSharpType> MemberSources { get; }
    public string MemberName { get; }
    public bool MemberIsStatic { get; }
    public IList`1<FSharpType> MemberArgumentTypes { get; }
    public FSharpType MemberReturnType { get; }
    internal FSharpGenericParameterMemberConstraint(SymbolEnv cenv, TraitConstraintInfo info);
    public IList`1<FSharpType> get_MemberSources();
    public string get_MemberName();
    public bool get_MemberIsStatic();
    public IList`1<FSharpType> get_MemberArgumentTypes();
    public FSharpType get_MemberReturnType();
    public virtual string ToString();
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpImplementationFileContents : object {
    internal SymbolEnv cenv;
    internal TcGlobals g;
    internal QualifiedNameOfFile qname;
    internal bool isScript;
    internal bool hasExplicitEntryPoint;
    internal ModuleOrNamespaceContents contents;
    public string QualifiedName { get; }
    public string FileName { get; }
    public FSharpList`1<FSharpImplementationFileDeclaration> Declarations { get; }
    public bool HasExplicitEntryPoint { get; }
    public bool IsScript { get; }
    internal FSharpImplementationFileContents(SymbolEnv cenv, CheckedImplFile mimpl);
    public string get_QualifiedName();
    public string get_FileName();
    public FSharpList`1<FSharpImplementationFileDeclaration> get_Declarations();
    public bool get_HasExplicitEntryPoint();
    public bool get_IsScript();
    [CompilerGeneratedAttribute]
internal FSharpImplementationFileDeclaration getBind(Binding bind);
    [CompilerGeneratedAttribute]
internal FSharpList`1<FSharpImplementationFileDeclaration> getDeclarations(ModuleOrNamespaceContents mdef);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Symbols.FSharpImplementationFileDeclaration : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEntity { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMemberOrFunctionOrValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInitAction { get; }
    [CompilationMappingAttribute("8", "0")]
public static FSharpImplementationFileDeclaration NewEntity(FSharpEntity _entity, FSharpList`1<FSharpImplementationFileDeclaration> _declarations);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEntity();
    [CompilationMappingAttribute("8", "1")]
public static FSharpImplementationFileDeclaration NewMemberOrFunctionOrValue(FSharpMemberOrFunctionOrValue _value, FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> _curriedArgs, FSharpExpr _body);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMemberOrFunctionOrValue();
    [CompilationMappingAttribute("8", "2")]
public static FSharpImplementationFileDeclaration NewInitAction(FSharpExpr _action);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInitAction();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpImplementationFileDeclaration obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Symbols.FSharpInlineAnnotation : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_AlwaysInline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_OptionalInline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_NeverInline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpInlineAnnotation _unique_AggressiveInline;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation AlwaysInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAlwaysInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation OptionalInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOptionalInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation NeverInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNeverInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpInlineAnnotation AggressiveInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAggressiveInline { get; }
    private static FSharpInlineAnnotation();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Symbols.FSharpInlineAnnotation")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpInlineAnnotation(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpInlineAnnotation get_AlwaysInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAlwaysInline();
    [CompilationMappingAttribute("8", "1")]
public static FSharpInlineAnnotation get_OptionalInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOptionalInline();
    [CompilationMappingAttribute("8", "2")]
public static FSharpInlineAnnotation get_NeverInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNeverInline();
    [CompilationMappingAttribute("8", "3")]
public static FSharpInlineAnnotation get_AggressiveInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAggressiveInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpInlineAnnotation obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpInlineAnnotation obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpMemberOrFunctionOrValue : FSharpSymbol {
    internal Item item;
    internal FSharpMemberOrValData d;
    internal SymbolEnv cenv;
    public bool IsUnresolved { get; }
    internal FSharpOption`1<Range> DeclarationLocationOpt { get; }
    public Range DeclarationLocation { get; }
    public FSharpOption`1<FSharpEntity> DeclaringEntity { get; }
    public FSharpEntity ApparentEnclosingEntity { get; }
    public IList`1<FSharpGenericParameter> GenericParameters { get; }
    public FSharpType FullType { get; }
    public bool HasGetterMethod { get; }
    public FSharpMemberOrFunctionOrValue GetterMethod { get; }
    public bool HasSetterMethod { get; }
    public FSharpMemberOrFunctionOrValue SetterMethod { get; }
    public FSharpMemberOrFunctionOrValue EventAddMethod { get; }
    public FSharpMemberOrFunctionOrValue EventRemoveMethod { get; }
    public FSharpType EventDelegateType { get; }
    public bool EventIsStandard { get; }
    public bool IsCompilerGenerated { get; }
    public FSharpInlineAnnotation InlineAnnotation { get; }
    public bool IsMutable { get; }
    public bool IsModuleValueOrMember { get; }
    public bool IsMember { get; }
    public bool IsDispatchSlot { get; }
    public bool IsMethod { get; }
    public bool IsProperty { get; }
    public bool HasSignatureFile { get; }
    public bool IsEvent { get; }
    public FSharpOption`1<FSharpMemberOrFunctionOrValue> EventForFSharpProperty { get; }
    public bool IsEventAddMethod { get; }
    public bool IsEventRemoveMethod { get; }
    public bool IsPropertyGetterMethod { get; }
    public bool IsPropertySetterMethod { get; }
    public bool IsInstanceMember { get; }
    public bool IsInstanceMemberInCompiledCode { get; }
    public bool IsExtensionMember { get; }
    public bool IsOverrideOrExplicitInterfaceImplementation { get; }
    public bool IsExplicitInterfaceImplementation { get; }
    public IList`1<FSharpAbstractSignature> ImplementedAbstractSignatures { get; }
    public bool IsImplicitConstructor { get; }
    public bool IsTypeFunction { get; }
    public bool IsActivePattern { get; }
    public string CompiledName { get; }
    public string LogicalName { get; }
    public string DisplayName { get; }
    public string XmlDocSig { get; }
    public FSharpXmlDoc XmlDoc { get; }
    internal IList`1<string> ElaboratedXmlDoc { get; }
    public IList`1<IList`1<FSharpParameter>> CurriedParameterGroups { get; }
    public FSharpParameter ReturnParameter { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public bool IsBaseValue { get; }
    public bool IsConstructorThisValue { get; }
    public bool IsMemberThisValue { get; }
    public FSharpOption`1<object> LiteralValue { get; }
    public FSharpAccessibility Accessibility { get; }
    public bool IsConstructor { get; }
    internal FSharpMemberOrValData Data { get; }
    public bool IsValCompiledAsMethod { get; }
    public bool IsValue { get; }
    public bool IsFunction { get; }
    public bool IsRefCell { get; }
    public bool IsReferencedValue { get; }
    public FSharpOption`1<FSharpType> FullTypeSafe { get; }
    internal FSharpMemberOrFunctionOrValue(SymbolEnv cenv, FSharpMemberOrValData d, Item item);
    internal FSharpMemberOrFunctionOrValue(SymbolEnv cenv, ValRef vref);
    internal FSharpMemberOrFunctionOrValue(SymbolEnv cenv, MethInfo minfo);
    public bool get_IsUnresolved();
    internal FSharpOption`1<Range> get_DeclarationLocationOpt();
    public FSharpOption`1<IList`1<FSharpMemberOrFunctionOrValue>> GetOverloads(bool matchParameterNumber);
    public Range get_DeclarationLocation();
    public FSharpOption`1<FSharpEntity> get_DeclaringEntity();
    public FSharpEntity get_ApparentEnclosingEntity();
    public IList`1<FSharpGenericParameter> get_GenericParameters();
    public FSharpType get_FullType();
    public bool get_HasGetterMethod();
    public FSharpMemberOrFunctionOrValue get_GetterMethod();
    public bool get_HasSetterMethod();
    public FSharpMemberOrFunctionOrValue get_SetterMethod();
    public FSharpMemberOrFunctionOrValue get_EventAddMethod();
    public FSharpMemberOrFunctionOrValue get_EventRemoveMethod();
    public FSharpType get_EventDelegateType();
    public bool get_EventIsStandard();
    public bool get_IsCompilerGenerated();
    public FSharpInlineAnnotation get_InlineAnnotation();
    public bool get_IsMutable();
    public bool get_IsModuleValueOrMember();
    public bool get_IsMember();
    public bool get_IsDispatchSlot();
    public bool get_IsMethod();
    public bool get_IsProperty();
    public bool get_HasSignatureFile();
    public bool get_IsEvent();
    public FSharpOption`1<FSharpMemberOrFunctionOrValue> get_EventForFSharpProperty();
    public bool get_IsEventAddMethod();
    public bool get_IsEventRemoveMethod();
    public bool get_IsPropertyGetterMethod();
    public bool get_IsPropertySetterMethod();
    public bool get_IsInstanceMember();
    public bool get_IsInstanceMemberInCompiledCode();
    public bool get_IsExtensionMember();
    public bool get_IsOverrideOrExplicitInterfaceImplementation();
    public bool get_IsExplicitInterfaceImplementation();
    public IList`1<FSharpAbstractSignature> get_ImplementedAbstractSignatures();
    public bool get_IsImplicitConstructor();
    public bool get_IsTypeFunction();
    public bool get_IsActivePattern();
    public string get_CompiledName();
    public string get_LogicalName();
    public string get_DisplayName();
    public string get_XmlDocSig();
    public FSharpXmlDoc get_XmlDoc();
    internal IList`1<string> get_ElaboratedXmlDoc();
    public IList`1<IList`1<FSharpParameter>> get_CurriedParameterGroups();
    public FSharpParameter get_ReturnParameter();
    public virtual IList`1<FSharpAttribute> get_Attributes();
    public bool get_IsBaseValue();
    public bool get_IsConstructorThisValue();
    public bool get_IsMemberThisValue();
    public FSharpOption`1<object> get_LiteralValue();
    public virtual FSharpAccessibility get_Accessibility();
    public bool get_IsConstructor();
    internal FSharpMemberOrValData get_Data();
    public bool get_IsValCompiledAsMethod();
    public bool get_IsValue();
    public bool get_IsFunction();
    public bool get_IsRefCell();
    public bool get_IsReferencedValue();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public TaggedText[] FormatLayout(FSharpDisplayContext displayContext);
    public FSharpOption`1<TaggedText[]> GetReturnTypeLayout(FSharpDisplayContext displayContext);
    public FSharpOption`1<string> GetValSignatureText(FSharpDisplayContext displayContext, Range m);
    public FSharpOption`1<Tuple`2<string, IList`1<FSharpParameter>>> GetWitnessPassingInfo();
    public FSharpOption`1<FSharpType> get_FullTypeSafe();
    public FSharpOption`1<string> TryGetFullDisplayName();
    public FSharpOption`1<String[]> TryGetFullCompiledOperatorNameIdents();
    [CompilerGeneratedAttribute]
internal FSharpOption`1<ValRef> fsharpInfo();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal void checkIsResolved();
    [CompilerGeneratedAttribute]
internal FSharpMemberOrFunctionOrValue mkMethSym(MethInfo minfo);
    [CompilerGeneratedAttribute]
internal FSharpMemberOrFunctionOrValue mkEventSym(EventInfo einfo);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.Symbols.FSharpMemberOrValData : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsE { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsP { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsM { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsC { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsV { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Symbols.FSharpMemberOrValData")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMemberOrValData(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static FSharpMemberOrValData NewE(EventInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsE();
    [CompilationMappingAttribute("8", "1")]
internal static FSharpMemberOrValData NewP(PropInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsP();
    [CompilationMappingAttribute("8", "2")]
internal static FSharpMemberOrValData NewM(MethInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsM();
    [CompilationMappingAttribute("8", "3")]
internal static FSharpMemberOrValData NewC(MethInfo item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsC();
    [CompilationMappingAttribute("8", "4")]
internal static FSharpMemberOrValData NewV(ValRef item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsV();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpObjectExprOverride : object {
    internal FSharpAbstractSignature sgn;
    internal FSharpList`1<FSharpGenericParameter> gps;
    internal FSharpExpr body;
    internal FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> args;
    public FSharpAbstractSignature Signature { get; }
    public FSharpList`1<FSharpGenericParameter> GenericParameters { get; }
    public FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> CurriedParameterGroups { get; }
    public FSharpExpr Body { get; }
    internal FSharpObjectExprOverride(FSharpAbstractSignature sgn, FSharpList`1<FSharpGenericParameter> gps, FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> args, FSharpExpr body);
    public FSharpAbstractSignature get_Signature();
    public FSharpList`1<FSharpGenericParameter> get_GenericParameters();
    public FSharpList`1<FSharpList`1<FSharpMemberOrFunctionOrValue>> get_CurriedParameterGroups();
    public FSharpExpr get_Body();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpOpenDeclaration : object {
    internal FSharpList`1<FSharpType> types;
    internal SynOpenDeclTarget target;
    internal FSharpOption`1<Range> range;
    internal FSharpList`1<FSharpEntity> modules;
    internal bool isOwnNamespace;
    internal Range appliedScope;
    public SynOpenDeclTarget Target { get; }
    public FSharpList`1<Ident> LongId { get; }
    public FSharpOption`1<Range> Range { get; }
    public FSharpList`1<FSharpType> Types { get; }
    public FSharpList`1<FSharpEntity> Modules { get; }
    public Range AppliedScope { get; }
    public bool IsOwnNamespace { get; }
    internal FSharpOpenDeclaration(SynOpenDeclTarget target, FSharpOption`1<Range> range, FSharpList`1<FSharpEntity> modules, FSharpList`1<FSharpType> types, Range appliedScope, bool isOwnNamespace);
    public SynOpenDeclTarget get_Target();
    public FSharpList`1<Ident> get_LongId();
    public FSharpOption`1<Range> get_Range();
    public FSharpList`1<FSharpType> get_Types();
    public FSharpList`1<FSharpEntity> get_Modules();
    public Range get_AppliedScope();
    public bool get_IsOwnNamespace();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpParameter : FSharpSymbol {
    internal ArgReprInfo topArgInfo;
    internal TType paramTy;
    internal FSharpOption`1<ArgumentContainer> ownerOpt;
    internal Range m;
    internal bool isWitnessArg;
    internal bool isParamArrayArg;
    internal bool isOutArg;
    internal bool isOptionalArg;
    internal bool isInArg;
    internal SymbolEnv cenv@2779;
    public FSharpOption`1<string> Name { get; }
    internal SymbolEnv cenv { get; }
    public FSharpType Type { get; }
    internal TType V { get; }
    public Range DeclarationLocation { get; }
    internal FSharpOption`1<FSharpSymbol> Owner { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public bool IsParamArrayArg { get; }
    public bool IsInArg { get; }
    public bool IsOutArg { get; }
    public bool IsOptionalArg { get; }
    internal bool IsWitnessArg { get; }
    internal ArgReprInfo ValReprInfo { get; }
    internal FSharpParameter(SymbolEnv cenv, TType paramTy, ArgReprInfo topArgInfo, FSharpOption`1<ArgumentContainer> ownerOpt, Range m, bool isParamArrayArg, bool isInArg, bool isOutArg, bool isOptionalArg, bool isWitnessArg);
    internal FSharpParameter(SymbolEnv cenv, FSharpOption`1<Ident> idOpt, TType ty, FSharpOption`1<ArgumentContainer> ownerOpt, Range m);
    internal FSharpParameter(SymbolEnv cenv, TType ty, ArgReprInfo argInfo, Range m);
    public FSharpOption`1<string> get_Name();
    internal SymbolEnv get_cenv();
    internal FSharpParameter AdjustType(TType ty);
    public FSharpType get_Type();
    internal TType get_V();
    public Range get_DeclarationLocation();
    internal FSharpOption`1<FSharpSymbol> get_Owner();
    public virtual IList`1<FSharpAttribute> get_Attributes();
    public bool get_IsParamArrayArg();
    public bool get_IsInArg();
    public bool get_IsOutArg();
    public bool get_IsOptionalArg();
    internal bool get_IsWitnessArg();
    internal ArgReprInfo get_ValReprInfo();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpStaticParameter : FSharpSymbol {
    internal Tainted`1<ProvidedParameterInfo> sp;
    internal Range m;
    internal SymbolEnv cenv;
    public string Name { get; }
    public Range DeclarationLocation { get; }
    public FSharpType Kind { get; }
    public bool IsOptional { get; }
    [ObsoleteAttribute("This member is no longer used, use IsOptional instead")]
public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public Range Range { get; }
    internal FSharpStaticParameter(SymbolEnv cenv, Tainted`1<ProvidedParameterInfo> sp, Range m);
    public string get_Name();
    public Range get_DeclarationLocation();
    public FSharpType get_Kind();
    public bool get_IsOptional();
    public bool get_HasDefaultValue();
    public object get_DefaultValue();
    public Range get_Range();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpSymbol : object {
    internal FSharpFunc`2<Unit, Item> item;
    internal SymbolEnv cenv;
    internal FSharpFunc`2<FSharpSymbol, FSharpFunc`2<CcuThunk, FSharpFunc`2<AccessorDomain, bool>>> access;
    public FSharpAssembly Assembly { get; }
    public bool IsExplicitlySuppressed { get; }
    public string FullName { get; }
    public FSharpOption`1<Range> DeclarationLocation { get; }
    public FSharpOption`1<Range> ImplementationLocation { get; }
    public FSharpOption`1<Range> SignatureLocation { get; }
    internal SymbolEnv SymbolEnv { get; }
    internal Item Item { get; }
    public string DisplayNameCore { get; }
    public string DisplayName { get; }
    public FSharpAccessibility Accessibility { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    internal FSharpSymbol(SymbolEnv cenv, FSharpFunc`2<Unit, Item> item, FSharpFunc`2<FSharpSymbol, FSharpFunc`2<CcuThunk, FSharpFunc`2<AccessorDomain, bool>>> access);
    public FSharpAssembly get_Assembly();
    public bool IsAccessible(FSharpAccessibilityRights rights);
    public bool get_IsExplicitlySuppressed();
    public string get_FullName();
    public FSharpOption`1<Range> get_DeclarationLocation();
    public FSharpOption`1<Range> get_ImplementationLocation();
    public FSharpOption`1<Range> get_SignatureLocation();
    public bool IsEffectivelySameAs(FSharpSymbol other);
    public int GetEffectivelySameAsHash();
    internal SymbolEnv get_SymbolEnv();
    internal Item get_Item();
    public string get_DisplayNameCore();
    public string get_DisplayName();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static FSharpSymbol Create(TcGlobals g, CcuThunk thisCcu, ModuleOrNamespaceType thisCcuTyp, TcImports tcImports, Item item);
    internal static FSharpSymbol Create(SymbolEnv cenv, Item item);
    public virtual FSharpAccessibility get_Accessibility();
    public virtual IList`1<FSharpAttribute> get_Attributes();
    public bool HasAttribute();
    public FSharpOption`1<FSharpAttribute> TryGetAttribute();
}
[ExperimentalAttribute("This module is subject to future redesign. Consider using patterns checking for properties of symbols directly, e.g. entity.IsFSharpRecord or entity.IsFSharpUnion")]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Symbols.FSharpSymbolPatterns : object {
    internal static bool hasModuleSuffixAttribute(FSharpEntity entity);
    public static FSharpOption`1<FSharpType> |AbbreviatedType|_|(FSharpEntity entity);
    public static FSharpOption`1<FSharpEntity> |TypeWithDefinition|_|(FSharpType ty);
    internal static Tuple`2<FSharpEntity, FSharpOption`1<FSharpType>> getEntityAbbreviatedType(FSharpEntity entity);
    internal static FSharpOption`1<FSharpEntity> getBaseType@49(FSharpEntity entity);
    internal static bool isAttributeType@56(FSharpOption`1<FSharpEntity> ty);
    internal static bool isAttribute@48(FSharpEntity entity);
    public static FSharpOption`1<Unit> |Attribute|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |ValueType|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |Class|_|(FSharpEntity original, FSharpEntity abbreviated, a _arg1);
    public static FSharpOption`1<Unit> |Record|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |UnionType|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |Delegate|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |FSharpException|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |Interface|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |AbstractClass|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |FSharpType|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |ProvidedType|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |ByRef|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |Array|_|(FSharpEntity e);
    public static FSharpOption`1<Unit> |FSharpModule|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |Namespace|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |ProvidedAndErasedType|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |Enum|_|(FSharpEntity entity);
    public static FSharpOption`1<Unit> |Tuple|_|(FSharpType ty);
    public static FSharpOption`1<Unit> |RefCell|_|(FSharpType ty);
    public static FSharpOption`1<Unit> |FunctionType|_|(FSharpType ty);
    public static FSharpOption`1<Unit> |Pattern|_|(FSharpSymbol symbol);
    public static FSharpOption`1<Tuple`2<FSharpField, FSharpType>> |Field|_|(FSharpSymbol symbol);
    public static FSharpOption`1<Unit> |MutableVar|_|(FSharpSymbol symbol);
    public static FSharpOption`1<Tuple`3<FSharpEntity, FSharpEntity, FSharpOption`1<FSharpType>>> |FSharpEntity|_|(FSharpSymbol symbol);
    public static FSharpOption`1<Unit> |Parameter|_|(FSharpSymbol symbol);
    public static FSharpOption`1<FSharpUnionCase> |UnionCase|_|(FSharpSymbol e);
    public static FSharpOption`1<FSharpField> |RecordField|_|(FSharpSymbol e);
    public static FSharpOption`1<FSharpActivePatternCase> |ActivePatternCase|_|(FSharpSymbol symbol);
    public static FSharpOption`1<FSharpMemberOrFunctionOrValue> |MemberFunctionOrValue|_|(FSharpSymbol symbol);
    public static FSharpOption`1<FSharpEntity> |Constructor|_|(FSharpMemberOrFunctionOrValue func);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static FSharpOption`1<Unit> |Function|_|(bool excluded, FSharpMemberOrFunctionOrValue func);
    public static FSharpOption`1<Unit> |ExtensionMember|_|(FSharpMemberOrFunctionOrValue func);
    public static FSharpOption`1<Unit> |Event|_|(FSharpMemberOrFunctionOrValue func);
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpType : object {
    internal TType ty;
    internal SymbolEnv cenv@2445;
    public bool IsUnresolved { get; }
    public bool HasTypeDefinition { get; }
    public bool IsMeasureType { get; }
    public bool IsTupleType { get; }
    public bool IsStructTupleType { get; }
    public FSharpEntity TypeDefinition { get; }
    public IList`1<FSharpType> GenericArguments { get; }
    public bool IsAbbreviation { get; }
    public FSharpType AbbreviatedType { get; }
    public bool IsFunctionType { get; }
    public bool IsAnonRecordType { get; }
    public FSharpAnonRecordTypeDetails AnonRecordTypeDetails { get; }
    public bool IsGenericParameter { get; }
    public FSharpGenericParameter GenericParameter { get; }
    public IList`1<FSharpType> AllInterfaces { get; }
    public FSharpOption`1<FSharpType> BaseType { get; }
    public FSharpType ErasedType { get; }
    public string BasicQualifiedName { get; }
    internal TType Type { get; }
    internal SymbolEnv cenv { get; }
    internal FSharpType(SymbolEnv cenv, TType ty);
    internal FSharpType(TcGlobals g, CcuThunk thisCcu, ModuleOrNamespaceType thisCcuTyp, TcImports tcImports, TType ty);
    public bool get_IsUnresolved();
    public bool get_HasTypeDefinition();
    public bool get_IsMeasureType();
    public bool get_IsTupleType();
    public bool get_IsStructTupleType();
    public FSharpEntity get_TypeDefinition();
    public IList`1<FSharpType> get_GenericArguments();
    public bool get_IsAbbreviation();
    public FSharpType get_AbbreviatedType();
    public bool get_IsFunctionType();
    public bool get_IsAnonRecordType();
    public FSharpAnonRecordTypeDetails get_AnonRecordTypeDetails();
    public bool get_IsGenericParameter();
    public FSharpGenericParameter get_GenericParameter();
    public IList`1<FSharpType> get_AllInterfaces();
    public FSharpOption`1<FSharpType> get_BaseType();
    public FSharpType get_ErasedType();
    public string get_BasicQualifiedName();
    public FSharpType Instantiate(FSharpList`1<Tuple`2<FSharpGenericParameter, FSharpType>> instantiation);
    internal TType get_Type();
    internal SymbolEnv get_cenv();
    internal FSharpType AdjustType(TType t);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public string Format(FSharpDisplayContext context);
    public string FormatWithConstraints(FSharpDisplayContext context);
    public TaggedText[] FormatLayout(FSharpDisplayContext context);
    public TaggedText[] FormatLayoutWithConstraints(FSharpDisplayContext context);
    public virtual string ToString();
    public static FSharpType Prettify(FSharpType ty);
    public static IList`1<FSharpType> Prettify(IList`1<FSharpType> types);
    public static FSharpParameter Prettify(FSharpParameter parameter);
    public static IList`1<FSharpParameter> Prettify(IList`1<FSharpParameter> parameters);
    public static IList`1<IList`1<FSharpParameter>> Prettify(IList`1<IList`1<FSharpParameter>> parameters);
    public static Tuple`2<IList`1<IList`1<FSharpParameter>>, FSharpParameter> Prettify(IList`1<IList`1<FSharpParameter>> parameters, FSharpParameter returnParameter);
    public FSharpType StripAbbreviations();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal bool isResolved();
}
[ClassAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Symbols.FSharpUnionCase : FSharpSymbol {
    internal UnionCaseRef v;
    internal SymbolEnv cenv;
    public bool IsUnresolved { get; }
    public string Name { get; }
    public Range DeclarationLocation { get; }
    public FSharpEntity DeclaringEntity { get; }
    public bool HasFields { get; }
    public IList`1<FSharpField> Fields { get; }
    public FSharpType ReturnType { get; }
    public string CompiledName { get; }
    public string XmlDocSig { get; }
    public FSharpXmlDoc XmlDoc { get; }
    internal IList`1<string> ElaboratedXmlDoc { get; }
    public IList`1<FSharpAttribute> Attributes { get; }
    public FSharpAccessibility Accessibility { get; }
    internal UnionCaseRef V { get; }
    internal FSharpUnionCase(SymbolEnv cenv, UnionCaseRef v);
    public bool get_IsUnresolved();
    public string get_Name();
    public Range get_DeclarationLocation();
    public FSharpEntity get_DeclaringEntity();
    public bool get_HasFields();
    public IList`1<FSharpField> get_Fields();
    public FSharpType get_ReturnType();
    public string get_CompiledName();
    public string get_XmlDocSig();
    public FSharpXmlDoc get_XmlDoc();
    internal IList`1<string> get_ElaboratedXmlDoc();
    public virtual IList`1<FSharpAttribute> get_Attributes();
    public virtual FSharpAccessibility get_Accessibility();
    internal UnionCaseRef get_V();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool isUnresolved();
    [CompilerGeneratedAttribute]
internal void checkIsResolved();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Symbols.FSharpXmlDoc : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpXmlDoc _unique_None;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpXmlDoc None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFromXmlText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFromXmlFile { get; }
    private static FSharpXmlDoc();
    [CompilationMappingAttribute("8", "0")]
public static FSharpXmlDoc get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilationMappingAttribute("8", "1")]
public static FSharpXmlDoc NewFromXmlText(XmlDoc item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFromXmlText();
    [CompilationMappingAttribute("8", "2")]
public static FSharpXmlDoc NewFromXmlFile(string _dllName, string _xmlSig);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFromXmlFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpXmlDoc obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Symbols.Impl : object {
    internal static a dflt@153(string asmName, string path);
    internal static a protect(FSharpFunc`2<Unit, a> f);
    internal static IList`1<string> makeElaboratedXmlDoc(XmlDoc doc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef rescopeEntity(FSharpOption`1<CcuThunk> optViewedCcu, Entity entity);
    internal static bool entityIsUnresolved(EntityRef entity);
    internal static void checkEntityIsResolved(EntityRef entity);
    internal static string nameOfScoRef@119(ILGlobals ilg, CcuThunk thisCcu, ILScopeRef scoref);
    internal static bool loop@126-90(FSharpList`1<Tuple`2<b, c>> p1, FSharpList`1<Tuple`2<b, c>> p2);
    internal static bool canAccessCompPathFromCrossProject@125(ILGlobals ilg, CcuThunk thisCcu2, CcuThunk thisCcu1, CompilationPath _arg4, CompilationPath _arg3);
    internal static FSharpFunc`2<CompilationPath, bool> canAccessFromCrossProject@133(ILGlobals ilg, CcuThunk thisCcu2, CcuThunk thisCcu1, Accessibility _arg5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkForCrossProjectAccessibility(ILGlobals ilg, CcuThunk thisCcu2, AccessorDomain ad2, CcuThunk thisCcu1, Accessibility taccess1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility getApproxFSharpAccessibilityOfMember(EntityRef declaringEntity, ILMemberAccess ilAccess);
    internal static Accessibility getApproxFSharpAccessibilityOfEntity(EntityRef entity);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<object> getLiteralValue$cont@177(FSharpOption`1<Const> _arg6, Unit unitVar);
    internal static FSharpOption`1<object> getLiteralValue(FSharpOption`1<Const> _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string getXmlDocSigForEntity(SymbolEnv cenv, EntityRef ent);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Symbols.SymbolEnv : object {
    internal FSharpOption`1<ModuleOrNamespaceType> thisCcuTyp;
    internal CcuThunk thisCcu@59;
    internal TcImports tcImports@59;
    internal InfoReader infoReader@59;
    internal TcGlobals g@59;
    internal ImportMap amap@59;
    internal FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcVal;
    internal TcGlobals g { get; }
    internal ImportMap amap { get; }
    internal CcuThunk thisCcu { get; }
    internal FSharpOption`1<ModuleOrNamespaceType> thisCcuTy { get; }
    internal InfoReader infoReader { get; }
    internal TcImports tcImports { get; }
    internal FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> tcValF { get; }
    public SymbolEnv(TcGlobals g, CcuThunk thisCcu, FSharpOption`1<ModuleOrNamespaceType> thisCcuTyp, TcImports tcImports, ImportMap amap, InfoReader infoReader);
    public SymbolEnv(TcGlobals g, CcuThunk thisCcu, FSharpOption`1<ModuleOrNamespaceType> thisCcuTyp, TcImports tcImports);
    internal TcGlobals get_g();
    internal ImportMap get_amap();
    internal CcuThunk get_thisCcu();
    internal FSharpOption`1<ModuleOrNamespaceType> get_thisCcuTy();
    internal InfoReader get_infoReader();
    internal TcImports get_tcImports();
    internal FSharpFunc`2<ValRef, FSharpFunc`2<ValUseFlag, FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<Range, Tuple`2<Expr, TType>>>>> get_tcValF();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Symbols.SymbolHelpers : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range rangeOfValRef(FSharpOption`1<bool> preferFlag, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range rangeOfEntityRef(FSharpOption`1<bool> preferFlag, EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Range> rangeOfPropInfo(FSharpOption`1<bool> preferFlag, PropInfo pinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Range> rangeOfMethInfo(TcGlobals g, FSharpOption`1<bool> preferFlag, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Range> rangeOfEventInfo(FSharpOption`1<bool> preferFlag, EventInfo einfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range rangeOfUnionCaseInfo(FSharpOption`1<bool> preferFlag, UnionCaseInfo ucinfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range rangeOfRecdField(FSharpOption`1<bool> preferFlag, RecdField rField);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Range> rangeOfItem(TcGlobals g, FSharpOption`1<bool> preferFlag, Item d);
    internal static FSharpOption`1<CcuThunk> computeCcuOfTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<CcuThunk> ccuOfMethInfo(TcGlobals g, MethInfo minfo);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<CcuThunk> func2@1-11(FSharpOption`1<EntityRef> option);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<CcuThunk> ccuOfItem(TcGlobals g, Item d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string fileNameOfItem(TcGlobals g, FSharpOption`1<string> qualProjectDir, Range m, Item h);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ParamNameAndType> ParamNameAndTypesOfUnaryCustomOperation(TcGlobals g, MethInfo minfo);
    internal static FSharpXmlDoc mkXmlComment(FSharpOption`1<Tuple`2<FSharpOption`1<string>, string>> thing);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlDocFromLoader(InfoReader infoReader, FSharpXmlDoc xmlDoc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlDocHelpSigOfItemForLookup(InfoReader infoReader, Range m, Item d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlCommentForItemAux(FSharpOption`1<XmlDoc> xmlDoc, InfoReader infoReader, Range m, Item d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlCommentForMethInfoItem(InfoReader infoReader, Range m, Item d, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Layout> FormatTyparMapping(DisplayEnv denv, FSharpList`1<Tuple`2<Typar, TType>> prettyTyparInst);
    internal static FSharpOption`1<TType> |ItemWhereTypIsPreferred|_|(Item item);
    internal static bool equalHeadTypes@415(TcGlobals g, TType ty1, TType ty2);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@426-18(TcGlobals g, Item item2, Item item1, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@426-17(TcGlobals g, Item item2, Item item1, Unit unitVar);
    internal static IPartialEqualityComparer`1<Item> ItemDisplayPartialEquality(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ItemWithInst> RemoveDuplicateItems(TcGlobals g, FSharpList`1<ItemWithInst> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsExplicitlySuppressed(TcGlobals g, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ItemWithInst> RemoveExplicitlySuppressed(TcGlobals g, FSharpList`1<ItemWithInst> items);
    internal static DisplayEnv SimplerDisplayEnv(DisplayEnv denv);
    [CompilerGeneratedAttribute]
internal static void f@284-19(DisplayEnv denv, ILFieldInfo finfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@284-20(DisplayEnv denv, EventInfo einfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@284-21(DisplayEnv denv, PropInfo pinfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@284-22(DisplayEnv denv, MethInfo minfo, StringBuilder os);
    [CompilerGeneratedAttribute]
internal static void f@284-23(DisplayEnv denv, MethInfo minfo, StringBuilder os);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string FullNameOfItem(TcGlobals g, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpXmlDoc GetXmlCommentForItem(InfoReader infoReader, Range m, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsAttribute(InfoReader infoReader, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<EntityRef> |ItemIsProvidedType|_|(TcGlobals g, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tainted`1[]> |ItemIsProvidedTypeWithStaticArguments|_|(Range m, TcGlobals g, Item item);
    internal static FSharpOption`1<Tainted`1[]> |ItemIsProvidedMethodWithStaticArguments|_|(Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tainted`1[]> |ItemIsWithStaticArguments|_|(Range m, TcGlobals g, Item item);
    internal static FSharpOption`1<string> getKeywordForMethInfo@796(TcGlobals g, MethInfo minfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> GetF1Keyword(TcGlobals g, Item item);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ItemWithInst> SelectMethodGroupItems2(TcGlobals g, Range m, ItemWithInst item);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.DebugPointAtBinding : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtBinding _unique_NoneAtDo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtBinding _unique_NoneAtLet;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtBinding _unique_NoneAtSticky;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtBinding _unique_NoneAtInvisible;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtBinding NoneAtDo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoneAtDo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtBinding NoneAtLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoneAtLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtBinding NoneAtSticky { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoneAtSticky { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtBinding NoneAtInvisible { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNoneAtInvisible { get; }
    private static DebugPointAtBinding();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.DebugPointAtBinding")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DebugPointAtBinding(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtBinding NewYes(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtBinding get_NoneAtDo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoneAtDo();
    [CompilationMappingAttribute("8", "2")]
public static DebugPointAtBinding get_NoneAtLet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoneAtLet();
    [CompilationMappingAttribute("8", "3")]
public static DebugPointAtBinding get_NoneAtSticky();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoneAtSticky();
    [CompilationMappingAttribute("8", "4")]
public static DebugPointAtBinding get_NoneAtInvisible();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNoneAtInvisible();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public DebugPointAtBinding Combine(DebugPointAtBinding y);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtBinding obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.DebugPointAtFinally : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtFinally _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtFinally No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNo { get; }
    private static DebugPointAtFinally();
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtFinally NewYes(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtFinally get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtFinally obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.DebugPointAtFor : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtFor _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtFor No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNo { get; }
    private static DebugPointAtFor();
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtFor NewYes(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtFor get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtFor obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.DebugPointAtInOrTo : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtInOrTo _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtInOrTo No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNo { get; }
    private static DebugPointAtInOrTo();
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtInOrTo NewYes(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtInOrTo get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtInOrTo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.DebugPointAtLeafExpr : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range Item { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.DebugPointAtLeafExpr")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DebugPointAtLeafExpr(Range item);
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtLeafExpr NewYes(Range item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtLeafExpr obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.DebugPointAtSequential : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtSequential _unique_SuppressNeither;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtSequential _unique_SuppressStmt;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtSequential _unique_SuppressBoth;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtSequential _unique_SuppressExpr;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtSequential SuppressNeither { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSuppressNeither { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtSequential SuppressStmt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSuppressStmt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtSequential SuppressBoth { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSuppressBoth { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtSequential SuppressExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSuppressExpr { get; }
    private static DebugPointAtSequential();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.DebugPointAtSequential")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DebugPointAtSequential(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtSequential get_SuppressNeither();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSuppressNeither();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtSequential get_SuppressStmt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSuppressStmt();
    [CompilationMappingAttribute("8", "2")]
public static DebugPointAtSequential get_SuppressBoth();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSuppressBoth();
    [CompilationMappingAttribute("8", "3")]
public static DebugPointAtSequential get_SuppressExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSuppressExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DebugPointAtSequential obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtSequential obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.DebugPointAtTarget : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtTarget _unique_Yes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtTarget _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtTarget Yes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtTarget No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNo { get; }
    private static DebugPointAtTarget();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.DebugPointAtTarget")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DebugPointAtTarget(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtTarget get_Yes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtTarget get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(DebugPointAtTarget obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtTarget obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.DebugPointAtTry : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtTry _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtTry No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNo { get; }
    private static DebugPointAtTry();
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtTry NewYes(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtTry get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtTry obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.DebugPointAtWhile : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtWhile _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtWhile No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNo { get; }
    private static DebugPointAtWhile();
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtWhile NewYes(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtWhile get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtWhile obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.DebugPointAtWith : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static DebugPointAtWith _unique_No;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static DebugPointAtWith No { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNo { get; }
    private static DebugPointAtWith();
    [CompilationMappingAttribute("8", "0")]
public static DebugPointAtWith NewYes(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYes();
    [CompilationMappingAttribute("8", "1")]
public static DebugPointAtWith get_No();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DebugPointAtWith obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.Syntax.ExprAtomicFlag : Enum {
    public int value__;
    public static ExprAtomicFlag Atomic;
    public static ExprAtomicFlag NonAtomic;
}
[StructAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{idText}")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Syntax.Ident : ValueType {
    internal string text;
    internal Range range;
    public string idText { get; }
    public Range idRange { get; }
    public Ident(string text, Range range);
    public string get_idText();
    public Range get_idRange();
    public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.ParsedHashDirective : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string _ident;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ParsedHashDirectiveArgument> _args;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string ident { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirectiveArgument> args { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.ParsedHashDirective")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedHashDirective(string _ident, FSharpList`1<ParsedHashDirectiveArgument> _args, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static ParsedHashDirective NewParsedHashDirective(string _ident, FSharpList`1<ParsedHashDirectiveArgument> _args, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_ident();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirectiveArgument> get_args();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.ParsedHashDirectiveArgument : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSourceIdentifier { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static ParsedHashDirectiveArgument NewString(string _value, SynStringKind _stringKind, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsString();
    [CompilationMappingAttribute("8", "1")]
public static ParsedHashDirectiveArgument NewSourceIdentifier(string _constant, string _value, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSourceIdentifier();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.ParsedImplFile : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ParsedHashDirective> _hashDirectives;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ParsedImplFileFragment> _fragments;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirective> hashDirectives { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedImplFileFragment> fragments { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.ParsedImplFile")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedImplFile(FSharpList`1<ParsedHashDirective> _hashDirectives, FSharpList`1<ParsedImplFileFragment> _fragments);
    [CompilationMappingAttribute("8", "0")]
public static ParsedImplFile NewParsedImplFile(FSharpList`1<ParsedHashDirective> _hashDirectives, FSharpList`1<ParsedImplFileFragment> _fragments);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirective> get_hashDirectives();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedImplFileFragment> get_fragments();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.ParsedImplFileFragment : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnonModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespaceFragment { get; }
    [CompilationMappingAttribute("8", "0")]
public static ParsedImplFileFragment NewAnonModule(FSharpList`1<SynModuleDecl> _decls, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnonModule();
    [CompilationMappingAttribute("8", "1")]
public static ParsedImplFileFragment NewNamedModule(SynModuleOrNamespace _namedModule);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamedModule();
    [CompilationMappingAttribute("8", "2")]
public static ParsedImplFileFragment NewNamespaceFragment(FSharpList`1<Ident> _longId, bool _isRecursive, SynModuleOrNamespaceKind _kind, FSharpList`1<SynModuleDecl> _decls, PreXmlDoc _xmlDoc, FSharpList`1<SynAttributeList> _attributes, Range _range, SynModuleOrNamespaceTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespaceFragment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.ParsedImplFileInput : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string _fileName;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isScript;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal QualifiedNameOfFile _qualifiedNameOfFile;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ScopedPragma> _scopedPragmas;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ParsedHashDirective> _hashDirectives;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynModuleOrNamespace> _contents;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Tuple`2<bool, bool> _flags;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedImplFileInputTrivia _trivia;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpSet`1<string> _identifiers;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string fileName { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isScript { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public QualifiedNameOfFile qualifiedNameOfFile { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ScopedPragma> scopedPragmas { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirective> hashDirectives { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleOrNamespace> contents { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<bool, bool> flags { get; }
    [CompilationMappingAttribute("4", "0", "7")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ParsedImplFileInputTrivia trivia { get; }
    [CompilationMappingAttribute("4", "0", "8")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<string> identifiers { get; }
    public QualifiedNameOfFile QualifiedName { get; }
    public FSharpList`1<ScopedPragma> ScopedPragmas { get; }
    public FSharpList`1<ParsedHashDirective> HashDirectives { get; }
    public string FileName { get; }
    public FSharpList`1<SynModuleOrNamespace> Contents { get; }
    public bool IsScript { get; }
    public bool IsLastCompiland { get; }
    public bool IsExe { get; }
    public ParsedImplFileInputTrivia Trivia { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.ParsedImplFileInput")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedImplFileInput(string _fileName, bool _isScript, QualifiedNameOfFile _qualifiedNameOfFile, FSharpList`1<ScopedPragma> _scopedPragmas, FSharpList`1<ParsedHashDirective> _hashDirectives, FSharpList`1<SynModuleOrNamespace> _contents, Tuple`2<bool, bool> _flags, ParsedImplFileInputTrivia _trivia, FSharpSet`1<string> _identifiers);
    [CompilationMappingAttribute("8", "0")]
public static ParsedImplFileInput NewParsedImplFileInput(string _fileName, bool _isScript, QualifiedNameOfFile _qualifiedNameOfFile, FSharpList`1<ScopedPragma> _scopedPragmas, FSharpList`1<ParsedHashDirective> _hashDirectives, FSharpList`1<SynModuleOrNamespace> _contents, Tuple`2<bool, bool> _flags, ParsedImplFileInputTrivia _trivia, FSharpSet`1<string> _identifiers);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_fileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isScript();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public QualifiedNameOfFile get_qualifiedNameOfFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ScopedPragma> get_scopedPragmas();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirective> get_hashDirectives();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleOrNamespace> get_contents();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<bool, bool> get_flags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ParsedImplFileInputTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<string> get_identifiers();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public QualifiedNameOfFile get_QualifiedName();
    public FSharpList`1<ScopedPragma> get_ScopedPragmas();
    public FSharpList`1<ParsedHashDirective> get_HashDirectives();
    public string get_FileName();
    public FSharpList`1<SynModuleOrNamespace> get_Contents();
    public bool get_IsScript();
    public bool get_IsLastCompiland();
    public bool get_IsExe();
    public ParsedImplFileInputTrivia get_Trivia();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.ParsedInput : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsImplFile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSigFile { get; }
    public string FileName { get; }
    public FSharpList`1<ScopedPragma> ScopedPragmas { get; }
    public QualifiedNameOfFile QualifiedName { get; }
    public Range Range { get; }
    [ExperimentalAttribute("This FCS API is experimental and subject to change.")]
public FSharpSet`1<string> Identifiers { get; }
    [CompilationMappingAttribute("8", "0")]
public static ParsedInput NewImplFile(ParsedImplFileInput item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsImplFile();
    [CompilationMappingAttribute("8", "1")]
public static ParsedInput NewSigFile(ParsedSigFileInput item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSigFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public string get_FileName();
    public FSharpList`1<ScopedPragma> get_ScopedPragmas();
    public QualifiedNameOfFile get_QualifiedName();
    public Range get_Range();
    public FSharpSet`1<string> get_Identifiers();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.ParsedScriptInteraction : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynModuleDecl> _defns;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleDecl> defns { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.ParsedScriptInteraction")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedScriptInteraction(FSharpList`1<SynModuleDecl> _defns, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static ParsedScriptInteraction NewDefinitions(FSharpList`1<SynModuleDecl> _defns, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleDecl> get_defns();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.ParsedSigFile : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ParsedHashDirective> _hashDirectives;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ParsedSigFileFragment> _fragments;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirective> hashDirectives { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedSigFileFragment> fragments { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.ParsedSigFile")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedSigFile(FSharpList`1<ParsedHashDirective> _hashDirectives, FSharpList`1<ParsedSigFileFragment> _fragments);
    [CompilationMappingAttribute("8", "0")]
public static ParsedSigFile NewParsedSigFile(FSharpList`1<ParsedHashDirective> _hashDirectives, FSharpList`1<ParsedSigFileFragment> _fragments);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirective> get_hashDirectives();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedSigFileFragment> get_fragments();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.ParsedSigFileFragment : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnonModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespaceFragment { get; }
    [CompilationMappingAttribute("8", "0")]
public static ParsedSigFileFragment NewAnonModule(FSharpList`1<SynModuleSigDecl> _decls, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnonModule();
    [CompilationMappingAttribute("8", "1")]
public static ParsedSigFileFragment NewNamedModule(SynModuleOrNamespaceSig _namedModule);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamedModule();
    [CompilationMappingAttribute("8", "2")]
public static ParsedSigFileFragment NewNamespaceFragment(FSharpList`1<Ident> _longId, bool _isRecursive, SynModuleOrNamespaceKind _kind, FSharpList`1<SynModuleSigDecl> _decls, PreXmlDoc _xmlDoc, FSharpList`1<SynAttributeList> _attributes, Range _range, SynModuleOrNamespaceSigTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespaceFragment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.ParsedSigFileInput : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string _fileName;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal QualifiedNameOfFile _qualifiedNameOfFile;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ScopedPragma> _scopedPragmas;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<ParsedHashDirective> _hashDirectives;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynModuleOrNamespaceSig> _contents;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedSigFileInputTrivia _trivia;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpSet`1<string> _identifiers;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string fileName { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public QualifiedNameOfFile qualifiedNameOfFile { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ScopedPragma> scopedPragmas { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirective> hashDirectives { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleOrNamespaceSig> contents { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ParsedSigFileInputTrivia trivia { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<string> identifiers { get; }
    public QualifiedNameOfFile QualifiedName { get; }
    public FSharpList`1<ScopedPragma> ScopedPragmas { get; }
    public FSharpList`1<ParsedHashDirective> HashDirectives { get; }
    public string FileName { get; }
    public FSharpList`1<SynModuleOrNamespaceSig> Contents { get; }
    public ParsedSigFileInputTrivia Trivia { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.ParsedSigFileInput")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParsedSigFileInput(string _fileName, QualifiedNameOfFile _qualifiedNameOfFile, FSharpList`1<ScopedPragma> _scopedPragmas, FSharpList`1<ParsedHashDirective> _hashDirectives, FSharpList`1<SynModuleOrNamespaceSig> _contents, ParsedSigFileInputTrivia _trivia, FSharpSet`1<string> _identifiers);
    [CompilationMappingAttribute("8", "0")]
public static ParsedSigFileInput NewParsedSigFileInput(string _fileName, QualifiedNameOfFile _qualifiedNameOfFile, FSharpList`1<ScopedPragma> _scopedPragmas, FSharpList`1<ParsedHashDirective> _hashDirectives, FSharpList`1<SynModuleOrNamespaceSig> _contents, ParsedSigFileInputTrivia _trivia, FSharpSet`1<string> _identifiers);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_fileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public QualifiedNameOfFile get_qualifiedNameOfFile();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ScopedPragma> get_scopedPragmas();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ParsedHashDirective> get_hashDirectives();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleOrNamespaceSig> get_contents();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public ParsedSigFileInputTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpSet`1<string> get_identifiers();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public QualifiedNameOfFile get_QualifiedName();
    public FSharpList`1<ScopedPragma> get_ScopedPragmas();
    public FSharpList`1<ParsedHashDirective> get_HashDirectives();
    public string get_FileName();
    public FSharpList`1<SynModuleOrNamespaceSig> get_Contents();
    public ParsedSigFileInputTrivia get_Trivia();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.ParserDetail : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ParserDetail _unique_Ok;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static ParserDetail _unique_ErrorRecovery;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ParserDetail Ok { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOk { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static ParserDetail ErrorRecovery { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsErrorRecovery { get; }
    private static ParserDetail();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.ParserDetail")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ParserDetail(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static ParserDetail get_Ok();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOk();
    [CompilationMappingAttribute("8", "1")]
public static ParserDetail get_ErrorRecovery();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsErrorRecovery();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(ParserDetail obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParserDetail obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Syntax.PrettyNaming : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string parenGet;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string parenSet;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string qmark;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string qmarkSet;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string opNamePrefix;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string compilerGeneratedMarker;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static char compilerGeneratedMarkerChar;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static char mangledGenericTypeNameSym;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string FSharpModuleSuffix;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string MangledGlobalName;
    [DebuggerBrowsableAttribute("0")]
internal static T1063353_22Bytes@ field1063354@;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string suffixForVariablesThatMayNotBeEliminated;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string suffixForTupleElementAssignmentTarget;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string stackVarPrefix;
    [CompilationMappingAttribute("9")]
internal static Tuple`2[] opNameTable { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2[] opCharTranslateTable { get; }
    [CompilationMappingAttribute("9")]
internal static HashSet`1<char> opCharSet { get; }
    [CompilationMappingAttribute("9")]
internal static HashSet`1<char> t@127-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<string, string>> keywordsWithDescription { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> keywordLookup { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> compileCustomOpName { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<char, string> t2@371 { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<char, string> t2@372-1 { get; }
    [CompilationMappingAttribute("9")]
internal static int maxOperatorNameLength@381 { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<char, string> accv@1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static int acc@1-1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<char, string> x@1 { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, string> compiledOperators@389 { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> standardOpNames { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> opNames@417 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, string> decompileCustomOpName { get; }
    [CompilationMappingAttribute("9")]
internal static ConcurrentDictionary`2<string, string> decompiledOperators@441 { get; }
    [CompilationMappingAttribute("9")]
internal static int minOperatorNameLength@445 { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<char, string> accv@1-1 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static int acc@1-2 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<char, string> x@1-1 { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> standardOpsDecompile { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<string, string> ops@508 { get; }
    [CompilationMappingAttribute("9")]
internal static string opNameCons { get; }
    [CompilationMappingAttribute("9")]
internal static string opNameNil { get; }
    [CompilationMappingAttribute("9")]
internal static string opNameEquals { get; }
    [CompilationMappingAttribute("9")]
internal static string opNameEqualsNullable { get; }
    [CompilationMappingAttribute("9")]
internal static string opNameNullableEquals { get; }
    [CompilationMappingAttribute("9")]
internal static string opNameNullableEqualsNullable { get; }
    [CompilationMappingAttribute("9")]
internal static String[] relational { get; }
    [CompilationMappingAttribute("9")]
internal static String[] concat { get; }
    [CompilationMappingAttribute("9")]
internal static String[] plusMinus { get; }
    [CompilationMappingAttribute("9")]
internal static String[] otherMath { get; }
    [CompilationMappingAttribute("9")]
internal static Char[] ignoredChars { get; }
    [CompilationMappingAttribute("9")]
internal static Char[] IllegalCharactersInTypeAndNamespaceNames { get; }
    internal static string outArgCompilerGeneratedName { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<int, FSharpFunc`2<int, string>> mkUnionCaseFieldName { get; }
    [CompilationMappingAttribute("9")]
internal static String[] names@1058 { get; }
    [CompilationMappingAttribute("9")]
internal static Int32[] arg@1-1 { get; }
    [CompilationMappingAttribute("9")]
internal static String[] res@1-5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<int, string> mkExceptionFieldName { get; }
    [CompilationMappingAttribute("9")]
internal static String[] names@1068-1 { get; }
    [CompilationMappingAttribute("9")]
internal static Int32[] arg@1-2 { get; }
    [CompilationMappingAttribute("9")]
internal static String[] res@1-6 { get; }
    public static string FsiDynamicModulePrefix { get; }
    internal static string unassignedTyparName { get; }
    internal static string FSharpOptimizationDataResourceName { get; }
    internal static string FSharpSignatureDataResourceName { get; }
    internal static string FSharpOptimizationCompressedDataResourceName { get; }
    internal static string FSharpSignatureCompressedDataResourceName { get; }
    internal static string FSharpOptimizationDataResourceName2 { get; }
    internal static string FSharpSignatureDataResourceName2 { get; }
    private static PrettyNaming();
    internal static Tuple`2[] get_opNameTable();
    internal static Tuple`2[] get_opCharTranslateTable();
    internal static HashSet`1<char> get_opCharSet();
    internal static HashSet`1<char> get_t@127-1();
    public static bool IsIdentifierFirstCharacter(char c);
    public static bool IsIdentifierPartCharacter(char c);
    internal static FSharpList`1<Tuple`2<string, string>> get_keywordsWithDescription();
    internal static FSharpSet`1<string> get_keywordLookup();
    internal static bool IsUnencodedLegacyOpName(string name);
    internal static bool loop@289-30(string name, int nameLen, int i);
    public static bool IsIdentifierName(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isCoreActivePatternName(string name, int idx, bool seenNonOpChar);
    public static bool IsActivePatternName(string name);
    internal static bool loop@327-31(string name, int idx, int endIndex);
    public static bool IsOperatorDisplayName(string name);
    internal static FSharpFunc`2<string, string> get_compileCustomOpName();
    internal static Dictionary`2<char, string> get_t2@371();
    internal static Dictionary`2<char, string> get_t2@372-1();
    internal static int get_maxOperatorNameLength@381();
    internal static Tuple`2<char, string> get_accv@1();
    internal static void set_accv@1(Tuple`2<char, string> value);
    internal static int get_acc@1-1();
    internal static void set_acc@1-1(int value);
    internal static Tuple`2<char, string> get_x@1();
    internal static ConcurrentDictionary`2<string, string> get_compiledOperators@389();
    internal static Dictionary`2<string, string> get_standardOpNames();
    internal static Dictionary`2<string, string> get_opNames@417();
    public static string CompileOpName(string op);
    internal static FSharpFunc`2<string, string> get_decompileCustomOpName();
    internal static ConcurrentDictionary`2<string, string> get_decompiledOperators@441();
    internal static int get_minOperatorNameLength@445();
    internal static Tuple`2<char, string> get_accv@1-1();
    internal static void set_accv@1-1(Tuple`2<char, string> value);
    internal static int get_acc@1-2();
    internal static void set_acc@1-2(int value);
    internal static Tuple`2<char, string> get_x@1-1();
    internal static string decompile@461(string opName, int opNameLen, StringBuilder sb, int idx);
    internal static Dictionary`2<string, string> get_standardOpsDecompile();
    internal static Dictionary`2<string, string> get_ops@508();
    public static string ConvertValLogicalNameToDisplayNameCore(string opName);
    internal static bool DoesIdentifierNeedBackticks(string name);
    internal static string AddBackticksToIdentifierIfNeeded(string name);
    public static string NormalizeIdentifierBackticks(string name);
    internal static string ConvertLogicalNameToDisplayName(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ConvertValLogicalNameToDisplayName(bool isBaseVal, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout ConvertLogicalNameToDisplayLayout(FSharpFunc`2<string, Layout> nonOpLayout, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout ConvertValLogicalNameToDisplayLayout(bool isBaseVal, FSharpFunc`2<string, Layout> nonOpLayout, string name);
    internal static string get_opNameCons();
    internal static string get_opNameNil();
    internal static string get_opNameEquals();
    internal static string get_opNameEqualsNullable();
    internal static string get_opNameNullableEquals();
    internal static string get_opNameNullableEqualsNullable();
    public static bool IsLongIdentifierPartCharacter(char c);
    internal static bool loop@611-32(string s, int idx);
    internal static bool isTildeOnlyString(string s);
    internal static bool IsValidPrefixOperatorUse(string s);
    internal static bool IsValidPrefixOperatorDefinitionName(string s);
    public static bool IsLogicalPrefixOperator(string logicalName);
    public static bool IsLogicalTernaryOperator(string logicalName);
    [CompilerGeneratedAttribute]
internal static bool IsPunctuation$cont@676(string s, Unit unitVar);
    public static bool IsPunctuation(string s);
    internal static String[] get_relational();
    internal static String[] get_concat();
    internal static String[] get_plusMinus();
    internal static String[] get_otherMath();
    internal static Char[] get_ignoredChars();
    internal static bool afterSkipStarts@726(string skipIgnoredChars, String[] prefixes);
    public static bool IsLogicalInfixOpName(string logicalName);
    public static bool IsLogicalOpName(string logicalName);
    internal static FSharpChoice`6<Unit, Unit, Unit, Unit, Unit, Unit> |Control|Equality|Relational|Indexer|FixedTypes|Other|(string opName);
    public static bool IsCompilerGeneratedName(string nm);
    internal static string CompilerGeneratedName(string nm);
    internal static string GetBasicNameOfPossibleCompilerGeneratedName(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string CompilerGeneratedNameSuffix(string basicName, string suffix);
    internal static FSharpValueOption`1<int> TryDemangleGenericNameAndPos(string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string DemangleGenericTypeNameWithPos(int pos, string mangledName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NameArityPair DecodeGenericTypeNameWithPos(int pos, string mangledName);
    internal static string DemangleGenericTypeName(string mangledName);
    internal static NameArityPair DecodeGenericTypeName(string mangledName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string chopStringTo(string s, char c);
    public static FSharpOption`1<string> TryChopPropertyName(string s);
    internal static string ChopPropertyName(string s);
    internal static FSharpList`1<string> SplitNamesForILPath(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] splitAroundQuotation(string text, char separator);
    [CompilerGeneratedAttribute]
internal static String[] splitAroundQuotationWithCount$cont@937(char separator, int count, String[] mangledText, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] splitAroundQuotationWithCount(string text, char separator, int count);
    internal static Char[] get_IllegalCharactersInTypeAndNamespaceNames();
    internal static FSharpList`1<Tuple`2<string, Range>> loop@964-33(string nm, Range mp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ActivePatternInfo> ActivePatternInfoOfValName(string nm, Range m);
    internal static FSharpOption`1<Tuple`2<string, string>> tryDemangleStaticStringArg(string mangledText);
    internal static Tuple`2<string, Tuple`2[]> DemangleProvidedTypeName(string typeLogicalName);
    internal static string MangleProvidedTypeName(string typeLogicalName, Tuple`2[] nonDefaultArgs);
    internal static string ComputeMangledNameWithoutDefaultArgValues(string nm, a[] staticArgs, Tuple`2[] defaultArgValues);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_outArgCompilerGeneratedName();
    internal static string ExtraWitnessMethodName(string nm);
    internal static FSharpFunc`2<int, FSharpFunc`2<int, string>> get_mkUnionCaseFieldName();
    internal static String[] get_names@1058();
    internal static Int32[] get_arg@1-1();
    internal static String[] get_res@1-5();
    internal static FSharpFunc`2<int, string> get_mkExceptionFieldName();
    internal static String[] get_names@1068-1();
    internal static Int32[] get_arg@1-2();
    internal static String[] get_res@1-6();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public static string get_FsiDynamicModulePrefix();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_unassignedTyparName();
    public static string FormatAndOtherOverloadsString(int remainingOverloads);
    public static FSharpList`1<string> GetLongNameFromString(string x);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpOptimizationDataResourceName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpSignatureDataResourceName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpOptimizationCompressedDataResourceName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpSignatureCompressedDataResourceName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpOptimizationDataResourceName2();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpSignatureDataResourceName2();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.QualifiedNameOfFile : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Ident item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Ident Item { get; }
    public string Text { get; }
    public Ident Id { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.QualifiedNameOfFile")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal QualifiedNameOfFile(Ident item);
    [CompilationMappingAttribute("8", "0")]
public static QualifiedNameOfFile NewQualifiedNameOfFile(Ident item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Ident get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public string get_Text();
    public Ident get_Id();
    public Range get_Range();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.ScopedPragma : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _warningNumber;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int warningNumber { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.ScopedPragma")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ScopedPragma(Range _range, int _warningNumber);
    [CompilationMappingAttribute("8", "0")]
public static ScopedPragma NewWarningOff(Range _range, int _warningNumber);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_warningNumber();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ScopedPragma obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SeqExprOnly : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool Item { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SeqExprOnly")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SeqExprOnly(bool item);
    [CompilationMappingAttribute("8", "0")]
public static SeqExprOnly NewSeqExprOnly(bool item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SeqExprOnly obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SeqExprOnly obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynAccess : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPublic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInternal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPrivate { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynAccess NewPublic(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPublic();
    [CompilationMappingAttribute("8", "1")]
public static SynAccess NewInternal(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInternal();
    [CompilationMappingAttribute("8", "2")]
public static SynAccess NewPrivate(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPrivate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public virtual string ToString();
    public Range get_Range();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SynAccess obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynArgInfo : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _optional;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Ident> _ident;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool optional { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> ident { get; }
    public FSharpOption`1<Ident> Ident { get; }
    public FSharpList`1<SynAttributeList> Attributes { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynArgInfo")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynArgInfo(FSharpList`1<SynAttributeList> _attributes, bool _optional, FSharpOption`1<Ident> _ident);
    [CompilationMappingAttribute("8", "0")]
public static SynArgInfo NewSynArgInfo(FSharpList`1<SynAttributeList> _attributes, bool _optional, FSharpOption`1<Ident> _ident);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_optional();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> get_ident();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public FSharpOption`1<Ident> get_Ident();
    public FSharpList`1<SynAttributeList> get_Attributes();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynArgPats : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPats { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamePatPairs { get; }
    public FSharpList`1<SynPat> Patterns { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynArgPats NewPats(FSharpList`1<SynPat> _pats);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPats();
    [CompilationMappingAttribute("8", "1")]
public static SynArgPats NewNamePatPairs(FSharpList`1<Tuple`3<Ident, FSharpOption`1<Range>, SynPat>> _pats, Range _range, SynArgPatsNamePatPairsTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamePatPairs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public FSharpList`1<SynPat> get_Patterns();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.Syntax.SynAttribute : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynLongIdent TypeName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynExpr ArgExpr@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Ident> Target@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool AppliesToGetterAndSetter@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range Range@;
    [CompilationMappingAttribute("4", "0")]
public SynLongIdent TypeName { get; }
    [CompilationMappingAttribute("4", "1")]
public SynExpr ArgExpr { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<Ident> Target { get; }
    [CompilationMappingAttribute("4", "3")]
public bool AppliesToGetterAndSetter { get; }
    [CompilationMappingAttribute("4", "4")]
public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynAttribute")]
public SynAttribute(SynLongIdent typeName, SynExpr argExpr, FSharpOption`1<Ident> target, bool appliesToGetterAndSetter, Range range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynLongIdent get_TypeName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr get_ArgExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> get_Target();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_AppliesToGetterAndSetter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_Range();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.Syntax.SynAttributeList : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<SynAttribute> Attributes@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range Range@;
    [CompilationMappingAttribute("4", "0")]
public FSharpList`1<SynAttribute> Attributes { get; }
    [CompilationMappingAttribute("4", "1")]
public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynAttributeList")]
public SynAttributeList(FSharpList`1<SynAttribute> attributes, Range range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttribute> get_Attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_Range();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynBinding : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynAccess> _accessibility;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynBindingKind _kind;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isInline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isMutable;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValData _valData;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynPat _headPat;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynBindingReturnInfo> _returnInfo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExpr _expr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DebugPointAtBinding _debugPoint;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynBindingTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> accessibility { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynBindingKind kind { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isInline { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isMutable { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValData valData { get; }
    [CompilationMappingAttribute("4", "0", "7")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynPat headPat { get; }
    [CompilationMappingAttribute("4", "0", "8")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynBindingReturnInfo> returnInfo { get; }
    [CompilationMappingAttribute("4", "0", "9")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr expr { get; }
    [CompilationMappingAttribute("4", "0", "10")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "11")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DebugPointAtBinding debugPoint { get; }
    [CompilationMappingAttribute("4", "0", "12")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynBindingTrivia trivia { get; }
    public Range RangeOfBindingWithoutRhs { get; }
    public Range RangeOfBindingWithRhs { get; }
    public Range RangeOfHeadPattern { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynBinding")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynBinding(FSharpOption`1<SynAccess> _accessibility, SynBindingKind _kind, bool _isInline, bool _isMutable, FSharpList`1<SynAttributeList> _attributes, PreXmlDoc _xmlDoc, SynValData _valData, SynPat _headPat, FSharpOption`1<SynBindingReturnInfo> _returnInfo, SynExpr _expr, Range _range, DebugPointAtBinding _debugPoint, SynBindingTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynBinding NewSynBinding(FSharpOption`1<SynAccess> _accessibility, SynBindingKind _kind, bool _isInline, bool _isMutable, FSharpList`1<SynAttributeList> _attributes, PreXmlDoc _xmlDoc, SynValData _valData, SynPat _headPat, FSharpOption`1<SynBindingReturnInfo> _returnInfo, SynExpr _expr, Range _range, DebugPointAtBinding _debugPoint, SynBindingTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> get_accessibility();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynBindingKind get_kind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isMutable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValData get_valData();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynPat get_headPat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynBindingReturnInfo> get_returnInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr get_expr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DebugPointAtBinding get_debugPoint();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynBindingTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_RangeOfBindingWithoutRhs();
    public Range get_RangeOfBindingWithRhs();
    public Range get_RangeOfHeadPattern();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynBindingKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynBindingKind _unique_StandaloneExpression;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynBindingKind _unique_Normal;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynBindingKind _unique_Do;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynBindingKind StandaloneExpression { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStandaloneExpression { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynBindingKind Normal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNormal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynBindingKind Do { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDo { get; }
    private static SynBindingKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynBindingKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynBindingKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynBindingKind get_StandaloneExpression();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStandaloneExpression();
    [CompilationMappingAttribute("8", "1")]
public static SynBindingKind get_Normal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNormal();
    [CompilationMappingAttribute("8", "2")]
public static SynBindingKind get_Do();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SynBindingKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SynBindingKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynBindingReturnInfo : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynType _typeName;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynBindingReturnInfoTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynType typeName { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynBindingReturnInfoTrivia trivia { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynBindingReturnInfo")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynBindingReturnInfo(SynType _typeName, Range _range, FSharpList`1<SynAttributeList> _attributes, SynBindingReturnInfoTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynBindingReturnInfo NewSynBindingReturnInfo(SynType _typeName, Range _range, FSharpList`1<SynAttributeList> _attributes, SynBindingReturnInfoTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynType get_typeName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynBindingReturnInfoTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[StructAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynByteStringKind : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynByteStringKind Regular { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRegular { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynByteStringKind Verbatim { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVerbatim { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynByteStringKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynByteStringKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynByteStringKind get_Regular();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRegular();
    [CompilationMappingAttribute("8", "1")]
public static SynByteStringKind get_Verbatim();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVerbatim();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SynByteStringKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SynByteStringKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynComponentInfo : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynTyparDecls> _typeParams;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynTypeConstraint> _constraints;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Ident> _longId;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _preferPostfix;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynAccess> _accessibility;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynTyparDecls> typeParams { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynTypeConstraint> constraints { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Ident> longId { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool preferPostfix { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> accessibility { get; }
    [CompilationMappingAttribute("4", "0", "7")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynComponentInfo")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynComponentInfo(FSharpList`1<SynAttributeList> _attributes, FSharpOption`1<SynTyparDecls> _typeParams, FSharpList`1<SynTypeConstraint> _constraints, FSharpList`1<Ident> _longId, PreXmlDoc _xmlDoc, bool _preferPostfix, FSharpOption`1<SynAccess> _accessibility, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static SynComponentInfo NewSynComponentInfo(FSharpList`1<SynAttributeList> _attributes, FSharpOption`1<SynTyparDecls> _typeParams, FSharpList`1<SynTypeConstraint> _constraints, FSharpList`1<Ident> _longId, PreXmlDoc _xmlDoc, bool _preferPostfix, FSharpOption`1<SynAccess> _accessibility, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynTyparDecls> get_typeParams();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynTypeConstraint> get_constraints();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Ident> get_longId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_preferPostfix();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> get_accessibility();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynConst : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynConst _unique_Unit;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynConst Unit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBool { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSByte { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsByte { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt16 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt16 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIntPtr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUIntPtr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSingle { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDouble { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDecimal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUserNum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBytes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt16s { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMeasure { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSourceIdentifier { get; }
    private static SynConst();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynConst")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynConst(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynConst get_Unit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnit();
    [CompilationMappingAttribute("8", "1")]
public static SynConst NewBool(bool item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBool();
    [CompilationMappingAttribute("8", "2")]
public static SynConst NewSByte(sbyte item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSByte();
    [CompilationMappingAttribute("8", "3")]
public static SynConst NewByte(byte item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsByte();
    [CompilationMappingAttribute("8", "4")]
public static SynConst NewInt16(short item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt16();
    [CompilationMappingAttribute("8", "5")]
public static SynConst NewUInt16(ushort item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt16();
    [CompilationMappingAttribute("8", "6")]
public static SynConst NewInt32(int item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt32();
    [CompilationMappingAttribute("8", "7")]
public static SynConst NewUInt32(UInt32 item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt32();
    [CompilationMappingAttribute("8", "8")]
public static SynConst NewInt64(long item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt64();
    [CompilationMappingAttribute("8", "9")]
public static SynConst NewUInt64(ulong item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt64();
    [CompilationMappingAttribute("8", "10")]
public static SynConst NewIntPtr(long item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIntPtr();
    [CompilationMappingAttribute("8", "11")]
public static SynConst NewUIntPtr(ulong item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUIntPtr();
    [CompilationMappingAttribute("8", "12")]
public static SynConst NewSingle(float item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSingle();
    [CompilationMappingAttribute("8", "13")]
public static SynConst NewDouble(double item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDouble();
    [CompilationMappingAttribute("8", "14")]
public static SynConst NewChar(char item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChar();
    [CompilationMappingAttribute("8", "15")]
public static SynConst NewDecimal(decimal item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDecimal();
    [CompilationMappingAttribute("8", "16")]
public static SynConst NewUserNum(string _value, string _suffix);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUserNum();
    [CompilationMappingAttribute("8", "17")]
public static SynConst NewString(string _text, SynStringKind _synStringKind, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsString();
    [CompilationMappingAttribute("8", "18")]
public static SynConst NewBytes(Byte[] _bytes, SynByteStringKind _synByteStringKind, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBytes();
    [CompilationMappingAttribute("8", "19")]
public static SynConst NewUInt16s(UInt16[] item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt16s();
    [CompilationMappingAttribute("8", "20")]
public static SynConst NewMeasure(SynConst _constant, Range _constantRange, SynMeasure _synMeasure, SynMeasureConstantTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMeasure();
    [CompilationMappingAttribute("8", "21")]
public static SynConst NewSourceIdentifier(string _constant, string _value, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSourceIdentifier();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range Range(Range dflt);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynEnumCase : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynIdent _ident;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExpr _valueExpr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynEnumCaseTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynIdent ident { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr valueExpr { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynEnumCaseTrivia trivia { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynEnumCase")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynEnumCase(FSharpList`1<SynAttributeList> _attributes, SynIdent _ident, SynExpr _valueExpr, PreXmlDoc _xmlDoc, Range _range, SynEnumCaseTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynEnumCase NewSynEnumCase(FSharpList`1<SynAttributeList> _attributes, SynIdent _ident, SynExpr _valueExpr, PreXmlDoc _xmlDoc, Range _range, SynEnumCaseTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynIdent get_ident();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr get_valueExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynEnumCaseTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynExceptionDefn : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExceptionDefnRepr _exnRepr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Range> _withKeyword;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynMemberDefn> _members;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExceptionDefnRepr exnRepr { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> withKeyword { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberDefn> members { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynExceptionDefn")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExceptionDefn(SynExceptionDefnRepr _exnRepr, FSharpOption`1<Range> _withKeyword, FSharpList`1<SynMemberDefn> _members, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static SynExceptionDefn NewSynExceptionDefn(SynExceptionDefnRepr _exnRepr, FSharpOption`1<Range> _withKeyword, FSharpList`1<SynMemberDefn> _members, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExceptionDefnRepr get_exnRepr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_withKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberDefn> get_members();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynExceptionDefnRepr : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynUnionCase _caseName;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<FSharpList`1<Ident>> _longId;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynAccess> _accessibility;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynUnionCase caseName { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<FSharpList`1<Ident>> longId { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> accessibility { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynExceptionDefnRepr")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExceptionDefnRepr(FSharpList`1<SynAttributeList> _attributes, SynUnionCase _caseName, FSharpOption`1<FSharpList`1<Ident>> _longId, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static SynExceptionDefnRepr NewSynExceptionDefnRepr(FSharpList`1<SynAttributeList> _attributes, SynUnionCase _caseName, FSharpOption`1<FSharpList`1<Ident>> _longId, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynUnionCase get_caseName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<FSharpList`1<Ident>> get_longId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> get_accessibility();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynExceptionSig : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExceptionDefnRepr _exnRepr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Range> _withKeyword;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynMemberSig> _members;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExceptionDefnRepr exnRepr { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> withKeyword { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberSig> members { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynExceptionSig")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExceptionSig(SynExceptionDefnRepr _exnRepr, FSharpOption`1<Range> _withKeyword, FSharpList`1<SynMemberSig> _members, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static SynExceptionSig NewSynExceptionSig(SynExceptionDefnRepr _exnRepr, FSharpOption`1<Range> _withKeyword, FSharpList`1<SynMemberSig> _members, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExceptionDefnRepr get_exnRepr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_withKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberSig> get_members();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynExpr : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConst { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTyped { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTuple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnonRecd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArrayOrList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNew { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsObjExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsForEach { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArrayOrListComputed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIndexRange { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIndexFromEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsComputationExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLambda { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMatchLambda { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMatch { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAssert { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLetOrUse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTryWith { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTryFinally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLazy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSequential { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIfThenElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIdent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLongIdent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLongIdentSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotLambda { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotIndexedGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotIndexedSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamedIndexedPropertySet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotNamedIndexedPropertySet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeTest { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUpcast { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDowncast { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInferredUpcast { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInferredDowncast { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAddressOf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTraitCall { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJoinIn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsImplicitZero { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSequentialOrImplicitYield { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYieldOrReturn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYieldOrReturnFrom { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLetOrUseBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMatchBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDoBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhileBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLibraryOnlyILAssembly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLibraryOnlyStaticOptimization { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLibraryOnlyUnionCaseFieldGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLibraryOnlyUnionCaseFieldSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArbitraryAfterError { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFromParseError { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDiscardAfterMissingQualificationAfterDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFixed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterpolatedString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDebugPoint { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDynamic { get; }
    public Range Range { get; }
    public Range RangeWithoutAnyExtraDot { get; }
    public Range RangeOfFirstPortion { get; }
    public bool IsArbExprAndThusAlreadyReportedError { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynExpr")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExpr(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynExpr NewParen(SynExpr _expr, Range _leftParenRange, FSharpOption`1<Range> _rightParenRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParen();
    [CompilationMappingAttribute("8", "1")]
public static SynExpr NewQuote(SynExpr _operator, bool _isRaw, SynExpr _quotedExpr, bool _isFromQueryExpression, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsQuote();
    [CompilationMappingAttribute("8", "2")]
public static SynExpr NewConst(SynConst _constant, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConst();
    [CompilationMappingAttribute("8", "3")]
public static SynExpr NewTyped(SynExpr _expr, SynType _targetType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTyped();
    [CompilationMappingAttribute("8", "4")]
public static SynExpr NewTuple(bool _isStruct, FSharpList`1<SynExpr> _exprs, FSharpList`1<Range> _commaRanges, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTuple();
    [CompilationMappingAttribute("8", "5")]
public static SynExpr NewAnonRecd(bool _isStruct, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<Range, FSharpOption`1<Position>>>> _copyInfo, FSharpList`1<Tuple`3<SynLongIdent, FSharpOption`1<Range>, SynExpr>> _recordFields, Range _range, SynExprAnonRecdTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnonRecd();
    [CompilationMappingAttribute("8", "6")]
public static SynExpr NewArrayOrList(bool _isArray, FSharpList`1<SynExpr> _exprs, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArrayOrList();
    [CompilationMappingAttribute("8", "7")]
public static SynExpr NewRecord(FSharpOption`1<Tuple`5<SynType, SynExpr, Range, FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>>, Range>> _baseInfo, FSharpOption`1<Tuple`2<SynExpr, Tuple`2<Range, FSharpOption`1<Position>>>> _copyInfo, FSharpList`1<SynExprRecordField> _recordFields, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute("8", "8")]
public static SynExpr NewNew(bool _isProtected, SynType _targetType, SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNew();
    [CompilationMappingAttribute("8", "9")]
public static SynExpr NewObjExpr(SynType _objType, FSharpOption`1<Tuple`2<SynExpr, FSharpOption`1<Ident>>> _argOptions, FSharpOption`1<Range> _withKeyword, FSharpList`1<SynBinding> _bindings, FSharpList`1<SynMemberDefn> _members, FSharpList`1<SynInterfaceImpl> _extraImpls, Range _newExprRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsObjExpr();
    [CompilationMappingAttribute("8", "10")]
public static SynExpr NewWhile(DebugPointAtWhile _whileDebugPoint, SynExpr _whileExpr, SynExpr _doExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhile();
    [CompilationMappingAttribute("8", "11")]
public static SynExpr NewFor(DebugPointAtFor _forDebugPoint, DebugPointAtInOrTo _toDebugPoint, Ident _ident, FSharpOption`1<Range> _equalsRange, SynExpr _identBody, bool _direction, SynExpr _toBody, SynExpr _doBody, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFor();
    [CompilationMappingAttribute("8", "12")]
public static SynExpr NewForEach(DebugPointAtFor _forDebugPoint, DebugPointAtInOrTo _inDebugPoint, SeqExprOnly _seqExprOnly, bool _isFromSource, SynPat _pat, SynExpr _enumExpr, SynExpr _bodyExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsForEach();
    [CompilationMappingAttribute("8", "13")]
public static SynExpr NewArrayOrListComputed(bool _isArray, SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArrayOrListComputed();
    [CompilationMappingAttribute("8", "14")]
public static SynExpr NewIndexRange(FSharpOption`1<SynExpr> _expr1, Range _opm, FSharpOption`1<SynExpr> _expr2, Range _range1, Range _range2, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIndexRange();
    [CompilationMappingAttribute("8", "15")]
public static SynExpr NewIndexFromEnd(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIndexFromEnd();
    [CompilationMappingAttribute("8", "16")]
public static SynExpr NewComputationExpr(bool _hasSeqBuilder, SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsComputationExpr();
    [CompilationMappingAttribute("8", "17")]
public static SynExpr NewLambda(bool _fromMethod, bool _inLambdaSeq, SynSimplePats _args, SynExpr _body, FSharpOption`1<Tuple`2<FSharpList`1<SynPat>, SynExpr>> _parsedData, Range _range, SynExprLambdaTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLambda();
    [CompilationMappingAttribute("8", "18")]
public static SynExpr NewMatchLambda(bool _isExnMatch, Range _keywordRange, FSharpList`1<SynMatchClause> _matchClauses, DebugPointAtBinding _matchDebugPoint, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMatchLambda();
    [CompilationMappingAttribute("8", "19")]
public static SynExpr NewMatch(DebugPointAtBinding _matchDebugPoint, SynExpr _expr, FSharpList`1<SynMatchClause> _clauses, Range _range, SynExprMatchTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMatch();
    [CompilationMappingAttribute("8", "20")]
public static SynExpr NewDo(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDo();
    [CompilationMappingAttribute("8", "21")]
public static SynExpr NewAssert(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAssert();
    [CompilationMappingAttribute("8", "22")]
public static SynExpr NewApp(ExprAtomicFlag _flag, bool _isInfix, SynExpr _funcExpr, SynExpr _argExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsApp();
    [CompilationMappingAttribute("8", "23")]
public static SynExpr NewTypeApp(SynExpr _expr, Range _lessRange, FSharpList`1<SynType> _typeArgs, FSharpList`1<Range> _commaRanges, FSharpOption`1<Range> _greaterRange, Range _typeArgsRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeApp();
    [CompilationMappingAttribute("8", "24")]
public static SynExpr NewLetOrUse(bool _isRecursive, bool _isUse, FSharpList`1<SynBinding> _bindings, SynExpr _body, Range _range, SynExprLetOrUseTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLetOrUse();
    [CompilationMappingAttribute("8", "25")]
public static SynExpr NewTryWith(SynExpr _tryExpr, FSharpList`1<SynMatchClause> _withCases, Range _range, DebugPointAtTry _tryDebugPoint, DebugPointAtWith _withDebugPoint, SynExprTryWithTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTryWith();
    [CompilationMappingAttribute("8", "26")]
public static SynExpr NewTryFinally(SynExpr _tryExpr, SynExpr _finallyExpr, Range _range, DebugPointAtTry _tryDebugPoint, DebugPointAtFinally _finallyDebugPoint, SynExprTryFinallyTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTryFinally();
    [CompilationMappingAttribute("8", "27")]
public static SynExpr NewLazy(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLazy();
    [CompilationMappingAttribute("8", "28")]
public static SynExpr NewSequential(DebugPointAtSequential _debugPoint, bool _isTrueSeq, SynExpr _expr1, SynExpr _expr2, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSequential();
    [CompilationMappingAttribute("8", "29")]
public static SynExpr NewIfThenElse(SynExpr _ifExpr, SynExpr _thenExpr, FSharpOption`1<SynExpr> _elseExpr, DebugPointAtBinding _spIfToThen, bool _isFromErrorRecovery, Range _range, SynExprIfThenElseTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIfThenElse();
    [CompilationMappingAttribute("8", "30")]
public static SynExpr NewTypar(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypar();
    [CompilationMappingAttribute("8", "31")]
public static SynExpr NewIdent(Ident _ident);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIdent();
    [CompilationMappingAttribute("8", "32")]
public static SynExpr NewLongIdent(bool _isOptional, SynLongIdent _longDotId, FSharpOption`1<FSharpRef`1<SynSimplePatAlternativeIdInfo>> _altNameRefCell, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLongIdent();
    [CompilationMappingAttribute("8", "33")]
public static SynExpr NewLongIdentSet(SynLongIdent _longDotId, SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLongIdentSet();
    [CompilationMappingAttribute("8", "34")]
public static SynExpr NewDotGet(SynExpr _expr, Range _rangeOfDot, SynLongIdent _longDotId, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotGet();
    [CompilationMappingAttribute("8", "35")]
public static SynExpr NewDotLambda(SynExpr _expr, Range _range, SynExprDotLambdaTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotLambda();
    [CompilationMappingAttribute("8", "36")]
public static SynExpr NewDotSet(SynExpr _targetExpr, SynLongIdent _longDotId, SynExpr _rhsExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotSet();
    [CompilationMappingAttribute("8", "37")]
public static SynExpr NewSet(SynExpr _targetExpr, SynExpr _rhsExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSet();
    [CompilationMappingAttribute("8", "38")]
public static SynExpr NewDotIndexedGet(SynExpr _objectExpr, SynExpr _indexArgs, Range _dotRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotIndexedGet();
    [CompilationMappingAttribute("8", "39")]
public static SynExpr NewDotIndexedSet(SynExpr _objectExpr, SynExpr _indexArgs, SynExpr _valueExpr, Range _leftOfSetRange, Range _dotRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotIndexedSet();
    [CompilationMappingAttribute("8", "40")]
public static SynExpr NewNamedIndexedPropertySet(SynLongIdent _longDotId, SynExpr _expr1, SynExpr _expr2, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamedIndexedPropertySet();
    [CompilationMappingAttribute("8", "41")]
public static SynExpr NewDotNamedIndexedPropertySet(SynExpr _targetExpr, SynLongIdent _longDotId, SynExpr _argExpr, SynExpr _rhsExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotNamedIndexedPropertySet();
    [CompilationMappingAttribute("8", "42")]
public static SynExpr NewTypeTest(SynExpr _expr, SynType _targetType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeTest();
    [CompilationMappingAttribute("8", "43")]
public static SynExpr NewUpcast(SynExpr _expr, SynType _targetType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUpcast();
    [CompilationMappingAttribute("8", "44")]
public static SynExpr NewDowncast(SynExpr _expr, SynType _targetType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDowncast();
    [CompilationMappingAttribute("8", "45")]
public static SynExpr NewInferredUpcast(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInferredUpcast();
    [CompilationMappingAttribute("8", "46")]
public static SynExpr NewInferredDowncast(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInferredDowncast();
    [CompilationMappingAttribute("8", "47")]
public static SynExpr NewNull(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNull();
    [CompilationMappingAttribute("8", "48")]
public static SynExpr NewAddressOf(bool _isByref, SynExpr _expr, Range _opRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAddressOf();
    [CompilationMappingAttribute("8", "49")]
public static SynExpr NewTraitCall(SynType _supportTys, SynMemberSig _traitSig, SynExpr _argExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTraitCall();
    [CompilationMappingAttribute("8", "50")]
public static SynExpr NewJoinIn(SynExpr _lhsExpr, Range _lhsRange, SynExpr _rhsExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJoinIn();
    [CompilationMappingAttribute("8", "51")]
public static SynExpr NewImplicitZero(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsImplicitZero();
    [CompilationMappingAttribute("8", "52")]
public static SynExpr NewSequentialOrImplicitYield(DebugPointAtSequential _debugPoint, SynExpr _expr1, SynExpr _expr2, SynExpr _ifNotStmt, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSequentialOrImplicitYield();
    [CompilationMappingAttribute("8", "53")]
public static SynExpr NewYieldOrReturn(Tuple`2<bool, bool> _flags, SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYieldOrReturn();
    [CompilationMappingAttribute("8", "54")]
public static SynExpr NewYieldOrReturnFrom(Tuple`2<bool, bool> _flags, SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYieldOrReturnFrom();
    [CompilationMappingAttribute("8", "55")]
public static SynExpr NewLetOrUseBang(DebugPointAtBinding _bindDebugPoint, bool _isUse, bool _isFromSource, SynPat _pat, SynExpr _rhs, FSharpList`1<SynExprAndBang> _andBangs, SynExpr _body, Range _range, SynExprLetOrUseBangTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLetOrUseBang();
    [CompilationMappingAttribute("8", "56")]
public static SynExpr NewMatchBang(DebugPointAtBinding _matchDebugPoint, SynExpr _expr, FSharpList`1<SynMatchClause> _clauses, Range _range, SynExprMatchBangTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMatchBang();
    [CompilationMappingAttribute("8", "57")]
public static SynExpr NewDoBang(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDoBang();
    [CompilationMappingAttribute("8", "58")]
public static SynExpr NewWhileBang(DebugPointAtWhile _whileDebugPoint, SynExpr _whileExpr, SynExpr _doExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhileBang();
    [CompilationMappingAttribute("8", "59")]
public static SynExpr NewLibraryOnlyILAssembly(object _ilCode, FSharpList`1<SynType> _typeArgs, FSharpList`1<SynExpr> _args, FSharpList`1<SynType> _retTy, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLibraryOnlyILAssembly();
    [CompilationMappingAttribute("8", "60")]
public static SynExpr NewLibraryOnlyStaticOptimization(FSharpList`1<SynStaticOptimizationConstraint> _constraints, SynExpr _expr, SynExpr _optimizedExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLibraryOnlyStaticOptimization();
    [CompilationMappingAttribute("8", "61")]
public static SynExpr NewLibraryOnlyUnionCaseFieldGet(SynExpr _expr, FSharpList`1<Ident> _longId, int _fieldNum, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLibraryOnlyUnionCaseFieldGet();
    [CompilationMappingAttribute("8", "62")]
public static SynExpr NewLibraryOnlyUnionCaseFieldSet(SynExpr _expr, FSharpList`1<Ident> _longId, int _fieldNum, SynExpr _rhsExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLibraryOnlyUnionCaseFieldSet();
    [CompilationMappingAttribute("8", "63")]
public static SynExpr NewArbitraryAfterError(string _debugStr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArbitraryAfterError();
    [CompilationMappingAttribute("8", "64")]
public static SynExpr NewFromParseError(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFromParseError();
    [CompilationMappingAttribute("8", "65")]
public static SynExpr NewDiscardAfterMissingQualificationAfterDot(SynExpr _expr, Range _dotRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDiscardAfterMissingQualificationAfterDot();
    [CompilationMappingAttribute("8", "66")]
public static SynExpr NewFixed(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFixed();
    [CompilationMappingAttribute("8", "67")]
public static SynExpr NewInterpolatedString(FSharpList`1<SynInterpolatedStringPart> _contents, SynStringKind _synStringKind, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterpolatedString();
    [CompilationMappingAttribute("8", "68")]
public static SynExpr NewDebugPoint(DebugPointAtLeafExpr _debugPoint, bool _isControlFlow, SynExpr _innerExpr);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDebugPoint();
    [CompilationMappingAttribute("8", "69")]
public static SynExpr NewDynamic(SynExpr _funcExpr, Range _qmark, SynExpr _argExpr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDynamic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
    public Range get_RangeWithoutAnyExtraDot();
    public Range get_RangeOfFirstPortion();
    public bool get_IsArbExprAndThusAlreadyReportedError();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynExprAndBang : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DebugPointAtBinding _debugPoint;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isUse;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isFromSource;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynPat _pat;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExpr _body;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExprAndBangTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DebugPointAtBinding debugPoint { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isUse { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isFromSource { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynPat pat { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr body { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExprAndBangTrivia trivia { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynExprAndBang")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExprAndBang(DebugPointAtBinding _debugPoint, bool _isUse, bool _isFromSource, SynPat _pat, SynExpr _body, Range _range, SynExprAndBangTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynExprAndBang NewSynExprAndBang(DebugPointAtBinding _debugPoint, bool _isUse, bool _isFromSource, SynPat _pat, SynExpr _body, Range _range, SynExprAndBangTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DebugPointAtBinding get_debugPoint();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isUse();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isFromSource();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynPat get_pat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr get_body();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExprAndBangTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynExprRecordField : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Tuple`2<SynLongIdent, bool> _fieldName;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Range> _equalsRange;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynExpr> _expr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>> _blockSeparator;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<SynLongIdent, bool> fieldName { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> equalsRange { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynExpr> expr { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>> blockSeparator { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynExprRecordField")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExprRecordField(Tuple`2<SynLongIdent, bool> _fieldName, FSharpOption`1<Range> _equalsRange, FSharpOption`1<SynExpr> _expr, FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>> _blockSeparator);
    [CompilationMappingAttribute("8", "0")]
public static SynExprRecordField NewSynExprRecordField(Tuple`2<SynLongIdent, bool> _fieldName, FSharpOption`1<Range> _equalsRange, FSharpOption`1<SynExpr> _expr, FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>> _blockSeparator);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<SynLongIdent, bool> get_fieldName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_equalsRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynExpr> get_expr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Tuple`2<Range, FSharpOption`1<Position>>> get_blockSeparator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynField : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isStatic;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Ident> _idOpt;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynType _fieldType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isMutable;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynAccess> _accessibility;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynFieldTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isStatic { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> idOpt { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynType fieldType { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isMutable { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> accessibility { get; }
    [CompilationMappingAttribute("4", "0", "7")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "8")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynFieldTrivia trivia { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynField")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynField(FSharpList`1<SynAttributeList> _attributes, bool _isStatic, FSharpOption`1<Ident> _idOpt, SynType _fieldType, bool _isMutable, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, Range _range, SynFieldTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynField NewSynField(FSharpList`1<SynAttributeList> _attributes, bool _isStatic, FSharpOption`1<Ident> _idOpt, SynType _fieldType, bool _isMutable, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, Range _range, SynFieldTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isStatic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> get_idOpt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynType get_fieldType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isMutable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> get_accessibility();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynFieldTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynIdent : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Ident _ident;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<IdentTrivia> _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Ident ident { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<IdentTrivia> trivia { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynIdent")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynIdent(Ident _ident, FSharpOption`1<IdentTrivia> _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynIdent NewSynIdent(Ident _ident, FSharpOption`1<IdentTrivia> _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Ident get_ident();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<IdentTrivia> get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynInterfaceImpl : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynType _interfaceTy;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Range> _withKeyword;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynBinding> _bindings;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynMemberDefn> _members;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynType interfaceTy { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> withKeyword { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynBinding> bindings { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberDefn> members { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynInterfaceImpl")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynInterfaceImpl(SynType _interfaceTy, FSharpOption`1<Range> _withKeyword, FSharpList`1<SynBinding> _bindings, FSharpList`1<SynMemberDefn> _members, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static SynInterfaceImpl NewSynInterfaceImpl(SynType _interfaceTy, FSharpOption`1<Range> _withKeyword, FSharpList`1<SynBinding> _bindings, FSharpList`1<SynMemberDefn> _members, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynType get_interfaceTy();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_withKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynBinding> get_bindings();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberDefn> get_members();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynInterpolatedStringPart : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFillExpr { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynInterpolatedStringPart NewString(string _value, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsString();
    [CompilationMappingAttribute("8", "1")]
public static SynInterpolatedStringPart NewFillExpr(SynExpr _fillExpr, FSharpOption`1<Ident> _qualifiers);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFillExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynLongIdent : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Ident> _id;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Range> _dotRanges;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<FSharpOption`1<IdentTrivia>> _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Ident> id { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Range> dotRanges { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FSharpOption`1<IdentTrivia>> trivia { get; }
    public Range Range { get; }
    public FSharpList`1<Ident> LongIdent { get; }
    public FSharpList`1<Range> Dots { get; }
    public FSharpList`1<IdentTrivia> Trivia { get; }
    public FSharpList`1<SynIdent> IdentsWithTrivia { get; }
    public bool ThereIsAnExtraDotAtTheEnd { get; }
    public Range RangeWithoutAnyExtraDot { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynLongIdent")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynLongIdent(FSharpList`1<Ident> _id, FSharpList`1<Range> _dotRanges, FSharpList`1<FSharpOption`1<IdentTrivia>> _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynLongIdent NewSynLongIdent(FSharpList`1<Ident> _id, FSharpList`1<Range> _dotRanges, FSharpList`1<FSharpOption`1<IdentTrivia>> _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Ident> get_id();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Range> get_dotRanges();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FSharpOption`1<IdentTrivia>> get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
    public FSharpList`1<Ident> get_LongIdent();
    public FSharpList`1<Range> get_Dots();
    public FSharpList`1<IdentTrivia> get_Trivia();
    public FSharpList`1<SynIdent> get_IdentsWithTrivia();
    public bool get_ThereIsAnExtraDotAtTheEnd();
    public Range get_RangeWithoutAnyExtraDot();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Syntax.SynLongIdentHelpers : object {
    [ObsoleteAttribute("Please use SynLongIdent or define a custom active pattern")]
public static Tuple`2<FSharpList`1<Ident>, FSharpList`1<Range>> |LongIdentWithDots|(SynLongIdent _arg1);
    [ObsoleteAttribute("Please use SynLongIdent")]
public static SynLongIdent LongIdentWithDots(FSharpList`1<Ident> lid, FSharpList`1<Range> dots);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynMatchClause : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynPat _pat;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynExpr> _whenExpr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynExpr _resultExpr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal DebugPointAtTarget _debugPoint;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynMatchClauseTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynPat pat { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynExpr> whenExpr { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr resultExpr { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DebugPointAtTarget debugPoint { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynMatchClauseTrivia trivia { get; }
    public Range RangeOfGuardAndRhs { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynMatchClause")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynMatchClause(SynPat _pat, FSharpOption`1<SynExpr> _whenExpr, SynExpr _resultExpr, Range _range, DebugPointAtTarget _debugPoint, SynMatchClauseTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynMatchClause NewSynMatchClause(SynPat _pat, FSharpOption`1<SynExpr> _whenExpr, SynExpr _resultExpr, Range _range, DebugPointAtTarget _debugPoint, SynMatchClauseTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynPat get_pat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynExpr> get_whenExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynExpr get_resultExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DebugPointAtTarget get_debugPoint();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynMatchClauseTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_RangeOfGuardAndRhs();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynMeasure : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProduct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSeq { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDivide { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPower { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOne { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParen { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynMeasure")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynMeasure(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynMeasure NewNamed(FSharpList`1<Ident> _longId, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamed();
    [CompilationMappingAttribute("8", "1")]
public static SynMeasure NewProduct(SynMeasure _measure1, Range _mAsterisk, SynMeasure _measure2, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProduct();
    [CompilationMappingAttribute("8", "2")]
public static SynMeasure NewSeq(FSharpList`1<SynMeasure> _measures, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSeq();
    [CompilationMappingAttribute("8", "3")]
public static SynMeasure NewDivide(FSharpOption`1<SynMeasure> _measure1, Range _mSlash, SynMeasure _measure2, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDivide();
    [CompilationMappingAttribute("8", "4")]
public static SynMeasure NewPower(SynMeasure _measure, Range _caretRange, SynRationalConst _power, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPower();
    [CompilationMappingAttribute("8", "5")]
public static SynMeasure NewOne(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOne();
    [CompilationMappingAttribute("8", "6")]
public static SynMeasure NewAnon(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnon();
    [CompilationMappingAttribute("8", "7")]
public static SynMeasure NewVar(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVar();
    [CompilationMappingAttribute("8", "8")]
public static SynMeasure NewParen(SynMeasure _measure, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynMemberDefn : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGetSetMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsImplicitCtor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsImplicitInherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLetBindings { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAbstractSlot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsValField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNestedType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAutoProperty { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynMemberDefn")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynMemberDefn(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynMemberDefn NewOpen(SynOpenDeclTarget _target, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpen();
    [CompilationMappingAttribute("8", "1")]
public static SynMemberDefn NewMember(SynBinding _memberDefn, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMember();
    [CompilationMappingAttribute("8", "2")]
public static SynMemberDefn NewGetSetMember(FSharpOption`1<SynBinding> _memberDefnForGet, FSharpOption`1<SynBinding> _memberDefnForSet, Range _range, SynMemberGetSetTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGetSetMember();
    [CompilationMappingAttribute("8", "3")]
public static SynMemberDefn NewImplicitCtor(FSharpOption`1<SynAccess> _accessibility, FSharpList`1<SynAttributeList> _attributes, SynSimplePats _ctorArgs, FSharpOption`1<Ident> _selfIdentifier, PreXmlDoc _xmlDoc, Range _range, SynMemberDefnImplicitCtorTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsImplicitCtor();
    [CompilationMappingAttribute("8", "4")]
public static SynMemberDefn NewImplicitInherit(SynType _inheritType, SynExpr _inheritArgs, FSharpOption`1<Ident> _inheritAlias, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsImplicitInherit();
    [CompilationMappingAttribute("8", "5")]
public static SynMemberDefn NewLetBindings(FSharpList`1<SynBinding> _bindings, bool _isStatic, bool _isRecursive, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLetBindings();
    [CompilationMappingAttribute("8", "6")]
public static SynMemberDefn NewAbstractSlot(SynValSig _slotSig, SynMemberFlags _flags, Range _range, SynMemberDefnAbstractSlotTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAbstractSlot();
    [CompilationMappingAttribute("8", "7")]
public static SynMemberDefn NewInterface(SynType _interfaceType, FSharpOption`1<Range> _withKeyword, FSharpOption`1<FSharpList`1<SynMemberDefn>> _members, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "8")]
public static SynMemberDefn NewInherit(SynType _baseType, FSharpOption`1<Ident> _asIdent, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInherit();
    [CompilationMappingAttribute("8", "9")]
public static SynMemberDefn NewValField(SynField _fieldInfo, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsValField();
    [CompilationMappingAttribute("8", "10")]
public static SynMemberDefn NewNestedType(SynTypeDefn _typeDefn, FSharpOption`1<SynAccess> _accessibility, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNestedType();
    [CompilationMappingAttribute("8", "11")]
public static SynMemberDefn NewAutoProperty(FSharpList`1<SynAttributeList> _attributes, bool _isStatic, Ident _ident, FSharpOption`1<SynType> _typeOpt, SynMemberKind _propKind, SynMemberFlags _memberFlags, SynMemberFlags _memberFlagsForSet, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, SynExpr _synExpr, Range _range, SynMemberDefnAutoPropertyTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAutoProperty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[CustomEqualityAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.Syntax.SynMemberFlags : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInstance@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDispatchSlot@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsOverrideOrExplicitImpl@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFinal@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool GetterOrSetterIsCompilerGenerated@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynMemberKind MemberKind@;
    [CompilationMappingAttribute("4", "0")]
public bool IsInstance { get; }
    [CompilationMappingAttribute("4", "1")]
public bool IsDispatchSlot { get; }
    [CompilationMappingAttribute("4", "2")]
public bool IsOverrideOrExplicitImpl { get; }
    [CompilationMappingAttribute("4", "3")]
public bool IsFinal { get; }
    [CompilationMappingAttribute("4", "4")]
public bool GetterOrSetterIsCompilerGenerated { get; }
    [CompilationMappingAttribute("4", "5")]
public SynMemberKind MemberKind { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynMemberFlags")]
public SynMemberFlags(bool isInstance, bool isDispatchSlot, bool isOverrideOrExplicitImpl, bool isFinal, bool getterOrSetterIsCompilerGenerated, SynMemberKind memberKind);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInstance();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDispatchSlot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOverrideOrExplicitImpl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFinal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_GetterOrSetterIsCompilerGenerated();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynMemberKind get_MemberKind();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynMemberKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynMemberKind _unique_ClassConstructor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynMemberKind _unique_Constructor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynMemberKind _unique_Member;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynMemberKind _unique_PropertyGet;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynMemberKind _unique_PropertySet;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynMemberKind _unique_PropertyGetSet;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynMemberKind ClassConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClassConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynMemberKind Constructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynMemberKind Member { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynMemberKind PropertyGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPropertyGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynMemberKind PropertySet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPropertySet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynMemberKind PropertyGetSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPropertyGetSet { get; }
    private static SynMemberKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynMemberKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynMemberKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynMemberKind get_ClassConstructor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClassConstructor();
    [CompilationMappingAttribute("8", "1")]
public static SynMemberKind get_Constructor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstructor();
    [CompilationMappingAttribute("8", "2")]
public static SynMemberKind get_Member();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMember();
    [CompilationMappingAttribute("8", "3")]
public static SynMemberKind get_PropertyGet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPropertyGet();
    [CompilationMappingAttribute("8", "4")]
public static SynMemberKind get_PropertySet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPropertySet();
    [CompilationMappingAttribute("8", "5")]
public static SynMemberKind get_PropertyGetSet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPropertyGetSet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SynMemberKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynMemberSig : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsValField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNestedType { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynMemberSig")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynMemberSig(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynMemberSig NewMember(SynValSig _memberSig, SynMemberFlags _flags, Range _range, SynMemberSigMemberTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMember();
    [CompilationMappingAttribute("8", "1")]
public static SynMemberSig NewInterface(SynType _interfaceType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "2")]
public static SynMemberSig NewInherit(SynType _inheritedType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInherit();
    [CompilationMappingAttribute("8", "3")]
public static SynMemberSig NewValField(SynField _field, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsValField();
    [CompilationMappingAttribute("8", "4")]
public static SynMemberSig NewNestedType(SynTypeDefnSig _nestedType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNestedType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynModuleDecl : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleAbbrev { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNestedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAttributes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashDirective { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespaceFragment { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynModuleDecl")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleDecl(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynModuleDecl NewModuleAbbrev(Ident _ident, FSharpList`1<Ident> _longId, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleAbbrev();
    [CompilationMappingAttribute("8", "1")]
public static SynModuleDecl NewNestedModule(SynComponentInfo _moduleInfo, bool _isRecursive, FSharpList`1<SynModuleDecl> _decls, bool _isContinuing, Range _range, SynModuleDeclNestedModuleTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNestedModule();
    [CompilationMappingAttribute("8", "2")]
public static SynModuleDecl NewLet(bool _isRecursive, FSharpList`1<SynBinding> _bindings, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLet();
    [CompilationMappingAttribute("8", "3")]
public static SynModuleDecl NewExpr(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExpr();
    [CompilationMappingAttribute("8", "4")]
public static SynModuleDecl NewTypes(FSharpList`1<SynTypeDefn> _typeDefns, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypes();
    [CompilationMappingAttribute("8", "5")]
public static SynModuleDecl NewException(SynExceptionDefn _exnDefn, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "6")]
public static SynModuleDecl NewOpen(SynOpenDeclTarget _target, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpen();
    [CompilationMappingAttribute("8", "7")]
public static SynModuleDecl NewAttributes(FSharpList`1<SynAttributeList> _attributes, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAttributes();
    [CompilationMappingAttribute("8", "8")]
public static SynModuleDecl NewHashDirective(ParsedHashDirective _hashDirective, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashDirective();
    [CompilationMappingAttribute("8", "9")]
public static SynModuleDecl NewNamespaceFragment(SynModuleOrNamespace _fragment);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespaceFragment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynModuleOrNamespace : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Ident> _longId;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isRecursive;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleOrNamespaceKind _kind;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynModuleDecl> _decls;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attribs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynAccess> _accessibility;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleOrNamespaceTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Ident> longId { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isRecursive { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceKind kind { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleDecl> decls { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attribs { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> accessibility { get; }
    [CompilationMappingAttribute("4", "0", "7")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "8")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceTrivia trivia { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynModuleOrNamespace")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleOrNamespace(FSharpList`1<Ident> _longId, bool _isRecursive, SynModuleOrNamespaceKind _kind, FSharpList`1<SynModuleDecl> _decls, PreXmlDoc _xmlDoc, FSharpList`1<SynAttributeList> _attribs, FSharpOption`1<SynAccess> _accessibility, Range _range, SynModuleOrNamespaceTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynModuleOrNamespace NewSynModuleOrNamespace(FSharpList`1<Ident> _longId, bool _isRecursive, SynModuleOrNamespaceKind _kind, FSharpList`1<SynModuleDecl> _decls, PreXmlDoc _xmlDoc, FSharpList`1<SynAttributeList> _attribs, FSharpOption`1<SynAccess> _accessibility, Range _range, SynModuleOrNamespaceTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Ident> get_longId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isRecursive();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceKind get_kind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleDecl> get_decls();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attribs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> get_accessibility();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[StructAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynModuleOrNamespaceKind : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynModuleOrNamespaceKind NamedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynModuleOrNamespaceKind AnonModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnonModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynModuleOrNamespaceKind DeclaredNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDeclaredNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynModuleOrNamespaceKind GlobalNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGlobalNamespace { get; }
    public bool IsModule { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynModuleOrNamespaceKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleOrNamespaceKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynModuleOrNamespaceKind get_NamedModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamedModule();
    [CompilationMappingAttribute("8", "1")]
public static SynModuleOrNamespaceKind get_AnonModule();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnonModule();
    [CompilationMappingAttribute("8", "2")]
public static SynModuleOrNamespaceKind get_DeclaredNamespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDeclaredNamespace();
    [CompilationMappingAttribute("8", "3")]
public static SynModuleOrNamespaceKind get_GlobalNamespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGlobalNamespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SynModuleOrNamespaceKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public bool get_IsModule();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SynModuleOrNamespaceKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynModuleOrNamespaceSig : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Ident> _longId;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isRecursive;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleOrNamespaceKind _kind;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynModuleSigDecl> _decls;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attribs;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynAccess> _accessibility;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleOrNamespaceSigTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Ident> longId { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isRecursive { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceKind kind { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleSigDecl> decls { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attribs { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> accessibility { get; }
    [CompilationMappingAttribute("4", "0", "7")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "8")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceSigTrivia trivia { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynModuleOrNamespaceSig")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleOrNamespaceSig(FSharpList`1<Ident> _longId, bool _isRecursive, SynModuleOrNamespaceKind _kind, FSharpList`1<SynModuleSigDecl> _decls, PreXmlDoc _xmlDoc, FSharpList`1<SynAttributeList> _attribs, FSharpOption`1<SynAccess> _accessibility, Range _range, SynModuleOrNamespaceSigTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynModuleOrNamespaceSig NewSynModuleOrNamespaceSig(FSharpList`1<Ident> _longId, bool _isRecursive, SynModuleOrNamespaceKind _kind, FSharpList`1<SynModuleSigDecl> _decls, PreXmlDoc _xmlDoc, FSharpList`1<SynAttributeList> _attribs, FSharpOption`1<SynAccess> _accessibility, Range _range, SynModuleOrNamespaceSigTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Ident> get_longId();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isRecursive();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceKind get_kind();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynModuleSigDecl> get_decls();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attribs();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> get_accessibility();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceSigTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynModuleSigDecl : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleAbbrev { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNestedModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypes { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashDirective { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespaceFragment { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynModuleSigDecl")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynModuleSigDecl(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynModuleSigDecl NewModuleAbbrev(Ident _ident, FSharpList`1<Ident> _longId, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleAbbrev();
    [CompilationMappingAttribute("8", "1")]
public static SynModuleSigDecl NewNestedModule(SynComponentInfo _moduleInfo, bool _isRecursive, FSharpList`1<SynModuleSigDecl> _moduleDecls, Range _range, SynModuleSigDeclNestedModuleTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNestedModule();
    [CompilationMappingAttribute("8", "2")]
public static SynModuleSigDecl NewVal(SynValSig _valSig, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVal();
    [CompilationMappingAttribute("8", "3")]
public static SynModuleSigDecl NewTypes(FSharpList`1<SynTypeDefnSig> _types, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypes();
    [CompilationMappingAttribute("8", "4")]
public static SynModuleSigDecl NewException(SynExceptionSig _exnSig, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "5")]
public static SynModuleSigDecl NewOpen(SynOpenDeclTarget _target, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpen();
    [CompilationMappingAttribute("8", "6")]
public static SynModuleSigDecl NewHashDirective(ParsedHashDirective _hashDirective, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashDirective();
    [CompilationMappingAttribute("8", "7")]
public static SynModuleSigDecl NewNamespaceFragment(SynModuleOrNamespaceSig item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespaceFragment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynOpenDeclTarget : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleOrNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynOpenDeclTarget NewModuleOrNamespace(SynLongIdent _longId, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleOrNamespace();
    [CompilationMappingAttribute("8", "1")]
public static SynOpenDeclTarget NewType(SynType _typeName, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynPat : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConst { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWild { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTyped { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAttrib { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsListCons { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnds { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLongIdent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTuple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArrayOrList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOptionalVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIsInst { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsQuoteExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInstanceMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFromParseError { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynPat")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynPat(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynPat NewConst(SynConst _constant, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConst();
    [CompilationMappingAttribute("8", "1")]
public static SynPat NewWild(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWild();
    [CompilationMappingAttribute("8", "2")]
public static SynPat NewNamed(SynIdent _ident, bool _isThisVal, FSharpOption`1<SynAccess> _accessibility, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamed();
    [CompilationMappingAttribute("8", "3")]
public static SynPat NewTyped(SynPat _pat, SynType _targetType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTyped();
    [CompilationMappingAttribute("8", "4")]
public static SynPat NewAttrib(SynPat _pat, FSharpList`1<SynAttributeList> _attributes, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAttrib();
    [CompilationMappingAttribute("8", "5")]
public static SynPat NewOr(SynPat _lhsPat, SynPat _rhsPat, Range _range, SynPatOrTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOr();
    [CompilationMappingAttribute("8", "6")]
public static SynPat NewListCons(SynPat _lhsPat, SynPat _rhsPat, Range _range, SynPatListConsTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsListCons();
    [CompilationMappingAttribute("8", "7")]
public static SynPat NewAnds(FSharpList`1<SynPat> _pats, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnds();
    [CompilationMappingAttribute("8", "8")]
public static SynPat NewAs(SynPat _lhsPat, SynPat _rhsPat, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAs();
    [CompilationMappingAttribute("8", "9")]
public static SynPat NewLongIdent(SynLongIdent _longDotId, FSharpOption`1<Ident> _extraId, FSharpOption`1<SynValTyparDecls> _typarDecls, SynArgPats _argPats, FSharpOption`1<SynAccess> _accessibility, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLongIdent();
    [CompilationMappingAttribute("8", "10")]
public static SynPat NewTuple(bool _isStruct, FSharpList`1<SynPat> _elementPats, FSharpList`1<Range> _commaRanges, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTuple();
    [CompilationMappingAttribute("8", "11")]
public static SynPat NewParen(SynPat _pat, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParen();
    [CompilationMappingAttribute("8", "12")]
public static SynPat NewArrayOrList(bool _isArray, FSharpList`1<SynPat> _elementPats, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArrayOrList();
    [CompilationMappingAttribute("8", "13")]
public static SynPat NewRecord(FSharpList`1<Tuple`3<Tuple`2<FSharpList`1<Ident>, Ident>, FSharpOption`1<Range>, SynPat>> _fieldPats, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute("8", "14")]
public static SynPat NewNull(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNull();
    [CompilationMappingAttribute("8", "15")]
public static SynPat NewOptionalVal(Ident _ident, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOptionalVal();
    [CompilationMappingAttribute("8", "16")]
public static SynPat NewIsInst(SynType _pat, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIsInst();
    [CompilationMappingAttribute("8", "17")]
public static SynPat NewQuoteExpr(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsQuoteExpr();
    [CompilationMappingAttribute("8", "18")]
public static SynPat NewInstanceMember(Ident _thisId, Ident _memberId, FSharpOption`1<Ident> _toolingId, FSharpOption`1<SynAccess> _accessibility, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInstanceMember();
    [CompilationMappingAttribute("8", "19")]
public static SynPat NewFromParseError(SynPat _pat, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFromParseError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynRationalConst : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInteger { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRational { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParen { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynRationalConst")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynRationalConst(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynRationalConst NewInteger(int _value, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInteger();
    [CompilationMappingAttribute("8", "1")]
public static SynRationalConst NewRational(int _numerator, Range _numeratorRange, Range _divRange, int _denominator, Range _denominatorRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRational();
    [CompilationMappingAttribute("8", "2")]
public static SynRationalConst NewNegate(SynRationalConst _rationalConst, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNegate();
    [CompilationMappingAttribute("8", "3")]
public static SynRationalConst NewParen(SynRationalConst _rationalConst, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynReturnInfo : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Tuple`2<SynType, SynArgInfo> _returnType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<SynType, SynArgInfo> returnType { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynReturnInfo")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynReturnInfo(Tuple`2<SynType, SynArgInfo> _returnType, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static SynReturnInfo NewSynReturnInfo(Tuple`2<SynType, SynArgInfo> _returnType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Tuple`2<SynType, SynArgInfo> get_returnType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynSimplePat : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsId { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTyped { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAttrib { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynSimplePat NewId(Ident _ident, FSharpOption`1<FSharpRef`1<SynSimplePatAlternativeIdInfo>> _altNameRefCell, bool _isCompilerGenerated, bool _isThisVal, bool _isOptional, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsId();
    [CompilationMappingAttribute("8", "1")]
public static SynSimplePat NewTyped(SynSimplePat _pat, SynType _targetType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTyped();
    [CompilationMappingAttribute("8", "2")]
public static SynSimplePat NewAttrib(SynSimplePat _pat, FSharpList`1<SynAttributeList> _attributes, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAttrib();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynSimplePatAlternativeIdInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUndecided { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDecided { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynSimplePatAlternativeIdInfo NewUndecided(Ident item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUndecided();
    [CompilationMappingAttribute("8", "1")]
public static SynSimplePatAlternativeIdInfo NewDecided(Ident item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDecided();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynSimplePats : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynSimplePat> _pats;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<Range> _commaRanges;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynSimplePat> pats { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Range> commaRanges { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynSimplePats")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynSimplePats(FSharpList`1<SynSimplePat> _pats, FSharpList`1<Range> _commaRanges, Range _range);
    [CompilationMappingAttribute("8", "0")]
public static SynSimplePats NewSimplePats(FSharpList`1<SynSimplePat> _pats, FSharpList`1<Range> _commaRanges, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynSimplePat> get_pats();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Range> get_commaRanges();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynStaticOptimizationConstraint : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhenTyparTyconEqualsTycon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhenTyparIsStruct { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynStaticOptimizationConstraint NewWhenTyparTyconEqualsTycon(SynTypar _typar, SynType _rhsType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhenTyparTyconEqualsTycon();
    [CompilationMappingAttribute("8", "1")]
public static SynStaticOptimizationConstraint NewWhenTyparIsStruct(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhenTyparIsStruct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[StructAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynStringKind : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynStringKind Regular { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRegular { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynStringKind Verbatim { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVerbatim { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynStringKind TripleQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTripleQuote { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynStringKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynStringKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynStringKind get_Regular();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRegular();
    [CompilationMappingAttribute("8", "1")]
public static SynStringKind get_Verbatim();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVerbatim();
    [CompilationMappingAttribute("8", "2")]
public static SynStringKind get_TripleQuote();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTripleQuote();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(SynStringKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SynStringKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SyntaxNode : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynPat { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynModuleOrNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynTypeDefn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynMemberDefn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynMatchClause { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynBinding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynModuleOrNamespaceSig { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynModuleSigDecl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynValSig { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynTypeDefnSig { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynMemberSig { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SyntaxNode")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SyntaxNode(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SyntaxNode NewSynPat(SynPat item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynPat();
    [CompilationMappingAttribute("8", "1")]
public static SyntaxNode NewSynType(SynType item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynType();
    [CompilationMappingAttribute("8", "2")]
public static SyntaxNode NewSynExpr(SynExpr item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynExpr();
    [CompilationMappingAttribute("8", "3")]
public static SyntaxNode NewSynModule(SynModuleDecl item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynModule();
    [CompilationMappingAttribute("8", "4")]
public static SyntaxNode NewSynModuleOrNamespace(SynModuleOrNamespace item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynModuleOrNamespace();
    [CompilationMappingAttribute("8", "5")]
public static SyntaxNode NewSynTypeDefn(SynTypeDefn item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynTypeDefn();
    [CompilationMappingAttribute("8", "6")]
public static SyntaxNode NewSynMemberDefn(SynMemberDefn item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynMemberDefn();
    [CompilationMappingAttribute("8", "7")]
public static SyntaxNode NewSynMatchClause(SynMatchClause item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynMatchClause();
    [CompilationMappingAttribute("8", "8")]
public static SyntaxNode NewSynBinding(SynBinding item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynBinding();
    [CompilationMappingAttribute("8", "9")]
public static SyntaxNode NewSynModuleOrNamespaceSig(SynModuleOrNamespaceSig item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynModuleOrNamespaceSig();
    [CompilationMappingAttribute("8", "10")]
public static SyntaxNode NewSynModuleSigDecl(SynModuleSigDecl item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynModuleSigDecl();
    [CompilationMappingAttribute("8", "11")]
public static SyntaxNode NewSynValSig(SynValSig item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynValSig();
    [CompilationMappingAttribute("8", "12")]
public static SyntaxNode NewSynTypeDefnSig(SynTypeDefnSig item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynTypeDefnSig();
    [CompilationMappingAttribute("8", "13")]
public static SyntaxNode NewSynMemberSig(SynMemberSig item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynMemberSig();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Syntax.SyntaxTraversal : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool rangeContainsPosLeftEdgeInclusive(Range m1, Position p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool rangeContainsPosEdgesExclusive(Range m1, Position p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool rangeContainsPosLeftEdgeExclusiveAndRightEdgeInclusive(Range m1, Position p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<b, FSharpFunc`2<Unit, c>> dive(a node, b range, FSharpFunc`2<a, c> project);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<a> pick$cont@247(Position pos, FSharpList`1<Tuple`2<Range, FSharpFunc`2<Unit, FSharpOption`1<a>>>> diveResults, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> pick(Position pos, Range outerRange, object debugObj, FSharpList`1<Tuple`2<Range, FSharpFunc`2<Unit, FSharpOption`1<a>>>> diveResults);
    internal static FSharpFunc`2<FSharpList`1<Tuple`2<Range, FSharpFunc`2<Unit, FSharpOption`1<b>>>>, FSharpOption`1<b>> pick@303-2(Position pos, Range x, a debugObj);
    internal static FSharpFunc`2<SynModuleDecl, FSharpOption`1<T>> traverseSynModuleDecl@305(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath);
    internal static FSharpOption`1<T> traverseSynModuleOrNamespace@338(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynModuleOrNamespace mors);
    internal static FSharpOption`1<T> diveIntoSeparator@424(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpList`1<SyntaxNode> path, int offsideColumn, FSharpOption`1<Position> scPosOpt, FSharpOption`1<SynExpr> copyOpt);
    internal static FSharpOption`1<T> traverseSynExpr@348(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynExpr expr);
    internal static FSharpOption`1<T> traversePat@710(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynPat pat);
    internal static FSharpOption`1<T> traverseSynSimplePats@738(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, FSharpList`1<SynSimplePat> pats);
    internal static FSharpOption`1<T> traverseSynType@749(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynType _arg1);
    internal static FSharpFunc`2<FSharpList`1<SynMemberDefn>, IEnumerable`1<Tuple`2<Range, FSharpFunc`2<Unit, FSharpOption`1<T>>>>> normalizeMembersToDealWithPeculiaritiesOfGettersAndSetters@777(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> path, FSharpFunc`2<Tuple`2<SynType, Range>, FSharpOption`1<T>> traverseInherit);
    internal static FSharpOption`1<T> traverseSynTypeDefn@794(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynTypeDefn tydef);
    internal static FSharpOption`1<T> traverseRecordDefn@835(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> path, FSharpList`1<SynField> fields, Range m);
    internal static FSharpOption`1<T> traverseEnumDefn@840(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> path, FSharpList`1<SynEnumCase> cases, Range m);
    internal static FSharpOption`1<T> traverseUnionDefn@845(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> path, FSharpList`1<SynUnionCase> cases, Range m);
    internal static FSharpFunc`2<object, FSharpFunc`2<FSharpList`1<Tuple`2<Range, FSharpFunc`2<Unit, FSharpOption`1<a>>>>, FSharpOption`1<a>>> pick@860-5(Position pos, SynMemberDefn m);
    internal static FSharpOption`1<T> traverseSynMemberDefn@859(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> path, FSharpFunc`2<Tuple`2<SynType, Range>, FSharpOption`1<T>> traverseInherit, SynMemberDefn m);
    internal static FSharpFunc`2<SynMatchClause, FSharpOption`1<T>> traverseSynMatchClause@919(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath);
    internal static FSharpOption`1<T> traverseSynBinding@937(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynBinding b);
    internal static FSharpList`1<Tuple`2<Range, FSharpFunc`2<Unit, FSharpOption`1<T>>>> attributeApplicationDives@952(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, FSharpList`1<SynAttributeList> attributes);
    internal static FSharpOption`1<T> traverseSynModuleOrNamespaceSig@956(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynModuleOrNamespaceSig mors);
    internal static FSharpFunc`2<SynModuleSigDecl, FSharpOption`1<T>> traverseSynModuleSigDecl@966(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath);
    internal static FSharpOption`1<T> traverseSynValSig@992(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynValSig valSig);
    internal static FSharpOption`1<T> traverseSynTypeDefnSig@1007(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> origPath, SynTypeDefnSig tydef);
    internal static FSharpFunc`2<SynMemberSig, FSharpOption`1<T>> traverseSynMemberSig@1040(SyntaxVisitorBase`1<T> visitor, Position pos, FSharpTypeFunc pick, FSharpList`1<SyntaxNode> path);
    public static FSharpOption`1<T> Traverse(Position pos, ParsedInput parseTree, SyntaxVisitorBase`1<T> visitor);
}
[AbstractClassAttribute]
[CompilationMappingAttribute("3")]
public abstract class FSharp.Compiler.Syntax.SyntaxVisitorBase`1 : object {
    public virtual FSharpOption`1<T> VisitExpr(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynExpr, FSharpOption`1<T>> traverseSynExpr, FSharpFunc`2<SynExpr, FSharpOption`1<T>> defaultTraverse, SynExpr synExpr);
    public virtual FSharpOption`1<T> VisitTypeAbbrev(FSharpList`1<SyntaxNode> path, SynType synType, Range range);
    public virtual FSharpOption`1<T> VisitImplicitInherit(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynExpr, FSharpOption`1<T>> defaultTraverse, SynType inheritedType, SynExpr synArgs, Range range);
    public virtual FSharpOption`1<T> VisitModuleDecl(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynModuleDecl, FSharpOption`1<T>> defaultTraverse, SynModuleDecl synModuleDecl);
    public virtual FSharpOption`1<T> VisitBinding(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynBinding, FSharpOption`1<T>> defaultTraverse, SynBinding synBinding);
    public virtual FSharpOption`1<T> VisitMatchClause(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynMatchClause, FSharpOption`1<T>> defaultTraverse, SynMatchClause matchClause);
    public virtual FSharpOption`1<T> VisitInheritSynMemberDefn(FSharpList`1<SyntaxNode> path, SynComponentInfo componentInfo, SynTypeDefnKind typeDefnKind, SynType synType, FSharpList`1<SynMemberDefn> members, Range range);
    public virtual FSharpOption`1<T> VisitRecordDefn(FSharpList`1<SyntaxNode> path, FSharpList`1<SynField> fields, Range range);
    public virtual FSharpOption`1<T> VisitUnionDefn(FSharpList`1<SyntaxNode> path, FSharpList`1<SynUnionCase> cases, Range range);
    public virtual FSharpOption`1<T> VisitEnumDefn(FSharpList`1<SyntaxNode> path, FSharpList`1<SynEnumCase> cases, Range range);
    public virtual FSharpOption`1<T> VisitInterfaceSynMemberDefnType(FSharpList`1<SyntaxNode> path, SynType synType);
    public virtual FSharpOption`1<T> VisitRecordField(FSharpList`1<SyntaxNode> path, FSharpOption`1<SynExpr> copyOpt, FSharpOption`1<SynLongIdent> recordField);
    public virtual FSharpOption`1<T> VisitHashDirective(FSharpList`1<SyntaxNode> path, ParsedHashDirective hashDirective, Range range);
    public virtual FSharpOption`1<T> VisitModuleOrNamespace(FSharpList`1<SyntaxNode> path, SynModuleOrNamespace synModuleOrNamespace);
    public virtual FSharpOption`1<T> VisitComponentInfo(FSharpList`1<SyntaxNode> path, SynComponentInfo synComponentInfo);
    public virtual FSharpOption`1<T> VisitLetOrUse(FSharpList`1<SyntaxNode> path, bool isRecursive, FSharpFunc`2<SynBinding, FSharpOption`1<T>> defaultTraverse, FSharpList`1<SynBinding> bindings, Range range);
    public virtual FSharpOption`1<T> VisitSimplePats(FSharpList`1<SyntaxNode> path, FSharpList`1<SynSimplePat> synPats);
    public virtual FSharpOption`1<T> VisitPat(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynPat, FSharpOption`1<T>> defaultTraverse, SynPat synPat);
    public virtual FSharpOption`1<T> VisitType(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynType, FSharpOption`1<T>> defaultTraverse, SynType synType);
    public virtual FSharpOption`1<T> VisitAttributeApplication(FSharpList`1<SyntaxNode> path, SynAttributeList attributes);
    public virtual FSharpOption`1<T> VisitModuleOrNamespaceSig(FSharpList`1<SyntaxNode> path, SynModuleOrNamespaceSig synModuleOrNamespaceSig);
    public virtual FSharpOption`1<T> VisitModuleSigDecl(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynModuleSigDecl, FSharpOption`1<T>> defaultTraverse, SynModuleSigDecl synModuleSigDecl);
    public virtual FSharpOption`1<T> VisitValSig(FSharpList`1<SyntaxNode> path, FSharpFunc`2<SynValSig, FSharpOption`1<T>> defaultTraverse, SynValSig valSig);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynTupleTypeSegment : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSlash { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynTupleTypeSegment NewType(SynType _typeName);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "1")]
public static SynTupleTypeSegment NewStar(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStar();
    [CompilationMappingAttribute("8", "2")]
public static SynTupleTypeSegment NewSlash(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSlash();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynTypar : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Ident _ident;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TyparStaticReq _staticReq;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isCompGen;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Ident ident { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TyparStaticReq staticReq { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isCompGen { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynTypar")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypar(Ident _ident, TyparStaticReq _staticReq, bool _isCompGen);
    [CompilationMappingAttribute("8", "0")]
public static SynTypar NewSynTypar(Ident _ident, TyparStaticReq _staticReq, bool _isCompGen);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Ident get_ident();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public TyparStaticReq get_staticReq();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isCompGen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynTyparDecl : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypar _typar;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynType> _intersectionConstraints;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTyparDeclTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypar typar { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynType> intersectionConstraints { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTyparDeclTrivia trivia { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynTyparDecl")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTyparDecl(FSharpList`1<SynAttributeList> _attributes, SynTypar _typar, FSharpList`1<SynType> _intersectionConstraints, SynTyparDeclTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynTyparDecl NewSynTyparDecl(FSharpList`1<SynAttributeList> _attributes, SynTypar _typar, FSharpList`1<SynType> _intersectionConstraints, SynTyparDeclTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypar get_typar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynType> get_intersectionConstraints();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTyparDeclTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynTyparDecls : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPostfixList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPrefixList { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSinglePrefix { get; }
    public FSharpList`1<SynTyparDecl> TyparDecls { get; }
    public FSharpList`1<SynTypeConstraint> Constraints { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynTyparDecls NewPostfixList(FSharpList`1<SynTyparDecl> _decls, FSharpList`1<SynTypeConstraint> _constraints, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPostfixList();
    [CompilationMappingAttribute("8", "1")]
public static SynTyparDecls NewPrefixList(FSharpList`1<SynTyparDecl> _decls, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPrefixList();
    [CompilationMappingAttribute("8", "2")]
public static SynTyparDecls NewSinglePrefix(SynTyparDecl _decl, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSinglePrefix();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public FSharpList`1<SynTyparDecl> get_TyparDecls();
    public FSharpList`1<SynTypeConstraint> get_Constraints();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynType : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLongIdent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLongIdentApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTuple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnonRecd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFun { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWithGlobalConstraints { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashConstraint { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMeasurePower { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticConstant { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticConstantExpr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticConstantNamed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSignatureParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFromParseError { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIntersection { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynType")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynType(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynType NewLongIdent(SynLongIdent _longDotId);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLongIdent();
    [CompilationMappingAttribute("8", "1")]
public static SynType NewApp(SynType _typeName, FSharpOption`1<Range> _lessRange, FSharpList`1<SynType> _typeArgs, FSharpList`1<Range> _commaRanges, FSharpOption`1<Range> _greaterRange, bool _isPostfix, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsApp();
    [CompilationMappingAttribute("8", "2")]
public static SynType NewLongIdentApp(SynType _typeName, SynLongIdent _longDotId, FSharpOption`1<Range> _lessRange, FSharpList`1<SynType> _typeArgs, FSharpList`1<Range> _commaRanges, FSharpOption`1<Range> _greaterRange, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLongIdentApp();
    [CompilationMappingAttribute("8", "3")]
public static SynType NewTuple(bool _isStruct, FSharpList`1<SynTupleTypeSegment> _path, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTuple();
    [CompilationMappingAttribute("8", "4")]
public static SynType NewAnonRecd(bool _isStruct, FSharpList`1<Tuple`2<Ident, SynType>> _fields, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnonRecd();
    [CompilationMappingAttribute("8", "5")]
public static SynType NewArray(int _rank, SynType _elementType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsArray();
    [CompilationMappingAttribute("8", "6")]
public static SynType NewFun(SynType _argType, SynType _returnType, Range _range, SynTypeFunTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFun();
    [CompilationMappingAttribute("8", "7")]
public static SynType NewVar(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVar();
    [CompilationMappingAttribute("8", "8")]
public static SynType NewAnon(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnon();
    [CompilationMappingAttribute("8", "9")]
public static SynType NewWithGlobalConstraints(SynType _typeName, FSharpList`1<SynTypeConstraint> _constraints, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWithGlobalConstraints();
    [CompilationMappingAttribute("8", "10")]
public static SynType NewHashConstraint(SynType _innerType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashConstraint();
    [CompilationMappingAttribute("8", "11")]
public static SynType NewMeasurePower(SynType _baseMeasure, SynRationalConst _exponent, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMeasurePower();
    [CompilationMappingAttribute("8", "12")]
public static SynType NewStaticConstant(SynConst _constant, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticConstant();
    [CompilationMappingAttribute("8", "13")]
public static SynType NewStaticConstantExpr(SynExpr _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticConstantExpr();
    [CompilationMappingAttribute("8", "14")]
public static SynType NewStaticConstantNamed(SynType _ident, SynType _value, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticConstantNamed();
    [CompilationMappingAttribute("8", "15")]
public static SynType NewParen(SynType _innerType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParen();
    [CompilationMappingAttribute("8", "16")]
public static SynType NewSignatureParameter(FSharpList`1<SynAttributeList> _attributes, bool _optional, FSharpOption`1<Ident> _id, SynType _usedType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSignatureParameter();
    [CompilationMappingAttribute("8", "17")]
public static SynType NewOr(SynType _lhsType, SynType _rhsType, Range _range, SynTypeOrTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOr();
    [CompilationMappingAttribute("8", "18")]
public static SynType NewFromParseError(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFromParseError();
    [CompilationMappingAttribute("8", "19")]
public static SynType NewIntersection(FSharpOption`1<SynTypar> _typar, FSharpList`1<SynType> _types, Range _range, SynTyparDeclTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIntersection();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynTypeConstraint : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparIsValueType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparIsReferenceType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparIsUnmanaged { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparSupportsNull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparIsComparable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparIsEquatable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparDefaultsToType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparSubtypeOfType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparSupportsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparIsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereTyparIsDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhereSelfConstrained { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynTypeConstraint")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeConstraint(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynTypeConstraint NewWhereTyparIsValueType(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparIsValueType();
    [CompilationMappingAttribute("8", "1")]
public static SynTypeConstraint NewWhereTyparIsReferenceType(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparIsReferenceType();
    [CompilationMappingAttribute("8", "2")]
public static SynTypeConstraint NewWhereTyparIsUnmanaged(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparIsUnmanaged();
    [CompilationMappingAttribute("8", "3")]
public static SynTypeConstraint NewWhereTyparSupportsNull(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparSupportsNull();
    [CompilationMappingAttribute("8", "4")]
public static SynTypeConstraint NewWhereTyparIsComparable(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparIsComparable();
    [CompilationMappingAttribute("8", "5")]
public static SynTypeConstraint NewWhereTyparIsEquatable(SynTypar _typar, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparIsEquatable();
    [CompilationMappingAttribute("8", "6")]
public static SynTypeConstraint NewWhereTyparDefaultsToType(SynTypar _typar, SynType _typeName, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparDefaultsToType();
    [CompilationMappingAttribute("8", "7")]
public static SynTypeConstraint NewWhereTyparSubtypeOfType(SynTypar _typar, SynType _typeName, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparSubtypeOfType();
    [CompilationMappingAttribute("8", "8")]
public static SynTypeConstraint NewWhereTyparSupportsMember(SynType _typars, SynMemberSig _memberSig, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparSupportsMember();
    [CompilationMappingAttribute("8", "9")]
public static SynTypeConstraint NewWhereTyparIsEnum(SynTypar _typar, FSharpList`1<SynType> _typeArgs, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparIsEnum();
    [CompilationMappingAttribute("8", "10")]
public static SynTypeConstraint NewWhereTyparIsDelegate(SynTypar _typar, FSharpList`1<SynType> _typeArgs, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereTyparIsDelegate();
    [CompilationMappingAttribute("8", "11")]
public static SynTypeConstraint NewWhereSelfConstrained(SynType _selfConstraint, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhereSelfConstrained();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynTypeDefn : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynComponentInfo _typeInfo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefnRepr _typeRepr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynMemberDefn> _members;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynMemberDefn> _implicitConstructor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefnTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynComponentInfo typeInfo { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnRepr typeRepr { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberDefn> members { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynMemberDefn> implicitConstructor { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnTrivia trivia { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynTypeDefn")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefn(SynComponentInfo _typeInfo, SynTypeDefnRepr _typeRepr, FSharpList`1<SynMemberDefn> _members, FSharpOption`1<SynMemberDefn> _implicitConstructor, Range _range, SynTypeDefnTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynTypeDefn NewSynTypeDefn(SynComponentInfo _typeInfo, SynTypeDefnRepr _typeRepr, FSharpList`1<SynMemberDefn> _members, FSharpOption`1<SynMemberDefn> _implicitConstructor, Range _range, SynTypeDefnTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynComponentInfo get_typeInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnRepr get_typeRepr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberDefn> get_members();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynMemberDefn> get_implicitConstructor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynTypeDefnKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_Unspecified;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_Struct;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_Record;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_Union;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_Abbrev;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_Opaque;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnKind _unique_IL;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind Unspecified { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnspecified { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind Struct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStruct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind Record { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind Union { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind Abbrev { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAbbrev { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind Opaque { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpaque { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAugmentation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnKind IL { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIL { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDelegate { get; }
    private static SynTypeDefnKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynTypeDefnKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefnKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynTypeDefnKind get_Unspecified();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnspecified();
    [CompilationMappingAttribute("8", "1")]
public static SynTypeDefnKind get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "2")]
public static SynTypeDefnKind get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "3")]
public static SynTypeDefnKind get_Struct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStruct();
    [CompilationMappingAttribute("8", "4")]
public static SynTypeDefnKind get_Record();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute("8", "5")]
public static SynTypeDefnKind get_Union();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnion();
    [CompilationMappingAttribute("8", "6")]
public static SynTypeDefnKind get_Abbrev();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAbbrev();
    [CompilationMappingAttribute("8", "7")]
public static SynTypeDefnKind get_Opaque();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpaque();
    [CompilationMappingAttribute("8", "8")]
public static SynTypeDefnKind NewAugmentation(Range _withKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAugmentation();
    [CompilationMappingAttribute("8", "9")]
public static SynTypeDefnKind get_IL();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIL();
    [CompilationMappingAttribute("8", "10")]
public static SynTypeDefnKind NewDelegate(SynType _signature, SynValInfo _signatureInfo);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDelegate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynTypeDefnRepr : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsObjectModel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSimple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynTypeDefnRepr NewObjectModel(SynTypeDefnKind _kind, FSharpList`1<SynMemberDefn> _members, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsObjectModel();
    [CompilationMappingAttribute("8", "1")]
public static SynTypeDefnRepr NewSimple(SynTypeDefnSimpleRepr _simpleRepr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSimple();
    [CompilationMappingAttribute("8", "2")]
public static SynTypeDefnRepr NewException(SynExceptionDefnRepr _exnRepr);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynTypeDefnSig : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynComponentInfo _typeInfo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefnSigRepr _typeRepr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynMemberSig> _members;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefnSigTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynComponentInfo typeInfo { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnSigRepr typeRepr { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberSig> members { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnSigTrivia trivia { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynTypeDefnSig")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefnSig(SynComponentInfo _typeInfo, SynTypeDefnSigRepr _typeRepr, FSharpList`1<SynMemberSig> _members, Range _range, SynTypeDefnSigTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynTypeDefnSig NewSynTypeDefnSig(SynComponentInfo _typeInfo, SynTypeDefnSigRepr _typeRepr, FSharpList`1<SynMemberSig> _members, Range _range, SynTypeDefnSigTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynComponentInfo get_typeInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnSigRepr get_typeRepr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynMemberSig> get_members();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnSigTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynTypeDefnSigRepr : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsObjectModel { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSimple { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynTypeDefnSigRepr NewObjectModel(SynTypeDefnKind _kind, FSharpList`1<SynMemberSig> _memberSigs, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsObjectModel();
    [CompilationMappingAttribute("8", "1")]
public static SynTypeDefnSigRepr NewSimple(SynTypeDefnSimpleRepr _repr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSimple();
    [CompilationMappingAttribute("8", "2")]
public static SynTypeDefnSigRepr NewException(SynExceptionDefnRepr _repr);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGeneral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLibraryOnlyILAssembly { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeAbbrev { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.SynTypeDefnSimpleRepr")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefnSimpleRepr(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynTypeDefnSimpleRepr NewUnion(FSharpOption`1<SynAccess> _accessibility, FSharpList`1<SynUnionCase> _unionCases, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnion();
    [CompilationMappingAttribute("8", "1")]
public static SynTypeDefnSimpleRepr NewEnum(FSharpList`1<SynEnumCase> _cases, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnum();
    [CompilationMappingAttribute("8", "2")]
public static SynTypeDefnSimpleRepr NewRecord(FSharpOption`1<SynAccess> _accessibility, FSharpList`1<SynField> _recordFields, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute("8", "3")]
public static SynTypeDefnSimpleRepr NewGeneral(SynTypeDefnKind _kind, FSharpList`1<Tuple`3<SynType, Range, FSharpOption`1<Ident>>> _inherits, FSharpList`1<Tuple`2<SynValSig, SynMemberFlags>> _slotsigs, FSharpList`1<SynField> _fields, bool _isConcrete, bool _isIncrClass, FSharpOption`1<SynSimplePats> _implicitCtorSynPats, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGeneral();
    [CompilationMappingAttribute("8", "4")]
public static SynTypeDefnSimpleRepr NewLibraryOnlyILAssembly(object _ilType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLibraryOnlyILAssembly();
    [CompilationMappingAttribute("8", "5")]
public static SynTypeDefnSimpleRepr NewTypeAbbrev(ParserDetail _detail, SynType _rhsType, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeAbbrev();
    [CompilationMappingAttribute("8", "6")]
public static SynTypeDefnSimpleRepr NewNone(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilationMappingAttribute("8", "7")]
public static SynTypeDefnSimpleRepr NewException(SynExceptionDefnRepr _exnRepr);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynUnionCase : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynIdent _ident;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynUnionCaseKind _caseType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynAccess> _accessibility;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynUnionCaseTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynIdent ident { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynUnionCaseKind caseType { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> accessibility { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynUnionCaseTrivia trivia { get; }
    public Range Range { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynUnionCase")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynUnionCase(FSharpList`1<SynAttributeList> _attributes, SynIdent _ident, SynUnionCaseKind _caseType, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, Range _range, SynUnionCaseTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynUnionCase NewSynUnionCase(FSharpList`1<SynAttributeList> _attributes, SynIdent _ident, SynUnionCaseKind _caseType, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, Range _range, SynUnionCaseTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynIdent get_ident();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynUnionCaseKind get_caseType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> get_accessibility();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynUnionCaseTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.Syntax.SynUnionCaseKind : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFields { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFullType { get; }
    [CompilationMappingAttribute("8", "0")]
public static SynUnionCaseKind NewFields(FSharpList`1<SynField> _cases);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFields();
    [CompilationMappingAttribute("8", "1")]
public static SynUnionCaseKind NewFullType(SynType _fullType, SynValInfo _fullTypeInfo);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFullType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynValData : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynMemberFlags> _memberFlags;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValInfo _valInfo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Ident> _thisIdOpt;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<Ident> _transformedFromProperty;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynMemberFlags> memberFlags { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValInfo valInfo { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> thisIdOpt { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> transformedFromProperty { get; }
    public SynValInfo SynValInfo { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynValData")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValData(FSharpOption`1<SynMemberFlags> _memberFlags, SynValInfo _valInfo, FSharpOption`1<Ident> _thisIdOpt, FSharpOption`1<Ident> _transformedFromProperty);
    [CompilationMappingAttribute("8", "0")]
public static SynValData NewSynValData(FSharpOption`1<SynMemberFlags> _memberFlags, SynValInfo _valInfo, FSharpOption`1<Ident> _thisIdOpt, FSharpOption`1<Ident> _transformedFromProperty);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynMemberFlags> get_memberFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValInfo get_valInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> get_thisIdOpt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Ident> get_transformedFromProperty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public SynValInfo get_SynValInfo();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynValInfo : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<FSharpList`1<SynArgInfo>> _curriedArgInfos;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynArgInfo _returnInfo;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FSharpList`1<SynArgInfo>> curriedArgInfos { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynArgInfo returnInfo { get; }
    public FSharpList`1<FSharpList`1<SynArgInfo>> CurriedArgInfos { get; }
    public FSharpList`1<string> ArgNames { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynValInfo")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValInfo(FSharpList`1<FSharpList`1<SynArgInfo>> _curriedArgInfos, SynArgInfo _returnInfo);
    [CompilationMappingAttribute("8", "0")]
public static SynValInfo NewSynValInfo(FSharpList`1<FSharpList`1<SynArgInfo>> _curriedArgInfos, SynArgInfo _returnInfo);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<FSharpList`1<SynArgInfo>> get_curriedArgInfos();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynArgInfo get_returnInfo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public FSharpList`1<FSharpList`1<SynArgInfo>> get_CurriedArgInfos();
    public FSharpList`1<string> get_ArgNames();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynValSig : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<SynAttributeList> _attributes;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynIdent _ident;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValTyparDecls _explicitTypeParams;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynType _synType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValInfo _arity;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isInline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _isMutable;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc _xmlDoc;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynAccess> _accessibility;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynExpr> _synExpr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range _range;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValSigTrivia _trivia;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> attributes { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynIdent ident { get; }
    [CompilationMappingAttribute("4", "0", "2")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValTyparDecls explicitTypeParams { get; }
    [CompilationMappingAttribute("4", "0", "3")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynType synType { get; }
    [CompilationMappingAttribute("4", "0", "4")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValInfo arity { get; }
    [CompilationMappingAttribute("4", "0", "5")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isInline { get; }
    [CompilationMappingAttribute("4", "0", "6")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool isMutable { get; }
    [CompilationMappingAttribute("4", "0", "7")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc xmlDoc { get; }
    [CompilationMappingAttribute("4", "0", "8")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> accessibility { get; }
    [CompilationMappingAttribute("4", "0", "9")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynExpr> synExpr { get; }
    [CompilationMappingAttribute("4", "0", "10")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range range { get; }
    [CompilationMappingAttribute("4", "0", "11")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValSigTrivia trivia { get; }
    public Range RangeOfId { get; }
    public SynValInfo SynInfo { get; }
    public SynType SynType { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynValSig")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValSig(FSharpList`1<SynAttributeList> _attributes, SynIdent _ident, SynValTyparDecls _explicitTypeParams, SynType _synType, SynValInfo _arity, bool _isInline, bool _isMutable, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, FSharpOption`1<SynExpr> _synExpr, Range _range, SynValSigTrivia _trivia);
    [CompilationMappingAttribute("8", "0")]
public static SynValSig NewSynValSig(FSharpList`1<SynAttributeList> _attributes, SynIdent _ident, SynValTyparDecls _explicitTypeParams, SynType _synType, SynValInfo _arity, bool _isInline, bool _isMutable, PreXmlDoc _xmlDoc, FSharpOption`1<SynAccess> _accessibility, FSharpOption`1<SynExpr> _synExpr, Range _range, SynValSigTrivia _trivia);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<SynAttributeList> get_attributes();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynIdent get_ident();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValTyparDecls get_explicitTypeParams();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynType get_synType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValInfo get_arity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isInline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_isMutable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public PreXmlDoc get_xmlDoc();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynAccess> get_accessibility();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynExpr> get_synExpr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_range();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynValSigTrivia get_trivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_RangeOfId();
    public SynValInfo get_SynInfo();
    public SynType get_SynType();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.SynValTyparDecls : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpOption`1<SynTyparDecls> _typars;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool _canInfer;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynTyparDecls> typars { get; }
    [CompilationMappingAttribute("4", "0", "1")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool canInfer { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Syntax.SynValTyparDecls")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynValTyparDecls(FSharpOption`1<SynTyparDecls> _typars, bool _canInfer);
    [CompilationMappingAttribute("8", "0")]
public static SynValTyparDecls NewSynValTyparDecls(FSharpOption`1<SynTyparDecls> _typars, bool _canInfer);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynTyparDecls> get_typars();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_canInfer();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Syntax.TyparStaticReq : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TyparStaticReq _unique_None;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TyparStaticReq _unique_HeadType;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TyparStaticReq None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TyparStaticReq HeadType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHeadType { get; }
    private static TyparStaticReq();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Syntax.TyparStaticReq")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TyparStaticReq(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static TyparStaticReq get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilationMappingAttribute("8", "1")]
public static TyparStaticReq get_HeadType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHeadType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(TyparStaticReq obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TyparStaticReq obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.SyntaxTreeOps : object {
    [CompilationMappingAttribute("9")]
internal static string opNameParenGet { get; }
    [CompilationMappingAttribute("9")]
internal static string opNameQMark { get; }
    [CompilationMappingAttribute("9")]
internal static SynMemberFlags CtorMemberFlags { get; }
    [CompilationMappingAttribute("9")]
internal static SynMemberFlags ClassCtorMemberFlags { get; }
    [CompilationMappingAttribute("9")]
internal static SynValTyparDecls inferredTyparDecls { get; }
    [CompilationMappingAttribute("9")]
internal static SynValTyparDecls noInferredTypars { get; }
    internal static Ident ident(string s, Range r);
    internal static string textOfId(Ident id);
    internal static FSharpList`1<string> pathOfLid(FSharpList`1<Ident> lid);
    internal static String[] arrPathOfLid(FSharpList`1<Ident> lid);
    internal static string textOfPath(IEnumerable`1<string> path);
    internal static string textOfLid(FSharpList`1<Ident> lid);
    internal static Range rangeOfLid(FSharpList`1<Ident> lid);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Ident mkSynId(Range m, string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Ident> pathToSynLid(Range m, FSharpList`1<string> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynIdGet(Range m, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynLidGet(Range m, FSharpList`1<string> path, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynIdGetWithAlt(Range m, Ident id, FSharpOption`1<FSharpRef`1<SynSimplePatAlternativeIdInfo>> altInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynSimplePat mkSynSimplePatVar(bool isOpt, Ident id);
    internal static SynSimplePat mkSynCompGenSimplePatVar(Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr pushUnaryArg(SynExpr expr, Ident arg);
    internal static FSharpOption`1<Ident> |SynSingleIdent|_|(SynLongIdent x);
    internal static FSharpOption`1<Tuple`4<bool, SynLongIdent, FSharpOption`1<FSharpRef`1<SynSimplePatAlternativeIdInfo>>, Range>> |LongOrSingleIdent|_|(SynExpr inp);
    internal static FSharpOption`1<Ident> |SingleIdent|_|(SynExpr inp);
    internal static FSharpOption`1<Tuple`3<Ident, SynExpr, SynExpr>> |SynBinOp|_|(SynExpr input);
    internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |SynPipeRight|_|(SynExpr input);
    internal static FSharpOption`1<Tuple`3<SynExpr, SynExpr, SynExpr>> |SynPipeRight2|_|(SynExpr input);
    internal static FSharpOption`1<Tuple`4<SynExpr, SynExpr, SynExpr, SynExpr>> |SynPipeRight3|_|(SynExpr input);
    internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |SynAndAlso|_|(SynExpr input);
    internal static FSharpOption`1<Tuple`2<SynExpr, SynExpr>> |SynOrElse|_|(SynExpr input);
    internal static bool IsControlFlowExpression(SynExpr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsDebugPointBinding(SynPat synPat, SynExpr synExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range unionRangeWithXmlDoc(PreXmlDoc xmlDoc, Range range);
    internal static SynField mkSynAnonField(SynType ty, PreXmlDoc xmlDoc);
    internal static SynField mkSynNamedField(Ident ident, SynType ty, PreXmlDoc xmlDoc, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynPat mkSynPatVar(FSharpOption`1<SynAccess> vis, Ident id);
    internal static SynPat mkSynThisPatVar(Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynPat mkSynPatMaybeVar(SynLongIdent lidwd, FSharpOption`1<SynAccess> vis, Range m);
    internal static FSharpOption`1<SynPat> |SynPatForConstructorDecl|_|(SynPat x);
    internal static FSharpOption`1<Unit> |SynPatForNullaryArgs|_|(SynPat x);
    internal static SynExpr |SynExprErrorSkip|(SynExpr p);
    internal static FSharpOption`1<Tuple`4<SynExpr, Range, FSharpOption`1<Range>, Range>> |SynExprParen|_|(SynExpr e);
    internal static SynPat |SynPatErrorSkip|(SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SynSimplePat, FSharpOption`1<FSharpFunc`2<SynExpr, SynExpr>>> SimplePatOfPat(SynArgNameGenerator synArgNameGenerator, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a appFunOpt(FSharpOption`1<FSharpFunc`2<a, a>> funOpt, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpFunc`2<a, a>> composeFunOpt(FSharpOption`1<FSharpFunc`2<a, a>> funOpt1, FSharpOption`1<FSharpFunc`2<a, a>> funOpt2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SynSimplePats, FSharpOption`1<FSharpFunc`2<SynExpr, SynExpr>>> SimplePatsOfPat(SynArgNameGenerator synArgNameGenerator, SynPat p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SynSimplePats, SynExpr> PushPatternToExpr(SynArgNameGenerator synArgNameGenerator, bool isMember, SynPat pat, SynExpr rhs);
    internal static bool isSimplePattern(SynPat pat);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<SynSimplePats>, SynExpr> PushCurriedPatternsToExpr(SynArgNameGenerator synArgNameGenerator, Range wholem, bool isMember, FSharpList`1<SynPat> pats, FSharpOption`1<Range> arrow, SynExpr rhs);
    internal static string get_opNameParenGet();
    internal static string get_opNameQMark();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynOperator(Range opm, string oper);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynInfix(Range opm, SynExpr l, string oper, SynExpr r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynBifix(Range m, string oper, SynExpr x1, SynExpr x2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynTrifix(Range m, string oper, SynExpr x1, SynExpr x2, SynExpr x3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynPrefixPrim(Range opm, Range m, string oper, SynExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynPrefix(Range opm, Range m, string oper, SynExpr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Ident> mkSynCaseName(Range m, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynApp1(SynExpr f, SynExpr x1, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynApp2(SynExpr f, SynExpr x1, SynExpr x2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynApp3(SynExpr f, SynExpr x1, SynExpr x2, SynExpr x3, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynApp4(SynExpr f, SynExpr x1, SynExpr x2, SynExpr x3, SynExpr x4, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynApp5(SynExpr f, SynExpr x1, SynExpr x2, SynExpr x3, SynExpr x4, SynExpr x5, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynDotParenSet(Range m, SynExpr a, SynExpr b, SynExpr c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynDotBrackGet(Range m, Range mDot, SynExpr a, SynExpr b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynQMarkSet(Range m, SynExpr a, SynExpr b, SynExpr c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynDotParenGet(Range mLhs, Range mDot, SynExpr a, SynExpr b);
    internal static SynExpr mkSynUnit(Range m);
    internal static SynPat mkSynUnitPat(Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynDelay(Range m, SynExpr e);
    [CompilerGeneratedAttribute]
internal static SynExpr mkSynAssign$cont@483-1(SynExpr l, SynExpr r, Range m, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static SynExpr mkSynAssign$cont@483(SynExpr l, SynExpr r, Range m, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynAssign(SynExpr l, SynExpr r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynDot(Range mDot, Range m, SynExpr l, SynIdent r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynDotMissing(Range mDot, Range m, SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynExpr mkSynFunMatchLambdas(SynArgNameGenerator synArgNameGenerator, bool isMember, Range wholem, FSharpList`1<SynPat> ps, FSharpOption`1<Range> arrow, SynExpr e);
    internal static SynExpr arbExpr(string debugStr, Range range);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Range unionRangeWithListBy(FSharpFunc`2<a, Range> projectRangeFromThing, Range m, FSharpList`1<a> listOfThing);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<SynAttributeList> mkAttributeList(FSharpList`1<SynAttribute> attrs, Range range);
    internal static FSharpList`1<SynAttribute> ConcatAttributesLists(FSharpList`1<SynAttributeList> attrsLists);
    internal static FSharpList`1<SynAttribute> |Attributes|(FSharpList`1<SynAttributeList> synAttributes);
    internal static FSharpList`1<SynTyparDecl> |TyparDecls|(FSharpOption`1<SynTyparDecls> typarDecls);
    internal static Tuple`2<FSharpList`1<SynTyparDecl>, FSharpList`1<SynTypeConstraint>> |TyparsAndConstraints|(FSharpOption`1<SynTyparDecls> typarDecls);
    internal static Tuple`3<FSharpList`1<SynTyparDecl>, FSharpList`1<SynTypeConstraint>, bool> |ValTyparDecls|(SynValTyparDecls valTyparDecls);
    internal static Range rangeOfNonNilAttrs(FSharpList`1<SynAttributeList> attrs);
    internal static SynType stripParenTypes(SynType synType);
    internal static SynType |StripParenTypes|(SynType synType);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SynExpr, FSharpOption`1<SynBindingReturnInfo>> mkSynBindingRhs(FSharpList`1<Tuple`2<FSharpList`1<SynStaticOptimizationConstraint>, SynExpr>> staticOptimizations, SynExpr rhsExpr, Range mRhs, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>> retInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynBinding mkSynBinding(PreXmlDoc xmlDoc, SynPat headPat, FSharpOption`1<SynAccess> vis, bool isInline, bool isMutable, Range mBind, DebugPointAtBinding spBind, FSharpOption`1<Tuple`2<FSharpOption`1<Range>, SynReturnInfo>> retInfo, SynExpr origRhsExpr, Range mRhs, FSharpList`1<Tuple`2<FSharpList`1<SynStaticOptimizationConstraint>, SynExpr>> staticOptimizations, FSharpList`1<SynAttributeList> attrs, FSharpOption`1<SynMemberFlags> memberFlagsOpt, SynBindingTrivia trivia);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynBinding updatePropertyIdentInSynBinding(Ident propertyIdent, SynBinding _arg1);
    internal static SynMemberFlags NonVirtualMemberFlags(SynMemberKind k);
    internal static SynMemberFlags get_CtorMemberFlags();
    internal static SynMemberFlags get_ClassCtorMemberFlags();
    internal static SynMemberFlags OverrideMemberFlags(SynMemberKind k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynMemberFlags AbstractMemberFlags(bool isInstance, SynMemberKind k);
    internal static SynMemberFlags StaticMemberFlags(SynMemberKind k);
    internal static SynMemberFlags ImplementStaticMemberFlags(SynMemberKind k);
    internal static SynValTyparDecls get_inferredTyparDecls();
    internal static SynValTyparDecls get_noInferredTypars();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<SynBinding> unionBindingAndMembers(FSharpList`1<SynBinding> bindings, FSharpList`1<SynMemberDefn> members);
    internal static bool walkMatchClauses@827(FSharpFunc`2<SynBinding, bool> walkBind, FSharpList`1<SynMatchClause> cl);
    internal static bool walkExprOpt@831(FSharpFunc`2<SynBinding, bool> walkBind, FSharpOption`1<SynExpr> eOpt);
    internal static bool walkExpr@833(FSharpFunc`2<SynBinding, bool> walkBind, SynExpr e);
    internal static bool synExprContainsError(SynExpr inpExpr);
    internal static FSharpList`1<string> |ParsedHashDirectiveArguments|(FSharpList`1<ParsedHashDirectiveArgument> input);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SynLongIdent prependIdentInLongIdentWithTrivia(SynIdent ident, Range mDot, SynLongIdent lid);
    internal static SynExpr mkDynamicArgExpr(SynExpr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<SynPat>, FSharpList`1<Range>> normalizeTuplePat(FSharpList`1<SynPat> pats, FSharpList`1<Range> commas);
    internal static FSharpList`1<SynMemberDefn> desugarGetSetMembers(FSharpList`1<SynMemberDefn> memberDefns);
    internal static FSharpList`1<SynType> getTypeFromTuplePath(FSharpList`1<SynTupleTypeSegment> path);
    internal static FSharpOption`1<Tuple`3<int, SynType, Range>> |MultiDimensionArrayType|_|(SynType t);
    internal static a visit@1051(FSharpFunc`2<FSharpList`1<SynType>, a> continuation, SynType t);
    internal static FSharpList`1<SynType> |TypesForTypar|(SynType t);
}
[RequireQualifiedAccessAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SyntaxTrivia.CommentTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLineComment { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBlockComment { get; }
    [CompilationMappingAttribute("8", "0")]
public static CommentTrivia NewLineComment(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLineComment();
    [CompilationMappingAttribute("8", "1")]
public static CommentTrivia NewBlockComment(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBlockComment();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SyntaxTrivia.ConditionalDirectiveTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEndIf { get; }
    [CompilationMappingAttribute("8", "0")]
public static ConditionalDirectiveTrivia NewIf(IfDirectiveExpression _expr, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIf();
    [CompilationMappingAttribute("8", "1")]
public static ConditionalDirectiveTrivia NewElse(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsElse();
    [CompilationMappingAttribute("8", "2")]
public static ConditionalDirectiveTrivia NewEndIf(Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEndIf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SyntaxTrivia.GetSetKeywords : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGetSet { get; }
    public Range Range { get; }
    [CompilationMappingAttribute("8", "0")]
public static GetSetKeywords NewGet(Range item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGet();
    [CompilationMappingAttribute("8", "1")]
public static GetSetKeywords NewSet(Range item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSet();
    [CompilationMappingAttribute("8", "2")]
public static GetSetKeywords NewGetSet(Range _get, Range _set);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGetSet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[RequireQualifiedAccessAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SyntaxTrivia.IdentTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOriginalNotation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOriginalNotationWithParen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHasParenthesis { get; }
    [CompilationMappingAttribute("8", "0")]
public static IdentTrivia NewOriginalNotation(string _text);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOriginalNotation();
    [CompilationMappingAttribute("8", "1")]
public static IdentTrivia NewOriginalNotationWithParen(Range _leftParenRange, string _text, Range _rightParenRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOriginalNotationWithParen();
    [CompilationMappingAttribute("8", "2")]
public static IdentTrivia NewHasParenthesis(Range _leftParenRange, Range _rightParenRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHasParenthesis();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[RequireQualifiedAccessAttribute]
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SyntaxTrivia.IfDirectiveExpression : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIdent { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.SyntaxTrivia.IfDirectiveExpression")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IfDirectiveExpression(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static IfDirectiveExpression NewAnd(IfDirectiveExpression item1, IfDirectiveExpression item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnd();
    [CompilationMappingAttribute("8", "1")]
public static IfDirectiveExpression NewOr(IfDirectiveExpression item1, IfDirectiveExpression item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOr();
    [CompilationMappingAttribute("8", "2")]
public static IfDirectiveExpression NewNot(IfDirectiveExpression item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNot();
    [CompilationMappingAttribute("8", "3")]
public static IfDirectiveExpression NewIdent(string item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIdent();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.ParsedImplFileInputTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<ConditionalDirectiveTrivia> ConditionalDirectives@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<CommentTrivia> CodeComments@;
    [CompilationMappingAttribute("4", "0")]
public FSharpList`1<ConditionalDirectiveTrivia> ConditionalDirectives { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<CommentTrivia> CodeComments { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.ParsedImplFileInputTrivia")]
public ParsedImplFileInputTrivia(FSharpList`1<ConditionalDirectiveTrivia> conditionalDirectives, FSharpList`1<CommentTrivia> codeComments);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ConditionalDirectiveTrivia> get_ConditionalDirectives();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<CommentTrivia> get_CodeComments();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.ParsedSigFileInputTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<ConditionalDirectiveTrivia> ConditionalDirectives@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<CommentTrivia> CodeComments@;
    [CompilationMappingAttribute("4", "0")]
public FSharpList`1<ConditionalDirectiveTrivia> ConditionalDirectives { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpList`1<CommentTrivia> CodeComments { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.ParsedSigFileInputTrivia")]
public ParsedSigFileInputTrivia(FSharpList`1<ConditionalDirectiveTrivia> conditionalDirectives, FSharpList`1<CommentTrivia> codeComments);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<ConditionalDirectiveTrivia> get_ConditionalDirectives();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<CommentTrivia> get_CodeComments();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynArgPatsNamePatPairsTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range ParenRange@;
    [CompilationMappingAttribute("4", "0")]
public Range ParenRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynArgPatsNamePatPairsTrivia")]
public SynArgPatsNamePatPairsTrivia(Range parenRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_ParenRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynBindingReturnInfoTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> ColonRange@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> ColonRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynBindingReturnInfoTrivia")]
public SynBindingReturnInfoTrivia(FSharpOption`1<Range> colonRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_ColonRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynBindingTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynLeadingKeyword LeadingKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> InlineKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> EqualsRange@;
    [CompilationMappingAttribute("4", "0")]
public SynLeadingKeyword LeadingKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> InlineKeyword { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<Range> EqualsRange { get; }
    public static SynBindingTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynBindingTrivia")]
public SynBindingTrivia(SynLeadingKeyword leadingKeyword, FSharpOption`1<Range> inlineKeyword, FSharpOption`1<Range> equalsRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynLeadingKeyword get_LeadingKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_InlineKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_EqualsRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynBindingTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynEnumCaseTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> BarRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range EqualsRange@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> BarRange { get; }
    [CompilationMappingAttribute("4", "1")]
public Range EqualsRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynEnumCaseTrivia")]
public SynEnumCaseTrivia(FSharpOption`1<Range> barRange, Range equalsRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_BarRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_EqualsRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprAndBangTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range EqualsRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> InKeyword@;
    [CompilationMappingAttribute("4", "0")]
public Range EqualsRange { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> InKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprAndBangTrivia")]
public SynExprAndBangTrivia(Range equalsRange, FSharpOption`1<Range> inKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_EqualsRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_InKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprAnonRecdTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range OpeningBraceRange@;
    [CompilationMappingAttribute("4", "0")]
public Range OpeningBraceRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprAnonRecdTrivia")]
public SynExprAnonRecdTrivia(Range openingBraceRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_OpeningBraceRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprDotLambdaTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range UnderscoreRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range DotRange@;
    [CompilationMappingAttribute("4", "0")]
public Range UnderscoreRange { get; }
    [CompilationMappingAttribute("4", "1")]
public Range DotRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprDotLambdaTrivia")]
public SynExprDotLambdaTrivia(Range underscoreRange, Range dotRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_UnderscoreRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_DotRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprIfThenElseTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range IfKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsElif@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range ThenKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> ElseKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range IfToThenRange@;
    [CompilationMappingAttribute("4", "0")]
public Range IfKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public bool IsElif { get; }
    [CompilationMappingAttribute("4", "2")]
public Range ThenKeyword { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<Range> ElseKeyword { get; }
    [CompilationMappingAttribute("4", "4")]
public Range IfToThenRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprIfThenElseTrivia")]
public SynExprIfThenElseTrivia(Range ifKeyword, bool isElif, Range thenKeyword, FSharpOption`1<Range> elseKeyword, Range ifToThenRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_IfKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsElif();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_ThenKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_ElseKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_IfToThenRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprLambdaTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> ArrowRange@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> ArrowRange { get; }
    public static SynExprLambdaTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprLambdaTrivia")]
public SynExprLambdaTrivia(FSharpOption`1<Range> arrowRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_ArrowRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynExprLambdaTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseBangTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> EqualsRange@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> EqualsRange { get; }
    public static SynExprLetOrUseBangTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseBangTrivia")]
public SynExprLetOrUseBangTrivia(FSharpOption`1<Range> equalsRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_EqualsRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynExprLetOrUseBangTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> InKeyword@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> InKeyword { get; }
    public static SynExprLetOrUseTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprLetOrUseTrivia")]
public SynExprLetOrUseTrivia(FSharpOption`1<Range> inKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_InKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynExprLetOrUseTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprMatchBangTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range MatchBangKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range WithKeyword@;
    [CompilationMappingAttribute("4", "0")]
public Range MatchBangKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public Range WithKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprMatchBangTrivia")]
public SynExprMatchBangTrivia(Range matchBangKeyword, Range withKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_MatchBangKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_WithKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprMatchTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range MatchKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range WithKeyword@;
    [CompilationMappingAttribute("4", "0")]
public Range MatchKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public Range WithKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprMatchTrivia")]
public SynExprMatchTrivia(Range matchKeyword, Range withKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_MatchKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_WithKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprTryFinallyTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range TryKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range FinallyKeyword@;
    [CompilationMappingAttribute("4", "0")]
public Range TryKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public Range FinallyKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprTryFinallyTrivia")]
public SynExprTryFinallyTrivia(Range tryKeyword, Range finallyKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_TryKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_FinallyKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynExprTryWithTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range TryKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range TryToWithRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range WithKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range WithToEndRange@;
    [CompilationMappingAttribute("4", "0")]
public Range TryKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public Range TryToWithRange { get; }
    [CompilationMappingAttribute("4", "2")]
public Range WithKeyword { get; }
    [CompilationMappingAttribute("4", "3")]
public Range WithToEndRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynExprTryWithTrivia")]
public SynExprTryWithTrivia(Range tryKeyword, Range tryToWithRange, Range withKeyword, Range withToEndRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_TryKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_TryToWithRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_WithKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_WithToEndRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynFieldTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<SynLeadingKeyword> LeadingKeyword@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<SynLeadingKeyword> LeadingKeyword { get; }
    public static SynFieldTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynFieldTrivia")]
public SynFieldTrivia(FSharpOption`1<SynLeadingKeyword> leadingKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<SynLeadingKeyword> get_LeadingKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynFieldTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SyntaxTrivia.SynLeadingKeyword : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynLeadingKeyword _unique_Synthetic;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLetRec { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUseRec { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExtern { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMemberVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOverride { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOverrideVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAbstract { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAbstractMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStatic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticMemberVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticAbstract { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticAbstractMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticLetRec { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticDo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDefault { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDefaultVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNew { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynLeadingKeyword Synthetic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynthetic { get; }
    public Range Range { get; }
    private static SynLeadingKeyword();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.SyntaxTrivia.SynLeadingKeyword")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynLeadingKeyword(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynLeadingKeyword NewLet(Range _letRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLet();
    [CompilationMappingAttribute("8", "1")]
public static SynLeadingKeyword NewLetRec(Range _letRange, Range _recRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLetRec();
    [CompilationMappingAttribute("8", "2")]
public static SynLeadingKeyword NewAnd(Range _andRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnd();
    [CompilationMappingAttribute("8", "3")]
public static SynLeadingKeyword NewUse(Range _useRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUse();
    [CompilationMappingAttribute("8", "4")]
public static SynLeadingKeyword NewUseRec(Range _useRange, Range _recRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUseRec();
    [CompilationMappingAttribute("8", "5")]
public static SynLeadingKeyword NewExtern(Range _externRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExtern();
    [CompilationMappingAttribute("8", "6")]
public static SynLeadingKeyword NewMember(Range _memberRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMember();
    [CompilationMappingAttribute("8", "7")]
public static SynLeadingKeyword NewMemberVal(Range _memberRange, Range _valRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMemberVal();
    [CompilationMappingAttribute("8", "8")]
public static SynLeadingKeyword NewOverride(Range _overrideRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOverride();
    [CompilationMappingAttribute("8", "9")]
public static SynLeadingKeyword NewOverrideVal(Range _overrideRange, Range _valRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOverrideVal();
    [CompilationMappingAttribute("8", "10")]
public static SynLeadingKeyword NewAbstract(Range _abstractRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAbstract();
    [CompilationMappingAttribute("8", "11")]
public static SynLeadingKeyword NewAbstractMember(Range _abstractRange, Range _memberRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAbstractMember();
    [CompilationMappingAttribute("8", "12")]
public static SynLeadingKeyword NewStatic(Range _staticRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStatic();
    [CompilationMappingAttribute("8", "13")]
public static SynLeadingKeyword NewStaticMember(Range _staticRange, Range _memberRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticMember();
    [CompilationMappingAttribute("8", "14")]
public static SynLeadingKeyword NewStaticMemberVal(Range _staticRange, Range _memberRange, Range _valRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticMemberVal();
    [CompilationMappingAttribute("8", "15")]
public static SynLeadingKeyword NewStaticAbstract(Range _staticRange, Range _abstractRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticAbstract();
    [CompilationMappingAttribute("8", "16")]
public static SynLeadingKeyword NewStaticAbstractMember(Range _staticRange, Range _abstractMember, Range _memberRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticAbstractMember();
    [CompilationMappingAttribute("8", "17")]
public static SynLeadingKeyword NewStaticVal(Range _staticRange, Range _valRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticVal();
    [CompilationMappingAttribute("8", "18")]
public static SynLeadingKeyword NewStaticLet(Range _staticRange, Range _letRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticLet();
    [CompilationMappingAttribute("8", "19")]
public static SynLeadingKeyword NewStaticLetRec(Range _staticRange, Range _letRange, Range _recRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticLetRec();
    [CompilationMappingAttribute("8", "20")]
public static SynLeadingKeyword NewStaticDo(Range _staticRange, Range _doRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticDo();
    [CompilationMappingAttribute("8", "21")]
public static SynLeadingKeyword NewDefault(Range _defaultRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDefault();
    [CompilationMappingAttribute("8", "22")]
public static SynLeadingKeyword NewDefaultVal(Range _defaultRange, Range _valRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDefaultVal();
    [CompilationMappingAttribute("8", "23")]
public static SynLeadingKeyword NewVal(Range _valRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVal();
    [CompilationMappingAttribute("8", "24")]
public static SynLeadingKeyword NewNew(Range _newRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNew();
    [CompilationMappingAttribute("8", "25")]
public static SynLeadingKeyword NewDo(Range _doRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDo();
    [CompilationMappingAttribute("8", "26")]
public static SynLeadingKeyword get_Synthetic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynthetic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynMatchClauseTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> ArrowRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> BarRange@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> ArrowRange { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> BarRange { get; }
    public static SynMatchClauseTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynMatchClauseTrivia")]
public SynMatchClauseTrivia(FSharpOption`1<Range> arrowRange, FSharpOption`1<Range> barRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_ArrowRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_BarRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynMatchClauseTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynMeasureConstantTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range LessRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range GreaterRange@;
    [CompilationMappingAttribute("4", "0")]
public Range LessRange { get; }
    [CompilationMappingAttribute("4", "1")]
public Range GreaterRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynMeasureConstantTrivia")]
public SynMeasureConstantTrivia(Range lessRange, Range greaterRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_LessRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_GreaterRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynMemberDefnAbstractSlotTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<GetSetKeywords> GetSetKeywords@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<GetSetKeywords> GetSetKeywords { get; }
    public static SynMemberDefnAbstractSlotTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynMemberDefnAbstractSlotTrivia")]
public SynMemberDefnAbstractSlotTrivia(FSharpOption`1<GetSetKeywords> getSetKeywords);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<GetSetKeywords> get_GetSetKeywords();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynMemberDefnAbstractSlotTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynLeadingKeyword LeadingKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> WithKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> EqualsRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<GetSetKeywords> GetSetKeywords@;
    [CompilationMappingAttribute("4", "0")]
public SynLeadingKeyword LeadingKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> WithKeyword { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<Range> EqualsRange { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<GetSetKeywords> GetSetKeywords { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynMemberDefnAutoPropertyTrivia")]
public SynMemberDefnAutoPropertyTrivia(SynLeadingKeyword leadingKeyword, FSharpOption`1<Range> withKeyword, FSharpOption`1<Range> equalsRange, FSharpOption`1<GetSetKeywords> getSetKeywords);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynLeadingKeyword get_LeadingKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_WithKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_EqualsRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<GetSetKeywords> get_GetSetKeywords();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynMemberDefnImplicitCtorTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> AsKeyword@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> AsKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynMemberDefnImplicitCtorTrivia")]
public SynMemberDefnImplicitCtorTrivia(FSharpOption`1<Range> asKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_AsKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynMemberGetSetTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> InlineKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range WithKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> GetKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> AndKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> SetKeyword@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> InlineKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public Range WithKeyword { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<Range> GetKeyword { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<Range> AndKeyword { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpOption`1<Range> SetKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynMemberGetSetTrivia")]
public SynMemberGetSetTrivia(FSharpOption`1<Range> inlineKeyword, Range withKeyword, FSharpOption`1<Range> getKeyword, FSharpOption`1<Range> andKeyword, FSharpOption`1<Range> setKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_InlineKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_WithKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_GetKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_AndKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_SetKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynMemberSigMemberTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<GetSetKeywords> GetSetKeywords@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<GetSetKeywords> GetSetKeywords { get; }
    public static SynMemberSigMemberTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynMemberSigMemberTrivia")]
public SynMemberSigMemberTrivia(FSharpOption`1<GetSetKeywords> getSetKeywords);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<GetSetKeywords> get_GetSetKeywords();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynMemberSigMemberTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynModuleDeclNestedModuleTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> ModuleKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> EqualsRange@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> ModuleKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> EqualsRange { get; }
    public static SynModuleDeclNestedModuleTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynModuleDeclNestedModuleTrivia")]
public SynModuleDeclNestedModuleTrivia(FSharpOption`1<Range> moduleKeyword, FSharpOption`1<Range> equalsRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_ModuleKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_EqualsRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynModuleDeclNestedModuleTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public abstract class FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceLeadingKeyword : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynModuleOrNamespaceLeadingKeyword _unique_None;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynModuleOrNamespaceLeadingKeyword None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    private static SynModuleOrNamespaceLeadingKeyword();
    [CompilationMappingAttribute("8", "0")]
public static SynModuleOrNamespaceLeadingKeyword NewModule(Range _moduleRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "1")]
public static SynModuleOrNamespaceLeadingKeyword NewNamespace(Range _namespaceRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "2")]
public static SynModuleOrNamespaceLeadingKeyword get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceSigTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynModuleOrNamespaceLeadingKeyword LeadingKeyword@;
    [CompilationMappingAttribute("4", "0")]
public SynModuleOrNamespaceLeadingKeyword LeadingKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceSigTrivia")]
public SynModuleOrNamespaceSigTrivia(SynModuleOrNamespaceLeadingKeyword leadingKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceLeadingKeyword get_LeadingKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynModuleOrNamespaceLeadingKeyword LeadingKeyword@;
    [CompilationMappingAttribute("4", "0")]
public SynModuleOrNamespaceLeadingKeyword LeadingKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynModuleOrNamespaceTrivia")]
public SynModuleOrNamespaceTrivia(SynModuleOrNamespaceLeadingKeyword leadingKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynModuleOrNamespaceLeadingKeyword get_LeadingKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynModuleSigDeclNestedModuleTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> ModuleKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> EqualsRange@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> ModuleKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> EqualsRange { get; }
    public static SynModuleSigDeclNestedModuleTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynModuleSigDeclNestedModuleTrivia")]
public SynModuleSigDeclNestedModuleTrivia(FSharpOption`1<Range> moduleKeyword, FSharpOption`1<Range> equalsRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_ModuleKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_EqualsRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynModuleSigDeclNestedModuleTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynPatListConsTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range ColonColonRange@;
    [CompilationMappingAttribute("4", "0")]
public Range ColonColonRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynPatListConsTrivia")]
public SynPatListConsTrivia(Range colonColonRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_ColonColonRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynPatOrTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range BarRange@;
    [CompilationMappingAttribute("4", "0")]
public Range BarRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynPatOrTrivia")]
public SynPatOrTrivia(Range barRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_BarRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynTyparDeclTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<Range> AmpersandRanges@;
    [CompilationMappingAttribute("4", "0")]
public FSharpList`1<Range> AmpersandRanges { get; }
    public static SynTyparDeclTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynTyparDeclTrivia")]
public SynTyparDeclTrivia(FSharpList`1<Range> ampersandRanges);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpList`1<Range> get_AmpersandRanges();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynTyparDeclTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.SyntaxTrivia.SynTypeDefnLeadingKeyword : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static SynTypeDefnLeadingKeyword _unique_Synthetic;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStaticType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static SynTypeDefnLeadingKeyword Synthetic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSynthetic { get; }
    public Range Range { get; }
    private static SynTypeDefnLeadingKeyword();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.SyntaxTrivia.SynTypeDefnLeadingKeyword")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal SynTypeDefnLeadingKeyword(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static SynTypeDefnLeadingKeyword NewType(Range item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "1")]
public static SynTypeDefnLeadingKeyword NewAnd(Range item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnd();
    [CompilationMappingAttribute("8", "2")]
public static SynTypeDefnLeadingKeyword NewStaticType(Range _staticRange, Range _typeRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStaticType();
    [CompilationMappingAttribute("8", "3")]
public static SynTypeDefnLeadingKeyword get_Synthetic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSynthetic();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public Range get_Range();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynTypeDefnSigTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynTypeDefnLeadingKeyword LeadingKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> EqualsRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> WithKeyword@;
    [CompilationMappingAttribute("4", "0")]
public SynTypeDefnLeadingKeyword LeadingKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> EqualsRange { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<Range> WithKeyword { get; }
    public static SynTypeDefnSigTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynTypeDefnSigTrivia")]
public SynTypeDefnSigTrivia(SynTypeDefnLeadingKeyword leadingKeyword, FSharpOption`1<Range> equalsRange, FSharpOption`1<Range> withKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnLeadingKeyword get_LeadingKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_EqualsRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_WithKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynTypeDefnSigTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynTypeDefnTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynTypeDefnLeadingKeyword LeadingKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> EqualsRange@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> WithKeyword@;
    [CompilationMappingAttribute("4", "0")]
public SynTypeDefnLeadingKeyword LeadingKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> EqualsRange { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<Range> WithKeyword { get; }
    public static SynTypeDefnTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynTypeDefnTrivia")]
public SynTypeDefnTrivia(SynTypeDefnLeadingKeyword leadingKeyword, FSharpOption`1<Range> equalsRange, FSharpOption`1<Range> withKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynTypeDefnLeadingKeyword get_LeadingKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_EqualsRange();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_WithKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynTypeDefnTrivia get_Zero();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynTypeFunTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range ArrowRange@;
    [CompilationMappingAttribute("4", "0")]
public Range ArrowRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynTypeFunTrivia")]
public SynTypeFunTrivia(Range arrowRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_ArrowRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynTypeOrTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal Range OrKeyword@;
    [CompilationMappingAttribute("4", "0")]
public Range OrKeyword { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynTypeOrTrivia")]
public SynTypeOrTrivia(Range orKeyword);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_OrKeyword();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynUnionCaseTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> BarRange@;
    [CompilationMappingAttribute("4", "0")]
public FSharpOption`1<Range> BarRange { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynUnionCaseTrivia")]
public SynUnionCaseTrivia(FSharpOption`1<Range> barRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_BarRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.SyntaxTrivia.SynValSigTrivia : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal SynLeadingKeyword LeadingKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> InlineKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> WithKeyword@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpOption`1<Range> EqualsRange@;
    [CompilationMappingAttribute("4", "0")]
public SynLeadingKeyword LeadingKeyword { get; }
    [CompilationMappingAttribute("4", "1")]
public FSharpOption`1<Range> InlineKeyword { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpOption`1<Range> WithKeyword { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpOption`1<Range> EqualsRange { get; }
    public static SynValSigTrivia Zero { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.SyntaxTrivia.SynValSigTrivia")]
public SynValSigTrivia(SynLeadingKeyword leadingKeyword, FSharpOption`1<Range> inlineKeyword, FSharpOption`1<Range> withKeyword, FSharpOption`1<Range> equalsRange);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public SynLeadingKeyword get_LeadingKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_InlineKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_WithKeyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpOption`1<Range> get_EqualsRange();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static SynValSigTrivia get_Zero();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TailCallChecks : object {
    [CompilationMappingAttribute("9")]
internal static int PostInferenceChecksStackGuardDepth { get; }
    internal static int get_PostInferenceChecksStackGuardDepth();
    internal static FSharpOption`1<Tuple`2<ValRef, ValUseFlag>> |ValUseAtApp|_|(Expr e);
    internal static PermitByRefExpr mkArgsPermit(int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PermitByRefExpr> mkArgsForAppliedVal(bool isBaseCall, ValRef vref, FSharpList`1<a> argsl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<PermitByRefExpr> mkArgsForAppliedExpr(bool isBaseCall, FSharpList`1<a> argsl, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckForNonTailRecCall(cenv cenv, Expr expr, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckCallWithReceiver(cenv cenv, FSharpList`1<Expr> args, FSharpList`1<PermitByRefExpr> ctxts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckExprLinear(cenv cenv, Expr expr, PermitByRefExpr ctxt, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckExpr(cenv cenv, Expr origExpr, PermitByRefExpr ctxt, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckStructStateMachineExpr(cenv cenv, TType info_0, Tuple`2<Val, Expr> info_1, Tuple`3<Val, Val, Expr> info_2, Tuple`2<Val, Expr> info_3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckObjectExpr(cenv cenv, TType ty, Expr superInitCall, FSharpList`1<ObjExprMethod> overrides, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> iimpls);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckFSharpBaseCall(cenv cenv, ValRef v, Expr f, FSharpList`1<Expr> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckILBaseCall(cenv cenv, FSharpList`1<Expr> rest);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckApplication(cenv cenv, Expr f, FSharpList`1<Expr> argsl, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckLambda(cenv cenv, Expr expr, FSharpList`1<Val> argvs, Range m, TType bodyTy, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckTyLambda(cenv cenv, Expr expr, FSharpList`1<Typar> tps, Range m, TType bodyTy, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMatch(cenv cenv, PermitByRefExpr ctxt, DecisionTree dtree, DecisionTreeTarget[] targets, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckLetRec(cenv cenv, FSharpList`1<Binding> binds, Expr bodyExpr, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckStaticOptimization(cenv cenv, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMethods(cenv cenv, TType ty, FSharpList`1<ObjExprMethod> methods);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckMethod(cenv cenv, TType _ty, ObjExprMethod _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInterfaceImpls(cenv cenv, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckInterfaceImpl(cenv cenv, TType overrides_0, FSharpList`1<ObjExprMethod> overrides_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckExprOp(cenv cenv, TOp op, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m, PermitByRefExpr ctxt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckLambdas(bool isTop, FSharpOption`1<Val> memberVal, cenv cenv, bool inlined, ValReprInfo valReprInfo, TailCall tailCall, bool alwaysCheckNoReraise, Expr expr, Range mOrig, TType ety, PermitByRefExpr ctxt);
    internal static PermitByRefExpr argArity@622-1(PermitByRefExpr[] ctxts, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckExprs(cenv cenv, FSharpList`1<Expr> exprs, FSharpList`1<PermitByRefExpr> ctxts, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckExprsNoByRefLike(cenv cenv, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckExprsPermitByRefLike(cenv cenv, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckExprPermitByRefLike(cenv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckExprPermitReturnableByRef(cenv cenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTreeTargets(cenv cenv, DecisionTreeTarget[] targets, PermitByRefExpr ctxt, TailCall tailCall);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTreeTarget(cenv cenv, TailCall tailCall, PermitByRefExpr ctxt, DecisionTreeTarget _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTree(cenv cenv, DecisionTree dtree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTreeSwitch(cenv cenv, Expr inpExpr, FSharpList`1<DecisionTreeCase> cases, FSharpOption`1<DecisionTree> dflt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDecisionTreeTest(cenv cenv, DecisionTreeTest discrim);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckBinding(cenv cenv, bool alwaysCheckNoReraise, PermitByRefExpr ctxt, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckBindings(cenv cenv, FSharpList`1<Binding> binds);
    internal static void checkTailCall@696(cenv cenv, bool isRec, bool insideSubBinding, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckModuleBinding(cenv cenv, bool isRec, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDefnsInModule(cenv cenv, FSharpList`1<ModuleOrNamespaceContents> mdefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckDefnInModule(cenv cenv, ModuleOrNamespaceContents mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void CheckModuleSpec(cenv cenv, bool isRec, ModuleOrNamespaceBinding mbind);
    internal static void CheckImplFile(TcGlobals g, ImportMap amap, bool reportErrors, ModuleOrNamespaceContents implFileContents);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Tainted : object {
    internal static FSharpChoice`2<Unit, Tainted`1<T>> |Null|NonNull|(Tainted`1<T> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Eq(Tainted`1<T> p, T v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EqTainted(Tainted`1<T> t1, Tainted`1<T> t2);
    internal static int GetHashCodeTainted(Tainted`1<T> t);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[ClassAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Tainted`1 : object {
    internal T value;
    internal TaintedContext context;
    internal string TypeProviderDesignation { get; }
    internal ILScopeRef TypeProviderAssemblyRef { get; }
    internal Tainted`1<ITypeProvider> TypeProvider { get; }
    internal T AccessObjectDirectly { get; }
    public Tainted`1(TaintedContext context, T value);
    internal string get_TypeProviderDesignation();
    internal ILScopeRef get_TypeProviderAssemblyRef();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal a Protect(FSharpFunc`2<T, a> f, Range range);
    internal Tainted`1<ITypeProvider> get_TypeProvider();
    internal Tainted`1<U> PApply(FSharpFunc`2<T, U> f, Range range);
    internal Tuple`2<Tainted`1<U1>, Tainted`1<U2>> PApply2(FSharpFunc`2<T, Tuple`2<U1, U2>> f, Range range);
    internal Tuple`3<Tainted`1<U1>, Tainted`1<U2>, Tainted`1<U3>> PApply3(FSharpFunc`2<T, Tuple`3<U1, U2, U3>> f, Range range);
    internal Tuple`4<Tainted`1<U1>, Tainted`1<U2>, Tainted`1<U3>, Tainted`1<U4>> PApply4(FSharpFunc`2<T, Tuple`4<U1, U2, U3, U4>> f, Range range);
    internal Tainted`1<U> PApplyNoFailure(FSharpFunc`2<T, U> f);
    internal Tainted`1<U> PApplyWithProvider(FSharpFunc`2<Tuple`2<T, ITypeProvider>, U> f, Range range);
    internal Tainted`1[] PApplyArray(FSharpFunc`2<T, U[]> f, string methodName, Range range);
    internal FSharpOption`1<Tainted`1<U>> PApplyOption(FSharpFunc`2<T, FSharpOption`1<U>> f, Range range);
    internal U PUntaint(FSharpFunc`2<T, U> f, Range range);
    internal U PUntaintNoFailure(FSharpFunc`2<T, U> f);
    internal T get_AccessObjectDirectly();
    internal static FSharpList`1<Tainted`1<ITypeProvider>> CreateAll(FSharpList`1<Tuple`2<ITypeProvider, ILScopeRef>> providerSpecs);
    internal FSharpOption`1<Tainted`1<U>> OfType();
    internal Tainted`1<U> Coerce(Range range);
}
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.TaintedContext : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ITypeProvider TypeProvider@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal ILScopeRef TypeProviderAssemblyRef@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal TypeProviderLock Lock@;
    [CompilationMappingAttribute("4", "0")]
internal ITypeProvider TypeProvider { get; }
    [CompilationMappingAttribute("4", "1")]
internal ILScopeRef TypeProviderAssemblyRef { get; }
    [CompilationMappingAttribute("4", "2")]
internal TypeProviderLock Lock { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.TaintedContext")]
internal TaintedContext(ITypeProvider typeProvider, ILScopeRef typeProviderAssemblyRef, TypeProviderLock lock);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ITypeProvider get_TypeProvider();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal ILScopeRef get_TypeProviderAssemblyRef();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TypeProviderLock get_Lock();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TaintedContext obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TcGlobals : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_InternalsVisibleToAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerNonUserCodeAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggableAttribute_DebuggingModes;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerHiddenAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerDisplayAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerTypeProxyAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerStepThroughAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerBrowsableAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggerBrowsableState;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_StringBuilder;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_IComparable;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Exception;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Missing;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_FormattableString;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_SerializationInfo;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_StreamingContext;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_SecurityPermissionAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Delegate;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_ValueType;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Enum;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_FlagsAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_Array;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_RuntimeArgumentHandle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_RuntimeTypeHandle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_RuntimeMethodHandle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_RuntimeFieldHandle;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_CompilerGeneratedAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_ReferenceAssemblyAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_UnmanagedType;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_DebuggableAttribute;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_AsyncCallback;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_IAsyncResult;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static string tname_IsByRefLikeAttribute;
    [CompilationMappingAttribute("9")]
internal static string DummyFileNameForRangesWithoutASpecificLocation { get; }
    [CompilationMappingAttribute("9")]
internal static Range envRange { get; }
    private static TcGlobals();
    internal static string get_DummyFileNameForRangesWithoutASpecificLocation();
    internal static Range get_envRange();
    internal static ValRef ValRefForIntrinsic(IntrinsicValRef _arg1);
    [CompilerGeneratedAttribute]
internal static EntityRef initializer@1-4(TcGlobals this, int idx);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.Display : object {
    internal static int chunkN { get; }
    [CompilationMappingAttribute("9")]
internal static Layout structL { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-56 { get; }
    [CompilationMappingAttribute("9")]
internal static Layout nullL { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-57 { get; }
    [CompilationMappingAttribute("9")]
internal static Layout unitL { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-58 { get; }
    internal static bool typeUsesSystemObjectToString(Type ty);
    internal static FSharpChoice`2<a, Exception> catchExn(FSharpFunc`2<Unit, a> f);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_chunkN();
    [CompilerGeneratedAttribute]
internal static int initializer@1(Int32[] stack, int next, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Breaks pushBreak(int saving, Breaks _arg1);
    internal static Tuple`2<Breaks, bool> popBreak(Breaks _arg1);
    internal static FSharpOption`1<Tuple`2<Breaks, int>> forceBreak(Breaks _arg1);
    internal static Tuple`4<Breaks, Layout, int, int> fitLeaf@686(int maxWidth, Layout layout, int textWidth, Breaks breaks, int pos);
    internal static Tuple`4<Breaks, Layout, int, int> fit@661(int maxWidth, FSharpFunc`2<object, TaggedText> leafFormatter, Breaks breaks, int pos, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout squashToAux(int maxWidth, FSharpFunc`2<object, TaggedText> leafFormatter, Layout layout);
    internal static Tuple`2<FSharpList`1<string>, int> addText@748(FSharpList`1<string> rstrs, int i, string text);
    internal static Tuple`2<FSharpList`1<string>, int> newLine@752(FSharpList`1<string> rstrs, a tupledArg1, int n);
    internal static Tuple`2<FSharpList`1<string>, int> addL@759(FormatOptions opts, FSharpFunc`2<object, string> leafFormatter, Tuple`2<FSharpList`1<string>, int> z, int pos, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string showL(FormatOptions opts, FSharpFunc`2<object, string> leafFormatter, Layout layout);
    internal static FSharpFunc`2<TaggedText, int> addText@794-1(TaggedTextWriter chan, int z);
    internal static int newLine@798-1(TaggedTextWriter chan, c _arg1, int n);
    internal static int addL@805-1(FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, a>>> outAttribute, FSharpFunc`2<object, b> leafFormatter, TaggedTextWriter chan, int z, int pos, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outL(FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, a>>> outAttribute, FSharpFunc`2<object, b> leafFormatter, TaggedTextWriter chan, Layout layout);
    internal static Tuple`2<b, b> unpackCons(Tuple`2[] recd);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Tuple`2<object, Type>, Tuple`2<object, Type>>> getListValueInfo(BindingFlags bindingFlags, object x, Type ty);
    internal static Layout get_structL();
    internal static TextTag get_tag@121-56();
    internal static Layout get_nullL();
    internal static TextTag get_tag@121-57();
    internal static Layout get_unitL();
    internal static TextTag get_tag@121-58();
    internal static Layout itemL@854(TaggedText name, Layout xL);
    internal static Layout makeRecordL(FSharpList`1<Tuple`2<a, Layout>> nameXs);
    internal static Layout itemL@862-1(TaggedText name, FSharpOption`1<Layout> v);
    internal static Layout makePropertiesL(FSharpList`1<Tuple`2<a, FSharpOption`1<Layout>>> nameXs);
    internal static Layout makeListL(FSharpList`1<Layout> itemLs);
    internal static Layout makeArrayL(FSharpList`1<Layout> xs);
    internal static Layout makeArray2L(FSharpList`1<Layout> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatChar(bool isChar, char c);
    internal static bool check@916(string s, int i);
    internal static string conv@919(string s, int i, FSharpList`1<string> acc);
    internal static string formatString(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string formatStringInWidth(int width, string str);
    internal static bool isSetOrMapType(Type ty);
    internal static FSharpOption`1<Layout> buildObjMessageL@1054(ObjectGraphFormatter this, ShowMode showMode, Type ty, int depthLim, object obj, string txt, FSharpList`1<Layout> layouts);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@1166-639(ObjectGraphFormatter this, int depthLim);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@1169-640(ObjectGraphFormatter this, int depthLim);
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<Precedence, FSharpFunc`2<Tuple`2<object, Type>, Layout>> clo0@1180-641(ObjectGraphFormatter this, int depthLim);
    internal static Tuple`2<TaggedText, Layout> itemL@1189-2(ObjectGraphFormatter this, int depthLim, Tuple`3<string, a, Type> tupledArg);
    internal static FSharpFunc`2<Tuple`2<a, Type>, FSharpOption`1<Tuple`2<Tuple`2<object, Type>, Tuple`2<object, Type>>>> project@1199(ObjectGraphFormatter this);
    internal static FSharpFunc`2<int, FSharpOption`1<Tuple`2<Tuple`2<object, Type>, int>>> project2@1285(Array arr, Type ty, int n1, int n2, int b1, int b2, int x);
    internal static FSharpFunc`2<o, Layout> possibleKeyValueL@1316(ObjectGraphFormatter this, int depthLim, string word);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedText leafFormatter(FormatOptions opts, object obj);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout any_to_layout(FormatOptions options, T value, Type typValue);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout squashTo(int width, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout squash_layout(FormatOptions options, Layout layout);
    internal static TaggedTextWriter asTaggedTextWriter(TextWriter writer);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void output_layout_tagged(FormatOptions options, TaggedTextWriter writer, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string layout_to_string(FormatOptions options, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout fsi_any_to_layout(FormatOptions options, T value, Type typValue);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.FileIndexModule : object {
    [CompilationMappingAttribute("9")]
internal static int maxFileIndex { get; }
    [CompilationMappingAttribute("9")]
internal static FileIndexTable fileIndexTable { get; }
    internal static string unknownFileName { get; }
    internal static string startupFileName { get; }
    internal static string commandLineArgsFileName { get; }
    internal static int get_maxFileIndex();
    internal static FileIndexTable get_fileIndexTable();
    internal static int fileIndexOfFile(string filePath);
    internal static string fileOfFileIndex(int idx);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_unknownFileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_startupFileName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_commandLineArgsFileName();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Text.FileIndexTable : object {
    internal List`1<string> indexToFileTable;
    internal ConcurrentDictionary`2<string, int> fileToIndexTable;
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal int FileToIndex(bool normalize, string filePath);
    internal string IndexToFile(int n);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("34")]
internal class FSharp.Compiler.Text.FormatOptions : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string FloatingPointFormat@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> AttributeProcessor@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpList`1<FSharpFunc`2<IEnvironment, FSharpFunc`2<object, FSharpOption`1<Layout>>>> PrintIntercepts@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int StringLimit@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal IFormatProvider FormatProvider@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal BindingFlags BindingFlags@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int PrintWidth@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int PrintDepth@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int PrintLength@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int PrintSize@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool ShowProperties@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool ShowIEnumerable@;
    [CompilationMappingAttribute("4", "0")]
internal string FloatingPointFormat { get; }
    [CompilationMappingAttribute("4", "1")]
internal FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> AttributeProcessor { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpList`1<FSharpFunc`2<IEnvironment, FSharpFunc`2<object, FSharpOption`1<Layout>>>> PrintIntercepts { get; }
    [CompilationMappingAttribute("4", "3")]
internal int StringLimit { get; }
    [CompilationMappingAttribute("4", "4")]
internal IFormatProvider FormatProvider { get; }
    [CompilationMappingAttribute("4", "5")]
internal BindingFlags BindingFlags { get; }
    [CompilationMappingAttribute("4", "6")]
internal int PrintWidth { get; }
    [CompilationMappingAttribute("4", "7")]
internal int PrintDepth { get; }
    [CompilationMappingAttribute("4", "8")]
internal int PrintLength { get; }
    [CompilationMappingAttribute("4", "9")]
internal int PrintSize { get; }
    [CompilationMappingAttribute("4", "10")]
internal bool ShowProperties { get; }
    [CompilationMappingAttribute("4", "11")]
internal bool ShowIEnumerable { get; }
    internal static FormatOptions Default { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Text.FormatOptions")]
internal FormatOptions(string floatingPointFormat, FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> attributeProcessor, FSharpList`1<FSharpFunc`2<IEnvironment, FSharpFunc`2<object, FSharpOption`1<Layout>>>> printIntercepts, int stringLimit, IFormatProvider formatProvider, BindingFlags bindingFlags, int printWidth, int printDepth, int printLength, int printSize, bool showProperties, bool showIEnumerable);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal string get_FloatingPointFormat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<string, FSharpFunc`2<FSharpList`1<Tuple`2<string, string>>, FSharpFunc`2<bool, Unit>>> get_AttributeProcessor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpList`1<FSharpFunc`2<IEnvironment, FSharpFunc`2<object, FSharpOption`1<Layout>>>> get_PrintIntercepts();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_StringLimit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal IFormatProvider get_FormatProvider();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal BindingFlags get_BindingFlags();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_PrintWidth();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_PrintDepth();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_PrintLength();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_PrintSize();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_ShowProperties();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_ShowIEnumerable();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal static FormatOptions get_Default();
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("3")]
internal interface FSharp.Compiler.Text.IEnvironment {
    public int MaxColumns { get; }
    public int MaxRows { get; }
    public abstract virtual Layout GetLayout(object );
    public abstract virtual int get_MaxColumns();
    public abstract virtual int get_MaxRows();
}
[DefaultMemberAttribute("Item")]
[CompilationMappingAttribute("3")]
public interface FSharp.Compiler.Text.ISourceText {
    public char Item { get; }
    public int Length { get; }
    public abstract virtual char get_Item(int index);
    public abstract virtual string GetLineString(int lineIndex);
    public abstract virtual int GetLineCount();
    public abstract virtual Tuple`2<int, int> GetLastCharacterPosition();
    public abstract virtual string GetSubTextString(int start, int length);
    public abstract virtual bool SubTextEquals(string target, int startIndex);
    public abstract virtual int get_Length();
    public abstract virtual bool ContentEquals(ISourceText sourceText);
    public abstract virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.Text.Joint : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Joint _unique_Unbreakable;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static Joint Unbreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsUnbreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsBreakable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsBroken { get; }
    private static Joint();
    [CompilationMappingAttribute("8", "0")]
internal static Joint get_Unbreakable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsUnbreakable();
    [CompilationMappingAttribute("8", "1")]
internal static Joint NewBreakable(int _indentation);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsBreakable();
    [CompilationMappingAttribute("8", "2")]
internal static Joint NewBroken(int _indentation);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsBroken();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Joint obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class FSharp.Compiler.Text.Layout : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsObjLeaf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsLeaf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsAttr { get; }
    internal bool JuxtapositionLeft { get; }
    internal bool JuxtapositionRight { get; }
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Text.Layout")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Layout(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static Layout NewObjLeaf(bool _juxtLeft, object _object, bool _juxtRight);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsObjLeaf();
    [CompilationMappingAttribute("8", "1")]
internal static Layout NewLeaf(bool _juxtLeft, TaggedText _text, bool _juxtRight);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsLeaf();
    [CompilationMappingAttribute("8", "2")]
internal static Layout NewNode(Layout _leftLayout, Layout _rightLayout, Joint _joint);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNode();
    [CompilationMappingAttribute("8", "3")]
internal static Layout NewAttr(string _text, FSharpList`1<Tuple`2<string, string>> _attributes, Layout _layout);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsAttr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal bool get_JuxtapositionLeft();
    internal static bool JuxtapositionMiddle(Layout left, Layout right);
    internal bool get_JuxtapositionRight();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.LayoutModule : object {
    [CompilationMappingAttribute("9")]
internal static Layout emptyL { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-55 { get; }
    internal static Layout objL(object value);
    internal static Layout wordL(TaggedText text);
    internal static Layout sepL(TaggedText text);
    internal static Layout rightL(TaggedText text);
    internal static Layout leftL(TaggedText text);
    internal static Layout get_emptyL();
    internal static TextTag get_tag@121-55();
    internal static bool isEmptyL(Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool endsWithL(string text, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout mkNode(Layout l, Layout r, Joint joint);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout aboveL(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout tagAttrL(string text, FSharpList`1<Tuple`2<string, string>> maps, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout apply2(FSharpFunc`2<Layout, FSharpFunc`2<Layout, Layout>> f, Layout l, Layout r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_HatHat(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_PlusPlus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_MinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_MinusMinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_MinusMinusMinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_MinusMinusMinusMinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_AtAt(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_AtAtMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_AtAtMinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_AtAtMinusMinusMinus(Layout layout1, Layout layout2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout op_AtAtMinusMinusMinusMinus(Layout layout1, Layout layout2);
    internal static Layout process'@337(FSharpFunc`2<Layout, Layout> tagger, Layout prefixL, FSharpList`1<Layout> yl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout tagListL(FSharpFunc`2<Layout, Layout> tagger, FSharpList`1<Layout> els);
    internal static Layout commaListL(FSharpList`1<Layout> layouts);
    internal static Layout semiListL(FSharpList`1<Layout> layouts);
    internal static Layout spaceListL(FSharpList`1<Layout> layouts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout sepListL(Layout layout1, FSharpList`1<Layout> layouts);
    internal static Layout bracketL(Layout layout);
    internal static Layout tupleL(FSharpList`1<Layout> layouts);
    internal static Layout aboveListL(FSharpList`1<Layout> layouts);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout optionL(FSharpFunc`2<T, Layout> selector, FSharpOption`1<T> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout listL(FSharpFunc`2<T, Layout> selector, FSharpList`1<T> value);
    internal static Layout squareBracketL(Layout layout);
    internal static Layout braceL(Layout layout);
    internal static FSharpList`1<Layout> consume@384(FSharpFunc`2<a, Layout> itemL, FSharpFunc`2<z, FSharpOption`1<Tuple`2<a, z>>> project, FSharpFunc`2<z, bool> stopShort, int n, z z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Layout> boundedUnfoldL(FSharpFunc`2<a, Layout> itemL, FSharpFunc`2<z, FSharpOption`1<Tuple`2<a, z>>> project, FSharpFunc`2<z, bool> stopShort, z z, int maxLength);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Layout> unfoldL(FSharpFunc`2<T, Layout> selector, FSharpFunc`2<State, FSharpOption`1<Tuple`2<T, State>>> folder, State state, int count);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.LayoutRender : object {
    [CompilationMappingAttribute("9")]
internal static LayoutRenderer`2<string, FSharpList`1<string>> stringR { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedText mkNav(Range r, TaggedText t);
    internal static c addL@99-4(LayoutRenderer`2<b, a> rr, a z, int pos, int i, Layout layout, FSharpFunc`2<Tuple`2<a, int>, c> k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b renderL(LayoutRenderer`2<b, a> rr, Layout layout);
    internal static LayoutRenderer`2<string, FSharpList`1<string>> get_stringR();
    internal static LayoutRenderer`2<NoResult, NoState> taggedTextListR(FSharpFunc`2<TaggedText, Unit> collector);
    internal static LayoutRenderer`2<NoResult, NoState> channelR(TextWriter chan);
    internal static LayoutRenderer`2<NoResult, NoState> bufferR(StringBuilder os);
    internal static string showL(Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void outL(TextWriter chan, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void bufferL(StringBuilder os, Layout layout);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void emitL(FSharpFunc`2<TaggedText, Unit> f, Layout layout);
    internal static TaggedText[] toArray(Layout layout);
}
[CompilationMappingAttribute("3")]
internal interface FSharp.Compiler.Text.LayoutRenderer`2 {
    public abstract virtual b Start();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual b AddText(b , TaggedText );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual b AddBreak(b , int );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract virtual b AddTag(b , string , FSharpList`1<Tuple`2<string, string>> , bool );
    public abstract virtual a Finish(b );
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.LeftL : object {
    [CompilationMappingAttribute("9")]
internal static Layout leftParen { get; }
    [CompilationMappingAttribute("9")]
internal static Layout questionMark { get; }
    [CompilationMappingAttribute("9")]
internal static Layout colon { get; }
    [CompilationMappingAttribute("9")]
internal static Layout leftBracketAngle { get; }
    [CompilationMappingAttribute("9")]
internal static Layout leftBracketBar { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordTypeof { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordTypedefof { get; }
    internal static Layout get_leftParen();
    internal static Layout get_questionMark();
    internal static Layout get_colon();
    internal static Layout get_leftBracketAngle();
    internal static Layout get_leftBracketBar();
    internal static Layout get_keywordTypeof();
    internal static Layout get_keywordTypedefof();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Text.Line : object {
    public static int fromZ(int line);
    public static int toZ(int line);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Text.NavigableTaggedText : TaggedText {
    internal Range Range@;
    public Range Range { get; }
    internal NavigableTaggedText(TaggedText taggedText, Range range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Range get_Range();
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.Text.NoResult : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NoResult _unique_NoResult;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NoResult NoResult { get; }
    private static NoResult();
    [CompilationMappingAttribute("8", "0")]
internal static NoResult get_NoResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NoResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NoResult obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.Text.NoState : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NoState _unique_NoState;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NoState NoState { get; }
    private static NoState();
    [CompilationMappingAttribute("8", "0")]
internal static NoState get_NoState();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NoState obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NoState obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class FSharp.Compiler.Text.NotedSourceConstruct : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_None;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_While;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_For;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_InOrTo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_Try;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_Binding;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_Finally;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_With;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_Combine;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static NotedSourceConstruct _unique_DelayOrQuoteOrRun;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct While { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWhile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct For { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct InOrTo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsInOrTo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct Try { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsTry { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct Binding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsBinding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct Finally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsFinally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct With { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWith { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct Combine { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCombine { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static NotedSourceConstruct DelayOrQuoteOrRun { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsDelayOrQuoteOrRun { get; }
    private static NotedSourceConstruct();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Text.NotedSourceConstruct")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal NotedSourceConstruct(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static NotedSourceConstruct get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsNone();
    [CompilationMappingAttribute("8", "1")]
internal static NotedSourceConstruct get_While();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWhile();
    [CompilationMappingAttribute("8", "2")]
internal static NotedSourceConstruct get_For();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFor();
    [CompilationMappingAttribute("8", "3")]
internal static NotedSourceConstruct get_InOrTo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsInOrTo();
    [CompilationMappingAttribute("8", "4")]
internal static NotedSourceConstruct get_Try();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsTry();
    [CompilationMappingAttribute("8", "5")]
internal static NotedSourceConstruct get_Binding();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsBinding();
    [CompilationMappingAttribute("8", "6")]
internal static NotedSourceConstruct get_Finally();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsFinally();
    [CompilationMappingAttribute("8", "7")]
internal static NotedSourceConstruct get_With();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWith();
    [CompilationMappingAttribute("8", "8")]
internal static NotedSourceConstruct get_Combine();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCombine();
    [CompilationMappingAttribute("8", "9")]
internal static NotedSourceConstruct get_DelayOrQuoteOrRun();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsDelayOrQuoteOrRun();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(NotedSourceConstruct obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NotedSourceConstruct obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.PosImpl : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int columnBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int lineBitCount;
    internal static int posBitCount { get; }
    [CompilationMappingAttribute("9")]
internal static long posColumnMask { get; }
    [CompilationMappingAttribute("9")]
internal static long lineColumnMask { get; }
    private static PosImpl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_posBitCount();
    internal static long get_posColumnMask();
    internal static long get_lineColumnMask();
}
[StructAttribute]
[CustomEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{Line},{Column}")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Text.Position : ValueType {
    internal long code;
    public int Line { get; }
    public int Column { get; }
    internal long Encoding { get; }
    internal static int EncodingSize { get; }
    internal Position(long code);
    internal Position(int l, int c);
    public int get_Line();
    public int get_Column();
    internal long get_Encoding();
    internal static int get_EncodingSize();
    internal static Position Decode(long code);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal bool IsAdjacentTo(Position otherPos);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Text.PositionModule : object {
    [CompilationMappingAttribute("9")]
public static Position pos0 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Position mkPos(int line, int column);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void outputPos(TextWriter os, Position m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool posGt(Position p1, Position p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool posEq(Position p1, Position p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool posGeq(Position p1, Position p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool posLt(Position p1, Position p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Position fromZ(int line, int column);
    public static Tuple`2<int, int> toZ(Position p);
    public static string stringOfPos(Position pos);
    public static Position get_pos0();
}
[StructAttribute]
[CustomEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("({StartLine},{StartColumn}-{EndLine},{EndColumn}) {ShortFileName} -> {DebugCode}")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Text.Range : ValueType {
    internal long code1;
    internal long code2;
    public static Range Zero { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public bool IsSynthetic { get; }
    internal NotedSourceConstruct NotedSourceConstruct { get; }
    public Position Start { get; }
    public Position End { get; }
    internal int FileIndex { get; }
    public Range StartRange { get; }
    public Range EndRange { get; }
    public string FileName { get; }
    internal string ShortFileName { get; }
    internal long Code1 { get; }
    internal long Code2 { get; }
    internal string DebugCode { get; }
    internal Range(long code1, long code2);
    internal Range(int fIdx, int bl, int bc, int el, int ec);
    internal Range(int fIdx, Position b, Position e);
    public static Range get_Zero();
    public int get_StartLine();
    public int get_StartColumn();
    public int get_EndLine();
    public int get_EndColumn();
    public bool get_IsSynthetic();
    internal NotedSourceConstruct get_NotedSourceConstruct();
    public Position get_Start();
    public Position get_End();
    internal int get_FileIndex();
    public Range get_StartRange();
    public Range get_EndRange();
    public string get_FileName();
    internal string get_ShortFileName();
    internal Range MakeSynthetic();
    internal bool IsAdjacentTo(Range otherRange);
    internal Range NoteSourceConstruct(NotedSourceConstruct kind);
    internal long get_Code1();
    internal long get_Code2();
    internal string get_DebugCode();
    internal bool Equals(Range m2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.RangeImpl : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int fileIndexBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int startColumnBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int endColumnBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int startLineBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int heightBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int isSyntheticBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int debugPointKindBitCount;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int fileIndexShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int startColumnShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int endColumnShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int startLineShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int heightShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int isSyntheticShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int debugPointKindShift;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long fileIndexMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long startColumnMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long endColumnMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long startLineMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long heightMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long isSyntheticMask;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static long debugPointKindMask;
    private static RangeImpl();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Text.RangeModule : object {
    [CompilationMappingAttribute("9")]
public static IComparer`1<Position> posOrder { get; }
    [CompilationMappingAttribute("9")]
public static IComparer`1<Range> rangeOrder { get; }
    [CompilationMappingAttribute("9")]
public static Range range0 { get; }
    [CompilationMappingAttribute("9")]
public static Range rangeStartup { get; }
    [CompilationMappingAttribute("9")]
public static Range rangeCmdArgs { get; }
    [CompilationMappingAttribute("9")]
public static IEqualityComparer`1<Range> comparer { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range mkRange(string filePath, Position startPos, Position endPos);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool equals(Range r1, Range r2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range mkFileIndexRange(int fileIndex, Position startPos, Position endPos);
    public static IComparer`1<Position> get_posOrder();
    public static IComparer`1<Range> get_rangeOrder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static void outputRange(TextWriter os, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range unionRanges(Range m1, Range m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range withStartEnd(Position startPos, Position endPos, Range r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range withStart(Position startPos, Range r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range withEnd(Position endPos, Range r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range shiftStart(int lineDelta, int columnDelta, Range r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range shiftEnd(int lineDelta, int columnDelta, Range r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeContainsRange(Range m1, Range m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeContainsPos(Range m1, Position p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static bool rangeBeforePos(Range m1, Position p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Range rangeN(string fileName, int line);
    public static Range get_range0();
    public static Range get_rangeStartup();
    public static Range get_rangeCmdArgs();
    public static Range trimRangeToLine(Range r);
    public static string stringOfRange(Range r);
    public static Tuple`2<Tuple`2<int, int>, Tuple`2<int, int>> toZ(Range m);
    public static Tuple`2<string, Tuple`2<Tuple`2<int, int>, Tuple`2<int, int>>> toFileZ(Range m);
    public static IEqualityComparer`1<Range> get_comparer();
    public static Range mkFirstLineOfFile(string file);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.ReflectUtils : object {
    [CompilationMappingAttribute("9")]
internal static Type option { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@1 { get; }
    [CompilationMappingAttribute("9")]
internal static Type func { get; }
    [CompilationMappingAttribute("9")]
internal static Type ty@1-1 { get; }
    internal static bool isNamedType(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equivHeadTypes(Type ty1, Type ty2);
    internal static Type get_option();
    internal static Type get_ty@1();
    internal static Type get_func();
    internal static Type get_ty@1-1();
    internal static bool isListType(Type ty);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.RightL : object {
    [CompilationMappingAttribute("9")]
internal static Layout comma { get; }
    [CompilationMappingAttribute("9")]
internal static Layout rightParen { get; }
    [CompilationMappingAttribute("9")]
internal static Layout colon { get; }
    [CompilationMappingAttribute("9")]
internal static Layout rightBracket { get; }
    [CompilationMappingAttribute("9")]
internal static Layout rightAngle { get; }
    [CompilationMappingAttribute("9")]
internal static Layout rightBracketAngle { get; }
    [CompilationMappingAttribute("9")]
internal static Layout rightBracketBar { get; }
    internal static Layout get_comma();
    internal static Layout get_rightParen();
    internal static Layout get_colon();
    internal static Layout get_rightBracket();
    internal static Layout get_rightAngle();
    internal static Layout get_rightBracketAngle();
    internal static Layout get_rightBracketBar();
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.SepL : object {
    [CompilationMappingAttribute("9")]
internal static Layout dot { get; }
    [CompilationMappingAttribute("9")]
internal static Layout star { get; }
    [CompilationMappingAttribute("9")]
internal static Layout colon { get; }
    [CompilationMappingAttribute("9")]
internal static Layout questionMark { get; }
    [CompilationMappingAttribute("9")]
internal static Layout leftParen { get; }
    [CompilationMappingAttribute("9")]
internal static Layout comma { get; }
    [CompilationMappingAttribute("9")]
internal static Layout space { get; }
    [CompilationMappingAttribute("9")]
internal static Layout leftBracket { get; }
    [CompilationMappingAttribute("9")]
internal static Layout leftAngle { get; }
    [CompilationMappingAttribute("9")]
internal static Layout lineBreak { get; }
    [CompilationMappingAttribute("9")]
internal static Layout rightParen { get; }
    internal static Layout get_dot();
    internal static Layout get_star();
    internal static Layout get_colon();
    internal static Layout get_questionMark();
    internal static Layout get_leftParen();
    internal static Layout get_comma();
    internal static Layout get_space();
    internal static Layout get_leftBracket();
    internal static Layout get_leftAngle();
    internal static Layout get_lineBreak();
    internal static Layout get_rightParen();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Text.SourceText : object {
    public static ISourceText ofString(string str);
}
[DefaultMemberAttribute("Item")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Text.StringText : object {
    internal string str;
    internal Lazy`1<String[]> getLines@50;
    internal string String { get; }
    public StringText(string str);
    internal string get_String();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private virtual override char FSharp.Compiler.Text.ISourceText.get_Item(int index);
    private virtual override Tuple`2<int, int> FSharp.Compiler.Text.ISourceText.GetLastCharacterPosition();
    private virtual override string FSharp.Compiler.Text.ISourceText.GetLineString(int lineIndex);
    private virtual override int FSharp.Compiler.Text.ISourceText.GetLineCount();
    private virtual override string FSharp.Compiler.Text.ISourceText.GetSubTextString(int start, int length);
    private virtual override bool FSharp.Compiler.Text.ISourceText.SubTextEquals(string target, int startIndex);
    private virtual override int FSharp.Compiler.Text.ISourceText.get_Length();
    private virtual override bool FSharp.Compiler.Text.ISourceText.ContentEquals(ISourceText sourceText);
    private virtual override void FSharp.Compiler.Text.ISourceText.CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [CompilerGeneratedAttribute]
internal String[] getLines(string str);
}
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Text.TaggedText : object {
    internal string text;
    internal TextTag tag;
    public TextTag Tag { get; }
    public string Text { get; }
    public TaggedText(TextTag tag, string text);
    public TextTag get_Tag();
    public string get_Text();
    public virtual string ToString();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Text.TaggedTextModule : object {
    [CompilationMappingAttribute("9")]
internal static TaggedText leftParen { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText rightParen { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-1 { get; }
    [CompilationMappingAttribute("9")]
public static TaggedText comma { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-2 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText semicolon { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-3 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText questionMark { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-4 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText leftBracket { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-5 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText rightBracket { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-6 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText leftBrace { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-7 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText rightBrace { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-8 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText equals { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-9 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpSet`1<string> keywordFunctions { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<string> arg@1 { get; }
    [CompilationMappingAttribute("9")]
public static TaggedText lineBreak { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-10 { get; }
    [CompilationMappingAttribute("9")]
public static TaggedText space { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-11 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText leftBraceBar { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-12 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText rightBraceBar { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-13 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText arrow { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-14 { get; }
    [CompilationMappingAttribute("9")]
public static TaggedText dot { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-15 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText leftAngle { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-16 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText rightAngle { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-17 { get; }
    [CompilationMappingAttribute("9")]
public static TaggedText colon { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-18 { get; }
    [CompilationMappingAttribute("9")]
public static TaggedText minus { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-19 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordTrue { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-20 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordFalse { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-21 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText structUnit { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-22 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordStatic { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-23 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordMember { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-24 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordVal { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-25 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordEvent { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-26 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordWith { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-27 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordSet { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-28 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordGet { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-29 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText bar { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-30 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordStruct { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-31 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordClass { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-32 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordInterface { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-33 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordInherit { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-34 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordEnd { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-35 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordBegin { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-36 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordNested { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-37 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordType { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-38 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordDelegate { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-39 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordOf { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-40 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordInternal { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-41 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordPrivate { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-42 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordAbstract { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-43 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordOverride { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-44 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordEnum { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-45 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText leftBracketBar { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-46 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText rightBracketBar { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-47 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordTypeof { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-48 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordTypedefof { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-49 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText leftBracketAngle { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-50 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText rightBracketAngle { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-51 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText star { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-52 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordNew { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-53 { get; }
    [CompilationMappingAttribute("9")]
internal static TaggedText keywordInline { get; }
    [CompilationMappingAttribute("9")]
internal static TextTag tag@121-54 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedText mkTag(TextTag tag, string text);
    public static TaggedText tagClass(string name);
    internal static TaggedText tagUnionCase(string t);
    internal static TaggedText tagField(string t);
    internal static TaggedText tagNumericLiteral(string t);
    internal static TaggedText tagKeyword(string t);
    internal static TaggedText tagStringLiteral(string t);
    internal static TaggedText tagLocal(string t);
    public static TaggedText tagText(string t);
    internal static TaggedText tagRecordField(string t);
    internal static TaggedText tagProperty(string t);
    internal static TaggedText tagMethod(string t);
    internal static TaggedText tagPunctuation(string t);
    internal static TaggedText tagOperator(string t);
    internal static TaggedText get_leftParen();
    internal static TextTag get_tag@121();
    internal static TaggedText get_rightParen();
    internal static TextTag get_tag@121-1();
    public static TaggedText get_comma();
    internal static TextTag get_tag@121-2();
    internal static TaggedText get_semicolon();
    internal static TextTag get_tag@121-3();
    internal static TaggedText get_questionMark();
    internal static TextTag get_tag@121-4();
    internal static TaggedText get_leftBracket();
    internal static TextTag get_tag@121-5();
    internal static TaggedText get_rightBracket();
    internal static TextTag get_tag@121-6();
    internal static TaggedText get_leftBrace();
    internal static TextTag get_tag@121-7();
    internal static TaggedText get_rightBrace();
    internal static TextTag get_tag@121-8();
    internal static TaggedText get_equals();
    internal static TextTag get_tag@121-9();
    internal static TaggedText tagAlias(string t);
    internal static FSharpSet`1<string> get_keywordFunctions();
    internal static FSharpList`1<string> get_arg@1();
    internal static TaggedText tagDelegate(string t);
    internal static TaggedText tagEnum(string t);
    internal static TaggedText tagEvent(string t);
    internal static TaggedText tagInterface(string t);
    internal static TaggedText tagLineBreak(string t);
    internal static TaggedText tagRecord(string t);
    internal static TaggedText tagModule(string t);
    internal static TaggedText tagModuleBinding(string name);
    internal static TaggedText tagFunction(string t);
    public static TaggedText tagNamespace(string t);
    public static TaggedText tagParameter(string t);
    public static TaggedText tagSpace(string t);
    internal static TaggedText tagStruct(string t);
    internal static TaggedText tagTypeParameter(string t);
    internal static TaggedText tagActivePatternCase(string t);
    internal static TaggedText tagActivePatternResult(string t);
    internal static TaggedText tagUnion(string t);
    internal static TaggedText tagMember(string t);
    internal static TaggedText tagUnknownEntity(string t);
    internal static TaggedText tagUnknownType(string t);
    public static TaggedText get_lineBreak();
    internal static TextTag get_tag@121-10();
    public static TaggedText get_space();
    internal static TextTag get_tag@121-11();
    internal static TaggedText get_leftBraceBar();
    internal static TextTag get_tag@121-12();
    internal static TaggedText get_rightBraceBar();
    internal static TextTag get_tag@121-13();
    internal static TaggedText get_arrow();
    internal static TextTag get_tag@121-14();
    public static TaggedText get_dot();
    internal static TextTag get_tag@121-15();
    internal static TaggedText get_leftAngle();
    internal static TextTag get_tag@121-16();
    internal static TaggedText get_rightAngle();
    internal static TextTag get_tag@121-17();
    public static TaggedText get_colon();
    internal static TextTag get_tag@121-18();
    public static TaggedText get_minus();
    internal static TextTag get_tag@121-19();
    internal static TaggedText get_keywordTrue();
    internal static TextTag get_tag@121-20();
    internal static TaggedText get_keywordFalse();
    internal static TextTag get_tag@121-21();
    internal static TaggedText get_structUnit();
    internal static TextTag get_tag@121-22();
    internal static TaggedText get_keywordStatic();
    internal static TextTag get_tag@121-23();
    internal static TaggedText get_keywordMember();
    internal static TextTag get_tag@121-24();
    internal static TaggedText get_keywordVal();
    internal static TextTag get_tag@121-25();
    internal static TaggedText get_keywordEvent();
    internal static TextTag get_tag@121-26();
    internal static TaggedText get_keywordWith();
    internal static TextTag get_tag@121-27();
    internal static TaggedText get_keywordSet();
    internal static TextTag get_tag@121-28();
    internal static TaggedText get_keywordGet();
    internal static TextTag get_tag@121-29();
    internal static TaggedText get_bar();
    internal static TextTag get_tag@121-30();
    internal static TaggedText get_keywordStruct();
    internal static TextTag get_tag@121-31();
    internal static TaggedText get_keywordClass();
    internal static TextTag get_tag@121-32();
    internal static TaggedText get_keywordInterface();
    internal static TextTag get_tag@121-33();
    internal static TaggedText get_keywordInherit();
    internal static TextTag get_tag@121-34();
    internal static TaggedText get_keywordEnd();
    internal static TextTag get_tag@121-35();
    internal static TaggedText get_keywordBegin();
    internal static TextTag get_tag@121-36();
    internal static TaggedText get_keywordNested();
    internal static TextTag get_tag@121-37();
    internal static TaggedText get_keywordType();
    internal static TextTag get_tag@121-38();
    internal static TaggedText get_keywordDelegate();
    internal static TextTag get_tag@121-39();
    internal static TaggedText get_keywordOf();
    internal static TextTag get_tag@121-40();
    internal static TaggedText get_keywordInternal();
    internal static TextTag get_tag@121-41();
    internal static TaggedText get_keywordPrivate();
    internal static TextTag get_tag@121-42();
    internal static TaggedText get_keywordAbstract();
    internal static TextTag get_tag@121-43();
    internal static TaggedText get_keywordOverride();
    internal static TextTag get_tag@121-44();
    internal static TaggedText get_keywordEnum();
    internal static TextTag get_tag@121-45();
    internal static TaggedText get_leftBracketBar();
    internal static TextTag get_tag@121-46();
    internal static TaggedText get_rightBracketBar();
    internal static TextTag get_tag@121-47();
    internal static TaggedText get_keywordTypeof();
    internal static TextTag get_tag@121-48();
    internal static TaggedText get_keywordTypedefof();
    internal static TextTag get_tag@121-49();
    internal static TaggedText get_leftBracketAngle();
    internal static TextTag get_tag@121-50();
    internal static TaggedText get_rightBracketAngle();
    internal static TextTag get_tag@121-51();
    internal static TaggedText get_star();
    internal static TextTag get_tag@121-52();
    internal static TaggedText get_keywordNew();
    internal static TextTag get_tag@121-53();
    internal static TaggedText get_keywordInline();
    internal static TextTag get_tag@121-54();
}
[CompilationMappingAttribute("3")]
internal interface FSharp.Compiler.Text.TaggedTextWriter {
    public abstract virtual void Write(TaggedText t);
    public abstract virtual void WriteLine();
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[RequireQualifiedAccessAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Text.TextTag : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_ActivePatternCase;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_ActivePatternResult;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Alias;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Union;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_UnionCase;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Delegate;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Enum;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Event;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Field;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Keyword;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_LineBreak;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Local;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Record;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_RecordField;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Method;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Member;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_ModuleBinding;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Function;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_NumericLiteral;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Operator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Parameter;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Property;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Space;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_StringLiteral;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Struct;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_TypeParameter;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Text;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_Punctuation;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_UnknownType;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static TextTag _unique_UnknownEntity;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag ActivePatternCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsActivePatternCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag ActivePatternResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsActivePatternResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Alias { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAlias { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Union { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnion { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag UnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnionCase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Delegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Enum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnum { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Event { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEvent { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Field { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Keyword { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsKeyword { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag LineBreak { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLineBreak { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Local { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLocal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Record { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecord { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag RecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRecordField { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Method { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMethod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Member { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag ModuleBinding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModuleBinding { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Function { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFunction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag NumericLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNumericLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Operator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Parameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Property { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsProperty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Space { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSpace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag StringLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStringLiteral { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Struct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStruct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag TypeParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTypeParameter { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Text { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag Punctuation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPunctuation { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag UnknownType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknownType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static TextTag UnknownEntity { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnknownEntity { get; }
    private static TextTag();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Text.TextTag")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TextTag(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static TextTag get_ActivePatternCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsActivePatternCase();
    [CompilationMappingAttribute("8", "1")]
public static TextTag get_ActivePatternResult();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsActivePatternResult();
    [CompilationMappingAttribute("8", "2")]
public static TextTag get_Alias();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAlias();
    [CompilationMappingAttribute("8", "3")]
public static TextTag get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "4")]
public static TextTag get_Union();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnion();
    [CompilationMappingAttribute("8", "5")]
public static TextTag get_UnionCase();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnionCase();
    [CompilationMappingAttribute("8", "6")]
public static TextTag get_Delegate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDelegate();
    [CompilationMappingAttribute("8", "7")]
public static TextTag get_Enum();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnum();
    [CompilationMappingAttribute("8", "8")]
public static TextTag get_Event();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEvent();
    [CompilationMappingAttribute("8", "9")]
public static TextTag get_Field();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsField();
    [CompilationMappingAttribute("8", "10")]
public static TextTag get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "11")]
public static TextTag get_Keyword();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsKeyword();
    [CompilationMappingAttribute("8", "12")]
public static TextTag get_LineBreak();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLineBreak();
    [CompilationMappingAttribute("8", "13")]
public static TextTag get_Local();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLocal();
    [CompilationMappingAttribute("8", "14")]
public static TextTag get_Record();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecord();
    [CompilationMappingAttribute("8", "15")]
public static TextTag get_RecordField();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRecordField();
    [CompilationMappingAttribute("8", "16")]
public static TextTag get_Method();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMethod();
    [CompilationMappingAttribute("8", "17")]
public static TextTag get_Member();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMember();
    [CompilationMappingAttribute("8", "18")]
public static TextTag get_ModuleBinding();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModuleBinding();
    [CompilationMappingAttribute("8", "19")]
public static TextTag get_Function();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFunction();
    [CompilationMappingAttribute("8", "20")]
public static TextTag get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "21")]
public static TextTag get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "22")]
public static TextTag get_NumericLiteral();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNumericLiteral();
    [CompilationMappingAttribute("8", "23")]
public static TextTag get_Operator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOperator();
    [CompilationMappingAttribute("8", "24")]
public static TextTag get_Parameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsParameter();
    [CompilationMappingAttribute("8", "25")]
public static TextTag get_Property();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsProperty();
    [CompilationMappingAttribute("8", "26")]
public static TextTag get_Space();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSpace();
    [CompilationMappingAttribute("8", "27")]
public static TextTag get_StringLiteral();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStringLiteral();
    [CompilationMappingAttribute("8", "28")]
public static TextTag get_Struct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStruct();
    [CompilationMappingAttribute("8", "29")]
public static TextTag get_TypeParameter();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTypeParameter();
    [CompilationMappingAttribute("8", "30")]
public static TextTag get_Text();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsText();
    [CompilationMappingAttribute("8", "31")]
public static TextTag get_Punctuation();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPunctuation();
    [CompilationMappingAttribute("8", "32")]
public static TextTag get_UnknownType();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknownType();
    [CompilationMappingAttribute("8", "33")]
public static TextTag get_UnknownEntity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnknownEntity();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TextTag obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Text.WordL : object {
    [CompilationMappingAttribute("9")]
internal static Layout arrow { get; }
    [CompilationMappingAttribute("9")]
internal static Layout star { get; }
    [CompilationMappingAttribute("9")]
internal static Layout colon { get; }
    [CompilationMappingAttribute("9")]
internal static Layout equals { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordNew { get; }
    [CompilationMappingAttribute("9")]
internal static Layout structUnit { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordStatic { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordMember { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordVal { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordEvent { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordWith { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordSet { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordGet { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordTrue { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordFalse { get; }
    [CompilationMappingAttribute("9")]
internal static Layout bar { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordStruct { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordClass { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordInterface { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordInherit { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordBegin { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordEnd { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordNested { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordType { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordDelegate { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordOf { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordInternal { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordPrivate { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordAbstract { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordOverride { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordEnum { get; }
    [CompilationMappingAttribute("9")]
internal static Layout keywordInline { get; }
    internal static Layout get_arrow();
    internal static Layout get_star();
    internal static Layout get_colon();
    internal static Layout get_equals();
    internal static Layout get_keywordNew();
    internal static Layout get_structUnit();
    internal static Layout get_keywordStatic();
    internal static Layout get_keywordMember();
    internal static Layout get_keywordVal();
    internal static Layout get_keywordEvent();
    internal static Layout get_keywordWith();
    internal static Layout get_keywordSet();
    internal static Layout get_keywordGet();
    internal static Layout get_keywordTrue();
    internal static Layout get_keywordFalse();
    internal static Layout get_bar();
    internal static Layout get_keywordStruct();
    internal static Layout get_keywordClass();
    internal static Layout get_keywordInterface();
    internal static Layout get_keywordInherit();
    internal static Layout get_keywordBegin();
    internal static Layout get_keywordEnd();
    internal static Layout get_keywordNested();
    internal static Layout get_keywordType();
    internal static Layout get_keywordDelegate();
    internal static Layout get_keywordOf();
    internal static Layout get_keywordInternal();
    internal static Layout get_keywordPrivate();
    internal static Layout get_keywordAbstract();
    internal static Layout get_keywordOverride();
    internal static Layout get_keywordEnum();
    internal static Layout get_keywordInline();
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Tokenization.FSharpKeywords : object {
    [CompilationMappingAttribute("9")]
public static FSharpList`1<Tuple`2<string, string>> KeywordsWithDescription { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, FSharpOption`1<string>> KeywordsDescriptionLookup { get; }
    [CompilationMappingAttribute("9")]
internal static IDictionary`2<string, string> d@1269 { get; }
    [CompilationMappingAttribute("9")]
public static FSharpList`1<string> KeywordNames { get; }
    public static string NormalizeIdentifierBackticks(string s);
    public static FSharpList`1<Tuple`2<string, string>> get_KeywordsWithDescription();
    internal static FSharpFunc`2<string, FSharpOption`1<string>> get_KeywordsDescriptionLookup();
    internal static IDictionary`2<string, string> get_d@1269();
    public static FSharpList`1<string> get_KeywordNames();
}
[AbstractClassAttribute]
[SealedAttribute]
[ExperimentalAttribute("This FCS API is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
public static class FSharp.Compiler.Tokenization.FSharpLexer : object {
    [ExperimentalAttribute("This FCS API is experimental and subject to change.")]
public static void Tokenize(ISourceText text, FSharpFunc`2<FSharpToken, Unit> tokenCallback, FSharpOption`1<string> langVersion, FSharpOption`1<bool> strictIndentation, FSharpOption`1<string> filePath, FSharpOption`1<FSharpList`1<string>> conditionalDefines, FSharpOption`1<FSharpLexerFlags> flags, FSharpOption`1<FSharpMap`2<string, string>> pathMap, FSharpOption`1<CancellationToken> ct);
}
[FlagsAttribute]
[ExperimentalAttribute("This FCS API is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.Tokenization.FSharpLexerFlags : Enum {
    public int value__;
    public static FSharpLexerFlags Default;
    public static FSharpLexerFlags LightSyntaxOn;
    public static FSharpLexerFlags Compiling;
    public static FSharpLexerFlags CompilingFSharpCore;
    public static FSharpLexerFlags SkipTrivia;
    public static FSharpLexerFlags UseLexFilter;
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Tokenization.FSharpLexerImpl : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void lexWithDiagnosticsLogger(ISourceText text, FSharpList`1<string> conditionalDefines, FSharpLexerFlags flags, bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, DiagnosticsLogger diagnosticsLogger, FSharpFunc`2<token, FSharpFunc`2<Range, Unit>> onToken, PathMap pathMap, CancellationToken ct);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void lex(ISourceText text, FSharpList`1<string> conditionalDefines, FSharpLexerFlags flags, bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, FSharpFunc`2<token, FSharpFunc`2<Range, Unit>> lexCallback, PathMap pathMap, CancellationToken ct);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Tokenization.FSharpLineTokenizer : object {
    internal FSharpOption`1<int> maxLength;
    internal LexBuffer`1<char> lexbuf;
    internal LexArgs lexargs;
    internal bool skip;
    internal SingleLineTokenState singleLineTokenState;
    internal bool fsx;
    internal Stack`1<Tuple`3<token, int, int>> tokenStack;
    internal FSharpLineTokenizer(LexBuffer`1<char> lexbuf, FSharpOption`1<int> maxLength, FSharpOption`1<string> fileName, LexArgs lexargs);
    public Tuple`2<FSharpOption`1<FSharpTokenInfo>, FSharpTokenizerLexState> ScanToken(FSharpTokenizerLexState lexState);
    public static FSharpTokenizerColorState ColorStateOfLexState(FSharpTokenizerLexState lexState);
    public static FSharpTokenizerLexState LexStateOfColorState(FSharpTokenizerColorState colorState);
    [CompilerGeneratedAttribute]
internal void delayToken(token tok_0, int tok_1, int tok_2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int processDirective(string str, int directiveLength, FSharpFunc`2<Tuple`3<token, int, int>, Unit> delay, LexerContinuation cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal void processWhiteAndComment(string str, int offset, FSharpFunc`2<Tuple`3<token, int, int>, Unit> delay, LexerContinuation cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`3<token, int, int> processDirectiveLine(int ofs, FSharpFunc`2<FSharpFunc`2<Tuple`3<token, int, int>, Unit>, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`3<token, int, int> processHashEndElse(int ofs, string str, int length, LexerContinuation cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`3<token, int, int> processHashIfLine(int ofs, string str, LexerContinuation cont);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal token callLexCont(LexerContinuation lexcont, IndentationAwareSyntaxStatus indentationSyntaxStatus, bool skip);
    [CompilerGeneratedAttribute]
internal ValueTuple`2<int, int> columnsOfCurrentToken();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal Tuple`2<bool, Tuple`3<token, int, int>> getTokenWithPosition(LexerContinuation lexcont, IndentationAwareSyntaxStatus indentationSyntaxStatus);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Tokenization.FSharpSourceTokenizer : object {
    internal FSharpOption`1<bool> strictIndentation;
    internal FSharpOption`1<string> fileName;
    internal LanguageVersion langVersion@1226;
    internal bool reportLibraryOnlyFeatures;
    internal LexArgs lexargs;
    public FSharpSourceTokenizer(FSharpList`1<string> conditionalDefines, FSharpOption`1<string> fileName, FSharpOption`1<string> langVersion, FSharpOption`1<bool> strictIndentation);
    public FSharpLineTokenizer CreateLineTokenizer(string lineText);
    public FSharpLineTokenizer CreateBufferTokenizer(FSharpFunc`2<Tuple`3<Char[], int, int>, int> bufferFiller);
}
[StructAttribute]
[NoComparisonAttribute]
[NoEqualityAttribute]
[ExperimentalAttribute("This FCS API is experimental and subject to change.")]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Tokenization.FSharpToken : ValueType {
    internal token tok@;
    internal Range tokRange@;
    [CompilationMappingAttribute("4", "0")]
internal token tok { get; }
    [CompilationMappingAttribute("4", "1")]
internal Range tokRange { get; }
    public Range Range { get; }
    public FSharpTokenKind Kind { get; }
    public bool IsKeyword { get; }
    public bool IsIdentifier { get; }
    public bool IsStringLiteral { get; }
    public bool IsNumericLiteral { get; }
    public bool IsCommentTrivia { get; }
    internal FSharpToken(token tok, Range tokRange);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal token get_tok();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Range get_tokRange();
    public Range get_Range();
    public FSharpTokenKind get_Kind();
    public bool get_IsKeyword();
    public bool get_IsIdentifier();
    public bool get_IsStringLiteral();
    public bool get_IsNumericLiteral();
    public bool get_IsCommentTrivia();
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.Tokenization.FSharpTokenCharKind : Enum {
    public int value__;
    public static FSharpTokenCharKind Default;
    public static FSharpTokenCharKind Text;
    public static FSharpTokenCharKind Keyword;
    public static FSharpTokenCharKind Identifier;
    public static FSharpTokenCharKind String;
    public static FSharpTokenCharKind Literal;
    public static FSharpTokenCharKind Operator;
    public static FSharpTokenCharKind Delimiter;
    public static FSharpTokenCharKind WhiteSpace;
    public static FSharpTokenCharKind LineComment;
    public static FSharpTokenCharKind Comment;
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.Tokenization.FSharpTokenColorKind : Enum {
    public int value__;
    public static FSharpTokenColorKind Default;
    public static FSharpTokenColorKind Text;
    public static FSharpTokenColorKind Keyword;
    public static FSharpTokenColorKind Comment;
    public static FSharpTokenColorKind Identifier;
    public static FSharpTokenColorKind String;
    public static FSharpTokenColorKind UpperIdentifier;
    public static FSharpTokenColorKind InactiveCode;
    public static FSharpTokenColorKind PreprocessorKeyword;
    public static FSharpTokenColorKind Number;
    public static FSharpTokenColorKind Operator;
    public static FSharpTokenColorKind Punctuation;
}
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.Tokenization.FSharpTokenInfo : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int LeftColumn@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int RightColumn@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpTokenColorKind ColorClass@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpTokenCharKind CharClass@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpTokenTriggerClass FSharpTokenTriggerClass@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal string TokenName@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int FullMatchedLength@;
    [CompilationMappingAttribute("4", "0")]
public int LeftColumn { get; }
    [CompilationMappingAttribute("4", "1")]
public int RightColumn { get; }
    [CompilationMappingAttribute("4", "2")]
public FSharpTokenColorKind ColorClass { get; }
    [CompilationMappingAttribute("4", "3")]
public FSharpTokenCharKind CharClass { get; }
    [CompilationMappingAttribute("4", "4")]
public FSharpTokenTriggerClass FSharpTokenTriggerClass { get; }
    [CompilationMappingAttribute("4", "5")]
public int Tag { get; }
    [CompilationMappingAttribute("4", "6")]
public string TokenName { get; }
    [CompilationMappingAttribute("4", "7")]
public int FullMatchedLength { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Tokenization.FSharpTokenInfo")]
public FSharpTokenInfo(int leftColumn, int rightColumn, FSharpTokenColorKind colorClass, FSharpTokenCharKind charClass, FSharpTokenTriggerClass fSharpTokenTriggerClass, int tag, string tokenName, int fullMatchedLength);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_LeftColumn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_RightColumn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpTokenColorKind get_ColorClass();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpTokenCharKind get_CharClass();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public FSharpTokenTriggerClass get_FSharpTokenTriggerClass();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public string get_TokenName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_FullMatchedLength();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpTokenInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpTokenInfo obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.Tokenization.FSharpTokenizerColorState : Enum {
    public int value__;
    public static FSharpTokenizerColorState Token;
    public static FSharpTokenizerColorState IfDefSkip;
    public static FSharpTokenizerColorState String;
    public static FSharpTokenizerColorState Comment;
    public static FSharpTokenizerColorState StringInComment;
    public static FSharpTokenizerColorState VerbatimStringInComment;
    public static FSharpTokenizerColorState CamlOnly;
    public static FSharpTokenizerColorState VerbatimString;
    public static FSharpTokenizerColorState SingleLineComment;
    public static FSharpTokenizerColorState EndLineThenSkip;
    public static FSharpTokenizerColorState EndLineThenToken;
    public static FSharpTokenizerColorState TripleQuoteString;
    public static FSharpTokenizerColorState TripleQuoteStringInComment;
    public static FSharpTokenizerColorState ExtendedInterpolatedString;
    public static FSharpTokenizerColorState InitialState;
}
[StructAttribute]
[CustomEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("2")]
public class FSharp.Compiler.Tokenization.FSharpTokenizerLexState : ValueType {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal long PosBits@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal long OtherBits@;
    [CompilationMappingAttribute("4", "0")]
public long PosBits { get; }
    [CompilationMappingAttribute("4", "1")]
public long OtherBits { get; }
    public static FSharpTokenizerLexState Initial { get; }
    [DynamicDependencyAttribute("1632", "FSharp.Compiler.Tokenization.FSharpTokenizerLexState")]
public FSharpTokenizerLexState(long posBits, long otherBits);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public long get_PosBits();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public long get_OtherBits();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    public static FSharpTokenizerLexState get_Initial();
    public bool Equals(FSharpTokenizerLexState other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[RequireQualifiedAccessAttribute]
[ExperimentalAttribute("This FCS API is experimental and subject to change.")]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("1")]
public class FSharp.Compiler.Tokenization.FSharpTokenKind : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_None;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_HashIf;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_HashElse;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_HashEndIf;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_CommentTrivia;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_WhitespaceTrivia;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_HashLine;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_HashLight;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InactiveCode;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LineCommentTrivia;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_StringText;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Fixed;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideInterfaceMember;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideBlockEnd;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideRightBlockEnd;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideDeclEnd;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideEnd;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideBlockSep;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideBlockBegin;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideReset;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideFun;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideFunction;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideWith;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideElse;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideThen;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideDoBang;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideDo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideBinder;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideLet;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_HighPrecedenceTypeApp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_HighPrecedenceParenthesisApp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_HighPrecedenceBracketApp;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Extern;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Void;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Public;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Private;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Internal;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Global;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Static;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Member;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Class;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Abstract;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Override;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Default;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Constructor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Inherit;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_GreaterRightBracket;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Struct;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Sig;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Bar;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_RightBracket;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_RightBrace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Minus;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Dollar;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_BarRightBracket;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_BarRightBrace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Underscore;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Semicolon;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_SemicolonSemicolon;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftArrow;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Equals;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftBracket;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftBracketBar;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftBraceBar;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftBracketLess;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftBrace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_QuestionMark;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_QuestionMarkQuestionMark;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Dot;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Colon;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_ColonColon;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_ColonGreater;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_ColonQuestionMark;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_ColonQuestionMarkGreater;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_ColonEquals;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_When;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_While;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_WhileBang;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_With;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Hash;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Ampersand;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_AmpersandAmpersand;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Quote;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftParenthesis;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_RightParenthesis;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Star;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Comma;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_RightArrow;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_GreaterBarRightBracket;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftParenthesisStarRightParenthesis;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Open;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Or;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Rec;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Then;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_To;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_True;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Try;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Type;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Val;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Inline;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Interface;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Instance;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Const;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Lazy;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideLazy;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Match;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_MatchBang;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Mutable;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_New;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Of;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_False;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_For;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Fun;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Function;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_If;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_In;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_JoinIn;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Finally;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_DoBang;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_And;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_As;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Assert;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_OffsideAssert;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Begin;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Do;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Done;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_DownTo;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Else;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Elif;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_End;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_DotDot;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_DotDotHat;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_BarBar;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Upcast;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Downcast;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Null;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Reserved;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Module;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Namespace;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Delegate;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Constraint;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Base;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_LeftQuote;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_RightQuote;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_RightQuoteDot;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_PercentOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Binder;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Less;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Greater;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Let;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Yield;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_YieldBang;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_BigNumber;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Decimal;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Char;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Ieee64;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Ieee32;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_NativeInt;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_UNativeInt;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_UInt64;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_UInt32;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_UInt16;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_UInt8;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Int64;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Int32;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Int32DotDot;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Int16;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Int8;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_FunkyOperatorName;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_AdjacentPrefixOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_PlusMinusOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixAmpersandOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixStarDivideModuloOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_PrefixOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixBarOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixAtHatOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixCompareOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixStarStarOperator;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Identifier;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_KeywordString;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_String;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_ByteArray;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_Asr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixAsr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixLand;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixLor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixLsl;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixLsr;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixLxor;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpTokenKind _unique_InfixMod;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind None { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind HashIf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashIf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind HashElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind HashEndIf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashEndIf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind CommentTrivia { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsCommentTrivia { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind WhitespaceTrivia { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhitespaceTrivia { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind HashLine { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashLine { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind HashLight { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHashLight { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InactiveCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInactiveCode { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LineCommentTrivia { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLineCommentTrivia { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind StringText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStringText { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Fixed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFixed { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideInterfaceMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideInterfaceMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideBlockEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideBlockEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideRightBlockEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideRightBlockEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideDeclEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideDeclEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideBlockSep { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideBlockSep { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideBlockBegin { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideBlockBegin { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideReset { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideReset { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideFun { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideFun { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideFunction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideFunction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideWith { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideWith { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideThen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideThen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideDoBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideDoBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideDo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideDo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideBinder { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideBinder { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind HighPrecedenceTypeApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHighPrecedenceTypeApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind HighPrecedenceParenthesisApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHighPrecedenceParenthesisApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind HighPrecedenceBracketApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHighPrecedenceBracketApp { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Extern { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsExtern { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Void { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVoid { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Public { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPublic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Private { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPrivate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Internal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInternal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Global { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGlobal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Static { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStatic { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Member { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMember { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Class { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsClass { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Abstract { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAbstract { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Override { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOverride { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Default { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDefault { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Constructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstructor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Inherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInherit { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind GreaterRightBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGreaterRightBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Struct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStruct { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Sig { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSig { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Bar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind RightBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRightBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind RightBrace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRightBrace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Minus { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMinus { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Dollar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDollar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind BarRightBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBarRightBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind BarRightBrace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBarRightBrace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Underscore { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUnderscore { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Semicolon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSemicolon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind SemicolonSemicolon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsSemicolonSemicolon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftArrow { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftArrow { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Equals { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEquals { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftBracketBar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftBracketBar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftBraceBar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftBraceBar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftBracketLess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftBracketLess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftBrace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftBrace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind QuestionMark { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsQuestionMark { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind QuestionMarkQuestionMark { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsQuestionMarkQuestionMark { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Dot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Colon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsColon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind ColonColon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsColonColon { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind ColonGreater { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsColonGreater { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind ColonQuestionMark { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsColonQuestionMark { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind ColonQuestionMarkGreater { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsColonQuestionMarkGreater { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind ColonEquals { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsColonEquals { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind When { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind While { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhile { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind WhileBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWhileBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind With { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsWith { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Hash { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsHash { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Ampersand { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAmpersand { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind AmpersandAmpersand { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAmpersandAmpersand { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Quote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftParenthesis { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftParenthesis { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind RightParenthesis { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRightParenthesis { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Star { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsStar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Comma { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsComma { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind RightArrow { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRightArrow { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind GreaterBarRightBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGreaterBarRightBracket { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftParenthesisStarRightParenthesis { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftParenthesisStarRightParenthesis { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Open { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOpen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Or { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Rec { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRec { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Then { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsThen { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind To { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind True { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTrue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Try { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsTry { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Val { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsVal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Inline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInline { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Interface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInterface { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Instance { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInstance { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Const { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConst { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Lazy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLazy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideLazy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideLazy { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Match { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMatch { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind MatchBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMatchBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Mutable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsMutable { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind New { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNew { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Of { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Exception { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsException { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind False { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFalse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind For { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Fun { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFun { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Function { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFunction { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind If { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIf { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind In { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind JoinIn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsJoinIn { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Finally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFinally { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind DoBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDoBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind And { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind As { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAs { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Assert { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAssert { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind OffsideAssert { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsOffsideAssert { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Begin { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBegin { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Do { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Done { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDone { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind DownTo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDownTo { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Else { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsElse { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Elif { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsElif { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind End { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsEnd { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind DotDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind DotDotHat { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDotDotHat { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind BarBar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBarBar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Upcast { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUpcast { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Downcast { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDowncast { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Null { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNull { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Reserved { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsReserved { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Module { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsModule { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Namespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNamespace { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Delegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDelegate { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Constraint { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsConstraint { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Base { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBase { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind LeftQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLeftQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind RightQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRightQuote { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind RightQuoteDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsRightQuoteDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind PercentOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPercentOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Binder { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBinder { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Less { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLess { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Greater { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsGreater { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Let { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsLet { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Yield { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYield { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind YieldBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsYieldBang { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind BigNumber { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsBigNumber { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Decimal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsDecimal { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Char { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsChar { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Ieee64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIeee64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Ieee32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIeee32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind NativeInt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsNativeInt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind UNativeInt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUNativeInt { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind UInt64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind UInt32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind UInt16 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt16 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind UInt8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsUInt8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Int64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt64 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Int32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt32 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Int32DotDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt32DotDot { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Int16 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt16 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Int8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInt8 { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind FunkyOperatorName { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsFunkyOperatorName { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind AdjacentPrefixOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAdjacentPrefixOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind PlusMinusOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPlusMinusOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixAmpersandOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixAmpersandOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixStarDivideModuloOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixStarDivideModuloOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind PrefixOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsPrefixOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixBarOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixBarOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixAtHatOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixAtHatOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixCompareOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixCompareOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixStarStarOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixStarStarOperator { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Identifier { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsIdentifier { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind KeywordString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsKeywordString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind String { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsString { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind ByteArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsByteArray { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind Asr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsAsr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixAsr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixAsr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixLand { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixLand { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixLor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixLor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixLsl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixLsl { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixLsr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixLsr { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixLxor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixLxor { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public static FSharpTokenKind InfixMod { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
public bool IsInfixMod { get; }
    private static FSharpTokenKind();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Tokenization.FSharpTokenKind")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpTokenKind(int _tag);
    [CompilationMappingAttribute("8", "0")]
public static FSharpTokenKind get_None();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNone();
    [CompilationMappingAttribute("8", "1")]
public static FSharpTokenKind get_HashIf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashIf();
    [CompilationMappingAttribute("8", "2")]
public static FSharpTokenKind get_HashElse();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashElse();
    [CompilationMappingAttribute("8", "3")]
public static FSharpTokenKind get_HashEndIf();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashEndIf();
    [CompilationMappingAttribute("8", "4")]
public static FSharpTokenKind get_CommentTrivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsCommentTrivia();
    [CompilationMappingAttribute("8", "5")]
public static FSharpTokenKind get_WhitespaceTrivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhitespaceTrivia();
    [CompilationMappingAttribute("8", "6")]
public static FSharpTokenKind get_HashLine();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashLine();
    [CompilationMappingAttribute("8", "7")]
public static FSharpTokenKind get_HashLight();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHashLight();
    [CompilationMappingAttribute("8", "8")]
public static FSharpTokenKind get_InactiveCode();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInactiveCode();
    [CompilationMappingAttribute("8", "9")]
public static FSharpTokenKind get_LineCommentTrivia();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLineCommentTrivia();
    [CompilationMappingAttribute("8", "10")]
public static FSharpTokenKind get_StringText();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStringText();
    [CompilationMappingAttribute("8", "11")]
public static FSharpTokenKind get_Fixed();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFixed();
    [CompilationMappingAttribute("8", "12")]
public static FSharpTokenKind get_OffsideInterfaceMember();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideInterfaceMember();
    [CompilationMappingAttribute("8", "13")]
public static FSharpTokenKind get_OffsideBlockEnd();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideBlockEnd();
    [CompilationMappingAttribute("8", "14")]
public static FSharpTokenKind get_OffsideRightBlockEnd();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideRightBlockEnd();
    [CompilationMappingAttribute("8", "15")]
public static FSharpTokenKind get_OffsideDeclEnd();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideDeclEnd();
    [CompilationMappingAttribute("8", "16")]
public static FSharpTokenKind get_OffsideEnd();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideEnd();
    [CompilationMappingAttribute("8", "17")]
public static FSharpTokenKind get_OffsideBlockSep();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideBlockSep();
    [CompilationMappingAttribute("8", "18")]
public static FSharpTokenKind get_OffsideBlockBegin();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideBlockBegin();
    [CompilationMappingAttribute("8", "19")]
public static FSharpTokenKind get_OffsideReset();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideReset();
    [CompilationMappingAttribute("8", "20")]
public static FSharpTokenKind get_OffsideFun();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideFun();
    [CompilationMappingAttribute("8", "21")]
public static FSharpTokenKind get_OffsideFunction();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideFunction();
    [CompilationMappingAttribute("8", "22")]
public static FSharpTokenKind get_OffsideWith();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideWith();
    [CompilationMappingAttribute("8", "23")]
public static FSharpTokenKind get_OffsideElse();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideElse();
    [CompilationMappingAttribute("8", "24")]
public static FSharpTokenKind get_OffsideThen();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideThen();
    [CompilationMappingAttribute("8", "25")]
public static FSharpTokenKind get_OffsideDoBang();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideDoBang();
    [CompilationMappingAttribute("8", "26")]
public static FSharpTokenKind get_OffsideDo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideDo();
    [CompilationMappingAttribute("8", "27")]
public static FSharpTokenKind get_OffsideBinder();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideBinder();
    [CompilationMappingAttribute("8", "28")]
public static FSharpTokenKind get_OffsideLet();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideLet();
    [CompilationMappingAttribute("8", "29")]
public static FSharpTokenKind get_HighPrecedenceTypeApp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHighPrecedenceTypeApp();
    [CompilationMappingAttribute("8", "30")]
public static FSharpTokenKind get_HighPrecedenceParenthesisApp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHighPrecedenceParenthesisApp();
    [CompilationMappingAttribute("8", "31")]
public static FSharpTokenKind get_HighPrecedenceBracketApp();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHighPrecedenceBracketApp();
    [CompilationMappingAttribute("8", "32")]
public static FSharpTokenKind get_Extern();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsExtern();
    [CompilationMappingAttribute("8", "33")]
public static FSharpTokenKind get_Void();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVoid();
    [CompilationMappingAttribute("8", "34")]
public static FSharpTokenKind get_Public();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPublic();
    [CompilationMappingAttribute("8", "35")]
public static FSharpTokenKind get_Private();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPrivate();
    [CompilationMappingAttribute("8", "36")]
public static FSharpTokenKind get_Internal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInternal();
    [CompilationMappingAttribute("8", "37")]
public static FSharpTokenKind get_Global();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGlobal();
    [CompilationMappingAttribute("8", "38")]
public static FSharpTokenKind get_Static();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStatic();
    [CompilationMappingAttribute("8", "39")]
public static FSharpTokenKind get_Member();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMember();
    [CompilationMappingAttribute("8", "40")]
public static FSharpTokenKind get_Class();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsClass();
    [CompilationMappingAttribute("8", "41")]
public static FSharpTokenKind get_Abstract();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAbstract();
    [CompilationMappingAttribute("8", "42")]
public static FSharpTokenKind get_Override();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOverride();
    [CompilationMappingAttribute("8", "43")]
public static FSharpTokenKind get_Default();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDefault();
    [CompilationMappingAttribute("8", "44")]
public static FSharpTokenKind get_Constructor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstructor();
    [CompilationMappingAttribute("8", "45")]
public static FSharpTokenKind get_Inherit();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInherit();
    [CompilationMappingAttribute("8", "46")]
public static FSharpTokenKind get_GreaterRightBracket();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGreaterRightBracket();
    [CompilationMappingAttribute("8", "47")]
public static FSharpTokenKind get_Struct();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStruct();
    [CompilationMappingAttribute("8", "48")]
public static FSharpTokenKind get_Sig();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSig();
    [CompilationMappingAttribute("8", "49")]
public static FSharpTokenKind get_Bar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBar();
    [CompilationMappingAttribute("8", "50")]
public static FSharpTokenKind get_RightBracket();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRightBracket();
    [CompilationMappingAttribute("8", "51")]
public static FSharpTokenKind get_RightBrace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRightBrace();
    [CompilationMappingAttribute("8", "52")]
public static FSharpTokenKind get_Minus();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMinus();
    [CompilationMappingAttribute("8", "53")]
public static FSharpTokenKind get_Dollar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDollar();
    [CompilationMappingAttribute("8", "54")]
public static FSharpTokenKind get_BarRightBracket();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBarRightBracket();
    [CompilationMappingAttribute("8", "55")]
public static FSharpTokenKind get_BarRightBrace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBarRightBrace();
    [CompilationMappingAttribute("8", "56")]
public static FSharpTokenKind get_Underscore();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUnderscore();
    [CompilationMappingAttribute("8", "57")]
public static FSharpTokenKind get_Semicolon();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSemicolon();
    [CompilationMappingAttribute("8", "58")]
public static FSharpTokenKind get_SemicolonSemicolon();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsSemicolonSemicolon();
    [CompilationMappingAttribute("8", "59")]
public static FSharpTokenKind get_LeftArrow();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftArrow();
    [CompilationMappingAttribute("8", "60")]
public static FSharpTokenKind get_Equals();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEquals();
    [CompilationMappingAttribute("8", "61")]
public static FSharpTokenKind get_LeftBracket();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftBracket();
    [CompilationMappingAttribute("8", "62")]
public static FSharpTokenKind get_LeftBracketBar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftBracketBar();
    [CompilationMappingAttribute("8", "63")]
public static FSharpTokenKind get_LeftBraceBar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftBraceBar();
    [CompilationMappingAttribute("8", "64")]
public static FSharpTokenKind get_LeftBracketLess();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftBracketLess();
    [CompilationMappingAttribute("8", "65")]
public static FSharpTokenKind get_LeftBrace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftBrace();
    [CompilationMappingAttribute("8", "66")]
public static FSharpTokenKind get_QuestionMark();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsQuestionMark();
    [CompilationMappingAttribute("8", "67")]
public static FSharpTokenKind get_QuestionMarkQuestionMark();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsQuestionMarkQuestionMark();
    [CompilationMappingAttribute("8", "68")]
public static FSharpTokenKind get_Dot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDot();
    [CompilationMappingAttribute("8", "69")]
public static FSharpTokenKind get_Colon();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsColon();
    [CompilationMappingAttribute("8", "70")]
public static FSharpTokenKind get_ColonColon();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsColonColon();
    [CompilationMappingAttribute("8", "71")]
public static FSharpTokenKind get_ColonGreater();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsColonGreater();
    [CompilationMappingAttribute("8", "72")]
public static FSharpTokenKind get_ColonQuestionMark();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsColonQuestionMark();
    [CompilationMappingAttribute("8", "73")]
public static FSharpTokenKind get_ColonQuestionMarkGreater();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsColonQuestionMarkGreater();
    [CompilationMappingAttribute("8", "74")]
public static FSharpTokenKind get_ColonEquals();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsColonEquals();
    [CompilationMappingAttribute("8", "75")]
public static FSharpTokenKind get_When();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhen();
    [CompilationMappingAttribute("8", "76")]
public static FSharpTokenKind get_While();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhile();
    [CompilationMappingAttribute("8", "77")]
public static FSharpTokenKind get_WhileBang();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWhileBang();
    [CompilationMappingAttribute("8", "78")]
public static FSharpTokenKind get_With();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsWith();
    [CompilationMappingAttribute("8", "79")]
public static FSharpTokenKind get_Hash();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsHash();
    [CompilationMappingAttribute("8", "80")]
public static FSharpTokenKind get_Ampersand();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAmpersand();
    [CompilationMappingAttribute("8", "81")]
public static FSharpTokenKind get_AmpersandAmpersand();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAmpersandAmpersand();
    [CompilationMappingAttribute("8", "82")]
public static FSharpTokenKind get_Quote();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsQuote();
    [CompilationMappingAttribute("8", "83")]
public static FSharpTokenKind get_LeftParenthesis();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftParenthesis();
    [CompilationMappingAttribute("8", "84")]
public static FSharpTokenKind get_RightParenthesis();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRightParenthesis();
    [CompilationMappingAttribute("8", "85")]
public static FSharpTokenKind get_Star();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsStar();
    [CompilationMappingAttribute("8", "86")]
public static FSharpTokenKind get_Comma();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsComma();
    [CompilationMappingAttribute("8", "87")]
public static FSharpTokenKind get_RightArrow();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRightArrow();
    [CompilationMappingAttribute("8", "88")]
public static FSharpTokenKind get_GreaterBarRightBracket();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGreaterBarRightBracket();
    [CompilationMappingAttribute("8", "89")]
public static FSharpTokenKind get_LeftParenthesisStarRightParenthesis();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftParenthesisStarRightParenthesis();
    [CompilationMappingAttribute("8", "90")]
public static FSharpTokenKind get_Open();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOpen();
    [CompilationMappingAttribute("8", "91")]
public static FSharpTokenKind get_Or();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOr();
    [CompilationMappingAttribute("8", "92")]
public static FSharpTokenKind get_Rec();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRec();
    [CompilationMappingAttribute("8", "93")]
public static FSharpTokenKind get_Then();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsThen();
    [CompilationMappingAttribute("8", "94")]
public static FSharpTokenKind get_To();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTo();
    [CompilationMappingAttribute("8", "95")]
public static FSharpTokenKind get_True();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTrue();
    [CompilationMappingAttribute("8", "96")]
public static FSharpTokenKind get_Try();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsTry();
    [CompilationMappingAttribute("8", "97")]
public static FSharpTokenKind get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsType();
    [CompilationMappingAttribute("8", "98")]
public static FSharpTokenKind get_Val();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsVal();
    [CompilationMappingAttribute("8", "99")]
public static FSharpTokenKind get_Inline();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInline();
    [CompilationMappingAttribute("8", "100")]
public static FSharpTokenKind get_Interface();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInterface();
    [CompilationMappingAttribute("8", "101")]
public static FSharpTokenKind get_Instance();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInstance();
    [CompilationMappingAttribute("8", "102")]
public static FSharpTokenKind get_Const();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConst();
    [CompilationMappingAttribute("8", "103")]
public static FSharpTokenKind get_Lazy();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLazy();
    [CompilationMappingAttribute("8", "104")]
public static FSharpTokenKind get_OffsideLazy();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideLazy();
    [CompilationMappingAttribute("8", "105")]
public static FSharpTokenKind get_Match();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMatch();
    [CompilationMappingAttribute("8", "106")]
public static FSharpTokenKind get_MatchBang();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMatchBang();
    [CompilationMappingAttribute("8", "107")]
public static FSharpTokenKind get_Mutable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsMutable();
    [CompilationMappingAttribute("8", "108")]
public static FSharpTokenKind get_New();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNew();
    [CompilationMappingAttribute("8", "109")]
public static FSharpTokenKind get_Of();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOf();
    [CompilationMappingAttribute("8", "110")]
public static FSharpTokenKind get_Exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsException();
    [CompilationMappingAttribute("8", "111")]
public static FSharpTokenKind get_False();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFalse();
    [CompilationMappingAttribute("8", "112")]
public static FSharpTokenKind get_For();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFor();
    [CompilationMappingAttribute("8", "113")]
public static FSharpTokenKind get_Fun();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFun();
    [CompilationMappingAttribute("8", "114")]
public static FSharpTokenKind get_Function();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFunction();
    [CompilationMappingAttribute("8", "115")]
public static FSharpTokenKind get_If();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIf();
    [CompilationMappingAttribute("8", "116")]
public static FSharpTokenKind get_In();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIn();
    [CompilationMappingAttribute("8", "117")]
public static FSharpTokenKind get_JoinIn();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsJoinIn();
    [CompilationMappingAttribute("8", "118")]
public static FSharpTokenKind get_Finally();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFinally();
    [CompilationMappingAttribute("8", "119")]
public static FSharpTokenKind get_DoBang();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDoBang();
    [CompilationMappingAttribute("8", "120")]
public static FSharpTokenKind get_And();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAnd();
    [CompilationMappingAttribute("8", "121")]
public static FSharpTokenKind get_As();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAs();
    [CompilationMappingAttribute("8", "122")]
public static FSharpTokenKind get_Assert();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAssert();
    [CompilationMappingAttribute("8", "123")]
public static FSharpTokenKind get_OffsideAssert();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsOffsideAssert();
    [CompilationMappingAttribute("8", "124")]
public static FSharpTokenKind get_Begin();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBegin();
    [CompilationMappingAttribute("8", "125")]
public static FSharpTokenKind get_Do();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDo();
    [CompilationMappingAttribute("8", "126")]
public static FSharpTokenKind get_Done();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDone();
    [CompilationMappingAttribute("8", "127")]
public static FSharpTokenKind get_DownTo();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDownTo();
    [CompilationMappingAttribute("8", "128")]
public static FSharpTokenKind get_Else();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsElse();
    [CompilationMappingAttribute("8", "129")]
public static FSharpTokenKind get_Elif();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsElif();
    [CompilationMappingAttribute("8", "130")]
public static FSharpTokenKind get_End();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsEnd();
    [CompilationMappingAttribute("8", "131")]
public static FSharpTokenKind get_DotDot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotDot();
    [CompilationMappingAttribute("8", "132")]
public static FSharpTokenKind get_DotDotHat();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDotDotHat();
    [CompilationMappingAttribute("8", "133")]
public static FSharpTokenKind get_BarBar();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBarBar();
    [CompilationMappingAttribute("8", "134")]
public static FSharpTokenKind get_Upcast();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUpcast();
    [CompilationMappingAttribute("8", "135")]
public static FSharpTokenKind get_Downcast();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDowncast();
    [CompilationMappingAttribute("8", "136")]
public static FSharpTokenKind get_Null();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNull();
    [CompilationMappingAttribute("8", "137")]
public static FSharpTokenKind get_Reserved();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsReserved();
    [CompilationMappingAttribute("8", "138")]
public static FSharpTokenKind get_Module();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsModule();
    [CompilationMappingAttribute("8", "139")]
public static FSharpTokenKind get_Namespace();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNamespace();
    [CompilationMappingAttribute("8", "140")]
public static FSharpTokenKind get_Delegate();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDelegate();
    [CompilationMappingAttribute("8", "141")]
public static FSharpTokenKind get_Constraint();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsConstraint();
    [CompilationMappingAttribute("8", "142")]
public static FSharpTokenKind get_Base();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBase();
    [CompilationMappingAttribute("8", "143")]
public static FSharpTokenKind get_LeftQuote();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLeftQuote();
    [CompilationMappingAttribute("8", "144")]
public static FSharpTokenKind get_RightQuote();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRightQuote();
    [CompilationMappingAttribute("8", "145")]
public static FSharpTokenKind get_RightQuoteDot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsRightQuoteDot();
    [CompilationMappingAttribute("8", "146")]
public static FSharpTokenKind get_PercentOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPercentOperator();
    [CompilationMappingAttribute("8", "147")]
public static FSharpTokenKind get_Binder();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBinder();
    [CompilationMappingAttribute("8", "148")]
public static FSharpTokenKind get_Less();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLess();
    [CompilationMappingAttribute("8", "149")]
public static FSharpTokenKind get_Greater();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsGreater();
    [CompilationMappingAttribute("8", "150")]
public static FSharpTokenKind get_Let();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsLet();
    [CompilationMappingAttribute("8", "151")]
public static FSharpTokenKind get_Yield();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYield();
    [CompilationMappingAttribute("8", "152")]
public static FSharpTokenKind get_YieldBang();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsYieldBang();
    [CompilationMappingAttribute("8", "153")]
public static FSharpTokenKind get_BigNumber();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsBigNumber();
    [CompilationMappingAttribute("8", "154")]
public static FSharpTokenKind get_Decimal();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsDecimal();
    [CompilationMappingAttribute("8", "155")]
public static FSharpTokenKind get_Char();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsChar();
    [CompilationMappingAttribute("8", "156")]
public static FSharpTokenKind get_Ieee64();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIeee64();
    [CompilationMappingAttribute("8", "157")]
public static FSharpTokenKind get_Ieee32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIeee32();
    [CompilationMappingAttribute("8", "158")]
public static FSharpTokenKind get_NativeInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsNativeInt();
    [CompilationMappingAttribute("8", "159")]
public static FSharpTokenKind get_UNativeInt();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUNativeInt();
    [CompilationMappingAttribute("8", "160")]
public static FSharpTokenKind get_UInt64();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt64();
    [CompilationMappingAttribute("8", "161")]
public static FSharpTokenKind get_UInt32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt32();
    [CompilationMappingAttribute("8", "162")]
public static FSharpTokenKind get_UInt16();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt16();
    [CompilationMappingAttribute("8", "163")]
public static FSharpTokenKind get_UInt8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsUInt8();
    [CompilationMappingAttribute("8", "164")]
public static FSharpTokenKind get_Int64();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt64();
    [CompilationMappingAttribute("8", "165")]
public static FSharpTokenKind get_Int32();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt32();
    [CompilationMappingAttribute("8", "166")]
public static FSharpTokenKind get_Int32DotDot();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt32DotDot();
    [CompilationMappingAttribute("8", "167")]
public static FSharpTokenKind get_Int16();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt16();
    [CompilationMappingAttribute("8", "168")]
public static FSharpTokenKind get_Int8();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInt8();
    [CompilationMappingAttribute("8", "169")]
public static FSharpTokenKind get_FunkyOperatorName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsFunkyOperatorName();
    [CompilationMappingAttribute("8", "170")]
public static FSharpTokenKind get_AdjacentPrefixOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAdjacentPrefixOperator();
    [CompilationMappingAttribute("8", "171")]
public static FSharpTokenKind get_PlusMinusOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPlusMinusOperator();
    [CompilationMappingAttribute("8", "172")]
public static FSharpTokenKind get_InfixAmpersandOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixAmpersandOperator();
    [CompilationMappingAttribute("8", "173")]
public static FSharpTokenKind get_InfixStarDivideModuloOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixStarDivideModuloOperator();
    [CompilationMappingAttribute("8", "174")]
public static FSharpTokenKind get_PrefixOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsPrefixOperator();
    [CompilationMappingAttribute("8", "175")]
public static FSharpTokenKind get_InfixBarOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixBarOperator();
    [CompilationMappingAttribute("8", "176")]
public static FSharpTokenKind get_InfixAtHatOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixAtHatOperator();
    [CompilationMappingAttribute("8", "177")]
public static FSharpTokenKind get_InfixCompareOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixCompareOperator();
    [CompilationMappingAttribute("8", "178")]
public static FSharpTokenKind get_InfixStarStarOperator();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixStarStarOperator();
    [CompilationMappingAttribute("8", "179")]
public static FSharpTokenKind get_Identifier();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsIdentifier();
    [CompilationMappingAttribute("8", "180")]
public static FSharpTokenKind get_KeywordString();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsKeywordString();
    [CompilationMappingAttribute("8", "181")]
public static FSharpTokenKind get_String();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsString();
    [CompilationMappingAttribute("8", "182")]
public static FSharpTokenKind get_ByteArray();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsByteArray();
    [CompilationMappingAttribute("8", "183")]
public static FSharpTokenKind get_Asr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsAsr();
    [CompilationMappingAttribute("8", "184")]
public static FSharpTokenKind get_InfixAsr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixAsr();
    [CompilationMappingAttribute("8", "185")]
public static FSharpTokenKind get_InfixLand();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixLand();
    [CompilationMappingAttribute("8", "186")]
public static FSharpTokenKind get_InfixLor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixLor();
    [CompilationMappingAttribute("8", "187")]
public static FSharpTokenKind get_InfixLsl();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixLsl();
    [CompilationMappingAttribute("8", "188")]
public static FSharpTokenKind get_InfixLsr();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixLsr();
    [CompilationMappingAttribute("8", "189")]
public static FSharpTokenKind get_InfixLxor();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixLxor();
    [CompilationMappingAttribute("8", "190")]
public static FSharpTokenKind get_InfixMod();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public bool get_IsInfixMod();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(FSharpTokenKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FSharpTokenKind obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
public static class FSharp.Compiler.Tokenization.FSharpTokenTag : object {
    [CompilationMappingAttribute("9")]
public static int Identifier { get; }
    [CompilationMappingAttribute("9")]
public static int String { get; }
    [CompilationMappingAttribute("9")]
public static int IDENT { get; }
    [CompilationMappingAttribute("9")]
public static int STRING { get; }
    [CompilationMappingAttribute("9")]
public static int INTERP_STRING_BEGIN_END { get; }
    [CompilationMappingAttribute("9")]
public static int INTERP_STRING_BEGIN_PART { get; }
    [CompilationMappingAttribute("9")]
public static int INTERP_STRING_PART { get; }
    [CompilationMappingAttribute("9")]
public static int INTERP_STRING_END { get; }
    [CompilationMappingAttribute("9")]
public static int LPAREN { get; }
    [CompilationMappingAttribute("9")]
public static int RPAREN { get; }
    [CompilationMappingAttribute("9")]
public static int LBRACK { get; }
    [CompilationMappingAttribute("9")]
public static int RBRACK { get; }
    [CompilationMappingAttribute("9")]
public static int LBRACE { get; }
    [CompilationMappingAttribute("9")]
public static int RBRACE { get; }
    [CompilationMappingAttribute("9")]
public static int LBRACK_LESS { get; }
    [CompilationMappingAttribute("9")]
public static int GREATER_RBRACK { get; }
    [CompilationMappingAttribute("9")]
public static int LESS { get; }
    [CompilationMappingAttribute("9")]
public static int GREATER { get; }
    [CompilationMappingAttribute("9")]
public static int LBRACK_BAR { get; }
    [CompilationMappingAttribute("9")]
public static int BAR_RBRACK { get; }
    [CompilationMappingAttribute("9")]
public static int PLUS_MINUS_OP { get; }
    [CompilationMappingAttribute("9")]
public static int MINUS { get; }
    [CompilationMappingAttribute("9")]
public static int STAR { get; }
    [CompilationMappingAttribute("9")]
public static int INFIX_STAR_DIV_MOD_OP { get; }
    [CompilationMappingAttribute("9")]
public static int PERCENT_OP { get; }
    [CompilationMappingAttribute("9")]
public static int INFIX_AT_HAT_OP { get; }
    [CompilationMappingAttribute("9")]
public static int QMARK { get; }
    [CompilationMappingAttribute("9")]
public static int COLON { get; }
    [CompilationMappingAttribute("9")]
public static int EQUALS { get; }
    [CompilationMappingAttribute("9")]
public static int SEMICOLON { get; }
    [CompilationMappingAttribute("9")]
public static int COMMA { get; }
    [CompilationMappingAttribute("9")]
public static int DOT { get; }
    [CompilationMappingAttribute("9")]
public static int DOT_DOT { get; }
    [CompilationMappingAttribute("9")]
public static int DOT_DOT_HAT { get; }
    [CompilationMappingAttribute("9")]
public static int INT32_DOT_DOT { get; }
    [CompilationMappingAttribute("9")]
public static int UNDERSCORE { get; }
    [CompilationMappingAttribute("9")]
public static int BAR { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_GREATER { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_QMARK_GREATER { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_QMARK { get; }
    [CompilationMappingAttribute("9")]
public static int INFIX_BAR_OP { get; }
    [CompilationMappingAttribute("9")]
public static int INFIX_COMPARE_OP { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_COLON { get; }
    [CompilationMappingAttribute("9")]
public static int AMP_AMP { get; }
    [CompilationMappingAttribute("9")]
public static int PREFIX_OP { get; }
    [CompilationMappingAttribute("9")]
public static int COLON_EQUALS { get; }
    [CompilationMappingAttribute("9")]
public static int BAR_BAR { get; }
    [CompilationMappingAttribute("9")]
public static int RARROW { get; }
    [CompilationMappingAttribute("9")]
public static int LARROW { get; }
    [CompilationMappingAttribute("9")]
public static int QUOTE { get; }
    [CompilationMappingAttribute("9")]
public static int WHITESPACE { get; }
    [CompilationMappingAttribute("9")]
public static int COMMENT { get; }
    [CompilationMappingAttribute("9")]
public static int LINE_COMMENT { get; }
    [CompilationMappingAttribute("9")]
public static int BEGIN { get; }
    [CompilationMappingAttribute("9")]
public static int DO { get; }
    [CompilationMappingAttribute("9")]
public static int FUNCTION { get; }
    [CompilationMappingAttribute("9")]
public static int THEN { get; }
    [CompilationMappingAttribute("9")]
public static int ELSE { get; }
    [CompilationMappingAttribute("9")]
public static int STRUCT { get; }
    [CompilationMappingAttribute("9")]
public static int CLASS { get; }
    [CompilationMappingAttribute("9")]
public static int TRY { get; }
    [CompilationMappingAttribute("9")]
public static int NEW { get; }
    [CompilationMappingAttribute("9")]
public static int WITH { get; }
    [CompilationMappingAttribute("9")]
public static int OWITH { get; }
    public static int get_Identifier();
    public static int get_String();
    public static int get_IDENT();
    public static int get_STRING();
    public static int get_INTERP_STRING_BEGIN_END();
    public static int get_INTERP_STRING_BEGIN_PART();
    public static int get_INTERP_STRING_PART();
    public static int get_INTERP_STRING_END();
    public static int get_LPAREN();
    public static int get_RPAREN();
    public static int get_LBRACK();
    public static int get_RBRACK();
    public static int get_LBRACE();
    public static int get_RBRACE();
    public static int get_LBRACK_LESS();
    public static int get_GREATER_RBRACK();
    public static int get_LESS();
    public static int get_GREATER();
    public static int get_LBRACK_BAR();
    public static int get_BAR_RBRACK();
    public static int get_PLUS_MINUS_OP();
    public static int get_MINUS();
    public static int get_STAR();
    public static int get_INFIX_STAR_DIV_MOD_OP();
    public static int get_PERCENT_OP();
    public static int get_INFIX_AT_HAT_OP();
    public static int get_QMARK();
    public static int get_COLON();
    public static int get_EQUALS();
    public static int get_SEMICOLON();
    public static int get_COMMA();
    public static int get_DOT();
    public static int get_DOT_DOT();
    public static int get_DOT_DOT_HAT();
    public static int get_INT32_DOT_DOT();
    public static int get_UNDERSCORE();
    public static int get_BAR();
    public static int get_COLON_GREATER();
    public static int get_COLON_QMARK_GREATER();
    public static int get_COLON_QMARK();
    public static int get_INFIX_BAR_OP();
    public static int get_INFIX_COMPARE_OP();
    public static int get_COLON_COLON();
    public static int get_AMP_AMP();
    public static int get_PREFIX_OP();
    public static int get_COLON_EQUALS();
    public static int get_BAR_BAR();
    public static int get_RARROW();
    public static int get_LARROW();
    public static int get_QUOTE();
    public static int get_WHITESPACE();
    public static int get_COMMENT();
    public static int get_LINE_COMMENT();
    public static int get_BEGIN();
    public static int get_DO();
    public static int get_FUNCTION();
    public static int get_THEN();
    public static int get_ELSE();
    public static int get_STRUCT();
    public static int get_CLASS();
    public static int get_TRY();
    public static int get_NEW();
    public static int get_WITH();
    public static int get_OWITH();
}
[CompilationMappingAttribute("3")]
public enum FSharp.Compiler.Tokenization.FSharpTokenTriggerClass : Enum {
    public int value__;
    public static FSharpTokenTriggerClass None;
    public static FSharpTokenTriggerClass MemberSelect;
    public static FSharpTokenTriggerClass MatchBraces;
    public static FSharpTokenTriggerClass ChoiceSelect;
    public static FSharpTokenTriggerClass MethodTip;
    public static FSharpTokenTriggerClass ParamStart;
    public static FSharpTokenTriggerClass ParamNext;
    public static FSharpTokenTriggerClass ParamEnd;
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Tokenization.LexerStateEncoding : object {
    [CompilationMappingAttribute("9")]
internal static LexerContinuation revertToDefaultLexCont { get; }
    internal static int lexstateNumBits { get; }
    internal static int ncommentsNumBits { get; }
    internal static int hardwhiteNumBits { get; }
    internal static int ifdefstackCountNumBits { get; }
    internal static int ifdefstackNumBits { get; }
    internal static int stringKindBits { get; }
    internal static int nestingBits { get; }
    internal static int delimLenBits { get; }
    internal static int lexstateStart { get; }
    internal static int ncommentsStart { get; }
    internal static int hardwhitePosStart { get; }
    internal static int ifdefstackCountStart { get; }
    internal static int ifdefstackStart { get; }
    internal static int stringKindStart { get; }
    internal static int nestingStart { get; }
    internal static int delimLenStart { get; }
    [CompilationMappingAttribute("9")]
internal static long lexstateMask { get; }
    [CompilationMappingAttribute("9")]
internal static long ncommentsMask { get; }
    [CompilationMappingAttribute("9")]
internal static long hardwhitePosMask { get; }
    [CompilationMappingAttribute("9")]
internal static long ifdefstackCountMask { get; }
    [CompilationMappingAttribute("9")]
internal static long ifdefstackMask { get; }
    [CompilationMappingAttribute("9")]
internal static long stringKindMask { get; }
    [CompilationMappingAttribute("9")]
internal static long nestingMask { get; }
    [CompilationMappingAttribute("9")]
internal static long delimLenMask { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static LexerContinuation computeNextLexState(token token, LexerContinuation prevLexcont);
    internal static LexerContinuation get_revertToDefaultLexCont();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_lexstateNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ncommentsNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_hardwhiteNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ifdefstackCountNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ifdefstackNumBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_stringKindBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_nestingBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_delimLenBits();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_lexstateStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ncommentsStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_hardwhitePosStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ifdefstackCountStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_ifdefstackStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_stringKindStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_nestingStart();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_delimLenStart();
    internal static long get_lexstateMask();
    internal static long get_ncommentsMask();
    internal static long get_hardwhitePosMask();
    internal static long get_ifdefstackCountMask();
    internal static long get_ifdefstackMask();
    internal static long get_stringKindMask();
    internal static long get_nestingMask();
    internal static long get_delimLenMask();
    internal static int encodeStringStyle(LexerStringStyle kind);
    internal static LexerStringStyle decodeStringStyle(int kind);
    internal static FSharpTokenizerLexState encodeLexCont(FSharpTokenizerColorState colorState, long numComments, Position b, IEnumerable`1<Tuple`2<LexerIfdefStackEntry, a>> ifdefStack, bool light, LexerStringKind stringKind, FSharpList`1<Tuple`4<int, LexerStringStyle, b, c>> stringNest, int delimLen);
    internal static Tuple`8<FSharpTokenizerColorState, int, Position, FSharpList`1<Tuple`2<LexerIfdefStackEntry, Range>>, bool, LexerStringKind, FSharpList`1<Tuple`4<int, LexerStringStyle, int, Range>>, Tuple`1<int>> decodeLexCont(FSharpTokenizerLexState state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpTokenizerLexState encodeLexInt(bool indentationSyntaxStatus, LexerContinuation lexcont);
    internal static Tuple`2<bool, LexerContinuation> decodeLexInt(FSharpTokenizerLexState state);
}
[CompilationMappingAttribute("3")]
internal enum FSharp.Compiler.Tokenization.SingleLineTokenState : Enum {
    public int value__;
    public static SingleLineTokenState BeforeHash;
    public static SingleLineTokenState NoFurtherMatchPossible;
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Tokenization.TestExpose : object {
    internal static Tuple`3<FSharpTokenColorKind, FSharpTokenCharKind, FSharpTokenTriggerClass> TokenInfo(token tok);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.Tokenization.TokenClassifications : object {
    internal static Tuple`3<FSharpTokenColorKind, FSharpTokenCharKind, FSharpTokenTriggerClass> tokenInfo(token token);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypedTree : object {
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@4445-36(Const this, Const obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@4445-37(IComparer comp, Const this, Const objTemp, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@4445-7(IEqualityComparer comp, Const this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@4445-12(Const this, Const that, Unit unitVar);
    internal static ILTypeRef top@1271(string item, ILScopeRef sref, FSharpList`1<string> racc, FSharpList`1<Tuple`2<string, ModuleOrNamespaceKind>> p);
    internal static ILTypeRef ilTypeRefForCompilationPath@1270(CompilationPath _arg5, string item);
    internal static FSharpValueOption`1<Entity> tryResolveNestedTypeOf@3313(CcuThunk ccu, String[] path, Entity parentEntity, ResolutionEnvironment resolutionEnvironment, Tainted`1<ProvidedType> st, int i);
    internal static Entity injectNamespacesFromIToJ@3361(CcuThunk ccu, String[] path, ResolutionEnvironment resolutionEnvironment, int j, Tainted`1<ProvidedType> st, Entity entity, int k);
    internal static FSharpValueOption`1<Entity> tryResolvePrefix@3342(CcuThunk ccu, String[] path, int i, Entity entity, FSharpList`1<Tainted`1<ITypeProvider>> resolvers, ResolutionEnvironment resolutionEnvironment, int j);
    internal static FSharpValueOption`1<Entity> tryResolvePrefixes@3383(CcuThunk ccu, String[] path, int i, Entity entity, FSharpList`1<Tainted`1<ITypeProvider>> resolvers, ResolutionEnvironment resolutionEnvironment, int j);
    internal static FSharpValueOption`1<Entity> tryForwardPrefixPath@3407(String[] path, CcuThunk ccu, int i);
    internal static int loop@4698-36(FSharpList`1<FSharpList`1<ArgReprInfo>> args, int acc);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@4445-13(Const this, Const obj, Unit unitVar);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypedTreeBasics : object {
    [CompilationMappingAttribute("9")]
internal static TupInfo tupInfoRef { get; }
    [CompilationMappingAttribute("9")]
internal static TupInfo tupInfoStruct { get; }
    internal static bool structnessDefault { get; }
    [CompilationMappingAttribute("9")]
internal static Accessibility taccessPublic { get; }
    [CompilationMappingAttribute("9")]
internal static CompilationPath compPathInternal { get; }
    [CompilationMappingAttribute("9")]
internal static Accessibility taccessInternal { get; }
    internal static string getNameOfScopeRef(ILScopeRef sref);
    internal static TType typeOfVal(Val v);
    internal static FSharpList`1<TType> typesOfVals(FSharpList`1<Val> v);
    internal static string nameOfVal(Val v);
    internal static ValReprInfo arityOfVal(Val v);
    internal static ValReprInfo arityOfValForDisplay(Val v);
    internal static TupInfo get_tupInfoRef();
    internal static TupInfo get_tupInfoStruct();
    internal static TupInfo mkTupInfo(bool b);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_structnessDefault();
    internal static TType mkRawRefTupleTy(FSharpList`1<TType> tys);
    internal static TType mkRawStructTupleTy(FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarEq(Typar tp1, Typar tp2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarRefEq(Typar tp1, Typar tp2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valEq(Val v1, Val v2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ccuEq(CcuThunk ccu1, CcuThunk ccu2);
    internal static Val |ValDeref|(ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdFieldRef mkRecdFieldRef(EntityRef tcref, string f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef mkUnionCaseRef(EntityRef tcref, string c);
    internal static EntityRef ERefLocal(Entity x);
    internal static EntityRef ERefNonLocal(NonLocalEntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef ERefNonLocalPreResolved(Entity x, NonLocalEntityRef xref);
    internal static FSharpChoice`2<Entity, NonLocalEntityRef> |ERefLocal|ERefNonLocal|(EntityRef x);
    internal static EntityRef mkLocalTyconRef(Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef mkNonLocalEntityRef(CcuThunk ccu, String[] mp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef mkNestedNonLocalEntityRef(NonLocalEntityRef nleref, string id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkNonLocalTyconRef(NonLocalEntityRef nleref, string id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkNonLocalTyconRefPreResolved(Entity x, NonLocalEntityRef nleref, string id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef EntityRef.NestedTyconRef(EntityRef tcref, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdFieldRef EntityRef.RecdFieldRefInNestedTycon(EntityRef tcref, Entity tycon, Ident id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef mkModuleUnionCaseRef(EntityRef modref, Entity tycon, UnionCase uc);
    internal static ValRef VRefLocal(Val x);
    internal static ValRef VRefNonLocal(NonLocalValOrMemberRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef VRefNonLocalPreResolved(Val x, NonLocalValOrMemberRef xref);
    internal static FSharpChoice`2<Val, NonLocalValOrMemberRef> |VRefLocal|VRefNonLocal|(ValRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef mkNonLocalValRef(NonLocalEntityRef mp, ValLinkageFullKey id);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef mkNonLocalValRefPreResolved(Val x, NonLocalEntityRef mp, ValLinkageFullKey id);
    internal static FSharpOption`1<CcuThunk> ccuOfValRef(ValRef vref);
    internal static FSharpOption`1<CcuThunk> ccuOfTyconRef(EntityRef eref);
    internal static TType mkTyparTy(Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar copyTypar(bool clearStaticReq, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> copyTypars(bool clearStaticReq, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure tryShortcutSolvedUnitPar(bool canShortcut, Typar r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure stripUnitEqnsAux(bool canShortcut, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyparEqnsAux(bool canShortcut, TType ty);
    internal static TType stripTyparEqns(TType ty);
    internal static Measure stripUnitEqns(Measure unt);
    internal static FSharpOption`1<EntityRef> |AbbrevOrAppTy|_|(TType ty);
    internal static ValRef mkLocalValRef(Val v);
    internal static EntityRef mkLocalModuleRef(Entity v);
    internal static EntityRef mkLocalEntityRef(Entity v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkNonLocalCcuRootEntityRef(CcuThunk ccu, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef mkNestedValRef(EntityRef cref, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef rescopePubPathToParent(CcuThunk viewedCcu, PublicPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef rescopePubPath(CcuThunk viewedCcu, PublicPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valRefInThisAssembly(bool compilingFSharpCore, ValRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyconRefUsesLocalXmlDoc(bool compilingFSharpCore, EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool entityRefInThisAssembly(bool compilingFSharpCore, EntityRef x);
    internal static bool loop@324-37(String[] y1, String[] y2, int len1, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool arrayPathEq(String[] y1, String[] y2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool nonLocalRefEq(NonLocalEntityRef smr1, NonLocalEntityRef smr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool nonLocalRefDefinitelyNotEq(NonLocalEntityRef _arg2, NonLocalEntityRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool pubPathEq(PublicPath _arg2, PublicPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool fslibRefEq(NonLocalEntityRef nlr1, PublicPath _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool fslibEntityRefEq(CcuThunk fslibCcu, EntityRef eref1, EntityRef eref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool fslibValRefEq(CcuThunk fslibCcu, ValRef vref1, ValRef vref2);
    [CompilerGeneratedAttribute]
internal static bool primEntityRefEq$cont@398(bool compilingFSharpCore, CcuThunk fslibCcu, EntityRef x, EntityRef y, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool primEntityRefEq(bool compilingFSharpCore, CcuThunk fslibCcu, EntityRef x, EntityRef y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool primUnionCaseRefEq(bool compilingFSharpCore, CcuThunk fslibCcu, UnionCaseRef uc1, UnionCaseRef uc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool primValRefEq(bool compilingFSharpCore, CcuThunk fslibCcu, ValRef x, ValRef y);
    internal static CompilationPath fullCompPathOfModuleOrNamespace(Entity m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canAccessCompPathFrom(CompilationPath _arg2, CompilationPath _arg1);
    [CompilerGeneratedAttribute]
internal static bool loop@444-39(FSharpList`1<Tuple`2<a, b>> p1, FSharpList`1<Tuple`2<a, b>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canAccessFromOneOf(FSharpList`1<CompilationPath> cpaths, CompilationPath cpathTest);
    [CompilerGeneratedAttribute]
internal static bool loop@444-40(FSharpList`1<Tuple`2<a, b>> p1, FSharpList`1<Tuple`2<a, b>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canAccessFrom(Accessibility _arg1, CompilationPath cpath);
    internal static bool canAccessFromEverywhere(Accessibility _arg1);
    internal static bool canAccessFromSomewhere(Accessibility _arg1);
    [CompilerGeneratedAttribute]
internal static bool loop@444-41(FSharpList`1<Tuple`2<a, b>> p1, FSharpList`1<Tuple`2<a, b>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isLessAccessible(Accessibility _arg2, Accessibility _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility accessSubstPaths(CompilationPath newPath, CompilationPath oldPath, Accessibility _arg1);
    internal static CompilationPath compPathOfCcu(CcuThunk ccu);
    internal static Accessibility get_taccessPublic();
    internal static Accessibility taccessPrivate(CompilationPath accessPath);
    internal static CompilationPath get_compPathInternal();
    internal static Accessibility get_taccessInternal();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Accessibility combineAccess(Accessibility _arg2, Accessibility _arg1);
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@476-8(IEqualityComparer comp, Exception this, Unit unitVar);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypedTreeOps : object {
    [CompilationMappingAttribute("9")]
internal static int AccFreeVarsStackGuardDepth { get; }
    [CompilationMappingAttribute("9")]
internal static int RemapExprStackGuardDepth { get; }
    [CompilationMappingAttribute("9")]
internal static int FoldExprStackGuardDepth { get; }
    [CompilationMappingAttribute("9")]
internal static TyconRefMap`1<EntityRef> emptyTyconRefRemap { get; }
    internal static FSharpList`1<Tuple`2<Typar, TType>> emptyTyparInst { get; }
    [CompilationMappingAttribute("9")]
internal static Remap emptyRemap { get; }
    internal static int maxTuple { get; }
    internal static int goodTupleFields { get; }
    [CompilationMappingAttribute("9")]
internal static TypeEquivEnv typeEquivEnvEmpty { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<Val> valOrder { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<Entity> tyconOrder { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<RecdFieldRef> recdFieldRefOrder { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<UnionCaseRef> unionCaseRefOrder { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<Val, IComparer`1<Val>> emptyFreeLocals { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> emptyFreeRecdFields { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> emptyFreeUnionCases { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<Entity, IComparer`1<Entity>> emptyFreeTycons { get; }
    [CompilationMappingAttribute("9")]
internal static IComparer`1<Typar> typarOrder { get; }
    [CompilationMappingAttribute("9")]
internal static Set`2<Typar, IComparer`1<Typar>> emptyFreeTypars { get; }
    [CompilationMappingAttribute("9")]
internal static FreeTyvars emptyFreeTyvars { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectAllNoCaching { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectTyparsNoCaching { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectLocalsNoCaching { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectTyparsAndLocalsNoCaching { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectAll { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectTyparsAndLocals { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectTypars { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVarOptions CollectLocals { get; }
    [CompilationMappingAttribute("9")]
internal static FreeVars emptyFreeVars { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr box { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr isinst { get; }
    [CompilationMappingAttribute("9")]
internal static ILInstr unbox { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<TcGlobals, FSharpFunc`2<Range, FSharpFunc`2<Expr, FSharpFunc`2<Expr, Expr>>>> mkGetStringChar { get; }
    [CompilationMappingAttribute("9")]
internal static string tnameCompilationSourceNameAttr { get; }
    [CompilationMappingAttribute("9")]
internal static string tnameCompilationArgumentCountsAttr { get; }
    [CompilationMappingAttribute("9")]
internal static string tnameCompilationMappingAttr { get; }
    [CompilationMappingAttribute("9")]
internal static string tnameSourceConstructFlags { get; }
    [CompilationMappingAttribute("9")]
internal static string tname_SignatureDataVersionAttr { get; }
    [CompilationMappingAttribute("9")]
internal static string tname_AutoOpenAttr { get; }
    internal static int enum_CompilationRepresentationAttribute_Static { get; }
    internal static int enum_CompilationRepresentationAttribute_Instance { get; }
    internal static int enum_CompilationRepresentationAttribute_ModuleSuffix { get; }
    internal static int enum_CompilationRepresentationAttribute_PermitNull { get; }
    internal static int get_AccFreeVarsStackGuardDepth();
    internal static int get_RemapExprStackGuardDepth();
    internal static int get_FoldExprStackGuardDepth();
    internal static TyconRefMap`1<EntityRef> get_emptyTyconRefRemap();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static FSharpList`1<Tuple`2<Typar, TType>> get_emptyTyparInst();
    internal static Remap get_emptyRemap();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap addTyconRefRemap(EntityRef tcref1, EntityRef tcref2, Remap tmenv);
    internal static bool isRemapEmpty(Remap remap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a instTyparRef(FSharpList`1<Tuple`2<Typar, a>> tpinst, a ty, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef remapTyconRef(TyconRefMap`1<EntityRef> tcmap, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef remapUnionCaseRef(TyconRefMap`1<EntityRef> tcmap, UnionCaseRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdFieldRef remapRecdFieldRef(TyconRefMap`1<EntityRef> tcmap, RecdFieldRef _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> mkTyparInst(FSharpList`1<Typar> typars, FSharpList`1<TType> tyargs);
    internal static FSharpList`1<TType> generalizeTypars(FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType remapTypeAux(Remap tyenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure remapMeasureAux(Remap tyenv, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TupInfo remapTupInfoAux(Remap _tyenv, TupInfo unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> remapTypesAux(Remap tyenv, FSharpList`1<TType> types);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TyparConstraint> remapTyparConstraintsAux(Remap tyenv, FSharpList`1<TyparConstraint> cs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TraitConstraintInfo remapTraitInfo(Remap tyenv, TraitConstraintInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<a, b>> bindTypars(FSharpList`1<a> tps, FSharpList`1<b> tyargs, FSharpList`1<Tuple`2<a, b>> tpinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, Remap> copyAndRemapAndBindTyparsFull(FSharpFunc`2<FSharpList`1<Attrib>, FSharpList`1<Attrib>> remapAttrib, Remap tyenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, Remap> copyAndRemapAndBindTypars(Remap tyenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValLinkageFullKey remapValLinkage(Remap tyenv, ValLinkageFullKey vlink);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalValOrMemberRef remapNonLocalValRef(Remap tyenv, NonLocalValOrMemberRef nlvref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValRef remapValRef(Remap tmenv, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType remapType(Remap tyenv, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> remapTypes(Remap tyenv, FSharpList`1<TType> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType remapTypeFull(FSharpFunc`2<FSharpList`1<Attrib>, FSharpList`1<Attrib>> remapAttrib, Remap tyenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotParam remapParam(Remap tyenv, SlotParam x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig remapSlotSig(FSharpFunc`2<FSharpList`1<Attrib>, FSharpList`1<Attrib>> remapAttrib, Remap tyenv, SlotSig x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType instType(FSharpList`1<Tuple`2<Typar, TType>> tpinst, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> instTypes(FSharpList`1<Tuple`2<Typar, TType>> tpinst, FSharpList`1<TType> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TraitConstraintInfo instTrait(FSharpList`1<Tuple`2<Typar, TType>> tpinst, TraitConstraintInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TyparConstraint> instTyparConstraints(FSharpList`1<Tuple`2<Typar, TType>> tpinst, FSharpList`1<TyparConstraint> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SlotSig instSlotSig(FSharpList`1<Tuple`2<Typar, TType>> tpinst, SlotSig ss);
    internal static SlotSig copySlotSig(SlotSig ss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>> mkTyparToTyparRenaming(FSharpList`1<Typar> tpsorig, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> mkTyconRefInst(EntityRef tcref, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyconRefEq(TcGlobals g, EntityRef tcref1, EntityRef tcref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valRefEq(TcGlobals g, ValRef vref1, ValRef vref2);
    internal static Measure reduceTyconRefAbbrevMeasureable(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure stripUnitEqnsFromMeasureAux(bool canShortcut, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational MeasureExprConExponent(TcGlobals g, bool abbrev, EntityRef ucref, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational MeasureConExponentAfterRemapping(TcGlobals g, FSharpFunc`2<EntityRef, EntityRef> r, EntityRef ucref, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational MeasureVarExponent(Typar tp, Measure unt);
    internal static FSharpList`1<Typar> gather@465(FSharpList`1<Typar> acc, Measure unt);
    internal static FSharpList`1<Typar> ListMeasureVarOccs(Measure unt);
    internal static FSharpList`1<Tuple`2<Typar, Rational>> gather@476-2(Measure untexpr, FSharpList`1<Tuple`2<Typar, Rational>> acc, Measure unt);
    internal static FSharpList`1<Tuple`2<Typar, Rational>> ListMeasureVarOccsWithNonZeroExponents(Measure untexpr);
    internal static FSharpList`1<Tuple`2<EntityRef, Rational>> gather@491-4(TcGlobals g, bool eraseAbbrevs, Measure untexpr, FSharpList`1<Tuple`2<EntityRef, Rational>> acc, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<EntityRef, Rational>> ListMeasureConOccsWithNonZeroExponents(TcGlobals g, bool eraseAbbrevs, Measure untexpr);
    internal static FSharpList`1<EntityRef> gather@506-6(TcGlobals g, FSharpFunc`2<EntityRef, EntityRef> r, FSharpList`1<EntityRef> acc, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<EntityRef> ListMeasureConOccsAfterRemapping(TcGlobals g, FSharpFunc`2<EntityRef, EntityRef> r, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure MeasurePower(Measure u, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure MeasureProdOpt(Measure m1, Measure m2);
    internal static Measure ProdMeasures(FSharpList`1<Measure> ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDimensionless(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar destUnitParMeasure(TcGlobals g, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnitParMeasure(TcGlobals g, Measure unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure normalizeMeasure(TcGlobals g, Measure ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType tryNormalizeMeasureInType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkNativePtrTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkInByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkOutByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkByrefTyWithFlag(TcGlobals g, bool readonly, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkByref2Ty(TcGlobals g, TType ty1, TType ty2);
    internal static TType mkVoidPtrTy(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkByrefTyWithInference(TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkArrayTy(TcGlobals g, int rank, TType ty, Range m);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_maxTuple();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_goodTupleFields();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isCompiledTupleTyconRef(TcGlobals g, EntityRef tcref);
    [CompilerGeneratedAttribute]
internal static EntityRef mkCompiledTupleTyconRef$cont@654(TcGlobals g, bool isStruct, int n, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkCompiledTupleTyconRef(TcGlobals g, bool isStruct, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkCompiledTupleTy(TcGlobals g, bool isStruct, FSharpList`1<TType> tupElemTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkOuterCompiledTupleTy(TcGlobals g, bool isStruct, FSharpList`1<TType> tupElemTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType applyTyconAbbrev(TType abbrevTy, Entity tycon, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceTyconAbbrev(Entity tycon, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceTyconRefAbbrev(EntityRef tcref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceTyconMeasureableOrProvided(TcGlobals g, Entity tycon, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceTyconRefMeasureableOrProvided(TcGlobals g, EntityRef tcref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqnsA(TcGlobals g, bool canShortcut, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqns(TcGlobals g, TType ty);
    internal static bool evalTupInfoIsStruct(TupInfo aexpr);
    internal static bool evalAnonInfoIsStruct(AnonRecdTypeInfo anonInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqnsAndErase(bool eraseFuncAndTuple, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqnsAndMeasureEqns(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripTyEqnsWrtErasure(Erasure erasureFlag, TcGlobals g, TType ty);
    internal static Entity stripExnEqns(EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, TType> primDestForallTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, TType> destFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TupInfo, FSharpList`1<TType>> destAnyTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> destRefTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> destStructTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar destTyparTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Typar destAnyParTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Measure destMeasureTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<AnonRecdTypeInfo, FSharpList`1<TType>> destAnonRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> destStructAnonRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isForallTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAnyTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRefTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAnonRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructAnonRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructUnionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isReprHiddenTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpObjModelTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpStructOrEnumTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpEnumTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTyparTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAnyParTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isMeasureTy(TcGlobals g, TType ty);
    internal static bool isProvenUnionCaseTy(TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkAppTy(EntityRef tcref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkProvenUnionCaseTy(UnionCaseRef ucref, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Tuple`2<EntityRef, FSharpList`1<TType>>> tryAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<EntityRef, FSharpList`1<TType>> destAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef tcrefOfAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> argsOfAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Typar> tryDestTyparTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Tuple`2<TType, TType>> tryDestFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<EntityRef> tryTcrefOfAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Tuple`2<AnonRecdTypeInfo, FSharpList`1<TType>>> tryDestAnonRecdTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<Typar> tryAnyParTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Typar> tryAnyParTyOption(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<EntityRef, FSharpList`1<TType>>> |AppTy|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<TType>> |RefTupleTy|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<TType, TType>> |FunTy|_|(TcGlobals g, TType ty);
    internal static FSharpValueOption`1<EntityRef> tryNiceEntityRefOfTy(TType ty);
    internal static FSharpOption`1<EntityRef> tryNiceEntityRefOfTyOption(TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<Typar, TType>> mkInstForAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType domainOfFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType rangeOfFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType convertToTypeWithMetadataIfPossible(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripMeasuresFromTy(TcGlobals g, TType ty);
    internal static TypeEquivEnv get_typeEquivEnvEmpty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool traitsAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, TraitConstraintInfo traitInfo1, TraitConstraintInfo traitInfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool traitKeysAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, TraitWitnessInfo witnessInfo1, TraitWitnessInfo witnessInfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool returnTypesAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, FSharpOption`1<TType> retTy, FSharpOption`1<TType> retTy2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarConstraintsAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, TyparConstraint tpc1, TyparConstraint tpc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarConstraintSetsAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, Typar tp1, Typar tp2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarsAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, FSharpList`1<Typar> tps1, FSharpList`1<Typar> tps2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tcrefAEquiv(TcGlobals g, TypeEquivEnv aenv, EntityRef tcref1, EntityRef tcref2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typeAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool anonInfoEquiv(AnonRecdTypeInfo anonInfo1, AnonRecdTypeInfo anonInfo2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool structnessAEquiv(TupInfo un1, TupInfo un2);
    internal static Typar trans@1079(TcGlobals g, TypeEquivEnv aenv, Typar tp1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool measureAEquiv(TcGlobals g, TypeEquivEnv aenv, Measure un1, Measure un2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typesAEquivAux(Erasure erasureFlag, TcGlobals g, TypeEquivEnv aenv, FSharpList`1<TType> l1, FSharpList`1<TType> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typeEquivAux(Erasure erasureFlag, TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typeAEquiv(TcGlobals g, TypeEquivEnv aenv, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typeEquiv(TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool traitsAEquiv(TcGlobals g, TypeEquivEnv aenv, TraitConstraintInfo t1, TraitConstraintInfo t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool traitKeysAEquiv(TcGlobals g, TypeEquivEnv aenv, TraitWitnessInfo t1, TraitWitnessInfo t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarConstraintsAEquiv(TcGlobals g, TypeEquivEnv aenv, TyparConstraint c1, TyparConstraint c2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool typarsAEquiv(TcGlobals g, TypeEquivEnv aenv, FSharpList`1<Typar> d1, FSharpList`1<Typar> d2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool returnTypesAEquiv(TcGlobals g, TypeEquivEnv aenv, FSharpOption`1<TType> t1, FSharpOption`1<TType> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool measureEquiv(TcGlobals g, Measure m1, Measure m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<EntityRef, Measure>> getMeasureOfType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isErasedType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> getErasedTypes(TcGlobals g, TType ty);
    internal static IComparer`1<Val> get_valOrder();
    internal static IComparer`1<Entity> get_tyconOrder();
    internal static IComparer`1<RecdFieldRef> get_recdFieldRefOrder();
    internal static IComparer`1<UnionCaseRef> get_unionCaseRefOrder();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkFunTy(TcGlobals g, TType domainTy, TType rangeTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkForallTyIfNeeded(FSharpList`1<Typar> d, TType r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType op_PlusMinusGreater(FSharpList`1<Typar> d, TType r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIteratedFunTy(TcGlobals g, FSharpList`1<TType> dl, TType r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkLambdaTy(TcGlobals g, FSharpList`1<Typar> tps, FSharpList`1<TType> tys, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkLambdaArgTy(Range m, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType typeOfLambdaArg(Range m, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkMultiLambdaTy(TcGlobals g, Range m, FSharpList`1<Val> vs, TType bodyTy);
    internal static void loop@1197-42(XmlDoc xml, ILScopeRef scoref, FSharpList`1<Tuple`2<string, ModuleOrNamespaceKind>> prior_cpath, FSharpList`1<Ident> path, FSharpList`1<Tuple`2<a, ModuleOrNamespaceKind>> cpath, Entity modul);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ensureCcuHasModuleOrNamespaceAtPath(CcuThunk ccu, FSharpList`1<Ident> path, CompilationPath _arg1, XmlDoc xml);
    internal static Expr stripExpr(Expr e);
    internal static Expr stripDebugPoints(Expr expr);
    internal static Tuple`2<Expr, FSharpFunc`2<Expr, Expr>> |DebugPoints|(Expr expr);
    internal static DecisionTreeCase mkCase(DecisionTreeTest a, DecisionTree b);
    internal static bool isRefTupleExpr(Expr e);
    internal static FSharpList`1<Expr> tryDestRefTupleExpr(Expr e);
    internal static Expr primMkMatch(DebugPointAtBinding spBind, Range mExpr, DecisionTree tree, DecisionTreeTarget[] targets, Range mMatch, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree mkBoolSwitch(Range m, Expr g, DecisionTree t, DecisionTree e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr primMkCond(DebugPointAtBinding spBind, Range m, TType ty, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCond(DebugPointAtBinding spBind, Range m, TType ty, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr exprForValRef(Range m, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr exprForVal(Range m, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkLocalAux(Range m, string s, TType ty, ValMutability mut, bool compgen);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkLocal(Range m, string s, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkCompGenLocal(Range m, string s, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> mkMutableCompGenLocal(Range m, string s, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkMultiLambda(Range m, FSharpList`1<Val> vs, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr rebuildLambda(Range m, FSharpOption`1<Val> ctorThisValOpt, FSharpOption`1<Val> baseValOpt, FSharpList`1<Val> vs, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLambda(Range m, Val v, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTypeLambda(Range m, FSharpList`1<Typar> vs, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTypeChoose(Range m, FSharpList`1<Typar> vs, Expr body);
    internal static Expr mkObjExpr(TType ty, FSharpOption`1<Val> basev, Expr basecall, FSharpList`1<ObjExprMethod> overrides, FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> iimpls, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLambdas(TcGlobals g, Range m, FSharpList`1<Typar> tps, FSharpList`1<Val> vs, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> mkMultiLambdasCore(TcGlobals g, Range m, FSharpList`1<FSharpList`1<Val>> vsl, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkMultiLambdas(TcGlobals g, Range m, FSharpList`1<Typar> tps, FSharpList`1<FSharpList`1<Val>> vsl, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkMemberLambdas(TcGlobals g, Range m, FSharpList`1<Typar> tps, FSharpOption`1<Val> ctorThisValOpt, FSharpOption`1<Val> baseValOpt, FSharpList`1<FSharpList`1<Val>> vsl, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding mkMultiLambdaBind(TcGlobals g, Val v, DebugPointAtBinding letSeqPtOpt, Range m, FSharpList`1<Typar> tps, FSharpList`1<FSharpList`1<Val>> vsl, Expr body, TType bodyTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding mkBind(DebugPointAtBinding seqPtOpt, Val v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLetBind(Range m, Binding bind, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLetsBind(Range m, FSharpList`1<Binding> binds, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLetsFromBindings(Range m, FSharpList`1<Binding> binds, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLet(DebugPointAtBinding seqPtOpt, Range m, Val v, Expr x, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding mkCompGenBind(Val v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> mkCompGenBinds(FSharpList`1<Val> vs, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompGenLet(Range m, Val v, Expr x, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding mkInvisibleBind(Val v, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> mkInvisibleBinds(FSharpList`1<Val> vs, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInvisibleLet(Range m, Val v, Expr x, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInvisibleLets(Range m, FSharpList`1<Val> vs, FSharpList`1<Expr> xs, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLetRecBinds(Range m, FSharpList`1<Binding> binds, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> NormalizeDeclaredTyparsForEquiRecursiveInference(TcGlobals g, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGenericBindRhs(TcGlobals g, Range m, FSharpList`1<Typar> generalizedTyparsForRecursiveBlock, GeneralizedType typeScheme, Expr bodyExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isBeingGeneralized(Typar tp, GeneralizedType typeScheme);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBool(TcGlobals g, Range m, bool b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTrue(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkFalse(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLazyOr(TcGlobals g, Range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLazyAnd(TcGlobals g, Range m, Expr e1, Expr e2);
    internal static Expr mkCoerceExpr(Expr e, TType toTy, Range m, TType fromTy);
    internal static Expr mkAsmExpr(FSharpList`1<ILInstr> code, FSharpList`1<TType> tinst, FSharpList`1<Expr> args, FSharpList`1<TType> rettys, Range m);
    internal static Expr mkUnionCaseExpr(UnionCaseRef uc, FSharpList`1<TType> tinst, FSharpList`1<Expr> args, Range m);
    internal static Expr mkExnExpr(EntityRef uc, FSharpList`1<Expr> args, Range m);
    internal static Expr mkTupleFieldGetViaExprAddr(TupInfo tupInfo, Expr e, FSharpList`1<TType> tinst, int i, Range m);
    internal static Expr mkAnonRecdFieldGetViaExprAddr(AnonRecdTypeInfo anonInfo, Expr e, FSharpList`1<TType> tinst, int i, Range m);
    internal static Expr mkRecdFieldGetViaExprAddr(Expr e, RecdFieldRef fref, FSharpList`1<TType> tinst, Range m);
    internal static Expr mkRecdFieldGetAddrViaExprAddr(bool readonly, Expr e, RecdFieldRef fref, FSharpList`1<TType> tinst, Range m);
    internal static Expr mkStaticRecdFieldGetAddr(bool readonly, RecdFieldRef fref, FSharpList`1<TType> tinst, Range m);
    internal static Expr mkStaticRecdFieldGet(RecdFieldRef fref, FSharpList`1<TType> tinst, Range m);
    internal static Expr mkStaticRecdFieldSet(RecdFieldRef fref, FSharpList`1<TType> tinst, Expr e, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkArrayElemAddress(TcGlobals g, bool readonly, ILReadonly ilInstrReadOnlyAnnotation, bool isNativePtr, ILArrayShape shape, TType elemTy, FSharpList`1<Expr> exprs, Range m);
    internal static Expr mkRecdFieldSetViaExprAddr(Expr e1, RecdFieldRef fref, FSharpList`1<TType> tinst, Expr e2, Range m);
    internal static Expr mkUnionCaseTagGetViaExprAddr(Expr e1, EntityRef cref, FSharpList`1<TType> tinst, Range m);
    internal static Expr mkUnionCaseProof(Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, Range m);
    internal static Expr mkUnionCaseFieldGetProvenViaExprAddr(Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, Range m);
    internal static Expr mkUnionCaseFieldGetAddrProvenViaExprAddr(bool readonly, Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, Range m);
    internal static Expr mkUnionCaseFieldGetUnprovenViaExprAddr(Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, Range m);
    internal static Expr mkUnionCaseFieldSet(Expr e1, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, Expr e2, Range m);
    internal static Expr mkExnCaseFieldGet(Expr e1, EntityRef ecref, int j, Range m);
    internal static Expr mkExnCaseFieldSet(Expr e1, EntityRef ecref, int j, Expr e2, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkDummyLambda(TcGlobals g, Expr bodyExpr, TType bodyExprTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkWhile(TcGlobals g, DebugPointAtWhile spWhile, SpecialWhileLoopMarker marker, Expr guardExpr, Expr bodyExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIntegerForLoop(TcGlobals g, DebugPointAtFor spFor, DebugPointAtInOrTo spIn, Val v, Expr startExpr, ForLoopStyle dir, Expr finishExpr, Expr bodyExpr, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTryWith(TcGlobals g, Expr bodyExpr, Val filterVal, Expr filterExpr, Val handlerVal, Expr handlerExpr, Range m, TType ty, DebugPointAtTry spTry, DebugPointAtWith spWith);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTryFinally(TcGlobals g, Expr bodyExpr, Expr finallyExpr, Range m, TType ty, DebugPointAtTry spTry, DebugPointAtFinally spFinally);
    internal static Expr mkDefault(Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkValSet(Range m, ValRef vref, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAddrSet(Range m, ValRef vref, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAddrGet(Range m, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkValAddr(Range m, bool readonly, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<EntityRef> tryRescopeEntity(CcuThunk viewedCcu, Entity entity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<ValRef> tryRescopeVal(CcuThunk viewedCcu, Remap entityRemap, Val vspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualTyOfRecdField(FSharpList`1<Tuple`2<Typar, TType>> inst, RecdField fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> actualTysOfInstanceRecdFields(FSharpList`1<Tuple`2<Typar, TType>> inst, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> actualTysOfUnionCaseFields(FSharpList`1<Tuple`2<Typar, TType>> inst, UnionCaseRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualResultTyOfUnionCase(FSharpList`1<TType> tinst, UnionCaseRef x);
    internal static FSharpList`1<RecdField> recdFieldsOfExnDefRef(EntityRef x);
    internal static FSharpList`1<TType> recdFieldTysOfExnDefRef(EntityRef x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType recdFieldTyOfExnDefRefByIdx(EntityRef x, int j);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualTyOfRecdFieldForTycon(Entity tycon, FSharpList`1<TType> tinst, RecdField fspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualTyOfRecdFieldRef(RecdFieldRef fref, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType actualTyOfUnionFieldRef(UnionCaseRef fref, int n, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, TType> destForallTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, TType> tryDestForallTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, TType> stripFunTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType applyForallTy(TcGlobals g, TType ty, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType reduceIteratedFunTy(TcGlobals g, TType ty, FSharpList`1<a> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType applyTyArgs(TcGlobals g, TType ty, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType applyTys(TcGlobals g, TType funcTy, FSharpList`1<TType> tyargs, FSharpList`1<T> argTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType formalApplyTys(TcGlobals g, TType funcTy, FSharpList`1<a> tyargs, FSharpList`1<b> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, TType> stripFunTyN(TcGlobals g, int n, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TupInfo, FSharpList`1<TType>> tryDestAnyTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> tryDestRefTupleTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, TType> GetTopTauTypeInFSharpForm(TcGlobals g, FSharpList`1<FSharpList`1<ArgReprInfo>> curriedArgInfos, TType tau, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, TType> destTopForallTy(TcGlobals g, ValReprInfo _arg1, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, TType, ArgReprInfo> GetValReprTypeInFSharpForm(TcGlobals g, ValReprInfo valReprInfo, TType ty, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsCompiledAsStaticProperty(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsCompiledAsStaticPropertyWithField(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isArrayTyconRef(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int rankOfArrayTyconRef(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destArrayTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destListTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tyconRefEqOpt(TcGlobals g, FSharpOption`1<EntityRef> tcrefOpt, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStringTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isListTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isArrayTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isArray1DTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnitTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isObjTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isValueTypeTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isVoidTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILAppTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNativePtrTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isInByrefTag(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isInByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOutByrefTag(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOutByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconRepresentation extensionInfoOfTy(TcGlobals g, TType ty);
    internal static TypeDefMetadata metadataOfTycon(Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TypeDefMetadata metadataOfTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILReferenceTy(TcGlobals g, TType ty);
    internal static bool isILInterfaceTycon(Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int rankOfArrayTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpObjModelRefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpClassTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpStructTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpInterfaceTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDelegateTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isInterfaceTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpDelegateTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isClassTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructOrEnumTyconTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructRecordOrUnionTyconTy(TcGlobals g, TType ty);
    internal static bool isStructTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isStructTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isForallFunctionTy(TcGlobals g, TType ty);
    internal static FSharpFunc`2<RecdField, bool> isUnmanagedRecordField@1974(TcGlobals g, FSharpList`1<Tuple`2<Typar, TType>> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnmanagedTy(TcGlobals g, TType ty);
    internal static bool isInterfaceTycon(Entity x);
    internal static bool isInterfaceTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isEnumTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSignedIntegerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnsignedIntegerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isIntegerTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFpTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isDecimalTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNonDecimalNumericType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNumericType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> actualReturnTyOfSlotSig(FSharpList`1<TType> parentTyInst, FSharpList`1<TType> methTyInst, SlotSig _arg1);
    internal static bool slotSigHasVoidReturnTy(SlotSig _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> returnTyOfMethod(TcGlobals g, ObjExprMethod _arg1);
    internal static bool isAbstractTycon(Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberIsExplicitImpl(TcGlobals g, ValMemberInfo membInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValIsExplicitImpl(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRefIsExplicitImpl(TcGlobals g, ValRef vref);
    internal static Set`2<Val, IComparer`1<Val>> get_emptyFreeLocals();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Val, IComparer`1<Val>> unionFreeLocals(Set`2<Val, IComparer`1<Val>> s1, Set`2<Val, IComparer`1<Val>> s2);
    internal static Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> get_emptyFreeRecdFields();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> unionFreeRecdFields(Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> s1, Set`2<RecdFieldRef, IComparer`1<RecdFieldRef>> s2);
    internal static Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> get_emptyFreeUnionCases();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> unionFreeUnionCases(Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> s1, Set`2<UnionCaseRef, IComparer`1<UnionCaseRef>> s2);
    internal static Set`2<Entity, IComparer`1<Entity>> get_emptyFreeTycons();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Entity, IComparer`1<Entity>> unionFreeTycons(Set`2<Entity, IComparer`1<Entity>> s1, Set`2<Entity, IComparer`1<Entity>> s2);
    internal static IComparer`1<Typar> get_typarOrder();
    internal static Set`2<Typar, IComparer`1<Typar>> get_emptyFreeTypars();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<Typar, IComparer`1<Typar>> unionFreeTypars(Set`2<Typar, IComparer`1<Typar>> s1, Set`2<Typar, IComparer`1<Typar>> s2);
    internal static FreeTyvars get_emptyFreeTyvars();
    internal static bool isEmptyFreeTyvars(FreeTyvars ftyvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars unionFreeTyvars(FreeTyvars fvs1, FreeTyvars fvs2);
    internal static FreeVarOptions get_CollectAllNoCaching();
    internal static FreeVarOptions get_CollectTyparsNoCaching();
    internal static FreeVarOptions get_CollectLocalsNoCaching();
    internal static FreeVarOptions get_CollectTyparsAndLocalsNoCaching();
    internal static FreeVarOptions get_CollectAll();
    internal static FreeVarOptions get_CollectTyparsAndLocals();
    internal static FreeVarOptions get_CollectTypars();
    internal static FreeVarOptions get_CollectLocals();
    internal static FreeVarOptions CollectTyparsAndLocalsWithStackGuard();
    internal static FreeVarOptions CollectLocalsWithStackGuard();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeLocalTycon(FreeVarOptions opts, Entity x, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeTycon(FreeVarOptions opts, EntityRef tcref, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars boundTypars(FreeVarOptions opts, FSharpList`1<Typar> tps, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTyparConstraints(FreeVarOptions opts, FSharpList`1<TyparConstraint> cxs, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTyparConstraint(FreeVarOptions opts, TyparConstraint tpc, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTrait(FreeVarOptions opts, TraitConstraintInfo _arg1, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTraitSln(FreeVarOptions opts, TraitConstraintSln sln, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeLocalValInTraitSln(a _opts, Val v, FreeTyvars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeValRefInTraitSln(FreeVarOptions opts, ValRef vref, FreeTyvars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeTyparRef(FreeVarOptions opts, Typar tp, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInType(FreeVarOptions opts, TType ty, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTupInfo(FreeVarOptions _opts, TupInfo unt, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInMeasure(FreeVarOptions opts, Measure unt, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTypes(FreeVarOptions opts, FSharpList`1<TType> tys, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars freeInType(FreeVarOptions opts, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars freeInTypes(FreeVarOptions opts, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars freeInVal(FreeVarOptions opts, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars accFreeInTypars(FreeVarOptions opts, FSharpList`1<Typar> tps, FreeTyvars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeTyvars addFreeInModuleTy(ModuleOrNamespaceType mtyp, FreeTyvars acc);
    internal static FreeTyvars freeInModuleTy(ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> boundTyparsLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTyparConstraintsLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, FSharpList`1<TyparConstraint> cxs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTyparConstraintLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, TyparConstraint tpc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTraitLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, TraitConstraintInfo _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeTyparRefLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTypeLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTupInfoLeftToRight(TcGlobals _g, bool _cxFlag, bool _thruFlag, FSharpList`1<Typar> acc, TupInfo unt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> accFreeInTypesLeftToRight(TcGlobals g, bool cxFlag, bool thruFlag, FSharpList`1<Typar> acc, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> freeInTypeLeftToRight(TcGlobals g, bool thruFlag, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> freeInTypesLeftToRight(TcGlobals g, bool thruFlag, FSharpList`1<TType> ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Typar> freeInTypesLeftToRightSkippingConstraints(TcGlobals g, FSharpList`1<TType> ty);
    internal static FSharpList`1<Val> valsOfBinds(FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, TType, ArgReprInfo> GetMemberTypeInFSharpForm(TcGlobals g, SynMemberFlags memberFlags, ValReprInfo arities, TType ty, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<a, b> checkMemberVal(FSharpOption`1<a> membInfo, FSharpOption`1<b> arity, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GetFSharpViewOfReturnType(TcGlobals g, FSharpOption`1<TType> retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType TraitConstraintInfo.GetReturnType(TraitConstraintInfo traitInfo, TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> TraitConstraintInfo.GetObjectType(TraitConstraintInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> TraitConstraintInfo.GetCompiledArgumentTypes(TraitConstraintInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> TraitConstraintInfo.GetLogicalArgumentTypes(TraitConstraintInfo traitInfo, TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string TraitConstraintInfo.get_MemberDisplayNameCore(TraitConstraintInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TraitWitnessInfo TraitConstraintInfo.GetWitnessInfo(TraitConstraintInfo );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TraitConstraintInfo> GetTraitConstraintInfosOfTypars(TcGlobals g, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TraitWitnessInfo> GetTraitWitnessInfosOfTypars(TcGlobals g, int numParentTypars, FSharpList`1<Typar> typars);
    internal static int CountEnclosingTyparsOfActualParentOfVal(Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<FSharpList`1<Typar>, FSharpList`1<TraitWitnessInfo>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpOption`1<TType>, ArgReprInfo> GetValReprTypeInCompiledForm(TcGlobals g, ValReprInfo valReprInfo, int numEnclosingTypars, TType ty, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<FSharpList`1<Typar>, FSharpList`1<TraitWitnessInfo>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpOption`1<TType>, ArgReprInfo> GetMemberTypeInMemberForm(TcGlobals g, SynMemberFlags memberFlags, ValReprInfo valReprInfo, int numEnclosingTypars, TType ty, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<FSharpList`1<Typar>, FSharpList`1<TraitWitnessInfo>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpOption`1<TType>, ArgReprInfo> GetTypeOfMemberInMemberForm(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, TType, ArgReprInfo> GetTypeOfMemberInFSharpForm(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>>> PartitionValTyparsForApparentEnclosingType(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>>> PartitionValTypars(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Typar>, FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>>> PartitionValRefTypars(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> ArgInfosOfMemberVal(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> ArgInfosOfMember(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ReturnTypeOfPropertyVal(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`2<TType, ArgReprInfo>> ArgInfosOfPropertyVal(TcGlobals g, Val v);
    internal static FSharpList`1<TType> generalTyconRefInst(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<TType>, TType> generalizeTyconRef(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType generalizedTyconRef(TcGlobals g, EntityRef tcref);
    internal static string prefixOfStaticReq(TyparStaticReq s);
    internal static string prefixOfInferenceTypar(Typar typar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string op_PlusDotPlus(string s1, string s2);
    internal static Layout layoutOfPath(FSharpList`1<string> p);
    internal static FSharpValueOption`1<string> fullNameOfParentOfPubPath(PublicPath pp);
    internal static FSharpValueOption`1<Layout> fullNameOfParentOfPubPathAsLayout(PublicPath pp);
    internal static FSharpValueOption`1<string> fullNameOfParentOfNonLocalEntityRef(NonLocalEntityRef nlr);
    internal static FSharpValueOption`1<Layout> fullNameOfParentOfNonLocalEntityRefAsLayout(NonLocalEntityRef nlr);
    internal static FSharpValueOption`1<string> fullNameOfParentOfEntityRef(EntityRef eref);
    internal static FSharpValueOption`1<Layout> fullNameOfParentOfEntityRefAsLayout(EntityRef eref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string fullNameOfEntityRef(FSharpFunc`2<EntityRef, string> nmF, EntityRef xref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TaggedText tagEntityRefName(EntityRef xref, string name);
    internal static string fullDisplayTextOfTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Layout fullNameOfEntityRefAsLayout(FSharpFunc`2<EntityRef, string> nmF, EntityRef xref);
    internal static FSharpValueOption`1<string> fullNameOfParentOfValRef(ValRef vref);
    internal static FSharpValueOption`1<Layout> fullNameOfParentOfValRefAsLayout(ValRef vref);
    internal static FSharpValueOption`1<string> fullDisplayTextOfParentOfModRef(EntityRef eref);
    internal static string fullDisplayTextOfModRef(EntityRef r);
    internal static Layout fullDisplayTextOfTyconRefAsLayout(EntityRef tcref);
    internal static string fullDisplayTextOfExnRef(EntityRef tcref);
    internal static Layout fullDisplayTextOfExnRefAsLayout(EntityRef tcref);
    internal static string fullDisplayTextOfUnionCaseRef(UnionCaseRef ucref);
    internal static string fullDisplayTextOfRecdFieldRef(RecdFieldRef rfref);
    internal static string fullDisplayTextOfValRef(ValRef vref);
    internal static Layout fullDisplayTextOfValRefAsLayout(ValRef vref);
    internal static String[] fullMangledPathToTyconRef(EntityRef tcref);
    internal static string tyconRefToFullName(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string qualifiedInterfaceImplementationNameAux(TcGlobals g, TType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string qualifiedInterfaceImplementationName(TcGlobals g, TType ty, string memberName);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string qualifiedMangledNameOfTyconRef(EntityRef tcref, string nm);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool firstEq(FSharpList`1<a> p1, FSharpList`1<a> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> firstRem(FSharpList`1<a> p1, FSharpList`1<b> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string trimPathByDisplayEnv(DisplayEnv denv, FSharpList`1<string> path);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType superOfTycon(TcGlobals g, Entity tycon);
    internal static EntityRef[] supersOfTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isILAttribByName(FSharpList`1<string> tencl, string tname, ILAttribute attr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasILAttribute(ILTypeRef tref, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>>> TryDecodeILAttribute(ILTypeRef tref, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMatchingFSharpAttribute(TcGlobals g, BuiltinAttribInfo _arg2, Attrib _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasFSharpAttribute(TcGlobals g, BuiltinAttribInfo tref, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Attrib> TryFindFSharpAttribute(TcGlobals g, BuiltinAttribInfo tref, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Attrib> TryFindFSharpAttributeOpt(TcGlobals g, FSharpOption`1<BuiltinAttribInfo> tref, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasFSharpAttributeOpt(TcGlobals g, FSharpOption`1<BuiltinAttribInfo> trefOpt, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMatchingFSharpAttributeOpt(TcGlobals g, FSharpOption`1<BuiltinAttribInfo> attrOpt, Attrib _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<AttribExpr> |ExtractAttribNamedArg|_|(string nm, FSharpList`1<AttribNamedArg> args);
    internal static FSharpOption`1<string> |StringExpr|_|(Expr _arg1);
    internal static FSharpOption`1<int> |AttribInt32Arg|_|(AttribExpr _arg1);
    internal static FSharpOption`1<short> |AttribInt16Arg|_|(AttribExpr _arg1);
    internal static FSharpOption`1<bool> |AttribBoolArg|_|(AttribExpr _arg1);
    internal static FSharpOption`1<string> |AttribStringArg|_|(AttribExpr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindFSharpBoolAttributeWithDefault(bool dflt, TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindFSharpBoolAttribute(TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindFSharpBoolAttributeAssumeFalse(TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> TryFindFSharpInt32Attribute(TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindFSharpStringAttribute(TcGlobals g, BuiltinAttribInfo nm, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TryFindILAttribute(BuiltinAttribInfo _arg1, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TryFindILAttributeOpt(FSharpOption`1<BuiltinAttribInfo> attr, ILAttributes attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> TryBindTyconRefAttribute(TcGlobals g, Range m, BuiltinAttribInfo args, EntityRef tcref, FSharpFunc`2<Tuple`2<FSharpList`1<ILAttribElem>, FSharpList`1<Tuple`4<string, ILType, bool, ILAttribElem>>>, FSharpOption`1<a>> f1, FSharpFunc`2<Attrib, FSharpOption`1<a>> f2, FSharpFunc`2<Tuple`2<FSharpList`1<FSharpOption`1<object>>, FSharpList`1<Tuple`2<string, FSharpOption`1<object>>>>, FSharpOption`1<a>> f3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindTyconRefBoolAttribute(TcGlobals g, Range m, BuiltinAttribInfo attribSpec, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<bool> TryFindAttributeUsageAttribute(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> TryFindTyconRefStringAttribute(TcGlobals g, Range m, BuiltinAttribInfo attribSpec, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconRefHasAttribute(TcGlobals g, Range m, BuiltinAttribInfo attribSpec, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconRefHasAttributeByName(Range m, string attrFullName, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isByrefTyconRef(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isByrefLikeTyconRef(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpanLikeTyconRef(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isByrefLikeTy(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpanLikeTy(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpanTyconRef(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSpanTy(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<EntityRef, TType>> tryDestSpanTy(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<EntityRef, TType> destSpanTy(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isReadOnlySpanTyconRef(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isReadOnlySpanTy(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<EntityRef, TType>> tryDestReadOnlySpanTy(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<EntityRef, TType> destReadOnlySpanTy(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destByrefTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |ByrefTy|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destNativePtrTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRefCellTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destRefCellTy(TcGlobals g, TType ty);
    internal static TType StripSelfRefCell(TcGlobals g, ValBaseOrThisInfo baseOrThisInfo, TType tau);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkRefCellTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkLazyTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkPrintfFormatTy(TcGlobals g, TType aty, TType bty, TType cty, TType dty, TType ety);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkValueOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkNullableTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkListTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isValueOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<TType> tryDestOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<TType> tryDestValueOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destValueOptionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNullableTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<TType> tryDestNullableTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destNullableTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |NullableTy|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType |StripNullableTy|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isLinqExpressionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> tryDestLinqExpressionTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destLinqExpressionTy(TcGlobals g, TType ty);
    internal static UnionCaseRef mkNoneCase(TcGlobals g);
    internal static UnionCaseRef mkSomeCase(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSome(TcGlobals g, TType ty, Expr arg, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNone(TcGlobals g, TType ty, Range m);
    internal static UnionCaseRef mkValueSomeCase(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef mkAnySomeCase(TcGlobals g, bool isStruct);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRef.get_IsDispatchSlot(ValRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<ValRef, Expr>> |UnopExpr|_|(a _g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<ValRef, Expr, Expr>> |BinopExpr|_|(a _g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> |SpecificUnopExpr|_|(TcGlobals g, ValRef vrefReqd, Expr expr);
    internal static FSharpOption`1<Unit> |SignedConstExpr|_|(Expr expr);
    internal static FSharpOption`1<Unit> |IntegerConstExpr|_|(Expr expr);
    internal static FSharpOption`1<Unit> |FloatConstExpr|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Expr>> |SpecificBinopExpr|_|(TcGlobals g, ValRef vrefReqd, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> |EnumExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Expr>> |AttribBitwiseOrExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUncheckedDefaultOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTypeOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSizeOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNameOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTypeDefOfValRef(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |UncheckedDefaultOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |TypeOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |SizeOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |TypeDefOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> |NameOfExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |SeqExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity wrapModuleOrNamespaceType(Ident id, CompilationPath cpath, ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceType, Entity> wrapModuleOrNamespaceTypeInNamespace(Ident id, CompilationPath cpath, ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceContents wrapModuleOrNamespaceContentsInNamespace(bool isModule, Ident id, CompilationPath cpath, ModuleOrNamespaceContents mexpr);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@4656-38(SignatureHidingInfo this, SignatureHidingInfo obj, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static int CompareTo$cont@4656-39(IComparer comp, SignatureHidingInfo this, SignatureHidingInfo objTemp, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap addValRemap(Val v, Val vNew, Remap tmenv);
    internal static Remap mkRepackageRemapping(SignatureRepackageInfo mrpi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemap(ModuleOrNamespaceType msigty, Entity entity, SignatureRepackageInfo mrpi, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accSubEntityRemap(ModuleOrNamespaceType msigty, Entity entity, SignatureRepackageInfo mrpi, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool valLinkageAEquiv(TcGlobals g, TypeEquivEnv aenv, Val v1, Val v2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemap(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType msigty, Val implVal, SignatureRepackageInfo mrpi, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType getCorrespondingSigTy(string nm, ModuleOrNamespaceType msigty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemapFromModuleOrNamespaceType(ModuleOrNamespaceType mty, ModuleOrNamespaceType msigty, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemapFromModuleOrNamespaceType(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType mty, ModuleOrNamespaceType msigty, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> ComputeRemappingFromInferredSignatureToExplicitSignature(TcGlobals g, ModuleOrNamespaceType mty, ModuleOrNamespaceType msigty);
    internal static FSharpList`1<ValRef> abstractSlotValRefsOfTycons(FSharpList`1<Entity> tycons);
    internal static FSharpList`1<Val> abstractSlotValsOfTycons(FSharpList`1<Entity> tycons);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemapFromModuleOrNamespace(ModuleOrNamespaceType msigty, ModuleOrNamespaceContents x, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemapFromModuleOrNamespaceDefs(ModuleOrNamespaceType msigty, FSharpList`1<ModuleOrNamespaceContents> mdefs, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accEntityRemapFromModuleOrNamespaceBind(ModuleOrNamespaceType msigty, ModuleOrNamespaceBinding x, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemapFromModuleOrNamespace(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType msigty, ModuleOrNamespaceContents x, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemapFromModuleOrNamespaceBind(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType msigty, ModuleOrNamespaceBinding x, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> accValRemapFromModuleOrNamespaceDefs(TcGlobals g, TypeEquivEnv aenv, ModuleOrNamespaceType msigty, FSharpList`1<ModuleOrNamespaceContents> mdefs, SignatureRepackageInfo acc_0, SignatureHidingInfo acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SignatureRepackageInfo, SignatureHidingInfo> ComputeRemappingFromImplementationToSignature(TcGlobals g, ModuleOrNamespaceContents mdef, ModuleOrNamespaceType msigty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo accTyconHidingInfoAtAssemblyBoundary(Entity tycon, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo accValHidingInfoAtAssemblyBoundary(Val vspec, SignatureHidingInfo mhi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo accModuleOrNamespaceHidingInfoAtAssemblyBoundary(ModuleOrNamespaceType mty, SignatureHidingInfo acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo ComputeSignatureHidingInfoAtAssemblyBoundary(ModuleOrNamespaceType mty, SignatureHidingInfo acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo accImplHidingInfoAtAssemblyBoundary(ModuleOrNamespaceContents mdef, SignatureHidingInfo acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SignatureHidingInfo ComputeImplementationHidingInfoAtAssemblyBoundary(ModuleOrNamespaceContents mty, SignatureHidingInfo acc);
    internal static bool check@4927-2(FSharpFunc`2<a, Set`2<b, IComparer`1<b>>> setF, FSharpFunc`2<b, Accessibility> accessF, FSharpFunc`2<c, FSharpFunc`2<b, b>> remapF, FSharpList`1<Tuple`2<c, a>> mrmi, b x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<FSharpList`1<Tuple`2<c, a>>, FSharpFunc`2<b, bool>> IsHidden(FSharpFunc`2<a, Set`2<b, IComparer`1<b>>> setF, FSharpFunc`2<b, Accessibility> accessF, FSharpFunc`2<c, FSharpFunc`2<b, b>> remapF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsHiddenTycon(FSharpList`1<Tuple`2<Remap, SignatureHidingInfo>> mrmi, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsHiddenTyconRepr(FSharpList`1<Tuple`2<Remap, SignatureHidingInfo>> mrmi, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsHiddenVal(FSharpList`1<Tuple`2<Remap, SignatureHidingInfo>> mrmi, Val x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsHiddenRecdField(FSharpList`1<Tuple`2<Remap, SignatureHidingInfo>> mrmi, RecdFieldRef x);
    internal static a go@4953-8(FSharpFunc`2<Entity, FSharpFunc`2<a, a>> ft, FSharpFunc`2<Val, FSharpFunc`2<a, a>> fv, ModuleOrNamespaceType mty, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldModuleOrNamespaceTy(FSharpFunc`2<Entity, FSharpFunc`2<a, a>> ft, FSharpFunc`2<Val, FSharpFunc`2<a, a>> fv, ModuleOrNamespaceType mty, a acc);
    internal static FSharpList`1<Val> allValsOfModuleOrNamespaceTy(ModuleOrNamespaceType m);
    internal static FSharpList`1<Entity> allEntitiesOfModuleOrNamespaceTy(ModuleOrNamespaceType m);
    internal static bool isPublicUnionCase(UnionCaseRef ucr);
    internal static bool isPublicRecdField(RecdFieldRef rfr);
    internal static bool freeVarsAllPublic(FreeVars fvs);
    internal static bool freeTyvarsAllPublic(FreeTyvars tyvars);
    internal static FSharpOption`1<Tuple`7<DebugPointAtBinding, Range, DecisionTree, DecisionTreeTarget, Expr, Range, TType>> |LinearMatchExpr|_|(Expr expr);
    internal static Expr rebuildLinearMatchExpr(DebugPointAtBinding sp, Range m, DecisionTree dtree, DecisionTreeTarget tg1, Expr e2, Range m2, TType ty);
    internal static FSharpOption`1<Tuple`5<TOp, FSharpList`1<TType>, FSharpList`1<Expr>, Expr, Range>> |LinearOpExpr|_|(Expr expr);
    internal static Expr rebuildLinearOpExpr(TOp op, FSharpList`1<TType> tinst, FSharpList`1<Expr> argsFront, Expr argLast, Range m);
    internal static FreeVars get_emptyFreeVars();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars unionFreeVars(FreeVars fvs1, FreeVars fvs2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeVarsInTy(FreeVarOptions opts, TType ty, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeVarsInTys(FreeVarOptions opts, FSharpList`1<TType> tys, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreevarsInTycon(FreeVarOptions opts, EntityRef tcref, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreevarsInVal(FreeVarOptions opts, Val v, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeVarsInTraitSln(FreeVarOptions opts, TraitConstraintSln tys, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeVarsInTraitInfo(FreeVarOptions opts, TraitConstraintInfo tys, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars boundLocalVal(FreeVarOptions opts, Val v, FreeVars fvs);
    internal static FreeVars boundProtect(FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accUsesFunctionLocalConstructs(bool flg, FreeVars fvs);
    internal static FreeVars bound_rethrow(FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accUsesRethrow(bool flg, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars boundLocalVals(FreeVarOptions opts, FSharpList`1<Val> vs, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a freeVarsCacheCompute(FreeVarOptions opts, cache`1<a> cache, FSharpFunc`2<Unit, a> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<a> tryGetFreeVarsCacheValue(FreeVarOptions opts, cache`1<a> cache);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInSwitchCases(FreeVarOptions opts, FSharpList`1<DecisionTreeCase> csl, FSharpOption`1<DecisionTree> dflt, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInSwitchCase(FreeVarOptions opts, DecisionTreeCase _arg2, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInTest(FreeVarOptions opts, DecisionTreeTest discrim, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInDecisionTree(FreeVarOptions opts, DecisionTree x, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInValFlags(FreeVarOptions opts, ValUseFlag flag, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeLocalVal(FreeVarOptions opts, Val v, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accLocalTyconRepr(FreeVarOptions opts, Entity b, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accUsedRecdOrUnionTyconRepr(FreeVarOptions opts, Entity tc, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeUnionCaseRef(FreeVarOptions opts, UnionCaseRef ucref, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeRecdFieldRef(FreeVarOptions opts, RecdFieldRef rfref, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeValRef(FreeVarOptions opts, ValRef vref, FreeVars fvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInMethod(FreeVarOptions opts, ObjExprMethod _arg3, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInInterfaceImpl(FreeVarOptions opts, TType ty, FSharpList`1<ObjExprMethod> overrides, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExpr(FreeVarOptions opts, Expr x, FreeVars acc);
    [CompilerGeneratedAttribute]
internal static FreeVars func1@1(FreeVarOptions opts, FreeVars acc, cache`1<FreeVars> cache, Binding bind, FreeVars free);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExprLinear(FreeVarOptions opts, Expr x, FreeVars acc, FSharpFunc`2<FreeVars, FreeVars> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExprNonLinear(FreeVarOptions opts, Expr x, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExprNonLinearImpl(FreeVarOptions opts, Expr x, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInOp(FreeVarOptions opts, TOp op, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInTargets(FreeVarOptions opts, DecisionTreeTarget[] targets, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInTarget(FreeVarOptions opts, DecisionTreeTarget _arg4, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInFlatExprs(FreeVarOptions opts, FSharpList`1<Expr> exprs, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInExprs(FreeVarOptions opts, FSharpList`1<Expr> exprs, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInSlotSig(FreeVarOptions opts, SlotSig _arg5, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars freeInDecisionTree(FreeVarOptions opts, DecisionTree dtree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars freeInExpr(FreeVarOptions opts, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInModuleOrNamespace(FreeVarOptions opts, ModuleOrNamespaceContents mexpr, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInModuleOrNamespaceBind(FreeVarOptions opts, ModuleOrNamespaceBinding mbind, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars accFreeInModuleOrNamespaces(FreeVarOptions opts, FSharpList`1<ModuleOrNamespaceContents> mexprs, FreeVars acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars freeInBindingRhs(FreeVarOptions opts, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FreeVars freeInModuleOrNamespace(FreeVarOptions opts, ModuleOrNamespaceContents mdef);
    internal static Tuple`3<FSharpList`1<FSharpList`1<Val>>, Expr, TType> stripLambda(Expr expr, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<FSharpList`1<Val>>, Expr, int> stripLambdaN(int n, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<FSharpList`1<FSharpList`1<Val>>, Expr>> tryStripLambdaN(int n, Expr expr);
    internal static Tuple`4<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Val>>, Expr, TType> stripTopLambda(Expr expr, TType exprTy);
    internal static Tuple`2<FSharpList`1<FSharpList`1<Val>>, Expr> stripLambda_notypes@5469(Expr e);
    internal static Tuple`3<FSharpList`1<Typar>, FSharpList`1<FSharpList`1<Val>>, Expr> stripTopLambdaNoTypes@5478(Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo InferValReprInfoOfExpr(TcGlobals g, AllowTypeDirectedDetupling allowTypeDirectedDetupling, TType ty, FSharpList`1<FSharpList`1<FSharpList`1<Attrib>>> partialArgAttribsL, FSharpList`1<Attrib> retAttribs, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo InferValReprInfoOfBinding(TcGlobals g, AllowTypeDirectedDetupling allowTypeDirectedDetupling, Val v, Expr expr);
    [CompilerGeneratedAttribute]
internal static TType underlyingTypeOfEnumTy$cont@5531(TcGlobals g, TypeDefMetadata matchValue, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType underlyingTypeOfEnumTy(TcGlobals g, TType ty);
    internal static Val ClearValReprInfo(Val f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType normalizeEnumTy(TcGlobals g, TType ty);
    internal static StaticOptimizationAnswer checkTypes@5588(TcGlobals g, TType a, TType b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StaticOptimizationAnswer decideStaticOptimizationConstraint(TcGlobals g, StaticOptimization c, bool canDecideTyparEqn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StaticOptimizationAnswer DecideStaticOptimizations(TcGlobals g, FSharpList`1<StaticOptimization> cs, bool canDecideTyparEqn);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticOptimizationExpr(TcGlobals g, FSharpList`1<StaticOptimization> cs, Expr e1, Expr e2, Range m);
    internal static ValCopyFlag fixValCopyFlagForQuotations(ValCopyFlag _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val markAsCompGen(ValCopyFlag compgen, Val d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap bindLocalVal(Val v, Val v', Remap tmenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap bindLocalVals(FSharpList`1<Val> vs, FSharpList`1<Val> vs', Remap tmenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap bindTycons(FSharpList`1<Entity> tcs, FSharpList`1<Entity> tcs', Remap tyenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AttribKind remapAttribKind(Remap tmenv, AttribKind k);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Typar>, Remap> tmenvCopyRemapAndBindTypars(FSharpFunc`2<FSharpList`1<Attrib>, FSharpList`1<Attrib>> remapAttrib, Remap tmenv, FSharpList`1<Typar> tps);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Attrib remapAttribImpl(RemapContext ctxt, Remap tmenv, Attrib _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static AttribExpr remapAttribExpr(RemapContext ctxt, Remap tmenv, AttribExpr _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Attrib> remapAttribs(RemapContext ctxt, Remap tmenv, FSharpList`1<Attrib> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ArgReprInfo remapArgData(RemapContext ctxt, Remap tmenv, ArgReprInfo argInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValReprInfo remapValReprInfo(RemapContext ctxt, Remap tmenv, ValReprInfo _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val remapValData(RemapContext ctxt, Remap tmenv, Val d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ParentRef remapParentRef(Remap tyenv, ParentRef p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType mapImmediateValsAndTycons(FSharpFunc`2<Entity, Entity> ft, FSharpFunc`2<Val, Val> fv, ModuleOrNamespaceType x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val copyVal(ValCopyFlag compgen, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void fixupValData(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, Val v2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, Remap> copyAndRemapAndBindVals(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Remap> copyAndRemapAndBindVal(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapExprImpl(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapLambaExpr(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, FSharpOption`1<Val> ctorThisValOpt, FSharpOption`1<Val> baseValOpt, FSharpList`1<Val> vs, Expr body, Range m, TType bodyTy);
    internal static Tuple`4<a, FSharpList`1<TType>, FSharpList`1<Expr>, b> doData@5866(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, a typeDefs, FSharpList`1<TType> argTypes, FSharpList`1<Expr> argExprs, b res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapQuoteExpr(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, Expr a, FSharpRef`1<FSharpOption`1<Tuple`2<Tuple`4<FSharpList`1<ILTypeRef>, FSharpList`1<TType>, FSharpList`1<Expr>, ExprData>, Tuple`4<FSharpList`1<ILTypeRef>, FSharpList`1<TType>, FSharpList`1<Expr>, ExprData>>>> dataCell, bool isFromQueryExpression, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapOpExpr(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, TOp op, FSharpList`1<TType> tinst, FSharpList`1<Expr> args, Range m, Expr origExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapAppExpr(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, Expr e1, TType e1ty, FSharpList`1<TType> tyargs, FSharpList`1<Expr> args, Range m, Expr origExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTreeTarget remapTarget(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, DecisionTreeTarget _arg4);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-1(Expr expr, Range m, Expr expr2, Expr expr1, SequentialOpKind dir, Expr expr1R, Expr expr2R);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-2(DebugPointAtBinding spBind, Range mExpr, Range m2, DecisionTree dtreeR, DecisionTreeTarget tg1R, TType tyR, Expr expr2R);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-3(Expr expr, FSharpList`1<TType> tyargs, TOp op, Range m, FSharpList`1<Expr> argsFront, Expr argLast, TOp opR, FSharpList`1<TType> tinstR, FSharpList`1<Expr> argsFrontR, Expr argLastR);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapLinearExpr(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, Expr expr, FSharpFunc`2<Expr, Expr> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static StaticOptimization remapConstraint(Remap tyenv, StaticOptimization c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TOp remapOp(Remap tmenv, TOp op);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValUseFlag remapValFlags(Remap tmenv, ValUseFlag x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Expr> remapExprs(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree remapDecisionTree(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Binding, Remap> copyAndRemapAndBindBinding(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, Remap> copyAndRemapAndBindBindings(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> remapAndRenameBinds(RemapContext ctxt, ValCopyFlag compgen, Remap tmenvinner, FSharpList`1<Binding> binds, FSharpList`1<Val> vsR);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding remapAndRenameBind(RemapContext ctxt, ValCopyFlag compgen, Remap tmenvinner, Binding _arg5, Val vR);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ObjExprMethod remapMethod(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, ObjExprMethod _arg6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, FSharpList`1<ObjExprMethod>> remapInterfaceImpl(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static RecdField remapRecdField(RemapContext ctxt, Remap tmenv, RecdField x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconRecdFields remapRecdFields(RemapContext ctxt, Remap tmenv, TyconRecdFields x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCase remapUnionCase(RemapContext ctxt, Remap tmenv, UnionCase x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconUnionData remapUnionCases(RemapContext ctxt, Remap tmenv, TyconUnionData x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpTyconData remapFsObjData(RemapContext ctxt, Remap tmenv, FSharpTyconData x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconRepresentation remapTyconRepr(RemapContext ctxt, Remap tmenv, TyconRepresentation repr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyconAugmentation remapTyconAug(Remap tmenv, TyconAugmentation x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ExceptionInfo remapTyconExnInfo(RemapContext ctxt, Remap tmenv, ExceptionInfo inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValMemberInfo remapMemberInfo(RemapContext ctxt, Range m, FSharpOption`1<ValReprInfo> valReprInfo, TType ty, TType tyR, Remap tmenv, ValMemberInfo x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<ModuleOrNamespaceType, Remap> copyAndRemapAndBindModTy(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType remapModTy(ValCopyFlag _compgen, Remap tmenv, ModuleOrNamespaceType mty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity renameTycon(Remap tyenv, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val renameVal(Remap tmenv, Val x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity copyTycon(ValCopyFlag compgen, Entity tycon);
    internal static Entity lookupTycon@6158(Remap tmenvinner, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<FSharpList`1<Entity>, FSharpList`1<Val>, Remap> copyAndRemapAndBindTyconsAndVals(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, FSharpList`1<Entity> tycons, FSharpList`1<Val> vs);
    internal static IEnumerable`1<Entity> allTyconsOfTycon(Entity tycon);
    internal static IEnumerable`1<Entity> allEntitiesOfModDef(ModuleOrNamespaceContents mdef);
    internal static IEnumerable`1<Val> allValsOfModDef(ModuleOrNamespaceContents mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceContents copyAndRemapModDef(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceContents mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<OpenDeclaration> remapOpenDeclarations(Remap tmenv, FSharpList`1<OpenDeclaration> opens);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceContents remapAndRenameModDef(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceContents mdef);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceBinding remapAndRenameModBind(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<CheckedImplFile, Remap> remapImplFile(RemapContext ctxt, ValCopyFlag compgen, Remap tmenv, CheckedImplFile implFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Attrib remapAttrib(TcGlobals g, Remap tmenv, Attrib attrib);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remapExpr(TcGlobals g, ValCopyFlag compgen, Remap tmenv, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType remapPossibleForallTy(TcGlobals g, Remap tmenv, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceType copyModuleOrNamespaceType(TcGlobals g, ValCopyFlag compgen, ModuleOrNamespaceType mtyp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr copyExpr(TcGlobals g, ValCopyFlag compgen, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CheckedImplFile copyImplFile(TcGlobals g, ValCopyFlag compgen, CheckedImplFile e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr instExpr(TcGlobals g, FSharpList`1<Tuple`2<Typar, TType>> tpinst, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr remarkExpr(Range m, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ObjExprMethod remarkObjExprMethod(Range m, ObjExprMethod _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, FSharpList`1<ObjExprMethod>> remarkInterfaceImpl(Range m, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Expr> remarkExprs(Range m, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree remarkDecisionTree(Range m, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Binding> remarkBinds(Range m, FSharpList`1<Binding> binds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding remarkBind(Range m, Binding _arg2);
    internal static bool isRecdOrStructFieldDefinitelyMutable(RecdField f);
    internal static bool isUnionCaseDefinitelyMutable(UnionCase uc);
    internal static bool isUnionCaseRefDefinitelyMutable(UnionCaseRef uc);
    internal static bool isRecdOrUnionOrStructTyconRefDefinitelyMutable(EntityRef tcref);
    internal static bool isExnDefinitelyMutable(EntityRef _ecref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isUnionCaseFieldMutable(TcGlobals g, UnionCaseRef ucref, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isExnFieldMutable(EntityRef ecref, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool useGenuineField(Entity tycon, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ComputeFieldName(Entity tycon, RecdField f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isQuotedExprTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destQuotedExprTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkQuotedExprTy(TcGlobals g, TType ty);
    internal static TType mkRawQuotedExprTy(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkAnyTupledTy(TcGlobals g, TupInfo tupInfo, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkAnyAnonRecdTy(TcGlobals _g, AnonRecdTypeInfo anonInfo, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkRefTupledTy(TcGlobals g, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkRefTupledVarsTy(TcGlobals g, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkMethodTy(TcGlobals g, FSharpList`1<FSharpList`1<TType>> argTys, TType retTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkArrayType(TcGlobals g, TType ty);
    internal static TType mkByteArrayTy(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<TType>> GenWitnessArgTys(TcGlobals g, TraitWitnessInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType GenWitnessTy(TcGlobals g, TraitWitnessInfo traitInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> GenWitnessTys(TcGlobals g, FSharpList`1<TraitWitnessInfo> cxs);
    [CompilerGeneratedAttribute]
internal static TType tyOfExpr$cont@6540(TcGlobals g, Expr expr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType tyOfExpr(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr primMkApp(Expr f, TType fty, FSharpList`1<TType> tyargs, FSharpList`1<Expr> argsl, Range m);
    internal static bool loop@6593-43(TcGlobals g, TType fty, FSharpList`1<d> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isExpansiveUnderInstantiation(TcGlobals g, TType fty0, FSharpList`1<a> tyargs, FSharpList`1<b> pargs, FSharpList`1<c> argsl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkExprAppAux(TcGlobals g, Expr f, TType fty, FSharpList`1<Expr> argsl, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAppsAux(TcGlobals g, Expr f, TType fty, FSharpList`1<FSharpList`1<TType>> tyargsl, FSharpList`1<Expr> argsl, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkApps(TcGlobals g, Tuple`2<Expr, TType> _arg1, FSharpList`1<FSharpList`1<TType>> tyargsl, FSharpList`1<Expr> argl, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTyAppExpr(Range m, Expr f, TType fty, FSharpList`1<TType> tyargs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<int> accTargetsOfDecisionTree(DecisionTree tree, FSharpList`1<int> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree mapTargetsOfDecisionTree(FSharpFunc`2<int, int> f, DecisionTree tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTreeCase mapTargetsOfDecisionTreeCase(FSharpFunc`2<int, int> f, DecisionTreeCase _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, a[]> eliminateDeadTargetsFromMatch(DecisionTree tree, a[] targets);
    internal static FSharpOption`1<int> targetOfSuccessDecisionTree(DecisionTree tree);
    internal static bool decisionTreeHasNonTrivialBindings(DecisionTree tree);
    internal static void accumulateTipsOfDecisionTree@6707(FSharpList`1[] branchesToTargets, FSharpList`1<Binding> accBinds, DecisionTree tree);
    internal static bool isLinearTarget@6723(FSharpList`1<a> bs);
    internal static DecisionTree rebuildDecisionTree@6735(FSharpList`1[] branchesToTargets, FSharpFunc`2<DecisionTreeCase, DecisionTreeCase> rebuildDecisionTreeEdge, DecisionTree tree);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<DecisionTree, DecisionTreeTarget[]> foldLinearBindingTargetsOfMatch(DecisionTree tree, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr simplifyTrivialMatch(DebugPointAtBinding spBind, Range mExpr, Range mMatch, TType ty, DecisionTree tree, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAndSimplifyMatch(DebugPointAtBinding spBind, Range mExpr, Range mMatch, TType ty, DecisionTree tree, FSharpList`1<DecisionTreeTarget> targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdOrStructTyconRefAssumedImmutable(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTyconRefReadOnly(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTyconRefAssumedReadOnly(TcGlobals g, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdOrStructTyconRefReadOnlyAux(TcGlobals g, Range m, bool isInref, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdOrStructTyconRefReadOnly(TcGlobals g, Range m, EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdOrStructTyReadOnlyAux(TcGlobals g, Range m, bool isInref, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isRecdOrStructTyReadOnly(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOf(TcGlobals g, Range m, bool isInref, TType ty, Mutates mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOfImmutableVal(TcGlobals g, Range m, ValRef vref, Mutates mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MustTakeAddressOfVal(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MustTakeAddressOfByrefGet(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOfByrefGet(TcGlobals g, ValRef vref, Mutates mut);
    internal static bool MustTakeAddressOfRecdField(RecdField rfref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOfRecdFieldRef(TcGlobals g, Range m, RecdFieldRef rfref, FSharpList`1<TType> tinst, Mutates mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanTakeAddressOfUnionFieldRef(TcGlobals g, Range m, UnionCaseRef uref, int cidx, FSharpList`1<TType> tinst, Mutates mut);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkDerefAddrExpr(Range mAddrGet, Expr expr, Range mExpr, TType exprTy);
    internal static void checkTakeNativeAddress@6930(Range m, bool isNativePtr, bool readonly);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpOption`1<Tuple`2<Val, Expr>>, Expr, bool, bool> mkExprAddrOfExprAux(TcGlobals g, bool mustTakeAddress, bool useReadonlyForGenericArrayAddress, Mutates mut, Expr expr, FSharpOption`1<ValRef> addrExprVal, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<FSharpFunc`2<Expr, Expr>, Expr, bool, bool> mkExprAddrOfExpr(TcGlobals g, bool mustTakeAddress, bool useReadonlyForGenericArrayAddress, Mutates mut, Expr e, FSharpOption`1<ValRef> addrExprVal, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTupleFieldGet(TcGlobals g, TupInfo tupInfo, Expr e, FSharpList`1<TType> tinst, int i, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAnonRecdFieldGet(TcGlobals g, AnonRecdTypeInfo anonInfo, Expr e, FSharpList`1<TType> tinst, int i, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRecdFieldGet(TcGlobals g, Expr e, RecdFieldRef fref, FSharpList`1<TType> tinst, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnionCaseFieldGetUnproven(TcGlobals g, Expr e, UnionCaseRef cref, FSharpList`1<TType> tinst, int j, Range m);
    internal static Expr mkArray(TType argTy, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IterateRecursiveFixups(TcGlobals g, FSharpOption`1<Val> selfv, FSharpFunc`2<FSharpOption`1<Val>, FSharpFunc`2<Expr, FSharpFunc`2<FSharpFunc`2<Expr, Expr>, FSharpFunc`2<Expr, Unit>>>> rvs, Expr access, FSharpFunc`2<Expr, Expr> set, Expr exprToFix);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TyparStaticReq JoinTyparStaticReq(TyparStaticReq r1, TyparStaticReq r2);
    internal static ExprFolder`1<State> ExprFolder0();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static State FoldExpr(ExprFolder`1<State> folders, State state, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static State FoldImplFile(ExprFolder`1<State> folders, State state, CheckedImplFile implFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkString(TcGlobals g, Range m, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkByte(TcGlobals g, Range m, byte b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUInt16(TcGlobals g, Range m, ushort b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnit(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInt32(TcGlobals g, Range m, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkInt(TcGlobals g, Range m, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkZero(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkOne(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkTwo(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkMinusOne(TcGlobals g, Range m);
    internal static FSharpOption`1<int> destInt32(Expr _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isIDelegateEventType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType destIDelegateEventType(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIEventType(TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIObservableType(TcGlobals g, TType ty1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIObserverType(TcGlobals g, TType ty1);
    internal static RecdFieldRef mkRefCellContentsRef(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSequential(Range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompGenSequential(Range m, Expr stmt, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkThenDoSequential(Range m, Expr expr, Expr stmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompGenThenDoSequential(Range m, Expr expr, Expr stmt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkSequentials(TcGlobals g, Range m, FSharpList`1<Expr> es);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGetArg0(Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAnyTupled(TcGlobals g, Range m, TupInfo tupInfo, FSharpList`1<Expr> es, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefTupled(TcGlobals g, Range m, FSharpList`1<Expr> es, FSharpList`1<TType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefTupledNoTypes(TcGlobals g, Range m, FSharpList`1<Expr> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefTupledVars(TcGlobals g, Range m, FSharpList`1<Val> vs);
    internal static Int32[] inversePerm(Int32[] sigma);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[] permute(Int32[] sigma, T[] data);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsR(int a, int b, FSharpFunc`2<int, bool> pred);
    internal static int liftAllBefore(Int32[] sigma);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Binding>, FSharpList`1<Expr>> permuteExprList(Int32[] sigma, FSharpList`1<Expr> exprs, FSharpList`1<TType> ty, FSharpList`1<string> names);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRecordExpr(TcGlobals g, RecordConstructionInfo lnk, EntityRef tcref, FSharpList`1<TType> tinst, FSharpList`1<RecdFieldRef> unsortedRecdFields, FSharpList`1<Expr> unsortedFieldExprs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkAnonRecd(TcGlobals _g, Range m, AnonRecdTypeInfo anonInfo, Ident[] unsortedIds, FSharpList`1<Expr> unsortedFieldExprs, FSharpList`1<TType> unsortedArgTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefCell(TcGlobals g, Range m, TType ty, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefCellGet(TcGlobals g, Range m, TType ty, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkRefCellSet(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNil(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCons(TcGlobals g, TType ty, Expr h, Expr t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<Val, Expr, Binding> mkCompGenLocalAndInvisibleBind(TcGlobals g, string nm, Range m, Expr e);
    internal static ILInstr get_box();
    internal static ILInstr get_isinst();
    internal static ILInstr get_unbox();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnbox(TType ty, Expr e, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkBox(TType ty, Expr e, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIsInst(TType ty, Expr e, Range m);
    internal static ILMethodSpec mspec_Type_GetTypeFromHandle(TcGlobals g);
    internal static ILMethodSpec mspec_String_Length(TcGlobals g);
    internal static ILMethodSpec mspec_String_Concat2(TcGlobals g);
    internal static ILMethodSpec mspec_String_Concat3(TcGlobals g);
    internal static ILMethodSpec mspec_String_Concat4(TcGlobals g);
    internal static ILMethodSpec mspec_String_Concat_Array(TcGlobals g);
    internal static ILFieldSpec fspec_Missing_Value(TcGlobals g);
    internal static ILMethodSpec mkInitializeArrayMethSpec(TcGlobals g);
    internal static ILInstr mkInvalidCastExnNewobj(TcGlobals g);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> typedExprForIntrinsic(a _g, Range m, IntrinsicValRef i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGetGenericComparer(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGetGenericEREqualityComparer(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGetGenericPEREqualityComparer(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnbox(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnboxFast(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallTypeTest(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallTypeOf(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallTypeDefOf(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDispose(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeq(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCreateInstance(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGetQuerySourceAsEnumerable(TcGlobals g, Range m, TType ty1, TType ty2, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallNewQuerySource(TcGlobals g, Range m, TType ty1, TType ty2, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCreateEvent(TcGlobals g, Range m, TType ty1, TType ty2, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGenericComparisonWithComparerOuter(TcGlobals g, Range m, TType ty, Expr comp, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGenericEqualityEROuter(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGenericEqualityWithComparerOuter(TcGlobals g, Range m, TType ty, Expr comp, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGenericHashWithComparerOuter(TcGlobals g, Range m, TType ty, Expr comp, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallEqualsOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallNotEqualsOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLessThanOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLessThanOrEqualsOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGreaterThanOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallGreaterThanOrEqualsOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallAdditionOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSubtractionOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallMultiplyOperator(TcGlobals g, Range m, TType ty1, TType ty2, TType retTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDivisionOperator(TcGlobals g, Range m, TType ty1, TType ty2, TType retTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallModulusOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDefaultOf(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallBitwiseAndOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallBitwiseOrOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallBitwiseXorOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallShiftLeftOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallShiftRightOperator(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnaryNegOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnaryNotOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallAdditionChecked(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSubtractionChecked(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallMultiplyChecked(TcGlobals g, Range m, TType ty1, TType ty2, TType retTy, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallUnaryNegChecked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToByteChecked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToSByteChecked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt16Checked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt16Checked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToIntChecked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt32Checked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt32Checked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt64Checked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt64Checked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToIntPtrChecked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUIntPtrChecked(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToByteOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToSByteOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt16Operator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt16Operator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt32Operator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt32Operator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToInt64Operator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUInt64Operator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToSingleOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToDoubleOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToIntPtrOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToUIntPtrOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToCharOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallToEnumOperator(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArrayLength(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArrayGet(TcGlobals g, Range m, TType ty, Expr e1, Expr idx1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray2DGet(TcGlobals g, Range m, TType ty, Expr e1, Expr idx1, Expr idx2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray3DGet(TcGlobals g, Range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr idx3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray4DGet(TcGlobals g, Range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr idx3, Expr idx4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArraySet(TcGlobals g, Range m, TType ty, Expr e1, Expr idx1, Expr v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray2DSet(TcGlobals g, Range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray3DSet(TcGlobals g, Range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr idx3, Expr v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallArray4DSet(TcGlobals g, Range m, TType ty, Expr e1, Expr idx1, Expr idx2, Expr idx3, Expr idx4, Expr v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallHash(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallBox(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallIsNull(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallRaise(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallNewDecimal(TcGlobals g, Range m, Expr e1, Expr e2, Expr e3, Expr e4, Expr e5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallNewFormat(TcGlobals g, Range m, TType aty, TType bty, TType cty, TType dty, TType ety, Expr formatStringExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> tryMkCallBuiltInWitness(TcGlobals g, TraitConstraintInfo traitInfo, FSharpList`1<Expr> argExprs, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> tryMkCallCoreFunctionAsBuiltInWitness(TcGlobals g, IntrinsicValRef info, FSharpList`1<TType> tyargs, FSharpList`1<Expr> argExprs, Range m);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Expr> TryEliminateDesugaredConstants$cont@7777(TcGlobals g, Range m, Const c, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> TryEliminateDesugaredConstants(TcGlobals g, Range m, Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkSeqTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkIEnumeratorTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqCollect(TcGlobals g, Range m, TType alphaTy, TType betaTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqUsing(TcGlobals g, Range m, TType resourceTy, TType elemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqDelay(TcGlobals g, Range m, TType elemTy, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqAppend(TcGlobals g, Range m, TType elemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqGenerated(TcGlobals g, Range m, TType elemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqFinally(TcGlobals g, Range m, TType elemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqTryWith(TcGlobals g, Range m, TType elemTy, Expr origSeq, Expr exnFilter, Expr exnHandler);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqOfFunctions(TcGlobals g, Range m, TType ty1, TType ty2, Expr arg1, Expr arg2, Expr arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqToArray(TcGlobals g, Range m, TType elemTy, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqToList(TcGlobals g, Range m, TType elemTy, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqMap(TcGlobals g, Range m, TType inpElemTy, TType genElemTy, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqSingleton(TcGlobals g, Range m, TType ty1, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallSeqEmpty(TcGlobals g, Range m, TType ty1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCall_sprintf(TcGlobals g, Range m, TType funcTy, Expr fmtExpr, FSharpList`1<Expr> fillExprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDeserializeQuotationFSharp20Plus(TcGlobals g, Range m, Expr e1, Expr e2, Expr e3, Expr e4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallDeserializeQuotationFSharp40Plus(TcGlobals g, Range m, Expr e1, Expr e2, Expr e3, Expr e4, Expr e5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCastQuotation(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLiftValue(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLiftValueWithName(TcGlobals g, Range m, TType ty, string nm, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallLiftValueWithDefn(TcGlobals g, Range m, TType qty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallCheckThis(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallFailInit(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallFailStaticInit(TcGlobals g, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCallQuoteToLinqLambdaExpression(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkOptionToNullable(TcGlobals g, Range m, TType ty, Expr e1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkOptionDefaultValue(TcGlobals g, Range m, TType ty, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLazyDelayed(TcGlobals g, Range m, TType ty, Expr f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLazyForce(TcGlobals g, Range m, TType ty, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGetString(TcGlobals g, Range m, Expr e1, Expr e2);
    internal static FSharpFunc`2<TcGlobals, FSharpFunc`2<Range, FSharpFunc`2<Expr, FSharpFunc`2<Expr, Expr>>>> get_mkGetStringChar();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGetStringLength(TcGlobals g, Range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticCall_String_Concat2(TcGlobals g, Range m, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticCall_String_Concat3(TcGlobals g, Range m, Expr arg1, Expr arg2, Expr arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticCall_String_Concat4(TcGlobals g, Range m, Expr arg1, Expr arg2, Expr arg3, Expr arg4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkStaticCall_String_Concat_Array(TcGlobals g, Range m, Expr arg);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkDecr(TcGlobals g, Range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIncr(TcGlobals g, Range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLdlen(TcGlobals g, Range m, Expr arre);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLdelem(TcGlobals _g, Range m, TType ty, Expr arre, Expr idxe);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkILAsmCeq(TcGlobals g, Range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkILAsmClt(TcGlobals g, Range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNull(Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkThrow(Range m, TType ty, Expr e);
    internal static FSharpOption`1<Tuple`3<Range, TType, Expr>> destThrow(Expr _arg1);
    internal static bool isThrow(Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkReraiseLibCall(TcGlobals g, TType ty, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkReraise(Range m, TType returnTy);
    internal static string get_tnameCompilationSourceNameAttr();
    internal static string get_tnameCompilationArgumentCountsAttr();
    internal static string get_tnameCompilationMappingAttr();
    internal static string get_tnameSourceConstructFlags();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttrPrim(TcGlobals g, int k, FSharpList`1<int> nums);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttr(TcGlobals g, int kind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttrWithSeqNum(TcGlobals g, int kind, int seqNum);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttrWithVariantNumAndSeqNum(TcGlobals g, int kind, int varNum, int seqNum);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationArgumentCountsAttr(TcGlobals g, FSharpList`1<int> nums);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationSourceNameAttr(TcGlobals g, string n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilationMappingAttrForQuotationResource(TcGlobals g, string nm, FSharpList`1<ILTypeRef> tys);
    internal static bool isTypeProviderAssemblyAttr(ILAttribute cattr);
    internal static FSharpOption`1<string> TryDecodeTypeProviderAssemblyAttr(ILAttribute cattr);
    internal static string get_tname_SignatureDataVersionAttr();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkSignatureDataVersionAttr(TcGlobals g, ILVersionInfo version);
    internal static string get_tname_AutoOpenAttr();
    internal static bool IsSignatureDataVersionAttr(ILAttribute cattr);
    internal static FSharpOption`1<string> TryFindAutoOpenAttr(ILAttribute cattr);
    internal static FSharpOption`1<string> TryFindInternalsVisibleToAttr(ILAttribute cattr);
    [CompilerGeneratedAttribute]
internal static bool IsMatchingSignatureDataVersionAttr$cont@8072(ILVersionInfo version, ILAttribute cattr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsMatchingSignatureDataVersionAttr(ILVersionInfo version, ILAttribute cattr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILAttribute mkCompilerGeneratedAttr(TcGlobals g, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, FSharpFunc`2<Expr, Expr>> untupledToRefTupled(TcGlobals g, FSharpList`1<Val> vs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, Expr> AdjustArityOfLambdaBody(TcGlobals g, int arity, FSharpList`1<Val> vs, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Val, Expr> MultiLambdaToTupledLambda(TcGlobals g, FSharpList`1<Val> vs, Expr body);
    internal static FSharpOption`1<FSharpList`1<Expr>> |RefTuple|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Val, Expr>>, Expr> MultiLambdaToTupledLambdaIfNeeded(TcGlobals g, FSharpList`1<Val> vs, Expr arg, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeApplicationAndBetaReduceAux(TcGlobals g, Expr f, TType fty, FSharpList`1<FSharpList`1<TType>> tyargsl, FSharpList`1<Expr> argsl, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeApplicationAndBetaReduce(TcGlobals g, Expr f, TType fty, FSharpList`1<FSharpList`1<TType>> tyargsl, FSharpList`1<Expr> argl, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<long, FSharpList`1<Val>, Expr, Range, FSharpFunc`2<Expr, Expr>>> |NewDelegateExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<Expr, TType, Expr, Expr, Range>> |DelegateInvokeExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`4<TType, Expr, Expr, Range>> |OpPipeRight|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<TType, Expr, Expr, Expr, Range>> |OpPipeRight2|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`6<TType, Expr, Expr, Expr, Expr, Range>> |OpPipeRight3|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr MakeFSharpDelegateInvokeAndTryBetaReduce(TcGlobals g, Expr delInvokeRef, Expr delExpr, TType delInvokeTy, Expr delInvokeArg, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<Val>> MakeArgsForTopArgs(a _g, Range m, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> argTysl, FSharpList`1<Tuple`2<Typar, TType>> tpenv);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Expr, TType> AdjustValForExpectedValReprInfo(TcGlobals g, Range m, ValRef vref, ValUseFlag flags, ValReprInfo valReprInfo);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<TType>>, TType> stripTupledFunTy(TcGlobals g, TType ty);
    internal static FSharpOption`1<Tuple`4<ValRef, ValUseFlag, FSharpList`1<TType>, Range>> |ExprValWithPossibleTypeInst|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCoerceIfNeeded(TcGlobals g, TType tgtTy, TType srcTy, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkCompGenLetIn(Range m, string nm, TType ty, Expr e, FSharpFunc`2<Tuple`2<Val, Expr>, Expr> f);
    internal static Expr CoerceDetupled@8397(TcGlobals g, FSharpList`1<TType> argTys, FSharpList`1<Expr> detupledArgs, FSharpList`1<TType> actualTys);
    internal static Expr CoerceBoundTuple@8407(TcGlobals g, Range appm, Expr tupleVar, FSharpList`1<TType> argTys, FSharpList`1<TType> actualTys);
    internal static Tuple`2<FSharpFunc`2<Expr, Expr>, Expr> CoerceTupled@8418(TcGlobals g, Range appm, bool buildingLambdas, FSharpList`1<string> niceNames, Expr argExpr, FSharpList`1<TType> actualTys);
    internal static FSharpFunc`2<a, a> lambdaBuilder@8547();
    internal static FSharpFunc`2<a, a> binderBuilder@8553();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, FSharpList`1<Expr>>> AdjustPossibleSubsumptionExpr(TcGlobals g, Expr expr, FSharpList`1<Expr> suppliedArgs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr NormalizeAndAdjustPossibleSubsumptionExprs(TcGlobals g, Expr inputExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr etaExpandTypeLambda(TcGlobals g, Range m, FSharpList`1<Typar> tps, Expr tm, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void AdjustValToHaveValReprInfo(Val tmp, ParentRef parent, ValReprInfo valData);
    internal static Expr itemsProj@8638(Range m, FSharpList`1<TType> tys, int i, Expr x);
    internal static bool isThrowingTarget@8643(DecisionTreeTarget _arg1);
    internal static DecisionTreeTarget fixup@8655(TType tmpTy, DecisionTreeTarget newTg, DecisionTreeTarget _arg2);
    [CompilerGeneratedAttribute]
internal static Expr LinearizeTopMatchAux$cont@8646(TcGlobals g, ParentRef parent, DecisionTree tree, DecisionTreeTarget[] targets, DebugPointAtBinding spBind, Range m2, Range m, FSharpList`1<DecisionTreeTarget> targetsL, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr LinearizeTopMatchAux(TcGlobals g, ParentRef parent, DebugPointAtBinding spBind, Range m, DecisionTree tree, DecisionTreeTarget[] targets, Range m2, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr LinearizeTopMatch(TcGlobals g, ParentRef parent, Expr _arg1);
    internal static string ticksAndArgCountTextOfTyconRef(EntityRef tcref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string typarEnc(a _g, FSharpList`1<Typar> gtpsType, FSharpList`1<Typar> gtpsMethod, Typar typar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string typeEnc(TcGlobals g, FSharpList`1<Typar> gtpsType, FSharpList`1<Typar> gtpsMethod, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string tyargsEnc(TcGlobals g, FSharpList`1<Typar> gtpsType, FSharpList`1<Typar> gtpsMethod, FSharpList`1<TType> args);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string XmlDocArgsEnc(TcGlobals g, FSharpList`1<Typar> gtpsType, FSharpList`1<Typar> gtpsMethod, FSharpList`1<TType> argTys);
    internal static string buildAccessPath(FSharpOption`1<CompilationPath> cp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string prependPath(string path, string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string XmlDocSigOfVal(TcGlobals g, bool full, string path, Val v);
    internal static string XmlDocSigOfUnionCase(FSharpList`1<string> path);
    internal static string XmlDocSigOfField(FSharpList`1<string> path);
    internal static string XmlDocSigOfProperty(FSharpList`1<string> path);
    internal static string XmlDocSigOfTycon(FSharpList`1<string> path);
    internal static string XmlDocSigOfSubModul(FSharpList`1<string> path);
    internal static string XmlDocSigOfEntity(EntityRef eref);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_Static();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_Instance();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_ModuleSuffix();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_enum_CompilationRepresentationAttribute_PermitNull();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasUseNullAsTrueValueAttribute(TcGlobals g, FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TyconHasUseNullAsTrueValueAttribute(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CanHaveUseNullAsTrueValueAttribute(TcGlobals _g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsUnionTypeWithNullAsTrueValue(TcGlobals g, Entity tycon);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isNonNullableStructTyparTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isReferenceTyparTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeNullNever(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeNullIsExtraValue(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeNullIsTrueValue(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeNullNotLiked(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeSatisfiesNullConstraint(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeHasDefaultValue(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<TType>> |SpecialComparableHeadType|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<FSharpList`1<TType>> |SpecialEquatableHeadType|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |SpecialNotEquatableHeadType|_|(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canUseTypeTestFast(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool canUseUnboxFast(TcGlobals g, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIsInstConditional(TcGlobals g, Range m, TType tgtTy, Expr vinputExpr, Val v, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNullTest(TcGlobals g, Range m, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNonNullTest(TcGlobals g, Range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkNonNullCond(TcGlobals g, Range m, TType ty, Expr e1, Expr e2, Expr e3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkIfThen(TcGlobals g, Range m, Expr e1, Expr e2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ModuleNameIsMangled(TcGlobals g, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool CompileAsEvent(TcGlobals g, FSharpList`1<Attrib> attrs);
    [CompilerGeneratedAttribute]
internal static bool MemberIsCompiledAsInstance$cont@9076(TcGlobals g, EntityRef parent, ValMemberInfo membInfo, FSharpList`1<Attrib> attrs, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool MemberIsCompiledAsInstance(TcGlobals g, EntityRef parent, bool isExtensionMember, ValMemberInfo membInfo, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSealedTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isComInteropTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValSpecIsCompiledAsInstance(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ValRefIsCompiledAsInstanceMember(TcGlobals g, ValRef vref);
    [CompilerGeneratedAttribute]
internal static Tuple`8<int, bool, bool, bool, bool, bool, bool, Tuple`1<bool>> GetMemberCallInfo$cont@9136(TcGlobals g, ValRef vref, ValUseFlag vFlags, ValMemberInfo membInfo, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`8<int, bool, bool, bool, bool, bool, bool, Tuple`1<bool>> GetMemberCallInfo(TcGlobals g, ValRef vref, ValUseFlag vFlags);
    internal static FSharpOption`1<ActivePatternInfo> TryGetActivePatternInfo(ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ActivePatternElemRef.get_LogicalName(ActivePatternElemRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ActivePatternElemRef.get_DisplayNameCore(ActivePatternElemRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ActivePatternElemRef.get_DisplayName(ActivePatternElemRef );
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EntityRef mkChoiceTyconRef(TcGlobals g, Range m, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkChoiceTy(TcGlobals g, Range m, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static UnionCaseRef mkChoiceCaseRef(TcGlobals g, Range m, int n, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ActivePatternInfo.DisplayNameCoreByIdx(ActivePatternInfo x, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string ActivePatternInfo.DisplayNameByIdx(ActivePatternInfo x, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ActivePatternInfo.ResultType(ActivePatternInfo apinfo, TcGlobals g, Range m, FSharpList`1<TType> retTys, bool isStruct);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ActivePatternInfo.OverallType(ActivePatternInfo apinfo, TcGlobals g, Range m, TType argTy, FSharpList`1<TType> retTys, bool isStruct);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool doesActivePatternHaveFreeTypars(TcGlobals g, ValRef v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding rewriteBind(ExprRewritingEnv env, Binding bind);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Binding rewriteBindStructure(ExprRewritingEnv env, Binding _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr RewriteExpr(ExprRewritingEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> preRewriteExpr(ExprRewritingEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr postRewriteExpr(ExprRewritingEnv env, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr rewriteExprStructure(ExprRewritingEnv env, Expr expr);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-4(Range m, Binding bind, Expr bodyExprR);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-5(Expr expr, Range m, Expr expr2, Expr expr1, SequentialOpKind dir, Expr expr1R, Expr expr2R);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-6(Expr expr, FSharpList`1<TType> tyargs, TOp op, Range m, FSharpList`1<Expr> argsFront, Expr argLast, FSharpList`1<Expr> argsFrontR, Expr argLastR);
    [CompilerGeneratedAttribute]
internal static Expr func1@1-7(TType ty, DebugPointAtBinding spBind, Range mExpr, Range m2, DecisionTree dtree, DecisionTreeTarget tg1R, Expr expr2R);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr rewriteLinearExpr(ExprRewritingEnv env, Expr expr, FSharpFunc`2<Expr, Expr> contf);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Expr> rewriteExprs(ExprRewritingEnv env, FSharpList`1<Expr> exprs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTree RewriteDecisionTree(ExprRewritingEnv env, DecisionTree x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static DecisionTreeTarget rewriteTarget(ExprRewritingEnv env, DecisionTreeTarget _arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<DecisionTreeTarget> rewriteTargets(ExprRewritingEnv env, DecisionTreeTarget[] targets);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ObjExprMethod rewriteObjExprOverride(ExprRewritingEnv env, ObjExprMethod _arg3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, FSharpList`1<ObjExprMethod>> rewriteObjExprInterfaceImpl(ExprRewritingEnv env, TType ty, FSharpList`1<ObjExprMethod> overrides);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceContents rewriteModuleOrNamespaceContents(ExprRewritingEnv env, ModuleOrNamespaceContents x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ModuleOrNamespaceBinding rewriteModuleOrNamespaceBinding(ExprRewritingEnv env, ModuleOrNamespaceBinding x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<ModuleOrNamespaceBinding> rewriteModuleOrNamespaceBindings(ExprRewritingEnv env, FSharpList`1<ModuleOrNamespaceBinding> mbinds);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static CheckedImplFile RewriteImplFile(ExprRewritingEnv env, CheckedImplFile implFile);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Remap MakeExportRemapping(CcuThunk viewedCcu, Entity mspec);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity remapEntityDataToNonLocal(RemapContext ctxt, Remap tmenv, Entity d);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity remapTyconToNonLocal(RemapContext ctxt, Remap tmenv, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Val remapValToNonLocal(RemapContext ctxt, Remap tmenv, Val inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity ApplyExportRemappingToEntity(TcGlobals g, Remap tmenv, Entity x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isCompiledOrWitnessPassingConstraint(TcGlobals g, TyparConstraint cx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsGenericValWithGenericConstraints(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Entity.HasInterface(Entity tycon, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Entity.HasOverride(Entity tycon, TcGlobals g, string nm, FSharpList`1<TType> argTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<ValRef> Entity.TryGetMember(Entity tycon, TcGlobals g, string nm, FSharpList`1<TType> argTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool Entity.HasMember(Entity tycon, TcGlobals g, string nm, FSharpList`1<TType> argTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EntityRef.HasInterface(EntityRef tcref, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EntityRef.HasOverride(EntityRef tcref, TcGlobals g, string nm, FSharpList`1<TType> argTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EntityRef.HasMember(EntityRef tcref, TcGlobals g, string nm, FSharpList`1<TType> argTys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkFastForLoop(TcGlobals g, DebugPointAtFor spFor, DebugPointAtInOrTo spTo, Range m, Val idv, Expr start, bool dir, Expr finish, Expr body);
    internal static bool checkExpr@9596(TcGlobals g, FSharpSet`1<long> vrefs, Expr x);
    internal static bool checkDecisionTree@9644(TcGlobals g, FSharpSet`1<long> vrefs, DecisionTree x);
    internal static FSharpFunc`2<DecisionTreeCase, bool> checkDecisionTreeCase@9655(TcGlobals g, FSharpSet`1<long> vrefs);
    internal static FSharpFunc`2<DecisionTreeTarget, bool> checkDecisionTreeTarget@9661(TcGlobals g, FSharpSet`1<long> vrefs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool IsSimpleSyntacticConstantExpr(TcGlobals g, Expr inputExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr EvalArithShiftOp(FSharpFunc`2<sbyte, FSharpFunc`2<int, sbyte>> opInt8, FSharpFunc`2<short, FSharpFunc`2<int, short>> opInt16, FSharpFunc`2<int, FSharpFunc`2<int, int>> opInt32, FSharpFunc`2<long, FSharpFunc`2<int, long>> opInt64, FSharpFunc`2<byte, FSharpFunc`2<int, byte>> opUInt8, FSharpFunc`2<ushort, FSharpFunc`2<int, ushort>> opUInt16, FSharpFunc`2<UInt32, FSharpFunc`2<int, UInt32>> opUInt32, FSharpFunc`2<ulong, FSharpFunc`2<int, ulong>> opUInt64, Expr arg1, Expr arg2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr EvalArithUnOp(FSharpFunc`2<sbyte, sbyte> opInt8, FSharpFunc`2<short, short> opInt16, FSharpFunc`2<int, int> opInt32, FSharpFunc`2<long, long> opInt64, FSharpFunc`2<byte, byte> opUInt8, FSharpFunc`2<ushort, ushort> opUInt16, FSharpFunc`2<UInt32, UInt32> opUInt32, FSharpFunc`2<ulong, ulong> opUInt64, FSharpFunc`2<float, float> opSingle, FSharpFunc`2<double, double> opDouble, Expr arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr EvalArithBinOp(FSharpFunc`2<sbyte, FSharpFunc`2<sbyte, sbyte>> opInt8, FSharpFunc`2<short, FSharpFunc`2<short, short>> opInt16, FSharpFunc`2<int, FSharpFunc`2<int, int>> opInt32, FSharpFunc`2<long, FSharpFunc`2<long, long>> opInt64, FSharpFunc`2<byte, FSharpFunc`2<byte, byte>> opUInt8, FSharpFunc`2<ushort, FSharpFunc`2<ushort, ushort>> opUInt16, FSharpFunc`2<UInt32, FSharpFunc`2<UInt32, UInt32>> opUInt32, FSharpFunc`2<ulong, FSharpFunc`2<ulong, ulong>> opUInt64, FSharpFunc`2<float, FSharpFunc`2<float, float>> opSingle, FSharpFunc`2<double, FSharpFunc`2<double, double>> opDouble, Expr arg1, Expr arg2);
    internal static FSharpFunc`2<a, a> ignore@9721();
    internal static FSharpFunc`2<a, FSharpFunc`2<a, a>> ignore2@9722();
    [CompilerGeneratedAttribute]
internal static Expr EvalAttribArgExpr$cont@9779(SuppressLanguageFeatureCheck suppressLangFeatureCheck, TcGlobals g, Expr x, Expr v1, Expr v2, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Expr EvalAttribArgExpr$cont@9789-1(Expr v1, Expr v2, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr EvalAttribArgExpr(SuppressLanguageFeatureCheck suppressLangFeatureCheck, TcGlobals g, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool EvaledAttribExprEquality(TcGlobals g, Expr e1, Expr e2);
    internal static FSharpOption`1<ILFieldInit> |ConstToILFieldInit|_|(Const c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr EvalLiteralExprOrAttribArg(TcGlobals g, Expr x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<FSharpList`1<Typar>, FSharpList`1<TraitWitnessInfo>, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>>, FSharpOption`1<TType>, ArgReprInfo> GetTypeOfIntrinsicMemberInCompiledForm(TcGlobals g, ValRef vref);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<EntityRef, FSharpList`1<TType>, FSharpList`1<Expr>, Range> mkCompiledTuple(TcGlobals g, bool isStruct, FSharpList`1<TType> argTys, FSharpList`1<Expr> args, Range m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILMethodSpec mkILMethodSpecForTupleItem(TcGlobals _g, ILType ty, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ILFieldSpec mkILFieldSpecForTupleItem(ILType ty, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkGetTupleItemN(TcGlobals g, Range m, int n, ILType ty, bool isStruct, Expr expr, TType retTy);
    internal static FSharpOption`1<int> |Int32Expr|_|(Expr expr);
    internal static FSharpOption`1<Tuple`2<Expr, Expr>> |TryFinally|_|(Expr expr);
    internal static FSharpOption`1<Tuple`4<DebugPointAtWhile, Expr, Expr, Range>> |WhileLoopForCompiledForEachExpr|_|(Expr expr);
    internal static FSharpOption`1<Tuple`4<Val, Expr, DebugPointAtBinding, Expr>> |Let|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<Expr, int, Expr>> |RangeInt32Step|_|(TcGlobals g, Expr expr);
    internal static FSharpOption`1<ValRef> |GetEnumeratorCall|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<TType, Expr, Val, Expr, Tuple`7<Range, DebugPointAtBinding, DebugPointAtInOrTo, Range, Range, DebugPointAtWhile, Range>>> |CompiledForEachExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`6<Expr, int, Expr, Val, Expr, Tuple`7<Range, DebugPointAtBinding, DebugPointAtInOrTo, Range, Range, DebugPointAtWhile, Range>>> |CompiledInt32RangeForEachExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkDebugPoint(Range m, Expr expr);
    [CompilerGeneratedAttribute]
internal static Expr DetectAndOptimizeForEachExpression$cont@10126-1(TcGlobals g, TType enumerableTy, Expr enumerableExpr, Val elemVar, Expr bodyExpr, DebugPointAtWhile spInWhile, DebugPointAtBinding spFor, Range mIn, Range mFor, Range mBody, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static Expr DetectAndOptimizeForEachExpression$cont@10090(TcGlobals g, Expr expr, Tuple`7<Range, DebugPointAtBinding, DebugPointAtInOrTo, Range, Range, DebugPointAtWhile, Range> ranges, TType enumerableTy, Expr enumerableExpr, Val elemVar, Expr bodyExpr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr DetectAndOptimizeForEachExpression(TcGlobals g, OptimizeForExpressionOptions option, Expr expr);
    internal static Expr |InnerExprPat|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Val>, Expr> BindUnitVars(TcGlobals g, FSharpList`1<Val> mvs, FSharpList`1<ArgReprInfo> paramInfos, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isThreadOrContextStatic(TcGlobals g, FSharpList`1<Attrib> attrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkUnitDelayLambda(TcGlobals g, Range m, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<FSharpList`1<TType>, FSharpList`1<Expr>, Range>> |ValApp|_|(TcGlobals g, ValRef vref, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |UseResumableStateMachinesExpr|_|(TcGlobals g, Expr expr);
    internal static FSharpOption`1<Tuple`3<Expr, Expr, Expr>> |IfThenElseExpr|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Expr>> |IfUseResumableStateMachinesExpr|_|(TcGlobals g, Expr expr);
    internal static ModuleOrNamespaceType CombineModuleOrNamespaceTypes@10210(FSharpList`1<string> path, ModuleOrNamespaceType mty1, ModuleOrNamespaceType mty2);
    internal static Entity CombineEntities@10231(FSharpList`1<string> path, Entity entity1, Entity entity2);
    internal static ModuleOrNamespaceType CombineModuleOrNamespaceTypeList@10258(FSharpList`1<string> path, FSharpList`1<ModuleOrNamespaceType> l);
    internal static ModuleOrNamespaceType CombineCcuContentFragments(FSharpList`1<ModuleOrNamespaceType> l);
    internal static ImmutableDictionary`2<TraitWitnessInfo, T> EmptyTraitWitnessInfoHashMap(TcGlobals g);
    internal static FSharpOption`1<Tuple`5<DebugPointAtWhile, SpecialWhileLoopMarker, Expr, Expr, Range>> |WhileExpr|_|(Expr expr);
    internal static FSharpOption`1<Tuple`6<DebugPointAtTry, DebugPointAtFinally, TType, Expr, Expr, Range>> |TryFinallyExpr|_|(Expr expr);
    internal static FSharpOption`1<Tuple`8<DebugPointAtFor, DebugPointAtInOrTo, ForLoopStyle, Expr, Expr, Val, Expr, Tuple`1<Range>>> |IntegerForLoopExpr|_|(Expr expr);
    internal static FSharpOption`1<Tuple`8<DebugPointAtTry, DebugPointAtWith, TType, Expr, Val, Expr, Val, Tuple`2<Expr, Range>>> |TryWithExpr|_|(Expr expr);
    internal static FSharpOption`1<Tuple`6<Expr, UnionCaseRef, int, int, DecisionTreeTarget[], FSharpFunc`2<Tuple`5<Expr, UnionCaseRef, int, int, DecisionTreeTarget[]>, Expr>>> |MatchTwoCasesExpr|_|(Expr expr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`5<Expr, Expr, Val, Expr, FSharpFunc`2<Tuple`4<Expr, Expr, Val, Expr>, Expr>>> |MatchOptionExpr|_|$cont@10318(UnionCaseRef ucref, DecisionTreeTarget[] tgs, int tg2, int tg1, FSharpFunc`2<Tuple`5<Expr, UnionCaseRef, int, int, DecisionTreeTarget[]>, Expr> rebuildTwoCases, Expr cond, Unit unitVar);
    internal static FSharpOption`1<Tuple`5<Expr, Expr, Val, Expr, FSharpFunc`2<Tuple`4<Expr, Expr, Val, Expr>, Expr>>> |MatchOptionExpr|_|(Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |ResumableEntryAppExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`4<Expr, Val, Expr, FSharpFunc`2<Tuple`2<Expr, Expr>, Expr>>> |ResumableEntryMatchExpr|_|(TcGlobals g, Expr expr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`4<TType, Tuple`2<Val, Expr>, Tuple`3<Val, Val, Expr>, Tuple`2<Val, Expr>>> |StructStateMachineExpr|_|$cont@10364(TcGlobals g, Expr setStateMachine, Expr moveNext, TType dataTy, Expr afterCode, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`4<TType, Tuple`2<Val, Expr>, Tuple`3<Val, Val, Expr>, Tuple`2<Val, Expr>>> |StructStateMachineExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Expr> |ResumeAtExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<string> |DebugPointExpr|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`4<Expr, Expr, Range, FSharpFunc`2<Expr, FSharpFunc`2<Expr, Expr>>>> |SequentialResumableCode|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr mkLabelled(Range m, int l, Expr e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isResumableCodeTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isReturnsResumableCodeTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<Expr, Expr, FSharpList`1<Expr>, Range, FSharpFunc`2<Tuple`2<Expr, FSharpList`1<Expr>>, Expr>>> |ResumableCodeInvoke|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ComputeUseMethodImpl(TcGlobals g, Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, TType>> |Seq|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, Range>> |SeqYield|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`3<Expr, Expr, Range>> |SeqAppend|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`4<Expr, Expr, DebugPointAtWhile, Range>> |SeqWhile|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`5<Expr, Expr, DebugPointAtTry, DebugPointAtFinally, Range>> |SeqTryFinally|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`6<Expr, Val, Expr, TType, DebugPointAtBinding, Range>> |SeqUsing|_|(TcGlobals g, Expr expr);
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<Tuple`7<Expr, Val, Expr, TType, Range, Range, DebugPointAtInOrTo>> |SeqForEach|_|$cont@10505(TcGlobals g, Expr expr, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`7<Expr, Val, Expr, TType, Range, Range, DebugPointAtInOrTo>> |SeqForEach|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Expr, TType>> |SeqDelay|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Range> |SeqEmpty|_|(TcGlobals g, Expr expr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isFSharpExceptionTy(TcGlobals g, TType ty);
    internal static FSharpOption`1<FSharpList`1<Entity>> |EmptyModuleOrNamespaces|_|(ModuleOrNamespaceContents moduleOrNamespaceContents);
    internal static FSharpOption`1<Attrib> tryFindExtensionAttribute@10575(FSharpList`1<Attrib> attribs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Entity tryAddExtensionAttributeIfNotAlreadyPresent(FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpOption`1<Attrib>>, FSharpOption`1<Attrib>> tryFindExtensionAttributeIn, Entity entity);
    internal static TypedTreeNode visitEntity(Entity entity);
    internal static TypedTreeNode visitVal(Val v);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void serializeNode(IndentedTextWriter writer, bool addTrailingComma, TypedTreeNode node);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void serializeEntity(string path, Entity entity);
    internal static FSharpOption`1<Entity> findModuleOrNamespace@10692(string name, Entity entity);
    internal static void updateSeqTypeIsPrefix(Entity fsharpCoreMSpec);
    internal static FSharpList`1<string> getTyparName@10718(TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isTyparOrderMismatch(FSharpList`1<Typar> tps, FSharpList`1<FSharpList`1<Tuple`2<TType, ArgReprInfo>>> argInfos);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypedTreePickle : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int PickleBufferCapacity;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_nop;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldarg;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldnull;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ilzero;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_call;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_add;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_sub;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_mul;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_div;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_div_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_rem;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_rem_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_and;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_or;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_xor;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_shl;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_shr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_shr_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_neg;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_not;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_conv;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_conv_ovf;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_conv_ovf_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_callvirt;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldobj;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldstr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_castclass;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_isinst;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_unbox;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_throw;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldfld;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldflda;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_stfld;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldsfld;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldsflda;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_stsfld;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_stobj;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_box;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_newarr;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldlen;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldelema;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ckfinite;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldtoken;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_add_ovf;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_add_ovf_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_mul_ovf;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_mul_ovf_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_sub_ovf;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_sub_ovf_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ceq;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_cgt;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_cgt_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_clt;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_clt_un;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldvirtftn;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_localloc;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_rethrow;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_sizeof;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldelem_any;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_stelem_any;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_unbox_any;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_ldlen_multi;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_initobj;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_initblk;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_cpobj;
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int itag_cpblk;
    internal static bool verbose { get; }
    internal static Unit space { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, string> u_encoded_string { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<string>> u_strings { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, FSharpFunc`2<WriterState, Unit>> p_encoded_string { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<string>, FSharpFunc`2<WriterState, Unit>> p_strings { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Int32[]> u_encoded_pubpath { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Int32[], FSharpFunc`2<WriterState, Unit>> p_encoded_pubpath { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Tuple`2<int, Int32[]>> u_encoded_nleref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Int32[]> p2@341 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Tuple`2<int, Int32[]>, FSharpFunc`2<WriterState, Unit>> p_encoded_nleref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Int32[], FSharpFunc`2<WriterState, Unit>> p2@247-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ILArrayShape, FSharpFunc`2<WriterState, Unit>> p_ILArrayShape { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpOption`1<int>, FSharpFunc`2<WriterState, Unit>> p1@247 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpOption`1<int>, FSharpFunc`2<WriterState, Unit>> p2@247-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, ILArrayShape> u_ILArrayShape { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpOption`1<int>> p1@341-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpOption`1<int>> p2@341-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, ILCallingSignature> u_ILCallSig { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, ILInstr>> simple_instrs { get; }
    [CompilationMappingAttribute("9")]
internal static Dictionary`2<ILInstr, int> encode_table { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, ILInstr>> current@1-2 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, ILInstr>> next@1-2 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> decoders { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2[] decode_tab { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2[] tab@1189-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2[] arr@1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> current@1-3 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> next@1-3 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, ILInstr>> current@1-4 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpList`1<Tuple`2<int, ILInstr>> next@1-4 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<UnionCaseRef, FSharpFunc`2<WriterState, Unit>> p_ucref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, EntityRef> u_tcref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, UnionCaseRef> u_ucref { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>, Unit>, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>> patternInput@1306-1 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>> p_ty2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>, Unit> fill_p_ty2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>> p_ty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<WriterState, Unit>> p_tys { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>> patternInput@1311-2 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>> p_attribs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_attribs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, TType>, Unit>, FSharpFunc`2<ReaderState, TType>> patternInput@1342-3 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, TType> u_ty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, TType>, Unit> fill_u_ty { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<TType>> u_tys { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>> patternInput@1344-4 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Attrib>> u_attribs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>, Unit> fill_u_attribs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, ValRef> u_vref { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<ValRef>> u_vrefs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, Expr>, Unit>, FSharpFunc`2<ReaderState, Expr>> patternInput@1411-5 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Expr> u_expr_fwd { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, Expr>, Unit> fill_u_Expr_hole { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>> patternInput@1412-6 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>> p_expr_fwd { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_Expr_hole { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<WriterState, Unit> p_measure_one { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<TyparConstraint>, FSharpFunc`2<WriterState, Unit>> p_tyar_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<TyparConstraint>> u_tyar_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Typar>, FSharpFunc`2<WriterState, Unit>> p_tyar_specs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Typar>> u_tyar_specs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>> patternInput@1728-7 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>> p_binds { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_binds { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>> patternInput@1729-8 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>> p_targets { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_targets { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>> patternInput@1730-9 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>> p_Exprs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_Exprs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>> patternInput@1731-10 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>> p_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>> patternInput@1732-11 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>> p_Vals { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>, Unit> fill_p_Vals { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Binding>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Binding>>> patternInput@1734-12 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Binding>> u_binds { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Binding>>, Unit> fill_u_binds { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, DecisionTreeTarget[]>, Unit>, FSharpFunc`2<ReaderState, DecisionTreeTarget[]>> patternInput@1735-13 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, DecisionTreeTarget[]> u_targets { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, DecisionTreeTarget[]>, Unit> fill_u_targets { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Expr>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Expr>>> patternInput@1736-14 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Expr>> u_Exprs { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Expr>>, Unit> fill_u_Exprs { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>> patternInput@1737-15 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>> u_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>, Unit> fill_u_constraints { get; }
    [CompilationMappingAttribute("9")]
internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Val>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Val>>> patternInput@1738-16 { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, FSharpList`1<Val>> u_Vals { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Val>>, Unit> fill_u_Vals { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Const, FSharpFunc`2<WriterState, Unit>> p_const { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Const> u_const { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>> p_expr { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<ReaderState, Expr> u_expr { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<PickledCcuInfo, FSharpFunc`2<WriterState, Unit>> pickleCcuInfo { get; }
    private static TypedTreePickle();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_verbose();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_byte(int b, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_bool(bool b, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void prim_p_int32(int i, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_int32(int n, WriterState st);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static Unit get_space();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_space(int n, Unit unitVar1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_bytes(Byte[] s, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_memory(ReadOnlyMemory`1<byte> s, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_prim_string(string s, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_int(int c, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_int64(long i, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`2<T1, T2>, FSharpFunc`2<WriterState, Unit>> p_tup2(FSharpFunc`2<T1, FSharpFunc`2<WriterState, Unit>> p1, FSharpFunc`2<T2, FSharpFunc`2<WriterState, Unit>> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`3<T1, T2, T3>, FSharpFunc`2<WriterState, Unit>> p_tup3(FSharpFunc`2<T1, FSharpFunc`2<WriterState, Unit>> p1, FSharpFunc`2<T2, FSharpFunc`2<WriterState, Unit>> p2, FSharpFunc`2<T3, FSharpFunc`2<WriterState, Unit>> p3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<Tuple`4<T1, T2, T3, T4>, FSharpFunc`2<WriterState, Unit>> p_tup4(FSharpFunc`2<T1, FSharpFunc`2<WriterState, Unit>> p1, FSharpFunc`2<T2, FSharpFunc`2<WriterState, Unit>> p2, FSharpFunc`2<T3, FSharpFunc`2<WriterState, Unit>> p3, FSharpFunc`2<T4, FSharpFunc`2<WriterState, Unit>> p4);
    internal static int u_byte(ReaderState st);
    internal static bool u_bool(ReaderState st);
    internal static int prim_u_int32(ReaderState st);
    internal static int u_int32(ReaderState st);
    internal static Byte[] u_bytes(ReaderState st);
    internal static int u_int(ReaderState st);
    internal static long u_int64(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void u_space(int n, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> u_used_space1(FSharpFunc`2<ReaderState, a> f, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<ReaderState, Tuple`2<T2, T3>> u_tup2(FSharpFunc`2<ReaderState, T2> p1, FSharpFunc`2<ReaderState, T3> p2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<ReaderState, Tuple`3<T2, T3, T4>> u_tup3(FSharpFunc`2<ReaderState, T2> p1, FSharpFunc`2<ReaderState, T3> p2, FSharpFunc`2<ReaderState, T4> p3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<ReaderState, Tuple`4<T2, T3, T4, T5>> u_tup4(FSharpFunc`2<ReaderState, T2> p1, FSharpFunc`2<ReaderState, T3> p2, FSharpFunc`2<ReaderState, T4> p3, FSharpFunc`2<ReaderState, T5> p4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_osgn_decl(NodeOutTable`2<a, b> outMap, FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> p, b x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b u_osgn_ref(NodeInTable`2<a, b> inMap, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b u_osgn_decl(NodeInTable`2<a, b> inMap, FSharpFunc`2<ReaderState, a> u, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a lookup_uniq(ReaderState st, InputTable`1<a> tbl, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_array_core(FSharpFunc`2<T, FSharpFunc`2<a, Unit>> f, T[] x, a st);
    internal static FSharpFunc`2<T[], FSharpFunc`2<WriterState, Unit>> p_array(FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_list_core(FSharpFunc`2<T, FSharpFunc`2<a, Unit>> f, FSharpList`1<T> xs, a st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_list_ext(FSharpOption`1<FSharpFunc`2<WriterState, Unit>> extraf, FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> f, FSharpList`1<a> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_option(FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> f, FSharpOption`1<a> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_lazy_impl(FSharpFunc`2<a, FSharpFunc`2<WriterState, Unit>> p, a v, WriterState st);
    internal static FSharpFunc`2<Lazy`1<T>, FSharpFunc`2<WriterState, Unit>> p_lazy(FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> p);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<a, FSharpFunc`2<WriterState, b>>, Unit>, FSharpFunc`2<a, FSharpFunc`2<WriterState, b>>> p_hole();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<WriterState, c>>>, Unit>, FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<WriterState, c>>>> p_hole2();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b[] u_array_core(FSharpFunc`2<a, b> f, int n, a st);
    internal static FSharpFunc`2<ReaderState, T[]> u_array(FSharpFunc`2<ReaderState, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> u_list_core(FSharpFunc`2<a, b> f, int n, a st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<a>, FSharpList`1<b>> u_list_ext(FSharpFunc`2<ReaderState, a> extra, FSharpFunc`2<ReaderState, b> f, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> u_list_revi(FSharpFunc`2<ReaderState, FSharpFunc`2<int, a>> f, ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> u_option(FSharpFunc`2<ReaderState, a> f, ReaderState st);
    internal static FSharpFunc`2<ReaderState, Lazy`1<T>> u_lazy(FSharpFunc`2<ReaderState, T> u);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, a>, Unit>, FSharpFunc`2<ReaderState, a>> u_hole();
    internal static FSharpFunc`2<ReaderState, string> get_u_encoded_string();
    internal static string u_string(ReaderState st);
    internal static FSharpFunc`2<ReaderState, FSharpList`1<string>> get_u_strings();
    internal static FSharpFunc`2<string, FSharpFunc`2<WriterState, Unit>> get_p_encoded_string();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_string(string s, WriterState st);
    internal static FSharpFunc`2<FSharpList`1<string>, FSharpFunc`2<WriterState, Unit>> get_p_strings();
    internal static string u_encoded_ccuref(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PublicPath decode_pubpath(ReaderState st, InputTable`1<string> stringTab, Int32[] a);
    internal static FSharpFunc`2<ReaderState, Int32[]> get_u_encoded_pubpath();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int encode_pubpath(Table`1<string> stringTab, Table`1<Int32[]> pubpathTab, PublicPath _arg1);
    internal static FSharpFunc`2<Int32[], FSharpFunc`2<WriterState, Unit>> get_p_encoded_pubpath();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static NonLocalEntityRef decode_nleref(ReaderState st, InputTable`1<CcuThunk> ccuTab, InputTable`1<string> stringTab, int a, Int32[] b);
    internal static FSharpFunc`2<ReaderState, Tuple`2<int, Int32[]>> get_u_encoded_nleref();
    internal static FSharpFunc`2<ReaderState, Int32[]> get_p2@341();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int encode_nleref(Table`1<string> ccuTab, Table`1<string> stringTab, Table`1<Tuple`2<int, Int32[]>> nlerefTab, CcuThunk thisCcu, NonLocalEntityRef nleref);
    internal static FSharpFunc`2<Tuple`2<int, Int32[]>, FSharpFunc`2<WriterState, Unit>> get_p_encoded_nleref();
    internal static FSharpFunc`2<Int32[], FSharpFunc`2<WriterState, Unit>> get_p2@247-1();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_nleref(NonLocalEntityRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType decode_simpletyp(ReaderState st, a _ccuTab, b _stringTab, InputTable`1<NonLocalEntityRef> nlerefTab, int a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_simpletyp(NonLocalEntityRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ByteBuffer pickleObjWithDanglingCcus(bool inMem, string file, TcGlobals g, CcuThunk scope, FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> p, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void check(ILScopeRef ilscope, NodeInTable`2<a, b> inMap);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PickledDataWithReferences`1<T> unpickleObjWithDanglingCcus(string file, ILScopeRef viewedScope, FSharpOption`1<ILModuleDef> ilModule, FSharpFunc`2<ReaderState, T> u, ReadOnlyByteMemory phase2bytes);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILPublicKey(PublicKey x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILVersion(ILVersionInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILModuleRef(ILModuleRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILAssemblyRef(ILAssemblyRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILScopeRef(ILScopeRef x, WriterState st);
    internal static PublicKey u_ILPublicKey(ReaderState st);
    internal static ILVersionInfo u_ILVersion(ReaderState st);
    internal static ILModuleRef u_ILModuleRef(ReaderState st);
    internal static ILAssemblyRef u_ILAssemblyRef(ReaderState st);
    internal static ILScopeRef u_ILScopeRef(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILHasThis(ILThisConvention x, WriterState st);
    internal static FSharpFunc`2<ILArrayShape, FSharpFunc`2<WriterState, Unit>> get_p_ILArrayShape();
    internal static FSharpFunc`2<FSharpOption`1<int>, FSharpFunc`2<WriterState, Unit>> get_p1@247();
    internal static FSharpFunc`2<FSharpOption`1<int>, FSharpFunc`2<WriterState, Unit>> get_p2@247-2();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILType(ILType ty, WriterState st);
    internal static FSharpFunc`2<WriterState, Unit> p_ILTypes(FSharpList`1<ILType> tys);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILBasicCallConv(ILArgConvention x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILCallConv(ILCallingConv _arg1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILCallSig(ILCallingSignature x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILTypeRef(ILTypeRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILTypeSpec(ILTypeSpec a, WriterState st);
    internal static ILArgConvention u_ILBasicCallConv(ReaderState st);
    internal static ILThisConvention u_ILHasThis(ReaderState st);
    internal static ILCallingConv u_ILCallConv(ReaderState st);
    internal static ILTypeRef u_ILTypeRef(ReaderState st);
    internal static FSharpFunc`2<ReaderState, ILArrayShape> get_u_ILArrayShape();
    internal static FSharpFunc`2<ReaderState, FSharpOption`1<int>> get_p1@341-1();
    internal static FSharpFunc`2<ReaderState, FSharpOption`1<int>> get_p2@341-3();
    internal static ILType u_ILType(ReaderState st);
    internal static FSharpFunc`2<ReaderState, ILCallingSignature> get_u_ILCallSig();
    internal static ILTypeSpec u_ILTypeSpec(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILMethodRef(ILMethodRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILFieldRef(ILFieldRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILMethodSpec(ILMethodSpec x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILFieldSpec(ILFieldSpec x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILBasicType(ILBasicType x, WriterState st);
    internal static ILMethodRef u_ILMethodRef(ReaderState st);
    internal static ILFieldRef u_ILFieldRef(ReaderState st);
    internal static ILMethodSpec u_ILMethodSpec(ReaderState st);
    internal static ILFieldSpec u_ILFieldSpec(ReaderState st);
    internal static ILBasicType u_ILBasicType(ReaderState st);
    internal static ILVolatility u_ILVolatility(ReaderState st);
    internal static ILReadonly u_ILReadonly(ReaderState st);
    internal static FSharpList`1<Tuple`2<int, ILInstr>> get_simple_instrs();
    internal static Dictionary`2<ILInstr, int> get_encode_table();
    internal static FSharpList`1<Tuple`2<int, ILInstr>> get_current@1-2();
    internal static void set_current@1-2(FSharpList`1<Tuple`2<int, ILInstr>> value);
    internal static FSharpList`1<Tuple`2<int, ILInstr>> get_next@1-2();
    internal static void set_next@1-2(FSharpList`1<Tuple`2<int, ILInstr>> value);
    internal static FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> get_decoders();
    internal static ILInstr func2@1(ILVolatility tupledArg0, ILFieldSpec tupledArg1);
    internal static ILInstr func2@1-1(ILVolatility tupledArg0, ILFieldSpec tupledArg1);
    internal static FSharpFunc`2[] get_decode_tab();
    internal static FSharpFunc`2[] get_tab@1189-1();
    [CompilerGeneratedAttribute]
internal static FSharpFunc`2<ReaderState, ILInstr> initializer@1-5(int n);
    internal static FSharpFunc`2[] get_arr@1();
    internal static FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> get_current@1-3();
    internal static void set_current@1-3(FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> value);
    internal static FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> get_next@1-3();
    internal static void set_next@1-3(FSharpList`1<Tuple`2<int, FSharpFunc`2<ReaderState, ILInstr>>> value);
    internal static FSharpList`1<Tuple`2<int, ILInstr>> get_current@1-4();
    internal static void set_current@1-4(FSharpList`1<Tuple`2<int, ILInstr>> value);
    internal static FSharpList`1<Tuple`2<int, ILInstr>> get_next@1-4();
    internal static void set_next@1-4(FSharpList`1<Tuple`2<int, ILInstr>> value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ILInstr(ILInstr x, WriterState st);
    internal static ILInstr u_ILInstr(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_Map_core(FSharpFunc`2<a, FSharpFunc`2<b, Unit>> pk, FSharpFunc`2<c, FSharpFunc`2<b, Unit>> pv, FSharpMap`2<a, c> xs, b st);
    internal static FSharpFunc`2<FSharpMap`2<string, T>, FSharpFunc`2<WriterState, Unit>> p_namemap(FSharpFunc`2<T, FSharpFunc`2<WriterState, Unit>> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<b, c> u_Map_core(FSharpFunc`2<a, b> uk, FSharpFunc`2<a, c> uv, int n, a st);
    internal static FSharpFunc`2<ReaderState, FSharpMap`2<string, T>> u_namemap(FSharpFunc`2<ReaderState, T> u);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_pos(Position x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_range(Range x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ident(Ident x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_xmldoc(XmlDoc doc, WriterState st);
    internal static Range u_range(ReaderState st);
    internal static Ident u_ident(ReaderState st);
    internal static XmlDoc u_xmldoc(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpFunc`2<WriterState, Unit> p_local_item_ref(string ctxt, NodeOutTable`2<a, b> tab, b st);
    internal static FSharpFunc`2<EntityRef, FSharpFunc`2<WriterState, Unit>> p_tcref(string ctxt);
    internal static FSharpFunc`2<UnionCaseRef, FSharpFunc`2<WriterState, Unit>> get_p_ucref();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_rfref(RecdFieldRef _arg1, WriterState st);
    internal static FSharpFunc`2<ReaderState, EntityRef> get_u_tcref();
    internal static FSharpFunc`2<ReaderState, UnionCaseRef> get_u_ucref();
    internal static RecdFieldRef u_rfref(ReaderState st);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>, Unit>, FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>> get_patternInput@1306-1();
    internal static FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>> get_p_ty2();
    internal static FSharpFunc`2<FSharpFunc`2<bool, FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>>>, Unit> get_fill_p_ty2();
    internal static FSharpFunc`2<TType, FSharpFunc`2<WriterState, Unit>> get_p_ty();
    internal static FSharpFunc`2<FSharpList`1<TType>, FSharpFunc`2<WriterState, Unit>> get_p_tys();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1311-2();
    internal static FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>> get_p_attribs();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Attrib>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_attribs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkForInRefStructThisArg(WriterState st, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_nonlocal_val_ref(NonLocalValOrMemberRef nlv, WriterState st);
    internal static FSharpFunc`2<ValRef, FSharpFunc`2<WriterState, Unit>> p_vref(string ctxt);
    internal static FSharpFunc`2<FSharpList`1<ValRef>, FSharpFunc`2<WriterState, Unit>> p_vrefs(string ctxt);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, TType>, Unit>, FSharpFunc`2<ReaderState, TType>> get_patternInput@1342-3();
    internal static FSharpFunc`2<ReaderState, TType> get_u_ty();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, TType>, Unit> get_fill_u_ty();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<TType>> get_u_tys();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>> get_patternInput@1344-4();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Attrib>> get_u_attribs();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Attrib>>, Unit> get_fill_u_attribs();
    internal static NonLocalValOrMemberRef u_nonlocal_val_ref(ReaderState st);
    internal static FSharpFunc`2<ReaderState, ValRef> get_u_vref();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<ValRef>> get_u_vrefs();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_member_kind(SynMemberKind x, WriterState st);
    internal static TyparKind u_kind(ReaderState st);
    internal static SynMemberKind u_member_kind(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_MemberFlags(SynMemberFlags x, WriterState st);
    internal static SynMemberFlags u_MemberFlags(ReaderState st);
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, Expr>, Unit>, FSharpFunc`2<ReaderState, Expr>> get_patternInput@1411-5();
    internal static FSharpFunc`2<ReaderState, Expr> get_u_expr_fwd();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, Expr>, Unit> get_fill_u_Expr_hole();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1412-6();
    internal static FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>> get_p_expr_fwd();
    internal static FSharpFunc`2<FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_Expr_hole();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_anonInfo_data(AnonRecdTypeInfo anonInfo, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_trait_sln(TraitConstraintSln sln, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_trait(TraitConstraintInfo _arg1, WriterState st);
    internal static AnonRecdTypeInfo u_anonInfo_data(ReaderState st);
    internal static TraitConstraintSln u_trait_sln(ReaderState st);
    internal static TraitConstraintInfo u_trait(ReaderState st);
    internal static FSharpFunc`2<WriterState, Unit> get_p_measure_one();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_measure_varcon(Measure unt, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_measure_pospower(Measure unt, int n, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_measure_intpower(Measure unt, int n, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_measure_power(Measure unt, Rational q, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_normalized_measure(Measure unt, WriterState st);
    internal static Rational u_rational(ReaderState st);
    internal static Measure u_measure_expr(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tyar_constraint(TyparConstraint x, WriterState st);
    internal static FSharpFunc`2<FSharpList`1<TyparConstraint>, FSharpFunc`2<WriterState, Unit>> get_p_tyar_constraints();
    internal static FSharpFunc`2<int, TyparConstraint> u_tyar_constraint(ReaderState st);
    internal static FSharpFunc`2<ReaderState, FSharpList`1<TyparConstraint>> get_u_tyar_constraints();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tyar_spec_data(Typar x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tyar_spec(Typar x, WriterState st);
    internal static FSharpFunc`2<FSharpList`1<Typar>, FSharpFunc`2<WriterState, Unit>> get_p_tyar_specs();
    internal static Typar u_tyar_spec_data(ReaderState st);
    internal static Typar u_tyar_spec(ReaderState st);
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Typar>> get_u_tyar_specs();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1728-7();
    internal static FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>> get_p_binds();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Binding>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_binds();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>> get_patternInput@1729-8();
    internal static FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>> get_p_targets();
    internal static FSharpFunc`2<FSharpFunc`2<DecisionTreeTarget[], FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_targets();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1730-9();
    internal static FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>> get_p_Exprs();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Expr>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_Exprs();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1731-10();
    internal static FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>> get_p_constraints();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<StaticOptimization>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_constraints();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>, Unit>, FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>> get_patternInput@1732-11();
    internal static FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>> get_p_Vals();
    internal static FSharpFunc`2<FSharpFunc`2<FSharpList`1<Val>, FSharpFunc`2<WriterState, Unit>>, Unit> get_fill_p_Vals();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Binding>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Binding>>> get_patternInput@1734-12();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Binding>> get_u_binds();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Binding>>, Unit> get_fill_u_binds();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, DecisionTreeTarget[]>, Unit>, FSharpFunc`2<ReaderState, DecisionTreeTarget[]>> get_patternInput@1735-13();
    internal static FSharpFunc`2<ReaderState, DecisionTreeTarget[]> get_u_targets();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, DecisionTreeTarget[]>, Unit> get_fill_u_targets();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Expr>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Expr>>> get_patternInput@1736-14();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Expr>> get_u_Exprs();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Expr>>, Unit> get_fill_u_Exprs();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>> get_patternInput@1737-15();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>> get_u_constraints();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<StaticOptimization>>, Unit> get_fill_u_constraints();
    internal static Tuple`2<FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Val>>, Unit>, FSharpFunc`2<ReaderState, FSharpList`1<Val>>> get_patternInput@1738-16();
    internal static FSharpFunc`2<ReaderState, FSharpList`1<Val>> get_u_Vals();
    internal static FSharpFunc`2<FSharpFunc`2<ReaderState, FSharpList`1<Val>>, Unit> get_fill_u_Vals();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ArgReprInfo(ArgReprInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_TyparReprInfo(TyparReprInfo _arg1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ValReprInfo(ValReprInfo _arg1, WriterState st);
    internal static ArgReprInfo u_ArgReprInfo(ReaderState st);
    internal static ValReprInfo u_ValReprInfo(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ranges(FSharpOption`1<Tuple`2<Range, Range>> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_istype(ModuleOrNamespaceKind x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_cpath(CompilationPath _arg1, WriterState st);
    internal static FSharpOption`1<Tuple`2<Range, Range>> u_ranges(ReaderState st);
    internal static ModuleOrNamespaceKind u_istype(ReaderState st);
    internal static CompilationPath u_cpath(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool p_tycon_repr(TyconRepresentation x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tycon_objmodel_data(FSharpTyconData x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_unioncase_spec(UnionCase x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_exnc_repr(ExceptionInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_access(Accessibility _arg1, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_recdfield_spec(RecdField x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_rfield_table(TyconRecdFields x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_entity_spec_data(Entity x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tcaug(TyconAugmentation p, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_entity_spec(Entity x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_parentref(ParentRef x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attribkind(AttribKind x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attrib(Attrib _arg2, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attrib_expr(AttribExpr _arg3, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_attrib_arg(AttribNamedArg _arg4, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_member_info(ValMemberInfo x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_tycon_objmodel_kind(FSharpTyconKind x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_vrefFlags(ValUseFlag x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_ValData(Val x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_Val(Val x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_modul_typ(ModuleOrNamespaceType x, WriterState st);
    internal static Tuple`2<FSharpList`1<ILTypeDef>, ILTypeDef> find@2085(ILTypeRef iltref, FSharpList`1<ILTypeDef> acc, FSharpList`1<string> enclosingTypeNames, ILTypeDefs tdefs);
    internal static FSharpFunc`2<bool, TyconRepresentation> u_tycon_repr(ReaderState st);
    internal static FSharpTyconData u_tycon_objmodel_data(ReaderState st);
    internal static UnionCase u_unioncase_spec(ReaderState st);
    internal static ExceptionInfo u_exnc_repr(ReaderState st);
    internal static Accessibility u_access(ReaderState st);
    internal static RecdField u_recdfield_spec(ReaderState st);
    internal static TyconRecdFields u_rfield_table(ReaderState st);
    internal static Entity u_entity_spec_data(ReaderState st);
    internal static TyconAugmentation u_tcaug(ReaderState st);
    internal static Entity u_entity_spec(ReaderState st);
    internal static ParentRef u_parentref(ReaderState st);
    internal static AttribKind u_attribkind(ReaderState st);
    internal static Attrib u_attrib(ReaderState st);
    internal static AttribExpr u_attrib_expr(ReaderState st);
    internal static AttribNamedArg u_attrib_arg(ReaderState st);
    internal static ValMemberInfo u_member_info(ReaderState st);
    internal static FSharpTyconKind u_tycon_objmodel_kind(ReaderState st);
    internal static ValUseFlag u_vrefFlags(ReaderState st);
    internal static Val u_ValData(ReaderState st);
    internal static Val u_Val(ReaderState st);
    internal static ModuleOrNamespaceType u_modul_typ(ReaderState st);
    internal static FSharpFunc`2<Const, FSharpFunc`2<WriterState, Unit>> get_p_const();
    internal static FSharpFunc`2<ReaderState, Const> get_u_const();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_dtree(DecisionTree x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_dtree_case(DecisionTreeCase _arg5, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_dtree_discrim(DecisionTreeTest x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_target(DecisionTreeTarget _arg6, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_bind(Binding _arg7, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_lval_op_kind(LValueOperation x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_recdInfo(RecordConstructionInfo x, WriterState st);
    internal static DecisionTree u_dtree(ReaderState st);
    internal static DecisionTreeCase u_dtree_case(ReaderState st);
    internal static DecisionTreeTest u_dtree_discrim(ReaderState st);
    internal static DecisionTreeTarget u_target(ReaderState st);
    internal static Binding u_bind(ReaderState st);
    internal static LValueOperation u_lval_op_kind(ReaderState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_op(TOp x, WriterState st);
    internal static TOp u_op(ReaderState st);
    internal static FSharpFunc`2<Expr, FSharpFunc`2<WriterState, Unit>> get_p_expr();
    internal static FSharpFunc`2<ReaderState, Expr> get_u_expr();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_static_optimization_constraint(StaticOptimization x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_slotparam(SlotParam _arg8, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_slotsig(SlotSig _arg9, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_method(ObjExprMethod _arg10, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_methods(FSharpList`1<ObjExprMethod> x, WriterState st);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void p_intfs(FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> x, WriterState st);
    internal static StaticOptimization u_static_optimization_constraint(ReaderState st);
    internal static SlotParam u_slotparam(ReaderState st);
    internal static SlotSig u_slotsig(ReaderState st);
    internal static ObjExprMethod u_method(ReaderState st);
    internal static FSharpList`1<ObjExprMethod> u_methods(ReaderState st);
    internal static Tuple`2<TType, FSharpList`1<ObjExprMethod>> u_intf(ReaderState st);
    internal static FSharpList`1<Tuple`2<TType, FSharpList`1<ObjExprMethod>>> u_intfs(ReaderState st);
    internal static FSharpFunc`2<PickledCcuInfo, FSharpFunc`2<WriterState, Unit>> get_pickleCcuInfo();
    internal static PickledCcuInfo unpickleCcuInfo(ReaderState st);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypeHierarchy : object {
    [CompilerGeneratedAttribute]
internal static FSharpOption`1<TType> resBeforeNull$cont@64(TcGlobals g, TType ty, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> GetSuperTypeOfType(TcGlobals g, ImportMap amap, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType mkSystemCollectionsGenericIListTy(TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> GetImmediateInterfacesOfMetadataType(TcGlobals g, ImportMap amap, Range m, SkipUnrefInterfaces skipUnref, TType ty, EntityRef tcref, FSharpList`1<TType> tinst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> GetImmediateInterfacesOfType(SkipUnrefInterfaces skipUnref, TcGlobals g, ImportMap amap, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> GetImmediateInterfacesOfMeasureAnnotatedType(SkipUnrefInterfaces skipUnref, TcGlobals g, ImportMap amap, Range m, TType ty, TType reprTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsSystemNumericsTypeInInterfaceHierarchy(SkipUnrefInterfaces skipUnref, TcGlobals g, ImportMap amap, Range m, TType ity);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsHeadTypeInInterfaceHierarchy(EntityRef target, SkipUnrefInterfaces skipUnref, TcGlobals g, ImportMap amap, Range m, TType intfTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsInInterfaceHierarchy(FSharpFunc`2<TType, bool> p, SkipUnrefInterfaces skipUnref, TcGlobals g, ImportMap amap, Range m, TType intfTy);
    internal static Tuple`3<FSharpSet`1<long>, TyconRefMultiMap`1<TType>, a> loop@225-44(bool followInterfaces, AllowMultiIntfInstantiations allowMultiIntfInst, SkipUnrefInterfaces skipUnref, FSharpFunc`2<TType, FSharpFunc`2<a, a>> visitor, TcGlobals g, ImportMap amap, Range m, int ndeep, TType ty, Tuple`3<FSharpSet`1<long>, TyconRefMultiMap`1<TType>, a> state);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a FoldHierarchyOfTypeAux(bool followInterfaces, AllowMultiIntfInstantiations allowMultiIntfInst, SkipUnrefInterfaces skipUnref, FSharpFunc`2<TType, FSharpFunc`2<a, a>> visitor, TcGlobals g, ImportMap amap, Range m, TType ty, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a FoldPrimaryHierarchyOfType(FSharpFunc`2<TType, FSharpFunc`2<a, a>> f, TcGlobals g, ImportMap amap, Range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a FoldEntireHierarchyOfType(FSharpFunc`2<TType, FSharpFunc`2<a, a>> f, TcGlobals g, ImportMap amap, Range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void IterateEntireHierarchyOfType(FSharpFunc`2<TType, Unit> f, TcGlobals g, ImportMap amap, Range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsInEntireHierarchyOfType(FSharpFunc`2<TType, bool> f, TcGlobals g, ImportMap amap, Range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> SearchEntireHierarchyOfType(FSharpFunc`2<TType, bool> f, TcGlobals g, ImportMap amap, Range m, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> AllSuperTypesOfType(TcGlobals g, ImportMap amap, Range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> AllInterfacesOfType(TcGlobals g, ImportMap amap, Range m, AllowMultiIntfInstantiations allowMultiIntfInst, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HaveSameHeadType(TcGlobals g, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool HasHeadType(TcGlobals g, EntityRef tcref, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsSameHeadTypeInHierarchy(TcGlobals g, ImportMap amap, Range m, TType typeToSearchFrom, TType typeToLookFor);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool ExistsHeadTypeInEntireHierarchy(TcGlobals g, ImportMap amap, Range m, TType typeToSearchFrom, EntityRef tcrefToLookFor);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportILTypeFromMetadata(ImportMap amap, Range m, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<TType> minst, ILType ilTy);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportILTypeFromMetadataWithAttributes(ImportMap amap, Range m, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<TType> minst, ILType ilTy, FSharpFunc`2<Unit, ILAttributes> getCattrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ImportParameterTypeFromMetadata(ImportMap amap, Range m, ILType ilTy, FSharpFunc`2<Unit, ILAttributes> getCattrs, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<TType> mist);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> ImportReturnTypeFromMetadata(ImportMap amap, Range m, ILType ilTy, FSharpFunc`2<Unit, ILAttributes> getCattrs, ILScopeRef scoref, FSharpList`1<TType> tinst, FSharpList`1<TType> minst);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TyparConstraint> CopyTyparConstraints(Range m, FSharpList`1<Tuple`2<Typar, TType>> tprefInst, Typar tporig);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<Tuple`2<Typar, TType>>, FSharpList`1<TType>> FixupNewTypars(Range m, FSharpList`1<Typar> formalEnclosingTypars, FSharpList`1<TType> tinst, FSharpList`1<Typar> tpsorig, FSharpList`1<Typar> tps);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.TypeProviderError : Exception {
    internal FSharpOption`1<string> typeNameContext;
    internal string tpDesignation;
    internal FSharpOption`1<string> methodNameContext;
    internal Range m;
    internal FSharpList`1<string> errors;
    internal int errNum;
    internal int Number { get; }
    internal Range Range { get; }
    public string Message { get; }
    internal string ContextualErrorMessage { get; }
    public TypeProviderError(int errNum, string tpDesignation, Range m, FSharpList`1<string> errors, FSharpOption`1<string> typeNameContext, FSharpOption`1<string> methodNameContext);
    public TypeProviderError(Tuple`2<int, string> _arg1, string tpDesignation, Range m);
    public TypeProviderError(int errNum, string tpDesignation, Range m, IEnumerable`1<string> messages);
    internal int get_Number();
    internal Range get_Range();
    public virtual string get_Message();
    internal TypeProviderError MapText(FSharpFunc`2<string, Tuple`2<int, string>> f, string tpDesignation, Range m);
    internal TypeProviderError WithContext(string typeNameContext, string methodNameContext);
    internal string get_ContextualErrorMessage();
    internal void Iter(FSharpFunc`2<TypeProviderError, Unit> f);
}
[SealedAttribute]
[ClassAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.TypeProviderLock : Lock`1<TypeProviderToken> {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypeProviders : object {
    internal static BindingFlags bindingFlags { get; }
    [CompilerGeneratedAttribute]
internal static int GetHashCode$cont@853-6(IEqualityComparer comp, ProvidedExprType this, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@853-10(ProvidedExprType this, ProvidedExprType that, IEqualityComparer comp, Unit unitVar);
    internal static FSharpList`1<string> toolingCompatiblePaths();
    internal static FSharpFunc`2<FSharpOption`1<string>, FSharpFunc`2<Exception, g>> raiseError@50(string runTimeAssemblyFileName, string designTimeAssemblyNameString, Range m);
    internal static FSharpList`1<Type> GetTypeProviderImplementationTypes(string runTimeAssemblyFileName, string designTimeAssemblyNameString, Range m, FSharpList`1<string> compilerToolPaths);
    internal static Exception StripException(Exception e);
    internal static g protect@114(Type typeProviderImplementationType, Range m, FSharpFunc`2<Unit, g> f);
    internal static ITypeProvider CreateTypeProvider(Type typeProviderImplementationType, string runtimeAssemblyPath, ResolutionEnvironment resolutionEnvironment, bool isInvalidationSupported, bool isInteractive, FSharpFunc`2<string, bool> systemRuntimeContainsType, Version systemRuntimeAssemblyVersion, Range m);
    internal static FSharpList`1<Tainted`1<ITypeProvider>> GetTypeProvidersOfAssembly(string runtimeAssemblyFilename, ILScopeRef ilScopeRefOfRuntimeAssembly, string designTimeName, ResolutionEnvironment resolutionEnvironment, bool isInvalidationSupported, bool isInteractive, FSharpFunc`2<string, bool> systemRuntimeContainsType, Version systemRuntimeAssemblyVersion, FSharpList`1<string> compilerToolPaths, Range m);
    internal static Tainted`1<U> TryTypeMember(Tainted`1<T> st, string fullName, string memberName, Range m, U recover, FSharpFunc`2<T, U> f);
    internal static Tainted`1[] TryTypeMemberArray(Tainted`1<d> st, string fullName, string memberName, Range m, FSharpFunc`2<d, e[]> f);
    internal static Tainted`1<U> TryTypeMemberNonNull(Tainted`1<T> st, string fullName, string memberName, Range m, U recover, FSharpFunc`2<T, U> f);
    internal static Tainted`1<c> TryMemberMember(Tainted`1<b> mi, string typeName, string memberName, string memberMemberName, Range m, c recover, FSharpFunc`2<b, c> f);
    internal static string DisplayNameOfTypeProvider(Tainted`1<ITypeProvider> resolver, Range m);
    internal static void ValidateNamespaceName(string name, Tainted`1<ITypeProvider> typeProvider, Range m, string nsp);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static BindingFlags get_bindingFlags();
    internal static ProvidedExpr GetInvokerExpression(ITypeProvider provider, ProvidedMethodBase methodBase, ProvidedVar[] paramExprs);
    internal static string CheckAndComputeProvidedNameProperty(Range m, Tainted`1<ProvidedType> st, FSharpFunc`2<ProvidedType, string> proj, string propertyString);
    internal static void ValidateAttributesOfProvidedType(Range m, Tainted`1<ProvidedType> st);
    internal static FSharpList`1<string> declaringTypes@990(Range m, string name, Tainted`1<ProvidedType> st, FSharpList`1<string> accu);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void ValidateExpectedName(Range m, String[] expectedPath, string expectedName, Tainted`1<ProvidedType> st);
    internal static void ValidateProvidedTypeAfterStaticInstantiation(Range m, Tainted`1<ProvidedType> st, String[] expectedPath, string expectedName);
    internal static void ValidateProvidedTypeDefinition(Range m, Tainted`1<ProvidedType> st, String[] expectedPath, string expectedName);
    internal static Tainted`1<ProvidedType> ResolveProvidedType(Tainted`1<ITypeProvider> resolver, Range m, String[] moduleOrNamespace, string typeName);
    internal static FSharpOption`1<Tainted`1<ProvidedType>> TryResolveProvidedType(Tainted`1<ITypeProvider> resolver, Range m, String[] moduleOrNamespace, string typeName);
    internal static string nameContrib@1182(Range m, Tainted`1<ProvidedType> st);
    internal static FSharpList`1<string> encContrib@1191(Range m, Tainted`1<ProvidedType> st);
    internal static Tuple`2<FSharpList`1<string>, string> ILPathToProvidedType(Tainted`1<ProvidedType> st, Range m);
    internal static string ComputeMangledNameForApplyStaticParameters(string nm, a[] staticArgs, Tainted`1<ProvidedParameterInfo[]> staticParams, Range m);
    internal static FSharpOption`1<Tainted`1<ProvidedMethodBase>> TryApplyProvidedMethod(Tainted`1<ProvidedMethodBase> methBeforeArgs, Object[] staticArgs, Range m);
    internal static FSharpOption`1<Tuple`2<Tainted`1<ProvidedType>, FSharpFunc`2<Unit, Unit>>> TryApplyProvidedType(Tainted`1<ProvidedType> typeBeforeArguments, FSharpOption`1<FSharpList`1<string>> optGeneratedTypePath, Object[] staticArgs, Range m);
    internal static FSharpOption`1<Tainted`1<ProvidedType>> TryLinkProvidedType(Tainted`1<ITypeProvider> resolver, String[] moduleOrNamespace, string typeLogicalName, Range range);
    internal static FSharpList`1<string> GetPartsOfNamespaceRecover(string namespaceName);
    internal static FSharpList`1<string> GetProvidedNamespaceAsPath(Range m, Tainted`1<ITypeProvider> resolver, string namespaceName);
    internal static FSharpList`1<string> walkUpNestedClasses@1345(Range range, Tainted`1<ProvidedType> st, FSharpList`1<string> soFar);
    internal static FSharpList`1<string> GetFSharpPathToProvidedType(Tainted`1<ProvidedType> st, Range range);
    internal static ILAssemblyRef GetOriginalILAssemblyRefOfProvidedAssembly(Tainted`1<ProvidedAssembly> assembly, Range m);
    internal static ILTypeRef GetOriginalILTypeRefOfProvidedType(Tainted`1<ProvidedType> st, Range range);
    internal static ILTypeRef GetILTypeRefOfProvidedType(Tainted`1<ProvidedType> st, Range range);
    internal static bool IsGeneratedTypeDirectReference(Tainted`1<ProvidedType> st, Range m);
    [CompilerGeneratedAttribute]
internal static bool Equals$cont@853-11(ProvidedExprType this, ProvidedExprType obj, Unit unitVar);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.TypeProviderToken : object {
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.TypeRelations : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeDefinitelySubsumesTypeNoCoercion(int ndeep, TcGlobals g, ImportMap amap, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType stripAll(bool stripMeasures, TcGlobals g, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypesFeasiblyEquivalent(bool stripMeasures, int ndeep, TcGlobals g, a amap, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypesFeasiblyEquiv(int ndeep, TcGlobals g, a amap, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypesFeasiblyEquivStripMeasures(TcGlobals g, a amap, Range m, TType ty1, TType ty2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool TypeFeasiblySubsumesType(int ndeep, TcGlobals g, ImportMap amap, Range m, TType ty1, CanCoerce canCoerce, TType ty2);
    internal static Tuple`2<TType, bool> join@145(TcGlobals g, ImportMap amap, TType maxTy, bool isRefined, Range m, TType x);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Tuple`2<TType, bool>, Range> ChooseTyparSolutionAndRange$cont@151(TcGlobals g, ImportMap amap, TyparConstraint tpc, TType maxTy, bool isRefined, Unit unitVar);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<TType, Range> ChooseTyparSolutionAndRange(TcGlobals g, ImportMap amap, Typar tp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static TType ChooseTyparSolution(TcGlobals g, ImportMap amap, Typar tp);
    internal static FSharpList`1<TType> loop@208-48(TcGlobals g, FSharpList`1<Tuple`2<Typar, TType>> tpenv, int n, FSharpList`1<TType> curr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<TType> IterativelySubstituteTyparSolutions(TcGlobals g, FSharpList`1<Typar> tps, FSharpList`1<TType> solutions);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Expr ChooseTyparSolutionsForFreeChoiceTypars(TcGlobals g, ImportMap amap, Expr e);
    internal static Tuple`3<FSharpList`1<FSharpList`1<Val>>, Expr, TType> stripLambdaUpto@245(int n, Expr e, TType ty);
    internal static Tuple`5<FSharpOption`1<Val>, FSharpOption`1<Val>, FSharpList`1<FSharpList`1<Val>>, Expr, TType> startStripLambdaUpto@253(TcGlobals g, ImportMap amap, int n, Expr e, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`6<FSharpList`1<Typar>, FSharpOption`1<Val>, FSharpOption`1<Val>, FSharpList`1<FSharpList`1<Val>>, Expr, TType>> tryDestLambdaWithValReprInfo(TcGlobals g, ImportMap amap, ValReprInfo valReprInfo, Expr lambdaExpr, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<Typar>, FSharpOption`1<Val>, FSharpOption`1<Val>, FSharpList`1<FSharpList`1<Val>>, Expr, TType> destLambdaWithValReprInfo(TcGlobals g, ImportMap amap, ValReprInfo valReprInfo, Expr lambdaExpr, TType ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<Val>>, Expr> IteratedAdjustArityOfLambdaBody(TcGlobals g, FSharpList`1<int> arities, FSharpList`1<FSharpList`1<Val>> vsl, Expr body);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<FSharpList`1<Typar>, FSharpOption`1<Val>, FSharpOption`1<Val>, FSharpList`1<FSharpList`1<Val>>, Expr, TType> IteratedAdjustLambdaToMatchValReprInfo(TcGlobals g, ImportMap amap, ValReprInfo valReprInfo, Expr lambdaExpr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<TType> FindUniqueFeasibleSupertype(TcGlobals g, ImportMap amap, Range m, TType ty1, TType ty2);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.UnicodeLexing : object {
    internal static LexBuffer`1<char> StringAsLexbuf(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, string s);
    internal static LexBuffer`1<char> FunctionAsLexbuf(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, FSharpFunc`2<Tuple`3<Char[], int, int>, int> bufferFiller);
    internal static LexBuffer`1<char> SourceTextAsLexbuf(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, ISourceText sourceText);
    internal static LexBuffer`1<char> StreamReaderAsLexbuf(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, StreamReader reader);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.UpdatePrettyTyparNames : object {
    internal static void updateVal(Val v);
    internal static void updateEntity(Entity entity);
    internal static void updateModuleOrNamespaceType(ModuleOrNamespaceType signatureData);
}
[CompilationMappingAttribute("3")]
internal interface FSharp.Compiler.Xml.IXmlDocumentationInfoLoader {
    public abstract virtual FSharpOption`1<XmlDocumentationInfo> TryLoad(string assemblyFileName);
}
[SealedAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
public class FSharp.Compiler.Xml.PreXmlDoc : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static PreXmlDoc _unique_PreXmlDocEmpty;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPreXmlDirect { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPreXmlMerge { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPreXmlDoc { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal static PreXmlDoc PreXmlDocEmpty { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsPreXmlDocEmpty { get; }
    public Range Range { get; }
    public bool IsEmpty { get; }
    public static PreXmlDoc Empty { get; }
    private static PreXmlDoc();
    [DynamicDependencyAttribute("2016", "FSharp.Compiler.Xml.PreXmlDoc")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PreXmlDoc(int _tag);
    [CompilationMappingAttribute("8", "0")]
internal static PreXmlDoc NewPreXmlDirect(String[] _unprocessedLines, Range _range);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPreXmlDirect();
    [CompilationMappingAttribute("8", "1")]
internal static PreXmlDoc NewPreXmlMerge(PreXmlDoc item1, PreXmlDoc item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPreXmlMerge();
    [CompilationMappingAttribute("8", "2")]
internal static PreXmlDoc NewPreXmlDoc(Position item1, XmlDocCollector item2);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPreXmlDoc();
    [CompilationMappingAttribute("8", "3")]
internal static PreXmlDoc get_PreXmlDocEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsPreXmlDocEmpty();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    public XmlDoc ToXmlDoc(bool check, FSharpOption`1<FSharpList`1<string>> paramNamesOpt);
    public Range get_Range();
    public bool get_IsEmpty();
    internal void MarkAsInvalid();
    internal static PreXmlDoc CreateFromGrabPoint(XmlDocCollector collector, Position grabPointPos);
    public static PreXmlDoc get_Empty();
    public static PreXmlDoc Create(String[] unprocessedLines, Range range);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static PreXmlDoc Merge(PreXmlDoc a, PreXmlDoc b);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PreXmlDoc obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[ClassAttribute]
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("3")]
public class FSharp.Compiler.Xml.XmlDoc : object {
    internal String[] unprocessedLines;
    internal Range range;
    public String[] UnprocessedLines { get; }
    public Range Range { get; }
    public static XmlDoc Empty { get; }
    public bool IsEmpty { get; }
    public bool NonEmpty { get; }
    public XmlDoc(String[] unprocessedLines, Range range);
    public String[] get_UnprocessedLines();
    public String[] GetElaboratedXmlLines();
    public Range get_Range();
    public static XmlDoc get_Empty();
    public bool get_IsEmpty();
    public bool get_NonEmpty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static XmlDoc Merge(XmlDoc doc1, XmlDoc doc2);
    public string GetXmlText();
    internal void Check(FSharpOption`1<FSharpList`1<string>> paramNamesOpt);
    [CompilerGeneratedAttribute]
internal FSharpList`1<string> processLines(FSharpList`1<string> lines);
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Xml.XmlDocCollector : object {
    internal List`1<Tuple`2<string, Range>> savedLines;
    internal Dictionary`2<Position, ValueTuple`3<int, int, bool>> savedGrabPoints;
    internal int currentGrabPointCommentsCount;
    internal FSharpValueOption`1<Position> delayedGrabPoint;
    internal void AddGrabPoint(Position pos);
    internal void AddGrabPointDelayed(Position pos);
    internal void AddXmlDocLine(string line, Range range);
    internal Tuple`2[] LinesBefore(Position grabPointPos);
    internal Range LinesRange(Position grabPointPos);
    internal void SetXmlDocValidity(Position grabPointPos, bool isValid);
    internal bool HasComments(Position grabPointPos);
    internal FSharpList`1<Range> CheckInvalidXmlDocPositions();
}
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Xml.XmlDocStatics : object {
    internal static XmlDoc empty;
    internal static int init@159;
    internal static XmlDoc Empty { get; }
    private static XmlDocStatics();
    internal static XmlDoc get_Empty();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class FSharp.Compiler.Xml.XmlDocumentationInfo : object {
    internal FSharpFunc`2<Unit, FSharpOption`1<XmlDocument>> tryGetXmlDocument;
    internal static AgedLookup`3<Unit, Tuple`2<string, DateTime>, XmlDocument> cache;
    internal static int init@303-1;
    public XmlDocumentationInfo(FSharpFunc`2<Unit, FSharpOption`1<XmlDocument>> tryGetXmlDocument);
    private static XmlDocumentationInfo();
    internal FSharpOption`1<XmlDoc> TryGetXmlDocBySig(string xmlDocSig);
    internal static FSharpOption`1<XmlDocumentationInfo> TryCreateFromFile(string xmlFileName);
    [CompilerGeneratedAttribute]
internal static bool cacheAreSimilar(Tuple`2<string, DateTime> _arg1, Tuple`2<string, DateTime> _arg2);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<XmlNode> tryGetSummaryNode(string xmlDocSig);
}
[CompilationMappingAttribute("7")]
internal static class FSharp.Compiler.XmlDocFileWriter : object {
}
[CompilationMappingAttribute("3")]
internal class FSIstrings.SR : object {
    internal static Lazy`1<ResourceManager> resources;
    internal static Type funTyC;
    internal static bool swallowResourceText;
    internal static int init@14;
    internal static bool SwallowResourceText { get; internal set; }
    private static SR();
    internal static bool get_SwallowResourceText();
    internal static void set_SwallowResourceText(bool b);
    internal static string stoppedDueToError();
    internal static string fsiUsage(string a0);
    internal static string fsiInputFiles();
    internal static string fsiCodeGeneration();
    internal static string fsiErrorsAndWarnings();
    internal static string fsiLanguage();
    internal static string fsiMiscellaneous();
    internal static string fsiAdvanced();
    internal static string fsiExceptionRaisedStartingServer(string a0);
    internal static string fsiUse();
    internal static string fsiLoad();
    internal static string fsiRemaining();
    internal static string fsiHelp();
    internal static string fsiExec();
    internal static string fsiGui();
    internal static string fsiQuiet();
    internal static string fsiReadline();
    internal static string fsiEmitDebugInfoInQuotations();
    internal static string fsiBanner3();
    internal static string fsiConsoleProblem();
    internal static Tuple`2<int, string> fsiInvalidAssembly(string a0);
    internal static Tuple`2<int, string> fsiDirectoryDoesNotExist(string a0);
    internal static string fsiLineTooLong();
    internal static string fsiTimeInfoMainString(string a0, string a1, string a2);
    internal static string fsiTimeInfoGCGenerationLabelSomeShorthandForTheWordGeneration();
    internal static string fsiExceptionDuringPrettyPrinting(string a0);
    internal static string fsiIntroTextHeader1directives();
    internal static string fsiIntroTextHashrInfo();
    internal static string fsiIntroTextHashIInfo();
    internal static string fsiIntroPackageSourceUriInfo();
    internal static string fsiIntroTextHashloadInfo();
    internal static string fsiIntroTextHashtimeInfo();
    internal static string fsiIntroTextHashhelpInfo();
    internal static string fsiIntroTextHashquitInfo();
    internal static string fsiIntroTextHashclearInfo();
    internal static string fsiIntroTextHeader2commandLine();
    internal static string fsiIntroTextHeader3(string a0);
    internal static string fsiLoadingFilesPrefixText();
    internal static string fsiInterrupt();
    internal static string fsiExit();
    internal static string fsiAbortingMainThread();
    internal static string fsiCouldNotInstallCtrlCHandler(string a0);
    internal static string fsiDidAHashr(string a0);
    internal static string fsiDidAHashrWithLockWarning(string a0);
    internal static string fsiDidAHashrWithStaleWarning(string a0);
    internal static string fsiDidAHashI(string a0);
    internal static string fsiTurnedTimingOn();
    internal static string fsiTurnedTimingOff();
    internal static string fsiUnexpectedThreadAbortException();
    internal static string fsiFailedToResolveAssembly(string a0);
    internal static string fsiBindingSessionTo(string a0);
    internal static string fsiProductName(string a0);
    internal static string fsiProductNameCommunity(string a0);
    internal static string shadowCopyReferences();
    internal static string fsiOperationCouldNotBeCompleted();
    internal static string fsiOperationFailed();
    internal static string fsiMultiAssemblyEmitOption();
    internal static Tuple`2<int, string> fsiEntryPointWontBeInvoked(string a0, string a1, string a2);
    internal static void RunStartupValidation();
    [CompilerGeneratedAttribute]
internal static Assembly getCurrentAssembly();
    [CompilerGeneratedAttribute]
internal static Type getTypeInfo(Type t);
    [CompilerGeneratedAttribute]
internal static string GetString(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object mkFunctionValue(Type[] tys, FSharpFunc`2<object, object> impl);
    [CompilerGeneratedAttribute]
internal static bool isNamedType(Type ty);
    [CompilerGeneratedAttribute]
internal static bool isFunctionType(Type ty1);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Type, Type[]> destFunTy(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object buildFunctionForOneArgPat(Type ty, FSharpFunc`2<Type, FSharpFunc`2<object, object>> impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object capture1(string fmt, int i, FSharpList`1<object> args, Type ty, FSharpFunc`2<FSharpList`1<object>, FSharpFunc`2<Type, FSharpFunc`2<int, object>>> go);
    [CompilerGeneratedAttribute]
internal static string postProcessString(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static T createMessageString(string messageString, PrintfFormat`4<T, Unit, string, string> fmt);
    [CompilerGeneratedAttribute]
internal static T GetStringFunc(string messageID, PrintfFormat`4<T, Unit, string, string> fmt);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.AgedLookup`3 : object {
    internal FSharpFunc`2<Tuple`2<Key, Key>, bool> areSimilar;
    internal FSharpList`1<Tuple`2<Key, ValueStrength`1<Value>>> refs;
    internal int keepStrongly@22;
    internal int keepMax@28-1;
    internal FSharpFunc`2<Value, bool> requiredToKeep@29;
    public AgedLookup`3(int keepStrongly, FSharpFunc`2<Tuple`2<Key, Key>, bool> areSimilar, FSharpOption`1<FSharpFunc`2<Value, bool>> requiredToKeep, FSharpOption`1<int> keepMax);
    internal FSharpOption`1<Tuple`2<Key, Value>> TryPeekKeyValue(Token tok, Key key);
    internal FSharpOption`1<Tuple`2<Key, Value>> TryGetKeyValue(Token tok, Key key);
    internal FSharpOption`1<Value> TryGet(Token tok, Key key);
    internal void Put(Token tok, Key key, Value value);
    internal void Remove(Token tok, Key key);
    internal void Clear(Token tok);
    internal void Resize(Token tok, int newKeepStrongly, FSharpOption`1<int> newKeepMax);
    [CompilerGeneratedAttribute]
internal FSharpOption`1<Tuple`2<Key, d>> TryPeekKeyValueImpl(FSharpList`1<Tuple`2<Key, d>> data, Key key);
    [CompilerGeneratedAttribute]
internal bool Exists(FSharpList`1<Tuple`2<Key, d>> data, Key key);
    [CompilerGeneratedAttribute]
internal FSharpList`1<Tuple`2<d, e>> Add(FSharpList`1<Tuple`2<d, e>> data, d key, e value);
    [CompilerGeneratedAttribute]
internal FSharpList`1<Tuple`2<Key, a>> Promote(FSharpList`1<Tuple`2<Key, a>> data, Key key, a value);
    [CompilerGeneratedAttribute]
internal FSharpList`1<Tuple`2<Key, d>> RemoveImpl(FSharpList`1<Tuple`2<Key, d>> data, Key key);
    [CompilerGeneratedAttribute]
internal Tuple`2<FSharpOption`1<Tuple`2<Key, d>>, FSharpList`1<Tuple`2<Key, d>>> TryGetKeyValueImpl(FSharpList`1<Tuple`2<Key, d>> data, Key key);
    [CompilerGeneratedAttribute]
internal FSharpList`1<Tuple`2<Key, Value>> FilterAndHold(Token tok);
    [CompilerGeneratedAttribute]
internal void AssignWithStrength(d tok, FSharpList`1<Tuple`2<Key, Value>> newData);
}
[DefaultMemberAttribute("Item")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.HashMultiMap`2 : object {
    internal Dictionary`2<Key, Value> firstEntries;
    internal Dictionary`2<Key, FSharpList`1<Value>> rest;
    internal int init@10;
    internal Dictionary`2<Key, Value> FirstEntries { get; }
    internal Dictionary`2<Key, FSharpList`1<Value>> Rest { get; }
    internal Value Item { get; internal set; }
    internal int Count { get; }
    public HashMultiMap`2(int size, IEqualityComparer`1<Key> comparer);
    public HashMultiMap`2(IEqualityComparer`1<Key> comparer);
    public HashMultiMap`2(IEnumerable`1<Tuple`2<Key, Value>> entries, IEqualityComparer`1<Key> comparer);
    internal FSharpList`1<Value> GetRest(Key k);
    internal void Add(Key y, Value z);
    internal void Clear();
    internal Dictionary`2<Key, Value> get_FirstEntries();
    internal Dictionary`2<Key, FSharpList`1<Value>> get_Rest();
    internal HashMultiMap`2<Key, Value> Copy();
    internal Value get_Item(Key y);
    internal void set_Item(Key y, Value z);
    internal FSharpList`1<Value> FindAll(Key y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal State Fold(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<State, State>>> f, State acc);
    internal void Iterate(FSharpFunc`2<Key, FSharpFunc`2<Value, Unit>> f);
    internal bool Contains(Key y);
    internal bool ContainsKey(Key y);
    internal void Remove(Key y);
    internal void Replace(Key y, Value z);
    internal FSharpOption`1<Value> TryFind(Key y);
    internal int get_Count();
    private virtual override IEnumerator`1<KeyValuePair`2<Key, Value>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override Value System.Collections.Generic.IDictionary<'Key, 'Value>.get_Item(Key x);
    private virtual override void System.Collections.Generic.IDictionary<'Key, 'Value>.set_Item(Key x, Value v);
    private virtual override ICollection`1<Key> System.Collections.Generic.IDictionary<'Key, 'Value>.get_Keys();
    private virtual override ICollection`1<Value> System.Collections.Generic.IDictionary<'Key, 'Value>.get_Values();
    private virtual override void System.Collections.Generic.IDictionary<'Key, 'Value>.Add(Key k, Value v);
    private virtual override bool System.Collections.Generic.IDictionary<'Key, 'Value>.ContainsKey(Key k);
    private virtual override bool System.Collections.Generic.IDictionary<'Key, 'Value>.TryGetValue(Key k, Value& r);
    private virtual override bool System.Collections.Generic.IDictionary<'Key, 'Value>.Remove(Key k);
    private virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.Add(KeyValuePair`2<Key, Value> x);
    private virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.Clear();
    private virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.Remove(KeyValuePair`2<Key, Value> x);
    private virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.Contains(KeyValuePair`2<Key, Value> x);
    private virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.CopyTo(KeyValuePair`2[] arr, int arrIndex);
    private virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.get_IsReadOnly();
    private virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.get_Count();
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.MruCache`3 : object {
    internal FSharpFunc`2<Tuple`2<Key, Key>, bool> areSame;
    internal AgedLookup`3<Token, Key, Value> cache;
    internal FSharpFunc`2<Tuple`2<Key, Value>, bool> isStillValid@191;
    public MruCache`3(int keepStrongly, FSharpFunc`2<Tuple`2<Key, Key>, bool> areSame, FSharpOption`1<FSharpFunc`2<Tuple`2<Key, Value>, bool>> isStillValid, FSharpOption`1<FSharpFunc`2<Tuple`2<Key, Key>, bool>> areSimilar, FSharpOption`1<FSharpFunc`2<Value, bool>> requiredToKeep, FSharpOption`1<int> keepMax);
    internal bool ContainsSimilarKey(Token tok, Key key);
    internal FSharpOption`1<Value> TryGetAny(Token tok, Key key);
    internal FSharpOption`1<Value> TryGet(Token tok, Key key);
    internal FSharpOption`1<Value> TryGetSimilarAny(Token tok, Key key);
    internal FSharpOption`1<Value> TryGetSimilar(Token tok, Key key);
    internal void Set(Token tok, Key key, Value value);
    internal void RemoveAnySimilar(Token tok, Key key);
    internal void Clear(Token tok);
    internal void Resize(Token tok, int newKeepStrongly, FSharpOption`1<int> newKeepMax);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Collections.QueueList : object {
    internal static QueueList`1<T> empty();
    internal static QueueList`1<a> ofSeq(IEnumerable`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<a, Unit> f, QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueueList`1<b> map(FSharpFunc`2<a, b> f, QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<a, bool> f, QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueueList`1<a> filter(FSharpFunc`2<a, bool> f, QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldBack(FSharpFunc`2<a, FSharpFunc`2<b, b>> f, QueueList`1<a> x, b acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<a, bool> f, QueueList`1<a> x);
    internal static QueueList`1<a> ofList(FSharpList`1<a> x);
    internal static FSharpList`1<a> toList(QueueList`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> tryFind(FSharpFunc`2<a, bool> f, QueueList`1<a> x);
    internal static QueueList`1<a> one(a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueueList`1<a> appendOne(QueueList`1<a> x, a y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static QueueList`1<a> append(QueueList`1<a> x, QueueList`1<a> ys);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.QueueList`1 : object {
    internal int numLastElementsIn;
    internal bool push;
    internal FSharpList`1<T> firstElements;
    internal FSharpList`1<T> lastElementsRev;
    internal int numLastElements;
    internal static QueueList`1<T> empty;
    internal static int init@13;
    internal static QueueList`1<T> Empty { get; }
    internal FSharpList`1<T> FirstElements { get; }
    internal FSharpList`1<T> LastElements { get; }
    public QueueList`1(FSharpList`1<T> firstElementsIn, FSharpList`1<T> lastElementsRevIn, int numLastElementsIn);
    private static QueueList`1();
    public QueueList`1(FSharpList`1<T> xs);
    internal static QueueList`1<T> get_Empty();
    internal FSharpList`1<T> ToList();
    internal FSharpList`1<T> get_FirstElements();
    internal FSharpList`1<T> get_LastElements();
    internal QueueList`1<T> AppendOne(T y);
    internal QueueList`1<T> Append(IEnumerable`1<T> ys);
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal FSharpList`1<T> lastElements();
}
[DefaultMemberAttribute("Item")]
[SealedAttribute]
[DebuggerDisplayAttribute("Count = {Count}")]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.Tagged.Map`3 : object {
    internal MapTree`2<Key, Value> tree;
    internal IComparer`1<Key> comparer;
    internal MapTree`2<Key, Value> Tree { get; }
    internal IComparer`1<Key> Comparer { get; }
    internal bool IsEmpty { get; }
    internal Value Item { get; }
    internal int Count { get; }
    public Map`3(IComparer`1<Key> comparer, MapTree`2<Key, Value> tree);
    private static Map`3();
    internal MapTree`2<Key, Value> get_Tree();
    internal IComparer`1<Key> get_Comparer();
    internal static Map`3<Key, Value, ComparerTag> Empty(ComparerTag comparer);
    internal Map`3<Key, Value, ComparerTag> Add(Key k, Value v);
    internal bool get_IsEmpty();
    internal Value get_Item(Key k);
    internal FSharpOption`1<T> First(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpOption`1<T>>> f);
    internal bool Exists(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    internal Map`3<Key, Value, ComparerTag> Filter(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    internal bool ForAll(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal State Fold(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<State, State>>> folder, State acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal State FoldSection(Key lo, Key hi, FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<State, State>>> f, State acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Tuple`2<Map`3<Key, T, ComparerTag>, State> FoldAndMap(FSharpFunc`2<Key, FSharpFunc`2<Value, FSharpFunc`2<State, Tuple`2<T, State>>>> f, State z);
    internal void Iterate(FSharpFunc`2<Key, FSharpFunc`2<Value, Unit>> action);
    internal Map`3<Key, T, ComparerTag> MapRange(FSharpFunc`2<Value, T> mapping);
    internal Map`3<Key, T, ComparerTag> Map(FSharpFunc`2<Key, FSharpFunc`2<Value, T>> mapping);
    internal Tuple`2<Map`3<Key, Value, ComparerTag>, Map`3<Key, Value, ComparerTag>> Partition(FSharpFunc`2<Key, FSharpFunc`2<Value, bool>> f);
    internal int get_Count();
    internal bool ContainsKey(Key k);
    internal Map`3<Key, Value, ComparerTag> Remove(Key k);
    internal FSharpOption`1<Value> TryFind(Key k);
    internal FSharpList`1<Tuple`2<Key, Value>> ToList();
    internal Tuple`2[] ToArray();
    internal static Map`3<Key, Value, ComparerTag> FromList(ComparerTag comparer, FSharpList`1<Tuple`2<Key, Value>> l);
    internal static Map`3<Key, Value, ComparerTag> Create(ComparerTag comparer, IEnumerable`1<Tuple`2<Key, Value>> ie);
    public virtual bool Equals(object that);
    internal int ComputeHashCode();
    public virtual int GetHashCode();
    private virtual override IEnumerator`1<KeyValuePair`2<Key, Value>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<'Key, 'Value>>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private virtual override int System.IComparable.CompareTo(object m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static Map`3<Key, e, ComparerTag> refresh(Map`3<Key, d, ComparerTag> m, MapTree`2<Key, e> t);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[AllowNullLiteralAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.Tagged.MapTree`2 : object {
    internal Value v;
    internal Key k;
    internal Key Key { get; }
    internal Value Value { get; }
    public MapTree`2(Key k, Value v);
    internal Key get_Key();
    internal Value get_Value();
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Collections.Tagged.MapTreeModule : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int sizeAux(int acc, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<Key, Value> mk(MapTree`2<Key, Value> l, Key k, Value v, MapTree`2<Key, Value> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<Key, Value> rebalance(MapTree`2<Key, Value> t1, Key k, Value v, MapTree`2<Key, Value> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<Key, Value> add(IComparer`1<Key> comparer, Key k, Value v, MapTree`2<Key, Value> m);
    internal static a indexNotFound();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool tryGetValue(IComparer`1<Key> comparer, Key k, Value& v, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Value find(IComparer`1<Key> comparer, Key k, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Value> tryFind(IComparer`1<Key> comparer, Key k, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<Key, a>, MapTree`2<Key, a>> partition1(IComparer`1<Key> comparer, FSharpFunc`3<Key, a, bool> f, Key k, a v, MapTree`2<Key, a> acc1, MapTree`2<Key, a> acc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<Key, Value>, MapTree`2<Key, Value>> partitionAux(IComparer`1<Key> comparer, FSharpFunc`3<Key, Value, bool> f, MapTree`2<Key, Value> m, MapTree`2<Key, Value> acc_0, MapTree`2<Key, Value> acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<Key, a> filter1(IComparer`1<Key> comparer, FSharpFunc`3<Key, a, bool> f, Key k, a v, MapTree`2<Key, a> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<Key, Value> filterAux(IComparer`1<Key> comparer, FSharpFunc`3<Key, Value, bool> f, MapTree`2<Key, Value> m, MapTree`2<Key, Value> acc);
    internal static Tuple`3<Key, Value, MapTree`2<Key, Value>> spliceOutSuccessor(MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<Key, Value> remove(IComparer`1<Key> comparer, Key k, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool mem(IComparer`1<Key> comparer, Key k, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iterOpt(FSharpFunc`3<Key, Value, Unit> f, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> tryPickOpt(FSharpFunc`3<Key, Value, FSharpOption`1<a>> f, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsOpt(FSharpFunc`3<Key, Value, bool> f, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forallOpt(FSharpFunc`3<Key, Value, bool> f, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<Key, Result> map(FSharpFunc`2<Value, Result> f, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<Key, Result> mapiOpt(FSharpFunc`3<Key, Value, Result> f, MapTree`2<Key, Value> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldBackOpt(FSharpFunc`4<Key, Value, a, a> f, MapTree`2<Key, Value> m, a x);
    internal static b foldFromTo@1020(IComparer`1<Key> comparer, Key lo, Key hi, FSharpFunc`4<Key, Value, b, b> f, MapTree`2<Key, Value> m, b x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldSectionOpt(IComparer`1<Key> comparer, Key lo, Key hi, FSharpFunc`4<Key, Value, a, a> f, MapTree`2<Key, Value> m, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<MapTree`2<Key, b>, a> foldMapOpt(IComparer`1<Key> comparer, FSharpFunc`4<Key, Value, a, Tuple`2<b, a>> f, MapTree`2<Key, Value> m, a z, MapTree`2<Key, b> acc);
    internal static FSharpList`1<Tuple`2<a, b>> toList(MapTree`2<a, b> m);
    internal static Tuple`2[] toArray(MapTree`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> ofList(IComparer`1<a> comparer, FSharpList`1<Tuple`2<a, b>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> mkFromEnumerator(IComparer`1<a> comparer, MapTree`2<a, b> acc, IEnumerator`1<Tuple`2<a, b>> e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static MapTree`2<a, b> ofSeq(IComparer`1<a> comparer, IEnumerable`1<Tuple`2<a, b>> c);
    internal static IEnumerator`1<KeyValuePair`2<a, b>> toSeq(MapTree`2<a, b> s);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[SealedAttribute]
[AllowNullLiteralAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.Tagged.MapTreeNode`2 : MapTree`2<Key, Value> {
    internal MapTree`2<Key, Value> right;
    internal MapTree`2<Key, Value> left;
    internal int h;
    internal MapTree`2<Key, Value> Left { get; }
    internal MapTree`2<Key, Value> Right { get; }
    internal int Height { get; }
    public MapTreeNode`2(Key k, Value v, MapTree`2<Key, Value> left, MapTree`2<Key, Value> right, int h);
    internal MapTree`2<Key, Value> get_Left();
    internal MapTree`2<Key, Value> get_Right();
    internal int get_Height();
}
[SealedAttribute]
[DebuggerDisplayAttribute("Count = {Count}")]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.Tagged.Set`2 : object {
    internal SetTree`1<T> tree;
    internal IComparer`1<T> comparer;
    internal SetTree`1<T> Tree { get; }
    internal IComparer`1<T> Comparer { get; }
    internal int Count { get; }
    internal bool IsEmpty { get; }
    internal T Choose { get; }
    internal T MinimumElement { get; }
    internal T MaximumElement { get; }
    public Set`2(IComparer`1<T> comparer, SetTree`1<T> tree);
    private static Set`2();
    internal SetTree`1<T> get_Tree();
    internal IComparer`1<T> get_Comparer();
    internal static Set`2<T, ComparerTag> Empty(ComparerTag comparer);
    internal Set`2<T, ComparerTag> Add(T x);
    internal Set`2<T, ComparerTag> Remove(T x);
    internal int get_Count();
    internal bool Contains(T x);
    internal void Iterate(FSharpFunc`2<T, Unit> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal State Fold(FSharpFunc`2<T, FSharpFunc`2<State, State>> f, State x);
    internal bool get_IsEmpty();
    internal Tuple`2<Set`2<T, ComparerTag>, Set`2<T, ComparerTag>> Partition(FSharpFunc`2<T, bool> predicate);
    internal Set`2<T, ComparerTag> Filter(FSharpFunc`2<T, bool> predicate);
    internal bool Exists(FSharpFunc`2<T, bool> predicate);
    internal bool ForAll(FSharpFunc`2<T, bool> predicate);
    internal static Set`2<T, ComparerTag> op_Subtraction(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static Set`2<T, ComparerTag> op_Addition(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static Set`2<T, ComparerTag> Intersection(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static Set`2<T, ComparerTag> Union(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static Set`2<T, ComparerTag> Difference(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static bool Equality(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal static int Compare(Set`2<T, ComparerTag> a, Set`2<T, ComparerTag> b);
    internal T get_Choose();
    internal T get_MinimumElement();
    internal T get_MaximumElement();
    internal bool IsSubsetOf(Set`2<T, ComparerTag> y);
    internal bool IsSupersetOf(Set`2<T, ComparerTag> y);
    internal FSharpList`1<T> ToList();
    internal T[] ToArray();
    public virtual bool Equals(object that);
    internal int ComputeHashCode();
    public virtual int GetHashCode();
    internal static Set`2<T, ComparerTag> Singleton(ComparerTag comparer, T x);
    internal static Set`2<T, ComparerTag> Create(ComparerTag comparer, IEnumerable`1<T> l);
    private virtual override int System.IComparable.CompareTo(object s2);
    private virtual override void System.Collections.Generic.ICollection<'T>.Add(T _arg1);
    private virtual override void System.Collections.Generic.ICollection<'T>.Clear();
    private virtual override bool System.Collections.Generic.ICollection<'T>.Remove(T _arg2);
    private virtual override bool System.Collections.Generic.ICollection<'T>.Contains(T x);
    private virtual override void System.Collections.Generic.ICollection<'T>.CopyTo(T[] arr, int i);
    private virtual override bool System.Collections.Generic.ICollection<'T>.get_IsReadOnly();
    private virtual override int System.Collections.Generic.ICollection<'T>.get_Count();
    private virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<'T>.GetEnumerator();
    private virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static Set`2<c, e> refresh(Set`2<c, d> s, SetTree`1<c> t);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[AllowNullLiteralAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.Tagged.SetTree`1 : object {
    internal T k;
    internal T Key { get; }
    public SetTree`1(T k);
    internal T get_Key();
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Collections.Tagged.SetTreeModule : object {
    [LiteralAttribute]
[DebuggerBrowsableAttribute("0")]
internal static int tolerance;
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int countAux(SetTree`1<T> t, int acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> mk(SetTree`1<T> l, T k, SetTree`1<T> r);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> rebalance(SetTree`1<a> t1, a v, SetTree`1<a> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> add(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> balance(IComparer`1<T> comparer, SetTree`1<T> t1, T k, SetTree`1<T> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<SetTree`1<T>, bool, SetTree`1<T>> split(IComparer`1<T> comparer, T pivot, SetTree`1<T> t);
    internal static Tuple`2<T, SetTree`1<T>> spliceOutSuccessor(SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> remove(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool contains(IComparer`1<T> comparer, T k, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<T, Unit> f, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a fold(FSharpFunc`2<T, FSharpFunc`2<a, a>> f, SetTree`1<T> t, a x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<T, bool> f, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<T, bool> f, SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool subset(IComparer`1<a> comparer, SetTree`1<a> a, SetTree`1<a> b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> filterAux(IComparer`1<T> comparer, FSharpFunc`2<T, bool> f, SetTree`1<T> t, SetTree`1<T> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> diffAux(IComparer`1<T> comparer, SetTree`1<T> t, SetTree`1<T> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> union(IComparer`1<T> comparer, SetTree`1<T> t1, SetTree`1<T> t2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<T> intersectionAux(IComparer`1<T> comparer, SetTree`1<T> b, SetTree`1<T> t, SetTree`1<T> acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SetTree`1<a>, SetTree`1<a>> partition1(IComparer`1<a> comparer, FSharpFunc`2<a, bool> f, a k, SetTree`1<a> acc1, SetTree`1<a> acc2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<SetTree`1<T>, SetTree`1<T>> partitionAux(IComparer`1<T> comparer, FSharpFunc`2<T, bool> f, SetTree`1<T> t, SetTree`1<T> acc_0, SetTree`1<T> acc_1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T minimumElementAux(SetTree`1<T> t, T n);
    internal static FSharpOption`1<T> minimumElementOpt(SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T maximumElementAux(SetTree`1<T> t, T n);
    internal static FSharpOption`1<T> maximumElementOpt(SetTree`1<T> t);
    internal static a minimumElement(SetTree`1<a> s);
    internal static a maximumElement(SetTree`1<a> s);
    internal static IEnumerator`1<a> toSeq(SetTree`1<a> s);
    internal static int cont@464(IComparer`1<T> comparer, FSharpList`1<SetTree`1<T>> l1, FSharpList`1<SetTree`1<T>> l2, Unit unitVar0);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compareStacks(IComparer`1<T> comparer, FSharpList`1<SetTree`1<T>> l1, FSharpList`1<SetTree`1<T>> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int compare(IComparer`1<T> comparer, SetTree`1<T> t1, SetTree`1<T> t2);
    internal static FSharpList`1<T> loop@539-9(SetTree`1<T> t', FSharpList`1<T> acc);
    internal static FSharpList`1<T> toList(SetTree`1<T> t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void copyToArray(SetTree`1<a> s, a[] arr, int i);
    internal static a[] toArray(SetTree`1<a> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> mkFromEnumerator(IComparer`1<a> comparer, SetTree`1<a> acc, IEnumerator`1<a> e);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static SetTree`1<a> ofSeq(IComparer`1<a> comparer, IEnumerable`1<a> c);
}
[NoEqualityAttribute]
[NoComparisonAttribute]
[SealedAttribute]
[AllowNullLiteralAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Collections.Tagged.SetTreeNode`1 : SetTree`1<T> {
    internal SetTree`1<T> right;
    internal SetTree`1<T> left;
    internal int h;
    internal SetTree`1<T> Left { get; }
    internal SetTree`1<T> Right { get; }
    internal int Height { get; }
    public SetTreeNode`1(T v, SetTree`1<T> left, SetTree`1<T> right, int h);
    internal SetTree`1<T> get_Left();
    internal SetTree`1<T> get_Right();
    internal int get_Height();
}
[StructuralEqualityAttribute]
[NoComparisonAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal abstract class Internal.Utilities.Collections.ValueStrength`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsStrong { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsWeak { get; }
    [CompilationMappingAttribute("8", "0")]
internal static ValueStrength`1<T> NewStrong(T item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsStrong();
    [CompilationMappingAttribute("8", "1")]
internal static ValueStrength`1<T> NewWeak(WeakReference`1<T> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsWeak();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueStrength`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Collections.Zmap : object {
    internal static Map`3<Key, T, IComparer`1<Key>> empty(IComparer`1<Key> ord);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, T, IComparer`1<Key>> add(Key k, T v, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T find(Key k, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<T> tryFind(Key k, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, T, IComparer`1<Key>> remove(Key k, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool mem(Key k, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<T, FSharpFunc`2<U, Unit>> action, Map`3<T, U, IComparer`1<T>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<Key, T>> first(FSharpFunc`2<Key, FSharpFunc`2<T, bool>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<Key, FSharpFunc`2<T, bool>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<Key, FSharpFunc`2<T, bool>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, U, IComparer`1<Key>> map(FSharpFunc`2<T, U> mapping, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, U, IComparer`1<Key>> mapi(FSharpFunc`2<Key, FSharpFunc`2<T, U>> mapping, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static U fold(FSharpFunc`2<Key, FSharpFunc`2<T, FSharpFunc`2<U, U>>> f, Map`3<Key, T, IComparer`1<Key>> m, U x);
    internal static FSharpList`1<Tuple`2<Key, T>> toList(Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static U foldSection(Key lo, Key hi, FSharpFunc`2<Key, FSharpFunc`2<T, FSharpFunc`2<U, U>>> f, Map`3<Key, T, IComparer`1<Key>> m, U x);
    internal static bool isEmpty(Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<State, Map`3<Key, U, IComparer`1<Key>>> foldMap(FSharpFunc`2<State, FSharpFunc`2<Key, FSharpFunc`2<T, Tuple`2<State, U>>>> f, State z, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<U> choose(FSharpFunc`2<Key, FSharpFunc`2<T, FSharpOption`1<U>>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<U> chooseL(FSharpFunc`2<Key, FSharpFunc`2<T, FSharpOption`1<U>>> f, Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Map`3<Key, T, IComparer`1<Key>> ofList(IComparer`1<Key> ord, FSharpList`1<Tuple`2<Key, T>> xs);
    internal static FSharpList`1<Key> keys(Map`3<Key, T, IComparer`1<Key>> m);
    internal static FSharpList`1<T> values(Map`3<Key, T, IComparer`1<Key>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool memberOf(Map`3<Key, T, IComparer`1<Key>> m, Key k);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Collections.Zset : object {
    internal static Set`2<T, IComparer`1<T>> empty(IComparer`1<T> ord);
    internal static bool isEmpty(Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool contains(T x, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> add(T x, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> addList(FSharpList`1<T> xs, Set`2<T, IComparer`1<T>> a);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> singleton(IComparer`1<T> ord, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> remove(T x, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static State fold(FSharpFunc`2<T, FSharpFunc`2<State, State>> f, Set`2<T, IComparer`1<T>> s, State b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<T, Unit> f, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<T, bool> predicate, Set`2<T, IComparer`1<T>> s);
    internal static int count(Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<T, bool> predicate, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool subset(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool equal(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    internal static FSharpList`1<T> elements(Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> filter(FSharpFunc`2<T, bool> predicate, Set`2<T, IComparer`1<T>> s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> union(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> inter(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Set`2<T, IComparer`1<T>> diff(Set`2<T, IComparer`1<T>> s1, Set`2<T, IComparer`1<T>> s2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool memberOf(Set`2<T, IComparer`1<T>> m, T k);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.EditDistance : object {
    [CompilerGeneratedAttribute]
internal static bool exists@16(string s2, char c, int endAt, int index);
    internal static ValueTuple`2<int, char> nextChar@29(int matchRadius, string s1, string s2, int i, char c);
    internal static ValueTuple`5<int, int, int, int, int> loop@43-7(string s1, string s2, int matchRadius, int i, int j, int mismatches, int c1length, int c2length);
    [CompilerGeneratedAttribute]
internal static bool exists@16-1(string s2, char c, int endAt, int index);
    internal static int loop@57-8(int matchRadius, string s1, string s2, int i, int length);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static double jaro(string s1, string s2);
    internal static double calcL@92(string s1, string s2, int maxLength, int i, double acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static double JaroWinklerDistance(string s1, string s2);
    internal static int calcDamerauLevenshtein(string a, string b);
    internal static int CalculateEditDistance(string a, string b);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.FSharpEnvironment : object {
    [CompilationMappingAttribute("9")]
internal static string FSharpBannerVersion { get; }
    [CompilationMappingAttribute("9")]
internal static string FSharpProductName { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpOption`1<string> FSharpCoreLibRunningVersion { get; }
    internal static string FSharpBinaryMetadataFormatRevision { get; }
    [CompilationMappingAttribute("9")]
internal static bool isRunningOnCoreClr { get; }
    [CompilationMappingAttribute("9")]
internal static String[] toolingCompatibleVersions { get; }
    [CompilationMappingAttribute("9")]
internal static String[] toolPaths { get; }
    internal static string getFSharpCoreLibraryName { get; }
    internal static string fsiLibraryName { get; }
    [CompilationMappingAttribute("9")]
internal static bool isWindows { get; }
    [CompilationMappingAttribute("9")]
internal static string dotnet { get; }
    internal static string get_FSharpBannerVersion();
    internal static string get_FSharpProductName();
    internal static FSharpOption`1<string> get_FSharpCoreLibRunningVersion();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_FSharpBinaryMetadataFormatRevision();
    internal static bool get_isRunningOnCoreClr();
    internal static FSharpOption`1<string> tryCurrentDomain();
    internal static FSharpOption`1<string> BinFolderOfDefaultFSharpCompiler(FSharpOption`1<string> probePoint);
    internal static String[] get_toolingCompatibleVersions();
    internal static String[] get_toolPaths();
    internal static FSharpList`1<string> toolingCompatiblePaths();
    internal static IEnumerable`1<string> searchToolPath(string compilerToolPath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEnumerable`1<string> searchToolPaths(FSharpOption`1<string> path, IEnumerable`1<string> compilerToolPaths);
    internal static FSharpOption`1<Assembly> loadFromLocation@174(FSharpFunc`2<FSharpOption`1<string>, FSharpFunc`2<Exception, FSharpOption`1<Assembly>>> raiseError, string designTimeAssemblyPath);
    internal static IEnumerable`1<string> searchParentDirChain@180(FSharpList`1<string> compilerToolPaths, FSharpOption`1<string> path, string assemblyName);
    internal static FSharpOption`1<Assembly> loadFromParentDirRelativeToRuntimeAssemblyLocation@196(string runTimeAssemblyFileName, FSharpFunc`2<FSharpOption`1<string>, FSharpFunc`2<Exception, FSharpOption`1<Assembly>>> raiseError, FSharpList`1<string> compilerToolPaths, string designTimeAssemblyName);
    internal static FSharpOption`1<Assembly> getTypeProviderAssembly(string runTimeAssemblyFileName, string designTimeAssemblyName, FSharpList`1<string> compilerToolPaths, FSharpFunc`2<FSharpOption`1<string>, FSharpFunc`2<Exception, FSharpOption`1<Assembly>>> raiseError);
    internal static IEnumerable`1<string> getCompilerToolsDesignTimeAssemblyPaths(IEnumerable`1<string> compilerToolPaths);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_getFSharpCoreLibraryName();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static string get_fsiLibraryName();
    internal static string getFSharpCompilerLocationWithDefaultFromType(Type defaultLocation);
    internal static string getFSharpCompilerLocation();
    internal static string getDefaultFSharpCoreLocation();
    internal static string getDefaultFsiLibraryLocation();
    internal static bool get_isWindows();
    internal static string get_dotnet();
    internal static FSharpOption`1<string> getDotnetGlobalHostPath();
    internal static FSharpOption`1<string> probePathForDotnetHost@310(Unit unitVar0);
    internal static FSharpOption`1<string> getDotnetHostPath();
    internal static String[] getDotnetHostDirectories();
    internal static FSharpOption`1<string> getDotnetHostDirectory();
    internal static DirectoryInfo[] getDotnetHostSubDirectories(string path);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.AnyCallerThreadToken : object {
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Array : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a[] mapq(FSharpFunc`2<a, a> f, a[] inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool lengthsEqAndForall2(FSharpFunc`2<a, FSharpFunc`2<b, bool>> p, a[] l1, b[] l2);
    internal static int loop@192-10(IComparer`1<T> eltOrder, T[] ys, T[] xs, int i);
    internal static IComparer`1<T[]> order(IComparer`1<T> eltOrder);
    internal static bool forallFrom@203(FSharpFunc`2<b, bool> p, b[] l, int n);
    internal static bool loop@206-11(FSharpFunc`2<b, bool> p, b[] l, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsOne(FSharpFunc`2<a, bool> p, a[] l);
    internal static bool loop@216-13(Boolean[] arr, int n);
    internal static bool existsTrue(Boolean[] arr);
    internal static int look@222(a[] arr, FSharpFunc`2<a, bool> p, int lo, int hi);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int findFirstIndexWhereTrue(a[] arr, FSharpFunc`2<a, bool> p);
    internal static void revInPlace(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpAsync`1<U[]> mapAsync(FSharpFunc`2<T, FSharpAsync`1<U>> mapping, T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a[] replace(int index, a value, a[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool areEqual(T[] xs, T[] ys);
    internal static T[][] heads(T[] array);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool isSubArray(T[] subArray, T[] wholeArray, int index);
    [CompilerGeneratedAttribute]
internal static bool isSubArray$cont@319(a[] prefix, a[] whole, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool loop@321-15(a[] prefix, a[] whole, int subidx, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool startsWith(a[] prefix, a[] whole);
    [CompilerGeneratedAttribute]
internal static bool isSubArray$cont@319-1(a[] suffix, a[] whole, Unit unitVar);
    [CompilerGeneratedAttribute]
internal static bool loop@321-16(a[] suffix, a[] whole, int subidx, int idx);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool endsWith(a[] suffix, a[] whole);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T[] prepend(T item, T[] array);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Block : object {
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Cancellable : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueOrCancelled`1<T> run(CancellationToken ct, Cancellable`1<T> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Cancellable`1<State> fold(FSharpFunc`2<State, FSharpFunc`2<T, Cancellable`1<State>>> f, State acc, IEnumerable`1<T> seq);
    internal static T runWithoutCancellation(Cancellable`1<T> comp);
    internal static FSharpAsync`1<T> toAsync(Cancellable`1<T> c);
    internal static Cancellable`1<CancellationToken> token();
}
[StructAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class Internal.Utilities.Library.Cancellable`1 : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<CancellationToken, ValueOrCancelled`1<T>> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<CancellationToken, ValueOrCancelled`1<T>> Item { get; }
    [CompilationMappingAttribute("8", "0")]
internal static Cancellable`1<T> NewCancellable(FSharpFunc`2<CancellationToken, ValueOrCancelled`1<T>> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<CancellationToken, ValueOrCancelled`1<T>> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.CancellableAutoOpens : object {
    [CompilationMappingAttribute("9")]
internal static CancellableBuilder cancellable { get; }
    internal static CancellableBuilder get_cancellable();
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.CancellableBuilder : object {
    internal Cancellable`1<T> Delay(FSharpFunc`2<Unit, Cancellable`1<T>> f);
    internal Cancellable`1<U> Bind(Cancellable`1<T> comp, FSharpFunc`2<T, Cancellable`1<U>> k);
    internal Cancellable`1<U> BindReturn(Cancellable`1<T> comp, FSharpFunc`2<T, U> k);
    internal Cancellable`1<T> Combine(Cancellable`1<Unit> comp1, Cancellable`1<T> comp2);
    internal Cancellable`1<T> TryWith(Cancellable`1<T> comp, FSharpFunc`2<Exception, Cancellable`1<T>> handler);
    internal Cancellable`1<T> Using(Resource resource, FSharpFunc`2<Resource, Cancellable`1<T>> comp);
    internal Cancellable`1<T> TryFinally(Cancellable`1<T> comp, FSharpFunc`2<Unit, Unit> compensation);
    internal Cancellable`1<T> Return(T v);
    internal Cancellable`1<T> ReturnFrom(Cancellable`1<T> v);
    internal Cancellable`1<Unit> Zero();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.CompilationThreadToken : object {
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Dictionary : object {
    internal static Dictionary`2<a, b> newWithSize(int size);
    internal static Dictionary`2<Key, Value> ofList(FSharpList`1<Tuple`2<Key, Value>> xs);
}
[ExtensionAttribute]
[ClassAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.DictionaryExtensions : object {
    [ExtensionAttribute]
internal static void BagAdd(Dictionary`2<key, FSharpList`1<value>> dic, key key, value value);
    [ExtensionAttribute]
internal static bool BagExistsValueForKey(Dictionary`2<key, FSharpList`1<value>> dic, key key, FSharpFunc`2<value, bool> f);
}
[CompilationMappingAttribute("3")]
internal interface Internal.Utilities.Library.ExecutionToken {
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Extras : object {
    internal static bool debug { get; }
    internal static bool verbose { get; }
    [CompilationMappingAttribute("9")]
internal static bool progress { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static bool tracking { get; internal set; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_debug();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_verbose();
    internal static bool get_progress();
    internal static void set_progress(bool value);
    internal static bool get_tracking();
    internal static void set_tracking(bool value);
    internal static bool isEnvVarSet(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int GetEnvInteger(string e, int dflt);
    internal static void dispose(IDisposable x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<c, e>, d> mapFoldFst(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, d>>> f, a s, b x, e y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<Tuple`2<e, c>, d> mapFoldSnd(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, d>>> f, a s, e x, b y);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<a, b> pair(a a, b b);
    internal static a p13(a x, b _y, c _z);
    internal static b p23(a _x, b y, c _z);
    internal static c p33(a _x, b _y, c z);
    internal static a p14(a x1, b _x2, c _x3, d _x4);
    internal static b p24(a _x1, b x2, c _x3, d _x4);
    internal static c p34(a _x1, b _x2, c x3, d _x4);
    internal static d p44(a _x1, b _x2, c _x3, d x4);
    internal static a p15(a x1, b _x2, c _x3, d _x4, e _x5);
    internal static b p25(a _x1, b x2, c _x3, d _x4, e _x5);
    internal static c p35(a _x1, b _x2, c x3, d _x4, e _x5);
    internal static d p45(a _x1, b _x2, c _x3, d x4, e _x5);
    internal static e p55(a _x1, b _x2, c _x3, d _x4, e x5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<b, c> map1Of2(FSharpFunc`2<a, b> f, a a1, c a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<c, b> map2Of2(FSharpFunc`2<a, b> f, c a1, a a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<b, c, d> map1Of3(FSharpFunc`2<a, b> f, a a1, c a2, d a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<c, b, d> map2Of3(FSharpFunc`2<a, b> f, c a1, a a2, d a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<c, d, b> map3Of3(FSharpFunc`2<a, b> f, c a1, d a2, a a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<c, d, b, e> map3Of4(FSharpFunc`2<a, b> f, c a1, d a2, a a3, e a4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<c, d, e, b> map4Of4(FSharpFunc`2<a, b> f, c a1, d a2, e a3, a a4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`5<c, d, e, f, b> map5Of5(FSharpFunc`2<a, b> f, c a1, d a2, e a3, f a4, a a5);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`6<c, d, e, f, g, b> map6Of6(FSharpFunc`2<a, b> f, c a1, d a2, e a3, f a4, g a5, a a6);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static e foldPair(FSharpFunc`2<a, FSharpFunc`2<b, c>> f1, FSharpFunc`2<c, FSharpFunc`2<d, e>> f2, a acc, b a1, d a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c fold1Of2(FSharpFunc`2<a, FSharpFunc`2<b, c>> f1, a acc, b a1, d _a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static g foldTriple(FSharpFunc`2<a, FSharpFunc`2<b, c>> f1, FSharpFunc`2<c, FSharpFunc`2<d, e>> f2, FSharpFunc`2<e, FSharpFunc`2<f, g>> f3, a acc, b a1, d a2, f a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static i foldQuadruple(FSharpFunc`2<a, FSharpFunc`2<b, c>> f1, FSharpFunc`2<c, FSharpFunc`2<d, e>> f2, FSharpFunc`2<e, FSharpFunc`2<f, g>> f3, FSharpFunc`2<g, FSharpFunc`2<h, i>> f4, a acc, b a1, d a2, f a3, h a4);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<b, d> mapPair(FSharpFunc`2<a, b> f1, FSharpFunc`2<c, d> f2, a a1, c a2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`3<b, d, f> mapTriple(FSharpFunc`2<a, b> f1, FSharpFunc`2<c, d> f2, FSharpFunc`2<e, f> f3, a a1, c a2, e a3);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`4<b, d, f, h> mapQuadruple(FSharpFunc`2<a, b> f1, FSharpFunc`2<c, d> f2, FSharpFunc`2<e, f> f3, FSharpFunc`2<g, h> f4, a a1, c a2, e a3, g a4);
    internal static string buildString(FSharpFunc`2<StringBuilder, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void writeViaBuffer(TextWriter os, FSharpFunc`2<StringBuilder, Unit> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void StringBuilder.AppendString(StringBuilder this, string value);
    internal static void trace@320(Graph`2<Data, Id> g, FSharpFunc`2<FSharpList`1<Data>, Unit> f, FSharpList`1<Data> path, GraphNode`2<Data, Id> node);
    internal static T nullableSlotEmpty();
    internal static a nullableSlotFull(a x);
    internal static cache`1<a> newCache();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a cached(cache`1<a> cache, FSharpFunc`2<Unit, a> resF);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T cacheOptByref(FSharpOption`1& cache, FSharpFunc`2<Unit, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a cacheOptRef(FSharpRef`1<FSharpOption`1<a>> cache, FSharpFunc`2<Unit, a> f);
    internal static FSharpValueOption`1<a> tryGetCacheValue(cache`1<a> cache);
    internal static T vsnd(ValueTuple`2<T, T> _arg1);
}
[StructAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.InlineDelayInit`1 : ValueType {
    internal T store;
    internal Func`1<T> func;
    internal T Value { get; }
    public InlineDelayInit`1(FSharpFunc`2<Unit, T> f);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal T get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InlineDelayInit`1<T> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.IPartialEqualityComparer : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IPartialEqualityComparer`1<a> On(FSharpFunc`2<a, b> f, IPartialEqualityComparer`1<b> c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> partialDistinctBy(IPartialEqualityComparer`1<T> per, FSharpList`1<T> seq);
}
[CompilationMappingAttribute("3")]
internal interface Internal.Utilities.Library.IPartialEqualityComparer`1 {
    public abstract virtual bool InEqualityRelation(T );
}
[DefaultMemberAttribute("Item")]
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.LayeredMultiMap`2 : object {
    internal FSharpMap`2<Key, FSharpList`1<Value>> contents;
    internal FSharpList`1<Value> Item { get; }
    internal FSharpList`1<Value> Values { get; }
    internal static LayeredMultiMap`2<Key, Value> Empty { get; }
    public LayeredMultiMap`2(FSharpMap`2<Key, FSharpList`1<Value>> contents);
    internal LayeredMultiMap`2<Key, Value> Add(Key k, Value v);
    internal FSharpList`1<Value> get_Item(Key k);
    internal LayeredMultiMap`2<Key, Value> AddMany(KeyValuePair`2[] kvs);
    internal FSharpOption`1<FSharpList`1<Value>> TryFind(Key k);
    internal Tuple`2<bool, FSharpList`1<Value>> TryGetValue(Key k);
    internal FSharpList`1<Value> get_Values();
    internal static LayeredMultiMap`2<Key, Value> get_Empty();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Lazy : object {
    internal static T force(Lazy`1<T> x);
}
[SealedAttribute]
[DefaultAugmentationAttribute("False")]
[NoEqualityAttribute]
[NoComparisonAttribute]
[CompilationMappingAttribute("34")]
internal class Internal.Utilities.Library.LazyWithContext`2 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal T value@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal object funcOrException@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<Exception, Exception> findOriginalException@;
    [CompilationMappingAttribute("4", "0")]
internal T value { get; internal set; }
    [CompilationMappingAttribute("4", "1")]
internal object funcOrException { get; internal set; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpFunc`2<Exception, Exception> findOriginalException { get; }
    internal bool IsDelayed { get; }
    internal bool IsForced { get; }
    [DynamicDependencyAttribute("1632", "Internal.Utilities.Library.LazyWithContext`2")]
internal LazyWithContext`2(T value, object funcOrException, FSharpFunc`2<Exception, Exception> findOriginalException);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal T get_value();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object get_funcOrException();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Exception, Exception> get_findOriginalException();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void set_value(T value);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal void set_funcOrException(object value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal static LazyWithContext`2<T, ctxt> Create(FSharpFunc`2<ctxt, T> f, FSharpFunc`2<Exception, Exception> findOriginalException);
    internal static LazyWithContext`2<T, ctxt> NotLazy(T x);
    internal bool get_IsDelayed();
    internal bool get_IsForced();
    internal T Force(ctxt ctxt);
    internal T UnsynchronizedForce(ctxt ctxt);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.LazyWithContextFailure : object {
    internal Exception exn;
    internal static LazyWithContextFailure undefined;
    internal static int init@1102;
    internal Exception Exception { get; }
    internal static LazyWithContextFailure Undefined { get; }
    public LazyWithContextFailure(Exception exn);
    private static LazyWithContextFailure();
    internal Exception get_Exception();
    internal static LazyWithContextFailure get_Undefined();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.List : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> sortWithOrder(IComparer`1<T> c, FSharpList`1<T> elements);
    internal static Tuple`2<FSharpList`1<b>, FSharpList`1<b>> split_after_acc@365(int n, FSharpList`1<b> l1, FSharpList`1<b> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<a>, FSharpList`1<a>> splitAfter(int n, FSharpList`1<a> l);
    internal static bool loop@374-17(FSharpFunc`2<int, FSharpFunc`2<a, bool>> f, int i, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsi(FSharpFunc`2<int, FSharpFunc`2<a, bool>> f, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool lengthsEqAndForall2(FSharpFunc`2<a, FSharpFunc`2<b, bool>> p, FSharpList`1<a> l1, FSharpList`1<b> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<a, int>> findi(int n, FSharpFunc`2<a, bool> f, FSharpList`1<a> l);
    internal static Tuple`2<FSharpList`1<b>, FSharpList`1<c>> ch@390(FSharpFunc`2<a, FSharpChoice`2<b, c>> select, FSharpList`1<b> acc1, FSharpList`1<c> acc2, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<b>, FSharpList`1<c>> splitChoose(FSharpFunc`2<a, FSharpChoice`2<b, c>> select, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool checkq(FSharpList`1<a> l1, FSharpList`1<a> l2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> mapq(FSharpFunc`2<T, T> f, FSharpList`1<T> inp);
    internal static Tuple`2<FSharpList`1<b>, b> loop@432-18(FSharpList`1<b> acc, FSharpList`1<b> l);
    internal static Tuple`2<FSharpList`1<a>, a> frontAndBack(FSharpList`1<a> l);
    internal static FSharpOption`1<Tuple`2<FSharpList`1<a>, a>> tryFrontAndBack(FSharpList`1<a> l);
    internal static FSharpOption`1<Tuple`2<a, FSharpList`1<a>>> loop@448-19(FSharpFunc`2<a, bool> f, FSharpList`1<a> acc, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Tuple`2<a, FSharpList`1<a>>> tryRemove(FSharpFunc`2<a, bool> f, FSharpList`1<a> inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<Tuple`4<a, b, c, d>> zip4(FSharpList`1<a> l1, FSharpList`1<b> l2, FSharpList`1<c> l3, FSharpList`1<d> l4);
    internal static Tuple`4<FSharpList`1<a>, FSharpList`1<b>, FSharpList`1<c>, FSharpList`1<d>> unzip4(FSharpList`1<Tuple`4<a, b, c, d>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter3(FSharpFunc`2<a, FSharpFunc`2<b, FSharpFunc`2<c, Unit>>> f, FSharpList`1<a> l1, FSharpList`1<b> l2, FSharpList`1<c> l3);
    internal static Tuple`2<FSharpList`1<a>, FSharpList`1<a>> loop@473-20(FSharpFunc`2<a, bool> p, FSharpList`1<a> acc, FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<a>, FSharpList`1<a>> takeUntil(FSharpFunc`2<a, bool> p, FSharpList`1<a> l);
    internal static int loop@483-21(IComparer`1<T> eltOrder, FSharpList`1<T> xs, FSharpList`1<T> ys);
    internal static IComparer`1<FSharpList`1<T>> order(IComparer`1<T> eltOrder);
    internal static a indexNotFound();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b assoc(a x, FSharpList`1<Tuple`2<a, b>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool memAssoc(a x, FSharpList`1<Tuple`2<a, b>> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool memq(a x, FSharpList`1<a> l);
    internal static FSharpList`1<a> mn@514(int n, FSharpFunc`2<a, a> f, int i, FSharpList`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> mapNth(int n, FSharpFunc`2<a, a> f, FSharpList`1<a> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int count(FSharpFunc`2<a, bool> pred, FSharpList`1<a> xs);
    internal static Tuple`2<a, FSharpList`1<a>> headAndTail(FSharpList`1<a> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> mapHeadTail(FSharpFunc`2<a, b> fhead, FSharpFunc`2<a, b> ftail, FSharpList`1<a> _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<c>, a> collectFold(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<FSharpList`1<c>, a>>> f, a s, FSharpList`1<b> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<c> collect2(FSharpFunc`2<a, FSharpFunc`2<b, FSharpList`1<c>>> f, FSharpList`1<a> xs, FSharpList`1<b> ys);
    internal static a[][] toArraySquared(FSharpList`1<FSharpList`1<a>> xss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iterSquared(FSharpFunc`2<a, Unit> f, FSharpList`1<FSharpList`1<a>> xss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> collectSquared(FSharpFunc`2<a, FSharpList`1<b>> f, FSharpList`1<FSharpList`1<a>> xss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<b>> mapSquared(FSharpFunc`2<a, b> f, FSharpList`1<FSharpList`1<a>> xss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<c>>, a> mapFoldSquared(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, a>>> f, a z, FSharpList`1<FSharpList`1<b>> xss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forallSquared(FSharpFunc`2<a, bool> f, FSharpList`1<FSharpList`1<a>> xss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<FSharpList`1<b>> mapiSquared(FSharpFunc`2<int, FSharpFunc`2<int, FSharpFunc`2<a, b>>> f, FSharpList`1<FSharpList`1<a>> xss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsSquared(FSharpFunc`2<a, bool> f, FSharpList`1<FSharpList`1<a>> xss);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpList`1<FSharpList`1<c>>, a> mapiFoldSquared(FSharpFunc`2<a, FSharpFunc`2<Tuple`3<int, int, b>, Tuple`2<c, a>>> f, a z, FSharpList`1<FSharpList`1<b>> xss);
    internal static FSharpList`1<T> duplicates(FSharpList`1<T> xs);
    internal static bool allEqual(FSharpList`1<T> xs);
    internal static bool isSingleton(FSharpList`1<T> xs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> prependIfSome(FSharpOption`1<a> x, FSharpList`1<a> l);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.Lock`1 : object {
    internal object lockObj;
    internal a AcquireLock(FSharpFunc`2<LockTokenType, a> f);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.LockAutoOpens : object {
    internal static AnyCallerThreadToken AnyCallerThread { get; }
    internal static void RequireCompilationThread(CompilationThreadToken _ctok);
    internal static void DoesNotRequireCompilerThreadTokenAndCouldPossiblyBeMadeConcurrent(CompilationThreadToken _ctok);
    internal static CompilationThreadToken AssumeCompilationThreadWithoutEvidence();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static AnyCallerThreadToken get_AnyCallerThread();
    internal static a AssumeLockWithoutEvidence();
}
[CompilationMappingAttribute("3")]
internal interface Internal.Utilities.Library.LockToken {
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Map : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> tryFindMulti(a k, FSharpMap`2<a, FSharpList`1<b>> map);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.MapAutoOpens : object {
    internal static FSharpMap`2<Key, Value> Map`2.get_Empty.Static();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<Key, Value> Map`2.AddMany(FSharpMap`2<Key, Value> x, KeyValuePair`2[] kvs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<Key, Value> Map`2.AddOrModify(FSharpMap`2<Key, Value> x, Key key, FSharpFunc`2<FSharpOption`1<Value>, Value> f);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.MemoizationTable`2 : object {
    internal FSharpFunc`2<T, U> compute;
    internal FSharpOption`1<FSharpFunc`2<T, bool>> canMemoize;
    internal ConcurrentDictionary`2<T, Lazy`1<U>> table;
    internal Func`2<T, Lazy`1<U>> computeFunc;
    public MemoizationTable`2(FSharpFunc`2<T, U> compute, IEqualityComparer`1<T> keyComparer, FSharpOption`1<FSharpFunc`2<T, bool>> canMemoize);
    internal U Apply(T x);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.MultiMap : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsInRange(FSharpFunc`2<a, bool> f, FSharpMap`2<b, FSharpList`1<a>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<b> find(a v, FSharpMap`2<a, FSharpList`1<b>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<a, FSharpList`1<b>> add(a v, b x, FSharpMap`2<a, FSharpList`1<b>> m);
    internal static FSharpList`1<b> range(FSharpMap`2<a, FSharpList`1<b>> m);
    internal static FSharpMap`2<a, FSharpList`1<b>> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<b, FSharpList`1<a>> initBy(FSharpFunc`2<a, b> f, IEnumerable`1<a> xs);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.NameMap : object {
    internal static FSharpMap`2<a, b> empty();
    internal static FSharpList`1<b> range(FSharpMap`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldBack(FSharpFunc`2<string, FSharpFunc`2<T, FSharpFunc`2<a, a>>> f, FSharpMap`2<string, T> m, a z);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, FSharpMap`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<a, FSharpFunc`2<b, bool>> f, FSharpMap`2<a, b> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<b, a> ofKeyedList(FSharpFunc`2<a, b> f, FSharpList`1<a> l);
    internal static FSharpMap`2<string, T> ofList(FSharpList`1<Tuple`2<string, T>> l);
    internal static FSharpMap`2<string, T> ofSeq(IEnumerable`1<Tuple`2<string, T>> l);
    internal static FSharpList`1<Tuple`2<string, T>> toList(FSharpMap`2<string, T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, T> layer(FSharpMap`2<string, T> m1, FSharpMap`2<string, T> m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<c, FSharpList`1<a>> layerAdditive(FSharpFunc`2<FSharpList`1<a>, FSharpFunc`2<b, FSharpList`1<a>>> addf, FSharpMap`2<c, b> m1, FSharpMap`2<c, FSharpList`1<a>> m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, b> union(FSharpFunc`2<IEnumerable`1<a>, b> unionf, IEnumerable`1<FSharpMap`2<string, a>> ms);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static c subfold2(FSharpFunc`2<a, FSharpFunc`2<b, c>> errf, FSharpFunc`2<a, FSharpFunc`2<d, FSharpFunc`2<b, FSharpFunc`2<c, c>>>> f, FSharpMap`2<a, d> m1, FSharpMap`2<a, b> m2, c acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool suball2(FSharpFunc`2<a, FSharpFunc`2<b, bool>> errf, FSharpFunc`2<c, FSharpFunc`2<b, bool>> p, FSharpMap`2<a, c> m1, FSharpMap`2<a, b> m2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpMap`2<string, b>, a> mapFold(FSharpFunc`2<a, FSharpFunc`2<string, FSharpFunc`2<T, Tuple`2<b, a>>>> f, a s, FSharpMap`2<string, T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldBackRange(FSharpFunc`2<T, FSharpFunc`2<a, a>> f, FSharpMap`2<string, T> l, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, T> filterRange(FSharpFunc`2<T, bool> f, FSharpMap`2<string, T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, a> mapFilter(FSharpFunc`2<T, FSharpOption`1<a>> f, FSharpMap`2<string, T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, a> map(FSharpFunc`2<T, a> f, FSharpMap`2<string, T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<T, Unit> f, FSharpMap`2<string, T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpMap`2<string, T>, FSharpMap`2<string, T>> partition(FSharpFunc`2<T, bool> f, FSharpMap`2<string, T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool mem(string v, FSharpMap`2<string, T> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T find(string v, FSharpMap`2<string, T> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<T> tryFind(string v, FSharpMap`2<string, T> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, T> add(string v, T x, FSharpMap`2<string, T> m);
    internal static bool isEmpty(FSharpMap`2<string, T> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsInRange(FSharpFunc`2<a, bool> p, FSharpMap`2<b, a> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<a> tryFindInRange(FSharpFunc`2<a, bool> p, FSharpMap`2<b, a> m);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.NameMultiMap : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool existsInRange(FSharpFunc`2<T, bool> f, FSharpMap`2<string, FSharpList`1<T>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<T> find(string v, FSharpMap`2<string, FSharpList`1<T>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, FSharpList`1<T>> add(string v, T x, FSharpMap`2<string, FSharpList`1<T>> m);
    internal static FSharpList`1<T> range(FSharpMap`2<string, FSharpList`1<T>> m);
    internal static FSharpList`1<T> rangeReversingEachBucket(FSharpMap`2<string, FSharpList`1<T>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpList`1<a> chooseRange(FSharpFunc`2<T, FSharpOption`1<a>> f, FSharpMap`2<string, FSharpList`1<T>> m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, FSharpList`1<a>> map(FSharpFunc`2<T, a> f, FSharpMap`2<string, FSharpList`1<T>> m);
    internal static FSharpMap`2<string, FSharpList`1<T>> empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpMap`2<string, FSharpList`1<T>> initBy(FSharpFunc`2<T, string> f, IEnumerable`1<T> xs);
    internal static FSharpMap`2<string, FSharpList`1<T>> ofList(FSharpList`1<Tuple`2<string, T>> xs);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Option : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<FSharpOption`1<c>, a> mapFold(FSharpFunc`2<a, FSharpFunc`2<b, Tuple`2<c, a>>> f, a s, FSharpOption`1<b> opt);
    internal static FSharpOption`1<T> attempt(FSharpFunc`2<Unit, T> f);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Order : object {
    internal static IComparer`1<T> orderBy(FSharpFunc`2<T, U> p);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IComparer`1<T> orderOn(FSharpFunc`2<T, U> p, IComparer`1<U> pxOrder);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int toFunction(IComparer`1<U> pxOrder, U x, U y);
}
[AutoOpenAttribute]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.PervasiveAutoOpens : object {
    internal static int LOH_SIZE_THRESHOLD_BYTES { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpFunc`2<string, Unit> reportTime { get; }
    [CompilationMappingAttribute("9")]
internal static FSharpRef`1<IDisposable> tPrev@88 { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int op_GreaterGreaterGreaterAmp(int x, int n);
    internal static Lazy`1<a> notlazy(a v);
    internal static bool isNil(FSharpList`1<a> l);
    internal static bool isNilOrSingleton(FSharpList`1<a> l);
    internal static bool isSingleton(FSharpList`1<a> l);
    internal static bool isNotNull(T x);
    internal static T |NonNullQuick|(T x);
    internal static T nonNull(T x);
    internal static FSharpChoice`2<Unit, T> |Null|NonNull|(T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T nullArgCheck(string paramName, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool op_EqualsEqualsEquals(a x, a y);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_LOH_SIZE_THRESHOLD_BYTES();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool String.StartsWithOrdinal(string x, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool String.EndsWithOrdinal(string x, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool String.EndsWithOrdinalIgnoreCase(string x, string value);
    internal static a getHole(FSharpRef`1<FSharpOption`1<a>> r);
    internal static FSharpFunc`2<string, Unit> get_reportTime();
    internal static FSharpRef`1<IDisposable> get_tPrev@88();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static d foldOn(FSharpFunc`2<a, b> p, FSharpFunc`2<c, FSharpFunc`2<b, d>> f, c z, a x);
    internal static a notFound();
    internal static T Async.RunImmediate.Static(FSharpAsync`1<T> computation, FSharpOption`1<CancellationToken> cancellationToken);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.ResizeArray : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a[][] chunkBySize(int chunkSize, FSharpFunc`2<t, a> f, List`1<t> items);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a[][] mapToSmallArrayChunks(FSharpFunc`2<t, a> f, List`1<t> inp);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.ResultOrException : object {
    internal static ResultOrException`1<a> success(a a);
    internal static ResultOrException`1<a> raze(Exception b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<b> op_BarQmarkGreater(ResultOrException`1<a> res, FSharpFunc`2<a, b> f);
    internal static a ForceRaise(ResultOrException`1<a> res);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ResultOrException`1<a> otherwise(FSharpFunc`2<Unit, ResultOrException`1<a>> f, ResultOrException`1<a> x);
}
[StructAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class Internal.Utilities.Library.ResultOrException`1 : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TResult _result;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Exception _exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsResult { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsException { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TResult result { get; }
    [CompilationMappingAttribute("4", "1", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Exception exception { get; }
    [CompilationMappingAttribute("8", "0")]
internal static ResultOrException`1<TResult> NewResult(TResult _result);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsResult();
    [CompilationMappingAttribute("8", "1")]
internal static ResultOrException`1<TResult> NewException(Exception _exception);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsException();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TResult get_result();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal Exception get_exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ResultOrException`1<TResult> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Span : object {
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<T, bool> predicate, Span`1<T> span);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.StampedDictionary`2 : object {
    internal ConcurrentDictionary`2<T, Lazy`1<Tuple`2<int, U>>> table;
    internal int count;
    public StampedDictionary`2(IEqualityComparer`1<T> keyComparer);
    internal void Add(T key, U value);
    internal void UpdateIfExists(T key, FSharpFunc`2<U, FSharpOption`1<U>> valueReplaceFunc);
    internal IEnumerable`1<Tuple`2<T, Tuple`2<int, U>>> GetAll();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.String : object {
    [CompilationMappingAttribute("9")]
internal static IComparer`1<string> order { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string make(int n, char c);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static char get(string str, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string sub(string s, int start, int len);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool contains(string s, char c);
    internal static IComparer`1<string> get_order();
    internal static string lowercase(string s);
    internal static string uppercase(string s);
    internal static bool isUpperCaseCharacter@674(char c);
    internal static bool isLeadingIdentifierCharacterUpperCase(string s);
    internal static string capitalize(string s);
    internal static string uncapitalize(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string dropPrefix(string s, string t);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string dropSuffix(string s, string t);
    internal static Char[] toCharArray(string str);
    internal static string lowerCaseFirstChar(string str);
    internal static Tuple`2<string, FSharpOption`1<int>> extractTrailingIndex(string str);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static String[] split(StringSplitOptions options, String[] separator, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |StartsWith|_|(string pattern, string value);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<Unit> |Contains|_|(string pattern, string value);
    internal static String[] getLines(string str);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.Tables : object {
    internal static FSharpFunc`2<a, b> memoize(FSharpFunc`2<a, b> f);
}
[CompilationMappingAttribute("5")]
internal class Internal.Utilities.Library.UndefinedException : Exception {
    protected UndefinedException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Library.UniqueStampGenerator`1 : object {
    internal ConcurrentDictionary`2<T, Lazy`1<int>> encodeTable;
    internal int nItems;
    internal Func`2<T, Lazy`1<int>> computeFunc;
    internal ICollection`1<T> Table { get; }
    internal int Encode(T str);
    internal ICollection`1<T> get_Table();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Library.ValueOptionInternal : object {
    internal static FSharpValueOption`1<a> ofOption(FSharpOption`1<a> x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpValueOption`1<b> bind(FSharpFunc`2<a, FSharpValueOption`1<b>> f, FSharpValueOption`1<a> x);
}
[RequireQualifiedAccessAttribute]
[StructAttribute]
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class Internal.Utilities.Library.ValueOrCancelled`1 : ValueType {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TResult _result;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal OperationCanceledException _exception;
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int _tag;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsValue { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal bool IsCancelled { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TResult result { get; }
    [CompilationMappingAttribute("4", "1", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal OperationCanceledException exception { get; }
    [CompilationMappingAttribute("8", "0")]
internal static ValueOrCancelled`1<TResult> NewValue(TResult _result);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsValue();
    [CompilationMappingAttribute("8", "1")]
internal static ValueOrCancelled`1<TResult> NewCancelled(OperationCanceledException _exception);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal bool get_IsCancelled();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal TResult get_result();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal OperationCanceledException get_exception();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueOrCancelled`1<TResult> obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{__DebugDisplay(),nq}")]
[CompilationMappingAttribute("33")]
internal class Internal.Utilities.PathMap : object {
    [DebuggerBrowsableAttribute("0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMap`2<string, string> item;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
[DebuggerBrowsableAttribute("0")]
internal int Tag { get; }
    [CompilationMappingAttribute("4", "0", "0")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMap`2<string, string> Item { get; }
    [DynamicDependencyAttribute("1632", "Internal.Utilities.PathMap")]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal PathMap(FSharpMap`2<string, string> item);
    [CompilationMappingAttribute("8", "0")]
internal static PathMap NewPathMap(FSharpMap`2<string, string> item);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpMap`2<string, string> get_Item();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Tag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal object __DebugDisplay();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(PathMap obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(PathMap obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[RequireQualifiedAccessAttribute]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.PathMapModule : object {
    [CompilationMappingAttribute("9")]
internal static string dirSepStr { get; }
    [CompilationMappingAttribute("9")]
internal static char copyOfStruct@16 { get; internal set; }
    [CompilationMappingAttribute("9")]
internal static PathMap empty { get; }
    internal static string get_dirSepStr();
    internal static char get_copyOfStruct@16();
    internal static void set_copyOfStruct@16(char value);
    internal static PathMap get_empty();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static PathMap addMapping(string src, string dst, PathMap _arg1);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string apply(PathMap _arg1, string filePath);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static string applyDir(PathMap pathMap, string dirName);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Rational : object {
    [CompilationMappingAttribute("9")]
internal static Rational ZeroRational { get; }
    [CompilationMappingAttribute("9")]
internal static Rational OneRational { get; }
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static BigInteger gcd(BigInteger a, BigInteger b);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational mkRational(BigInteger p, BigInteger q);
    internal static Rational intToRational(int p);
    internal static Rational get_ZeroRational();
    internal static Rational get_OneRational();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational AddRational(Rational m, Rational n);
    internal static Rational NegRational(Rational m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational MulRational(Rational m, Rational n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational DivRational(Rational m, Rational n);
    internal static Rational AbsRational(Rational m);
    internal static string RationalToString(Rational m);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Rational GcdRational(Rational m, Rational n);
    internal static int GetNumerator(Rational p);
    internal static int GetDenominator(Rational p);
    internal static int SignRational(Rational p);
}
[CompilationRepresentationAttribute("4")]
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.ResizeArrayModule : object {
    internal static int length(List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T get(List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void set(List`1<T> arr, int n, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> create(int n, T x);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> init(int n, FSharpFunc`2<int, T> f);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void blit(List`1<T> arr1, int start1, List`1<T> arr2, int start2, int len);
    internal static List`1<T> concat(FSharpList`1<List`1<T>> arrs);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> append(List`1<T> arr1, List`1<T> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> sub(List`1<T> arr, int start, int len);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void fill(List`1<T> arr, int start, int len, T x);
    internal static List`1<T> copy(List`1<T> arr);
    internal static FSharpList`1<T> toList(List`1<T> arr);
    internal static void add@91(List`1<T> res, FSharpList`1<T> _arg1);
    internal static List`1<T> ofList(FSharpList`1<T> l);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter(FSharpFunc`2<T, Unit> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<U> map(FSharpFunc`2<T, U> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<U> mapi(FSharpFunc`2<int, FSharpFunc`2<T, U>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iteri(FSharpFunc`2<int, FSharpFunc`2<T, Unit>> f, List`1<T> arr);
    internal static bool loop@132(FSharpFunc`2<T, bool> f, List`1<T> arr, int len, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static bool loop@137-1(FSharpFunc`2<T, bool> f, List`1<T> arr, int len, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static a indexNotFound();
    internal static T loop@144-2(FSharpFunc`2<T, bool> f, List`1<T> arr, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T find(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static FSharpOption`1<U> loop@152-3(FSharpFunc`2<T, FSharpOption`1<U>> f, List`1<T> arr, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<U> tryPick(FSharpFunc`2<T, FSharpOption`1<U>> f, List`1<T> arr);
    internal static FSharpOption`1<T> loop@163-4(FSharpFunc`2<T, bool> f, List`1<T> arr, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<T> tryFind(FSharpFunc`2<T, bool> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iter2(FSharpFunc`2<T, FSharpFunc`2<U, Unit>> f, List`1<T> arr1, List`1<U> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<c> map2(FSharpFunc`2<T, FSharpFunc`2<U, c>> f, List`1<T> arr1, List`1<U> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<U> choose(FSharpFunc`2<T, FSharpOption`1<U>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> filter(FSharpFunc`2<T, bool> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Tuple`2<List`1<T>, List`1<T>> partition(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static List`1<T> rev(List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static U foldBack(FSharpFunc`2<T, FSharpFunc`2<U, U>> f, List`1<T> arr, U acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T fold(FSharpFunc`2<T, FSharpFunc`2<U, T>> f, T acc, List`1<U> arr);
    internal static T[] toArray(List`1<T> arr);
    internal static List`1<T> ofArray(T[] arr);
    internal static IEnumerable`1<T> toSeq(List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sort(FSharpFunc`2<T, FSharpFunc`2<T, int>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void sortBy(FSharpFunc`2<T, Key> f, List`1<T> arr);
    internal static bool loop@269-5(FSharpFunc`2<T, FSharpFunc`2<U, bool>> f, List`1<T> arr1, List`1<U> arr2, int len1, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool exists2(FSharpFunc`2<T, FSharpFunc`2<U, bool>> f, List`1<T> arr1, List`1<U> arr2);
    internal static int go@275(FSharpFunc`2<T, bool> f, List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int findIndex(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static int go@283-1(FSharpFunc`2<int, FSharpFunc`2<T, bool>> f, List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static int findIndexi(FSharpFunc`2<int, FSharpFunc`2<T, bool>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static a foldSub(FSharpFunc`2<a, FSharpFunc`2<b, a>> f, a acc, List`1<b> arr, int start, int fin);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static b foldBackSub(FSharpFunc`2<a, FSharpFunc`2<b, b>> f, List`1<a> arr, int start, int fin, b acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T reduce(FSharpFunc`2<T, FSharpFunc`2<T, T>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static T reduceBack(FSharpFunc`2<T, FSharpFunc`2<T, T>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static state fold2(FSharpFunc`2<state, FSharpFunc`2<b1, FSharpFunc`2<b2, state>>> f, state acc, List`1<b1> arr1, List`1<b2> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static U foldBack2(FSharpFunc`2<a1, FSharpFunc`2<a2, FSharpFunc`2<U, U>>> f, List`1<a1> arr1, List`1<a2> arr2, U acc);
    internal static bool loop@354-6(FSharpFunc`2<T, FSharpFunc`2<U, bool>> f, List`1<T> arr1, List`1<U> arr2, int len1, int i);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static bool forall2(FSharpFunc`2<T, FSharpFunc`2<U, bool>> f, List`1<T> arr1, List`1<U> arr2);
    internal static bool isEmpty(List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static void iteri2(FSharpFunc`2<int, FSharpFunc`2<T, FSharpFunc`2<U, Unit>>> f, List`1<T> arr1, List`1<U> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<c> mapi2(FSharpFunc`2<int, FSharpFunc`2<T, FSharpFunc`2<U, c>>> f, List`1<T> arr1, List`1<U> arr2);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<a> scanBackSub(FSharpFunc`2<T, FSharpFunc`2<a, a>> f, List`1<T> arr, int start, int fin, a acc);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<a> scanSub(FSharpFunc`2<a, FSharpFunc`2<T, a>> f, a acc, List`1<T> arr, int start, int fin);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<U> scan(FSharpFunc`2<U, FSharpFunc`2<T, U>> f, U acc, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<c> scanBack(FSharpFunc`2<T, FSharpFunc`2<c, c>> f, List`1<T> arr, c acc);
    internal static List`1<T> singleton(T x);
    internal static FSharpOption`1<int> go@416-2(FSharpFunc`2<T, bool> f, List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> tryFindIndex(FSharpFunc`2<T, bool> f, List`1<T> arr);
    internal static FSharpOption`1<int> go@424-3(FSharpFunc`2<int, FSharpFunc`2<T, bool>> f, List`1<T> arr, int n);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static FSharpOption`1<int> tryFindIndexi(FSharpFunc`2<int, FSharpFunc`2<T, bool>> f, List`1<T> arr);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<Tuple`2<T, U>> zip(List`1<T> arr1, List`1<U> arr2);
    internal static Tuple`2<List`1<T>, List`1<U>> unzip(List`1<Tuple`2<T, U>> arr);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.RidHelpers : object {
    [CompilationMappingAttribute("9")]
internal static Tuple`3<String[], string, string> patternInput@11 { get; }
    [CompilationMappingAttribute("9")]
internal static Architecture processArchitecture@12 { get; }
    [CompilationMappingAttribute("9")]
internal static string baseRid@14 { get; }
    [CompilationMappingAttribute("9")]
internal static string platformRid@22 { get; }
    [CompilationMappingAttribute("9")]
internal static String[] probingRids { get; }
    [CompilationMappingAttribute("9")]
internal static string platformRid { get; }
    [CompilationMappingAttribute("9")]
internal static string baseRid { get; }
    internal static Tuple`3<String[], string, string> get_patternInput@11();
    internal static Architecture get_processArchitecture@12();
    internal static string get_baseRid@14();
    internal static string get_platformRid@22();
    internal static String[] get_probingRids();
    internal static string get_platformRid();
    internal static string get_baseRid();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Text.Lexing.GenericImplFragments : object {
    internal static void startInterpret(LexBuffer`1<char> lexBuffer);
    internal static a afterRefill(UInt16[][] trans, int sentinel, LexBuffer`1<char> lexBuffer, FSharpFunc`2<LexBuffer`1<char>, FSharpFunc`2<int, a>> scanUntilSentinel, FSharpFunc`2<Unit, a> endOfScan, int state, int eofPos);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Lexing.LexBuffer`1 : object {
    internal FSharpOption`1<bool> strictIndentation;
    internal bool reportLibraryOnlyFeatures;
    internal LanguageVersion langVersion;
    internal FSharpFunc`2<LexBuffer`1<Char>, Unit> filler;
    internal Dictionary`2<string, object> context;
    internal Char[] buffer;
    internal int bufferMaxScanLength;
    internal int bufferScanStart;
    internal int bufferScanLength;
    internal int lexemeLength;
    internal int bufferAcceptAction;
    internal bool eof;
    internal Position startPos;
    internal Position endPos;
    internal Position StartPos { get; internal set; }
    internal Position EndPos { get; internal set; }
    internal ReadOnlySpan`1<Char> LexemeView { get; }
    internal IDictionary`2<string, object> BufferLocalStore { get; }
    internal int LexemeLength { get; internal set; }
    internal Char[] Buffer { get; internal set; }
    internal int BufferMaxScanLength { get; internal set; }
    internal int BufferScanLength { get; internal set; }
    internal int BufferScanStart { get; internal set; }
    internal int BufferAcceptAction { get; internal set; }
    internal bool IsPastEndOfStream { get; internal set; }
    internal int BufferScanPos { get; }
    internal bool ReportLibraryOnlyFeatures { get; }
    internal LanguageVersion LanguageVersion { get; }
    internal FSharpOption`1<bool> StrictIndentation { get; }
    public LexBuffer`1(FSharpFunc`2<LexBuffer`1<Char>, Unit> filler, bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation);
    internal int EndOfScan();
    internal Position get_StartPos();
    internal void set_StartPos(Position b);
    internal Position get_EndPos();
    internal void set_EndPos(Position b);
    internal ReadOnlySpan`1<Char> get_LexemeView();
    internal Char LexemeChar(int n);
    internal bool LexemeContains(Char c);
    internal IDictionary`2<string, object> get_BufferLocalStore();
    internal int get_LexemeLength();
    internal void set_LexemeLength(int v);
    internal Char[] get_Buffer();
    internal void set_Buffer(Char[] v);
    internal int get_BufferMaxScanLength();
    internal void set_BufferMaxScanLength(int v);
    internal int get_BufferScanLength();
    internal void set_BufferScanLength(int v);
    internal int get_BufferScanStart();
    internal void set_BufferScanStart(int v);
    internal int get_BufferAcceptAction();
    internal void set_BufferAcceptAction(int v);
    internal void RefillBuffer();
    internal static string LexemeString(LexBuffer`1<char> lexbuf);
    internal bool get_IsPastEndOfStream();
    internal void set_IsPastEndOfStream(bool b);
    internal void DiscardInput();
    internal int get_BufferScanPos();
    internal void EnsureBufferSize(int n);
    internal bool get_ReportLibraryOnlyFeatures();
    internal LanguageVersion get_LanguageVersion();
    internal bool SupportsFeature(LanguageFeature featureId);
    internal FSharpOption`1<bool> get_StrictIndentation();
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal void CheckLanguageFeatureAndRecover(LanguageFeature featureId, Range range);
    internal static LexBuffer`1<Char> FromFunction(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, FSharpFunc`2<Tuple`3<Char[], int, int>, int> f);
    internal static LexBuffer`1<Char> FromArrayNoCopy(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, Char[] buffer);
    internal static LexBuffer`1<Char> FromArray(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, Char[] s);
    internal static LexBuffer`1<char> FromChars(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, Char[] arr);
    internal static LexBuffer`1<char> FromSourceText(bool reportLibraryOnlyFeatures, LanguageVersion langVersion, FSharpOption`1<bool> strictIndentation, ISourceText sourceText);
    [CompilerGeneratedAttribute]
internal void discardInput();
}
[StructAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Lexing.Position : ValueType {
    internal int FileIndex@;
    internal int Line@;
    internal int OriginalLine@;
    internal int AbsoluteOffset@;
    internal int StartOfLineAbsoluteOffset@;
    [CompilationMappingAttribute("4", "0")]
internal int FileIndex { get; }
    [CompilationMappingAttribute("4", "1")]
internal int Line { get; }
    [CompilationMappingAttribute("4", "2")]
internal int OriginalLine { get; }
    [CompilationMappingAttribute("4", "3")]
internal int AbsoluteOffset { get; }
    [CompilationMappingAttribute("4", "4")]
internal int StartOfLineAbsoluteOffset { get; }
    internal int Column { get; }
    internal Position NextLine { get; }
    internal Position ColumnMinusOne { get; }
    internal static Position Empty { get; }
    public Position(int fileIndex, int line, int originalLine, int startOfLineAbsoluteOffset, int absoluteOffset);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_FileIndex();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_Line();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_OriginalLine();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_AbsoluteOffset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_StartOfLineAbsoluteOffset();
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(Position obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual int CompareTo(object obj, IComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public sealed virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj, IEqualityComparer comp);
    internal int get_Column();
    internal Position get_NextLine();
    internal Position EndOfToken(int n);
    internal Position ShiftColumnBy(int by);
    internal Position get_ColumnMinusOne();
    internal Position ApplyLineDirective(int fileIdx, int line);
    public virtual string ToString();
    internal static Position get_Empty();
    internal static Position FirstLine(int fileIdx);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Position obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(object obj);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Lexing.UnicodeTables : object {
    internal UInt16[][] trans;
    internal UInt16[] accept;
    internal int sentinel;
    internal int numLowUnicodeChars;
    internal int numSpecificUnicodeChars;
    internal int eofPos;
    public UnicodeTables(UInt16[][] trans, UInt16[] accept);
    internal int Interpret(int initialState, LexBuffer`1<char> lexBuffer);
    internal static UnicodeTables Create(UInt16[][] trans, UInt16[] accept);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int lookupUnicodeCharacters(int state, char inp);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal int scanUntilSentinel(LexBuffer`1<char> lexBuffer, int state);
}
[CompilationMappingAttribute("5")]
internal class Internal.Utilities.Text.Parsing.Accept : Exception {
    internal object Data0@;
    [CompilationMappingAttribute("4", "0")]
internal object Data0 { get; }
    internal Accept(object data0);
    protected Accept(SerializationInfo info, StreamingContext context);
    internal object get_Data0();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Text.Parsing.Flags : object {
    internal static bool debug { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static bool get_debug();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Text.Parsing.Implementation : object {
    internal static int anyMarker { get; }
    internal static int shiftFlag { get; }
    internal static int reduceFlag { get; }
    internal static int errorFlag { get; }
    internal static int acceptFlag { get; }
    internal static int actionMask { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_anyMarker();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_shiftFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_reduceFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_errorFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_acceptFlag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal static int get_actionMask();
    internal static void popStackUntilErrorShifted@317(Tables`1<Token> tables, LexBuffer`1<char> lexbuf, Stack`1<int> stateStack, Stack`1<ValueInfo> valueStack, AssocTable actionTable, FSharpOption`1<Token> tokenOpt);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static object interpret(Tables`1<Token> tables, FSharpFunc`2<LexBuffer`1<char>, Token> lexer, LexBuffer`1<char> lexbuf, int initialState);
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Parsing.IParseState : object {
    internal Object[] ruleValues;
    internal Position[] ruleStartPoss;
    internal Position[] ruleEndPoss;
    internal Position[] lhsPos;
    internal LexBuffer`1<char> lexbuf;
    internal LexBuffer`1<char> LexBuffer { get; }
    internal Position ResultStartPosition { get; }
    internal Position ResultEndPosition { get; }
    internal Tuple`2<Position, Position> ResultRange { get; }
    public IParseState(Position[] ruleStartPoss, Position[] ruleEndPoss, Position[] lhsPos, Object[] ruleValues, LexBuffer`1<char> lexbuf);
    internal LexBuffer`1<char> get_LexBuffer();
    internal Tuple`2<Position, Position> InputRange(int index);
    internal Position InputStartPosition(int index);
    internal Position InputEndPosition(int index);
    internal Position get_ResultStartPosition();
    internal Position get_ResultEndPosition();
    internal object GetInput(int index);
    internal Tuple`2<Position, Position> get_ResultRange();
    internal b RaiseError();
}
[SealedAttribute]
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Parsing.ParseErrorContext`1 : object {
    internal FSharpList`1<int> stateStack;
    internal FSharpList`1<int> shiftableTokens;
    internal FSharpList`1<FSharpList`1<int>> reducibleProductions;
    internal FSharpList`1<int> reduceTokens;
    internal IParseState parseState;
    internal string message;
    internal FSharpOption`1<Token> currentToken;
    internal FSharpList`1<int> StateStack { get; }
    internal FSharpList`1<int> ReduceTokens { get; }
    internal FSharpOption`1<Token> CurrentToken { get; }
    internal IParseState ParseState { get; }
    internal FSharpList`1<FSharpList`1<int>> ReducibleProductions { get; }
    internal FSharpList`1<int> ShiftTokens { get; }
    internal string Message { get; }
    public ParseErrorContext`1(FSharpList`1<int> stateStack, IParseState parseState, FSharpList`1<int> reduceTokens, FSharpOption`1<Token> currentToken, FSharpList`1<FSharpList`1<int>> reducibleProductions, FSharpList`1<int> shiftableTokens, string message);
    internal FSharpList`1<int> get_StateStack();
    internal FSharpList`1<int> get_ReduceTokens();
    internal FSharpOption`1<Token> get_CurrentToken();
    internal IParseState get_ParseState();
    internal FSharpList`1<FSharpList`1<int>> get_ReducibleProductions();
    internal FSharpList`1<int> get_ShiftTokens();
    internal string get_Message();
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.Text.Parsing.ParseHelpers : object {
    internal static void parse_error(string _s);
    internal static FSharpOption`1<FSharpFunc`2<ParseErrorContext`1<Token>, Unit>> parse_error_rich();
}
[CompilationMappingAttribute("5")]
internal class Internal.Utilities.Text.Parsing.RecoverableParseError : Exception {
    protected RecoverableParseError(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual int GetHashCode(IEqualityComparer comp);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj, IEqualityComparer comp);
    [CompilerGeneratedAttribute]
internal bool Equals(Exception obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
}
[CompilationMappingAttribute("3")]
internal class Internal.Utilities.Text.Parsing.Stack`1 : object {
    internal a[] contents;
    internal int count;
    internal int Count { get; }
    internal bool IsEmpty { get; }
    public Stack`1(int n);
    internal void Ensure(int newSize);
    internal int get_Count();
    internal void Pop();
    internal a Peep();
    internal FSharpList`1<a> Top(int n);
    internal void Push(a x);
    internal bool get_IsEmpty();
    internal void PrintStack();
}
[CompilationMappingAttribute("34")]
internal class Internal.Utilities.Text.Parsing.Tables`1 : object {
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2[] reductions@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int endOfInputTag@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<Token, int> tagOfToken@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<Token, object> dataOfToken@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] actionTableElements@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] actionTableRowOffsets@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] reductionSymbolCounts@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] immediateActions@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] gotos@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] sparseGotoTableRowOffsets@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] stateToProdIdxsTableElements@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] stateToProdIdxsTableRowOffsets@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal UInt16[] productionToNonTerminalTable@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal FSharpFunc`2<ParseErrorContext`1<Token>, Unit> parseError@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int numTerminals@;
    [CompilerGeneratedAttribute]
[DebuggerBrowsableAttribute("0")]
internal int tagOfErrorTerminal@;
    [CompilationMappingAttribute("4", "0")]
internal FSharpFunc`2[] reductions { get; }
    [CompilationMappingAttribute("4", "1")]
internal int endOfInputTag { get; }
    [CompilationMappingAttribute("4", "2")]
internal FSharpFunc`2<Token, int> tagOfToken { get; }
    [CompilationMappingAttribute("4", "3")]
internal FSharpFunc`2<Token, object> dataOfToken { get; }
    [CompilationMappingAttribute("4", "4")]
internal UInt16[] actionTableElements { get; }
    [CompilationMappingAttribute("4", "5")]
internal UInt16[] actionTableRowOffsets { get; }
    [CompilationMappingAttribute("4", "6")]
internal UInt16[] reductionSymbolCounts { get; }
    [CompilationMappingAttribute("4", "7")]
internal UInt16[] immediateActions { get; }
    [CompilationMappingAttribute("4", "8")]
internal UInt16[] gotos { get; }
    [CompilationMappingAttribute("4", "9")]
internal UInt16[] sparseGotoTableRowOffsets { get; }
    [CompilationMappingAttribute("4", "10")]
internal UInt16[] stateToProdIdxsTableElements { get; }
    [CompilationMappingAttribute("4", "11")]
internal UInt16[] stateToProdIdxsTableRowOffsets { get; }
    [CompilationMappingAttribute("4", "12")]
internal UInt16[] productionToNonTerminalTable { get; }
    [CompilationMappingAttribute("4", "13")]
internal FSharpFunc`2<ParseErrorContext`1<Token>, Unit> parseError { get; }
    [CompilationMappingAttribute("4", "14")]
internal int numTerminals { get; }
    [CompilationMappingAttribute("4", "15")]
internal int tagOfErrorTerminal { get; }
    [DynamicDependencyAttribute("1632", "Internal.Utilities.Text.Parsing.Tables`1")]
internal Tables`1(FSharpFunc`2[] reductions, int endOfInputTag, FSharpFunc`2<Token, int> tagOfToken, FSharpFunc`2<Token, object> dataOfToken, UInt16[] actionTableElements, UInt16[] actionTableRowOffsets, UInt16[] reductionSymbolCounts, UInt16[] immediateActions, UInt16[] gotos, UInt16[] sparseGotoTableRowOffsets, UInt16[] stateToProdIdxsTableElements, UInt16[] stateToProdIdxsTableRowOffsets, UInt16[] productionToNonTerminalTable, FSharpFunc`2<ParseErrorContext`1<Token>, Unit> parseError, int numTerminals, int tagOfErrorTerminal);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2[] get_reductions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_endOfInputTag();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Token, int> get_tagOfToken();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<Token, object> get_dataOfToken();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_actionTableElements();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_actionTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_reductionSymbolCounts();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_immediateActions();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_gotos();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_sparseGotoTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_stateToProdIdxsTableElements();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_stateToProdIdxsTableRowOffsets();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal UInt16[] get_productionToNonTerminalTable();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal FSharpFunc`2<ParseErrorContext`1<Token>, Unit> get_parseError();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_numTerminals();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal int get_tagOfErrorTerminal();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    internal object Interpret(FSharpFunc`2<LexBuffer`1<char>, Token> lexer, LexBuffer`1<char> lexbuf, int initialState);
}
[CompilationMappingAttribute("7")]
internal static class Internal.Utilities.XmlAdapters : object {
    [CompilationMappingAttribute("9")]
internal static Char[] s_escapeChars { get; }
    internal static Char[] get_s_escapeChars();
    internal static string getEscapeSequence(char c);
    internal static string escape(string str);
}
[FlagsAttribute]
[CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
internal enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes All;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
}
internal class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
private DynamicallyAccessedMemberTypes MemberType@;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
private Type Type@;
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicallyAccessedMemberTypes MemberType { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Type Type { get; }
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes MemberType, Type Type);
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
[DebuggerNonUserCodeAttribute]
public DynamicallyAccessedMemberTypes get_MemberType();
}
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilationMappingAttribute("3")]
internal class UtilsStrings.SR : object {
    internal static Lazy`1<ResourceManager> resources;
    internal static Type funTyC;
    internal static bool swallowResourceText;
    internal static int init@14;
    internal static bool SwallowResourceText { get; internal set; }
    private static SR();
    internal static bool get_SwallowResourceText();
    internal static void set_SwallowResourceText(bool b);
    internal static string buildProductName(string a0);
    internal static string fSharpBannerVersion(string a0, string a1);
    internal static void RunStartupValidation();
    [CompilerGeneratedAttribute]
internal static Assembly getCurrentAssembly();
    [CompilerGeneratedAttribute]
internal static Type getTypeInfo(Type t);
    [CompilerGeneratedAttribute]
internal static string GetString(string name);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object mkFunctionValue(Type[] tys, FSharpFunc`2<object, object> impl);
    [CompilerGeneratedAttribute]
internal static bool isNamedType(Type ty);
    [CompilerGeneratedAttribute]
internal static bool isFunctionType(Type ty1);
    [CompilerGeneratedAttribute]
internal static Tuple`2<Type, Type[]> destFunTy(Type ty);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object buildFunctionForOneArgPat(Type ty, FSharpFunc`2<Type, FSharpFunc`2<object, object>> impl);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static object capture1(string fmt, int i, FSharpList`1<object> args, Type ty, FSharpFunc`2<FSharpList`1<object>, FSharpFunc`2<Type, FSharpFunc`2<int, object>>> go);
    [CompilerGeneratedAttribute]
internal static string postProcessString(string s);
    [CompilationArgumentCountsAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
internal static T createMessageString(string messageString, PrintfFormat`4<T, Unit, string, string> fmt);
    [CompilerGeneratedAttribute]
internal static T GetStringFunc(string messageID, PrintfFormat`4<T, Unit, string, string> fmt);
}
