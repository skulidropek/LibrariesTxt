public class Humanizer.Bytes.ByteRate : object {
    [CompilerGeneratedAttribute]
private ByteSize <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Interval>k__BackingField;
    public ByteSize Size { get; private set; }
    public TimeSpan Interval { get; private set; }
    public ByteRate(ByteSize size, TimeSpan interval);
    [CompilerGeneratedAttribute]
public ByteSize get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(ByteSize value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Interval();
    [CompilerGeneratedAttribute]
private void set_Interval(TimeSpan value);
    public string Humanize(TimeUnit timeUnit);
    public string Humanize(string format, TimeUnit timeUnit, CultureInfo culture);
}
public class Humanizer.Bytes.ByteSize : ValueType {
    public static ByteSize MinValue;
    public static ByteSize MaxValue;
    public static long BitsInByte;
    public static long BytesInKilobyte;
    public static long BytesInMegabyte;
    public static long BytesInGigabyte;
    public static long BytesInTerabyte;
    public static string BitSymbol;
    public static string Bit;
    public static string ByteSymbol;
    public static string Byte;
    public static string KilobyteSymbol;
    public static string Kilobyte;
    public static string MegabyteSymbol;
    public static string Megabyte;
    public static string GigabyteSymbol;
    public static string Gigabyte;
    public static string TerabyteSymbol;
    public static string Terabyte;
    [CompilerGeneratedAttribute]
private long <Bits>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Kilobytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Megabytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Gigabytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Terabytes>k__BackingField;
    public long Bits { get; private set; }
    public double Bytes { get; private set; }
    public double Kilobytes { get; private set; }
    public double Megabytes { get; private set; }
    public double Gigabytes { get; private set; }
    public double Terabytes { get; private set; }
    public string LargestWholeNumberSymbol { get; }
    public string LargestWholeNumberFullWord { get; }
    public double LargestWholeNumberValue { get; }
    public ByteSize(double byteSize);
    private static ByteSize();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Bits();
    [CompilerGeneratedAttribute]
private void set_Bits(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Bytes();
    [CompilerGeneratedAttribute]
private void set_Bytes(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Kilobytes();
    [CompilerGeneratedAttribute]
private void set_Kilobytes(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Megabytes();
    [CompilerGeneratedAttribute]
private void set_Megabytes(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Gigabytes();
    [CompilerGeneratedAttribute]
private void set_Gigabytes(double value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Terabytes();
    [CompilerGeneratedAttribute]
private void set_Terabytes(double value);
    public string get_LargestWholeNumberSymbol();
    public string GetLargestWholeNumberSymbol(IFormatProvider provider);
    public string get_LargestWholeNumberFullWord();
    public string GetLargestWholeNumberFullWord(IFormatProvider provider);
    public double get_LargestWholeNumberValue();
    public static ByteSize FromBits(long value);
    public static ByteSize FromBytes(double value);
    public static ByteSize FromKilobytes(double value);
    public static ByteSize FromMegabytes(double value);
    public static ByteSize FromGigabytes(double value);
    public static ByteSize FromTerabytes(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    private string ToString(string format, IFormatProvider provider, bool toSymbol);
    public string ToFullWords(string format, IFormatProvider provider);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(ByteSize value);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ByteSize other);
    public ByteSize Add(ByteSize bs);
    public ByteSize AddBits(long value);
    public ByteSize AddBytes(double value);
    public ByteSize AddKilobytes(double value);
    public ByteSize AddMegabytes(double value);
    public ByteSize AddGigabytes(double value);
    public ByteSize AddTerabytes(double value);
    public ByteSize Subtract(ByteSize bs);
    public static ByteSize op_Addition(ByteSize b1, ByteSize b2);
    public static ByteSize op_Subtraction(ByteSize b1, ByteSize b2);
    public static ByteSize op_Increment(ByteSize b);
    public static ByteSize op_UnaryNegation(ByteSize b);
    public static ByteSize op_Decrement(ByteSize b);
    public static bool op_Equality(ByteSize b1, ByteSize b2);
    public static bool op_Inequality(ByteSize b1, ByteSize b2);
    public static bool op_LessThan(ByteSize b1, ByteSize b2);
    public static bool op_LessThanOrEqual(ByteSize b1, ByteSize b2);
    public static bool op_GreaterThan(ByteSize b1, ByteSize b2);
    public static bool op_GreaterThanOrEqual(ByteSize b1, ByteSize b2);
    public static bool TryParse(string s, ByteSize& result);
    public static bool TryParse(string s, IFormatProvider formatProvider, ByteSize& result);
    private static NumberFormatInfo GetNumberFormatInfo(IFormatProvider formatProvider);
    public static ByteSize Parse(string s);
    public static ByteSize Parse(string s, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
internal static bool <ToString>g__has|62_0(string s, <>c__DisplayClass62_0& );
    [CompilerGeneratedAttribute]
internal static string <ToString>g__output|62_1(double n, <>c__DisplayClass62_0& );
}
[ExtensionAttribute]
public static class Humanizer.ByteSizeExtensions : object {
    [ExtensionAttribute]
public static ByteSize Bits(byte input);
    [ExtensionAttribute]
public static ByteSize Bits(sbyte input);
    [ExtensionAttribute]
public static ByteSize Bits(short input);
    [ExtensionAttribute]
public static ByteSize Bits(ushort input);
    [ExtensionAttribute]
public static ByteSize Bits(int input);
    [ExtensionAttribute]
public static ByteSize Bits(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Bits(long input);
    [ExtensionAttribute]
public static ByteSize Bytes(byte input);
    [ExtensionAttribute]
public static ByteSize Bytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Bytes(short input);
    [ExtensionAttribute]
public static ByteSize Bytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Bytes(int input);
    [ExtensionAttribute]
public static ByteSize Bytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Bytes(double input);
    [ExtensionAttribute]
public static ByteSize Bytes(long input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(byte input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(short input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(int input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(double input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(long input);
    [ExtensionAttribute]
public static ByteSize Megabytes(byte input);
    [ExtensionAttribute]
public static ByteSize Megabytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Megabytes(short input);
    [ExtensionAttribute]
public static ByteSize Megabytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Megabytes(int input);
    [ExtensionAttribute]
public static ByteSize Megabytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Megabytes(double input);
    [ExtensionAttribute]
public static ByteSize Megabytes(long input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(byte input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(short input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(int input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(double input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(long input);
    [ExtensionAttribute]
public static ByteSize Terabytes(byte input);
    [ExtensionAttribute]
public static ByteSize Terabytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Terabytes(short input);
    [ExtensionAttribute]
public static ByteSize Terabytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Terabytes(int input);
    [ExtensionAttribute]
public static ByteSize Terabytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Terabytes(double input);
    [ExtensionAttribute]
public static ByteSize Terabytes(long input);
    [ExtensionAttribute]
public static string Humanize(ByteSize input, string format);
    [ExtensionAttribute]
public static string Humanize(ByteSize input, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static string Humanize(ByteSize input, string format, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static ByteRate Per(ByteSize size, TimeSpan interval);
}
[ExtensionAttribute]
public static class Humanizer.CasingExtensions : object {
    [ExtensionAttribute]
public static string ApplyCase(string input, LetterCasing casing);
}
public enum Humanizer.ClockNotationRounding : Enum {
    public int value__;
    public static ClockNotationRounding None;
    public static ClockNotationRounding NearestFiveMinutes;
}
[ExtensionAttribute]
public static class Humanizer.CollectionHumanizeExtensions : object {
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection, Func`2<T, string> displayFormatter);
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection, Func`2<T, object> displayFormatter);
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection, string separator);
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection, Func`2<T, string> displayFormatter, string separator);
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection, Func`2<T, object> displayFormatter, string separator);
}
internal class Humanizer.Configuration.CollectionFormatterRegistry : LocaliserRegistry`1<ICollectionFormatter> {
}
public static class Humanizer.Configuration.Configurator : object {
    private static LocaliserRegistry`1<ICollectionFormatter> _collectionFormatters;
    private static LocaliserRegistry`1<IFormatter> _formatters;
    private static LocaliserRegistry`1<INumberToWordsConverter> _numberToWordsConverters;
    private static LocaliserRegistry`1<IOrdinalizer> _ordinalizers;
    private static LocaliserRegistry`1<IDateToOrdinalWordConverter> _dateToOrdinalWordConverters;
    private static LocaliserRegistry`1<IDateOnlyToOrdinalWordConverter> _dateOnlyToOrdinalWordConverters;
    private static LocaliserRegistry`1<ITimeOnlyToClockNotationConverter> _timeOnlyToClockNotationConverters;
    private static IDateTimeHumanizeStrategy _dateTimeHumanizeStrategy;
    private static IDateTimeOffsetHumanizeStrategy _dateTimeOffsetHumanizeStrategy;
    private static IDateOnlyHumanizeStrategy _dateOnlyHumanizeStrategy;
    private static ITimeOnlyHumanizeStrategy _timeOnlyHumanizeStrategy;
    private static Func`2<PropertyInfo, bool> DefaultEnumDescriptionPropertyLocator;
    private static Func`2<PropertyInfo, bool> _enumDescriptionPropertyLocator;
    public static LocaliserRegistry`1<ICollectionFormatter> CollectionFormatters { get; }
    public static LocaliserRegistry`1<IFormatter> Formatters { get; }
    public static LocaliserRegistry`1<INumberToWordsConverter> NumberToWordsConverters { get; }
    public static LocaliserRegistry`1<IOrdinalizer> Ordinalizers { get; }
    public static LocaliserRegistry`1<IDateToOrdinalWordConverter> DateToOrdinalWordsConverters { get; }
    public static LocaliserRegistry`1<IDateOnlyToOrdinalWordConverter> DateOnlyToOrdinalWordsConverters { get; }
    public static LocaliserRegistry`1<ITimeOnlyToClockNotationConverter> TimeOnlyToClockNotationConverters { get; }
    internal static ICollectionFormatter CollectionFormatter { get; }
    internal static IOrdinalizer Ordinalizer { get; }
    internal static IDateToOrdinalWordConverter DateToOrdinalWordsConverter { get; }
    internal static IDateOnlyToOrdinalWordConverter DateOnlyToOrdinalWordsConverter { get; }
    internal static ITimeOnlyToClockNotationConverter TimeOnlyToClockNotationConverter { get; }
    public static IDateTimeHumanizeStrategy DateTimeHumanizeStrategy { get; public set; }
    public static IDateTimeOffsetHumanizeStrategy DateTimeOffsetHumanizeStrategy { get; public set; }
    public static IDateOnlyHumanizeStrategy DateOnlyHumanizeStrategy { get; public set; }
    public static ITimeOnlyHumanizeStrategy TimeOnlyHumanizeStrategy { get; public set; }
    public static Func`2<PropertyInfo, bool> EnumDescriptionPropertyLocator { get; public set; }
    private static Configurator();
    public static LocaliserRegistry`1<ICollectionFormatter> get_CollectionFormatters();
    public static LocaliserRegistry`1<IFormatter> get_Formatters();
    public static LocaliserRegistry`1<INumberToWordsConverter> get_NumberToWordsConverters();
    public static LocaliserRegistry`1<IOrdinalizer> get_Ordinalizers();
    public static LocaliserRegistry`1<IDateToOrdinalWordConverter> get_DateToOrdinalWordsConverters();
    public static LocaliserRegistry`1<IDateOnlyToOrdinalWordConverter> get_DateOnlyToOrdinalWordsConverters();
    public static LocaliserRegistry`1<ITimeOnlyToClockNotationConverter> get_TimeOnlyToClockNotationConverters();
    internal static ICollectionFormatter get_CollectionFormatter();
    internal static IFormatter GetFormatter(CultureInfo culture);
    internal static INumberToWordsConverter GetNumberToWordsConverter(CultureInfo culture);
    internal static IOrdinalizer get_Ordinalizer();
    internal static IDateToOrdinalWordConverter get_DateToOrdinalWordsConverter();
    internal static IDateOnlyToOrdinalWordConverter get_DateOnlyToOrdinalWordsConverter();
    internal static ITimeOnlyToClockNotationConverter get_TimeOnlyToClockNotationConverter();
    public static IDateTimeHumanizeStrategy get_DateTimeHumanizeStrategy();
    public static void set_DateTimeHumanizeStrategy(IDateTimeHumanizeStrategy value);
    public static IDateTimeOffsetHumanizeStrategy get_DateTimeOffsetHumanizeStrategy();
    public static void set_DateTimeOffsetHumanizeStrategy(IDateTimeOffsetHumanizeStrategy value);
    public static IDateOnlyHumanizeStrategy get_DateOnlyHumanizeStrategy();
    public static void set_DateOnlyHumanizeStrategy(IDateOnlyHumanizeStrategy value);
    public static ITimeOnlyHumanizeStrategy get_TimeOnlyHumanizeStrategy();
    public static void set_TimeOnlyHumanizeStrategy(ITimeOnlyHumanizeStrategy value);
    public static Func`2<PropertyInfo, bool> get_EnumDescriptionPropertyLocator();
    public static void set_EnumDescriptionPropertyLocator(Func`2<PropertyInfo, bool> value);
}
internal class Humanizer.Configuration.DateOnlyToOrdinalWordsConverterRegistry : LocaliserRegistry`1<IDateOnlyToOrdinalWordConverter> {
}
internal class Humanizer.Configuration.DateToOrdinalWordsConverterRegistry : LocaliserRegistry`1<IDateToOrdinalWordConverter> {
}
internal class Humanizer.Configuration.FormatterRegistry : LocaliserRegistry`1<IFormatter> {
    private void RegisterDefaultFormatter(string localeCode);
    private void RegisterCzechSlovakPolishFormatter(string localeCode);
}
public class Humanizer.Configuration.LocaliserRegistry`1 : object {
    private IDictionary`2<string, Func`2<CultureInfo, TLocaliser>> _localisers;
    private Func`2<CultureInfo, TLocaliser> _defaultLocaliser;
    public LocaliserRegistry`1(TLocaliser defaultLocaliser);
    public LocaliserRegistry`1(Func`2<CultureInfo, TLocaliser> defaultLocaliser);
    public TLocaliser ResolveForUiCulture();
    public TLocaliser ResolveForCulture(CultureInfo culture);
    public void Register(string localeCode, TLocaliser localiser);
    public void Register(string localeCode, Func`2<CultureInfo, TLocaliser> localiser);
    private Func`2<CultureInfo, TLocaliser> FindLocaliser(CultureInfo culture);
}
internal class Humanizer.Configuration.NumberToWordsConverterRegistry : LocaliserRegistry`1<INumberToWordsConverter> {
}
internal class Humanizer.Configuration.OrdinalizerRegistry : LocaliserRegistry`1<IOrdinalizer> {
}
internal class Humanizer.Configuration.TimeOnlyToClockNotationConvertersRegistry : LocaliserRegistry`1<ITimeOnlyToClockNotationConverter> {
}
[ExtensionAttribute]
public static class Humanizer.DateHumanizeExtensions : object {
    [ExtensionAttribute]
public static string Humanize(DateTime input, Nullable`1<bool> utcDate, Nullable`1<DateTime> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(Nullable`1<DateTime> input, Nullable`1<bool> utcDate, Nullable`1<DateTime> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(DateTimeOffset input, Nullable`1<DateTimeOffset> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(Nullable`1<DateTimeOffset> input, Nullable`1<DateTimeOffset> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(DateOnly input, Nullable`1<DateOnly> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(Nullable`1<DateOnly> input, Nullable`1<DateOnly> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(TimeOnly input, Nullable`1<TimeOnly> timeToCompareAgainst, bool useUtc, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(Nullable`1<TimeOnly> input, Nullable`1<TimeOnly> timeToCompareAgainst, bool useUtc, CultureInfo culture);
}
internal static class Humanizer.DateTimeHumanizeStrategy.DateTimeHumanizeAlgorithms : object {
    public static string PrecisionHumanize(DateTime input, DateTime comparisonBase, double precision, CultureInfo culture);
    public static string PrecisionHumanize(DateOnly input, DateOnly comparisonBase, double precision, CultureInfo culture);
    public static string PrecisionHumanize(TimeOnly input, TimeOnly comparisonBase, double precision, CultureInfo culture);
    private static string PrecisionHumanize(TimeSpan ts, Tense tense, double precision, CultureInfo culture);
    public static string DefaultHumanize(DateTime input, DateTime comparisonBase, CultureInfo culture);
    public static string DefaultHumanize(DateOnly input, DateOnly comparisonBase, CultureInfo culture);
    public static string DefaultHumanize(TimeOnly input, TimeOnly comparisonBase, CultureInfo culture);
    private static string DefaultHumanize(TimeSpan ts, bool sameMonth, int days, Tense tense, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.DefaultDateOnlyHumanizeStrategy : object {
    public sealed virtual string Humanize(DateOnly input, DateOnly comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.DefaultDateTimeHumanizeStrategy : object {
    public sealed virtual string Humanize(DateTime input, DateTime comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.DefaultDateTimeOffsetHumanizeStrategy : object {
    public sealed virtual string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.DefaultTimeOnlyHumanizeStrategy : object {
    public sealed virtual string Humanize(TimeOnly input, TimeOnly comparisonBase, CultureInfo culture);
}
public interface Humanizer.DateTimeHumanizeStrategy.IDateOnlyHumanizeStrategy {
    public abstract virtual string Humanize(DateOnly input, DateOnly comparisonBase, CultureInfo culture);
}
public interface Humanizer.DateTimeHumanizeStrategy.IDateTimeHumanizeStrategy {
    public abstract virtual string Humanize(DateTime input, DateTime comparisonBase, CultureInfo culture);
}
public interface Humanizer.DateTimeHumanizeStrategy.IDateTimeOffsetHumanizeStrategy {
    public abstract virtual string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo culture);
}
public interface Humanizer.DateTimeHumanizeStrategy.ITimeOnlyHumanizeStrategy {
    public abstract virtual string Humanize(TimeOnly input, TimeOnly comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.PrecisionDateOnlyHumanizeStrategy : object {
    private double _precision;
    public PrecisionDateOnlyHumanizeStrategy(double precision);
    public sealed virtual string Humanize(DateOnly input, DateOnly comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.PrecisionDateTimeHumanizeStrategy : object {
    private double _precision;
    public PrecisionDateTimeHumanizeStrategy(double precision);
    public sealed virtual string Humanize(DateTime input, DateTime comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.PrecisionDateTimeOffsetHumanizeStrategy : object {
    private double _precision;
    public PrecisionDateTimeOffsetHumanizeStrategy(double precision);
    public sealed virtual string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.PrecisionTimeOnlyHumanizeStrategy : object {
    private double _precision;
    public PrecisionTimeOnlyHumanizeStrategy(double precision);
    public sealed virtual string Humanize(TimeOnly input, TimeOnly comparisonBase, CultureInfo culture);
}
[ExtensionAttribute]
public static class Humanizer.DateToOrdinalWordsExtensions : object {
    [ExtensionAttribute]
public static string ToOrdinalWords(DateTime input);
    [ExtensionAttribute]
public static string ToOrdinalWords(DateTime input, GrammaticalCase grammaticalCase);
    [ExtensionAttribute]
public static string ToOrdinalWords(DateOnly input);
    [ExtensionAttribute]
public static string ToOrdinalWords(DateOnly input, GrammaticalCase grammaticalCase);
}
public static class Humanizer.EnglishArticle : object {
    public static String[] AppendArticlePrefix(String[] items);
    public static String[] PrependArticleSuffix(String[] appended);
    private static string ToOriginalFormat(String[] appended, string suffix, int i);
}
public enum Humanizer.EnglishArticles : Enum {
    public int value__;
    public static EnglishArticles A;
    public static EnglishArticles An;
    public static EnglishArticles The;
}
[ExtensionAttribute]
public static class Humanizer.EnumDehumanizeExtensions : object {
    [ExtensionAttribute]
public static TTargetEnum DehumanizeTo(string input);
    [ExtensionAttribute]
public static Enum DehumanizeTo(string input, Type targetEnum, OnNoMatch onNoMatch);
    private static object DehumanizeToPrivate(string input, Type targetEnum, OnNoMatch onNoMatch);
}
[ExtensionAttribute]
public static class Humanizer.EnumHumanizeExtensions : object {
    private static string DisplayAttributeTypeName;
    private static string DisplayAttributeGetDescriptionMethodName;
    private static string DisplayAttributeGetNameMethodName;
    private static Func`2<PropertyInfo, bool> StringTypedProperty;
    private static EnumHumanizeExtensions();
    [ExtensionAttribute]
public static string Humanize(Enum input);
    private static bool IsBitFieldEnum(TypeInfo typeInfo);
    private static string GetCustomDescription(MemberInfo memberInfo);
    [ExtensionAttribute]
public static string Humanize(Enum input, LetterCasing casing);
}
internal class Humanizer.FixedLengthTruncator : object {
    public sealed virtual string Truncate(string value, int length, string truncationString, TruncateFrom truncateFrom);
}
internal class Humanizer.FixedNumberOfCharactersTruncator : object {
    public sealed virtual string Truncate(string value, int length, string truncationString, TruncateFrom truncateFrom);
}
internal class Humanizer.FixedNumberOfWordsTruncator : object {
    public sealed virtual string Truncate(string value, int length, string truncationString, TruncateFrom truncateFrom);
    private static string TruncateFromRight(string value, int length, string truncationString);
    private static string TruncateFromLeft(string value, int length, string truncationString);
}
public enum Humanizer.GrammaticalCase : Enum {
    public int value__;
    public static GrammaticalCase Nominative;
    public static GrammaticalCase Genitive;
    public static GrammaticalCase Dative;
    public static GrammaticalCase Accusative;
    public static GrammaticalCase Instrumental;
    public static GrammaticalCase Prepositional;
}
public enum Humanizer.GrammaticalGender : Enum {
    public int value__;
    public static GrammaticalGender Masculine;
    public static GrammaticalGender Feminine;
    public static GrammaticalGender Neuter;
}
[ExtensionAttribute]
public static class Humanizer.HeadingExtensions : object {
    internal static String[] headings;
    internal static Char[] headingArrows;
    private static HeadingExtensions();
    [ExtensionAttribute]
public static string ToHeading(double heading, HeadingStyle style, CultureInfo culture);
    [ExtensionAttribute]
public static char ToHeadingArrow(double heading);
    [ExtensionAttribute]
public static double FromAbbreviatedHeading(string heading);
    [ExtensionAttribute]
public static double FromAbbreviatedHeading(string heading, CultureInfo culture);
    [ExtensionAttribute]
public static double FromHeadingArrow(char heading);
    [ExtensionAttribute]
public static double FromHeadingArrow(string heading);
}
public enum Humanizer.HeadingStyle : Enum {
    public int value__;
    public static HeadingStyle Abbreviated;
    public static HeadingStyle Full;
}
public interface Humanizer.ICulturedStringTransformer {
    public abstract virtual string Transform(string input, CultureInfo culture);
}
public class Humanizer.In : object {
    public static DateTime January { get; }
    public static DateTime February { get; }
    public static DateTime March { get; }
    public static DateTime April { get; }
    public static DateTime May { get; }
    public static DateTime June { get; }
    public static DateTime July { get; }
    public static DateTime August { get; }
    public static DateTime September { get; }
    public static DateTime October { get; }
    public static DateTime November { get; }
    public static DateTime December { get; }
    public static DateTime TheYear(int year);
    public static DateTime get_January();
    public static DateTime JanuaryOf(int year);
    public static DateTime get_February();
    public static DateTime FebruaryOf(int year);
    public static DateTime get_March();
    public static DateTime MarchOf(int year);
    public static DateTime get_April();
    public static DateTime AprilOf(int year);
    public static DateTime get_May();
    public static DateTime MayOf(int year);
    public static DateTime get_June();
    public static DateTime JuneOf(int year);
    public static DateTime get_July();
    public static DateTime JulyOf(int year);
    public static DateTime get_August();
    public static DateTime AugustOf(int year);
    public static DateTime get_September();
    public static DateTime SeptemberOf(int year);
    public static DateTime get_October();
    public static DateTime OctoberOf(int year);
    public static DateTime get_November();
    public static DateTime NovemberOf(int year);
    public static DateTime get_December();
    public static DateTime DecemberOf(int year);
}
public class Humanizer.InDate : object {
    public static DateOnly January { get; }
    public static DateOnly February { get; }
    public static DateOnly March { get; }
    public static DateOnly April { get; }
    public static DateOnly May { get; }
    public static DateOnly June { get; }
    public static DateOnly July { get; }
    public static DateOnly August { get; }
    public static DateOnly September { get; }
    public static DateOnly October { get; }
    public static DateOnly November { get; }
    public static DateOnly December { get; }
    public static DateOnly TheYear(int year);
    public static DateOnly get_January();
    public static DateOnly JanuaryOf(int year);
    public static DateOnly get_February();
    public static DateOnly FebruaryOf(int year);
    public static DateOnly get_March();
    public static DateOnly MarchOf(int year);
    public static DateOnly get_April();
    public static DateOnly AprilOf(int year);
    public static DateOnly get_May();
    public static DateOnly MayOf(int year);
    public static DateOnly get_June();
    public static DateOnly JuneOf(int year);
    public static DateOnly get_July();
    public static DateOnly JulyOf(int year);
    public static DateOnly get_August();
    public static DateOnly AugustOf(int year);
    public static DateOnly get_September();
    public static DateOnly SeptemberOf(int year);
    public static DateOnly get_October();
    public static DateOnly OctoberOf(int year);
    public static DateOnly get_November();
    public static DateOnly NovemberOf(int year);
    public static DateOnly get_December();
    public static DateOnly DecemberOf(int year);
}
public static class Humanizer.Inflections.Vocabularies : object {
    private static Lazy`1<Vocabulary> Instance;
    public static Vocabulary Default { get; }
    private static Vocabularies();
    public static Vocabulary get_Default();
    private static Vocabulary BuildDefault();
}
public class Humanizer.Inflections.Vocabulary : object {
    private List`1<Rule> _plurals;
    private List`1<Rule> _singulars;
    private List`1<string> _uncountables;
    public void AddIrregular(string singular, string plural, bool matchEnding);
    public void AddUncountable(string word);
    public void AddPlural(string rule, string replacement);
    public void AddSingular(string rule, string replacement);
    public string Pluralize(string word, bool inputIsKnownToBeSingular);
    public string Singularize(string word, bool inputIsKnownToBePlural, bool skipSimpleWords);
    private string ApplyRules(IList`1<Rule> rules, string word, bool skipFirstRule);
    private bool IsUncountable(string word);
    private string MatchUpperCase(string word, string replacement);
}
[ExtensionAttribute]
public static class Humanizer.InflectorExtensions : object {
    [ExtensionAttribute]
public static string Pluralize(string word, bool inputIsKnownToBeSingular);
    [ExtensionAttribute]
public static string Singularize(string word, bool inputIsKnownToBePlural, bool skipSimpleWords);
    [ExtensionAttribute]
public static string Titleize(string input);
    [ExtensionAttribute]
public static string Pascalize(string input);
    [ExtensionAttribute]
public static string Camelize(string input);
    [ExtensionAttribute]
public static string Underscore(string input);
    [ExtensionAttribute]
public static string Dasherize(string underscoredWord);
    [ExtensionAttribute]
public static string Hyphenate(string underscoredWord);
    [ExtensionAttribute]
public static string Kebaberize(string input);
}
public interface Humanizer.IStringTransformer {
    public abstract virtual string Transform(string input);
}
public interface Humanizer.ITruncator {
    public abstract virtual string Truncate(string value, int length, string truncationString, TruncateFrom truncateFrom);
}
public enum Humanizer.LetterCasing : Enum {
    public int value__;
    public static LetterCasing Title;
    public static LetterCasing AllCaps;
    public static LetterCasing LowerCase;
    public static LetterCasing Sentence;
}
internal class Humanizer.Localisation.CollectionFormatters.DefaultCollectionFormatter : object {
    protected string DefaultSeparator;
    public DefaultCollectionFormatter(string defaultSeparator);
    public virtual string Humanize(IEnumerable`1<T> collection);
    public virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, string> objectFormatter);
    public sealed virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, object> objectFormatter);
    public virtual string Humanize(IEnumerable`1<T> collection, string separator);
    public virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, string> objectFormatter, string separator);
    public sealed virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, object> objectFormatter, string separator);
    private string HumanizeDisplayStrings(IEnumerable`1<string> strings, string separator);
    protected virtual string GetConjunctionFormatString(int itemCount);
}
public interface Humanizer.Localisation.CollectionFormatters.ICollectionFormatter {
    public abstract virtual string Humanize(IEnumerable`1<T> collection);
    public abstract virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, string> objectFormatter);
    public abstract virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, object> objectFormatter);
    public abstract virtual string Humanize(IEnumerable`1<T> collection, string separator);
    public abstract virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, string> objectFormatter, string separator);
    public abstract virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, object> objectFormatter, string separator);
}
internal class Humanizer.Localisation.CollectionFormatters.OxfordStyleCollectionFormatter : DefaultCollectionFormatter {
    public OxfordStyleCollectionFormatter(string defaultSeparator);
    protected virtual string GetConjunctionFormatString(int itemCount);
}
public enum Humanizer.Localisation.DataUnit : Enum {
    public int value__;
    public static DataUnit Bit;
    public static DataUnit Byte;
    public static DataUnit Kilobyte;
    public static DataUnit Megabyte;
    public static DataUnit Gigabyte;
    public static DataUnit Terabyte;
}
internal class Humanizer.Localisation.DateToOrdinalWords.DefaultDateOnlyToOrdinalWordConverter : object {
    public virtual string Convert(DateOnly date);
    public virtual string Convert(DateOnly date, GrammaticalCase grammaticalCase);
}
internal class Humanizer.Localisation.DateToOrdinalWords.DefaultDateToOrdinalWordConverter : object {
    public virtual string Convert(DateTime date);
    public virtual string Convert(DateTime date, GrammaticalCase grammaticalCase);
}
internal class Humanizer.Localisation.DateToOrdinalWords.EsDateOnlyToOrdinalWordsConverter : DefaultDateOnlyToOrdinalWordConverter {
    public virtual string Convert(DateOnly date);
}
internal class Humanizer.Localisation.DateToOrdinalWords.EsDateToOrdinalWordsConverter : DefaultDateToOrdinalWordConverter {
    public virtual string Convert(DateTime date);
}
internal class Humanizer.Localisation.DateToOrdinalWords.FrDateOnlyToOrdinalWordsConverter : DefaultDateOnlyToOrdinalWordConverter {
    public virtual string Convert(DateOnly date);
}
internal class Humanizer.Localisation.DateToOrdinalWords.FrDateToOrdinalWordsConverter : DefaultDateToOrdinalWordConverter {
    public virtual string Convert(DateTime date);
}
public interface Humanizer.Localisation.DateToOrdinalWords.IDateOnlyToOrdinalWordConverter {
    public abstract virtual string Convert(DateOnly date);
    public abstract virtual string Convert(DateOnly date, GrammaticalCase grammaticalCase);
}
public interface Humanizer.Localisation.DateToOrdinalWords.IDateToOrdinalWordConverter {
    public abstract virtual string Convert(DateTime date);
    public abstract virtual string Convert(DateTime date, GrammaticalCase grammaticalCase);
}
internal class Humanizer.Localisation.DateToOrdinalWords.UsDateOnlyToOrdinalWordsConverter : DefaultDateOnlyToOrdinalWordConverter {
    public virtual string Convert(DateOnly date);
}
internal class Humanizer.Localisation.DateToOrdinalWords.UsDateToOrdinalWordsConverter : DefaultDateToOrdinalWordConverter {
    public virtual string Convert(DateTime date);
}
internal class Humanizer.Localisation.Formatters.ArabicFormatter : DefaultFormatter {
    private static string DualPostfix;
    private static string PluralPostfix;
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.CroatianFormatter : DefaultFormatter {
    private static string DualTrialQuadralPostfix;
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.CzechSlovakPolishFormatter : DefaultFormatter {
    private static string PaucalPostfix;
    public CzechSlovakPolishFormatter(string localeCode);
    protected virtual string GetResourceKey(string resourceKey, int number);
}
public class Humanizer.Localisation.Formatters.DefaultFormatter : object {
    private CultureInfo _culture;
    public DefaultFormatter(string localeCode);
    public virtual string DateHumanize_Now();
    public virtual string DateHumanize_Never();
    public virtual string DateHumanize(TimeUnit timeUnit, Tense timeUnitTense, int unit);
    public virtual string TimeSpanHumanize_Zero();
    public virtual string TimeSpanHumanize(TimeUnit timeUnit, int unit, bool toWords);
    public virtual string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol);
    public virtual string TimeUnitHumanize(TimeUnit timeUnit);
    private string GetResourceForDate(TimeUnit unit, Tense timeUnitTense, int count);
    private string GetResourceForTimeSpan(TimeUnit unit, int count, bool toWords);
    protected virtual string Format(string resourceKey);
    protected virtual string Format(string resourceKey, int number, bool toWords);
    protected virtual string GetResourceKey(string resourceKey, int number);
    protected virtual string GetResourceKey(string resourceKey);
}
internal class Humanizer.Localisation.Formatters.FrenchFormatter : DefaultFormatter {
    private static string DualPostfix;
    public FrenchFormatter(string localeCode);
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.GermanFormatter : DefaultFormatter {
    public virtual string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol);
}
internal class Humanizer.Localisation.Formatters.HebrewFormatter : DefaultFormatter {
    private static string DualPostfix;
    private static string PluralPostfix;
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.IcelandicFormatter : DefaultFormatter {
    private static string LocaleCode;
    private CultureInfo _localCulture;
    public virtual string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol);
    protected virtual string Format(string resourceKey, int number, bool toWords);
}
public interface Humanizer.Localisation.Formatters.IFormatter {
    public abstract virtual string DateHumanize_Now();
    public abstract virtual string DateHumanize_Never();
    public abstract virtual string DateHumanize(TimeUnit timeUnit, Tense timeUnitTense, int unit);
    public abstract virtual string TimeSpanHumanize_Zero();
    public abstract virtual string TimeSpanHumanize(TimeUnit timeUnit, int unit, bool toWords);
    public abstract virtual string DataUnitHumanize(DataUnit dataUnit, double count, bool toSymbol);
    public abstract virtual string TimeUnitHumanize(TimeUnit timeUnit);
}
internal class Humanizer.Localisation.Formatters.MalteseFormatter : DefaultFormatter {
    private static string DualPostfix;
    private static String[] DualResourceKeys;
    public MalteseFormatter(string localeCode);
    private static MalteseFormatter();
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.RomanianFormatter : DefaultFormatter {
    private static int PrepositionIndicatingDecimals;
    private static int MaxNumeralWithNoPreposition;
    private static int MinNumeralWithNoPreposition;
    private static string UnitPreposition;
    private static string RomanianCultureCode;
    private static double Divider;
    private CultureInfo _romanianCulture;
    private static RomanianFormatter();
    protected virtual string Format(string resourceKey, int number, bool toWords);
    private static bool ShouldUsePreposition(int number);
}
internal class Humanizer.Localisation.Formatters.RussianFormatter : DefaultFormatter {
    protected virtual string GetResourceKey(string resourceKey, int number);
    private string GetSuffix(RussianGrammaticalNumber grammaticalNumber);
}
internal class Humanizer.Localisation.Formatters.SerbianFormatter : DefaultFormatter {
    private static string PaucalPostfix;
    public SerbianFormatter(string localeCode);
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.SlovenianFormatter : DefaultFormatter {
    private static string DualPostfix;
    private static string TrialQuadralPostfix;
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.UkrainianFormatter : DefaultFormatter {
    protected virtual string GetResourceKey(string resourceKey, int number);
    private string GetSuffix(RussianGrammaticalNumber grammaticalNumber);
}
internal enum Humanizer.Localisation.GrammaticalNumber.RussianGrammaticalNumber : Enum {
    public int value__;
    public static RussianGrammaticalNumber Singular;
    public static RussianGrammaticalNumber Paucal;
    public static RussianGrammaticalNumber Plural;
}
internal static class Humanizer.Localisation.GrammaticalNumber.RussianGrammaticalNumberDetector : object {
    public static RussianGrammaticalNumber Detect(long number);
}
internal class Humanizer.Localisation.NumberToWords.AfrikaansNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<int, string> OrdinalExceptions;
    private static AfrikaansNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string Convert(int number, bool isOrdinal);
    private static string GetUnitValue(int number, bool isOrdinal);
    private static string RemoveOnePrefix(string toWords);
    private static bool ExceptionNumbersToWords(int number, String& words);
}
internal class Humanizer.Localisation.NumberToWords.ArabicNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] Groups;
    private static String[] AppendedGroups;
    private static String[] PluralGroups;
    private static String[] OnesGroup;
    private static String[] TensGroup;
    private static String[] HundredsGroup;
    private static String[] AppendedTwos;
    private static String[] Twos;
    private static String[] FeminineOnesGroup;
    private static Dictionary`2<string, string> OrdinalExceptions;
    private static Dictionary`2<string, string> FeminineOrdinalExceptions;
    private static ArabicNumberToWordsConverter();
    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static string ParseNumber(string word, int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.ArmenianNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<long, string> OrdinalExceptions;
    private static ArmenianNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string ConvertImpl(long number, bool isOrdinal);
    private static string GetUnitValue(long number, bool isOrdinal);
    private static string RemoveOnePrefix(string toWords);
    private static bool ExceptionNumbersToWords(long number, String& words);
}
internal class Humanizer.Localisation.NumberToWords.AzerbaijaniNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<char, string> OrdinalSuffix;
    private static AzerbaijaniNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.BanglaNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] HundredsMap;
    private static Dictionary`2<int, string> OrdinalExceptions;
    private static BanglaNumberToWordsConverter();
    public virtual string ConvertToOrdinal(int number);
    public virtual string Convert(long input);
    private static bool ExceptionNumbersToWords(int number, String& words);
}
internal class Humanizer.Localisation.NumberToWords.BrazilianPortugueseNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] PortugueseUnitsMap;
    private static String[] PortugueseTensMap;
    private static String[] PortugueseHundredsMap;
    private static String[] PortugueseOrdinalUnitsMap;
    private static String[] PortugueseOrdinalTensMap;
    private static String[] PortugueseOrdinalHundredsMap;
    private static BrazilianPortugueseNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static string ApplyGender(string toWords, GrammaticalGender gender);
    private static string ApplyOrdinalGender(string toWords, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.BulgarianNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] HundredsMap;
    private static String[] HundredsOrdinalMap;
    private static String[] UnitsOrdinal;
    private static BulgarianNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    private string Convert(long input, GrammaticalGender gender, bool isOrdinal, bool addAnd);
    public virtual string ConvertToOrdinal(int input, GrammaticalGender gender);
    private static string GetEndingForGender(GrammaticalGender gender, long input);
}
internal class Humanizer.Localisation.NumberToWords.CentralKurdishNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] KurdishHundredsMap;
    private static String[] KurdishTensMap;
    private static String[] KurdishUnitsMap;
    private static CentralKurdishNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private bool IsVowel(char c);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_0(long n);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_1(long n);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_2(long n);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_3(long n);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_4(long n);
}
internal class Humanizer.Localisation.NumberToWords.ChineseNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static ChineseNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private bool IsSpecial(long number);
    private string Convert(long number, bool isOrdinal, bool isSpecial);
}
internal class Humanizer.Localisation.NumberToWords.CroatianNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private CultureInfo _culture;
    public CroatianNumberToWordsConverter(CultureInfo culture);
    private static CroatianNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    private string Part(string singular, string dual, string trialQuadral, string plural, int number);
}
internal class Humanizer.Localisation.NumberToWords.CzechNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] BillionsMap;
    private static String[] MillionsMap;
    private static String[] ThousandsMap;
    private static String[] HundredsMap;
    private static String[] TensMap;
    private static String[] UnitsMap;
    private static String[] UnitsMasculineOverrideMap;
    private static String[] UnitsFeminineOverrideMap;
    private static String[] UnitsNeuterOverride;
    private static String[] UnitsIntraOverride;
    private CultureInfo _culture;
    public CzechNumberToWordsConverter(CultureInfo culture);
    private static CzechNumberToWordsConverter();
    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private string UnitByGender(long number, Nullable`1<GrammaticalGender> gender);
    private void CollectLessThanThousand(List`1<string> parts, long number, Nullable`1<GrammaticalGender> gender);
    private void CollectThousandAndAbove(List`1<string> parts, Int64& number, long divisor, GrammaticalGender gender, String[] map);
}
internal class Humanizer.Localisation.NumberToWords.DefaultNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private CultureInfo _culture;
    public DefaultNumberToWordsConverter(CultureInfo culture);
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.DutchNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Fact[] Hunderds;
    private static Dictionary`2<string, string> OrdinalExceptions;
    private static Char[] EndingCharForSte;
    private static DutchNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.EnglishNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<long, string> OrdinalExceptions;
    private static EnglishNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string Convert(long number, bool addAnd);
    public virtual string ConvertToOrdinal(int number);
    private string Convert(long number, bool isOrdinal, bool addAnd);
    private static string GetUnitValue(long number, bool isOrdinal);
    private static string RemoveOnePrefix(string toWords);
    private static bool ExceptionNumbersToWords(long number, String& words);
    public virtual string ConvertToTuple(int number);
}
internal class Humanizer.Localisation.NumberToWords.FarsiNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] FarsiHundredsMap;
    private static String[] FarsiTensMap;
    private static String[] FarsiUnitsMap;
    private static FarsiNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_0(int n);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_1(int n);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_2(int n);
}
internal class Humanizer.Localisation.NumberToWords.FinnishNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] OrdinalUnitsMap;
    private static Dictionary`2<int, string> OrdinalExceptions;
    private static FinnishNumberToWordsConverter();
    public virtual string Convert(long input);
    private string GetOrdinalUnit(int number, bool useExceptions);
    private string ToOrdinal(int number, bool useExceptions);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.FrenchBelgianNumberToWordsConverter : FrenchNumberToWordsConverterBase {
    protected virtual void CollectPartsUnderAHundred(ICollection`1<string> parts, Int64& number, GrammaticalGender gender, bool pluralize);
    protected virtual string GetTens(long tens);
}
internal class Humanizer.Localisation.NumberToWords.FrenchNumberToWordsConverter : FrenchNumberToWordsConverterBase {
    protected virtual void CollectPartsUnderAHundred(ICollection`1<string> parts, Int64& number, GrammaticalGender gender, bool pluralize);
    protected virtual string GetTens(long tens);
}
internal abstract class Humanizer.Localisation.NumberToWords.FrenchNumberToWordsConverterBase : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static FrenchNumberToWordsConverterBase();
    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    protected static string GetUnits(long number, GrammaticalGender gender);
    private static void CollectHundreds(ICollection`1<string> parts, Int64& number, long d, string form, bool pluralize);
    private void CollectParts(ICollection`1<string> parts, Int64& number, long d, string form);
    private void CollectPartsUnderAThousand(ICollection`1<string> parts, long number, GrammaticalGender gender, bool pluralize);
    private void CollectThousands(ICollection`1<string> parts, Int64& number, int d, string form);
    protected virtual void CollectPartsUnderAHundred(ICollection`1<string> parts, Int64& number, GrammaticalGender gender, bool pluralize);
    protected virtual string GetTens(long tens);
}
internal class Humanizer.Localisation.NumberToWords.FrenchSwissNumberToWordsConverter : FrenchNumberToWordsConverterBase {
}
internal abstract class Humanizer.Localisation.NumberToWords.GenderedNumberToWordsConverter : object {
    private GrammaticalGender _defaultGender;
    protected GenderedNumberToWordsConverter(GrammaticalGender defaultGender);
    public sealed virtual string Convert(long number);
    public sealed virtual string Convert(long number, WordForm wordForm);
    public sealed virtual string Convert(long number, bool addAnd);
    public sealed virtual string Convert(long number, bool addAnd, WordForm wordForm);
    public abstract virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd);
    public sealed virtual string ConvertToOrdinal(int number);
    public abstract virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    public sealed virtual string ConvertToOrdinal(int number, WordForm wordForm);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender, WordForm wordForm);
    public virtual string ConvertToTuple(int number);
}
internal abstract class Humanizer.Localisation.NumberToWords.GenderlessNumberToWordsConverter : object {
    public abstract virtual string Convert(long number);
    public sealed virtual string Convert(long number, WordForm wordForm);
    public virtual string Convert(long number, bool addAnd);
    public sealed virtual string Convert(long number, bool addAnd, WordForm wordForm);
    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd);
    public abstract virtual string ConvertToOrdinal(int number);
    public sealed virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, WordForm wordForm);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender, WordForm wordForm);
    public virtual string ConvertToTuple(int number);
}
internal class Humanizer.Localisation.NumberToWords.GermanNumberToWordsConverter : GermanNumberToWordsConverterBase {
}
internal abstract class Humanizer.Localisation.NumberToWords.GermanNumberToWordsConverterBase : GenderedNumberToWordsConverter {
    private String[] UnitsMap;
    private String[] TensMap;
    private String[] UnitsOrdinal;
    private String[] HundredOrdinalSingular;
    private String[] HundredOrdinalPlural;
    private String[] ThousandOrdinalSingular;
    private String[] ThousandOrdinalPlural;
    private String[] MillionOrdinalSingular;
    private String[] MillionOrdinalPlural;
    private String[] BillionOrdinalSingular;
    private String[] BillionOrdinalPlural;
    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private void CollectParts(ICollection`1<string> parts, Int64& number, long divisor, bool addSpaceBeforeNextPart, string pluralFormat, string singular);
    private void CollectOrdinalParts(ICollection`1<string> parts, Int32& number, int divisor, bool evaluateNoRest, String[] pluralFormats, String[] singulars);
    private string Part(string pluralFormat, string singular, long number);
    private int NoRestIndex(int number);
    private string GetEndingForGender(GrammaticalGender gender);
    protected virtual string GetTens(long tens);
}
internal class Humanizer.Localisation.NumberToWords.GermanSwissLiechtensteinNumberToWordsConverter : GermanNumberToWordsConverterBase {
    protected virtual string GetTens(long tens);
}
internal class Humanizer.Localisation.NumberToWords.GreekNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private String[] UnitMap;
    private String[] UnitsMap;
    private String[] TensMap;
    private String[] TensNoDiacriticsMap;
    private String[] HundredMap;
    private String[] HundredsMap;
    private static Dictionary`2<long, string> ΟrdinalMap;
    private static GreekNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string GetOneDigitOrdinal(int number);
    private string GetTwoDigigOrdinal(int number);
    private string GetThreeDigitOrdinal(int number);
    private string GetFourDigitOrdinal(int number);
    private string ConvertImpl(long number, bool returnPluralized);
    private string ConvertIntΒ13(long number, bool returnPluralized);
    private string ConvertIntBH(long number, bool returnPluralized);
    private string ConvertIntBT(long number, bool returnPluralized);
    private string ConvertIntBM(long number);
    private string ConvertIntBB(long number);
    private string ConvertIntBTR(long number);
}
internal class Humanizer.Localisation.NumberToWords.HebrewNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsFeminine;
    private static String[] UnitsMasculine;
    private static String[] TensUnit;
    private CultureInfo _culture;
    public HebrewNumberToWordsConverter(CultureInfo culture);
    private static HebrewNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private void ToBigNumber(int number, Group group, List`1<string> parts);
    private void ToThousands(int number, List`1<string> parts);
    private static void ToHundreds(int number, List`1<string> parts);
}
internal class Humanizer.Localisation.NumberToWords.IcelandicNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] FeminineUnitsMap;
    private static String[] MasculineUnitsMap;
    private static String[] NeuterUnitsMap;
    private static String[] TensMap;
    private static String[] UnitsOrdinalPrefixes;
    private static String[] TensOrdinalPrefixes;
    private static string AndSplit;
    private static Dictionary`2<int, Fact> PowerOfTenMap;
    private static IcelandicNumberToWordsConverter();
    private static bool IsAndSplitNeeded(int number);
    private static string GetOrdinalEnding(GrammaticalGender gender);
    private static void GetUnits(ICollection`1<string> builder, long number, GrammaticalGender gender);
    private static void CollectOrdinalParts(ICollection`1<string> builder, int threeDigitPart, Fact conversionRule, GrammaticalGender partGender, GrammaticalGender ordinalGender);
    private static string CollectOrdinalPartsUnderAHundred(int number, GrammaticalGender gender);
    private static void CollectParts(IList`1<string> parts, Int64& number, Boolean& needsAnd, Fact rule);
    private static void CollectPart(ICollection`1<string> parts, long number, Fact rule);
    private static void CollectPartUnderOneThousand(ICollection`1<string> builder, long number, GrammaticalGender gender);
    private static void CollectOrdinal(IList`1<string> parts, Int32& number, Boolean& needsAnd, Fact rule, GrammaticalGender gender);
    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.IndianNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static Dictionary`2<long, string> OrdinalExceptions;
    private static String[] Tillnineteen;
    private static String[] Tens;
    private static IndianNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    public string NumberToText(long number);
    private static bool ExceptionNumbersToWords(long number, String& words);
}
public interface Humanizer.Localisation.NumberToWords.INumberToWordsConverter {
    public abstract virtual string Convert(long number);
    public abstract virtual string Convert(long number, WordForm wordForm);
    public abstract virtual string Convert(long number, bool addAnd);
    public abstract virtual string Convert(long number, bool addAnd, WordForm wordForm);
    public abstract virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public abstract virtual string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd);
    public abstract virtual string ConvertToOrdinal(int number);
    public abstract virtual string ConvertToOrdinal(int number, WordForm wordForm);
    public abstract virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    public abstract virtual string ConvertToOrdinal(int number, GrammaticalGender gender, WordForm wordForm);
    public abstract virtual string ConvertToTuple(int number);
}
internal class Humanizer.Localisation.NumberToWords.Italian.ItalianCardinalNumberCruncher : object {
    protected int _fullNumber;
    protected List`1<int> _threeDigitParts;
    protected GrammaticalGender _gender;
    protected ThreeDigitSets _nextSet;
    protected static String[] _unitsNumberToText;
    protected static String[] _tensOver20NumberToText;
    protected static String[] _teensUnder20NumberToText;
    protected static String[] _hundredNumberToText;
    public ItalianCardinalNumberCruncher(int number, GrammaticalGender gender);
    private static ItalianCardinalNumberCruncher();
    public string Convert();
    protected static List`1<int> SplitEveryThreeDigits(int number);
    public Func`2<int, string> GetNextPartConverter();
    protected static string ThreeDigitSetConverter(int number, bool thisIsLastSet);
    protected string UnitsConverter(int number);
    protected static string ThousandsConverter(int number);
    protected static string MillionsConverter(int number);
    protected static string BillionsConverter(int number);
}
internal class Humanizer.Localisation.NumberToWords.Italian.ItalianOrdinalNumberCruncher : object {
    protected int _fullNumber;
    protected GrammaticalGender _gender;
    private string _genderSuffix;
    protected static String[] _unitsUnder10NumberToText;
    protected static int _lengthOf10AsCardinal;
    public ItalianOrdinalNumberCruncher(int number, GrammaticalGender gender);
    private static ItalianOrdinalNumberCruncher();
    public string Convert();
}
internal class Humanizer.Localisation.NumberToWords.ItalianNumberToWordsConverter : GenderedNumberToWordsConverter {
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.JapaneseNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap1;
    private static String[] UnitsMap2;
    private static String[] UnitsMap3;
    private static JapaneseNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string ConvertImpl(long number, bool isOrdinal);
}
internal class Humanizer.Localisation.NumberToWords.KoreanNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap1;
    private static String[] UnitsMap2;
    private static String[] UnitsMap3;
    private static Dictionary`2<long, string> OrdinalExceptions;
    private static KoreanNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string ConvertImpl(long number, bool isOrdinal);
}
internal class Humanizer.Localisation.NumberToWords.LatvianNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] HundredsMap;
    private static String[] UnitsOrdinal;
    private static LatvianNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int input, GrammaticalGender gender);
    private static string GetOrdinalEndingForGender(GrammaticalGender gender);
    private static string GetCardinalEndingForGender(GrammaticalGender gender, long number);
}
internal class Humanizer.Localisation.NumberToWords.MalteseNumberToWordsConvertor : GenderedNumberToWordsConverter {
    private static String[] OrdinalOverrideMap;
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] HundredsMap;
    private static String[] PrefixMap;
    private static MalteseNumberToWordsConvertor();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static string GetTens(long value, bool usePrefixMap, bool usePrefixMapForLowerDigits, GrammaticalGender gender);
    private static string GetHundreds(long value, bool usePrefixMap, bool usePrefixMapForLowerValueDigits, GrammaticalGender gender);
    private static string GetThousands(long value, GrammaticalGender gender);
    private static string GetMillions(long value, GrammaticalGender gender);
    private static string GetPrefixText(long thousands, long tensInThousands, string singular, string dual, string plural, bool usePrefixMapForLowerValueDigits, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.NorwegianBokmalNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<int, string> OrdinalExceptions;
    private static NorwegianBokmalNumberToWordsConverter();
    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private string Convert(int number, bool isOrdinal, GrammaticalGender gender);
    private static string GetUnitValue(int number, bool isOrdinal);
    private static bool ExceptionNumbersToWords(int number, String& words);
    private string Part(string pluralFormat, string singular, int number, bool postfixSpace);
}
internal class Humanizer.Localisation.NumberToWords.PolishNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] HundredsMap;
    private static String[] TensMap;
    private static String[] UnitsMap;
    private static String[][] PowersOfThousandMap;
    private static long MaxPossibleDivisor;
    private CultureInfo _culture;
    public PolishNumberToWordsConverter(CultureInfo culture);
    private static PolishNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static void CollectParts(ICollection`1<string> parts, long input, GrammaticalGender gender);
    private static void CollectPartsUnderThousand(ICollection`1<string> parts, int number, GrammaticalGender gender);
    private static string GetPowerOfThousandNameForm(int multiplier, int power);
}
internal class Humanizer.Localisation.NumberToWords.PortugueseNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] PortugueseUnitsMap;
    private static String[] PortugueseTensMap;
    private static String[] PortugueseHundredsMap;
    private static String[] PortugueseOrdinalUnitsMap;
    private static String[] PortugueseOrdinalTensMap;
    private static String[] PortugueseOrdinalHundredsMap;
    private static PortugueseNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static string ApplyGender(string toWords, GrammaticalGender gender);
    private static string ApplyOrdinalGender(string toWords, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.Romanian.RomanianCardinalNumberConverter : object {
    private String[] _units;
    private String[] _teensUnder20NumberToText;
    private String[] _tensOver20NumberToText;
    private string _feminineSingular;
    private string _masculineSingular;
    private string _joinGroups;
    private string _joinAbove20;
    private string _minusSign;
    public string Convert(int number, GrammaticalGender gender);
    private List`1<int> SplitEveryThreeDigits(int number);
    private Func`3<int, GrammaticalGender, string> GetNextPartConverter(ThreeDigitSets currentSet);
    private string ThreeDigitSetConverter(int number, GrammaticalGender gender, bool thisIsLastSet);
    private string getPartByGender(string multiGenderPart, GrammaticalGender gender);
    private bool IsAbove20(int number);
    private string HundredsToText(int hundreds);
    private string UnitsConverter(int number, GrammaticalGender gender);
    private string ThousandsConverter(int number, GrammaticalGender gender);
    private string MillionsConverter(int number, GrammaticalGender gender);
    private string BillionsConverter(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.Romanian.RomanianOrdinalNumberConverter : object {
    private Dictionary`2<int, string> _ordinalsUnder10;
    private string _femininePrefix;
    private string _masculinePrefix;
    private string _feminineSuffix;
    private string _masculineSuffix;
    public string Convert(int number, GrammaticalGender gender);
    private string getPartByGender(string multiGenderPart, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.RomanianNumberToWordsConverter : GenderedNumberToWordsConverter {
    public virtual string Convert(long number, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.RussianNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] HundredsMap;
    private static String[] TensMap;
    private static String[] UnitsMap;
    private static String[] UnitsOrdinalPrefixes;
    private static String[] TensOrdinalPrefixes;
    private static String[] TensOrdinal;
    private static String[] UnitsOrdinal;
    private static RussianNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int input, GrammaticalGender gender);
    private static void CollectPartsUnderOneThousand(ICollection`1<string> parts, long number, GrammaticalGender gender);
    private static string GetPrefix(long number);
    private static void CollectParts(ICollection`1<string> parts, Int64& number, long divisor, GrammaticalGender gender, String[] forms);
    private static void CollectOrdinalParts(ICollection`1<string> parts, Int64& number, int divisor, GrammaticalGender gender, string prefixedForm, String[] forms);
    private static int GetIndex(RussianGrammaticalNumber number);
    private static string ChooseOneForGrammaticalNumber(long number, String[] forms);
    private static string GetEndingForGender(GrammaticalGender gender, long number);
}
internal class Humanizer.Localisation.NumberToWords.SerbianCyrlNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private CultureInfo _culture;
    public SerbianCyrlNumberToWordsConverter(CultureInfo culture);
    private static SerbianCyrlNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    private string Part(string singular, string dual, string trialQuadral, string plural, int number);
}
internal class Humanizer.Localisation.NumberToWords.SerbianNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private CultureInfo _culture;
    public SerbianNumberToWordsConverter(CultureInfo culture);
    private static SerbianNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    private string Part(string singular, string dual, string trialQuadral, string plural, int number);
}
internal class Humanizer.Localisation.NumberToWords.SlovenianNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private CultureInfo _culture;
    public SlovenianNumberToWordsConverter(CultureInfo culture);
    private static SlovenianNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    private string Part(string singular, string dual, string trialQuadral, string plural, int number);
}
internal class Humanizer.Localisation.NumberToWords.SpanishNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] HundredsRootMap;
    private static String[] HundredthsRootMap;
    private static String[] OrdinalsRootMap;
    private static String[] TensMap;
    private static String[] TenthsRootMap;
    private static String[] ThousandthsRootMap;
    private static String[] TupleMap;
    private static String[] UnitsMap;
    private static SpanishNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string Convert(long number, WordForm wordForm, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender, WordForm wordForm);
    public virtual string ConvertToTuple(int number);
    private static string BuildWord(IReadOnlyList`1<string> wordParts);
    private static string ConvertHundreds(Int64& inputNumber, Int64& remainder, GrammaticalGender gender);
    private static string ConvertHundredths(Int32& number, Int32& remainder, GrammaticalGender gender);
    private static string ConvertMappedOrdinalNumber(Int32& number, Int32& divisor, IReadOnlyList`1<string> map, Int32& remainder, GrammaticalGender gender);
    private static string ConvertOrdinalUnits(Int32& number, GrammaticalGender gender, WordForm wordForm);
    private static string ConvertTenths(Int32& number, Int32& remainder, GrammaticalGender gender);
    private static string ConvertThousandths(Int32& number, Int32& remainder, GrammaticalGender gender);
    private static string ConvertUnits(long inputNumber, GrammaticalGender gender, WordForm wordForm);
    private static IReadOnlyList`1<string> GetGenderedHundredsMap(GrammaticalGender gender);
    private static string GetGenderedOne(GrammaticalGender gender, WordForm wordForm);
    private static string GetGenderedTwentyOne(GrammaticalGender gender, WordForm wordForm);
    private static bool HasOrdinalAbbreviation(int number, WordForm wordForm);
    private static bool IsRoundBillion(int number);
    private static bool IsRoundMillion(int number);
    private static string PluralizeGreaterThanMillion(string singularWord);
    private string ConvertGreaterThanMillion(Int64& inputNumber, Int64& remainder);
    private string ConvertRoundBillionths(int number, GrammaticalGender gender);
    private string ConvertTensAndHunderdsOfThousandths(Int32& number, Int32& remainder, GrammaticalGender gender);
    private string ConvertThousands(Int64& inputNumber, Int64& remainder, GrammaticalGender gender);
    [CompilerGeneratedAttribute]
internal static bool <ConvertTensAndHunderdsOfThousandths>g__IsRoundNumber|30_0(int number);
}
internal class Humanizer.Localisation.NumberToWords.SwedishNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Fact[] Hunderds;
    private static String[] ordinalNumbers;
    private static SwedishNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.TamilNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] HundredsMap;
    private static String[] ThousandsMap;
    private static String[] LakhsMap;
    private static Dictionary`2<long, string> OrdinalExceptions;
    private static TamilNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string ConvertImpl(long number, bool isOrdinal);
    private static string GetUnitValue(long number, bool isOrdinal);
    private static string GetTensValue(long number, bool isOrdinal, bool isThousand);
    private static string GetLakhsValue(Int64& number, bool isOrdinal);
    private static string GetCroresValue(Int64& number);
    private static string GetThousandsValue(Int64& number);
    private static string GetHundredsValue(Int64& number);
    private static string RemoveOnePrefix(string toWords);
    private static bool ExceptionNumbersToWords(long number, String& words);
}
internal class Humanizer.Localisation.NumberToWords.ThaiNumberToWordsConverter : GenderlessNumberToWordsConverter {
    public virtual string Convert(long numbermoney);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.TurkishNumberToWordConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<char, string> OrdinalSuffix;
    private static Dictionary`2<char, string> TupleSuffix;
    private static TurkishNumberToWordConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    public virtual string ConvertToTuple(int number);
}
internal class Humanizer.Localisation.NumberToWords.UkrainianNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] HundredsMap;
    private static String[] TensMap;
    private static String[] UnitsMap;
    private static String[] UnitsOrdinalPrefixes;
    private static String[] TensOrdinalPrefixes;
    private static String[] TensOrdinal;
    private static String[] UnitsOrdinal;
    private static UkrainianNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender, bool addAnd);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static void CollectPartsUnderOneThousand(ICollection`1<string> parts, long number, GrammaticalGender gender);
    private static string GetPrefix(int number);
    private static void CollectParts(ICollection`1<string> parts, Int64& number, long divisor, GrammaticalGender gender, String[] forms);
    private static void CollectOrdinalParts(ICollection`1<string> parts, Int32& number, int divisor, GrammaticalGender gender, string prefixedForm, String[] forms);
    private static int GetIndex(RussianGrammaticalNumber number);
    private static string ChooseOneForGrammaticalNumber(long number, String[] forms);
    private static string GetEndingForGender(GrammaticalGender gender, int number);
}
internal class Humanizer.Localisation.NumberToWords.UzbekCyrlNumberToWordConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] OrdinalSuffixes;
    private static UzbekCyrlNumberToWordConverter();
    public virtual string Convert(long input);
    private string Convert(int number, bool checkForHoundredRule);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.UzbekLatnNumberToWordConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] OrdinalSuffixes;
    private static UzbekLatnNumberToWordConverter();
    public virtual string Convert(long input);
    private string Convert(int number, bool checkForHoundredRule);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.VietnameseNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static int OneBillion;
    private static int OneMillion;
    private static String[] NumberVerbalPairs;
    private static VietnameseNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string ConvertToOrdinalImpl(int number);
    private static string ConvertImpl(long number, bool hasTens, bool isGreaterThanOneHundred);
}
internal class Humanizer.Localisation.Ordinalizers.ArmenianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
internal class Humanizer.Localisation.Ordinalizers.AzerbaijaniOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
internal class Humanizer.Localisation.Ordinalizers.DefaultOrdinalizer : object {
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, WordForm wordForm);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender, WordForm wordForm);
}
internal class Humanizer.Localisation.Ordinalizers.DutchOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.EnglishOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
internal class Humanizer.Localisation.Ordinalizers.FrenchOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.GermanOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
internal class Humanizer.Localisation.Ordinalizers.IcelandicOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
public interface Humanizer.Localisation.Ordinalizers.IOrdinalizer {
    public abstract virtual string Convert(int number, string numberString);
    public abstract virtual string Convert(int number, string numberString, WordForm wordForm);
    public abstract virtual string Convert(int number, string numberString, GrammaticalGender gender);
    public abstract virtual string Convert(int number, string numberString, GrammaticalGender gender, WordForm wordForm);
}
internal class Humanizer.Localisation.Ordinalizers.ItalianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.PortugueseOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.RomanianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.RussianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.SpanishOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender, WordForm wordForm);
    private static string GetNumberString(int number);
    private static string GetWordForm(int number, WordForm wordForm);
}
internal class Humanizer.Localisation.Ordinalizers.TurkishOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
internal class Humanizer.Localisation.Ordinalizers.UkrainianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
public class Humanizer.Localisation.ResourceKeys : object {
    private static string Single;
    private static string Multiple;
    private static void ValidateRange(int count);
}
public static class Humanizer.Localisation.Resources : object {
    private static ResourceManager ResourceManager;
    private static Resources();
    public static string GetResource(string resourceKey, CultureInfo culture);
}
public enum Humanizer.Localisation.Tense : Enum {
    public int value__;
    public static Tense Future;
    public static Tense Past;
}
internal class Humanizer.Localisation.TimeToClockNotation.BrazilianPortugueseTimeOnlyToClockNotationConverter : object {
    public virtual string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive);
}
internal class Humanizer.Localisation.TimeToClockNotation.DefaultTimeOnlyToClockNotationConverter : object {
    public virtual string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive);
}
internal class Humanizer.Localisation.TimeToClockNotation.EsTimeOnlyToClockNotationConverter : object {
    private static int MORNING;
    private static int NOON;
    private static int AFTERNOON;
    public sealed virtual string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive);
    private static int NormalizeHour(TimeOnly time);
    private static string GetArticle(TimeOnly time);
    private static string GetDayPeriod(TimeOnly time);
    private static bool IsEarlyMorning(TimeOnly time);
    private static bool IsMorning(TimeOnly time);
    private static bool IsAfternoon(TimeOnly time);
}
internal class Humanizer.Localisation.TimeToClockNotation.FrTimeOnlyToClockNotationConverter : object {
    public virtual string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive);
    [CompilerGeneratedAttribute]
internal static string <Convert>g__GetHourExpression|0_0(int hour);
}
public interface Humanizer.Localisation.TimeToClockNotation.ITimeOnlyToClockNotationConverter {
    public abstract virtual string Convert(TimeOnly time, ClockNotationRounding roundToNearestFive);
}
public enum Humanizer.Localisation.TimeUnit : Enum {
    public int value__;
    public static TimeUnit Millisecond;
    public static TimeUnit Second;
    public static TimeUnit Minute;
    public static TimeUnit Hour;
    public static TimeUnit Day;
    public static TimeUnit Week;
    public static TimeUnit Month;
    public static TimeUnit Year;
}
[ExtensionAttribute]
public static class Humanizer.MetricNumeralExtensions : object {
    private static double BigLimit;
    private static double SmallLimit;
    private static List`1[] Symbols;
    private static Dictionary`2<char, UnitPrefix> UnitPrefixes;
    private static MetricNumeralExtensions();
    [ExtensionAttribute]
public static double FromMetric(string input);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use overload with MetricNumeralFormats")]
public static string ToMetric(int input, bool hasSpace, bool useSymbol, Nullable`1<int> decimals);
    [ExtensionAttribute]
public static string ToMetric(int input, Nullable`1<MetricNumeralFormats> formats, Nullable`1<int> decimals);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use overload with MetricNumeralFormats")]
public static string ToMetric(double input, bool hasSpace, bool useSymbol, Nullable`1<int> decimals);
    [ExtensionAttribute]
public static string ToMetric(double input, Nullable`1<MetricNumeralFormats> formats, Nullable`1<int> decimals);
    private static string CleanRepresentation(string input);
    private static double BuildNumber(string input, char last);
    private static double BuildMetricNumber(string input, char last);
    private static string ReplaceNameBySymbol(string input);
    private static string BuildRepresentation(double input, Nullable`1<MetricNumeralFormats> formats, Nullable`1<int> decimals);
    private static string BuildMetricRepresentation(double input, int exponent, Nullable`1<MetricNumeralFormats> formats, Nullable`1<int> decimals);
    private static string GetUnitText(char symbol, Nullable`1<MetricNumeralFormats> formats);
    [ExtensionAttribute]
private static bool IsOutOfRange(double input);
    [ExtensionAttribute]
private static bool IsInvalidMetricNumeral(string input);
    [CompilerGeneratedAttribute]
internal static double <BuildMetricNumber>g__getExponent|12_0(List`1<char> symbols, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsOutOfRange>g__outside|17_0(double min, double max, <>c__DisplayClass17_0& );
}
[FlagsAttribute]
public enum Humanizer.MetricNumeralFormats : Enum {
    public int value__;
    public static MetricNumeralFormats UseLongScaleWord;
    public static MetricNumeralFormats UseName;
    public static MetricNumeralFormats UseShortScaleWord;
    public static MetricNumeralFormats WithSpace;
}
public class Humanizer.NoMatchFoundException : Exception {
    public NoMatchFoundException(string message);
    public NoMatchFoundException(string message, Exception inner);
}
[ExtensionAttribute]
public static class Humanizer.NumberToNumberExtensions : object {
    [ExtensionAttribute]
public static int Tens(int input);
    [ExtensionAttribute]
public static UInt32 Tens(UInt32 input);
    [ExtensionAttribute]
public static long Tens(long input);
    [ExtensionAttribute]
public static ulong Tens(ulong input);
    [ExtensionAttribute]
public static double Tens(double input);
    [ExtensionAttribute]
public static int Hundreds(int input);
    [ExtensionAttribute]
public static UInt32 Hundreds(UInt32 input);
    [ExtensionAttribute]
public static long Hundreds(long input);
    [ExtensionAttribute]
public static ulong Hundreds(ulong input);
    [ExtensionAttribute]
public static double Hundreds(double input);
    [ExtensionAttribute]
public static int Thousands(int input);
    [ExtensionAttribute]
public static UInt32 Thousands(UInt32 input);
    [ExtensionAttribute]
public static long Thousands(long input);
    [ExtensionAttribute]
public static ulong Thousands(ulong input);
    [ExtensionAttribute]
public static double Thousands(double input);
    [ExtensionAttribute]
public static int Millions(int input);
    [ExtensionAttribute]
public static UInt32 Millions(UInt32 input);
    [ExtensionAttribute]
public static long Millions(long input);
    [ExtensionAttribute]
public static ulong Millions(ulong input);
    [ExtensionAttribute]
public static double Millions(double input);
    [ExtensionAttribute]
public static int Billions(int input);
    [ExtensionAttribute]
public static UInt32 Billions(UInt32 input);
    [ExtensionAttribute]
public static long Billions(long input);
    [ExtensionAttribute]
public static ulong Billions(ulong input);
    [ExtensionAttribute]
public static double Billions(double input);
}
[ExtensionAttribute]
public static class Humanizer.NumberToTimeSpanExtensions : object {
    [ExtensionAttribute]
public static TimeSpan Milliseconds(byte ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(sbyte ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(short ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(ushort ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(int ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(UInt32 ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(long ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(ulong ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(double ms);
    [ExtensionAttribute]
public static TimeSpan Seconds(byte seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(sbyte seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(short seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(ushort seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(int seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(UInt32 seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(long seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(ulong seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(double seconds);
    [ExtensionAttribute]
public static TimeSpan Minutes(byte minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(sbyte minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(short minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(ushort minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(int minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(UInt32 minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(long minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(ulong minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(double minutes);
    [ExtensionAttribute]
public static TimeSpan Hours(byte hours);
    [ExtensionAttribute]
public static TimeSpan Hours(sbyte hours);
    [ExtensionAttribute]
public static TimeSpan Hours(short hours);
    [ExtensionAttribute]
public static TimeSpan Hours(ushort hours);
    [ExtensionAttribute]
public static TimeSpan Hours(int hours);
    [ExtensionAttribute]
public static TimeSpan Hours(UInt32 hours);
    [ExtensionAttribute]
public static TimeSpan Hours(long hours);
    [ExtensionAttribute]
public static TimeSpan Hours(ulong hours);
    [ExtensionAttribute]
public static TimeSpan Hours(double hours);
    [ExtensionAttribute]
public static TimeSpan Days(byte days);
    [ExtensionAttribute]
public static TimeSpan Days(sbyte days);
    [ExtensionAttribute]
public static TimeSpan Days(short days);
    [ExtensionAttribute]
public static TimeSpan Days(ushort days);
    [ExtensionAttribute]
public static TimeSpan Days(int days);
    [ExtensionAttribute]
public static TimeSpan Days(UInt32 days);
    [ExtensionAttribute]
public static TimeSpan Days(long days);
    [ExtensionAttribute]
public static TimeSpan Days(ulong days);
    [ExtensionAttribute]
public static TimeSpan Days(double days);
    [ExtensionAttribute]
public static TimeSpan Weeks(byte input);
    [ExtensionAttribute]
public static TimeSpan Weeks(sbyte input);
    [ExtensionAttribute]
public static TimeSpan Weeks(short input);
    [ExtensionAttribute]
public static TimeSpan Weeks(ushort input);
    [ExtensionAttribute]
public static TimeSpan Weeks(int input);
    [ExtensionAttribute]
public static TimeSpan Weeks(UInt32 input);
    [ExtensionAttribute]
public static TimeSpan Weeks(long input);
    [ExtensionAttribute]
public static TimeSpan Weeks(ulong input);
    [ExtensionAttribute]
public static TimeSpan Weeks(double input);
}
[ExtensionAttribute]
public static class Humanizer.NumberToWordsExtension : object {
    [ExtensionAttribute]
public static string ToOrdinalWords(int number, CultureInfo culture);
    [ExtensionAttribute]
public static string ToOrdinalWords(int number, WordForm wordForm, CultureInfo culture);
    [ExtensionAttribute]
public static string ToOrdinalWords(int number, GrammaticalGender gender, CultureInfo culture);
    [ExtensionAttribute]
public static string ToOrdinalWords(int number, GrammaticalGender gender, WordForm wordForm, CultureInfo culture);
    [ExtensionAttribute]
public static string ToTuple(int number, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(int number, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(int number, WordForm wordForm, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(int number, bool addAnd, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(int number, bool addAnd, WordForm wordForm, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(int number, GrammaticalGender gender, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(int number, WordForm wordForm, GrammaticalGender gender, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(long number, CultureInfo culture, bool addAnd);
    [ExtensionAttribute]
public static string ToWords(long number, WordForm wordForm, CultureInfo culture, bool addAnd);
    [ExtensionAttribute]
public static string ToWords(long number, GrammaticalGender gender, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(long number, WordForm wordForm, GrammaticalGender gender, CultureInfo culture);
}
public class Humanizer.On : object {
}
public class Humanizer.OnDate : object {
}
public enum Humanizer.OnNoMatch : Enum {
    public int value__;
    public static OnNoMatch ThrowsException;
    public static OnNoMatch ReturnsNull;
}
[ExtensionAttribute]
public static class Humanizer.OrdinalizeExtensions : object {
    [ExtensionAttribute]
public static string Ordinalize(string numberString);
    [ExtensionAttribute]
public static string Ordinalize(string numberString, WordForm wordForm);
    [ExtensionAttribute]
public static string Ordinalize(string numberString, CultureInfo culture);
    [ExtensionAttribute]
public static string Ordinalize(string numberString, CultureInfo culture, WordForm wordForm);
    [ExtensionAttribute]
public static string Ordinalize(string numberString, GrammaticalGender gender);
    [ExtensionAttribute]
public static string Ordinalize(string numberString, GrammaticalGender gender, WordForm wordForm);
    [ExtensionAttribute]
public static string Ordinalize(string numberString, GrammaticalGender gender, CultureInfo culture);
    [ExtensionAttribute]
public static string Ordinalize(string numberString, GrammaticalGender gender, CultureInfo culture, WordForm wordForm);
    [ExtensionAttribute]
public static string Ordinalize(int number);
    [ExtensionAttribute]
public static string Ordinalize(int number, WordForm wordForm);
    [ExtensionAttribute]
public static string Ordinalize(int number, CultureInfo culture);
    [ExtensionAttribute]
public static string Ordinalize(int number, CultureInfo culture, WordForm wordForm);
    [ExtensionAttribute]
public static string Ordinalize(int number, GrammaticalGender gender);
    [ExtensionAttribute]
public static string Ordinalize(int number, GrammaticalGender gender, WordForm wordForm);
    [ExtensionAttribute]
public static string Ordinalize(int number, GrammaticalGender gender, CultureInfo culture);
    [ExtensionAttribute]
public static string Ordinalize(int number, GrammaticalGender gender, CultureInfo culture, WordForm wordForm);
}
public enum Humanizer.Plurality : Enum {
    public int value__;
    public static Plurality Singular;
    public static Plurality Plural;
    public static Plurality CouldBeEither;
}
[ExtensionAttribute]
public static class Humanizer.PrepositionsExtensions : object {
    [ExtensionAttribute]
public static DateTime At(DateTime date, int hour, int min, int second, int millisecond);
    [ExtensionAttribute]
public static DateTime AtMidnight(DateTime date);
    [ExtensionAttribute]
public static DateTime AtNoon(DateTime date);
    [ExtensionAttribute]
public static DateTime In(DateTime date, int year);
}
internal static class Humanizer.RegexOptionsUtil : object {
    [CompilerGeneratedAttribute]
private static RegexOptions <Compiled>k__BackingField;
    public static RegexOptions Compiled { get; }
    private static RegexOptionsUtil();
    [CompilerGeneratedAttribute]
public static RegexOptions get_Compiled();
}
[ExtensionAttribute]
public static class Humanizer.RomanNumeralExtensions : object {
    private static int NumberOfRomanNumeralMaps;
    private static IDictionary`2<string, int> RomanNumerals;
    private static Regex ValidRomanNumeral;
    private static RomanNumeralExtensions();
    [ExtensionAttribute]
public static int FromRoman(string input);
    [ExtensionAttribute]
public static string ToRoman(int input);
    private static bool IsInvalidRomanNumeral(string input);
}
public enum Humanizer.ShowQuantityAs : Enum {
    public int value__;
    public static ShowQuantityAs None;
    public static ShowQuantityAs Numeric;
    public static ShowQuantityAs Words;
}
[ExtensionAttribute]
public static class Humanizer.StringDehumanizeExtensions : object {
    [ExtensionAttribute]
public static string Dehumanize(string input);
}
[ExtensionAttribute]
public static class Humanizer.StringExtensions : object {
    [ExtensionAttribute]
public static string FormatWith(string format, Object[] args);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, Object[] args);
}
[ExtensionAttribute]
public static class Humanizer.StringHumanizeExtensions : object {
    private static Regex PascalCaseWordPartsRegex;
    private static Regex FreestandingSpacingCharRegex;
    private static StringHumanizeExtensions();
    private static string FromUnderscoreDashSeparatedWords(string input);
    private static string FromPascalCase(string input);
    [ExtensionAttribute]
public static string Humanize(string input);
    [ExtensionAttribute]
public static string Humanize(string input, LetterCasing casing);
}
[ExtensionAttribute]
public static class Humanizer.TimeOnlyToClockNotationExtensions : object {
    [ExtensionAttribute]
public static string ToClockNotation(TimeOnly input, ClockNotationRounding roundToNearestFive);
}
[ExtensionAttribute]
public static class Humanizer.TimeSpanHumanizeExtensions : object {
    private static int _daysInAWeek;
    private static double _daysInAYear;
    private static double _daysInAMonth;
    [ExtensionAttribute]
public static string Humanize(TimeSpan timeSpan, int precision, CultureInfo culture, TimeUnit maxUnit, TimeUnit minUnit, string collectionSeparator, bool toWords);
    [ExtensionAttribute]
public static string Humanize(TimeSpan timeSpan, int precision, bool countEmptyUnits, CultureInfo culture, TimeUnit maxUnit, TimeUnit minUnit, string collectionSeparator, bool toWords);
    private static IEnumerable`1<string> CreateTheTimePartsWithUpperAndLowerLimits(TimeSpan timespan, CultureInfo culture, TimeUnit maxUnit, TimeUnit minUnit, bool toWords);
    private static IEnumerable`1<TimeUnit> GetEnumTypesForTimeUnit();
    private static string GetTimeUnitPart(TimeUnit timeUnitToGet, TimeSpan timespan, TimeUnit maximumTimeUnit, TimeUnit minimumTimeUnit, IFormatter cultureFormatter, bool toWords);
    private static int GetTimeUnitNumericalValue(TimeUnit timeUnitToGet, TimeSpan timespan, TimeUnit maximumTimeUnit);
    private static int GetSpecialCaseMonthAsInteger(TimeSpan timespan, bool isTimeUnitToGetTheMaximumTimeUnit);
    private static int GetSpecialCaseYearAsInteger(TimeSpan timespan);
    private static int GetSpecialCaseWeeksAsInteger(TimeSpan timespan, bool isTimeUnitToGetTheMaximumTimeUnit);
    private static int GetSpecialCaseDaysAsInteger(TimeSpan timespan, TimeUnit maximumTimeUnit);
    private static int GetNormalCaseTimeAsInteger(int timeNumberOfUnits, double totalTimeNumberOfUnits, bool isTimeUnitToGetTheMaximumTimeUnit);
    private static string BuildFormatTimePart(IFormatter cultureFormatter, TimeUnit timeUnitType, int amountOfTimeUnits, bool toWords);
    private static List`1<string> CreateTimePartsWithNoTimeValue(string noTimeValue);
    private static bool IsContainingOnlyNullValue(IEnumerable`1<string> timeParts);
    private static IEnumerable`1<string> SetPrecisionOfTimeSpan(IEnumerable`1<string> timeParts, int precision, bool countEmptyUnits);
    private static string ConcatenateTimeSpanParts(IEnumerable`1<string> timeSpanParts, CultureInfo culture, string collectionSeparator);
}
[ExtensionAttribute]
public static class Humanizer.TimeUnitToSymbolExtensions : object {
    [ExtensionAttribute]
public static string ToSymbol(TimeUnit unit, CultureInfo culture);
}
[ExtensionAttribute]
public static class Humanizer.To : object {
    public static ICulturedStringTransformer TitleCase { get; }
    public static ICulturedStringTransformer LowerCase { get; }
    public static ICulturedStringTransformer UpperCase { get; }
    public static ICulturedStringTransformer SentenceCase { get; }
    [ExtensionAttribute]
public static string Transform(string input, IStringTransformer[] transformers);
    [ExtensionAttribute]
public static string Transform(string input, CultureInfo culture, ICulturedStringTransformer[] transformers);
    public static ICulturedStringTransformer get_TitleCase();
    public static ICulturedStringTransformer get_LowerCase();
    public static ICulturedStringTransformer get_UpperCase();
    public static ICulturedStringTransformer get_SentenceCase();
}
internal class Humanizer.ToLowerCase : object {
    public sealed virtual string Transform(string input);
    public sealed virtual string Transform(string input, CultureInfo culture);
}
[ExtensionAttribute]
public static class Humanizer.ToQuantityExtensions : object {
    [ExtensionAttribute]
public static string ToQuantity(string input, int quantity, ShowQuantityAs showQuantityAs);
    [ExtensionAttribute]
public static string ToQuantity(string input, int quantity, string format, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static string ToQuantity(string input, long quantity, ShowQuantityAs showQuantityAs);
    [ExtensionAttribute]
public static string ToQuantity(string input, long quantity, string format, IFormatProvider formatProvider);
    [ExtensionAttribute]
private static string ToQuantity(string input, long quantity, ShowQuantityAs showQuantityAs, string format, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static string ToQuantity(string input, double quantity, string format, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static string ToQuantity(string input, double quantity);
}
internal class Humanizer.ToSentenceCase : object {
    public sealed virtual string Transform(string input);
    public sealed virtual string Transform(string input, CultureInfo culture);
}
internal class Humanizer.ToTitleCase : object {
    public sealed virtual string Transform(string input);
    public sealed virtual string Transform(string input, CultureInfo culture);
    private static bool AllCapitals(string input);
    private static string ReplaceWithTitleCase(Match word, string source, CultureInfo culture, bool firstWord);
}
internal class Humanizer.ToUpperCase : object {
    public sealed virtual string Transform(string input);
    public sealed virtual string Transform(string input, CultureInfo culture);
}
[ExtensionAttribute]
public static class Humanizer.TruncateExtensions : object {
    [ExtensionAttribute]
public static string Truncate(string input, int length);
    [ExtensionAttribute]
public static string Truncate(string input, int length, ITruncator truncator, TruncateFrom from);
    [ExtensionAttribute]
public static string Truncate(string input, int length, string truncationString, TruncateFrom from);
    [ExtensionAttribute]
public static string Truncate(string input, int length, string truncationString, ITruncator truncator, TruncateFrom from);
}
public enum Humanizer.TruncateFrom : Enum {
    public int value__;
    public static TruncateFrom Left;
    public static TruncateFrom Right;
}
public static class Humanizer.Truncator : object {
    public static ITruncator FixedLength { get; }
    public static ITruncator FixedNumberOfCharacters { get; }
    public static ITruncator FixedNumberOfWords { get; }
    public static ITruncator get_FixedLength();
    public static ITruncator get_FixedNumberOfCharacters();
    public static ITruncator get_FixedNumberOfWords();
}
[ExtensionAttribute]
public static class Humanizer.TupleizeExtensions : object {
    [ExtensionAttribute]
public static string Tupleize(int input);
}
public enum Humanizer.WordForm : Enum {
    public int value__;
    public static WordForm Normal;
    public static WordForm Abbreviation;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.4.255.64262")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
