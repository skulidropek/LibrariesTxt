internal class Microsoft.ApplicationInsights.Channel.Implementation.BackoffLogicManager : object {
    internal static int SlotDelayInSeconds;
    private static int MaxDelayInSeconds;
    private static int DefaultBackoffEnabledReportingIntervalInMin;
    private static Random Random;
    private static DataContractJsonSerializer Serializer;
    private object lockConsecutiveErrors;
    private TimeSpan minIntervalToUpdateConsecutiveErrors;
    private bool exponentialBackoffReported;
    private int consecutiveErrors;
    private DateTimeOffset nextMinTimeToUpdateConsecutiveErrors;
    [CompilerGeneratedAttribute]
private int <LastStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DefaultBackoffEnabledReportingInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CurrentDelay>k__BackingField;
    public int ConsecutiveErrors { get; }
    public int LastStatusCode { get; private set; }
    public TimeSpan DefaultBackoffEnabledReportingInterval { get; public set; }
    internal TimeSpan CurrentDelay { get; private set; }
    public BackoffLogicManager(TimeSpan defaultBackoffEnabledReportingInterval);
    internal BackoffLogicManager(TimeSpan defaultBackoffEnabledReportingInterval, TimeSpan minIntervalToUpdateConsecutiveErrors);
    private static BackoffLogicManager();
    public int get_ConsecutiveErrors();
    [CompilerGeneratedAttribute]
public int get_LastStatusCode();
    [CompilerGeneratedAttribute]
private void set_LastStatusCode(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DefaultBackoffEnabledReportingInterval();
    [CompilerGeneratedAttribute]
public void set_DefaultBackoffEnabledReportingInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
internal TimeSpan get_CurrentDelay();
    [CompilerGeneratedAttribute]
private void set_CurrentDelay(TimeSpan value);
    public static BackendResponse GetBackendResponse(string responseContent);
    public void ResetConsecutiveErrors();
    public void ReportBackoffEnabled(int statusCode);
    public void ReportBackoffDisabled();
    public TimeSpan GetBackOffTimeInterval(string headerValue);
    protected virtual TimeSpan GetBackOffTime(string headerValue);
    private static bool TryParseRetryAfter(string retryAfter, TimeSpan& retryAfterTimeSpan);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.ApplicationInsights.Extensibility.TelemetryProcessorChainBuilderExtensions : object {
    [ExtensionAttribute]
public static TelemetryProcessorChainBuilder UseSampling(TelemetryProcessorChainBuilder builder, double samplingPercentage, string excludedTypes, string includedTypes);
    [ExtensionAttribute]
public static TelemetryProcessorChainBuilder UseAdaptiveSampling(TelemetryProcessorChainBuilder builder, string excludedTypes, string includedTypes);
    [ExtensionAttribute]
public static TelemetryProcessorChainBuilder UseAdaptiveSampling(TelemetryProcessorChainBuilder builder, double maxTelemetryItemsPerSecond, string excludedTypes, string includedTypes);
    [ExtensionAttribute]
public static TelemetryProcessorChainBuilder UseAdaptiveSampling(TelemetryProcessorChainBuilder builder, SamplingPercentageEstimatorSettings settings, AdaptiveSamplingPercentageEvaluatedCallback callback, string excludedTypes, string includedTypes);
}
public class Microsoft.ApplicationInsights.WindowsServer.Channel.Implementation.AdaptiveSamplingPercentageEvaluatedCallback : MulticastDelegate {
    public AdaptiveSamplingPercentageEvaluatedCallback(object object, IntPtr method);
    public virtual void Invoke(double afterSamplingTelemetryItemRatePerSecond, double currentSamplingPercentage, double newSamplingPercentage, bool isSamplingPercentageChanged, SamplingPercentageEstimatorSettings settings);
    public virtual IAsyncResult BeginInvoke(double afterSamplingTelemetryItemRatePerSecond, double currentSamplingPercentage, double newSamplingPercentage, bool isSamplingPercentageChanged, SamplingPercentageEstimatorSettings settings, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.ApplicationInsights.WindowsServer.Channel.Implementation.SamplingPercentageEstimatorSettings : object {
    private static SamplingPercentageEstimatorSettings default;
    [CompilerGeneratedAttribute]
private double <MaxTelemetryItemsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <InitialSamplingPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinSamplingPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxSamplingPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <EvaluationInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SamplingPercentageDecreaseTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SamplingPercentageIncreaseTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MovingAverageRatio>k__BackingField;
    public double MaxTelemetryItemsPerSecond { get; public set; }
    public double InitialSamplingPercentage { get; public set; }
    public double MinSamplingPercentage { get; public set; }
    public double MaxSamplingPercentage { get; public set; }
    public TimeSpan EvaluationInterval { get; public set; }
    public TimeSpan SamplingPercentageDecreaseTimeout { get; public set; }
    public TimeSpan SamplingPercentageIncreaseTimeout { get; public set; }
    public double MovingAverageRatio { get; public set; }
    internal double EffectiveMaxTelemetryItemsPerSecond { get; }
    internal int EffectiveInitialSamplingRate { get; }
    internal int EffectiveMinSamplingRate { get; }
    internal int EffectiveMaxSamplingRate { get; }
    internal TimeSpan EffectiveEvaluationInterval { get; }
    internal TimeSpan EffectiveSamplingPercentageDecreaseTimeout { get; }
    internal TimeSpan EffectiveSamplingPercentageIncreaseTimeout { get; }
    internal double EffectiveMovingAverageRatio { get; }
    private static SamplingPercentageEstimatorSettings();
    [CompilerGeneratedAttribute]
public double get_MaxTelemetryItemsPerSecond();
    [CompilerGeneratedAttribute]
public void set_MaxTelemetryItemsPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_InitialSamplingPercentage();
    [CompilerGeneratedAttribute]
public void set_InitialSamplingPercentage(double value);
    [CompilerGeneratedAttribute]
public double get_MinSamplingPercentage();
    [CompilerGeneratedAttribute]
public void set_MinSamplingPercentage(double value);
    [CompilerGeneratedAttribute]
public double get_MaxSamplingPercentage();
    [CompilerGeneratedAttribute]
public void set_MaxSamplingPercentage(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_EvaluationInterval();
    [CompilerGeneratedAttribute]
public void set_EvaluationInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SamplingPercentageDecreaseTimeout();
    [CompilerGeneratedAttribute]
public void set_SamplingPercentageDecreaseTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SamplingPercentageIncreaseTimeout();
    [CompilerGeneratedAttribute]
public void set_SamplingPercentageIncreaseTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public double get_MovingAverageRatio();
    [CompilerGeneratedAttribute]
public void set_MovingAverageRatio(double value);
    internal double get_EffectiveMaxTelemetryItemsPerSecond();
    internal int get_EffectiveInitialSamplingRate();
    internal int get_EffectiveMinSamplingRate();
    internal int get_EffectiveMaxSamplingRate();
    internal TimeSpan get_EffectiveEvaluationInterval();
    internal TimeSpan get_EffectiveSamplingPercentageDecreaseTimeout();
    internal TimeSpan get_EffectiveSamplingPercentageIncreaseTimeout();
    internal double get_EffectiveMovingAverageRatio();
    private static double AdjustSamplingPercentage(double samplingPercentage);
}
public class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.AdaptiveSamplingTelemetryProcessor : object {
    private SamplingTelemetryProcessor samplingProcessor;
    private SamplingPercentageEstimatorSettings estimatorSettings;
    private AdaptiveSamplingPercentageEvaluatedCallback evaluationCallback;
    private SamplingPercentageEstimatorTelemetryProcessor estimatorProcessor;
    public string ExcludedTypes { get; public set; }
    public string IncludedTypes { get; public set; }
    public double InitialSamplingPercentage { get; public set; }
    public double MaxTelemetryItemsPerSecond { get; public set; }
    public double MinSamplingPercentage { get; public set; }
    public double MaxSamplingPercentage { get; public set; }
    public TimeSpan EvaluationInterval { get; public set; }
    public TimeSpan SamplingPercentageDecreaseTimeout { get; public set; }
    public TimeSpan SamplingPercentageIncreaseTimeout { get; public set; }
    public double MovingAverageRatio { get; public set; }
    internal SamplingTelemetryProcessor SamplingTelemetryProcessor { get; }
    internal SamplingPercentageEstimatorTelemetryProcessor SamplingPercentageEstimatorTelemetryProcessor { get; }
    public AdaptiveSamplingTelemetryProcessor(ITelemetryProcessor next);
    public AdaptiveSamplingTelemetryProcessor(SamplingPercentageEstimatorSettings settings, AdaptiveSamplingPercentageEvaluatedCallback callback, ITelemetryProcessor next);
    public string get_ExcludedTypes();
    public void set_ExcludedTypes(string value);
    public string get_IncludedTypes();
    public void set_IncludedTypes(string value);
    public double get_InitialSamplingPercentage();
    public void set_InitialSamplingPercentage(double value);
    public double get_MaxTelemetryItemsPerSecond();
    public void set_MaxTelemetryItemsPerSecond(double value);
    public double get_MinSamplingPercentage();
    public void set_MinSamplingPercentage(double value);
    public double get_MaxSamplingPercentage();
    public void set_MaxSamplingPercentage(double value);
    public TimeSpan get_EvaluationInterval();
    public void set_EvaluationInterval(TimeSpan value);
    public TimeSpan get_SamplingPercentageDecreaseTimeout();
    public void set_SamplingPercentageDecreaseTimeout(TimeSpan value);
    public TimeSpan get_SamplingPercentageIncreaseTimeout();
    public void set_SamplingPercentageIncreaseTimeout(TimeSpan value);
    public double get_MovingAverageRatio();
    public void set_MovingAverageRatio(double value);
    internal SamplingTelemetryProcessor get_SamplingTelemetryProcessor();
    internal SamplingPercentageEstimatorTelemetryProcessor get_SamplingPercentageEstimatorTelemetryProcessor();
    public sealed virtual void Process(ITelemetry item);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void SamplingPercentageChanged(double afterSamplingTelemetryItemRatePerSecond, double currentSamplingPercentage, double newSamplingPercentage, bool isSamplingPercentageChanged, SamplingPercentageEstimatorSettings settings);
}
[ObsoleteAttribute("This was a failed experiment. Please use 'Microsoft.ApplicationInsights.WindowsServer.Channel.Implementation.AdaptiveSamplingPercentageEvaluatedCallback' instead.")]
public class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.AdaptiveSamplingPercentageEvaluatedCallback : MulticastDelegate {
    public AdaptiveSamplingPercentageEvaluatedCallback(object object, IntPtr method);
    public virtual void Invoke(double afterSamplingTelemetryItemRatePerSecond, double currentSamplingPercentage, double newSamplingPercentage, bool isSamplingPercentageChanged, SamplingPercentageEstimatorSettings settings);
    public virtual IAsyncResult BeginInvoke(double afterSamplingTelemetryItemRatePerSecond, double currentSamplingPercentage, double newSamplingPercentage, bool isSamplingPercentageChanged, SamplingPercentageEstimatorSettings settings, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.ApplicationFolderProvider : object {
    internal Func`2<DirectoryInfo, bool> ApplySecurityToDirectory;
    private IDictionary environment;
    private string customFolderName;
    private IIdentityProvider identityProvider;
    private string nonWindowsStorageProbePathVarTmp;
    private string nonWindowsStorageProbePathTmp;
    public ApplicationFolderProvider(string folderName);
    internal ApplicationFolderProvider(IDictionary environment, string folderName);
    public sealed virtual IPlatformFolder GetApplicationFolder();
    internal static bool IsWindowsOperatingSystem();
    internal void OverrideApplySecurityToDirectory(Func`2<DirectoryInfo, bool> applySecurityToDirectory);
    private static string GetPathAccessFailureErrorMessage(Exception exp, string path);
    private static void CheckAccessPermissions(DirectoryInfo telemetryDirectory);
    private static string GetSHA256Hash(string input);
    private static SHA256 CreateSHA256();
    private IPlatformFolder CreateAndValidateApplicationFolder(string rootPath, bool createSubFolder, IList`1<string> errors);
    private DirectoryInfo CreateTelemetrySubdirectory(DirectoryInfo root);
    private bool SetSecurityPermissionsToAdminAndCurrentUserNonWindows(DirectoryInfo subdirectory);
    private bool SetSecurityPermissionsToAdminAndCurrentUserWindows(DirectoryInfo subdirectory);
}
public class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.ApplicationStoppingEventArgs : EventArgs {
    internal static ApplicationStoppingEventArgs Empty;
    private Func`2<Func`1<Task>, Task> asyncMethodRunner;
    public ApplicationStoppingEventArgs(Func`2<Func`1<Task>, Task> asyncMethodRunner);
    private static ApplicationStoppingEventArgs();
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.ApplicationStoppingEventArgs/<Run>d__3")]
public void Run(Func`1<Task> asyncMethod);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.AtomicSampledItemsCounter : object {
    private Int64[] proactivelySampledOutItems;
    private Dictionary`2<SamplingTelemetryItemTypes, int> typeToSamplingIndexMap;
    internal void AddItems(SamplingTelemetryItemTypes telemetryItemTypeFlag, long value);
    internal void ClearItems(SamplingTelemetryItemTypes telemetryItemTypeFlag);
    internal long GetItems(SamplingTelemetryItemTypes telemetryItemTypeFlag);
}
[DataContractAttribute]
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.BackendResponse : object {
    [CompilerGeneratedAttribute]
private int <ItemsReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemsAccepted>k__BackingField;
    [CompilerGeneratedAttribute]
private Error[] <Errors>k__BackingField;
    [DataMemberAttribute]
public int ItemsReceived { get; public set; }
    [DataMemberAttribute]
public int ItemsAccepted { get; public set; }
    [DataMemberAttribute]
public Error[] Errors { get; public set; }
    [CompilerGeneratedAttribute]
public int get_ItemsReceived();
    [CompilerGeneratedAttribute]
public void set_ItemsReceived(int value);
    [CompilerGeneratedAttribute]
public int get_ItemsAccepted();
    [CompilerGeneratedAttribute]
public void set_ItemsAccepted(int value);
    [CompilerGeneratedAttribute]
public Error[] get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(Error[] value);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.CurrentThreadTaskScheduler : TaskScheduler {
    public static TaskScheduler Instance;
    public int MaximumConcurrencyLevel { get; }
    private static CurrentThreadTaskScheduler();
    public virtual int get_MaximumConcurrencyLevel();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
}
internal static class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.ExceptionHandler : object {
    public static void Start(Func`1<Task> asyncMethod);
    public static void Start(Func`2<T, Task> asyncMethod, T param1);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.ExponentialMovingAverageCounter : object {
    private Nullable`1<double> average;
    private long current;
    [CompilerGeneratedAttribute]
private double <Coefficient>k__BackingField;
    public double Coefficient { get; private set; }
    public double Average { get; }
    public ExponentialMovingAverageCounter(double coefficient);
    [CompilerGeneratedAttribute]
public double get_Coefficient();
    [CompilerGeneratedAttribute]
private void set_Coefficient(double value);
    public double get_Average();
    public long Increment();
    public double StartNewInterval();
}
internal interface Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.IApplicationFolderProvider {
    public abstract virtual IPlatformFolder GetApplicationFolder();
}
public interface Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.IApplicationLifecycle {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopping(EventHandler`1<ApplicationStoppingEventArgs> value);
}
internal interface Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.INetwork {
    public abstract virtual void AddAddressChangedEventHandler(NetworkAddressChangedEventHandler handler);
    public abstract virtual void RemoveAddressChangeEventHandler(NetworkAddressChangedEventHandler handler);
    public abstract virtual bool IsAvailable();
}
internal interface Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.IPlatformFile {
    public string Name { get; }
    public string Extension { get; }
    public long Length { get; }
    public DateTimeOffset DateCreated { get; }
    public bool Exists { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Extension();
    public abstract virtual long get_Length();
    public abstract virtual DateTimeOffset get_DateCreated();
    public abstract virtual bool get_Exists();
    public abstract virtual void Delete();
    public abstract virtual void Rename(string newName);
    public abstract virtual Stream Open();
}
internal interface Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.IPlatformFolder {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void Delete();
    public abstract virtual bool Exists();
    public abstract virtual IEnumerable`1<IPlatformFile> GetFiles();
    public abstract virtual IPlatformFile CreateFile(string fileName);
}
internal interface Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.IRandomNumberBatchGenerator {
    public abstract virtual void NextBatch(UInt64[] buffer, int index, int count);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.Network : object {
    public sealed virtual void AddAddressChangedEventHandler(NetworkAddressChangedEventHandler handler);
    public sealed virtual void RemoveAddressChangeEventHandler(NetworkAddressChangedEventHandler handler);
    public sealed virtual bool IsAvailable();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.PlatformFile : object {
    private FileInfo file;
    public string Name { get; }
    public string Extension { get; }
    public long Length { get; }
    public DateTimeOffset DateCreated { get; }
    public bool Exists { get; }
    public PlatformFile(FileInfo file);
    public sealed virtual string get_Name();
    public sealed virtual string get_Extension();
    public sealed virtual long get_Length();
    public sealed virtual DateTimeOffset get_DateCreated();
    public sealed virtual bool get_Exists();
    public sealed virtual void Delete();
    public sealed virtual void Rename(string newName);
    public sealed virtual Stream Open();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.PlatformFolder : object {
    private DirectoryInfo folder;
    public string Name { get; }
    internal DirectoryInfo Folder { get; }
    public PlatformFolder(DirectoryInfo folder);
    public sealed virtual string get_Name();
    internal DirectoryInfo get_Folder();
    public sealed virtual bool Exists();
    public sealed virtual void Delete();
    public sealed virtual IEnumerable`1<IPlatformFile> GetFiles();
    public sealed virtual IPlatformFile CreateFile(string fileName);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.ResponseStatusCodes : object {
    public static int Success;
    public static int PartialSuccess;
    public static int RequestTimeout;
    public static int UnknownNetworkError;
    public static int ResponseCodeTooManyRequests;
    public static int ResponseCodeTooManyRequestsOverExtendedTime;
    public static int InternalServerError;
    public static int BadGateway;
    public static int ServiceUnavailable;
    public static int GatewayTimeout;
    public static int BadRequest;
    public static int Unauthorized;
    public static int Forbidden;
}
internal static class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.SamplingInternals.SamplingIncludesUtility : object {
    private static string DependencyTelemetryName;
    private static string EventTelemetryName;
    private static string ExceptionTelemetryName;
    private static string PageViewTelemetryName;
    private static string RequestTelemetryName;
    private static string TraceTelemetryName;
    private static Char[] ListSeparators;
    private static SamplingIncludesUtility();
    public static SamplingTelemetryItemTypes CalculateFromIncludes(string includesString);
    public static SamplingTelemetryItemTypes CalculateFromExcludes(string excludesString);
    private static IDictionary`2<string, SamplingTelemetryItemTypes> GetAllowedTypes();
    private static SamplingTelemetryItemTypes Calculate(Func`3<SamplingTelemetryItemTypes, SamplingTelemetryItemTypes, SamplingTelemetryItemTypes> operation, SamplingTelemetryItemTypes flags, string input);
    private static String[] SplitInput(string input);
    private static SamplingTelemetryItemTypes IncludeOperator(SamplingTelemetryItemTypes flags, SamplingTelemetryItemTypes value);
    private static SamplingTelemetryItemTypes ExcludeOperator(SamplingTelemetryItemTypes flags, SamplingTelemetryItemTypes value);
}
[ObsoleteAttribute("This was a failed experiment. Please use 'Microsoft.ApplicationInsights.WindowsServer.Channel.Implementation.SamplingPercentageEstimatorSettings' instead.")]
public class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.SamplingPercentageEstimatorSettings : object {
    private static SamplingPercentageEstimatorSettings default;
    [CompilerGeneratedAttribute]
private double <MaxTelemetryItemsPerSecond>k__BackingField;
    [CompilerGeneratedAttribute]
private double <InitialSamplingPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinSamplingPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxSamplingPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <EvaluationInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SamplingPercentageDecreaseTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SamplingPercentageIncreaseTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MovingAverageRatio>k__BackingField;
    public double MaxTelemetryItemsPerSecond { get; public set; }
    public double InitialSamplingPercentage { get; public set; }
    public double MinSamplingPercentage { get; public set; }
    public double MaxSamplingPercentage { get; public set; }
    public TimeSpan EvaluationInterval { get; public set; }
    public TimeSpan SamplingPercentageDecreaseTimeout { get; public set; }
    public TimeSpan SamplingPercentageIncreaseTimeout { get; public set; }
    public double MovingAverageRatio { get; public set; }
    internal double EffectiveMaxTelemetryItemsPerSecond { get; }
    internal int EffectiveInitialSamplingRate { get; }
    internal int EffectiveMinSamplingRate { get; }
    internal int EffectiveMaxSamplingRate { get; }
    internal TimeSpan EffectiveEvaluationInterval { get; }
    internal TimeSpan EffectiveSamplingPercentageDecreaseTimeout { get; }
    internal TimeSpan EffectiveSamplingPercentageIncreaseTimeout { get; }
    internal double EffectiveMovingAverageRatio { get; }
    private static SamplingPercentageEstimatorSettings();
    [CompilerGeneratedAttribute]
public double get_MaxTelemetryItemsPerSecond();
    [CompilerGeneratedAttribute]
public void set_MaxTelemetryItemsPerSecond(double value);
    [CompilerGeneratedAttribute]
public double get_InitialSamplingPercentage();
    [CompilerGeneratedAttribute]
public void set_InitialSamplingPercentage(double value);
    [CompilerGeneratedAttribute]
public double get_MinSamplingPercentage();
    [CompilerGeneratedAttribute]
public void set_MinSamplingPercentage(double value);
    [CompilerGeneratedAttribute]
public double get_MaxSamplingPercentage();
    [CompilerGeneratedAttribute]
public void set_MaxSamplingPercentage(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_EvaluationInterval();
    [CompilerGeneratedAttribute]
public void set_EvaluationInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SamplingPercentageDecreaseTimeout();
    [CompilerGeneratedAttribute]
public void set_SamplingPercentageDecreaseTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SamplingPercentageIncreaseTimeout();
    [CompilerGeneratedAttribute]
public void set_SamplingPercentageIncreaseTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public double get_MovingAverageRatio();
    [CompilerGeneratedAttribute]
public void set_MovingAverageRatio(double value);
    internal double get_EffectiveMaxTelemetryItemsPerSecond();
    internal int get_EffectiveInitialSamplingRate();
    internal int get_EffectiveMinSamplingRate();
    internal int get_EffectiveMaxSamplingRate();
    internal TimeSpan get_EffectiveEvaluationInterval();
    internal TimeSpan get_EffectiveSamplingPercentageDecreaseTimeout();
    internal TimeSpan get_EffectiveSamplingPercentageIncreaseTimeout();
    internal double get_EffectiveMovingAverageRatio();
    private static double AdjustSamplingPercentage(double samplingPercentage);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.SamplingPercentageEstimatorTelemetryProcessor : object {
    private ITelemetryProcessor next;
    private SamplingPercentageEstimatorSettings settings;
    private ExponentialMovingAverageCounter itemCount;
    private ExponentialMovingAverageCounter proactivelySampledInCount;
    private Timer evaluationTimer;
    private TimeSpan evaluationInterval;
    private DateTimeOffset samplingPercentageLastChangeDateTime;
    private AdaptiveSamplingPercentageEvaluatedCallback evaluationCallback;
    [CompilerGeneratedAttribute]
private int <CurrentSamplingRate>k__BackingField;
    [CompilerGeneratedAttribute]
private double <CurrentProactiveSamplingRate>k__BackingField;
    internal int CurrentSamplingRate { get; internal set; }
    internal double CurrentProactiveSamplingRate { get; private set; }
    public SamplingPercentageEstimatorTelemetryProcessor(ITelemetryProcessor next);
    public SamplingPercentageEstimatorTelemetryProcessor(SamplingPercentageEstimatorSettings settings, AdaptiveSamplingPercentageEvaluatedCallback callback, ITelemetryProcessor next);
    [CompilerGeneratedAttribute]
internal int get_CurrentSamplingRate();
    [CompilerGeneratedAttribute]
internal void set_CurrentSamplingRate(int value);
    [CompilerGeneratedAttribute]
internal double get_CurrentProactiveSamplingRate();
    [CompilerGeneratedAttribute]
private void set_CurrentProactiveSamplingRate(double value);
    public sealed virtual void Process(ITelemetry item);
    public sealed virtual void Dispose();
    private static bool MovingAverageCoefficientChanged(double running, double current);
    private void Dispose(bool disposing);
    private void EstimateSamplingPercentage(object state);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TaskTimerInternal : object {
    public static TimeSpan InfiniteTimeSpan;
    private TimeSpan delay;
    private CancellationTokenSource tokenSource;
    public TimeSpan Delay { get; public set; }
    public bool IsStarted { get; }
    private static TaskTimerInternal();
    public TimeSpan get_Delay();
    public void set_Delay(TimeSpan value);
    public bool get_IsStarted();
    public void Start(Func`1<Task> elapsed);
    public void Cancel();
    public sealed virtual void Dispose();
    private static void LogException(Exception exception);
    private static void CancelAndDispose(CancellationTokenSource tokenSource);
    private void Dispose(bool disposing);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TelemetryBuffer : object {
    private static TimeSpan DefaultFlushDelay;
    private TaskTimerInternal flushTimer;
    private TelemetrySerializer serializer;
    private int capacity;
    private int backlogSize;
    private int minimumBacklogSize;
    private bool itemDroppedMessageLogged;
    private List`1<ITelemetry> itemBuffer;
    public int Capacity { get; public set; }
    public int BacklogSize { get; public set; }
    public TimeSpan MaxTransmissionDelay { get; public set; }
    public TelemetryBuffer(TelemetrySerializer serializer, IApplicationLifecycle applicationLifecycle);
    private static TelemetryBuffer();
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_BacklogSize();
    public void set_BacklogSize(int value);
    public TimeSpan get_MaxTransmissionDelay();
    public void set_MaxTransmissionDelay(TimeSpan value);
    public sealed virtual void Dispose();
    public virtual void Process(ITelemetry item);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TelemetryBuffer/<FlushAsync>d__21")]
public virtual Task FlushAsync();
    public virtual Task`1<bool> FlushAsync(CancellationToken cancellationToken);
    public sealed virtual IEnumerator`1<ITelemetry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private List`1<ITelemetry> GetBufferTelemetryAndResetBuffer();
    private void HandleApplicationStoppingEvent(object sender, ApplicationStoppingEventArgs e);
    private void Dispose(bool disposing);
}
[EventSourceAttribute]
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TelemetryChannelEventSource : EventSource {
    public static TelemetryChannelEventSource Log;
    public string ApplicationName;
    public static bool IsVerboseEnabled { get; }
    private static TelemetryChannelEventSource();
    [NonEventAttribute]
public static bool get_IsVerboseEnabled();
    [EventAttribute("1")]
public void BackoffDisabled(string appDomainName);
    [EventAttribute("2")]
public void BackoffEnabled(double intervalInMin, int statusCode, string appDomainName);
    [EventAttribute("3")]
public void SamplingSkippedByType(string telemetryType, string appDomainName);
    [EventAttribute("4")]
public void BackoffInterval(double intervalInSec, string appDomainName);
    [EventAttribute("5")]
public void BreezeResponseWasNotParsedWarning(string exception, string response, string appDomainName);
    [EventAttribute("6")]
public void UnexpectedBreezeResponseWarning(int size, int index, string appDomainName);
    [EventAttribute("7")]
public void ItemRejectedByEndpointWarning(string message, string appDomainName);
    [EventAttribute("8")]
public void SamplingCallbackError(string exception, string appDomainName);
    [EventAttribute("9")]
public void SamplingChanged(double interval, string appDomainName);
    [EventAttribute("10")]
public void ItemSampledOut(string telemetryType, string appDomainName);
    [EventAttribute("11")]
public void StorageFolder(string folder, string appDomainName);
    [EventAttribute("12")]
public void BufferEnqueued(string transmissionId, int transmissionCount, string appDomainName);
    [EventAttribute("13")]
public void BufferEnqueueNoCapacityWarning(long size, int capacity, string appDomainName);
    [EventAttribute("14")]
public void UnauthorizedAccessExceptionOnTransmissionSaveWarning(string transmissionId, string message, string appDomainName);
    [EventAttribute("15")]
public void StorageSize(long size, string appDomainName);
    [EventAttribute("16")]
public void SenderEnqueueNoCapacityWarning(int transmissionCount, int capacity, string appDomainName);
    [EventAttribute("17")]
public void TransmissionSendStarted(string id, string appDomainName);
    [EventAttribute("18")]
public void SerializationStarted(int count, string appDomainName);
    [EventAttribute("19")]
public void TelemetryChannelFlush(string appDomainName);
    [EventAttribute("20")]
public void TelemetryChannelSend(string type, string key, string appDomainName);
    [EventAttribute("21")]
public void TransmitterEnqueue(string transmissionId, string appDomainName);
    [EventAttribute("22")]
public void TransmissionSentSuccessfully(string transmissionId, int capacity, string appDomainName);
    [EventAttribute("23")]
public void TransmissionSendingFailedWebExceptionWarning(string transmissionId, string exceptionMessage, int statusCode, string description, string appDomainName);
    [EventAttribute("24")]
public void TransmissionPolicyRetryAfterParseFailedWarning(string retryAfterHeader, string appDomainName);
    [EventAttribute("25")]
public void StorageEnqueueNoCapacityWarning(long size, long capacity, string appDomainName);
    [EventAttribute("26")]
public void TransmissionSavedToStorage(string transmissionId, string appDomainName);
    [EventAttribute("27")]
public void SenderCapacityChanged(string policyName, int newCapacity, string appDomainName);
    [EventAttribute("28")]
public void BufferCapacityChanged(string policyName, int newCapacity, string appDomainName);
    [EventAttribute("29")]
public void SenderCapacityReset(string policyName, string appDomainName);
    [EventAttribute("30")]
public void BufferCapacityReset(string policyName, string appDomainName);
    [EventAttribute("31")]
public void BackoffTimeSetInSeconds(double seconds, string appDomainName);
    [EventAttribute("32")]
public void NetworkIsNotAvailableWarning(string appDomainName);
    [EventAttribute("33")]
public void StorageCapacityReset(string policyName, string appDomainName);
    [EventAttribute("34")]
public void StorageCapacityChanged(string policyName, int newCapacity, string appDomainName);
    [EventAttribute("35")]
public void ThrottlingRetryAfterParsedInSec(double retryAfter, string appDomainName);
    [EventAttribute("36")]
public void TransmitterEmptyStorage(string appDomainName);
    [EventAttribute("37")]
public void TransmitterEmptyBuffer(string appDomainName);
    [EventAttribute("38")]
public void SubscribeToNetworkFailureWarning(string exception, string appDomainName);
    [EventAttribute("39")]
public void ExceptionHandlerStartExceptionWarning(string exception, string appDomainName);
    [EventAttribute("40")]
public void TransmitterSenderSkipped(string transmissionId, string appDomainName);
    [EventAttribute("41")]
public void TransmitterBufferSkipped(string transmissionId, string appDomainName);
    [EventAttribute("42")]
public void TransmitterStorageSkipped(string transmissionId, string appDomainName);
    [EventAttribute("43")]
public void IncorrectFileFormatWarning(string errorMessage, string appDomainName);
    [EventAttribute("44")]
public void UnexpectedExceptionInStopError(string exception, string appDomainName);
    [EventAttribute("45")]
public void ApplyPoliciesError(string exception, string appDomainName);
    [EventAttribute("46")]
public void RetryAfterHeaderIsPresent(string retryAfterHeader, string appDomainName);
    [EventAttribute("48")]
public void TransmissionFailedToStoreWarning(string transmissionId, string exception, string appDomainName);
    [EventAttribute("49")]
public void MovedFromBufferToSender(string appDomainName);
    [EventAttribute("50")]
public void MovedFromStorageToSender(string appDomainName);
    [EventAttribute("51")]
public void MovedFromStorageToBuffer(string appDomainName);
    [EventAttribute("52")]
public void MovedFromBufferToStorage(string appDomainName);
    [EventAttribute("53")]
public void UnauthorizedAccessExceptionOnCalculateSizeWarning(string message, string appDomainName);
    [EventAttribute("54")]
public void TransmissionSendingFailedWarning(string transmissionId, string exceptionMessage, string appDomainName);
    [EventAttribute("55")]
public void TransmissionStorageAccessDeniedError(string error, string user, string customFolder, string appDomainName);
    [EventAttribute("56")]
public void TransmissionStorageIssuesWarning(string error, string user, string appDomainName);
    [EventAttribute("57")]
public void StorageNotInitializedError(string appDomainName);
    [EventAttribute("58")]
public void LastBackendResponseWhenPutToStorage(int statusCode, double currentDelayInSeconds, string appDomainName);
    [EventAttribute("59")]
public void TransmissionStorageDequeueIOError(string fileName, string exception, string appDomainName);
    [EventAttribute("60")]
public void TransmissionStorageDequeueUnauthorizedAccessException(string fileName, string exception, string appDomainName);
    [EventAttribute("61")]
public void TransmissionStorageInaccessibleFile(string fileName, string appDomainName);
    [EventAttribute("62")]
public void TransmissionStorageFileExpired(string fileName, string created, string appDomainName);
    [EventAttribute("63")]
public void TransmissionStorageUnexpectedRetryOfBadFile(string fileName, string appDomainName);
    [EventAttribute("64")]
public void TransmissionThrottledWarning(int limit, int attempted, int accepted, string appDomainName);
    [EventAttribute("65")]
public void ItemDroppedAsMaximumUnsentBacklogSizeReached(int maxBacklogSize, string appDomainName);
    [EventAttribute("66")]
public void LogError(string msg, string appDomainName);
    [EventAttribute("67")]
public void ItemRejectedNoInstrumentationKey(string item, string appDomainName);
    [EventAttribute("68")]
public void FailedToSetSecurityPermissionStorageDirectory(string directory, string error, string appDomainName);
    [EventAttribute("69")]
public void TransmissionDataLossError(string transmissionId, string message, string appDomainName);
    [EventAttribute("70")]
public void RawResponseFromAIBackend(string transmissionId, string message, string appDomainName);
    [EventAttribute("71")]
public void TransmissionDataNotRetriedForNonWhitelistedResponse(string transmissionId, string status, string appDomainName);
    [EventAttribute("72")]
public void ItemProactivelySampledOut(string telemetryType, string appDomainName);
    [EventAttribute("73")]
public void SamplingConfigErrorBothTypes(string appDomainName);
    [EventAttribute("74")]
public void TelemetryChannelNoInstrumentationKey(string appDomainName);
    [EventAttribute("75")]
public void TransmissionCustomStorageError(string error, string user, string customFolder, string appDomainName);
    [EventAttribute("76")]
public void TelemetryChannelFlushAsync(string appDomainName);
    [EventAttribute("77")]
public void TransmissionFlushAsyncWarning(string exception, string appDomainName);
    [EventAttribute("78")]
public void AuthenticationPolicyCaughtFailedIngestion(string transmissionId, string statusCode, string statusDescription, string appDomainName);
    [EventAttribute("79")]
public void UnexpectedBreezeResponseErrorIndexWarning(int index, string appDomainName);
    private static string GetApplicationName();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TelemetrySerializer : object {
    internal Transmitter Transmitter;
    private Uri endpoindAddress;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransmissionStatusEventArgs> <TransmissionStatusEvent>k__BackingField;
    public Uri EndpointAddress { get; public set; }
    public EventHandler`1<TransmissionStatusEventArgs> TransmissionStatusEvent { get; public set; }
    public TelemetrySerializer(Transmitter transmitter);
    public Uri get_EndpointAddress();
    public void set_EndpointAddress(Uri value);
    [CompilerGeneratedAttribute]
public EventHandler`1<TransmissionStatusEventArgs> get_TransmissionStatusEvent();
    [CompilerGeneratedAttribute]
public void set_TransmissionStatusEvent(EventHandler`1<TransmissionStatusEventArgs> value);
    public virtual void Serialize(ICollection`1<ITelemetry> items);
    public virtual Task`1<bool> SerializeAsync(ICollection`1<ITelemetry> items, CancellationToken cancellationToken);
    private Task`1<bool> SerializeTransmissionAndEnqueue(Transmission transmission, ICollection`1<ITelemetry> items, CancellationToken cancellationToken);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionBuffer : object {
    private static int DefaultCapacityInKiloBytes;
    private Queue`1<Transmission> transmissions;
    private int capacity;
    private long size;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransmissionProcessedEventArgs> TransmissionDequeued;
    public int Capacity { get; public set; }
    public long Size { get; }
    [CompilerGeneratedAttribute]
public void add_TransmissionDequeued(EventHandler`1<TransmissionProcessedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TransmissionDequeued(EventHandler`1<TransmissionProcessedEventArgs> value);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Size();
    public virtual bool Enqueue(Func`1<Transmission> transmissionGetter);
    public virtual Transmission Dequeue();
    protected void OnTransmissionDequeued(TransmissionProcessedEventArgs args);
}
[ExtensionAttribute]
internal static class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionExtensions : object {
    private static string ContentTypeHeader;
    private static string ContentEncodingHeader;
    public static Transmission Load(Stream stream);
    [ExtensionAttribute]
public static void Save(Transmission transmission, Stream stream);
    private static string ReadHeader(TextReader reader, string headerName);
    private static Uri ReadAddress(TextReader reader);
    private static Byte[] ReadContent(TextReader reader);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionPolicy.ApplicationLifecycleTransmissionPolicy : TransmissionPolicy {
    private IApplicationLifecycle applicationLifecycle;
    public ApplicationLifecycleTransmissionPolicy(IApplicationLifecycle applicationLifecycle);
    public virtual void Initialize(Transmitter transmitter);
    private void HandleApplicationStoppingEvent(object sender, ApplicationStoppingEventArgs e);
    private void SetMaxTransmissionCapacity(int value);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionPolicy.AuthenticationTransmissionPolicy : TransmissionPolicy {
    internal TaskTimerInternal PauseTimer;
    private BackoffLogicManager backoffLogicManager;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    public bool Enabled { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    public virtual void Initialize(Transmitter transmitter);
    public sealed virtual void Dispose();
    private void HandleTransmissionSentEvent(object sender, TransmissionProcessedEventArgs e);
    private void ApplyThrottlePolicy(TransmissionProcessedEventArgs e);
    private void ResetPolicy();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task <ApplyThrottlePolicy>b__9_0();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionPolicy.ErrorHandlingTransmissionPolicy : TransmissionPolicy {
    private BackoffLogicManager backoffLogicManager;
    private TaskTimerInternal pauseTimer;
    public virtual void Initialize(Transmitter transmitter);
    public sealed virtual void Dispose();
    private static void AdditionalVerboseTracing(string httpResponse);
    private void HandleTransmissionSentEvent(object sender, TransmissionProcessedEventArgs e);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task <HandleTransmissionSentEvent>b__5_0();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionPolicy.NetworkAvailabilityTransmissionPolicy : TransmissionPolicy {
    private INetwork network;
    public NetworkAvailabilityTransmissionPolicy(INetwork network);
    public virtual void Initialize(Transmitter transmitter);
    public sealed virtual void Dispose();
    private void SubscribeToNetworkAddressChangedEvents();
    private void UnsubscribeFromNetworkAddressChangedEvents();
    private void HandleNetworkStatusChangedEvent(object sender, EventArgs e);
    private void SetBufferAndSenderCapacity();
    private bool IsNetworkAvailable();
    private void Dispose(bool disposing);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionPolicy.PartialSuccessTransmissionPolicy : TransmissionPolicy {
    private BackoffLogicManager backoffLogicManager;
    private TaskTimerInternal pauseTimer;
    public virtual void Initialize(Transmitter transmitter);
    public sealed virtual void Dispose();
    private static string ParsePartialSuccessResponse(Transmission initialTransmission, TransmissionProcessedEventArgs args, Int32& lastStatusCode);
    private static Transmission SerializeNewTransmission(TransmissionProcessedEventArgs args, string newTransmissions);
    private void HandleTransmissionSentEvent(object sender, TransmissionProcessedEventArgs args);
    private void DelayFutureProcessing(HttpWebResponseWrapper response, int statusCode);
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task <DelayFutureProcessing>b__7_0();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionPolicy.ThrottlingTransmissionPolicy : TransmissionPolicy {
    private BackoffLogicManager backoffLogicManager;
    private TaskTimerInternal pauseTimer;
    public virtual void Initialize(Transmitter transmitter);
    public sealed virtual void Dispose();
    private void HandleTransmissionSentEvent(object sender, TransmissionProcessedEventArgs e);
    private void ResetPolicy();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Task <HandleTransmissionSentEvent>b__4_0();
}
internal abstract class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionPolicy.TransmissionPolicy : object {
    private string policyName;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxSenderCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxBufferCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxStorageCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private Transmitter <Transmitter>k__BackingField;
    public Nullable`1<int> MaxSenderCapacity { get; protected set; }
    public Nullable`1<int> MaxBufferCapacity { get; protected set; }
    public Nullable`1<int> MaxStorageCapacity { get; protected set; }
    protected Transmitter Transmitter { get; private set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxSenderCapacity();
    [CompilerGeneratedAttribute]
protected void set_MaxSenderCapacity(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxBufferCapacity();
    [CompilerGeneratedAttribute]
protected void set_MaxBufferCapacity(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxStorageCapacity();
    [CompilerGeneratedAttribute]
protected void set_MaxStorageCapacity(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
protected Transmitter get_Transmitter();
    [CompilerGeneratedAttribute]
private void set_Transmitter(Transmitter value);
    public void Apply();
    public virtual void Initialize(Transmitter transmitter);
    protected void LogCapacityChanged();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionPolicy.TransmissionPolicyCollection : object {
    private IEnumerable`1<TransmissionPolicy> policies;
    private bool isDisposed;
    private AuthenticationTransmissionPolicy authenticationTransmissionPolicy;
    public static TransmissionPolicyCollection Default { get; }
    public TransmissionPolicyCollection(INetwork network, IApplicationLifecycle applicationLifecycle);
    internal TransmissionPolicyCollection(IEnumerable`1<TransmissionPolicy> policies);
    public static TransmissionPolicyCollection get_Default();
    public void Initialize(Transmitter transmitter);
    public void EnableAuthenticationPolicy();
    public Nullable`1<int> CalculateMinimumMaxSenderCapacity();
    public Nullable`1<int> CalculateMinimumMaxBufferCapacity();
    public Nullable`1<int> CalculateMinimumMaxStorageCapacity();
    public sealed virtual void Dispose();
    private Nullable`1<int> CalculateMinimumCapacity(Func`2<TransmissionPolicy, Nullable`1<int>> getMaxPolicyCapacity);
    private void Dispose(bool disposing);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionProcessedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Transmission <Transmission>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpWebResponseWrapper <Response>k__BackingField;
    public Transmission Transmission { get; }
    public Exception Exception { get; }
    public HttpWebResponseWrapper Response { get; protected set; }
    public TransmissionProcessedEventArgs(Transmission transmission, Exception exception, HttpWebResponseWrapper response);
    [CompilerGeneratedAttribute]
public Transmission get_Transmission();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public HttpWebResponseWrapper get_Response();
    [CompilerGeneratedAttribute]
protected void set_Response(HttpWebResponseWrapper value);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionSender : object {
    private static HttpWebResponseWrapper DefaultHttpWebResponseWrapper;
    private ConcurrentDictionary`2<long, Task`1<HttpWebResponseWrapper>> inFlightTransmissions;
    private int transmissionCount;
    private int capacity;
    private bool applyThrottle;
    private int throttleWindowInMilliseconds;
    private long currentThrottleWindowId;
    private int currentItemsCount;
    private int throttleLimit;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransmissionProcessedEventArgs> TransmissionSent;
    [CompilerGeneratedAttribute]
private CredentialEnvelope <CredentialEnvelope>k__BackingField;
    public int Capacity { get; public set; }
    public bool ApplyThrottle { get; public set; }
    public int ThrottleLimit { get; public set; }
    public int ThrottleWindow { get; public set; }
    internal CredentialEnvelope CredentialEnvelope { get; internal set; }
    [CompilerGeneratedAttribute]
public void add_TransmissionSent(EventHandler`1<TransmissionProcessedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TransmissionSent(EventHandler`1<TransmissionProcessedEventArgs> value);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual bool get_ApplyThrottle();
    public virtual void set_ApplyThrottle(bool value);
    public virtual int get_ThrottleLimit();
    public virtual void set_ThrottleLimit(int value);
    public virtual int get_ThrottleWindow();
    public virtual void set_ThrottleWindow(int value);
    [CompilerGeneratedAttribute]
internal CredentialEnvelope get_CredentialEnvelope();
    [CompilerGeneratedAttribute]
internal void set_CredentialEnvelope(CredentialEnvelope value);
    public virtual bool Enqueue(Func`1<Transmission> transmissionGetter);
    internal Task`1<TaskStatus> WaitForPreviousTransmissionsToComplete(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionSender/<WaitForPreviousTransmissionsToComplete>d__30")]
internal Task`1<TaskStatus> WaitForPreviousTransmissionsToComplete(long transmissionFlushAsyncId, CancellationToken cancellationToken);
    protected void OnTransmissionSent(TransmissionProcessedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionSender/<StartSending>d__32")]
private Task StartSending(Transmission transmission);
    private int IsTransmissionSendable(int numEvents, bool peek);
    private Transmission Throttle(Transmission transmission);
    private void SendTransmissionThrottleRejection(Transmission rejectedTransmission);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.TransmissionStorage : object {
    internal static string TemporaryFileExtension;
    internal static string TransmissionFileExtension;
    internal static int DefaultCapacityKiloBytes;
    private ConcurrentDictionary`2<string, string> badFiles;
    private ConcurrentQueue`1<IPlatformFile> files;
    private object loadFilesLock;
    private IPlatformFolder folder;
    private long capacity;
    private long size;
    private bool sizeCalculated;
    private Random random;
    private Timer clearBadFiles;
    private long flushAsyncInProcessCounter;
    public long Capacity { get; public set; }
    public virtual long get_Capacity();
    public virtual void set_Capacity(long value);
    public sealed virtual void Dispose();
    public virtual void Initialize(IApplicationFolderProvider applicationFolderProvider);
    public virtual bool Enqueue(Func`1<Transmission> transmissionGetter);
    public virtual Transmission Dequeue();
    internal void IncrementFlushAsyncCounter();
    internal void DecrementFlushAsyncCounter();
    private static string GetUniqueFileName(string extension);
    private static Transmission LoadFromTransmissionFile(IPlatformFile file, Int64& fileSize);
    private static Transmission LoadFromTemporaryFile(IPlatformFile file, Int64& fileSize);
    private static void ChangeFileExtension(IPlatformFile file, string extension);
    private static long SaveTransmissionToFile(Transmission transmission, IPlatformFile file);
    private IPlatformFile CreateTemporaryFile();
    private IEnumerable`1<IPlatformFile> GetTransmissionFiles();
    private IPlatformFile GetOldestTransmissionFileOrNull();
    private void LoadFilesOrderedByDateFromFolder();
    private void EnsureSizeIsCalculated();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0(object o);
    [CompilerGeneratedAttribute]
private bool <LoadFilesOrderedByDateFromFolder>b__31_0(IPlatformFile f);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.Transmitter : object {
    internal TransmissionSender Sender;
    internal TransmissionBuffer Buffer;
    internal TransmissionStorage Storage;
    private TransmissionPolicyCollection policies;
    private BackoffLogicManager backoffLogicManager;
    private Task`1<bool> successTask;
    private Task`1<bool> failedTask;
    private bool arePoliciesApplied;
    private int maxSenderCapacity;
    private int maxBufferCapacity;
    private long maxStorageCapacity;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransmissionProcessedEventArgs> TransmissionSent;
    [CompilerGeneratedAttribute]
private string <StorageFolder>k__BackingField;
    public string StorageFolder { get; public set; }
    public int MaxBufferCapacity { get; public set; }
    public int MaxSenderCapacity { get; public set; }
    public long MaxStorageCapacity { get; public set; }
    public bool ApplyThrottle { get; public set; }
    public int ThrottleLimit { get; public set; }
    public int ThrottleWindow { get; public set; }
    public BackoffLogicManager BackoffLogicManager { get; }
    internal CredentialEnvelope CredentialEnvelope { get; internal set; }
    internal Transmitter(TransmissionSender sender, TransmissionBuffer transmissionBuffer, TransmissionStorage storage, TransmissionPolicyCollection policies, BackoffLogicManager backoffLogicManager);
    [CompilerGeneratedAttribute]
public void add_TransmissionSent(EventHandler`1<TransmissionProcessedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_TransmissionSent(EventHandler`1<TransmissionProcessedEventArgs> value);
    [CompilerGeneratedAttribute]
public string get_StorageFolder();
    [CompilerGeneratedAttribute]
public void set_StorageFolder(string value);
    public int get_MaxBufferCapacity();
    public void set_MaxBufferCapacity(int value);
    public int get_MaxSenderCapacity();
    public void set_MaxSenderCapacity(int value);
    public long get_MaxStorageCapacity();
    public void set_MaxStorageCapacity(long value);
    public bool get_ApplyThrottle();
    public void set_ApplyThrottle(bool value);
    public int get_ThrottleLimit();
    public void set_ThrottleLimit(int value);
    public int get_ThrottleWindow();
    public void set_ThrottleWindow(int value);
    public BackoffLogicManager get_BackoffLogicManager();
    internal CredentialEnvelope get_CredentialEnvelope();
    internal void set_CredentialEnvelope(CredentialEnvelope value);
    public sealed virtual void Dispose();
    internal virtual void Initialize();
    internal virtual void Enqueue(Transmission transmission);
    internal Task`1<bool> FlushAsync(Transmission transmission, CancellationToken cancellationToken);
    internal Task`1<bool> MoveTransmissionsAndWaitForSender(CancellationToken cancellationToken);
    internal TaskStatus MoveTransmissionsAndWaitForSender(long transmissionFlushAsyncId, CancellationToken cancellationToken);
    internal virtual void ApplyPolicies();
    internal void EmptyBuffer();
    internal void EmptyStorage();
    protected void OnTransmissionSent(TransmissionProcessedEventArgs e);
    private static void MoveTransmissions(Func`1<Transmission> dequeue, Func`2<Func`1<Transmission>, bool> enqueue);
    private static bool MoveTransmissions(Func`1<Transmission> dequeue, Func`2<Func`1<Transmission>, bool> enqueue, long size, CancellationToken cancellationToken);
    private void ApplyPoliciesIfAlreadyApplied();
    private void HandleSenderTransmissionSentEvent(object sender, TransmissionProcessedEventArgs e);
    private void HandleBufferTransmissionDequeuedEvent(object sender, TransmissionProcessedEventArgs e);
    private void UpdateComponentCapacitiesFromPolicies();
    private void Dispose(bool disposing);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.WeakConcurrentRandom : object {
    private static WeakConcurrentRandom random;
    private int index;
    private int segmentCount;
    private int segmentSize;
    private int bitsToStoreRandomIndexWithinSegment;
    private int segmentIndexMask;
    private int randomIndexWithinSegmentMask;
    private int randomArrayIndexMask;
    private IRandomNumberBatchGenerator[] randomGemerators;
    private UInt64[] randomNumbers;
    public static WeakConcurrentRandom Instance { get; }
    public static WeakConcurrentRandom get_Instance();
    public void Initialize();
    public void Initialize(Func`2<ulong, IRandomNumberBatchGenerator> randomGeneratorFactory, int segmentIndexBits, int segmentBits);
    public ulong Next();
    private void RegenerateSegment(int newIndex);
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Implementation.XorshiftRandomBatchGenerator : object {
    private static ulong Y;
    private static ulong Z;
    private static ulong W;
    private ulong lastX;
    private ulong lastY;
    private ulong lastZ;
    private ulong lastW;
    public XorshiftRandomBatchGenerator(ulong seed);
    public sealed virtual void NextBatch(UInt64[] buffer, int index, int count);
}
public class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.SamplingTelemetryProcessor : object {
    private AtomicSampledItemsCounter proactivelySampledOutCounters;
    private string excludedTypesString;
    private SamplingTelemetryItemTypes includedTypesFlags;
    private string includedTypesString;
    [CompilerGeneratedAttribute]
private double <SamplingPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <ProactiveSamplingPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryProcessor <SampledNext>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryProcessor <UnsampledNext>k__BackingField;
    public string ExcludedTypes { get; public set; }
    public string IncludedTypes { get; public set; }
    public double SamplingPercentage { get; public set; }
    internal Nullable`1<double> ProactiveSamplingPercentage { get; internal set; }
    private ITelemetryProcessor SampledNext { get; private set; }
    private ITelemetryProcessor UnsampledNext { get; private set; }
    public SamplingTelemetryProcessor(ITelemetryProcessor next);
    internal SamplingTelemetryProcessor(ITelemetryProcessor unsampledNext, ITelemetryProcessor sampledNext);
    public string get_ExcludedTypes();
    public void set_ExcludedTypes(string value);
    public string get_IncludedTypes();
    public void set_IncludedTypes(string value);
    [CompilerGeneratedAttribute]
public double get_SamplingPercentage();
    [CompilerGeneratedAttribute]
public void set_SamplingPercentage(double value);
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_ProactiveSamplingPercentage();
    [CompilerGeneratedAttribute]
internal void set_ProactiveSamplingPercentage(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
private ITelemetryProcessor get_SampledNext();
    [CompilerGeneratedAttribute]
private void set_SampledNext(ITelemetryProcessor value);
    [CompilerGeneratedAttribute]
private ITelemetryProcessor get_UnsampledNext();
    [CompilerGeneratedAttribute]
private void set_UnsampledNext(ITelemetryProcessor value);
    public sealed virtual void Process(ITelemetry item);
    private void HandlePossibleProactiveSampling(ITelemetry item, double currentSamplingPercentage, ISupportAdvancedSampling samplingSupportingTelemetry);
    private bool IsSamplingApplicable(SamplingTelemetryItemTypes telemetryItemTypeFlag);
}
public class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.ServerTelemetryChannel : object {
    internal TelemetrySerializer TelemetrySerializer;
    internal TelemetryBuffer TelemetryBuffer;
    internal Transmitter Transmitter;
    private InterlockedThrottle throttleEmptyIkeyLog;
    private TransmissionPolicyCollection policies;
    private Nullable`1<bool> developerMode;
    private int telemetryBufferCapacity;
    private ITelemetryProcessor telemetryProcessor;
    private bool isInitialized;
    [EditorBrowsableAttribute("1")]
public TimeSpan DefaultBackoffEnabledReportingInterval { get; public set; }
    public Nullable`1<bool> DeveloperMode { get; public set; }
    public string EndpointAddress { get; public set; }
    public EventHandler`1<TransmissionStatusEventArgs> TransmissionStatusEvent { get; public set; }
    public TimeSpan MaxTelemetryBufferDelay { get; public set; }
    public int MaxTelemetryBufferCapacity { get; public set; }
    public int MaxBacklogSize { get; public set; }
    public int MaxTransmissionBufferCapacity { get; public set; }
    public int MaxTransmissionSenderCapacity { get; public set; }
    public long MaxTransmissionStorageCapacity { get; public set; }
    public string StorageFolder { get; public set; }
    public bool EnableLocalThrottling { get; public set; }
    public int LocalThrottleLimit { get; public set; }
    public int LocalThrottleWindow { get; public set; }
    private CredentialEnvelope Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ISupportCredentialEnvelope.CredentialEnvelope { get; private set; }
    internal ITelemetryProcessor TelemetryProcessor { get; internal set; }
    internal ServerTelemetryChannel(INetwork network, IApplicationLifecycle applicationLifecycle);
    public TimeSpan get_DefaultBackoffEnabledReportingInterval();
    public void set_DefaultBackoffEnabledReportingInterval(TimeSpan value);
    public sealed virtual Nullable`1<bool> get_DeveloperMode();
    public sealed virtual void set_DeveloperMode(Nullable`1<bool> value);
    public sealed virtual string get_EndpointAddress();
    public sealed virtual void set_EndpointAddress(string value);
    public EventHandler`1<TransmissionStatusEventArgs> get_TransmissionStatusEvent();
    public void set_TransmissionStatusEvent(EventHandler`1<TransmissionStatusEventArgs> value);
    public TimeSpan get_MaxTelemetryBufferDelay();
    public void set_MaxTelemetryBufferDelay(TimeSpan value);
    public int get_MaxTelemetryBufferCapacity();
    public void set_MaxTelemetryBufferCapacity(int value);
    public int get_MaxBacklogSize();
    public void set_MaxBacklogSize(int value);
    public int get_MaxTransmissionBufferCapacity();
    public void set_MaxTransmissionBufferCapacity(int value);
    public int get_MaxTransmissionSenderCapacity();
    public void set_MaxTransmissionSenderCapacity(int value);
    public long get_MaxTransmissionStorageCapacity();
    public void set_MaxTransmissionStorageCapacity(long value);
    public string get_StorageFolder();
    public void set_StorageFolder(string value);
    public bool get_EnableLocalThrottling();
    public void set_EnableLocalThrottling(bool value);
    public int get_LocalThrottleLimit();
    public void set_LocalThrottleLimit(int value);
    public int get_LocalThrottleWindow();
    public void set_LocalThrottleWindow(int value);
    private sealed virtual override CredentialEnvelope Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ISupportCredentialEnvelope.get_CredentialEnvelope();
    private sealed virtual override void Microsoft.ApplicationInsights.Extensibility.Implementation.Authentication.ISupportCredentialEnvelope.set_CredentialEnvelope(CredentialEnvelope value);
    internal ITelemetryProcessor get_TelemetryProcessor();
    internal void set_TelemetryProcessor(ITelemetryProcessor value);
    public sealed virtual void Dispose();
    public sealed virtual void Send(ITelemetry item);
    public sealed virtual void Flush();
    public sealed virtual Task`1<bool> FlushAsync(CancellationToken cancellationToken);
    public sealed virtual void Initialize(TelemetryConfiguration configuration);
    [CompilerGeneratedAttribute]
private Task <Initialize>b__63_0();
    [CompilerGeneratedAttribute]
private void <Initialize>b__63_1();
}
internal interface Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Shared.Implementation.IIdentityProvider {
    public abstract virtual string GetName();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Shared.Implementation.NonWindowsIdentityProvider : object {
    private sealed virtual override string Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Shared.Implementation.IIdentityProvider.GetName();
}
internal class Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Shared.Implementation.WindowsIdentityProvider : object {
    private sealed virtual override string Microsoft.ApplicationInsights.WindowsServer.TelemetryChannel.Shared.Implementation.IIdentityProvider.GetName();
}
