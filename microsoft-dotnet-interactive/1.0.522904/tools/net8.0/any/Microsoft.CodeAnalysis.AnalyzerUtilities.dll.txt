[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Analyzer.Utilities.AbstractCategorizedAnalyzerConfigOptions : object {
    protected static string KeyPrefix;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, ValueTuple`2<bool, object>> _computedOptionValuesMap;
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    protected abstract virtual bool TryGetOptionValue(string optionKeyPrefix, string optionKeySuffix, string optionName, String& valueString);
    public sealed virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue);
    public bool TryGetOptionValue(string optionName, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue, T& value);
    private ValueTuple`2<bool, object> ComputeOptionValue(string optionName, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetSpecificOptionValue|8_0(string specificOptionKey, T& specificOptionValue, <>c__DisplayClass8_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetAnySpecificOptionValue|8_1(IEnumerable`1<string> specificOptionKeys, T& specificOptionValue, <>c__DisplayClass8_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputeOptionValue>g__TryGetGeneralOptionValue|8_2(T& generalOptionValue, <>c__DisplayClass8_0`1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.AggregateCategorizedAnalyzerConfigOptions : object {
    public static AggregateCategorizedAnalyzerConfigOptions Empty;
    private ImmutableDictionary`2<SyntaxTree, Lazy`1<SyntaxTreeCategorizedAnalyzerConfigOptions>> _perTreeOptions;
    private CompilationCategorizedAnalyzerConfigOptions _additionalFileBasedOptions;
    public bool IsEmpty { get; }
    private AggregateCategorizedAnalyzerConfigOptions(ImmutableDictionary`2<SyntaxTree, Lazy`1<SyntaxTreeCategorizedAnalyzerConfigOptions>> perTreeOptions, CompilationCategorizedAnalyzerConfigOptions additionalFileBasedOptions);
    private static AggregateCategorizedAnalyzerConfigOptions();
    public sealed virtual bool get_IsEmpty();
    public static AggregateCategorizedAnalyzerConfigOptions Create(AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider, Compilation compilation, CompilationCategorizedAnalyzerConfigOptions additionalFileBasedOptions);
    public sealed virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue);
    private bool TryGetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue, T& value);
    [CompilerGeneratedAttribute]
internal static SyntaxTreeCategorizedAnalyzerConfigOptions <Create>g__Create|6_0(SyntaxTree tree, AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.AnalyzerConfigOptionsProviderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsEmpty(AnalyzerConfigOptionsProvider analyzerConfigOptionsProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.AnalyzerOptionsExtensions : object {
    private static ConditionalWeakTable`2<AnalyzerOptions, ICategorizedAnalyzerConfigOptions> s_cachedOptions;
    private static ImmutableHashSet`1<OutputKind> s_defaultOutputKinds;
    private static AnalyzerOptionsExtensions();
    private static bool TryGetSyntaxTreeForOption(ISymbol symbol, SyntaxTree& tree);
    [ExtensionAttribute]
public static SymbolVisibilityGroup GetSymbolVisibilityGroupOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, SymbolVisibilityGroup defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolVisibilityGroup GetSymbolVisibilityGroupOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, SymbolVisibilityGroup defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolModifiers GetRequiredModifiersOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, SymbolModifiers defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolModifiers GetRequiredModifiersOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, SymbolModifiers defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static EnumValuesPrefixTrigger GetEnumValuesPrefixTriggerOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, EnumValuesPrefixTrigger defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static EnumValuesPrefixTrigger GetEnumValuesPrefixTriggerOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, EnumValuesPrefixTrigger defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableHashSet`1<OutputKind> GetOutputKindsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableHashSet`1<SymbolKind> GetAnalyzedSymbolKindsOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, ImmutableHashSet`1<SymbolKind> defaultSymbolKinds, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableHashSet`1<SymbolKind> GetAnalyzedSymbolKindsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, ImmutableHashSet`1<SymbolKind> defaultSymbolKinds, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static TEnum GetFlagsEnumOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, TEnum defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static ImmutableHashSet`1<TEnum> GetNonFlagsEnumOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, ImmutableHashSet`1<TEnum> defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static TEnum GetNonFlagsEnumOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, TEnum defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool GetBoolOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, bool defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool GetBoolOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, bool defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static UInt32 GetUnsignedIntegralOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, UInt32 defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static UInt32 GetUnsignedIntegralOptionValue(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, UInt32 defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetNullCheckValidationMethodsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetAdditionalStringFormattingMethodsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetExcludedSymbolNamesWithValueOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetExcludedSymbolNamesWithValueOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetExcludedTypeNamesWithDerivedTypesOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetExcludedTypeNamesWithDerivedTypesOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetDisallowedSymbolNamesWithValueOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetDisallowedSymbolNamesWithValueOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<string> GetAdditionalRequiredSuffixesOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<string> GetAdditionalRequiredSuffixesOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<INamedTypeSymbol> GetAdditionalRequiredGenericInterfaces(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<INamedTypeSymbol> GetAdditionalRequiredGenericInterfaces(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetInheritanceExcludedSymbolNamesOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, string defaultForcedValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolNamesWithValueOption`1<Unit> GetAdditionalUseResultsMethodsOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static SymbolNamesWithValueOption`1<TValue> GetSymbolNamesWithValueOption(AnalyzerOptions options, string optionName, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken, string namePrefixOpt, string optionDefaultValue, string optionForcedValue, Func`2<string, NameParts<TValue>> getTypeAndSuffixFunc);
    [ExtensionAttribute]
private static ICategorizedAnalyzerConfigOptions GetOrComputeCategorizedAnalyzerConfigOptions(AnalyzerOptions options, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static InterproceduralAnalysisKind GetInterproceduralAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, InterproceduralAnalysisKind defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static InterproceduralAnalysisKind GetInterproceduralAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, InterproceduralAnalysisKind defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static DisposeAnalysisKind GetDisposeAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, DisposeAnalysisKind defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static DisposeAnalysisKind GetDisposeAnalysisKindOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, DisposeAnalysisKind defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool GetDisposeOwnershipTransferAtConstructorOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, bool defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool GetDisposeOwnershipTransferAtConstructorOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, bool defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool GetDisposeOwnershipTransferAtMethodCall(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, bool defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool GetDisposeOwnershipTransferAtMethodCall(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, bool defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool GetCopyAnalysisOption(AnalyzerOptions options, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, bool defaultValue, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool GetCopyAnalysisOption(AnalyzerOptions options, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, bool defaultValue, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <GetNonFlagsEnumOptionValue>g__TryParseValue|13_0(string value, ImmutableHashSet`1& result);
    [CompilerGeneratedAttribute]
internal static NameParts<string> <GetAdditionalRequiredSuffixesOption>g__GetParts|28_0(string name);
    [CompilerGeneratedAttribute]
internal static NameParts<INamedTypeSymbol> <GetAdditionalRequiredGenericInterfaces>g__GetParts|30_1(string name, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.BoundedCache`2 : BoundedCacheWithFactory`2<TKey, TValue> {
    public TValue GetOrCreateValue(TKey key);
    [CompilerGeneratedAttribute]
internal static TValue <GetOrCreateValue>g__CreateDefaultValue|0_0(TKey _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.BoundedCacheWithFactory`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<WeakReference`1<Entry<TKey, TValue>>> _weakReferencedEntries;
    public TValue GetOrCreateValue(TKey key, Func`2<TKey, TValue> valueFactory);
}
internal static class Analyzer.Utilities.CategorizedAnalyzerConfigOptionsExtensions : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.CompilationCategorizedAnalyzerConfigOptions : AbstractCategorizedAnalyzerConfigOptions {
    public static CompilationCategorizedAnalyzerConfigOptions Empty;
    private ImmutableDictionary`2<string, string> _generalOptions;
    private ImmutableDictionary`2<string, ImmutableDictionary`2<string, string>> _specificOptions;
    public bool IsEmpty { get; }
    private CompilationCategorizedAnalyzerConfigOptions(ImmutableDictionary`2<string, string> generalOptions, ImmutableDictionary`2<string, ImmutableDictionary`2<string, string>> specificOptions);
    private static CompilationCategorizedAnalyzerConfigOptions();
    public virtual bool get_IsEmpty();
    public static CompilationCategorizedAnalyzerConfigOptions Create(IDictionary`2<string, string> options);
    protected virtual bool TryGetOptionValue(string optionKeyPrefix, string optionKeySuffix, string optionName, String& valueString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.DiagnosticCategory : object {
    public static string Design;
    public static string Globalization;
    public static string Interoperability;
    public static string Mobility;
    public static string Performance;
    public static string Reliability;
    public static string Security;
    public static string Usage;
    public static string Naming;
    public static string Library;
    public static string Documentation;
    public static string Maintainability;
    public static string RoslynDiagnosticsDesign;
    public static string RoslynDiagnosticsMaintainability;
    public static string RoslynDiagnosticsPerformance;
    public static string RoslynDiagnosticsReliability;
    public static string RoslynDiagnosticsUsage;
    public static string MicrosoftCodeAnalysisCorrectness;
    public static string MicrosoftCodeAnalysisDesign;
    public static string MicrosoftCodeAnalysisDocumentation;
    public static string MicrosoftCodeAnalysisLocalization;
    public static string MicrosoftCodeAnalysisPerformance;
    public static string MicrosoftCodeAnalysisCompatibility;
    public static string MicrosoftCodeAnalysisReleaseTracking;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.DiagnosticHelpers : object {
    public static bool TryConvertToUInt64(object value, SpecialType specialType, UInt64& convertedValue);
    public static string GetMemberName(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.DisposeAnalysisHelper : object {
    private static String[] s_disposeOwnershipTransferLikelyTypes;
    private static BoundedCacheWithFactory`2<Compilation, DisposeAnalysisHelper> s_DisposeHelperCache;
    private static ImmutableHashSet`1<OperationKind> s_DisposableCreationKinds;
    private WellKnownTypeProvider _wellKnownTypeProvider;
    private ImmutableHashSet`1<INamedTypeSymbol> _disposeOwnershipTransferLikelyTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<INamedTypeSymbol, ImmutableHashSet`1<IFieldSymbol>> _lazyDisposableFieldsMap;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <IDisposable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <IAsyncDisposable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <Task>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ValueTask>k__BackingField;
    [NullableAttribute("2")]
public INamedTypeSymbol IDisposable { get; }
    [NullableAttribute("2")]
public INamedTypeSymbol IAsyncDisposable { get; }
    [NullableAttribute("2")]
public INamedTypeSymbol Task { get; }
    [NullableAttribute("2")]
public INamedTypeSymbol ValueTask { get; }
    private DisposeAnalysisHelper(Compilation compilation);
    private static DisposeAnalysisHelper();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_IDisposable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_IAsyncDisposable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_Task();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public INamedTypeSymbol get_ValueTask();
    private static ImmutableHashSet`1<INamedTypeSymbol> GetDisposeOwnershipTransferLikelyTypes(Compilation compilation);
    private void EnsureDisposableFieldsMap();
    public static bool TryGetOrCreate(Compilation compilation, DisposeAnalysisHelper& disposeHelper);
    public bool TryGetOrComputeResult(ImmutableArray`1<IOperation> operationBlocks, IMethodSymbol containingMethod, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, bool trackInstanceFields, bool trackExceptionPaths, CancellationToken cancellationToken, DisposeAnalysisResult& disposeAnalysisResult, PointsToAnalysisResult& pointsToAnalysisResult, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt, bool defaultDisposeOwnershipTransferAtConstructor);
    private bool HasDisposableOwnershipTransferForConstructorParameter(IMethodSymbol containingMethod);
    private bool IsDisposableCreation(IOperation operation);
    public bool HasAnyDisposableCreationDescendant(ImmutableArray`1<IOperation> operationBlocks, IMethodSymbol containingMethod);
    public ImmutableHashSet`1<IFieldSymbol> GetDisposableFields(INamedTypeSymbol namedType);
    public bool IsDisposableCreationOrDisposeOwnershipTransfer(AbstractLocation location, IMethodSymbol containingMethod);
    [NullableContextAttribute("2")]
public bool IsDisposable(ITypeSymbol type);
    public DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method);
    [CompilerGeneratedAttribute]
internal static DisposeAnalysisHelper <TryGetOrCreate>g__CreateDisposeAnalysisHelper|21_0(Compilation compilation);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <HasDisposableOwnershipTransferForConstructorParameter>b__23_0(IParameterSymbol p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetDisposableFields>b__26_0(IFieldSymbol f);
}
internal enum Analyzer.Utilities.DisposeAnalysisKind : Enum {
    public int value__;
    public static DisposeAnalysisKind AllPaths;
    public static DisposeAnalysisKind AllPathsOnlyNotDisposed;
    public static DisposeAnalysisKind NonExceptionPaths;
    public static DisposeAnalysisKind NonExceptionPathsOnlyNotDisposed;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.DisposeAnalysisKindExtensions : object {
    [ExtensionAttribute]
public static bool AreExceptionPathsAndMayBeNotDisposedViolationsEnabled(DisposeAnalysisKind disposeAnalysisKind);
    [ExtensionAttribute]
public static bool AreExceptionPathsEnabled(DisposeAnalysisKind disposeAnalysisKind);
    [ExtensionAttribute]
public static bool AreMayBeNotDisposedViolationsEnabled(DisposeAnalysisKind disposeAnalysisKind);
}
internal enum Analyzer.Utilities.DisposeMethodKind : Enum {
    public int value__;
    public static DisposeMethodKind None;
    public static DisposeMethodKind Dispose;
    public static DisposeMethodKind DisposeBool;
    public static DisposeMethodKind DisposeAsync;
    public static DisposeMethodKind DisposeCoreAsync;
    public static DisposeMethodKind Close;
    public static DisposeMethodKind CloseAsync;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Analyzer.Utilities.DoNotCatchGeneralUnlessRethrownAnalyzer : DiagnosticAnalyzer {
    private bool _shouldCheckLambdas;
    [NullableAttribute("2")]
private string _enablingMethodAttributeFullyQualifiedName;
    private bool RequiresAttributeOnMethod { get; }
    [NullableContextAttribute("2")]
protected DoNotCatchGeneralUnlessRethrownAnalyzer(bool shouldCheckLambdas, string enablingMethodAttributeFullyQualifiedName);
    private bool get_RequiresAttributeOnMethod();
    protected abstract virtual Diagnostic CreateDiagnostic(IMethodSymbol containingMethod, SyntaxToken catchKeyword);
    protected virtual bool IsConfiguredDisallowedExceptionType(INamedTypeSymbol namedTypeSymbol, IMethodSymbol containingMethod, Compilation compilation, AnalyzerOptions analyzerOptions, CancellationToken cancellationToken);
    public virtual void Initialize(AnalysisContext analysisContext);
    private INamedTypeSymbol GetRequiredAttributeType(Compilation compilation);
    private static IReadOnlyCollection`1<INamedTypeSymbol> GetDisallowedCatchTypes(Compilation compilation);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Initialize>b__7_0(CompilationStartAnalysisContext compilationStartAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.EditorConfigOptionNames : object {
    public static string ApiSurface;
    public static string RequiredModifiers;
    public static string ExcludeAsyncVoidMethods;
    public static string OutputKind;
    public static string ExcludeSingleLetterTypeParameters;
    public static string SufficientIterationCountForWeakKDFAlgorithm;
    public static string ExcludeExtensionMethodThisParameter;
    public static string NullCheckValidationMethods;
    public static string AdditionalStringFormattingMethods;
    public static string TryDetermineAdditionalStringFormattingMethodsAutomatically;
    public static string ExcludedSymbolNames;
    public static string ExcludedTypeNamesWithDerivedTypes;
    public static string DisallowedSymbolNames;
    public static string UnsafeDllImportSearchPathBits;
    public static string ExcludeAspnetCoreMvcControllerBase;
    public static string EnumValuesPrefixTrigger;
    public static string AdditionalRequiredSuffixes;
    public static string ExcludeIndirectBaseTypes;
    public static string AdditionalRequiredGenericInterfaces;
    public static string AdditionalInheritanceExcludedSymbolNames;
    public static string AnalyzedSymbolKinds;
    public static string UseNamingHeuristic;
    public static string AdditionalUseResultsMethods;
    public static string InterproceduralAnalysisKind;
    public static string MaxInterproceduralMethodCallChain;
    public static string MaxInterproceduralLambdaOrLocalFunctionCallChain;
    public static string DisposeAnalysisKind;
    public static string DisposeOwnershipTransferAtConstructor;
    public static string DisposeOwnershipTransferAtMethodCall;
    public static string CopyAnalysis;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.EditorConfigParser : object {
    private static Regex s_propertyMatcher;
    private static StringComparer s_keyComparer;
    private static ImmutableHashSet`1<string> s_reservedKeys;
    private static ImmutableHashSet`1<string> s_reservedValues;
    private static EditorConfigParser();
    public static CompilationCategorizedAnalyzerConfigOptions Parse(SourceText text);
    private static bool IsComment(string line);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.CompilationExtensions : object {
    private static Byte[] mscorlibPublicKeyToken;
    private static CompilationExtensions();
    [ExtensionAttribute]
internal static INamedTypeSymbol GetOrCreateTypeByMetadataName(Compilation compilation, string fullTypeName);
    [ExtensionAttribute]
internal static bool TryGetOrCreateTypeByMetadataName(Compilation compilation, string fullTypeName, INamedTypeSymbol& namedTypeSymbol);
    [ExtensionAttribute]
internal static bool TargetsDotNetFramework(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.DiagnosticExtensions : object {
    private static PropertyInfo s_syntaxTreeDiagnosticOptionsProperty;
    private static DiagnosticExtensions();
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxNode node, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IOperation operation, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(SyntaxToken token, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(ISymbol symbol, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(Location location, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IEnumerable`1<Location> locations, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static Diagnostic CreateDiagnostic(IEnumerable`1<Location> locations, DiagnosticDescriptor rule, ImmutableDictionary`2<string, string> properties, Object[] args);
    [ExtensionAttribute]
public static void ReportNoLocationDiagnostic(CompilationAnalysisContext context, DiagnosticDescriptor rule, Object[] args);
    [ExtensionAttribute]
public static void ReportNoLocationDiagnostic(Compilation compilation, DiagnosticDescriptor rule, Action`1<Diagnostic> addDiagnostic, ImmutableDictionary`2<string, string> properties, Object[] args);
    [CompilerGeneratedAttribute]
internal static Nullable`1<DiagnosticSeverity> <ReportNoLocationDiagnostic>g__GetEffectiveSeverity|12_0(<>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static void AddKeyValueIfNotNull(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void AddRange(IDictionary`2<TKey, TValue> dictionary, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static bool IsEqualTo(IReadOnlyDictionary`2<TKey, TValue> dictionary, IReadOnlyDictionary`2<TKey, TValue> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IEnumerableExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<object, bool> s_notNullTest;
    private static IEnumerableExtensions();
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.IEnumerableExtensions/<Concat>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> WhereAsArray(IEnumerable`1<TSource> source, Func`2<TSource, bool> selector);
    [ExtensionAttribute]
public static void Dispose(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static bool HasExactly(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasMoreThan(IEnumerable`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasFewerThan(IEnumerable`1<TSource> source, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IEnumerableOfIMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> WhereMethodDoesNotContainAttribute(IEnumerable`1<IMethodSymbol> methods, INamedTypeSymbol attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodOverloadsWithDesiredParameterAtLeadingOrTrailing(IEnumerable`1<IMethodSymbol> methods, IMethodSymbol selectedOverload, INamedTypeSymbol expectedParameterType, bool trailingOnly);
    [ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodOverloadsWithDesiredParameterAtTrailing(IEnumerable`1<IMethodSymbol> methods, IMethodSymbol selectedOverload, INamedTypeSymbol expectedTrailingParameterType);
    [ExtensionAttribute]
public static IMethodSymbol GetFirstOrDefaultMemberWithParameterInfos(IEnumerable`1<IMethodSymbol> members, ParameterInfo[] expectedParameterTypesInOrder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IMethodSymbolExtensions : object {
    private static ImmutableHashSet`1<string> s_collectionAddMethodNameVariants;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static BoundedCache`2<Compilation, ConcurrentDictionary`2<IMethodSymbol, IBlockOperation>> s_methodToTopmostOperationBlockCache;
    private static IMethodSymbolExtensions();
    [ExtensionAttribute]
public static bool IsObjectEqualsOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsObjectEquals(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsStaticObjectEqualsOrReferenceEquals(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsGetHashCodeOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsToStringOverride(IMethodSymbol method);
    private static bool IsObjectMethodOverride(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsFinalizer(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsImplementationOfInterfaceMethod(IMethodSymbol method, ITypeSymbol typeArgument, INamedTypeSymbol interfaceType, string interfaceMethodName);
    [ExtensionAttribute]
public static bool IsDisposeImplementation(IMethodSymbol method, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDisposeImplementation(IMethodSymbol method, INamedTypeSymbol iDisposable);
    [ExtensionAttribute]
private static bool HasDisposeMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasDisposeSignatureByConvention(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasDisposeBoolMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
private static bool HasDisposeCloseMethodSignature(IMethodSymbol method);
    [ExtensionAttribute]
private static bool HasDisposeCloseAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol taskType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static bool HasDisposeAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol task, INamedTypeSymbol valueTask);
    [ExtensionAttribute]
private static bool HasOverriddenDisposeCoreAsyncMethodSignature(IMethodSymbol method, INamedTypeSymbol task);
    [ExtensionAttribute]
public static DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method, INamedTypeSymbol iDisposable, INamedTypeSymbol iAsyncDisposable, INamedTypeSymbol task, INamedTypeSymbol valueTask);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOnDeserializationImplementation(IMethodSymbol method, INamedTypeSymbol iDeserializationCallback);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSerializationConstructor(IMethodSymbol method, INamedTypeSymbol serializationInfoType, INamedTypeSymbol streamingContextType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsGetObjectData(IMethodSymbol method, INamedTypeSymbol serializationInfoType, INamedTypeSymbol streamingContextType);
    [ExtensionAttribute]
public static bool IsPropertyGetter(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsIndexerGetter(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsEventAccessor(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsOperator(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
public static bool HasOptionalParameters(IMethodSymbol methodSymbol);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.IMethodSymbolExtensions/<GetOverloads>d__28")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetOverloads(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsCollectionAddMethod(IMethodSymbol method, ImmutableHashSet`1<INamedTypeSymbol> iCollectionTypes);
    [ExtensionAttribute]
public static bool IsTaskFromResultMethod(IMethodSymbol method, INamedTypeSymbol taskType);
    [ExtensionAttribute]
public static bool IsTaskConfigureAwaitMethod(IMethodSymbol method, INamedTypeSymbol genericTaskType);
    [ExtensionAttribute]
public static IBlockOperation GetTopmostOperationBlock(IMethodSymbol method, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunctionOrDelegate(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsLambdaOrLocalFunction(IMethodSymbol method);
    [ExtensionAttribute]
public static int GetParameterIndex(IMethodSymbol methodSymbol, IParameterSymbol parameterSymbol);
    [ExtensionAttribute]
public static bool HasEventHandlerSignature(IMethodSymbol method, INamedTypeSymbol eventArgsType);
    [ExtensionAttribute]
public static bool IsLockMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingMonitor);
    [ExtensionAttribute]
public static bool IsInterlockedExchangeMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingInterlocked);
    [ExtensionAttribute]
public static bool IsInterlockedCompareExchangeMethod(IMethodSymbol method, INamedTypeSymbol systemThreadingInterlocked);
    [ExtensionAttribute]
public static bool HasParameterWithDelegateType(IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOverrideOrVirtualMethodOf(IMethodSymbol methodSymbol, INamedTypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsArgumentNullCheckMethod(IMethodSymbol method);
    [ExtensionAttribute]
public static bool IsXUnitTestMethod(IMethodSymbol method, ConcurrentDictionary`2<INamedTypeSymbol, bool> knownTestAttributes, INamedTypeSymbol xunitFactAttribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions : object {
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.INamedTypeSymbolExtensions/<GetBaseTypesAndThis>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypesAndThis(INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool DerivesFromOrImplementsAnyConstructionOf(INamedTypeSymbol type, INamedTypeSymbol parentType);
    [ExtensionAttribute]
public static bool ImplementsOperator(INamedTypeSymbol symbol, string op);
    [ExtensionAttribute]
public static bool ImplementsEqualityOperators(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool OverridesEquals(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool OverridesGetHashCode(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool HasFinalizer(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsStaticHolderType(INamedTypeSymbol symbol);
    private static bool IsQualifyingMember(ISymbol member);
    private static bool IsDisqualifyingMember(ISymbol member);
    [ExtensionAttribute]
public static bool IsXUnitTestAttribute(INamedTypeSymbol attributeClass, ConcurrentDictionary`2<INamedTypeSymbol, bool> knownTestAttributes, INamedTypeSymbol xunitFactAttribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.IOperationExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static BoundedCache`2<Compilation, ConcurrentDictionary`2<IOperation, ControlFlowGraph>> s_operationToCfgCache;
    private static IOperationExtensions();
    [ExtensionAttribute]
public static INamedTypeSymbol GetReceiverType(IInvocationOperation invocation, Compilation compilation, bool beforeConversion, CancellationToken cancellationToken);
    private static INamedTypeSymbol GetReceiverType(SyntaxNode receiverSyntax, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool HasNullConstantValue(IOperation operation);
    [ExtensionAttribute]
public static bool TryGetBoolConstantValue(IOperation operation, Boolean& constantValue);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, long comparand);
    [ExtensionAttribute]
public static bool HasConstantValue(IOperation operation, ulong comparand);
    private static bool HasConstantValue(Optional`1<object> constantValue, ITypeSymbol constantValueType, ulong comparand);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetElementType(IArrayCreationOperation arrayCreation);
    [ExtensionAttribute]
public static ImmutableArray`1<IOperation> WithoutFullyImplicitOperations(ImmutableArray`1<IOperation> operations);
    [ExtensionAttribute]
public static ImmutableArray`1<IOperation> GetTopmostExplicitDescendants(IOperation operation);
    [ExtensionAttribute]
public static bool IsOperationNoneRoot(IOperation operation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IBlockOperation GetTopmostParentBlock(IOperation operation);
    [ExtensionAttribute]
public static TOperation GetAncestor(IOperation root, OperationKind ancestorKind, Func`2<TOperation, bool> predicateOpt);
    [ExtensionAttribute]
public static IConditionalAccessOperation GetConditionalAccess(IConditionalAccessInstanceOperation operation);
    [ExtensionAttribute]
public static IOperation GetInstance(IInstanceReferenceOperation operation, bool isInsideAnonymousObjectInitializer);
    [ExtensionAttribute]
public static IAnonymousObjectCreationOperation GetAnonymousObjectCreation(IPropertyReferenceOperation operation);
    [ExtensionAttribute]
public static bool IsInsideAnonymousFunction(IOperation operation);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate, IOperation& foundOperation);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, OperationKind kind);
    [ExtensionAttribute]
public static bool IsComparisonOperator(IBinaryOperation binaryOperation);
    [ExtensionAttribute]
public static IOperation GetRoot(IOperation operation);
    [ExtensionAttribute]
public static bool TryGetEnclosingControlFlowGraph(IOperation operation, ControlFlowGraph& cfg);
    [ExtensionAttribute]
public static ControlFlowGraph GetEnclosingControlFlowGraph(IBlockOperation blockOperation);
    private static ControlFlowGraph CreateControlFlowGraph(IOperation operation);
    [ExtensionAttribute]
public static PooledHashSet`1<ISymbol> GetCaptures(IOperation operation, IMethodSymbol lambdaOrLocalFunction);
    [ExtensionAttribute]
public static bool IsWithinLambdaOrLocalFunction(IOperation operation);
    [ExtensionAttribute]
public static ITypeSymbol GetPatternType(IPatternOperation pattern);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryGetParentTupleOperation(ITupleOperation tupleOperation, ITupleOperation& parentTupleOperation, IOperation& elementOfParentTupleContainingTuple);
    [ExtensionAttribute]
public static bool IsExtensionMethodAndHasNoInstance(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static IOperation GetInstance(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static SyntaxNode GetInstanceSyntax(IInvocationOperation invocationOperation);
    [ExtensionAttribute]
public static ITypeSymbol GetInstanceType(IOperation operation);
    [ExtensionAttribute]
public static ISymbol GetReferencedMemberOrLocalOrParameter(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkDownParentheses(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkUpParentheses(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkDownConversion(IOperation operation);
    [ExtensionAttribute]
public static IOperation WalkUpConversion(IOperation operation);
    [ExtensionAttribute]
public static ITypeSymbol GetThrownExceptionType(IThrowOperation operation);
    [ExtensionAttribute]
public static bool HasAnyExplicitDescendant(IOperation operation, Func`2<IOperation, bool> descendIntoOperation);
    [ExtensionAttribute]
public static bool IsSetMethodInvocation(IPropertyReferenceOperation operation);
    [ExtensionAttribute]
public static bool IsInsideCatchRegion(IOperation operation, ControlFlowGraph cfg);
    [ExtensionAttribute]
public static bool IsLValueFlowCaptureReference(IFlowCaptureReferenceOperation flowCaptureReference);
    [CompilerGeneratedAttribute]
internal static void <GetCaptures>g__ProcessLocalOrParameter|27_0(ISymbol symbol, <>c__DisplayClass27_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ISymbolExtensions : object {
    private static SymbolDisplayFormat s_memberDisplayFormat;
    private static ISymbolExtensions();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAccessorMethod(ISymbol symbol);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ISymbolExtensions/<GetAccessors>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetAccessors(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDefaultConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPublic(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsProtected(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPrivate(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsPropertyWithBackingField(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConversionOperator(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static bool MatchesConfiguredVisibility(ISymbol symbol, AnalyzerOptions options, DiagnosticDescriptor rule, Compilation compilation, CancellationToken cancellationToken, SymbolVisibilityGroup defaultRequiredVisibility);
    [ExtensionAttribute]
public static bool MatchesConfiguredVisibility(ISymbol symbol, ISymbol containingContextSymbol, AnalyzerOptions options, DiagnosticDescriptor rule, Compilation compilation, CancellationToken cancellationToken, SymbolVisibilityGroup defaultRequiredVisibility);
    [ExtensionAttribute]
public static bool IsConfiguredToSkipAnalysis(ISymbol symbol, AnalyzerOptions options, DiagnosticDescriptor rule, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsConfiguredToSkipAnalysis(ISymbol symbol, ISymbol containingContextSymbol, AnalyzerOptions options, DiagnosticDescriptor rule, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool MatchesConfiguredModifiers(ISymbol symbol, AnalyzerOptions options, DiagnosticDescriptor rule, Compilation compilation, CancellationToken cancellationToken, SymbolModifiers defaultRequiredModifiers);
    [ExtensionAttribute]
public static bool IsExternallyVisible(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static bool MatchMemberDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodDerivedByName(IMethodSymbol method, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMethodByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyDerivedByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchMemberByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchPropertyByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static bool MatchFieldByName(ISymbol member, INamedTypeSymbol type, string name);
    [ExtensionAttribute]
public static string FormatMemberName(ISymbol member);
    [ExtensionAttribute]
public static bool ContainsParameterOfType(IEnumerable`1<IParameterSymbol> parameters, INamedTypeSymbol type);
    [ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersOfType(IEnumerable`1<IParameterSymbol> parameters, INamedTypeSymbol type);
    [ExtensionAttribute]
public static bool HasOverloadWithParameterOfType(IEnumerable`1<IMethodSymbol> overloads, IMethodSymbol self, INamedTypeSymbol type, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ISymbolExtensions/<GetParameterIndices>d__34")]
[ExtensionAttribute]
public static IEnumerable`1<int> GetParameterIndices(IMethodSymbol method, IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ParametersAreSame(IMethodSymbol method1, IMethodSymbol method2);
    [ExtensionAttribute]
public static bool ParameterTypesAreSame(IMethodSymbol method1, IMethodSymbol method2, IEnumerable`1<int> parameterIndices, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static bool ParameterTypesAreSame(IParameterSymbol parameter1, IParameterSymbol parameter2);
    [ExtensionAttribute]
public static bool ReturnTypeAndParametersAreSame(IMethodSymbol method, IMethodSymbol otherMethod);
    [ExtensionAttribute]
public static bool IsFromMscorlib(ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
public static IMethodSymbol GetMatchingOverload(IMethodSymbol method, IEnumerable`1<IMethodSymbol> overloads, int parameterIndex, INamedTypeSymbol type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfAnyImplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementationOfInterfaceMember(ISymbol symbol, ISymbol interfaceMember);
    [ExtensionAttribute]
public static bool IsOverrideOrImplementationOfInterfaceMember(ISymbol symbol, ISymbol interfaceMember);
    [ExtensionAttribute]
public static ISymbol GetOverriddenMember(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsImplementationOfAnyExplicitInterfaceMember(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberOrLocalOrParameterType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReadOnlyFieldOrProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool HasAttribute(ISymbol symbol, INamedTypeSymbol attribute);
    [ExtensionAttribute]
public static bool IsInSource(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLambdaOrLocalFunction(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSymbolWithSpecialDiscardName(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConst(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReadOnly(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsPrimitiveType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Inherits(ITypeSymbol type, ITypeSymbol possibleBase);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ITypeSymbolExtensions/<GetBaseTypes>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type, Func`2<INamedTypeSymbol, bool> takeWilePredicate);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool DerivesFrom(ITypeSymbol symbol, ITypeSymbol candidateBaseType, bool baseTypesOnly, bool checkTypeParameterConstraints);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDisposable(ITypeSymbol type, INamedTypeSymbol iDisposable, INamedTypeSymbol iAsyncDisposable);
    [ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetApplicableAttributes(INamedTypeSymbol type, INamedTypeSymbol attributeUsageAttribute);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IEnumerable`1<AttributeData> GetApplicableExportAttributes(INamedTypeSymbol type, INamedTypeSymbol exportAttributeV1, INamedTypeSymbol exportAttributeV2, INamedTypeSymbol inheritedExportAttribute);
    [ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool HasValueCopySemantics(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNonNullableValueType(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullableValueType(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReferenceTypeOrNullableValueType(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullableOfBoolean(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static ITypeSymbol GetUnderlyingValueTupleTypeOrThis(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool HasAnyCollectionCountProperty(ITypeSymbol invocationTarget, WellKnownTypeProvider wellKnownTypeProvider);
    [CompilerGeneratedAttribute]
internal static bool <IsDisposable>g__IsInterfaceOrImplementsInterface|5_1(ITypeSymbol type, INamedTypeSymbol interfaceType);
    [CompilerGeneratedAttribute]
internal static bool <GetApplicableAttributes>g__IsInheritedAttribute|6_0(AttributeData attributeData, INamedTypeSymbol attributeUsageAttribute);
    [CompilerGeneratedAttribute]
internal static bool <HasAnyCollectionCountProperty>g__isAnySupportedCollectionType|15_0(ITypeSymbol type, <>c__DisplayClass15_0& );
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.KeyValuePairExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
internal static class Analyzer.Utilities.Extensions.MethodKindEx : object {
    public static MethodKind LocalFunction;
    private static UInt32 LocalFunctionValueAssertion1;
    private static UInt32 LocalFunctionValueAssertion2;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.OperationBlockAnalysisContextExtension : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsMethodNotImplementedOrSupported(OperationBlockStartAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsMethodNotImplementedOrSupported>g__IsSingleStatementBody|0_1(IBlockOperation body);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.OperationBlocksExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ControlFlowGraph GetControlFlowGraph(ImmutableArray`1<IOperation> operationBlocks);
}
internal static class Analyzer.Utilities.Extensions.OperationKinds : object {
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<OperationKind> <MemberReference>k__BackingField;
    public static ImmutableArray`1<OperationKind> MemberReference { get; }
    private static OperationKinds();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<OperationKind> get_MemberReference();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.Extensions.ParameterInfo : object {
    [CompilerGeneratedAttribute]
private int <ArrayRank>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ParameterType>k__BackingField;
    public int ArrayRank { get; private set; }
    public bool IsArray { get; private set; }
    public bool IsParams { get; private set; }
    public INamedTypeSymbol ParameterType { get; private set; }
    private ParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
    [CompilerGeneratedAttribute]
public int get_ArrayRank();
    [CompilerGeneratedAttribute]
private void set_ArrayRank(int value);
    [CompilerGeneratedAttribute]
public bool get_IsArray();
    [CompilerGeneratedAttribute]
private void set_IsArray(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParams();
    [CompilerGeneratedAttribute]
private void set_IsParams(bool value);
    [CompilerGeneratedAttribute]
public INamedTypeSymbol get_ParameterType();
    [CompilerGeneratedAttribute]
private void set_ParameterType(INamedTypeSymbol value);
    public static ParameterInfo GetParameterInfo(INamedTypeSymbol type, bool isArray, int arrayRank, bool isParams);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SemanticModelExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IOperation GetOperationWalkingUpParentChain(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static bool HasSuffix(string str, string suffix);
    [ExtensionAttribute]
public static string WithoutSuffix(string str, string suffix);
    [ExtensionAttribute]
public static bool IsASCII(string value);
}
internal enum Analyzer.Utilities.Extensions.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
    public static SymbolVisibility Friend;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.SymbolVisibilityExtensions : object {
    [ExtensionAttribute]
public static bool IsAtLeastAsVisibleAs(SymbolVisibility typeVisibility, SymbolVisibility comparisonVisibility);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Extensions.UriExtensions : object {
    private static ImmutableHashSet`1<string> s_uriWords;
    private static UriExtensions();
    [ExtensionAttribute]
public static bool ParameterNamesContainUriWordSubstring(IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SymbolNameContainsUriWordSubstring(ISymbol symbol, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Analyzer.Utilities.Extensions.UriExtensions/<GetParametersThatContainUriWords>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<IParameterSymbol> GetParametersThatContainUriWords(IEnumerable`1<IParameterSymbol> parameters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SymbolNameContainsUriWords(ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.FxCopWellKnownDiagnosticTags : object {
    public static string PortedFromFxCop;
    public static String[] PortedFxCopRule;
    public static String[] PortedFxCopDataflowRule;
    private static FxCopWellKnownDiagnosticTags();
    public static bool IsPortedFxCopRule(DiagnosticDescriptor diagnosticDescriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.HashUtilities : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static int GetHashCodeOrDefault(object objectOpt);
    internal static int Combine(int newKey, int currentKey);
    [NullableContextAttribute("2")]
internal static int Combine(ImmutableArray`1<T> array);
    [NullableContextAttribute("2")]
internal static int Combine(ImmutableArray`1<T> array, int currentKey);
    public static int Combine(T[] sequence);
    public static int Combine(IEnumerable`1<T> sequence, int length, int currentKey);
    internal static int Combine(ImmutableStack`1<T> stack);
    internal static int Combine(ImmutableStack`1<T> stack, int currentKey);
    internal static int Combine(ImmutableHashSet`1<T> set);
    internal static int Combine(ImmutableHashSet`1<T> set, int currentKey);
    [NullableContextAttribute("2")]
internal static int Combine(ImmutableDictionary`2<TKey, TValue> dictionary);
    [NullableContextAttribute("2")]
internal static int Combine(ImmutableDictionary`2<TKey, TValue> dictionary, int currentKey);
}
[NullableContextAttribute("1")]
internal interface Analyzer.Utilities.ICategorizedAnalyzerConfigOptions {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual T GetOptionValue(string optionName, SyntaxTree tree, DiagnosticDescriptor rule, TryParseValue`1<T> tryParseValue, T defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Lightup.ITypeSymbolExtensions : object {
    private static Func`2<ITypeSymbol, NullableAnnotation> s_nullableAnnotation;
    private static Func`3<ITypeSymbol, NullableAnnotation, ITypeSymbol> s_withNullableAnnotation;
    private static ITypeSymbolExtensions();
    [ExtensionAttribute]
public static NullableAnnotation NullableAnnotation(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static ITypeSymbol WithNullableAnnotation(ITypeSymbol typeSymbol, NullableAnnotation nullableAnnotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.Lightup.LightupHelpers : object {
    internal static Func`2<TSyntax, TProperty> CreateSyntaxPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    internal static Func`2<TSymbol, TProperty> CreateSymbolPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    private static Func`2<T, TProperty> CreatePropertyAccessor(Type type, string parameterName, string propertyName, TProperty fallbackResult);
    internal static Func`3<TSyntax, TProperty, TSyntax> CreateSyntaxWithPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    internal static Func`3<TSymbol, TProperty, TSymbol> CreateSymbolWithPropertyAccessor(Type type, string propertyName, TProperty fallbackResult);
    private static Func`3<T, TProperty, T> CreateWithPropertyAccessor(Type type, string parameterName, string propertyName, TProperty fallbackResult);
    internal static Func`3<T, TArg, TValue> CreateAccessorWithArgument(Type type, string parameterName, Type argumentType, string argumentName, string methodName, TValue fallbackResult);
    private static void VerifyTypeArgument(Type type);
    private static void VerifyResultTypeCompatibility(Type resultType);
    [NullableContextAttribute("2")]
private static bool TryGetProperty(Type type, string propertyName, PropertyInfo& propertyInfo);
    [NullableContextAttribute("2")]
private static bool TryGetMethod(Type type, string methodName, MethodInfo& methodInfo);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static TProperty <CreatePropertyAccessor>g__FallbackAccessor|2_1(T instance, TProperty fallbackResult);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <CreateWithPropertyAccessor>g__FallbackAccessor|5_3(T instance, TProperty newValue, TProperty fallbackResult);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static TValue <CreateAccessorWithArgument>g__FallbackAccessor|6_1(T instance, TValue fallbackResult);
}
internal enum Analyzer.Utilities.Lightup.NullableAnnotation : Enum {
    public byte value__;
    public static NullableAnnotation None;
    public static NullableAnnotation NotAnnotated;
    public static NullableAnnotation Annotated;
}
[FlagsAttribute]
internal enum Analyzer.Utilities.Lightup.NullableContext : Enum {
    public int value__;
    public static NullableContext Disabled;
    public static NullableContext WarningsEnabled;
    public static NullableContext AnnotationsEnabled;
    public static NullableContext Enabled;
    public static NullableContext WarningsContextInherited;
    public static NullableContext AnnotationsContextInherited;
    public static NullableContext ContextInherited;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.Lightup.NullableContextExtensions : object {
    private static bool IsFlagSet(NullableContext context, NullableContext flag);
    [ExtensionAttribute]
public static bool WarningsEnabled(NullableContext context);
    [ExtensionAttribute]
public static bool AnnotationsEnabled(NullableContext context);
    [ExtensionAttribute]
public static bool WarningsInherited(NullableContext context);
    [ExtensionAttribute]
public static bool AnnotationsInherited(NullableContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Analyzer.Utilities.Lightup.SemanticModelExtensions : object {
    private static Func`3<SemanticModel, int, NullableContext> s_getNullableContext;
    private static SemanticModelExtensions();
    [ExtensionAttribute]
public static NullableContext GetNullableContext(SemanticModel semanticModel, int position);
}
internal enum Analyzer.Utilities.Options.EnumValuesPrefixTrigger : Enum {
    public int value__;
    public static EnumValuesPrefixTrigger AnyEnumValue;
    public static EnumValuesPrefixTrigger AllEnumValues;
    public static EnumValuesPrefixTrigger Heuristic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Analyzer.Utilities.PooledObjects.ArrayBuilder`1/DebuggerProxy")]
internal class Analyzer.Utilities.PooledObjects.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void SetItem(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public sealed virtual void Dispose();
    public void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    internal static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    internal static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    [NullableContextAttribute("0")]
internal Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.PooledObjects.Extensions.PooledHashSetExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddRange(PooledHashSet`1<T> builder, IEnumerable`1<T> set2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.PooledObjects.ObjectPool`1 : object {
    [NullableAttribute("2")]
private T _firstItem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Element[] _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal static void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledConcurrentDictionary`2 : ConcurrentDictionary`2<K, V> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledConcurrentDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledConcurrentDictionary`2<K, V>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<K>, ObjectPool`1<PooledConcurrentDictionary`2<K, V>>> s_poolInstancesByComparer;
    private PooledConcurrentDictionary`2(ObjectPool`1<PooledConcurrentDictionary`2<K, V>> pool);
    private PooledConcurrentDictionary`2(ObjectPool`1<PooledConcurrentDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledConcurrentDictionary`2();
    public sealed virtual void Dispose();
    public void Free();
    public static ObjectPool`1<PooledConcurrentDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledConcurrentDictionary`2<K, V> GetInstance(IEqualityComparer`1<K> keyComparer);
    public static PooledConcurrentDictionary`2<K, V> GetInstance(IEnumerable`1<KeyValuePair`2<K, V>> initializer, IEqualityComparer`1<K> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1 : object {
    private PooledConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    private PooledConcurrentSet`1(PooledConcurrentDictionary`2<T, byte> dictionary);
    public sealed virtual void Dispose();
    public void Free();
    public static PooledConcurrentSet`1<T> GetInstance(IEqualityComparer`1<T> comparer);
    public static PooledConcurrentSet`1<T> GetInstance(IEnumerable`1<T> initializer, IEqualityComparer`1<T> comparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsReadOnly();
    public bool Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public sealed virtual bool Remove(T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [NullableContextAttribute("0")]
public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Analyzer.Utilities.PooledObjects.PooledConcurrentSet`1/<GetEnumeratorImpl>d__19")]
private IEnumerator`1<T> GetEnumeratorImpl();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledDictionary`2 : Dictionary`2<K, V> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<K>, ObjectPool`1<PooledDictionary`2<K, V>>> s_poolInstancesByComparer;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledDictionary`2();
    public sealed virtual void Dispose();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public ImmutableDictionary`2<TKey, TValue> ToImmutableDictionaryAndFree(Func`2<KeyValuePair`2<K, V>, TKey> keySelector, Func`2<KeyValuePair`2<K, V>, TValue> elementSelector, IEqualityComparer`1<TKey> comparer);
    public void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance(IEnumerable`1<KeyValuePair`2<K, V>> initializer, IEqualityComparer`1<K> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Analyzer.Utilities.PooledObjects.PooledHashSet`1 : HashSet`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private static ConcurrentDictionary`2<IEqualityComparer`1<T>, ObjectPool`1<PooledHashSet`1<T>>> s_poolInstancesByComparer;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool, IEqualityComparer`1<T> comparer);
    private static PooledHashSet`1();
    public sealed virtual void Dispose();
    public void Free();
    public ImmutableHashSet`1<T> ToImmutableAndFree();
    public ImmutableHashSet`1<T> ToImmutable();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool(IEqualityComparer`1<T> comparer);
    public static PooledHashSet`1<T> GetInstance(IEqualityComparer`1<T> comparer);
}
internal static class Analyzer.Utilities.RoslynDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.RoslynString : object {
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SingleThreadedConcurrentDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<TKey, Entry<TKey, TValue>> BackingDictionary;
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.SymbolDisplayFormats : object {
    public static SymbolDisplayFormat ShortSymbolDisplayFormat;
    public static SymbolDisplayFormat QualifiedTypeAndNamespaceSymbolDisplayFormat;
    private static SymbolDisplayFormats();
}
[FlagsAttribute]
internal enum Analyzer.Utilities.SymbolModifiers : Enum {
    public int value__;
    public static SymbolModifiers None;
    public static SymbolModifiers Static;
    public static SymbolModifiers Shared;
    public static SymbolModifiers Const;
    public static SymbolModifiers ReadOnly;
    public static SymbolModifiers Abstract;
    public static SymbolModifiers Virtual;
    public static SymbolModifiers Override;
    public static SymbolModifiers Sealed;
    public static SymbolModifiers Extern;
    public static SymbolModifiers Async;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.SymbolModifiersExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SymbolModifiers modifiers, SymbolModifiers modifiersToCheck);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SymbolModifiers GetSymbolModifiers(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SymbolNamesWithValueOption`1 : object {
    internal static SymbolKind AllKinds;
    internal static char WildcardChar;
    public static SymbolNamesWithValueOption`1<TValue> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static KeyValuePair`2<string, TValue> NoWildcardMatch;
    internal ImmutableDictionary`2<string, TValue> _names;
    internal ImmutableDictionary`2<ISymbol, TValue> _symbols;
    internal ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> _wildcardNamesBySymbolKind;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ConcurrentDictionary`2<ISymbol, KeyValuePair`2<string, TValue>> _wildcardMatchResult;
    public bool IsEmpty { get; }
    private SymbolNamesWithValueOption`1(ImmutableDictionary`2<string, TValue> names, ImmutableDictionary`2<ISymbol, TValue> symbols, ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> wildcardNamesBySymbolKind);
    private static SymbolNamesWithValueOption`1();
    public static SymbolNamesWithValueOption`1<TValue> Create(ImmutableArray`1<string> symbolNames, Compilation compilation, string optionalPrefix, Func`2<string, NameParts<TValue>> getSymbolNamePartsFunc);
    public bool get_IsEmpty();
    public bool Contains(ISymbol symbol);
    public bool TryGetValue(ISymbol symbol, TValue& value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolNamesWithValueOption`1<TValue> other);
    public virtual int GetHashCode();
    private bool TryGetFirstWildcardMatch(ISymbol symbol, KeyValuePair`2& firstMatch);
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessWildcardName|10_2(NameParts<TValue> parts, PooledDictionary`2<SymbolKind, PooledDictionary`2<string, TValue>> wildcardNamesBuilder);
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessName|10_3(NameParts<TValue> parts, PooledDictionary`2<string, TValue> namesBuilder);
    [CompilerGeneratedAttribute]
internal static void <Create>g__ProcessSymbolName|10_4(NameParts<TValue> parts, Compilation compilation, string optionalPrefix, PooledDictionary`2<ISymbol, TValue> symbolsBuilder);
    [CompilerGeneratedAttribute]
internal static bool <TryGetFirstWildcardMatch>g__TryUnqualifiedMatch|18_0(StringBuilder symbolFullNameBuilder, HashSet`1<SymbolKind> symbolKindsToCheck, ISymbol symbol, ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> wildcardNamesBySymbolKind, ConcurrentDictionary`2<ISymbol, KeyValuePair`2<string, TValue>> wildcardMatchResult, KeyValuePair`2& firstMatch);
    [CompilerGeneratedAttribute]
internal static bool <TryGetFirstWildcardMatch>g__TryQualifiedMatch|18_1(HashSet`1<SymbolKind> symbolKindsToCheck, ISymbol symbol, string fullyQualifiedSymbolName, ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> wildcardNamesBySymbolKind, ConcurrentDictionary`2<ISymbol, KeyValuePair`2<string, TValue>> wildcardMatchResult, KeyValuePair`2& firstMatch);
    [CompilerGeneratedAttribute]
internal static string <TryGetFirstWildcardMatch>g__GetSymbolNameWithParameters|18_2(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static void <TryGetFirstWildcardMatch>g__AppendParameterFullType|18_10(IParameterSymbol parameter, StringBuilder builder);
    [CompilerGeneratedAttribute]
internal static bool <TryGetFirstWildcardMatch>g__TryGetSymbolPartialMatch|18_3(StringBuilder builder, ISymbol symbol, string symbolName, ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> wildcardNamesBySymbolKind, ConcurrentDictionary`2<ISymbol, KeyValuePair`2<string, TValue>> wildcardMatchResult, KeyValuePair`2& firstMatch);
    [CompilerGeneratedAttribute]
internal static bool <TryGetFirstWildcardMatch>g__TryGetFirstWildcardMatch|18_4(SymbolKind kind, ISymbol symbol, string symbolName, ImmutableDictionary`2<SymbolKind, ImmutableDictionary`2<string, TValue>> wildcardNamesBySymbolKind, ConcurrentDictionary`2<ISymbol, KeyValuePair`2<string, TValue>> wildcardMatchResult, KeyValuePair`2& firstMatch);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.SymbolVisibilityGroup : Enum {
    public int value__;
    public static SymbolVisibilityGroup None;
    public static SymbolVisibilityGroup Public;
    public static SymbolVisibilityGroup Internal;
    public static SymbolVisibilityGroup Private;
    public static SymbolVisibilityGroup Friend;
    public static SymbolVisibilityGroup All;
}
[ExtensionAttribute]
internal static class Analyzer.Utilities.SymbolVisibilityGroupExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SymbolVisibilityGroup symbolVisibilityGroup, SymbolVisibility symbolVisibility);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.SyntaxTreeCategorizedAnalyzerConfigOptions : AbstractCategorizedAnalyzerConfigOptions {
    [NullableAttribute("2")]
private AnalyzerConfigOptions _analyzerConfigOptions;
    private static ConditionalWeakTable`2<ImmutableDictionary`2<string, string>, SyntaxTreeCategorizedAnalyzerConfigOptions> s_perTreeOptionsCache;
    public static SyntaxTreeCategorizedAnalyzerConfigOptions Empty;
    public bool IsEmpty { get; }
    [NullableContextAttribute("2")]
private SyntaxTreeCategorizedAnalyzerConfigOptions(AnalyzerConfigOptions analyzerConfigOptions);
    private static SyntaxTreeCategorizedAnalyzerConfigOptions();
    public static SyntaxTreeCategorizedAnalyzerConfigOptions Create(AnalyzerConfigOptions analyzerConfigOptions);
    public virtual bool get_IsEmpty();
    protected virtual bool TryGetOptionValue(string optionKeyPrefix, string optionKeySuffix, string optionName, String& valueString);
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> <Create>g__TryGetBackingOptionsDictionary|4_1(AnalyzerConfigOptions analyzerConfigOptions);
}
internal class Analyzer.Utilities.Unit : ValueType {
    public static Unit Default { get; }
    public sealed virtual bool Equals(Unit other);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool op_Equality(Unit first, Unit second);
    public static bool op_Inequality(Unit first, Unit second);
    public static Unit get_Default();
}
[IsReadOnlyAttribute]
internal class Analyzer.Utilities.UnusedValue : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Analyzer.Utilities.WellKnownTypeNames : object {
    public static string MicrosoftAspNetCoreAntiforgeryIAntiforgery;
    public static string MicrosoftAspNetCoreHttpCookieOptions;
    public static string MicrosoftAspNetCoreHttpInternalResponseCookies;
    public static string MicrosoftAspNetCoreHttpIResponseCookies;
    public static string MicrosoftAspNetCoreMvcController;
    public static string MicrosoftAspNetCoreMvcControllerBase;
    public static string MicrosoftAspNetCoreMvcFiltersAuthorizationFilterContext;
    public static string MicrosoftAspNetCoreMvcFiltersFilterCollection;
    public static string MicrosoftAspNetCoreMvcFiltersIAsyncAuthorizationFilter;
    public static string MicrosoftAspNetCoreMvcFiltersIAuthorizationFilter;
    public static string MicrosoftAspNetCoreMvcFiltersIFilterMetadata;
    public static string MicrosoftAspNetCoreMvcHttpDeleteAttribute;
    public static string MicrosoftAspNetCoreMvcHttpGetAttribute;
    public static string MicrosoftAspNetCoreMvcHttpHeadAttribute;
    public static string MicrosoftAspNetCoreMvcHttpOptionsAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPatchAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPostAttribute;
    public static string MicrosoftAspNetCoreMvcHttpPutAttribute;
    public static string MicrosoftAspNetCoreMvcNonActionAttribute;
    public static string MicrosoftAspNetCoreMvcRouteAttribute;
    public static string MicrosoftAspNetCoreMvcRoutingHttpMethodAttribute;
    public static string MicrosoftAspNetCoreRazorHostingRazorCompiledItemAttribute;
    public static string MicrosoftCodeAnalysisCompilation;
    public static string MicrosoftCodeAnalysisCSharpCSharpCompilation;
    public static string MicrosoftCodeAnalysisDiagnostic;
    public static string MicrosoftCodeAnalysisDiagnosticDescriptor;
    public static string MicrosoftCodeAnalysisDiagnosticsAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCodeBlockAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCodeBlockStartAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCompilationEndAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsCompilationStartAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsDiagnosticAnalyzer;
    public static string MicrosoftCodeAnalysisDiagnosticsDiagnosticAnalyzerAttribute;
    public static string MicrosoftCodeAnalysisDiagnosticsGeneratedCodeAnalysisFlags;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationBlockAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsOperationBlockStartAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSemanticModelAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSymbolAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSyntaxNodeAnalysisContext;
    public static string MicrosoftCodeAnalysisDiagnosticsSyntaxTreeAnalysisContext;
    public static string MicrosoftCodeAnalysisHostMefMefConstruction;
    public static string MicrosoftCodeAnalysisLocalizableString;
    public static string MicrosoftCodeAnalysisSymbolKind;
    public static string MicrosoftCodeAnalysisVisualBasicVisualBasicCompilation;
    public static string MicrosoftEntityFrameworkCoreEntityFrameworkQueryableExtensions;
    public static string MicrosoftSecurityApplicationAntiXss;
    public static string MicrosoftSecurityApplicationAntiXssEncoder;
    public static string MicrosoftSecurityApplicationEncoder;
    public static string MicrosoftSecurityApplicationUnicodeCharacterEncoder;
    public static string MicrosoftVisualBasicDevicesComputerInfo;
    public static string MicrosoftVisualStudioTestToolsUnitTestingAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingCollectionAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingDataTestMethodAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingExpectedExceptionAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingStringAssert;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestCleanupAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestInitializeAttribute;
    public static string MicrosoftVisualStudioTestToolsUnitTestingTestMethodAttribute;
    public static string MicrosoftWindowsAzureStorageCloudStorageAccount;
    public static string MicrosoftWindowsAzureStorageSharedAccessProtocol;
    public static string NewtonsoftJsonJsonConvert;
    public static string NewtonsoftJsonJsonSerializer;
    public static string NewtonsoftJsonJsonSerializerSettings;
    public static string NewtonsoftJsonTypeNameHandling;
    public static string NUnitFrameworkAssert;
    public static string NUnitFrameworkOneTimeSetUpAttribute;
    public static string NUnitFrameworkOneTimeTearDownAttribute;
    public static string NUnitFrameworkSetUpAttribute;
    public static string NUnitFrameworkTearDownAttribute;
    public static string NUnitFrameworkTestAttribute;
    public static string NUnitFrameworkTestCaseAttribute;
    public static string NUnitFrameworkTestCaseSourceAttribute;
    public static string NUnitFrameworkTheoryAttribute;
    public static string RoslynUtilitiesNonDefaultableAttribute;
    public static string SystemActivator;
    public static string SystemAppContext;
    public static string SystemAppDomain;
    public static string SystemArgumentException;
    public static string SystemAttribute;
    public static string SystemAttributeUsageAttribute;
    public static string SystemBoolean;
    public static string SystemBuffersMemoryManager1;
    public static string SystemByte;
    public static string SystemChar;
    public static string SystemCLSCompliantAttribute;
    public static string SystemCodeDomCompilerGeneratedCodeAttribute;
    public static string SystemCollectionsGenericICollection1;
    public static string SystemCollectionsGenericIEnumerable1;
    public static string SystemCollectionsGenericIEnumerator1;
    public static string SystemCollectionsGenericIEqualityComparer1;
    public static string SystemCollectionsGenericIList1;
    public static string SystemCollectionsGenericIReadOnlyCollection1;
    public static string SystemCollectionsGenericKeyNotFoundException;
    public static string SystemCollectionsGenericList1;
    public static string SystemCollectionsICollection;
    public static string SystemCollectionsIEnumerable;
    public static string SystemCollectionsIEnumerator;
    public static string SystemCollectionsIHashCodeProvider;
    public static string SystemCollectionsIList;
    public static string SystemCollectionsImmutableIImmutableDictionary;
    public static string SystemCollectionsImmutableIImmutableList;
    public static string SystemCollectionsImmutableIImmutableQueue;
    public static string SystemCollectionsImmutableIImmutableSet;
    public static string SystemCollectionsImmutableIImmutableStack;
    public static string SystemCollectionsImmutableImmutableArray;
    public static string SystemCollectionsObjectModelReadOnlyCollection1;
    public static string SystemCollectionsObjectModelReadOnlyDictionary2;
    public static string SystemCollectionsObjectModelReadOnlyObservableCollection1;
    public static string SystemComponentModelComponent;
    public static string SystemComponentModelCompositionExportAttribute;
    public static string SystemComponentModelCompositionImportingConstructorAttribute;
    public static string SystemComponentModelCompositionInheritedExportAttribute;
    public static string SystemComponentModelDesignerAttribute;
    public static string SystemComponentModelLocalizableAttribute;
    public static string SystemCompositionExportAttribute;
    public static string SystemCompositionImportingConstructorAttribute;
    public static string SystemConfigurationConfigurationSection;
    public static string SystemConfigurationIConfigurationSectionHandler;
    public static string SystemConsole;
    public static string SystemConvert;
    public static string SystemDataDataRow;
    public static string SystemDataDataSet;
    public static string SystemDataDataTable;
    public static string SystemDataDataViewManager;
    public static string SystemDataEntityQueryableExtensions;
    public static string SystemDataIDataAdapter;
    public static string SystemDataIDbCommand;
    public static string SystemDateTime;
    public static string SystemDecimal;
    public static string SystemDiagnosticContractsContract;
    public static string SystemDiagnosticsConditionalAttribute;
    public static string SystemDiagnosticsContractsPureAttribute;
    public static string SystemDiagnosticsDebug;
    public static string SystemDiagnosticsProcess;
    public static string SystemDiagnosticsProcessStartInfo;
    public static string SystemDiagnosticsTraceListener;
    public static string SystemDiagnosticsTracingEventSource;
    public static string SystemDirectoryDirectoryEntry;
    public static string SystemDirectoryServicesActiveDirectoryADSearcher;
    public static string SystemDirectoryServicesDirectorySearcher;
    public static string SystemDouble;
    public static string SystemEventArgs;
    public static string SystemEventHandler1;
    public static string SystemException;
    public static string SystemExecutionEngineException;
    public static string SystemFlagsAttribute;
    public static string SystemGC;
    public static string SystemGlobalizationCultureInfo;
    public static string SystemGuid;
    public static string SystemIAsyncDisposable;
    public static string SystemIComparable;
    public static string SystemIComparable1;
    public static string SystemIDisposable;
    public static string SystemIEquatable1;
    public static string SystemIFormatProvider;
    public static string SystemIndex;
    public static string SystemInt16;
    public static string SystemInt32;
    public static string SystemInt64;
    public static string SystemInvalidOperationException;
    public static string SystemIOCompressionZipArchiveEntry;
    public static string SystemIOCompressionZipFileExtensions;
    public static string SystemIODirectory;
    public static string SystemIODirectoryInfo;
    public static string SystemIOFile;
    public static string SystemIOFileInfo;
    public static string SystemIOFileStream;
    public static string SystemIOLogLogStore;
    public static string SystemIOPath;
    public static string SystemIOStream;
    public static string SystemIOStringReader;
    public static string SystemIOUnmanagedMemoryStream;
    public static string SystemIProgress1;
    public static string SystemLinqEnumerable;
    public static string SystemLinqQueryable;
    public static string SystemMarshalByRefObject;
    public static string SystemMemory1;
    public static string SystemNetHttpHttpClient;
    public static string SystemNetHttpHttpClientHandler;
    public static string SystemNetHttpWinHttpHandler;
    public static string SystemNetSecurityProtocolType;
    public static string SystemNetSecurityRemoteCertificateValidationCallback;
    public static string SystemNetSecuritySslPolicyErrors;
    public static string SystemNetServicePointManager;
    public static string SystemNonSerializedAttribute;
    public static string SystemNotImplementedException;
    public static string SystemNotSupportedException;
    public static string SystemNullable1;
    public static string SystemNumber;
    public static string SystemObsoleteAttribute;
    public static string SystemOutOfMemoryException;
    public static string SystemRandom;
    public static string SystemRange;
    public static string SystemReadOnlyMemory1;
    public static string SystemReadOnlySpan1;
    public static string SystemReflectionAssemblyFullName;
    public static string SystemReflectionAssemblyVersionAttribute;
    public static string SystemReflectionMemberInfo;
    public static string SystemReflectionParameterInfo;
    public static string SystemResourcesNeutralResourcesLanguageAttribute;
    public static string SystemResourcesResourceManager;
    public static string SystemRuntimeCompilerServicesCompilerGeneratedAttribute;
    public static string SystemRuntimeCompilerServicesGenericConfiguredValueTaskAwaitable;
    public static string SystemRuntimeCompilerServicesInternalsVisibleToAttribute;
    public static string SystemRuntimeCompilerServicesRestrictedInternalsVisibleToAttribute;
    public static string SystemRuntimeCompilerServicesTypeForwardedToAttribute;
    public static string SystemRuntimeExceptionServicesHandleProcessCorruptedStateExceptionsAttribute;
    public static string SystemRuntimeInteropServicesCharSet;
    public static string SystemRuntimeInteropServicesCoClassAttribute;
    public static string SystemRuntimeInteropServicesComSourceInterfacesAttribute;
    public static string SystemRuntimeInteropServicesComVisibleAttribute;
    public static string SystemRuntimeInteropServicesDefaultDllImportSearchPathsAttribute;
    public static string SystemRuntimeInteropServicesDllImportAttribute;
    public static string SystemRuntimeInteropServicesFieldOffsetAttribute;
    public static string SystemRuntimeInteropServicesGCHandle;
    public static string SystemRuntimeInteropServicesHandleRef;
    public static string SystemRuntimeInteropServicesMarshalAsAttribute;
    public static string SystemRuntimeInteropServicesOutAttribute;
    public static string SystemRuntimeInteropServicesSafeHandle;
    public static string SystemRuntimeInteropServicesStructLayoutAttribute;
    public static string SystemRuntimeInteropServicesUnmanagedType;
    public static string SystemRuntimeSerializationDataMemberAttribute;
    public static string SystemRuntimeSerializationFormattersBinaryBinaryFormatter;
    public static string SystemRuntimeSerializationIDeserializationCallback;
    public static string SystemRuntimeSerializationISerializable;
    public static string SystemRuntimeSerializationNetDataContractSerializer;
    public static string SystemRuntimeSerializationOnDeserializedAttribute;
    public static string SystemRuntimeSerializationOnDeserializingAttribute;
    public static string SystemRuntimeSerializationOnSerializedAttribute;
    public static string SystemRuntimeSerializationOnSerializingAttribute;
    public static string SystemRuntimeSerializationSerializationInfo;
    public static string SystemRuntimeSerializationStreamingContext;
    public static string SystemSecurityAuthenticationSslProtocols;
    public static string SystemSecurityCryptographyAesCcm;
    public static string SystemSecurityCryptographyAesGcm;
    public static string SystemSecurityCryptographyAsymmetricAlgorithm;
    public static string SystemSecurityCryptographyCipherMode;
    public static string SystemSecurityCryptographyCryptoConfig;
    public static string SystemSecurityCryptographyDES;
    public static string SystemSecurityCryptographyDSA;
    public static string SystemSecurityCryptographyDSASignatureFormatter;
    public static string SystemSecurityCryptographyHashAlgorithmName;
    public static string SystemSecurityCryptographyHMACMD5;
    public static string SystemSecurityCryptographyHMACRIPEMD160;
    public static string SystemSecurityCryptographyHMACSHA1;
    public static string SystemSecurityCryptographyMD5;
    public static string SystemSecurityCryptographyPasswordDeriveBytes;
    public static string SystemSecurityCryptographyRC2;
    public static string SystemSecurityCryptographyRfc2898DeriveBytes;
    public static string SystemSecurityCryptographyRIPEMD160;
    public static string SystemSecurityCryptographyRSA;
    public static string SystemSecurityCryptographySHA1;
    public static string SystemSecurityCryptographySymmetricAlgorithm;
    public static string SystemSecurityCryptographyTripleDES;
    public static string SystemSecurityCryptographyX509CertificatesStoreName;
    public static string SystemSecurityCryptographyX509CertificatesX509Certificate;
    public static string SystemSecurityCryptographyX509CertificatesX509Certificate2;
    public static string SystemSecurityCryptographyX509CertificatesX509Chain;
    public static string SystemSecurityCryptographyX509CertificatesX509Store;
    public static string SystemSerializableAttribute;
    public static string SystemSingle;
    public static string SystemSpan1;
    public static string SystemStackOverflowException;
    public static string SystemString;
    public static string SystemStringComparison;
    public static string SystemSystemException;
    public static string SystemTextEncoding;
    public static string SystemTextRegularExpressionsRegex;
    public static string SystemTextStringBuilder;
    public static string SystemThreadingCancellationToken;
    public static string SystemThreadingInterlocked;
    public static string SystemThreadingMonitor;
    public static string SystemThreadingSpinLock;
    public static string SystemThreadingTasksGenericTask;
    public static string SystemThreadingTasksGenericValueTask;
    public static string SystemThreadingTasksTask;
    public static string SystemThreadingTasksTaskCompletionSource;
    public static string SystemThreadingTasksTaskContinuationOptions;
    public static string SystemThreadingTasksTaskCreationOptions;
    public static string SystemThreadingTasksTaskFactory;
    public static string SystemThreadingTasksTaskScheduler;
    public static string SystemThreadingTasksValueTask;
    public static string SystemThreadingThread;
    public static string SystemTimeSpan;
    public static string SystemUri;
    public static string SystemWebConfigurationHttpRuntimeSection;
    public static string SystemWebHttpApplication;
    public static string SystemWebHttpCookie;
    public static string SystemWebHttpRequest;
    public static string SystemWebHttpRequestBase;
    public static string SystemWebHttpRequestWrapper;
    public static string SystemWebHttpResponse;
    public static string SystemWebHttpResponseBase;
    public static string SystemWebHttpRouteAttribute;
    public static string SystemWebHttpServerUtility;
    public static string SystemWebHttpServerUtilityBase;
    public static string SystemWebHttpServerUtilityWrapper;
    public static string SystemWebHttpUtility;
    public static string SystemWebMvcAcceptVerbsAttribute;
    public static string SystemWebMvcActionResult;
    public static string SystemWebMvcChildActionOnlyAttribute;
    public static string SystemWebMvcController;
    public static string SystemWebMvcControllerBase;
    public static string SystemWebMvcHttpDeleteAttribute;
    public static string SystemWebMvcHttpGetAttribute;
    public static string SystemWebMvcHttpHeadAttribute;
    public static string SystemWebMvcHttpOptionsAttribute;
    public static string SystemWebMvcHttpPatchAttribute;
    public static string SystemWebMvcHttpPostAttribute;
    public static string SystemWebMvcHttpPutAttribute;
    public static string SystemWebMvcHttpVerbs;
    public static string SystemWebMvcNonActionAttribute;
    public static string SystemWebMvcValidateAntiForgeryTokenAttribute;
    public static string SystemWebMvcValidateInputAttribute;
    public static string SystemWebScriptSerializationJavaScriptSerializer;
    public static string SystemWebScriptSerializationJavaScriptTypeResolver;
    public static string SystemWebScriptSerializationSimpleTypeResolver;
    public static string SystemWebSecurityAntiXssAntiXssEncoder;
    public static string SystemWebSecurityAntiXssUnicodeCharacterEncoder;
    public static string SystemWebServicesWebMethodAttribute;
    public static string SystemWebUIAdaptersPageAdapter;
    public static string SystemWebUIControl;
    public static string SystemWebUIDataBoundLiteralControl;
    public static string SystemWebUIDesignerDataBoundLiteralControl;
    public static string SystemWebUIHtmlControlsHtmlContainerControl;
    public static string SystemWebUIHtmlControlsHtmlInputControl;
    public static string SystemWebUIHtmlControlsHtmlTitle;
    public static string SystemWebUIHtmlTextWriter;
    public static string SystemWebUIIndexedString;
    public static string SystemWebUIITextControl;
    public static string SystemWebUILiteralControl;
    public static string SystemWebUILosFormatter;
    public static string SystemWebUIObjectStateFormatter;
    public static string SystemWebUIPage;
    public static string SystemWebUIPageTheme;
    public static string SystemWebUIResourceBasedLiteralControl;
    public static string SystemWebUISimplePropertyEntry;
    public static string SystemWebUIStateItem;
    public static string SystemWebUIStringPropertyBuilder;
    public static string SystemWebUITemplateBuilder;
    public static string SystemWebUITemplateControl;
    public static string SystemWebUITemplateParser;
    public static string SystemWebUIWebControlsBaseDataList;
    public static string SystemWebUIWebControlsBaseValidator;
    public static string SystemWebUIWebControlsBulletedList;
    public static string SystemWebUIWebControlsButton;
    public static string SystemWebUIWebControlsButtonColumn;
    public static string SystemWebUIWebControlsButtonField;
    public static string SystemWebUIWebControlsCalendar;
    public static string SystemWebUIWebControlsChangePassword;
    public static string SystemWebUIWebControlsCheckBox;
    public static string SystemWebUIWebControlsCheckBoxField;
    public static string SystemWebUIWebControlsCommandEventArgs;
    public static string SystemWebUIWebControlsCreateUserWizard;
    public static string SystemWebUIWebControlsDataKey;
    public static string SystemWebUIWebControlsDataList;
    public static string SystemWebUIWebControlsDetailsView;
    public static string SystemWebUIWebControlsDetailsViewInsertEventArgs;
    public static string SystemWebUIWebControlsDetailsViewUpdateEventArgs;
    public static string SystemWebUIWebControlsFormView;
    public static string SystemWebUIWebControlsFormViewInsertEventArgs;
    public static string SystemWebUIWebControlsFormViewUpdateEventArgs;
    public static string SystemWebUIWebControlsGridView;
    public static string SystemWebUIWebControlsHiddenField;
    public static string SystemWebUIWebControlsHyperLink;
    public static string SystemWebUIWebControlsHyperLinkColumn;
    public static string SystemWebUIWebControlsHyperLinkField;
    public static string SystemWebUIWebControlsImage;
    public static string SystemWebUIWebControlsImageButton;
    public static string SystemWebUIWebControlsLabel;
    public static string SystemWebUIWebControlsLinkButton;
    public static string SystemWebUIWebControlsListControl;
    public static string SystemWebUIWebControlsListItem;
    public static string SystemWebUIWebControlsLiteral;
    public static string SystemWebUIWebControlsLogin;
    public static string SystemWebUIWebControlsMenu;
    public static string SystemWebUIWebControlsMenuItem;
    public static string SystemWebUIWebControlsMenuItemBinding;
    public static string SystemWebUIWebControlsPasswordRecovery;
    public static string SystemWebUIWebControlsQueryStringParameter;
    public static string SystemWebUIWebControlsRadioButtonList;
    public static string SystemWebUIWebControlsRepeatInfo;
    public static string SystemWebUIWebControlsServerValidateEventArgs;
    public static string SystemWebUIWebControlsSqlDataSource;
    public static string SystemWebUIWebControlsTable;
    public static string SystemWebUIWebControlsTableCell;
    public static string SystemWebUIWebControlsTextBox;
    public static string SystemWebUIWebControlsTreeNode;
    public static string SystemWebUIWebControlsTreeNodeBinding;
    public static string SystemWebUIWebControlsTreeView;
    public static string SystemWebUIWebControlsUnit;
    public static string SystemWebUIWebControlsWebPartsAppearanceEditorPart;
    public static string SystemWebUIWebControlsWebPartsPersonalizationEntry;
    public static string SystemWebUIWebControlsWebPartsWebPartCatalogAddVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartCatalogCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsCancelVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsConfigureVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsConnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectionsDisconnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartConnectVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartDeleteVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorApplyVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorCancelVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditorOKVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartEditVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartExportVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartHeaderCloseVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartHelpVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartMinimizeVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartRestoreVerb;
    public static string SystemWebUIWebControlsWebPartsWebPartVerb;
    public static string SystemWebUIWebControlsXmlDataSource;
    public static string SystemWebUIXPathBinder;
    public static string SystemWebUtilHttpEncoder;
    public static string SystemWindowsAssemblyPart;
    public static string SystemWindowsMarkupXamlReader;
    public static string SystemXmlDtdProcessing;
    public static string SystemXmlSchemaXmlSchema;
    public static string SystemXmlSchemaXmlSchemaCollection;
    public static string SystemXmlSchemaXmlSchemaXPath;
    public static string SystemXmlSerializationXmlSerializer;
    public static string SystemXmlXmlAttribute;
    public static string SystemXmlXmlDocument;
    public static string SystemXmlXmlDocumentFragment;
    public static string SystemXmlXmlElement;
    public static string SystemXmlXmlEntity;
    public static string SystemXmlXmlNode;
    public static string SystemXmlXmlNotation;
    public static string SystemXmlXmlReader;
    public static string SystemXmlXmlReaderSettings;
    public static string SystemXmlXmlResolver;
    public static string SystemXmlXmlSecureResolver;
    public static string SystemXmlXmlTextReader;
    public static string SystemXmlXmlTextWriter;
    public static string SystemXmlXmlValidatingReader;
    public static string SystemXmlXmlWriter;
    public static string SystemXmlXPathXPathDocument;
    public static string SystemXmlXPathXPathExpression;
    public static string SystemXmlXPathXPathNavigator;
    public static string SystemXmlXslXslCompiledTransform;
    public static string SystemXmlXslXslTransform;
    public static string SystemXmlXslXsltSettings;
    public static string XunitAssert;
    public static string XunitFactAttribute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Analyzer.Utilities.WellKnownTypeProvider : object {
    private static BoundedCacheWithFactory`2<Compilation, WellKnownTypeProvider> s_providerCache;
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, INamedTypeSymbol> _fullNameToTypeMap;
    public Compilation Compilation { get; }
    private WellKnownTypeProvider(Compilation compilation);
    private static WellKnownTypeProvider();
    public static WellKnownTypeProvider GetOrCreate(Compilation compilation);
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    public bool TryGetOrCreateTypeByMetadataName(string fullTypeName, INamedTypeSymbol& namedTypeSymbol);
    public INamedTypeSymbol GetOrCreateTypeByMetadataName(string fullTypeName);
    internal bool IsTaskOfType(ITypeSymbol typeSymbol, Func`2<ITypeSymbol, bool> typeArgumentPredicate);
    [CompilerGeneratedAttribute]
internal static WellKnownTypeProvider <GetOrCreate>g__CreateWellKnownTypeProvider|2_0(Compilation compilation);
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <TryGetOrCreateTypeByMetadataName>b__7_0(string fullyQualifiedMetadataName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Analyzer.Utilities.WordParser : object {
    private static char NullChar;
    private WordParserOptions _options;
    private StringBuilder _buffer;
    private string _text;
    [NullableAttribute("2")]
private string _peekedWord;
    private int _index;
    private char _prefix;
    private bool SkipMnemonics { get; }
    private bool SplitCompoundWords { get; }
    public WordParser(string text, WordParserOptions options);
    public WordParser(string text, WordParserOptions options, char prefix);
    private bool get_SkipMnemonics();
    private bool get_SplitCompoundWords();
    internal static Collection`1<string> Parse(string text, WordParserOptions options);
    internal static Collection`1<string> Parse(string text, WordParserOptions options, char prefix);
    public static bool ContainsWord(string text, WordParserOptions options, ImmutableArray`1<string> words);
    internal static bool ContainsWord(string text, WordParserOptions options, char prefix, ImmutableArray`1<string> words);
    [NullableContextAttribute("2")]
public string NextWord();
    [NullableContextAttribute("2")]
public string PeekWord();
    [NullableContextAttribute("2")]
private string NextWordCore();
    private bool ParseNext();
    private bool TryParseWord(char c);
    private bool TryParsePrefix();
    private void ParseWholeWord();
    private void ParseInteger();
    private void ParseHex();
    private void ParseNumeric();
    private void ParseLowercase();
    private void ParseUppercase();
    private void ParseWithoutCase();
    private void ParseAllCaps();
    private void Read();
    private void Skip();
    private char Peek();
    private char Peek(int lookAhead);
    private void Unread();
    private bool IsIgnored(char c);
    private static bool IsLower(char c);
    private static bool IsUpper(char c);
    private static bool IsLetterOrDigit(char c);
    private static bool IsLetterWithoutCase(char c);
    private static bool IsDigit(char c);
    private static bool IsHexDigit(char c);
    private static bool IsIntraWordPunctuation(char c);
}
[FlagsAttribute]
internal enum Analyzer.Utilities.WordParserOptions : Enum {
    public int value__;
    public static WordParserOptions None;
    public static WordParserOptions IgnoreMnemonicsIndicators;
    public static WordParserOptions SplitCompoundWords;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData : object {
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ComputationalComplexityMetrics <ComputationalComplexityMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaintainabilityIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<INamedTypeSymbol> <CoupledNamedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SourceLines>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExecutableLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CyclomaticComplexity>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DepthOfInheritance>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<CodeAnalysisMetricData> <Children>k__BackingField;
    public ISymbol Symbol { get; }
    internal ComputationalComplexityMetrics ComputationalComplexityMetrics { get; }
    public int MaintainabilityIndex { get; }
    public ImmutableHashSet`1<INamedTypeSymbol> CoupledNamedTypes { get; }
    public long SourceLines { get; }
    public long ExecutableLines { get; }
    public int CyclomaticComplexity { get; }
    public Nullable`1<int> DepthOfInheritance { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CodeAnalysisMetricData> Children { get; }
    internal CodeAnalysisMetricData(ISymbol symbol, int maintainabilityIndex, ComputationalComplexityMetrics computationalComplexityMetrics, ImmutableHashSet`1<INamedTypeSymbol> coupledNamedTypes, long linesOfCode, int cyclomaticComplexity, Nullable`1<int> depthOfInheritance, ImmutableArray`1<CodeAnalysisMetricData> children);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
internal ComputationalComplexityMetrics get_ComputationalComplexityMetrics();
    [CompilerGeneratedAttribute]
public int get_MaintainabilityIndex();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<INamedTypeSymbol> get_CoupledNamedTypes();
    [CompilerGeneratedAttribute]
public long get_SourceLines();
    [CompilerGeneratedAttribute]
public long get_ExecutableLines();
    [CompilerGeneratedAttribute]
public int get_CyclomaticComplexity();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DepthOfInheritance();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CodeAnalysisMetricData> get_Children();
    public sealed virtual string ToString();
    [ObsoleteAttribute("Use ComputeAsync(CodeMetricsAnalysisContext) instead.")]
public static Task`1<CodeAnalysisMetricData> ComputeAsync(Compilation compilation, CancellationToken cancellationToken);
    public static Task`1<CodeAnalysisMetricData> ComputeAsync(CodeMetricsAnalysisContext context);
    [ObsoleteAttribute("Use ComputeAsync(ISymbol, CodeMetricsAnalysisContext) instead.")]
public static Task`1<CodeAnalysisMetricData> ComputeAsync(ISymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    public static Task`1<CodeAnalysisMetricData> ComputeAsync(ISymbol symbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData/<ComputeAsync>d__34")]
internal static Task`1<ImmutableArray`1<CodeAnalysisMetricData>> ComputeAsync(IEnumerable`1<ISymbol> children, CodeMetricsAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <ToString>g__appendChildren|29_0(string indent, <>c__DisplayClass29_0& );
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.CodeAnalysisMetricData/<<ComputeAsync>g__ComputeAsync|33_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<CodeAnalysisMetricData> <ComputeAsync>g__ComputeAsync|33_0(ISymbol symbol, CodeMetricsAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.CodeMetrics.CodeMetricsAnalysisContext : object {
    private ConcurrentDictionary`2<SyntaxTree, SemanticModel> _semanticModelMap;
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<INamedTypeSymbol, bool> <IsExcludedFromInheritanceCountFunc>k__BackingField;
    public Compilation Compilation { get; }
    public CancellationToken CancellationToken { get; }
    public Func`2<INamedTypeSymbol, bool> IsExcludedFromInheritanceCountFunc { get; }
    public CodeMetricsAnalysisContext(Compilation compilation, CancellationToken cancellationToken, Func`2<INamedTypeSymbol, bool> isExcludedFromInheritanceCountFunc);
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public Func`2<INamedTypeSymbol, bool> get_IsExcludedFromInheritanceCountFunc();
    internal SemanticModel GetSemanticModel(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeMetrics.ComputationalComplexityMetrics : object {
    internal static ComputationalComplexityMetrics Default;
    private static object s_nullConstantPlaceholder;
    private long _symbolUsageCounts;
    private long _constantUsageCounts;
    private ImmutableHashSet`1<OperationKind> _distinctOperatorKinds;
    private ImmutableHashSet`1<BinaryOperatorKind> _distinctBinaryOperatorKinds;
    private ImmutableHashSet`1<UnaryOperatorKind> _distinctUnaryOperatorKinds;
    private ImmutableHashSet`1<CaseKind> _distinctCaseKinds;
    private ImmutableHashSet`1<ISymbol> _distinctReferencedSymbols;
    private ImmutableHashSet`1<object> _distinctReferencedConstants;
    [CompilerGeneratedAttribute]
private long <TotalOperators>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExecutableLines>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EffectiveLinesOfCode>k__BackingField;
    public bool IsDefault { get; }
    public long DistinctOperators { get; }
    public long DistinctOperands { get; }
    public long TotalOperators { get; }
    public long TotalOperands { get; }
    public long Vocabulary { get; }
    public long Length { get; }
    public double Volume { get; }
    public long ExecutableLines { get; }
    public long EffectiveLinesOfCode { get; }
    private ComputationalComplexityMetrics(long executableLinesOfCode, long effectiveLinesOfMaintainableCode, long operatorUsageCounts, long symbolUsageCounts, long constantUsageCounts, ImmutableHashSet`1<OperationKind> distinctOperatorKinds, ImmutableHashSet`1<BinaryOperatorKind> distinctBinaryOperatorKinds, ImmutableHashSet`1<UnaryOperatorKind> distinctUnaryOperatorKinds, ImmutableHashSet`1<CaseKind> distinctCaseKinds, ImmutableHashSet`1<ISymbol> distinctReferencedSymbols, ImmutableHashSet`1<object> distinctReferencedConstants);
    private static ComputationalComplexityMetrics();
    private static ComputationalComplexityMetrics Create(long executableLinesOfCode, long operatorUsageCounts, long symbolUsageCounts, long constantUsageCounts, bool hasSymbolInitializer, ImmutableHashSet`1<OperationKind> distinctOperatorKinds, ImmutableHashSet`1<BinaryOperatorKind> distinctBinaryOperatorKinds, ImmutableHashSet`1<UnaryOperatorKind> distinctUnaryOperatorKinds, ImmutableHashSet`1<CaseKind> distinctCaseKinds, ImmutableHashSet`1<ISymbol> distinctReferencedSymbols, ImmutableHashSet`1<object> distinctReferencedConstants);
    public static ComputationalComplexityMetrics Compute(IOperation operationBlock);
    public ComputationalComplexityMetrics Union(ComputationalComplexityMetrics other);
    public bool get_IsDefault();
    public long get_DistinctOperators();
    public long get_DistinctOperands();
    [CompilerGeneratedAttribute]
public long get_TotalOperators();
    public long get_TotalOperands();
    public long get_Vocabulary();
    public long get_Length();
    public double get_Volume();
    [CompilerGeneratedAttribute]
public long get_ExecutableLines();
    [CompilerGeneratedAttribute]
public long get_EffectiveLinesOfCode();
    [CompilerGeneratedAttribute]
internal static int <Compute>g__getExecutableLinesOfCode|12_0(IOperation operation, Boolean& hasSymbolInitializer);
    [CompilerGeneratedAttribute]
internal static bool <Compute>g__hasAnyExplicitExpression|12_1(IOperation operation);
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countOperator|12_2(IOperation operation, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countOperand|12_3(ISymbol symbol, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countBinaryOperator|12_4(IOperation operation, BinaryOperatorKind operatorKind, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static void <Compute>g__countUnaryOperator|12_5(IOperation operation, UnaryOperatorKind operatorKind, <>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper : object {
    internal static int GetAverageRoundedMetricValue(int total, int childrenCount);
    private static int RoundMetricValue(double value);
    internal static int NormalizeAndRoundMaintainabilityIndex(double maintIndex);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, IEnumerable`1<ITypeSymbol> coupledTypes);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, ITypeSymbol[] coupledTypes);
    internal static void AddCoupledNamedTypes(Builder<INamedTypeSymbol> builder, WellKnownTypeProvider wellKnownTypeProvider, ImmutableArray`1<IParameterSymbol> parameters);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<GetLinesOfCodeAsync>d__6")]
internal static Task`1<long> GetLinesOfCodeAsync(ImmutableArray`1<SyntaxReference> declarations, ISymbol symbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<GetTopmostSyntaxNodeForDeclarationAsync>d__7")]
internal static Task`1<SyntaxNode> GetTopmostSyntaxNodeForDeclarationAsync(SyntaxReference declaration, ISymbol declaredSymbol, CodeMetricsAnalysisContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeMetrics.MetricsHelper/<ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync>d__8")]
internal static Task`1<ValueTuple`2<int, ComputationalComplexityMetrics>> ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync(ImmutableArray`1<SyntaxReference> declarations, ISymbol symbol, Builder<INamedTypeSymbol> builder, CodeMetricsAnalysisContext context);
    private static void AddCoupledNamedTypesCore(Builder<INamedTypeSymbol> builder, ITypeSymbol typeOpt, WellKnownTypeProvider wellKnownTypeProvider);
    internal static void RemoveContainingTypes(ISymbol symbol, Builder<INamedTypeSymbol> coupledTypesBuilder);
    [ExtensionAttribute]
internal static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol member);
    [CompilerGeneratedAttribute]
internal static int <GetLinesOfCodeAsync>g__GetNewlineCount|6_0(SyntaxTriviaList trivialList, bool leading);
    [CompilerGeneratedAttribute]
internal static int <GetLinesOfCodeAsync>g__GetNewlineCount|6_1(ImmutableArray`1<string> triviaParts, bool leading);
    [CompilerGeneratedAttribute]
internal static bool <GetLinesOfCodeAsync>g__LoopConditionForLeading|6_2(int index, int length);
    [CompilerGeneratedAttribute]
internal static bool <GetLinesOfCodeAsync>g__LoopConditionForTrailing|6_3(int index, int _);
    [CompilerGeneratedAttribute]
internal static bool <ComputeCoupledTypesAndComplexityExcludingMemberDeclsAsync>g__hasConditionalLogic|8_0(IOperation operation);
    [CompilerGeneratedAttribute]
internal static bool <AddCoupledNamedTypesCore>g__isIgnoreableType|9_0(INamedTypeSymbol namedType, WellKnownTypeProvider wellKnownTypeProvider);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions/<GetPredecessorsWithBranches>d__0")]
[ExtensionAttribute]
internal static IEnumerable`1<ValueTuple`2<BasicBlock, BranchWithInfo>> GetPredecessorsWithBranches(BasicBlock basicBlock, ControlFlowGraph cfg);
    [ExtensionAttribute]
internal static ITypeSymbol GetEnclosingRegionExceptionType(BasicBlock basicBlock);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions/<DescendantOperations>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(BasicBlock basicBlock);
    [ExtensionAttribute]
public static bool IsContainedInRegionOfKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind);
    [ExtensionAttribute]
public static ControlFlowRegion GetContainingRegionOfKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind);
    [ExtensionAttribute]
public static bool IsFirstBlockOfFinally(BasicBlock basicBlock, ControlFlowRegion& finallyRegion);
    [ExtensionAttribute]
public static bool IsLastBlockOfFinally(BasicBlock basicBlock, ControlFlowRegion& finallyRegion);
    [ExtensionAttribute]
public static bool IsFirstBlockOfRegionKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind, ControlFlowRegion& region);
    [ExtensionAttribute]
public static bool IsLastBlockOfRegionKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind, ControlFlowRegion& region);
    [ExtensionAttribute]
private static bool IsFirstOrLastBlockOfRegionKind(BasicBlock basicBlock, ControlFlowRegionKind regionKind, bool first, ControlFlowRegion& foundRegion);
    [ExtensionAttribute]
internal static ControlFlowRegion GetInnermostRegionStartedByBlock(BasicBlock basicBlock, ControlFlowRegionKind regionKind);
    [ExtensionAttribute]
internal static int GetMaxSuccessorOrdinal(BasicBlock basicBlock);
    [ExtensionAttribute]
internal static IOperation GetPreviousOperationInBlock(BasicBlock basicBlock, IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.BranchWithInfo : object {
    [CompilerGeneratedAttribute]
private BasicBlock <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBranchSemantics <Kind>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ControlFlowRegion> <EnteringRegions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ControlFlowRegion> <FinallyRegions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ControlFlowRegion> <LeavingRegions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IOperation <BranchValueOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowConditionKind <ControlFlowConditionKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ILocalSymbol> <LeavingRegionLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CaptureId> <LeavingRegionFlowCaptures>k__BackingField;
    public BasicBlock Destination { get; }
    public ControlFlowBranchSemantics Kind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ControlFlowRegion> EnteringRegions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ControlFlowRegion> FinallyRegions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ControlFlowRegion> LeavingRegions { get; }
    [NullableAttribute("2")]
public IOperation BranchValueOpt { get; }
    public ControlFlowConditionKind ControlFlowConditionKind { get; }
    public IEnumerable`1<ILocalSymbol> LeavingRegionLocals { get; }
    public IEnumerable`1<CaptureId> LeavingRegionFlowCaptures { get; }
    internal BranchWithInfo(ControlFlowBranch branch);
    internal BranchWithInfo(BasicBlock destination);
    private BranchWithInfo(BasicBlock destination, ImmutableArray`1<ControlFlowRegion> enteringRegions, ImmutableArray`1<ControlFlowRegion> leavingRegions, ImmutableArray`1<ControlFlowRegion> finallyRegions, ControlFlowBranchSemantics kind, IOperation branchValueOpt, ControlFlowConditionKind controlFlowConditionKind, IEnumerable`1<ILocalSymbol> leavingRegionLocals, IEnumerable`1<CaptureId> leavingRegionFlowCaptures);
    [CompilerGeneratedAttribute]
public BasicBlock get_Destination();
    [CompilerGeneratedAttribute]
public ControlFlowBranchSemantics get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ControlFlowRegion> get_EnteringRegions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ControlFlowRegion> get_FinallyRegions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ControlFlowRegion> get_LeavingRegions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IOperation get_BranchValueOpt();
    [CompilerGeneratedAttribute]
public ControlFlowConditionKind get_ControlFlowConditionKind();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ILocalSymbol> get_LeavingRegionLocals();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CaptureId> get_LeavingRegionFlowCaptures();
    internal BranchWithInfo WithEmptyRegions(BasicBlock destination);
    internal BranchWithInfo With(IOperation branchValueOpt, ControlFlowConditionKind controlFlowConditionKind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BranchWithInfo/<GetTransitiveNestedRegions>d__32")]
private static IEnumerable`1<ControlFlowRegion> GetTransitiveNestedRegions(ControlFlowRegion region);
    private static IEnumerable`1<ILocalSymbol> ComputeLeavingRegionLocals(ImmutableArray`1<ControlFlowRegion> leavingRegions);
    private static IEnumerable`1<CaptureId> ComputeLeavingRegionFlowCaptures(ImmutableArray`1<ControlFlowRegion> leavingRegions);
    private static ControlFlowConditionKind GetControlFlowConditionKind(ControlFlowBranch branch);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsBackEdge(ControlFlowBranch controlFlowBranch);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowConditionKindExtensions : object {
    [ExtensionAttribute]
public static ControlFlowConditionKind Negate(ControlFlowConditionKind controlFlowConditionKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions : object {
    [ExtensionAttribute]
public static BasicBlock GetEntry(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static BasicBlock GetExit(ControlFlowGraph cfg);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions/<DescendantOperations>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(ControlFlowGraph cfg);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions/<DescendantOperations>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> DescendantOperations(ControlFlowGraph cfg, OperationKind operationKind);
    [ExtensionAttribute]
internal static bool SupportsFlowAnalysis(ControlFlowGraph cfg);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsRegionOrSelf(ControlFlowRegion controlFlowRegion, ControlFlowRegion nestedRegion);
}
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisData : object {
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractAnalysisDomain`1 : object {
    public abstract virtual TAnalysisData Clone(TAnalysisData value);
    public abstract virtual TAnalysisData Merge(TAnalysisData value1, TAnalysisData value2);
    public abstract virtual int Compare(TAnalysisData oldValue, TAnalysisData newValue);
    public abstract virtual bool Equals(TAnalysisData value1, TAnalysisData value2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractBlockAnalysisResult : object {
    [CompilerGeneratedAttribute]
private BasicBlock <BasicBlock>k__BackingField;
    public BasicBlock BasicBlock { get; }
    protected AbstractBlockAnalysisResult(BasicBlock basicBlock);
    [CompilerGeneratedAttribute]
public BasicBlock get_BasicBlock();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDataFlowAnalysisContext`4 : CacheBasedEquatable`1<TAnalysisContext> {
    [CompilerGeneratedAttribute]
private AbstractValueDomain`1<TAbstractAnalysisValue> <ValueDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private WellKnownTypeProvider <WellKnownTypeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <OwningSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalyzerOptions <AnalyzerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private InterproceduralAnalysisConfiguration <InterproceduralAnalysisConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PessimisticAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PredicateAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExceptionPathsAnalysis>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> <CopyAnalysisResultOpt>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PointsToAnalysisResult <PointsToAnalysisResultOpt>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> <ValueContentAnalysisResultOpt>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<TAnalysisContext, TAnalysisResult> <TryGetOrComputeAnalysisResult>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ControlFlowGraph <ParentControlFlowGraphOpt>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> <InterproceduralAnalysisDataOpt>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private InterproceduralAnalysisPredicate <InterproceduralAnalysisPredicateOpt>k__BackingField;
    public AbstractValueDomain`1<TAbstractAnalysisValue> ValueDomain { get; }
    public WellKnownTypeProvider WellKnownTypeProvider { get; }
    public ControlFlowGraph ControlFlowGraph { get; }
    public ISymbol OwningSymbol { get; }
    public AnalyzerOptions AnalyzerOptions { get; }
    public InterproceduralAnalysisConfiguration InterproceduralAnalysisConfiguration { get; }
    public bool PessimisticAnalysis { get; }
    public bool PredicateAnalysis { get; }
    public bool ExceptionPathsAnalysis { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> CopyAnalysisResultOpt { get; }
    [NullableAttribute("2")]
public PointsToAnalysisResult PointsToAnalysisResultOpt { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> ValueContentAnalysisResultOpt { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<TAnalysisContext, TAnalysisResult> TryGetOrComputeAnalysisResult { get; }
    [NullableAttribute("2")]
protected ControlFlowGraph ParentControlFlowGraphOpt { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> InterproceduralAnalysisDataOpt { get; }
    [NullableAttribute("2")]
public InterproceduralAnalysisPredicate InterproceduralAnalysisPredicateOpt { get; }
    protected AbstractDataFlowAnalysisContext`4(AbstractValueDomain`1<TAbstractAnalysisValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool predicateAnalysis, bool exceptionPathsAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, PointsToAnalysisResult pointsToAnalysisResultOpt, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResultOpt, Func`2<TAnalysisContext, TAnalysisResult> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraphOpt, InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> interproceduralAnalysisDataOpt, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    [CompilerGeneratedAttribute]
public AbstractValueDomain`1<TAbstractAnalysisValue> get_ValueDomain();
    [CompilerGeneratedAttribute]
public WellKnownTypeProvider get_WellKnownTypeProvider();
    [CompilerGeneratedAttribute]
public sealed virtual ControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbol get_OwningSymbol();
    [CompilerGeneratedAttribute]
public AnalyzerOptions get_AnalyzerOptions();
    [CompilerGeneratedAttribute]
public InterproceduralAnalysisConfiguration get_InterproceduralAnalysisConfiguration();
    [CompilerGeneratedAttribute]
public bool get_PessimisticAnalysis();
    [CompilerGeneratedAttribute]
public bool get_PredicateAnalysis();
    [CompilerGeneratedAttribute]
public bool get_ExceptionPathsAnalysis();
    [CompilerGeneratedAttribute]
public DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> get_CopyAnalysisResultOpt();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PointsToAnalysisResult get_PointsToAnalysisResultOpt();
    [CompilerGeneratedAttribute]
public DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> get_ValueContentAnalysisResultOpt();
    [CompilerGeneratedAttribute]
public Func`2<TAnalysisContext, TAnalysisResult> get_TryGetOrComputeAnalysisResult();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected ControlFlowGraph get_ParentControlFlowGraphOpt();
    [CompilerGeneratedAttribute]
public InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> get_InterproceduralAnalysisDataOpt();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public InterproceduralAnalysisPredicate get_InterproceduralAnalysisPredicateOpt();
    public abstract virtual TAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedCfg, IOperation operation, PointsToAnalysisResult pointsToAnalysisResultOpt, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResultOpt, InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue> interproceduralAnalysisData);
    public sealed virtual ControlFlowGraph GetLocalFunctionControlFlowGraph(IMethodSymbol localFunction);
    public sealed virtual ControlFlowGraph GetAnonymousFunctionControlFlowGraph(IFlowAnonymousFunctionOperation lambda);
    protected abstract virtual void ComputeHashCodePartsSpecific(Action`1<int> builder);
    protected sealed virtual void ComputeHashCodeParts(Action`1<int> addPart);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetLocalFunctionControlFlowGraph>b__50_0(TAnalysisContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetAnonymousFunctionControlFlowGraph>b__51_0(TAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractDomain`1 : object {
    public T Bottom { get; }
    public abstract virtual T get_Bottom();
    public abstract virtual T Merge(T value1, T value2);
    public int Compare(T oldValue, T newValue);
    public bool Equals(T value1, T value2);
    public abstract virtual int Compare(T oldValue, T newValue, bool assertMonotonicity);
    [ConditionalAttribute("DEBUG")]
protected static void FireNonMonotonicAssertIfNeeded(bool assertMonotonicity);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractIndex : CacheBasedEquatable`1<AbstractIndex> {
    public static AbstractIndex Create(int index);
    public static AbstractIndex Create(AnalysisEntity analysisEntity);
    public static AbstractIndex Create(IOperation operation);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocation : CacheBasedEquatable`1<AbstractLocation> {
    private bool _isSpecialSingleton;
    [NullableAttribute("1")]
public static AbstractLocation Null;
    [NullableAttribute("1")]
public static AbstractLocation NoLocation;
    [CompilerGeneratedAttribute]
private IOperation <CreationOpt>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ImmutableStack`1<IOperation> <CreationCallStack>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalysisEntity <AnalysisEntityOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <SymbolOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<InterproceduralCaptureId> <CaptureIdOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <LocationTypeOpt>k__BackingField;
    public IOperation CreationOpt { get; }
    [NullableAttribute("1")]
public ImmutableStack`1<IOperation> CreationCallStack { get; }
    public AnalysisEntity AnalysisEntityOpt { get; }
    public ISymbol SymbolOpt { get; }
    public Nullable`1<InterproceduralCaptureId> CaptureIdOpt { get; }
    public ITypeSymbol LocationTypeOpt { get; }
    public bool IsNull { get; }
    public bool IsNoLocation { get; }
    public bool IsAnalysisEntityDefaultLocation { get; }
    private AbstractLocation(IOperation creationOpt, ImmutableStack`1<IOperation> creationCallStackOpt, AnalysisEntity analysisEntityOpt, ISymbol symbolOpt, Nullable`1<InterproceduralCaptureId> captureIdOpt, ITypeSymbol locationTypeOpt, bool isSpecialSingleton);
    private static AbstractLocation();
    private static AbstractLocation Create(IOperation creationOpt, ImmutableStack`1<IOperation> creationCallStackOpt, AnalysisEntity analysisEntityOpt, ISymbol symbolOpt, Nullable`1<InterproceduralCaptureId> captureIdOpt, ITypeSymbol locationType);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateAllocationLocation(IOperation creation, ITypeSymbol locationType, PointsToAnalysisContext analysisContext);
    [NullableContextAttribute("1")]
internal static AbstractLocation CreateAllocationLocation(IOperation creation, ITypeSymbol locationType, ImmutableStack`1<IOperation> callStackOpt);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateAnalysisEntityDefaultLocation(AnalysisEntity analysisEntity);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateThisOrMeLocation(INamedTypeSymbol namedTypeSymbol, ImmutableStack`1<IOperation> creationCallStackOpt);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateSymbolLocation(ISymbol symbol, ImmutableStack`1<IOperation> creationCallStackOpt);
    [NullableContextAttribute("1")]
public static AbstractLocation CreateFlowCaptureLocation(InterproceduralCaptureId captureId, ITypeSymbol locationType, ImmutableStack`1<IOperation> creationCallStackOpt);
    [CompilerGeneratedAttribute]
public IOperation get_CreationOpt();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ImmutableStack`1<IOperation> get_CreationCallStack();
    public IOperation GetTopOfCreationCallStackOrCreation();
    [CompilerGeneratedAttribute]
public AnalysisEntity get_AnalysisEntityOpt();
    [CompilerGeneratedAttribute]
public ISymbol get_SymbolOpt();
    [CompilerGeneratedAttribute]
public Nullable`1<InterproceduralCaptureId> get_CaptureIdOpt();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_LocationTypeOpt();
    public bool get_IsNull();
    public bool get_IsNoLocation();
    public bool get_IsAnalysisEntityDefaultLocation();
    [NullableContextAttribute("1")]
protected virtual void ComputeHashCodeParts(Action`1<int> addPart);
    public SyntaxNode TryGetNodeToReportDiagnostic(PointsToAnalysisResult pointsToAnalysisResultOpt);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <TryGetNodeToReportDiagnostic>g__TryGetSyntaxNodeToReportDiagnostic|37_0(IOperation creation, PointsToAnalysisResult pointsToAnalysisResult);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <TryGetNodeToReportDiagnostic>g__TryGetSyntaxNodeToReportDiagnosticCore|37_1(IOperation operation, <>c__DisplayClass37_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private SyntaxNode <TryGetNodeToReportDiagnostic>g__TryGetSyntaxNodeToReportDiagnosticForPointsValue|37_2(PointsToAbstractValue pointsToValue, IOperation operation, <>c__DisplayClass37_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractLocationDataFlowOperationVisitor`4 : DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> {
    protected AbstractLocationDataFlowOperationVisitor`4(TAnalysisContext analysisContext);
    protected abstract virtual TAbstractAnalysisValue GetAbstractValue(AbstractLocation location);
    protected abstract virtual void SetAbstractValue(AbstractLocation location, TAbstractAnalysisValue value);
    protected void SetAbstractValue(PointsToAbstractValue instanceLocation, TAbstractAnalysisValue value);
    protected void SetAbstractValue(IEnumerable`1<AbstractLocation> locations, TAbstractAnalysisValue value);
    protected abstract virtual void StopTrackingAbstractValue(AbstractLocation location);
    protected virtual void StopTrackingDataForParameter(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected virtual void ResetValueTypeInstanceAnalysisData(AnalysisEntity analysisEntity);
    protected virtual void ResetReferenceTypeInstanceAnalysisData(PointsToAbstractValue pointsToAbstractValue);
    protected virtual TAbstractAnalysisValue HandleInstanceCreation(IOperation creation, PointsToAbstractValue instanceLocation, TAbstractAnalysisValue defaultValue);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForEscapedRefOrOutArgument(IArgumentOperation operation, TAbstractAnalysisValue defaultValue);
    protected abstract virtual void SetValueForParameterPointsToLocationOnEntry(IParameterSymbol parameter, PointsToAbstractValue pointsToAbstractValue);
    protected abstract virtual void EscapeValueForParameterPointsToLocationOnExit(IParameterSymbol parameter, AnalysisEntity analysisEntity, ImmutableHashSet`1<AbstractLocation> escapedLocations);
    protected virtual void SetValueForParameterOnEntry(IParameterSymbol parameter, AnalysisEntity analysisEntity, ArgumentInfo`1<TAbstractAnalysisValue> assignedValueOpt);
    protected virtual void EscapeValueForParameterOnExit(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected void ResetAnalysisData(DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> currentAnalysisData);
    protected static DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> GetClonedAnalysisDataHelper(IDictionary`2<AbstractLocation, TAbstractAnalysisValue> analysisData);
    protected static DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> GetEmptyAnalysisDataHelper();
    protected void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> coreDataAtException, DictionaryAnalysisData`2<AbstractLocation, TAbstractAnalysisValue> coreCurrentAnalysisData);
    public virtual TAbstractAnalysisValue VisitObjectCreation(IObjectCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitTypeParameterObjectCreation(ITypeParameterObjectCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitDynamicObjectCreation(IDynamicObjectCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitAnonymousObjectCreation(IAnonymousObjectCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitArrayCreation(IArrayCreationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitDelegateCreation(IDelegateCreationOperation operation, object argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AbstractValueDomain`1 : AbstractDomain`1<T> {
    public T UnknownOrMayBeValue { get; }
    public abstract virtual T get_UnknownOrMayBeValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntity : CacheBasedEquatable`1<AnalysisEntity> {
    [NullableAttribute("0")]
private ImmutableArray`1<int> _ignoringLocationHashCodeParts;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISymbol <SymbolOpt>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<AbstractIndex> <Indices>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SyntaxNode <InstanceReferenceOperationSyntaxOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<InterproceduralCaptureId> <CaptureIdOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAbstractValue <InstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AnalysisEntity <ParentOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsThisOrMeInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EqualsIgnoringInstanceLocationId>k__BackingField;
    public bool IsChildOrInstanceMember { get; }
    public bool HasConstantValue { get; }
    [NullableAttribute("2")]
public ISymbol SymbolOpt { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<AbstractIndex> Indices { get; }
    [NullableAttribute("2")]
public SyntaxNode InstanceReferenceOperationSyntaxOpt { get; }
    public Nullable`1<InterproceduralCaptureId> CaptureIdOpt { get; }
    public PointsToAbstractValue InstanceLocation { get; }
    public ITypeSymbol Type { get; }
    [NullableAttribute("2")]
public AnalysisEntity ParentOpt { get; }
    public bool IsThisOrMeInstance { get; }
    public bool HasUnknownInstanceLocation { get; }
    public bool IsLValueFlowCaptureEntity { get; }
    public int EqualsIgnoringInstanceLocationId { get; private set; }
    [NullableContextAttribute("2")]
private AnalysisEntity(ISymbol symbolOpt, ImmutableArray`1<AbstractIndex> indices, SyntaxNode instanceReferenceOperationSyntaxOpt, Nullable`1<InterproceduralCaptureId> captureIdOpt, PointsToAbstractValue location, ITypeSymbol type, AnalysisEntity parentOpt, bool isThisOrMeInstance);
    private AnalysisEntity(ISymbol symbolOpt, ImmutableArray`1<AbstractIndex> indices, PointsToAbstractValue location, ITypeSymbol type, AnalysisEntity parentOpt);
    private AnalysisEntity(IInstanceReferenceOperation instanceReferenceOperation, PointsToAbstractValue location);
    private AnalysisEntity(InterproceduralCaptureId captureId, ITypeSymbol capturedType, PointsToAbstractValue location);
    private AnalysisEntity(INamedTypeSymbol namedType, PointsToAbstractValue location, bool isThisOrMeInstance);
    public static AnalysisEntity Create(ISymbol symbolOpt, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol type, PointsToAbstractValue instanceLocation, AnalysisEntity parentOpt);
    public static AnalysisEntity Create(IInstanceReferenceOperation instanceReferenceOperation, PointsToAbstractValue instanceLocation);
    public static AnalysisEntity Create(InterproceduralCaptureId interproceduralCaptureId, ITypeSymbol type, PointsToAbstractValue instanceLocation);
    public static AnalysisEntity CreateThisOrMeInstance(INamedTypeSymbol typeSymbol, PointsToAbstractValue instanceLocation);
    public AnalysisEntity WithMergedInstanceLocation(AnalysisEntity analysisEntityToMerge);
    public bool get_IsChildOrInstanceMember();
    public bool get_HasConstantValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ISymbol get_SymbolOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AbstractIndex> get_Indices();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SyntaxNode get_InstanceReferenceOperationSyntaxOpt();
    [CompilerGeneratedAttribute]
public Nullable`1<InterproceduralCaptureId> get_CaptureIdOpt();
    [CompilerGeneratedAttribute]
public PointsToAbstractValue get_InstanceLocation();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AnalysisEntity get_ParentOpt();
    [CompilerGeneratedAttribute]
public bool get_IsThisOrMeInstance();
    public bool get_HasUnknownInstanceLocation();
    public bool get_IsLValueFlowCaptureEntity();
    [NullableContextAttribute("2")]
public bool EqualsIgnoringInstanceLocation(AnalysisEntity other);
    [CompilerGeneratedAttribute]
public int get_EqualsIgnoringInstanceLocationId();
    [CompilerGeneratedAttribute]
private void set_EqualsIgnoringInstanceLocationId(int value);
    protected virtual void ComputeHashCodeParts(Action`1<int> addPart);
    private void ComputeHashCodePartsIgnoringLocation(Action`1<int> addPart);
    [NullableContextAttribute("0")]
private ImmutableArray`1<int> ComputeIgnoringLocationHashCodeParts();
    public bool HasAncestor(AnalysisEntity ancestor);
    internal bool IsCandidatePredicateEntity();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityBasedPredicateAnalysisData`1 : PredicatedAnalysisData`2<AnalysisEntity, TValue> {
    [CompilerGeneratedAttribute]
private DictionaryAnalysisData`2<AnalysisEntity, TValue> <CoreAnalysisData>k__BackingField;
    public DictionaryAnalysisData`2<AnalysisEntity, TValue> CoreAnalysisData { get; }
    public bool HasAnyAbstractValue { get; }
    public TValue Item { get; }
    protected AnalysisEntityBasedPredicateAnalysisData`1(IDictionary`2<AnalysisEntity, TValue> fromData);
    protected AnalysisEntityBasedPredicateAnalysisData`1(AnalysisEntityBasedPredicateAnalysisData`1<TValue> fromData);
    protected AnalysisEntityBasedPredicateAnalysisData`1(AnalysisEntityBasedPredicateAnalysisData`1<TValue> data1, AnalysisEntityBasedPredicateAnalysisData`1<TValue> data2, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    protected AnalysisEntityBasedPredicateAnalysisData`1(DictionaryAnalysisData`2<AnalysisEntity, TValue> mergedCoreAnalysisData, PredicatedAnalysisData`2<AnalysisEntity, TValue> predicatedData1, PredicatedAnalysisData`2<AnalysisEntity, TValue> predicatedData2, bool isReachableData, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    [CompilerGeneratedAttribute]
public DictionaryAnalysisData`2<AnalysisEntity, TValue> get_CoreAnalysisData();
    public virtual bool get_HasAnyAbstractValue();
    public abstract virtual AnalysisEntityBasedPredicateAnalysisData`1<TValue> Clone();
    public abstract virtual AnalysisEntityBasedPredicateAnalysisData`1<TValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<TValue> data, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    public abstract virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<TValue> other, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    protected int BaseCompareHelper(AnalysisEntityBasedPredicateAnalysisData`1<TValue> newData, MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    public bool HasAbstractValue(AnalysisEntity analysisEntity);
    public bool TryGetValue(AnalysisEntity key, TValue& value);
    public TValue get_Item(AnalysisEntity key);
    [ConditionalAttribute("DEBUG")]
private void AssertValidAnalysisData();
    public virtual void SetAbstractValue(AnalysisEntity key, TValue value);
    public void RemoveEntries(AnalysisEntity key);
    public bool Equals(AnalysisEntityBasedPredicateAnalysisData`1<TValue> other);
    public virtual void Reset(Func`3<AnalysisEntity, TValue, TValue> getResetValue);
    public void StartTrackingPredicatedData(AnalysisEntity predicatedEntity, AnalysisEntityBasedPredicateAnalysisData`1<TValue> truePredicateData, AnalysisEntityBasedPredicateAnalysisData`1<TValue> falsePredicateData);
    public PredicateValueKind ApplyPredicatedDataForEntity(AnalysisEntity predicatedEntity, bool trueData);
    public void AddTrackedEntities(HashSet`1<AnalysisEntity> builder);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4 : DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> {
    protected AnalysisEntityDataFlowOperationVisitor`4(TAnalysisContext analysisContext);
    protected void AddTrackedEntities(HashSet`1<AnalysisEntity> builder, bool forInterproceduralAnalysis);
    protected abstract virtual void AddTrackedEntities(TAnalysisData analysisData, HashSet`1<AnalysisEntity> builder, bool forInterproceduralAnalysis);
    protected abstract virtual void SetAbstractValue(AnalysisEntity analysisEntity, TAbstractAnalysisValue value);
    protected abstract virtual void ResetAbstractValue(AnalysisEntity analysisEntity);
    protected abstract virtual TAbstractAnalysisValue GetAbstractValue(AnalysisEntity analysisEntity);
    protected abstract virtual bool HasAbstractValue(AnalysisEntity analysisEntity);
    protected abstract virtual void StopTrackingEntity(AnalysisEntity analysisEntity, TAnalysisData analysisData);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForReferenceOperation(IOperation operation, TAbstractAnalysisValue defaultValue);
    protected sealed virtual TAbstractAnalysisValue ComputeAnalysisValueForEscapedRefOrOutArgument(IArgumentOperation operation, TAbstractAnalysisValue defaultValue);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForEscapedRefOrOutArgument(AnalysisEntity analysisEntity, IArgumentOperation operation, TAbstractAnalysisValue defaultValue);
    protected void ResetAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> currentAnalysisData);
    protected virtual void ProcessOutOfScopeLocalsAndFlowCaptures(IEnumerable`1<ILocalSymbol> locals, IEnumerable`1<CaptureId> flowCaptures);
    private void StopTrackingDataForEntity(AnalysisEntity analysisEntity, PooledHashSet`1<AnalysisEntity> allEntities);
    private void StopTrackingDataForEntity(AnalysisEntity analysisEntity, TAnalysisData analysisData, PooledHashSet`1<AnalysisEntity> allEntities);
    private void StopTrackingDataForParamArrayParameterIndices(AnalysisEntity analysisEntity, TAnalysisData analysisData, PooledHashSet`1<AnalysisEntity> allEntities);
    protected sealed virtual void StopTrackingDataForParameter(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected sealed virtual void StopTrackingDataForParameters(ImmutableDictionary`2<IParameterSymbol, AnalysisEntity> parameterEntities);
    protected virtual TAnalysisData GetMergedAnalysisDataForPossibleThrowingOperation(TAnalysisData existingDataOpt, IOperation operation);
    protected virtual void SetAbstractValueForArrayElementInitializer(IArrayCreationOperation arrayCreation, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol elementType, IOperation initializer, TAbstractAnalysisValue value);
    protected virtual void SetAbstractValueForAssignment(IOperation target, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue, bool mayBeAssignment);
    protected virtual void SetAbstractValueForTupleElementAssignment(AnalysisEntity tupleElementEntity, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue);
    protected virtual void SetAbstractValueForAssignment(AnalysisEntity targetAnalysisEntity, IOperation assignedValueOperationOpt, TAbstractAnalysisValue assignedValue);
    private void SetAbstractValueForAssignment(AnalysisEntity targetAnalysisEntity, AnalysisEntity assignedValueEntityOpt, IOperation assignedValueOperationOpt, TAbstractAnalysisValue assignedValue);
    protected virtual void SetValueForParameterOnEntry(IParameterSymbol parameter, AnalysisEntity analysisEntity, ArgumentInfo`1<TAbstractAnalysisValue> assignedValueOpt);
    protected virtual void EscapeValueForParameterOnExit(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected virtual TAbstractAnalysisValue GetDefaultValueForParameterOnEntry(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected virtual TAbstractAnalysisValue GetDefaultValueForParameterOnExit(ITypeSymbol parameterType);
    protected virtual void ResetValueTypeInstanceAnalysisData(AnalysisEntity analysisEntity);
    protected virtual void ResetReferenceTypeInstanceAnalysisData(PointsToAbstractValue pointsToValue);
    private void ResetInstanceAnalysisDataCore(IEnumerable`1<AnalysisEntity> dependantAnalysisEntities);
    [NullableContextAttribute("2")]
private void TransferValueTypeInstanceAnalysisDataForAssignment(AnalysisEntity targetAnalysisEntity, AnalysisEntity valueAnalysisEntityOpt, IOperation assignedValueOperationOpt);
    private ImmutableHashSet`1<AnalysisEntity> GetChildAnalysisEntities(AnalysisEntity analysisEntity);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityDataFlowOperationVisitor`4/<GetChildAnalysisEntities>d__33")]
protected static IEnumerable`1<AnalysisEntity> GetChildAnalysisEntities(AnalysisEntity analysisEntity, HashSet`1<AnalysisEntity> allEntities);
    protected static bool IsChildAnalysisEntity(AnalysisEntity entity, AnalysisEntity ancestorEntity);
    protected ImmutableHashSet`1<AnalysisEntity> GetChildAnalysisEntities(PointsToAbstractValue instanceLocationOpt);
    private ImmutableHashSet`1<AnalysisEntity> GetChildAnalysisEntities(PointsToAbstractValue instanceLocationOpt, Func`2<AnalysisEntity, bool> predicateOpt);
    protected static bool IsChildAnalysisEntity(AnalysisEntity entity, PointsToAbstractValue instanceLocation);
    private ImmutableHashSet`1<AnalysisEntity> GetChildAnalysisEntities(Func`2<AnalysisEntity, bool> predicate);
    protected virtual void UpdateReachability(BasicBlock basicBlock, TAnalysisData analysisData, bool isReachable);
    protected virtual bool IsReachableBlockData(TAnalysisData analysisData);
    [NullableContextAttribute("2")]
protected sealed virtual void StartTrackingPredicatedData(AnalysisEntity predicatedEntity, TAnalysisData truePredicateData, TAnalysisData falsePredicateData);
    protected sealed virtual void StopTrackingPredicatedData(AnalysisEntity predicatedEntity);
    protected sealed virtual bool HasPredicatedDataForEntity(TAnalysisData analysisData, AnalysisEntity predicatedEntity);
    protected sealed virtual void TransferPredicatedData(AnalysisEntity fromEntity, AnalysisEntity toEntity);
    protected sealed virtual PredicateValueKind ApplyPredicatedDataForEntity(TAnalysisData analysisData, AnalysisEntity predicatedEntity, bool trueData);
    protected virtual void SetPredicateValueKind(IOperation operation, TAnalysisData analysisData, PredicateValueKind predicateValueKind);
    protected virtual TAnalysisData GetInitialInterproceduralAnalysisData(IMethodSymbol invokedMethod, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> invocationInstanceOpt, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> thisOrMeInstanceForCallerOpt, ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> argumentValuesMap, IDictionary`2<AnalysisEntity, PointsToAbstractValue> pointsToValuesOpt, IDictionary`2<AnalysisEntity, CopyAbstractValue> copyValuesOpt, IDictionary`2<AnalysisEntity, ValueContentAbstractValue> valueContentValuesOpt, bool isLambdaOrLocalFunction, bool hasParameterWithDelegateType);
    protected abstract virtual TAnalysisData GetTrimmedCurrentAnalysisData(IEnumerable`1<AnalysisEntity> withEntities);
    protected TAnalysisData GetTrimmedCurrentAnalysisDataHelper(IEnumerable`1<AnalysisEntity> withEntities, IDictionary`2<AnalysisEntity, TAbstractAnalysisValue> existingValues, Action`3<TAnalysisData, AnalysisEntity, TAbstractAnalysisValue> setAbstractValue);
    protected abstract virtual void ApplyInterproceduralAnalysisResultCore(TAnalysisData resultData);
    protected sealed virtual void ApplyInterproceduralAnalysisResult(TAnalysisData resultData, bool isLambdaOrLocalFunction, bool hasParameterWithDelegateType, TAnalysisResult interproceduralResult);
    protected void ApplyInterproceduralAnalysisResultHelper(IDictionary`2<AnalysisEntity, TAbstractAnalysisValue> resultToApply);
    internal bool ShouldStopTrackingEntityAtExit(AnalysisEntity entity);
    [NullableContextAttribute("2")]
public virtual TAnalysisData GetMergedDataForUnhandledThrowOperations();
    protected DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> GetClonedAnalysisDataHelper(IDictionary`2<AnalysisEntity, TAbstractAnalysisValue> analysisData);
    protected void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> coreDataAtException, DictionaryAnalysisData`2<AnalysisEntity, TAbstractAnalysisValue> coreCurrentAnalysisData, ThrownExceptionInfo throwBranchWithExceptionType);
    public virtual TAbstractAnalysisValue VisitDeconstructionAssignment(IDeconstructionAssignmentOperation operation, object argument);
    private void HandleDeconstructionAssignment(IOperation target, ImmutableHashSet`1<AnalysisEntity> childEntities);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetMergedAnalysisDataForPossibleThrowingOperation>b__18_0(AnalysisEntity e);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <GetInitialInterproceduralAnalysisData>g__AddWorklistEntityAndPointsToValue|47_0(AnalysisEntity analysisEntityOpt, <>c__DisplayClass47_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <GetInitialInterproceduralAnalysisData>g__AddWorklistPointsToValue|47_1(PointsToAbstractValue pointsToValue, <>c__DisplayClass47_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetInitialInterproceduralAnalysisData>g__ShouldProcessPointsToValue|47_2(PointsToAbstractValue pointsToValue);
    [CompilerGeneratedAttribute]
internal static bool <HandleDeconstructionAssignment>g__IsMatchingAssignedEntity|58_0(AnalysisEntity tupleElementEntity, AnalysisEntity childEntity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityFactory : object {
    private ControlFlowGraph _controlFlowGraph;
    private WellKnownTypeProvider _wellKnownTypeProvider;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IOperation, AnalysisEntity> _analysisEntityMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ITupleOperation, ImmutableArray`1<AnalysisEntity>> _tupleElementEntitiesMap;
    private Dictionary`2<CaptureId, AnalysisEntity> _captureIdEntityMap;
    private Dictionary`2<ISymbol, PointsToAbstractValue> _instanceLocationsForSymbols;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IOperation, PointsToAbstractValue> _getPointsToAbstractValueOpt;
    private Func`1<bool> _getIsInsideAnonymousObjectInitializer;
    private Func`2<IFlowCaptureOperation, bool> _getIsLValueFlowCapture;
    [NullableAttribute("2")]
private AnalysisEntity _interproceduralThisOrMeInstanceForCallerOpt;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableStack`1<IOperation> _interproceduralCallStackOpt;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IOperation, AnalysisEntity> _interproceduralGetAnalysisEntityForFlowCaptureOpt;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ISymbol, ImmutableStack`1<IOperation>> _getInterproceduralCallStackForOwningSymbol;
    [CompilerGeneratedAttribute]
private AnalysisEntity <ThisOrMeInstance>k__BackingField;
    public AnalysisEntity ThisOrMeInstance { get; }
    internal AnalysisEntityFactory(ControlFlowGraph controlFlowGraph, WellKnownTypeProvider wellKnownTypeProvider, Func`2<IOperation, PointsToAbstractValue> getPointsToAbstractValueOpt, Func`1<bool> getIsInsideAnonymousObjectInitializer, Func`2<IFlowCaptureOperation, bool> getIsLValueFlowCapture, INamedTypeSymbol containingTypeSymbol, AnalysisEntity interproceduralInvocationInstanceOpt, AnalysisEntity interproceduralThisOrMeInstanceForCallerOpt, ImmutableStack`1<IOperation> interproceduralCallStackOpt, ImmutableDictionary`2<ISymbol, PointsToAbstractValue> interproceduralCapturedVariablesMapOpt, Func`2<IOperation, AnalysisEntity> interproceduralGetAnalysisEntityForFlowCaptureOpt, Func`2<ISymbol, ImmutableStack`1<IOperation>> getInterproceduralCallStackForOwningSymbol);
    [CompilerGeneratedAttribute]
public AnalysisEntity get_ThisOrMeInstance();
    [NullableContextAttribute("0")]
private static ImmutableArray`1<AbstractIndex> CreateAbstractIndices(ImmutableArray`1<T> indices);
    private static AbstractIndex CreateAbstractIndex(IOperation operation);
    public bool TryCreate(IOperation operation, AnalysisEntity& analysisEntity);
    private static void GetSymbolAndIndicesForMemberReference(IMemberReferenceOperation memberReference, ISymbol& symbolOpt, ImmutableArray`1& indices);
    public bool TryCreateForSymbolDeclaration(ISymbol symbol, AnalysisEntity& analysisEntity);
    public bool TryCreateForTupleElements(ITupleOperation tupleOperation, ImmutableArray`1& elementEntities);
    public bool TryCreateForArrayElementInitializer(IArrayCreationOperation arrayCreation, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol elementType, AnalysisEntity& analysisEntity);
    public bool TryGetForFlowCapture(CaptureId captureId, AnalysisEntity& analysisEntity);
    public bool TryGetForInterproceduralAnalysis(IOperation operation, AnalysisEntity& analysisEntity);
    private AnalysisEntity GetOrCreateForFlowCapture(CaptureId captureId, ITypeSymbol type, IOperation flowCaptureOrReference, bool isLValueFlowCapture);
    [NullableContextAttribute("2")]
private bool TryCreate(ISymbol symbolOpt, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol type, IOperation instanceOpt, AnalysisEntity& analysisEntity);
    [NullableContextAttribute("2")]
private PointsToAbstractValue EnsureLocation(PointsToAbstractValue instanceLocationOpt, ISymbol symbolOpt, AnalysisEntity parentOpt);
    [NullableContextAttribute("2")]
private AnalysisEntity Create(ISymbol symbolOpt, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol type, PointsToAbstractValue instanceLocationOpt, AnalysisEntity parentOpt);
    public AnalysisEntity CreateWithNewInstanceRoot(AnalysisEntity analysisEntity, AnalysisEntity newRootInstance);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.AnalysisEntityMapAbstractDomain`1 : MapAbstractDomain`2<AnalysisEntity, TValue> {
    private static Func`2<AnalysisEntity, bool> s_defaultIsTrackedEntity;
    private static Func`2<PointsToAbstractValue, bool> s_defaultIsTrackedPointsToValue;
    private Func`2<AnalysisEntity, bool> _isTrackedEntity;
    private Func`2<PointsToAbstractValue, bool> _isTrackedPointsToValue;
    private protected AnalysisEntityMapAbstractDomain`1(AbstractValueDomain`1<TValue> valueDomain, Func`2<AnalysisEntity, bool> isTrackedEntity, Func`2<PointsToAbstractValue, bool> isTrackedPointsToValue);
    protected AnalysisEntityMapAbstractDomain`1(AbstractValueDomain`1<TValue> valueDomain, PointsToAnalysisResult pointsToAnalysisResultOpt);
    private static AnalysisEntityMapAbstractDomain`1();
    protected abstract virtual TValue GetDefaultValue(AnalysisEntity analysisEntity);
    protected abstract virtual bool CanSkipNewEntry(AnalysisEntity analysisEntity, TValue value);
    protected virtual void OnNewMergedValue(TValue value);
    private bool CanSkipNewEntity(AnalysisEntity analysisEntity);
    protected abstract virtual void AssertValidEntryForMergedMap(AnalysisEntity analysisEntity, TValue value);
    protected virtual void AssertValidAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, TValue> map);
    public virtual DictionaryAnalysisData`2<AnalysisEntity, TValue> Merge(DictionaryAnalysisData`2<AnalysisEntity, TValue> map1, DictionaryAnalysisData`2<AnalysisEntity, TValue> map2);
    [CompilerGeneratedAttribute]
internal static bool <Merge>g__IsAnalysisEntityForFieldOrProperty|12_1(AnalysisEntity entity);
    [CompilerGeneratedAttribute]
private TValue <Merge>g__GetMergedValueForEntityPresentInOneMap|12_2(AnalysisEntity key, TValue value, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private TValue <Merge>g__GetMergedValue|12_3(ArrayBuilder`1<TValue> values, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private TValue <Merge>g__GetMergedValueCore|12_5(TValue value1, TValue value2, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private void <Merge>g__AddNewEntryToResultMap|12_4(AnalysisEntity key, TValue value, bool isNewKey, <>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ArgumentInfo`1 : CacheBasedEquatable`1<ArgumentInfo`1<TAbstractAnalysisValue>> {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AnalysisEntity <AnalysisEntityOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAbstractValue <InstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private TAbstractAnalysisValue <Value>k__BackingField;
    public IOperation Operation { get; }
    [NullableAttribute("2")]
public AnalysisEntity AnalysisEntityOpt { get; }
    public PointsToAbstractValue InstanceLocation { get; }
    public TAbstractAnalysisValue Value { get; }
    public ArgumentInfo`1(IOperation operation, AnalysisEntity analysisEntityOpt, PointsToAbstractValue instanceLocation, TAbstractAnalysisValue value);
    [CompilerGeneratedAttribute]
public IOperation get_Operation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AnalysisEntity get_AnalysisEntityOpt();
    [CompilerGeneratedAttribute]
public PointsToAbstractValue get_InstanceLocation();
    [CompilerGeneratedAttribute]
public TAbstractAnalysisValue get_Value();
    protected virtual void ComputeHashCodeParts(Action`1<int> addPart);
}
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CacheBasedEquatable`1 : object {
    private ImmutableArray`1<int> _lazyHashCodeParts;
    private int _lazyHashCode;
    private int GetOrComputeHashCode();
    private ImmutableArray`1<int> ComputeHashCodeParts();
    [NullableContextAttribute("1")]
protected abstract virtual void ComputeHashCodeParts(Action`1<int> addPart);
    public sealed virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(T other);
    public static bool op_Equality(CacheBasedEquatable`1<T> value1, CacheBasedEquatable`1<T> value2);
    public static bool op_Inequality(CacheBasedEquatable`1<T> value1, CacheBasedEquatable`1<T> value2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ConversionInference : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsTryCast>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysSucceed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysFail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnboxing>k__BackingField;
    public bool IsTryCast { get; public set; }
    public bool AlwaysSucceed { get; public set; }
    public bool AlwaysFail { get; public set; }
    public bool IsBoxing { get; public set; }
    public bool IsUnboxing { get; public set; }
    public static ConversionInference Create(IConversionOperation operation);
    public static ConversionInference Create(IIsPatternOperation operation);
    [NullableContextAttribute("2")]
public static ConversionInference Create(ITypeSymbol targetTypeOpt, ITypeSymbol sourceTypeOpt, bool isTryCast);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsTryCast();
    [CompilerGeneratedAttribute]
public void set_IsTryCast(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AlwaysSucceed();
    [CompilerGeneratedAttribute]
public void set_AlwaysSucceed(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AlwaysFail();
    [CompilerGeneratedAttribute]
public void set_AlwaysFail(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsBoxing();
    [CompilerGeneratedAttribute]
public void set_IsBoxing(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsUnboxing();
    [CompilerGeneratedAttribute]
public void set_IsUnboxing(bool value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ConversionInference other);
    public virtual int GetHashCode();
    public static bool op_Equality(ConversionInference left, ConversionInference right);
    public static bool op_Inequality(ConversionInference left, ConversionInference right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.AddressSharedEntitiesProvider`4 : object {
    private Builder<AnalysisEntity, CopyAbstractValue> _addressSharedEntitiesBuilder;
    public AddressSharedEntitiesProvider`4(TAnalysisContext analysisContext);
    public void SetAddressSharedEntities(ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> addressSharedEntitiesOpt);
    public void UpdateAddressSharedEntitiesForParameter(IParameterSymbol parameter, AnalysisEntity analysisEntity, ArgumentInfo`1<TAbstractAnalysisValue> assignedValueOpt);
    public CopyAbstractValue GetDefaultCopyValue(AnalysisEntity analysisEntity);
    public CopyAbstractValue TryGetAddressSharedCopyValue(AnalysisEntity analysisEntity);
    public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> GetAddressedSharedEntityMap();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<AnalysisEntity> <UpdateAddressSharedEntitiesForParameter>g__ComputeAddressSharedEntities|3_0(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static void <UpdateAddressSharedEntitiesForParameter>g__AddIfHasKnownInstanceLocation|3_1(AnalysisEntity entity, PooledHashSet`1<AnalysisEntity> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValue : CacheBasedEquatable`1<CopyAbstractValue> {
    [CompilerGeneratedAttribute]
private static CopyAbstractValue <NotApplicable>k__BackingField;
    [CompilerGeneratedAttribute]
private static CopyAbstractValue <Invalid>k__BackingField;
    [CompilerGeneratedAttribute]
private static CopyAbstractValue <Unknown>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<AnalysisEntity> <AnalysisEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyAbstractValueKind <Kind>k__BackingField;
    public static CopyAbstractValue NotApplicable { get; }
    public static CopyAbstractValue Invalid { get; }
    public static CopyAbstractValue Unknown { get; }
    public ImmutableHashSet`1<AnalysisEntity> AnalysisEntities { get; }
    public CopyAbstractValueKind Kind { get; }
    internal CopyAbstractValue(ImmutableHashSet`1<AnalysisEntity> analysisEntities, CopyAbstractValueKind kind);
    private CopyAbstractValue(CopyAbstractValueKind kind);
    internal CopyAbstractValue(AnalysisEntity analysisEntity);
    internal CopyAbstractValue(ImmutableHashSet`1<AnalysisEntity> analysisEntities, bool isReferenceCopy);
    private static CopyAbstractValue();
    [CompilerGeneratedAttribute]
public static CopyAbstractValue get_NotApplicable();
    [CompilerGeneratedAttribute]
public static CopyAbstractValue get_Invalid();
    [CompilerGeneratedAttribute]
public static CopyAbstractValue get_Unknown();
    internal CopyAbstractValue WithEntityRemoved(AnalysisEntity entityToRemove);
    internal CopyAbstractValue WithEntitiesRemoved(IEnumerable`1<AnalysisEntity> entitiesToRemove);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<AnalysisEntity> get_AnalysisEntities();
    [CompilerGeneratedAttribute]
public CopyAbstractValueKind get_Kind();
    protected virtual void ComputeHashCodeParts(Action`1<int> addPart);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKind : Enum {
    public int value__;
    public static CopyAbstractValueKind NotApplicable;
    public static CopyAbstractValueKind KnownReferenceCopy;
    public static CopyAbstractValueKind KnownValueCopy;
    public static CopyAbstractValueKind Unknown;
    public static CopyAbstractValueKind Invalid;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAbstractValueKindExtensions : object {
    [ExtensionAttribute]
public static bool IsKnown(CopyAbstractValueKind kind);
    [ExtensionAttribute]
public static CopyAbstractValueKind MergeIfBothKnown(CopyAbstractValueKind kind, CopyAbstractValueKind kindToMerge);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysis : ForwardDataFlowAnalysis`5<CopyAnalysisData, CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>, CopyBlockAnalysisResult, CopyAbstractValue> {
    private CopyAnalysis(CopyDataFlowOperationVisitor operationVisitor);
    public static DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt, bool pessimisticAnalysis, bool performPointsToAnalysis, bool exceptionPathsAnalysis);
    private static DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> TryGetOrComputeResultForAnalysisContext(CopyAnalysisContext analysisContext);
    protected virtual DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> ToResult(CopyAnalysisContext analysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> dataFlowAnalysisResult);
    protected virtual CopyBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, CopyAnalysisData blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisContext : AbstractDataFlowAnalysisContext`4<CopyAnalysisData, CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>, CopyAbstractValue> {
    private CopyAnalysisContext(AbstractValueDomain`1<CopyAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, PointsToAnalysisResult pointsToAnalysisResultOpt, Func`2<CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraphOpt, InterproceduralAnalysisData`3<CopyAnalysisData, CopyAnalysisContext, CopyAbstractValue> interproceduralAnalysisDataOpt, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    internal static CopyAnalysisContext Create(AbstractValueDomain`1<CopyAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, PointsToAnalysisResult pointsToAnalysisResultOpt, Func`2<CopyAnalysisContext, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue>> tryGetOrComputeAnalysisResult, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    public virtual CopyAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedControlFlowGraph, IOperation operation, PointsToAnalysisResult pointsToAnalysisResultOpt, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResultOpt, InterproceduralAnalysisData`3<CopyAnalysisData, CopyAnalysisContext, CopyAbstractValue> interproceduralAnalysisData);
    protected virtual void ComputeHashCodePartsSpecific(Action`1<int> addPart);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyAnalysisData : AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> {
    internal CopyAnalysisData(IDictionary`2<AnalysisEntity, CopyAbstractValue> fromData);
    private CopyAnalysisData(CopyAnalysisData fromData);
    private CopyAnalysisData(CopyAnalysisData data1, CopyAnalysisData data2, MapAbstractDomain`2<AnalysisEntity, CopyAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> Clone();
    public virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> other, MapAbstractDomain`2<AnalysisEntity, CopyAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<CopyAbstractValue> data, MapAbstractDomain`2<AnalysisEntity, CopyAbstractValue> coreDataAnalysisDomain);
    internal void SetAbstactValueForEntities(CopyAbstractValue copyValue, AnalysisEntity entityBeingAssignedOpt);
    public virtual void SetAbstractValue(AnalysisEntity key, CopyAbstractValue value);
    protected virtual void RemoveEntryInPredicatedData(AnalysisEntity key, DictionaryAnalysisData`2<AnalysisEntity, CopyAbstractValue> predicatedData);
    protected virtual void ApplyPredicatedData(DictionaryAnalysisData`2<AnalysisEntity, CopyAbstractValue> coreAnalysisData, DictionaryAnalysisData`2<AnalysisEntity, CopyAbstractValue> predicatedData);
    public virtual void Reset(Func`3<AnalysisEntity, CopyAbstractValue, CopyAbstractValue> getResetValue);
    [ConditionalAttribute("DEBUG")]
internal void AssertValidCopyAnalysisData(Func`2<AnalysisEntity, CopyAbstractValue> tryGetDefaultCopyValueOpt, bool initializingParameters);
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidCopyAnalysisData(IDictionary`2<AnalysisEntity, CopyAbstractValue> map, Func`2<AnalysisEntity, CopyAbstractValue> tryGetDefaultCopyValueOpt, bool initializingParameters);
    [ConditionalAttribute("DEBUG")]
private static void AssertValidCopyAnalysisEntity(AnalysisEntity analysisEntity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.CopyAnalysis.CopyBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReachable>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> Data { get; }
    public bool IsReachable { get; }
    internal CopyBlockAnalysisResult(BasicBlock basicBlock, CopyAnalysisData blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysis`5 : object {
    private static BoundedCache`2<IOperation, SingleThreadedConcurrentDictionary`2<TAnalysisContext, TAnalysisResult>> s_resultCache;
    [CompilerGeneratedAttribute]
private AbstractAnalysisDomain`1<TAnalysisData> <AnalysisDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> <OperationVisitor>k__BackingField;
    protected AbstractAnalysisDomain`1<TAnalysisData> AnalysisDomain { get; }
    protected DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> OperationVisitor { get; }
    protected DataFlowAnalysis`5(AbstractAnalysisDomain`1<TAnalysisData> analysisDomain, DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> operationVisitor);
    private static DataFlowAnalysis`5();
    [CompilerGeneratedAttribute]
protected AbstractAnalysisDomain`1<TAnalysisData> get_AnalysisDomain();
    [CompilerGeneratedAttribute]
protected DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> get_OperationVisitor();
    protected TAnalysisResult TryGetOrComputeResultCore(TAnalysisContext analysisContext, bool cacheResult);
    private TAnalysisResult Run(TAnalysisContext analysisContext);
    private void RunCore(ControlFlowGraph cfg, SortedSet`1<int> worklist, SortedSet`1<int> pendingBlocksNeedingAtLeastOnePass, TAnalysisData initialAnalysisDataOpt, DataFlowAnalysisResultBuilder`1<TAnalysisData> resultBuilder, PooledHashSet`1<BasicBlock> uniqueSuccessors, PooledDictionary`2<int, List`1<BranchWithInfo>> finallyBlockSuccessorsMap, PooledDictionary`2<ControlFlowRegion, TAnalysisData> catchBlockInputDataMap, PooledDictionary`2<int, TAnalysisData> inputDataFromInfeasibleBranchesMap, PooledDictionary`2<int, Nullable`1<ValueTuple`2<int, ControlFlowConditionKind>>> blockToUniqueInputFlowMap, PooledDictionary`2<int, int> loopRangeMap, bool exceptionPathsAnalysisPostPass);
    private TAnalysisData GetClonedAnalysisDataOrEmptyData(TAnalysisData initialAnalysisDataOpt);
    public static TAnalysisData Flow(DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> operationVisitor, BasicBlock block, TAnalysisData data);
    public static TAnalysisData FlowBranch(DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> operationVisitor, ControlFlowBranch branch, TAnalysisData data);
    protected abstract virtual TAnalysisResult ToResult(TAnalysisContext analysisContext, DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> dataFlowAnalysisResult);
    protected abstract virtual TBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, TAnalysisData blockAnalysisData);
    private void UpdateInput(DataFlowAnalysisResultBuilder`1<TAnalysisData> builder, BasicBlock block, TAnalysisData newInput);
    private void CloneAndUpdateOutputIfEntryOrExitBlock(DataFlowAnalysisResultBuilder`1<TAnalysisData> builder, BasicBlock block, TAnalysisData newOutput);
    private static void ComputeLoopRangeMap(ControlFlowGraph cfg, PooledDictionary`2<int, int> loopRangeMap);
    [CompilerGeneratedAttribute]
internal static ControlFlowRegion <RunCore>g__TryGetReachableCatchRegionStartingHandler|10_1(ControlFlowRegion tryAndCatchRegion, BasicBlock sourceBlock);
    [CompilerGeneratedAttribute]
internal static ControlFlowRegion <RunCore>g__GetEnclosingTryAndCatchRegionIfStartsHandler|10_5(BasicBlock block);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <ComputeLoopRangeMap>g__HandleBranch|18_0(ControlFlowBranch branch, <>c__DisplayClass18_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResult`2 : object {
    private ImmutableDictionary`2<BasicBlock, TBlockAnalysisResult> _basicBlockStateMap;
    private ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> _operationStateMap;
    private ImmutableDictionary`2<IOperation, PredicateValueKind> _predicateValueKindMap;
    private ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> _interproceduralResultsMap;
    private TAbstractAnalysisValue _defaultUnknownValue;
    [NullableAttribute("2")]
private object _analysisDataForUnhandledThrowOperationsOpt;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> <ReturnValueAndPredicateKindOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private TBlockAnalysisResult <EntryBlockOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private TBlockAnalysisResult <ExitBlockOutput>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TBlockAnalysisResult <ExceptionPathsExitBlockOutputOpt>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TBlockAnalysisResult <MergedStateForUnhandledThrowOperationsOpt>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> <TaskWrappedValuesMapOpt>k__BackingField;
    public TBlockAnalysisResult Item { get; }
    public TAbstractAnalysisValue Item { get; }
    public TAbstractAnalysisValue Item { get; }
    public ControlFlowGraph ControlFlowGraph { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> ReturnValueAndPredicateKindOpt { get; }
    public TBlockAnalysisResult EntryBlockOutput { get; }
    public TBlockAnalysisResult ExitBlockOutput { get; }
    [NullableAttribute("2")]
public TBlockAnalysisResult ExceptionPathsExitBlockOutputOpt { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult<TAbstractAnalysisValue>.AnalysisDataForUnhandledThrowOperationsOpt { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult<TAbstractAnalysisValue>.TaskWrappedValuesMapOpt { get; }
    [NullableAttribute("2")]
public TBlockAnalysisResult MergedStateForUnhandledThrowOperationsOpt { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> TaskWrappedValuesMapOpt { get; }
    internal DataFlowAnalysisResult`2(ImmutableDictionary`2<BasicBlock, TBlockAnalysisResult> basicBlockStateMap, ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> operationStateMap, ImmutableDictionary`2<IOperation, PredicateValueKind> predicateValueKindMap, Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> returnValueAndPredicateKindOpt, ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> interproceduralResultsMap, TBlockAnalysisResult entryBlockOutput, TBlockAnalysisResult exitBlockOutput, TBlockAnalysisResult exceptionPathsExitBlockOutputOpt, TBlockAnalysisResult mergedStateForUnhandledThrowOperationsOpt, object analysisDataForUnhandledThrowOperationsOpt, Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> taskWrappedValuesMapOpt, ControlFlowGraph cfg, TAbstractAnalysisValue defaultUnknownValue);
    protected DataFlowAnalysisResult`2(DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> other);
    internal DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> With(TBlockAnalysisResult mergedStateForUnhandledThrowOperationsOpt, object analysisDataForUnhandledThrowOperations);
    public TBlockAnalysisResult get_Item(BasicBlock block);
    public TAbstractAnalysisValue get_Item(IOperation operation);
    public TAbstractAnalysisValue get_Item(OperationKind operationKind, SyntaxNode syntax);
    internal DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> TryGetInterproceduralResult(IOperation operation);
    [CompilerGeneratedAttribute]
public sealed virtual ControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> get_ReturnValueAndPredicateKindOpt();
    [CompilerGeneratedAttribute]
public TBlockAnalysisResult get_EntryBlockOutput();
    [CompilerGeneratedAttribute]
public TBlockAnalysisResult get_ExitBlockOutput();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TBlockAnalysisResult get_ExceptionPathsExitBlockOutputOpt();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult<TAbstractAnalysisValue>.get_AnalysisDataForUnhandledThrowOperationsOpt();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult<TAbstractAnalysisValue>.get_TaskWrappedValuesMapOpt();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TBlockAnalysisResult get_MergedStateForUnhandledThrowOperationsOpt();
    public PredicateValueKind GetPredicateKind(IOperation operation);
    [CompilerGeneratedAttribute]
internal Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> get_TaskWrappedValuesMapOpt();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowAnalysisResultBuilder`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledDictionary`2<BasicBlock, TAnalysisData> _info;
    [CompilerGeneratedAttribute]
private TAnalysisData <EntryBlockOutputData>k__BackingField;
    [CompilerGeneratedAttribute]
private TAnalysisData <ExitBlockOutputData>k__BackingField;
    public TAnalysisData Item { get; }
    public TAnalysisData EntryBlockOutputData { get; public set; }
    public TAnalysisData ExitBlockOutputData { get; public set; }
    [NullableContextAttribute("1")]
public TAnalysisData get_Item(BasicBlock block);
    [CompilerGeneratedAttribute]
public TAnalysisData get_EntryBlockOutputData();
    [CompilerGeneratedAttribute]
public void set_EntryBlockOutputData(TAnalysisData value);
    [CompilerGeneratedAttribute]
public TAnalysisData get_ExitBlockOutputData();
    [CompilerGeneratedAttribute]
public void set_ExitBlockOutputData(TAnalysisData value);
    [NullableContextAttribute("1")]
internal void Add(BasicBlock block);
    [NullableContextAttribute("1")]
internal void Update(BasicBlock block, TAnalysisData newData);
    [NullableContextAttribute("1")]
public DataFlowAnalysisResult`2<TBlockAnalysisResult, TAbstractAnalysisValue> ToResult(Func`3<BasicBlock, TAnalysisData, TBlockAnalysisResult> getBlockResult, ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> stateMap, ImmutableDictionary`2<IOperation, PredicateValueKind> predicateValueKindMap, Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> returnValueAndPredicateKindOpt, ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> interproceduralResultsMap, TAnalysisData entryBlockOutputData, TAnalysisData exitBlockData, TAnalysisData exceptionPathsExitBlockDataOpt, TAnalysisData mergedDataForUnhandledThrowOperationsOpt, Dictionary`2<ThrownExceptionInfo, TAnalysisData> analysisDataForUnhandledThrowOperationsOpt, Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> taskWrappedValuesMapOpt, ControlFlowGraph cfg, TAbstractAnalysisValue defaultUnknownValue);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DataFlowOperationVisitor`4 : OperationVisitor`2<object, TAbstractAnalysisValue> {
    private static DiagnosticDescriptor s_dummyDataflowAnalysisDescriptor;
    private ImmutableHashSet`1<CaptureId> _lValueFlowCaptures;
    private Builder<IOperation, TAbstractAnalysisValue> _valueCacheBuilder;
    private Builder<IOperation, PredicateValueKind> _predicateValueKindCacheBuilder;
    private HashSet`1<IArgumentOperation> _pendingArgumentsToReset;
    private List`1<IArgumentOperation> _pendingArgumentsToPostProcess;
    private HashSet`1<IOperation> _visitedFlowBranchConditions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<IOperation> _returnValueOperationsOpt;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<IParameterSymbol, AnalysisEntity> _lazyParameterEntities;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableHashSet`1<IMethodSymbol> _lazyContractCheckMethodsForPredicateAnalysis;
    [NullableAttribute("2")]
private TAnalysisData _currentAnalysisData;
    [NullableAttribute("2")]
private BasicBlock _currentBasicBlock;
    private int _recursionDepth;
    private AddressSharedEntitiesProvider`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> _addressSharedEntitiesProvider;
    private Stack`1<IOperation> _interproceduralCallStack;
    private Builder<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> _interproceduralResultsBuilder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IMethodSymbol, ControlFlowGraph> _interproceduralMethodToCfgMapOpt;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<ThrownExceptionInfo, TAnalysisData> <AnalysisDataForUnhandledThrowOperations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> <TaskWrappedValuesMapOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private TAnalysisContext <DataFlowAnalysisContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExecutingExceptionPathsAnalysisPostPass>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowConditionKind <FlowBranchConditionKind>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAbstractValue <ThisOrMePointsToAbstractValue>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalysisEntityFactory <AnalysisEntityFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInsideAnonymousObjectInitializer>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<BasicBlock, ThrownExceptionInfo> _exceptionPathsThrownExceptionInfoMapOpt;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ExceptionNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ContractNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <IDisposableNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <IAsyncDisposableNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <TaskNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <ValueTaskNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <GenericTaskNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <MonitorNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <InterlockedNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <SerializationInfoNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <GenericIEquatableNamedType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol <StringReaderType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<INamedTypeSymbol> <CollectionNamedTypes>k__BackingField;
    private InterproceduralAnalysisKind InterproceduralAnalysisKind { get; }
    private UInt32 MaxInterproceduralMethodCallChain { get; }
    private UInt32 MaxInterproceduralLambdaOrLocalFunctionCallChain { get; }
    protected bool HasPointsToAnalysisResult { get; }
    protected bool IsPointsToAnalysis { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<ThrownExceptionInfo, TAnalysisData> AnalysisDataForUnhandledThrowOperations { get; private set; }
    public ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> InterproceduralResultsMap { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> TaskWrappedValuesMapOpt { get; private set; }
    protected TAnalysisContext DataFlowAnalysisContext { get; }
    public AbstractValueDomain`1<TAbstractAnalysisValue> ValueDomain { get; }
    protected ISymbol OwningSymbol { get; }
    protected WellKnownTypeProvider WellKnownTypeProvider { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Func`2<TAnalysisContext, TAnalysisResult> TryGetOrComputeAnalysisResult { get; }
    internal bool ExecutingExceptionPathsAnalysisPostPass { get; internal set; }
    protected TAnalysisData CurrentAnalysisData { get; private set; }
    protected BasicBlock CurrentBasicBlock { get; private set; }
    protected ControlFlowConditionKind FlowBranchConditionKind { get; private set; }
    protected PointsToAbstractValue ThisOrMePointsToAbstractValue { get; }
    protected AnalysisEntityFactory AnalysisEntityFactory { get; }
    protected bool PessimisticAnalysis { get; }
    protected bool PredicateAnalysis { get; }
    protected bool IsInsideAnonymousObjectInitializer { get; private set; }
    private ThrownExceptionInfo DefaultThrownExceptionInfo { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol ExceptionNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol ContractNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol IDisposableNamedType { get; }
    [NullableAttribute("2")]
private INamedTypeSymbol IAsyncDisposableNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol TaskNamedType { get; }
    [NullableAttribute("2")]
private INamedTypeSymbol ValueTaskNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol GenericTaskNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol MonitorNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol InterlockedNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol SerializationInfoNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol GenericIEquatableNamedType { get; }
    [NullableAttribute("2")]
protected INamedTypeSymbol StringReaderType { get; }
    protected ImmutableHashSet`1<INamedTypeSymbol> CollectionNamedTypes { get; }
    protected DataFlowOperationVisitor`4(TAnalysisContext analysisContext);
    private static DataFlowOperationVisitor`4();
    private InterproceduralAnalysisKind get_InterproceduralAnalysisKind();
    private UInt32 get_MaxInterproceduralMethodCallChain();
    private UInt32 get_MaxInterproceduralLambdaOrLocalFunctionCallChain();
    protected abstract virtual TAbstractAnalysisValue GetAbstractDefaultValue(ITypeSymbol type);
    protected virtual TAbstractAnalysisValue GetAbstractDefaultValueForCatchVariable(ICatchClauseOperation catchClause);
    protected abstract virtual bool HasAnyAbstractValue(TAnalysisData data);
    protected abstract virtual void SetValueForParameterOnEntry(IParameterSymbol parameter, AnalysisEntity analysisEntity, ArgumentInfo`1<TAbstractAnalysisValue> assignedValueOpt);
    protected abstract virtual void EscapeValueForParameterOnExit(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected abstract virtual void ResetCurrentAnalysisData();
    protected bool get_HasPointsToAnalysisResult();
    protected virtual bool get_IsPointsToAnalysis();
    [CompilerGeneratedAttribute]
internal Dictionary`2<ThrownExceptionInfo, TAnalysisData> get_AnalysisDataForUnhandledThrowOperations();
    [CompilerGeneratedAttribute]
private void set_AnalysisDataForUnhandledThrowOperations(Dictionary`2<ThrownExceptionInfo, TAnalysisData> value);
    public ImmutableDictionary`2<IOperation, IDataFlowAnalysisResult`1<TAbstractAnalysisValue>> get_InterproceduralResultsMap();
    [CompilerGeneratedAttribute]
internal Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> get_TaskWrappedValuesMapOpt();
    [CompilerGeneratedAttribute]
private void set_TaskWrappedValuesMapOpt(Dictionary`2<PointsToAbstractValue, TAbstractAnalysisValue> value);
    [CompilerGeneratedAttribute]
protected TAnalysisContext get_DataFlowAnalysisContext();
    public AbstractValueDomain`1<TAbstractAnalysisValue> get_ValueDomain();
    protected ISymbol get_OwningSymbol();
    protected WellKnownTypeProvider get_WellKnownTypeProvider();
    protected Func`2<TAnalysisContext, TAnalysisResult> get_TryGetOrComputeAnalysisResult();
    [CompilerGeneratedAttribute]
internal bool get_ExecutingExceptionPathsAnalysisPostPass();
    [CompilerGeneratedAttribute]
internal void set_ExecutingExceptionPathsAnalysisPostPass(bool value);
    protected TAnalysisData get_CurrentAnalysisData();
    private void set_CurrentAnalysisData(TAnalysisData value);
    protected BasicBlock get_CurrentBasicBlock();
    private void set_CurrentBasicBlock(BasicBlock value);
    [CompilerGeneratedAttribute]
protected ControlFlowConditionKind get_FlowBranchConditionKind();
    [CompilerGeneratedAttribute]
private void set_FlowBranchConditionKind(ControlFlowConditionKind value);
    [CompilerGeneratedAttribute]
protected PointsToAbstractValue get_ThisOrMePointsToAbstractValue();
    [CompilerGeneratedAttribute]
protected AnalysisEntityFactory get_AnalysisEntityFactory();
    protected bool get_PessimisticAnalysis();
    protected bool get_PredicateAnalysis();
    [CompilerGeneratedAttribute]
protected bool get_IsInsideAnonymousObjectInitializer();
    [CompilerGeneratedAttribute]
private void set_IsInsideAnonymousObjectInitializer(bool value);
    protected bool IsLValueFlowCapture(IFlowCaptureOperation flowCapture);
    protected bool IsLValueFlowCaptureReference(IFlowCaptureReferenceOperation flowCaptureReference);
    private ThrownExceptionInfo get_DefaultThrownExceptionInfo();
    protected CopyAbstractValue GetDefaultCopyValue(AnalysisEntity analysisEntity);
    protected CopyAbstractValue TryGetAddressSharedCopyValue(AnalysisEntity analysisEntity);
    public virtual Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> GetReturnValueAndPredicateKind();
    private static PointsToAbstractValue GetThisOrMeInstancePointsToValue(TAnalysisContext analysisContext);
    public virtual TAnalysisData Flow(IOperation statement, BasicBlock block, TAnalysisData input);
    [ConditionalAttribute("DEBUG")]
private void AfterVisitRoot(IOperation operation);
    public TAnalysisData OnStartBlockAnalysis(BasicBlock block, TAnalysisData input);
    public TAnalysisData OnEndBlockAnalysis(BasicBlock block, TAnalysisData analysisData);
    protected abstract virtual void UpdateValuesForAnalysisData(TAnalysisData targetAnalysisData);
    protected void UpdateValuesForAnalysisData(DictionaryAnalysisData`2<TKey, TAbstractAnalysisValue> targetAnalysisData, DictionaryAnalysisData`2<TKey, TAbstractAnalysisValue> newAnalysisData);
    protected abstract virtual void StopTrackingDataForParameter(IParameterSymbol parameter, AnalysisEntity analysisEntity);
    protected virtual void StopTrackingDataForParameters(ImmutableDictionary`2<IParameterSymbol, AnalysisEntity> parameterEntities);
    private void OnStartEntryBlockAnalysis(BasicBlock entryBlock);
    private void OnStartExitBlockAnalysis(BasicBlock exitBlock);
    private void OnEndExitBlockAnalysis(BasicBlock exitBlock);
    protected bool IsParameterEntityForCurrentMethod(AnalysisEntity analysisEntity);
    public virtual ValueTuple`2<TAnalysisData, bool> FlowBranch(BasicBlock fromBlock, BranchWithInfo branch, TAnalysisData input);
    private protected virtual TAbstractAnalysisValue GetAbstractValueForImplicitWrappingTaskCreation(IOperation returnValueOperation, TAbstractAnalysisValue returnValue, PointsToAbstractValue implicitTaskPointsToValue);
    [NullableContextAttribute("2")]
protected virtual void ProcessReturnValue(IOperation returnValueOperation);
    private TAbstractAnalysisValue GetAbstractValueForReturnOperation(IOperation returnValueOperation, PointsToAbstractValue& implicitTaskPointsToValueOpt);
    protected virtual void HandlePossibleThrowingOperation(IOperation operation);
    protected virtual TAnalysisData GetMergedAnalysisDataForPossibleThrowingOperation(TAnalysisData existingDataOpt, IOperation operation);
    public TAnalysisData OnLeavingRegions(IEnumerable`1<ILocalSymbol> leavingRegionLocals, IEnumerable`1<CaptureId> leavingRegionFlowCaptures, BasicBlock currentBasicBlock, TAnalysisData input);
    protected virtual void ProcessOutOfScopeLocalsAndFlowCaptures(IEnumerable`1<ILocalSymbol> locals, IEnumerable`1<CaptureId> flowCaptures);
    private bool IsContractCheckArgument(IArgumentOperation operation);
    internal ImmutableDictionary`2<IOperation, TAbstractAnalysisValue> GetStateMap();
    internal ImmutableDictionary`2<IOperation, PredicateValueKind> GetPredicateValueKindMap();
    [NullableContextAttribute("2")]
public virtual TAnalysisData GetMergedDataForUnhandledThrowOperations();
    public TAbstractAnalysisValue GetCachedAbstractValue(IOperation operation);
    protected void CacheAbstractValue(IOperation operation, TAbstractAnalysisValue value);
    protected NullAbstractValue GetNullAbstractValue(IOperation operation);
    protected virtual CopyAbstractValue GetCopyAbstractValue(IOperation operation);
    protected virtual PointsToAbstractValue GetPointsToAbstractValue(IOperation operation);
    protected virtual ValueContentAbstractValue GetValueContentAbstractValue(IOperation operation);
    protected ImmutableHashSet`1<AbstractLocation> GetEscapedLocations(IOperation operation);
    protected ImmutableHashSet`1<AbstractLocation> GetEscapedLocations(AnalysisEntity parameterEntity);
    protected bool TryGetPointsToAbstractValueAtEntryBlockEnd(AnalysisEntity analysisEntity, PointsToAbstractValue& pointsToAbstractValue);
    protected bool TryGetNullAbstractValueAtCurrentBlockEntry(AnalysisEntity analysisEntity, NullAbstractValue& nullAbstractValue);
    protected bool TryGetMergedNullAbstractValueAtUnhandledThrowOperationsInGraph(AnalysisEntity analysisEntity, NullAbstractValue& nullAbstractValue);
    private protected void SetTaskWrappedValue(PointsToAbstractValue pointsToValueForTask, TAbstractAnalysisValue wrappedValue);
    private protected bool TryGetTaskWrappedValue(PointsToAbstractValue pointsToAbstractValue, TAbstractAnalysisValue& wrappedValue);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForReferenceOperation(IOperation operation, TAbstractAnalysisValue defaultValue);
    protected virtual TAbstractAnalysisValue ComputeAnalysisValueForEscapedRefOrOutArgument(IArgumentOperation operation, TAbstractAnalysisValue defaultValue);
    internal bool TryInferConversion(IConversionOperation operation, ConversionInference& inference);
    internal bool TryInferConversion(IIsPatternOperation operation, ConversionInference& inference);
    private bool TryInferConversion(IOperation sourceOperand, ITypeSymbol targetType, bool isTryCast, IOperation operation, ConversionInference& inference);
    protected virtual void UpdateReachability(BasicBlock basicBlock, TAnalysisData analysisData, bool isReachable);
    protected virtual bool IsReachableBlockData(TAnalysisData analysisData);
    private bool GetBlockReachability(BasicBlock basicBlock);
    protected bool IsCurrentBlockReachable();
    private void PerformPredicateAnalysis(IOperation operation);
    private void PerformPredicateAnalysisCore(IOperation operation, TAnalysisData targetAnalysisData);
    protected virtual void SetPredicateValueKind(IOperation operation, TAnalysisData analysisData, PredicateValueKind predicateValueKind);
    protected virtual PredicateValueKind SetValueForComparisonOperator(IBinaryOperation operation, TAnalysisData targetAnalysisData);
    protected virtual PredicateValueKind SetValueForEqualsOrNotEqualsComparisonOperator(IOperation leftOperand, IOperation rightOperand, bool equals, bool isReferenceEquality, TAnalysisData targetAnalysisData);
    protected virtual PredicateValueKind SetValueForIsNullComparisonOperator(IOperation leftOperand, bool equals, TAnalysisData targetAnalysisData);
    [NullableContextAttribute("2")]
protected virtual void StartTrackingPredicatedData(AnalysisEntity predicatedEntity, TAnalysisData truePredicateData, TAnalysisData falsePredicateData);
    protected virtual void StopTrackingPredicatedData(AnalysisEntity predicatedEntity);
    private bool HasPredicatedDataForEntity(AnalysisEntity predicatedEntity);
    protected virtual bool HasPredicatedDataForEntity(TAnalysisData analysisData, AnalysisEntity predicatedEntity);
    protected virtual void TransferPredicatedData(AnalysisEntity fromEntity, AnalysisEntity toEntity);
    protected virtual PredicateValueKind ApplyPredicatedDataForEntity(TAnalysisData analysisData, AnalysisEntity predicatedEntity, bool trueData);
    [NullableContextAttribute("2")]
protected virtual void ProcessThrowValue(IOperation thrownValueOpt);
    protected abstract virtual void SetAbstractValueForArrayElementInitializer(IArrayCreationOperation arrayCreation, ImmutableArray`1<AbstractIndex> indices, ITypeSymbol elementType, IOperation initializer, TAbstractAnalysisValue value);
    protected abstract virtual void SetAbstractValueForAssignment(IOperation target, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue, bool mayBeAssignment);
    protected abstract virtual void SetAbstractValueForTupleElementAssignment(AnalysisEntity tupleElementEntity, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue);
    private void HandleFlowCaptureReferenceAssignment(IFlowCaptureReferenceOperation flowCaptureReference, IOperation assignedValueOperation, TAbstractAnalysisValue assignedValue);
    protected abstract virtual void ResetValueTypeInstanceAnalysisData(AnalysisEntity analysisEntity);
    protected abstract virtual void ResetReferenceTypeInstanceAnalysisData(PointsToAbstractValue pointsToAbstractValue);
    private void ResetValueTypeInstanceAnalysisData(IOperation operation);
    private void ResetReferenceTypeInstanceAnalysisData(IOperation operation);
    [NullableContextAttribute("2")]
private void ResetInstanceAnalysisData(IOperation operation);
    public TAnalysisData MergeAnalysisData(TAnalysisData value1, TAnalysisData value2, bool forBackEdge);
    protected abstract virtual TAnalysisData MergeAnalysisData(TAnalysisData value1, TAnalysisData value2);
    protected virtual TAnalysisData MergeAnalysisDataForBackEdge(TAnalysisData value1, TAnalysisData value2);
    protected abstract virtual TAnalysisData GetClonedAnalysisData(TAnalysisData analysisData);
    protected TAnalysisData GetClonedCurrentAnalysisData();
    public abstract virtual TAnalysisData GetEmptyAnalysisData();
    protected abstract virtual TAnalysisData GetExitBlockOutputData(TAnalysisResult analysisResult);
    protected abstract virtual bool Equals(TAnalysisData value1, TAnalysisData value2);
    protected static bool EqualsHelper(IDictionary`2<TKey, TValue> dict1, IDictionary`2<TKey, TValue> dict2);
    protected abstract virtual void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(TAnalysisData dataAtException, ThrownExceptionInfo throwBranchWithExceptionType);
    protected virtual void AssertValidAnalysisData(TAnalysisData analysisData);
    protected void ApplyMissingCurrentAnalysisDataForUnhandledExceptionData(DictionaryAnalysisData`2<TKey, TAbstractAnalysisValue> coreDataAtException, DictionaryAnalysisData`2<TKey, TAbstractAnalysisValue> coreCurrentAnalysisData, Func`2<TKey, bool> predicateOpt);
    protected virtual TAnalysisData GetInitialInterproceduralAnalysisData(IMethodSymbol invokedMethod, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> invocationInstanceOpt, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> thisOrMeInstanceForCallerOpt, ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> argumentValuesMap, IDictionary`2<AnalysisEntity, PointsToAbstractValue> pointsToValuesOpt, IDictionary`2<AnalysisEntity, CopyAbstractValue> copyValuesOpt, IDictionary`2<AnalysisEntity, ValueContentAbstractValue> valueContentValuesOpt, bool isLambdaOrLocalFunction, bool hasParameterWithDelegateType);
    protected virtual void ApplyInterproceduralAnalysisResult(TAnalysisData resultData, bool isLambdaOrLocalFunction, bool hasDelegateTypeArgument, TAnalysisResult analysisResult);
    private void ApplyInterproceduralAnalysisDataForUnhandledThrowOperations(Dictionary`2<ThrownExceptionInfo, TAnalysisData> interproceduralUnhandledThrowOperationsData);
    protected bool TryGetInterproceduralAnalysisResult(IOperation operation, TAnalysisResult& analysisResult);
    private TAbstractAnalysisValue PerformInterproceduralAnalysis(Func`1<ControlFlowGraph> getCfg, IMethodSymbol invokedMethod, IOperation instanceReceiver, ImmutableArray`1<IArgumentOperation> arguments, IOperation originalOperation, TAbstractAnalysisValue defaultValue, bool isLambdaOrLocalFunction);
    protected TAbstractAnalysisValue VisitArray(IEnumerable`1<IOperation> operations, object argument);
    public virtual TAbstractAnalysisValue Visit(IOperation operation, object argument);
    private TAbstractAnalysisValue VisitCore(IOperation operation, object argument);
    public virtual TAbstractAnalysisValue DefaultVisit(IOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitSimpleAssignment(ISimpleAssignmentOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitCompoundAssignment(ICompoundAssignmentOperation operation, object argument);
    public virtual TAbstractAnalysisValue ComputeValueForCompoundAssignment(ICompoundAssignmentOperation operation, TAbstractAnalysisValue targetValue, TAbstractAnalysisValue assignedValue, ITypeSymbol targetType, ITypeSymbol assignedValueType);
    public virtual TAbstractAnalysisValue VisitIncrementOrDecrement(IIncrementOrDecrementOperation operation, object argument);
    public virtual TAbstractAnalysisValue ComputeValueForIncrementOrDecrementOperation(IIncrementOrDecrementOperation operation, TAbstractAnalysisValue targetValue);
    public virtual TAbstractAnalysisValue VisitDeconstructionAssignment(IDeconstructionAssignmentOperation operation, object argument);
    protected virtual TAbstractAnalysisValue VisitAssignmentOperation(IAssignmentOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitArrayInitializer(IArrayInitializerOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitLocalReference(ILocalReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitParameterReference(IParameterReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitArrayElementReference(IArrayElementReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitDynamicMemberReference(IDynamicMemberReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitEventReference(IEventReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitFieldReference(IFieldReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitMethodReference(IMethodReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitPropertyReference(IPropertyReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitFlowCaptureReference(IFlowCaptureReferenceOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitFlowCapture(IFlowCaptureOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitDefaultValue(IDefaultValueOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitInterpolation(IInterpolationOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitInterpolatedStringText(IInterpolatedStringTextOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitArgument(IArgumentOperation operation, object argument);
    protected virtual void PostProcessArgument(IArgumentOperation operation, bool isEscaped);
    private void PostProcessEscapedArgument(IArgumentOperation operation);
    public virtual TAbstractAnalysisValue VisitConstantPattern(IConstantPatternOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitParenthesized(IParenthesizedOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitTranslatedQuery(ITranslatedQueryOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitConversion(IConversionOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitObjectCreation(IObjectCreationOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitInvocation(IInvocationOperation operation, object argument);
    private TAbstractAnalysisValue VisitInvocation_NonLambdaOrDelegateOrLocalFunction(IInvocationOperation operation, object argument);
    private TAbstractAnalysisValue VisitInvocation_LambdaOrDelegateOrLocalFunction(IInvocationOperation operation, object argument, HashSet`1& resolvedMethodTargetsOpt);
    public virtual TAbstractAnalysisValue VisitInvocation_NonLambdaOrDelegateOrLocalFunction(IMethodSymbol method, IOperation visitedInstance, ImmutableArray`1<IArgumentOperation> visitedArguments, bool invokedAsDelegate, IOperation originalOperation, TAbstractAnalysisValue defaultValue);
    private ControlFlowGraph GetInterproceduralControlFlowGraph(IMethodSymbol method);
    private ImmutableStack`1<IOperation> GetInterproceduralCallStackForOwningSymbol(ISymbol forOwningSymbol);
    public virtual TAbstractAnalysisValue VisitInvocation_LocalFunction(IMethodSymbol localFunction, ImmutableArray`1<IArgumentOperation> visitedArguments, IOperation originalOperation, TAbstractAnalysisValue defaultValue);
    public virtual TAbstractAnalysisValue VisitInvocation_Lambda(IFlowAnonymousFunctionOperation lambda, ImmutableArray`1<IArgumentOperation> visitedArguments, IOperation originalOperation, TAbstractAnalysisValue defaultValue);
    public virtual void HandleEnterLockOperation(IOperation lockedObject);
    private void ResetThisOrMeInstanceAnalysisData();
    public virtual TAbstractAnalysisValue VisitTuple(ITupleOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitUnaryOperatorCore(IUnaryOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitUnaryOperator(IUnaryOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitBinaryOperatorCore(IBinaryOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitBinaryOperator(IBinaryOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitIsNull(IIsNullOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitCaughtException(ICaughtExceptionOperation operation, object argument);
    [NullableContextAttribute("2")]
private void MergeAnalysisDataFromUnhandledThrowOperations(ITypeSymbol caughtExceptionTypeOpt);
    public virtual TAbstractAnalysisValue VisitFlowAnonymousFunction(IFlowAnonymousFunctionOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitStaticLocalInitializationSemaphore(IStaticLocalInitializationSemaphoreOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitAnonymousObjectCreation(IAnonymousObjectCreationOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitReturn(IReturnOperation operation, object argument);
    public virtual TAbstractAnalysisValue GetAssignedValueForPattern(IIsPatternOperation operation, TAbstractAnalysisValue operandValue);
    public sealed virtual TAbstractAnalysisValue VisitIsPattern(IIsPatternOperation operation, object argument);
    public virtual TAbstractAnalysisValue VisitAwait(IAwaitOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitUsing(IUsingOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitWhileLoop(IWhileLoopOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitForEachLoop(IForEachLoopOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitForLoop(IForLoopOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitForToLoop(IForToLoopOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitCoalesce(ICoalesceOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitConditional(IConditionalOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitConditionalAccess(IConditionalAccessOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitConditionalAccessInstance(IConditionalAccessInstanceOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitThrow(IThrowOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitVariableDeclaration(IVariableDeclarationOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitVariableDeclarationGroup(IVariableDeclarationGroupOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitVariableDeclarator(IVariableDeclaratorOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitTry(ITryOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitCatchClause(ICatchClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public virtual TAbstractAnalysisValue VisitLock(ILockOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitBranch(IBranchOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitLabeled(ILabeledOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitSwitch(ISwitchOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitSwitchCase(ISwitchCaseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitDefaultCaseClause(IDefaultCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitPatternCaseClause(IPatternCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitRangeCaseClause(IRangeCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitRelationalCaseClause(IRelationalCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitSingleValueCaseClause(ISingleValueCaseClauseOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitObjectOrCollectionInitializer(IObjectOrCollectionInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitMemberInitializer(IMemberInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitBlock(IBlockOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitVariableInitializer(IVariableInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitFieldInitializer(IFieldInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitParameterInitializer(IParameterInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitPropertyInitializer(IPropertyInitializerOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitEnd(IEndOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitEmpty(IEmptyOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitNameOf(INameOfOperation operation, object argument);
    public sealed virtual TAbstractAnalysisValue VisitAnonymousFunction(IAnonymousFunctionOperation operation, object argument);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TAbstractAnalysisValue VisitLocalFunction(ILocalFunctionOperation operation, object argument);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_ExceptionNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_ContractNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_IDisposableNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol get_IAsyncDisposableNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_TaskNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private INamedTypeSymbol get_ValueTaskNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_GenericTaskNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_MonitorNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_InterlockedNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_SerializationInfoNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_GenericIEquatableNamedType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected INamedTypeSymbol get_StringReaderType();
    [CompilerGeneratedAttribute]
protected ImmutableHashSet`1<INamedTypeSymbol> get_CollectionNamedTypes();
    private ImmutableHashSet`1<INamedTypeSymbol> GetWellKnownCollectionTypes();
    [NullableContextAttribute("2")]
private protected bool IsDisposable(ITypeSymbol type);
    private protected DisposeMethodKind GetDisposeMethodKind(IMethodSymbol method);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__87_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <FlowBranch>g__isConditionalBranchNeverTaken|104_0(<>c__DisplayClass104_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <FlowBranch>g__isPredicateAlwaysFalseForBranch|104_1(PredicateValueKind predicateValueKind, <>c__DisplayClass104_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <TryInferConversion>g__IsInterfaceOrTypeParameter|133_0(ITypeSymbol type);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <PerformPredicateAnalysis>g__IsRootOfCondition|138_0(<>c__DisplayClass138_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private AnalysisEntity <PerformPredicateAnalysis>g__GetPredicatedFlowCaptureEntity|138_1(<>c__DisplayClass138_0& );
    [CompilerGeneratedAttribute]
private bool <PerformPredicateAnalysisCore>g__IsOverrideOrImplementationOfEquatableEquals|139_0(IMethodSymbol methodSymbol);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <HandleFlowCaptureReferenceAssignment>g__HasUniqueCapturedEntity|154_0(<>c__DisplayClass154_0& );
    [CompilerGeneratedAttribute]
private void <ApplyInterproceduralAnalysisDataForUnhandledThrowOperations>g__ApplyInterproceduralAnalysisDataForUnhandledThrowOperation|174_0(ThrownExceptionInfo exceptionInfo, TAnalysisData analysisDataAtException);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <VisitFlowCapture>g__PerformFlowCapturePredicateAnalysis|198_0(<>c__DisplayClass198_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <VisitInvocation>g__PostVisitInvocation|210_0(IMethodSymbol targetMethod, ImmutableArray`1<IArgumentOperation> arguments, <>c__DisplayClass210_0& );
    [CompilerGeneratedAttribute]
private void <VisitInvocation>g__ProcessInterlockedOperation|210_1(IMethodSymbol targetMethod, ImmutableArray`1<IArgumentOperation> arguments, INamedTypeSymbol interlockedType, <>c__DisplayClass210_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <MergeAnalysisDataFromUnhandledThrowOperations>g__ShouldHandlePendingThrow|227_0(ThrownExceptionInfo pendingThrow, <>c__DisplayClass227_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DictionaryAnalysisData`2 : AbstractAnalysisData {
    private PooledDictionary`2<TKey, TValue> _coreAnalysisData;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public DictionaryAnalysisData`2(IDictionary`2<TKey, TValue> initializer);
    public ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValue : CacheBasedEquatable`1<DisposeAbstractValue> {
    public static DisposeAbstractValue NotDisposable;
    public static DisposeAbstractValue Invalid;
    public static DisposeAbstractValue NotDisposed;
    public static DisposeAbstractValue Unknown;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IOperation> <DisposingOrEscapingOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private DisposeAbstractValueKind <Kind>k__BackingField;
    public ImmutableHashSet`1<IOperation> DisposingOrEscapingOperations { get; }
    public DisposeAbstractValueKind Kind { get; }
    private DisposeAbstractValue(DisposeAbstractValueKind kind);
    internal DisposeAbstractValue(ImmutableHashSet`1<IOperation> disposingOrEscapingOperations, DisposeAbstractValueKind kind);
    private static DisposeAbstractValue();
    internal DisposeAbstractValue WithNewDisposingOperation(IOperation disposingOperation);
    internal DisposeAbstractValue WithNewEscapingOperation(IOperation escapingOperation);
    [ConditionalAttribute("DEBUG")]
private static void VerifyArguments(ImmutableHashSet`1<IOperation> disposingOrEscapingOperations, DisposeAbstractValueKind kind);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IOperation> get_DisposingOrEscapingOperations();
    [CompilerGeneratedAttribute]
public DisposeAbstractValueKind get_Kind();
    protected virtual void ComputeHashCodeParts(Action`1<int> addPart);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAbstractValueKind : Enum {
    public int value__;
    public static DisposeAbstractValueKind NotDisposable;
    public static DisposeAbstractValueKind Invalid;
    public static DisposeAbstractValueKind NotDisposed;
    public static DisposeAbstractValueKind Escaped;
    public static DisposeAbstractValueKind NotDisposedOrEscaped;
    public static DisposeAbstractValueKind Disposed;
    public static DisposeAbstractValueKind MaybeDisposed;
    public static DisposeAbstractValueKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysis : ForwardDataFlowAnalysis`5<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAnalysisResult, DisposeBlockAnalysisResult, DisposeAbstractValue> {
    private static bool PessimisticAnalysis;
    internal static MapAbstractDomain`2<AbstractLocation, DisposeAbstractValue> DisposeAnalysisDomainInstance;
    private DisposeAnalysis(MapAbstractDomain`2<AbstractLocation, DisposeAbstractValue> analysisDomain, DisposeDataFlowOperationVisitor operationVisitor);
    private static DisposeAnalysis();
    public static DisposeAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, ImmutableHashSet`1<INamedTypeSymbol> disposeOwnershipTransferLikelyTypes, bool trackInstanceFields, bool exceptionPathsAnalysis, CancellationToken cancellationToken, PointsToAnalysisResult& pointsToAnalysisResult, InterproceduralAnalysisKind interproceduralAnalysisKind, bool performCopyAnalysisIfNotUserConfigured, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt, bool defaultDisposeOwnershipTransferAtConstructor, bool defaultDisposeOwnershipTransferAtMethodCall);
    private static DisposeAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt, ImmutableHashSet`1<INamedTypeSymbol> disposeOwnershipTransferLikelyTypes, bool disposeOwnershipTransferAtConstructor, bool disposeOwnershipTransferAtMethodCall, bool trackInstanceFields, bool exceptionPathsAnalysis, bool performCopyAnalysis, SymbolNamesWithValueOption`1<Unit> excludedSymbols, PointsToAnalysisResult& pointsToAnalysisResult);
    private static DisposeAnalysisResult TryGetOrComputeResultForAnalysisContext(DisposeAnalysisContext disposeAnalysisContext);
    protected virtual DisposeAnalysisResult ToResult(DisposeAnalysisContext analysisContext, DataFlowAnalysisResult`2<DisposeBlockAnalysisResult, DisposeAbstractValue> dataFlowAnalysisResult);
    protected virtual DisposeBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue> blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysisContext : AbstractDataFlowAnalysisContext`4<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAnalysisResult, DisposeAbstractValue> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<INamedTypeSymbol> <DisposeOwnershipTransferLikelyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisposeOwnershipTransferAtConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisposeOwnershipTransferAtMethodCall>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrackInstanceFields>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolNamesWithValueOption`1<Unit> <ExcludedSymbols>k__BackingField;
    internal ImmutableHashSet`1<INamedTypeSymbol> DisposeOwnershipTransferLikelyTypes { get; }
    internal bool DisposeOwnershipTransferAtConstructor { get; }
    internal bool DisposeOwnershipTransferAtMethodCall { get; }
    internal bool TrackInstanceFields { get; }
    internal SymbolNamesWithValueOption`1<Unit> ExcludedSymbols { get; }
    private DisposeAnalysisContext(AbstractValueDomain`1<DisposeAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, PointsToAnalysisResult pointsToAnalysisResultOpt, Func`2<DisposeAnalysisContext, DisposeAnalysisResult> tryGetOrComputeAnalysisResult, ImmutableHashSet`1<INamedTypeSymbol> disposeOwnershipTransferLikelyTypes, bool disposeOwnershipTransferAtConstructor, bool disposeOwnershipTransferAtMethodCall, bool trackInstanceFields, ControlFlowGraph parentControlFlowGraphOpt, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAbstractValue> interproceduralAnalysisDataOpt, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt, SymbolNamesWithValueOption`1<Unit> excludedSymbols);
    internal static DisposeAnalysisContext Create(AbstractValueDomain`1<DisposeAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt, bool pessimisticAnalysis, bool exceptionPathsAnalysis, PointsToAnalysisResult pointsToAnalysisResultOpt, Func`2<DisposeAnalysisContext, DisposeAnalysisResult> tryGetOrComputeAnalysisResult, ImmutableHashSet`1<INamedTypeSymbol> disposeOwnershipTransferLikelyTypes, bool disposeOwnershipTransferAtConstructor, bool disposeOwnershipTransferAtMethodCall, bool trackInstanceFields, SymbolNamesWithValueOption`1<Unit> excludedSymbols);
    public virtual DisposeAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedControlFlowGraph, IOperation operation, PointsToAnalysisResult pointsToAnalysisResultOpt, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResultOpt, InterproceduralAnalysisData`3<DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue>, DisposeAnalysisContext, DisposeAbstractValue> interproceduralAnalysisData);
    [CompilerGeneratedAttribute]
internal ImmutableHashSet`1<INamedTypeSymbol> get_DisposeOwnershipTransferLikelyTypes();
    [CompilerGeneratedAttribute]
internal bool get_DisposeOwnershipTransferAtConstructor();
    [CompilerGeneratedAttribute]
internal bool get_DisposeOwnershipTransferAtMethodCall();
    [CompilerGeneratedAttribute]
internal bool get_TrackInstanceFields();
    [CompilerGeneratedAttribute]
internal SymbolNamesWithValueOption`1<Unit> get_ExcludedSymbols();
    protected virtual void ComputeHashCodePartsSpecific(Action`1<int> addPart);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeAnalysisResult : DataFlowAnalysisResult`2<DisposeBlockAnalysisResult, DisposeAbstractValue> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<IFieldSymbol, PointsToAbstractValue> <TrackedInstanceFieldPointsToMap>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<IFieldSymbol, PointsToAbstractValue> TrackedInstanceFieldPointsToMap { get; }
    internal DisposeAnalysisResult(DataFlowAnalysisResult`2<DisposeBlockAnalysisResult, DisposeAbstractValue> coreDisposeAnalysisResult, ImmutableDictionary`2<IFieldSymbol, PointsToAbstractValue> trackedInstanceFieldPointsToMap);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<IFieldSymbol, PointsToAbstractValue> get_TrackedInstanceFieldPointsToMap();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.DisposeAnalysis.DisposeBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AbstractLocation, DisposeAbstractValue> <Data>k__BackingField;
    public ImmutableDictionary`2<AbstractLocation, DisposeAbstractValue> Data { get; }
    internal DisposeBlockAnalysisResult(BasicBlock basicBlock, DictionaryAnalysisData`2<AbstractLocation, DisposeAbstractValue> blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AbstractLocation, DisposeAbstractValue> get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ForwardDataFlowAnalysis`5 : DataFlowAnalysis`5<TAnalysisData, TAnalysisContext, TAnalysisResult, TBlockAnalysisResult, TAbstractAnalysisValue> {
    protected ForwardDataFlowAnalysis`5(AbstractAnalysisDomain`1<TAnalysisData> analysisDomain, DataFlowOperationVisitor`4<TAnalysisData, TAnalysisContext, TAnalysisResult, TAbstractAnalysisValue> operationVisitor);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisContext {
    public ControlFlowGraph ControlFlowGraph { get; }
    public ISymbol OwningSymbol { get; }
    public abstract virtual ControlFlowGraph get_ControlFlowGraph();
    public abstract virtual ISymbol get_OwningSymbol();
    public abstract virtual ControlFlowGraph GetLocalFunctionControlFlowGraph(IMethodSymbol localFunction);
    public abstract virtual ControlFlowGraph GetAnonymousFunctionControlFlowGraph(IFlowAnonymousFunctionOperation lambda);
}
[NullableContextAttribute("2")]
public interface Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.IDataFlowAnalysisResult`1 {
    [NullableAttribute("1")]
public ControlFlowGraph ControlFlowGraph { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> ReturnValueAndPredicateKindOpt { get; }
    public object AnalysisDataForUnhandledThrowOperationsOpt { get; }
    public object TaskWrappedValuesMapOpt { get; }
    [NullableContextAttribute("1")]
public abstract virtual ControlFlowGraph get_ControlFlowGraph();
    public abstract virtual Nullable`1<ValueTuple`2<TAbstractAnalysisValue, PredicateValueKind>> get_ReturnValueAndPredicateKindOpt();
    public abstract virtual object get_AnalysisDataForUnhandledThrowOperationsOpt();
    public abstract virtual object get_TaskWrappedValuesMapOpt();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisConfiguration : ValueType {
    private static UInt32 DefaultMaxInterproceduralMethodCallChain;
    private static UInt32 DefaultMaxInterproceduralLambdaOrLocalFunctionCallChain;
    [CompilerGeneratedAttribute]
private InterproceduralAnalysisKind <InterproceduralAnalysisKind>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxInterproceduralMethodCallChain>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxInterproceduralLambdaOrLocalFunctionCallChain>k__BackingField;
    public InterproceduralAnalysisKind InterproceduralAnalysisKind { get; }
    public UInt32 MaxInterproceduralMethodCallChain { get; }
    public UInt32 MaxInterproceduralLambdaOrLocalFunctionCallChain { get; }
    private InterproceduralAnalysisConfiguration(InterproceduralAnalysisKind interproceduralAnalysisKind, UInt32 maxInterproceduralMethodCallChain, UInt32 maxInterproceduralLambdaOrLocalFunctionCallChain);
    public static InterproceduralAnalysisConfiguration Create(AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, ISymbol symbol, Compilation compilation, InterproceduralAnalysisKind defaultInterproceduralAnalysisKind, CancellationToken cancellationToken, UInt32 defaultMaxInterproceduralMethodCallChain, UInt32 defaultMaxInterproceduralLambdaOrLocalFunctionCallChain);
    public static InterproceduralAnalysisConfiguration Create(AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, SyntaxTree tree, Compilation compilation, InterproceduralAnalysisKind defaultInterproceduralAnalysisKind, CancellationToken cancellationToken, UInt32 defaultMaxInterproceduralMethodCallChain, UInt32 defaultMaxInterproceduralLambdaOrLocalFunctionCallChain);
    public static InterproceduralAnalysisConfiguration Create(AnalyzerOptions analyzerOptions, ImmutableArray`1<DiagnosticDescriptor> rules, ISymbol symbol, Compilation compilation, InterproceduralAnalysisKind defaultInterproceduralAnalysisKind, CancellationToken cancellationToken, UInt32 defaultMaxInterproceduralMethodCallChain, UInt32 defaultMaxInterproceduralLambdaOrLocalFunctionCallChain);
    public static InterproceduralAnalysisConfiguration Create(AnalyzerOptions analyzerOptions, ImmutableArray`1<DiagnosticDescriptor> rules, SyntaxTree tree, Compilation compilation, InterproceduralAnalysisKind defaultInterproceduralAnalysisKind, CancellationToken cancellationToken, UInt32 defaultMaxInterproceduralMethodCallChain, UInt32 defaultMaxInterproceduralLambdaOrLocalFunctionCallChain);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public InterproceduralAnalysisKind get_InterproceduralAnalysisKind();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MaxInterproceduralMethodCallChain();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_MaxInterproceduralLambdaOrLocalFunctionCallChain();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(InterproceduralAnalysisConfiguration other);
    public virtual int GetHashCode();
    public static bool op_Equality(InterproceduralAnalysisConfiguration left, InterproceduralAnalysisConfiguration right);
    public static bool op_Inequality(InterproceduralAnalysisConfiguration left, InterproceduralAnalysisConfiguration right);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisData`3 : CacheBasedEquatable`1<InterproceduralAnalysisData`3<TAnalysisData, TAnalysisContext, TAbstractAnalysisValue>> {
    [CompilerGeneratedAttribute]
private TAnalysisData <InitialAnalysisData>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> <InvocationInstanceOpt>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> <ThisOrMeInstanceForCallerOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> <ArgumentValuesMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<ISymbol, PointsToAbstractValue> <CapturedVariablesMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> <AddressSharedEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableStack`1<IOperation> <CallStack>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<TAnalysisContext> <MethodsBeingAnalyzed>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IOperation, TAbstractAnalysisValue> <GetCachedAbstractValueFromCaller>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<IMethodSymbol, ControlFlowGraph> <GetInterproceduralControlFlowGraph>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<IOperation, AnalysisEntity> <GetAnalysisEntityForFlowCapture>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<ISymbol, ImmutableStack`1<IOperation>> <GetInterproceduralCallStackForOwningSymbol>k__BackingField;
    public TAnalysisData InitialAnalysisData { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> InvocationInstanceOpt { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> ThisOrMeInstanceForCallerOpt { get; }
    public ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> ArgumentValuesMap { get; }
    public ImmutableDictionary`2<ISymbol, PointsToAbstractValue> CapturedVariablesMap { get; }
    public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> AddressSharedEntities { get; }
    public ImmutableStack`1<IOperation> CallStack { get; }
    public ImmutableHashSet`1<TAnalysisContext> MethodsBeingAnalyzed { get; }
    public Func`2<IOperation, TAbstractAnalysisValue> GetCachedAbstractValueFromCaller { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<IMethodSymbol, ControlFlowGraph> GetInterproceduralControlFlowGraph { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<IOperation, AnalysisEntity> GetAnalysisEntityForFlowCapture { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<ISymbol, ImmutableStack`1<IOperation>> GetInterproceduralCallStackForOwningSymbol { get; }
    public InterproceduralAnalysisData`3(TAnalysisData initialAnalysisData, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> invocationInstanceOpt, Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> thisOrMeInstanceForCallerOpt, ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> argumentValuesMap, ImmutableDictionary`2<ISymbol, PointsToAbstractValue> capturedVariablesMap, ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> addressSharedEntities, ImmutableStack`1<IOperation> callStack, ImmutableHashSet`1<TAnalysisContext> methodsBeingAnalyzed, Func`2<IOperation, TAbstractAnalysisValue> getCachedAbstractValueFromCaller, Func`2<IMethodSymbol, ControlFlowGraph> getInterproceduralControlFlowGraph, Func`2<IOperation, AnalysisEntity> getAnalysisEntityForFlowCapture, Func`2<ISymbol, ImmutableStack`1<IOperation>> getInterproceduralCallStackForOwningSymbol);
    [CompilerGeneratedAttribute]
public TAnalysisData get_InitialAnalysisData();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> get_InvocationInstanceOpt();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> get_ThisOrMeInstanceForCallerOpt();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<IParameterSymbol, ArgumentInfo`1<TAbstractAnalysisValue>> get_ArgumentValuesMap();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<ISymbol, PointsToAbstractValue> get_CapturedVariablesMap();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, CopyAbstractValue> get_AddressSharedEntities();
    [CompilerGeneratedAttribute]
public ImmutableStack`1<IOperation> get_CallStack();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<TAnalysisContext> get_MethodsBeingAnalyzed();
    [CompilerGeneratedAttribute]
public Func`2<IOperation, TAbstractAnalysisValue> get_GetCachedAbstractValueFromCaller();
    [CompilerGeneratedAttribute]
public Func`2<IMethodSymbol, ControlFlowGraph> get_GetInterproceduralControlFlowGraph();
    [CompilerGeneratedAttribute]
public Func`2<IOperation, AnalysisEntity> get_GetAnalysisEntityForFlowCapture();
    [CompilerGeneratedAttribute]
public Func`2<ISymbol, ImmutableStack`1<IOperation>> get_GetInterproceduralCallStackForOwningSymbol();
    protected virtual void ComputeHashCodeParts(Action`1<int> addPart);
    private static void AddHashCodeParts(Nullable`1<ValueTuple`2<AnalysisEntity, PointsToAbstractValue>> instanceAndPointsToValueOpt, Action`1<int> addPart);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisKind : Enum {
    public int value__;
    public static InterproceduralAnalysisKind None;
    public static InterproceduralAnalysisKind ContextSensitive;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralAnalysisPredicate : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IMethodSymbol, bool> _skipAnalysisForInvokedMethodPredicateOpt;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IMethodSymbol, bool> _skipAnalysisForInvokedLambdaOrLocalFunctionPredicateOpt;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<IDataFlowAnalysisContext, bool> _skipAnalysisForInvokedContextPredicateOpt;
    public InterproceduralAnalysisPredicate(Func`2<IMethodSymbol, bool> skipAnalysisForInvokedMethodPredicateOpt, Func`2<IMethodSymbol, bool> skipAnalysisForInvokedLambdaOrLocalFunctionPredicateOpt, Func`2<IDataFlowAnalysisContext, bool> skipAnalysisForInvokedContextPredicateOpt);
    public bool SkipInterproceduralAnalysis(IMethodSymbol invokedMethod, bool isLambdaOrLocalFunction);
    public bool SkipInterproceduralAnalysis(IDataFlowAnalysisContext interproceduralAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.InterproceduralCaptureId : ValueType {
    [CompilerGeneratedAttribute]
private CaptureId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLValueFlowCapture>k__BackingField;
    public CaptureId Id { get; }
    public ControlFlowGraph ControlFlowGraph { get; }
    public bool IsLValueFlowCapture { get; }
    internal InterproceduralCaptureId(CaptureId captureId, ControlFlowGraph controlFlowGraph, bool isLValueFlowCapture);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CaptureId get_Id();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ControlFlowGraph get_ControlFlowGraph();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsLValueFlowCapture();
    public sealed virtual bool Equals(InterproceduralCaptureId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(InterproceduralCaptureId left, InterproceduralCaptureId right);
    public static bool op_Inequality(InterproceduralCaptureId left, InterproceduralCaptureId right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.LValueFlowCapturesProvider : object {
    private static ConditionalWeakTable`2<ControlFlowGraph, ImmutableHashSet`1<CaptureId>> s_lValueFlowCapturesCache;
    private static LValueFlowCapturesProvider();
    public static ImmutableHashSet`1<CaptureId> GetOrCreateLValueFlowCaptures(ControlFlowGraph cfg);
    private static ImmutableHashSet`1<CaptureId> CreateLValueFlowCaptures(ControlFlowGraph cfg);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.MapAbstractDomain`2 : AbstractAnalysisDomain`1<DictionaryAnalysisData`2<TKey, TValue>> {
    [CompilerGeneratedAttribute]
private AbstractValueDomain`1<TValue> <ValueDomain>k__BackingField;
    protected AbstractValueDomain`1<TValue> ValueDomain { get; }
    public MapAbstractDomain`2(AbstractValueDomain`1<TValue> valueDomain);
    [CompilerGeneratedAttribute]
protected AbstractValueDomain`1<TValue> get_ValueDomain();
    public virtual DictionaryAnalysisData`2<TKey, TValue> Clone(DictionaryAnalysisData`2<TKey, TValue> value);
    public sealed virtual int Compare(DictionaryAnalysisData`2<TKey, TValue> oldValue, DictionaryAnalysisData`2<TKey, TValue> newValue);
    public sealed virtual bool Equals(DictionaryAnalysisData`2<TKey, TValue> value1, DictionaryAnalysisData`2<TKey, TValue> value2);
    private int Compare(DictionaryAnalysisData`2<TKey, TValue> oldValue, DictionaryAnalysisData`2<TKey, TValue> newValue, bool assertMonotonicity);
    [ConditionalAttribute("DEBUG")]
private static void FireNonMonotonicAssertIfNeeded(bool assertMonotonicity);
    public virtual DictionaryAnalysisData`2<TKey, TValue> Merge(DictionaryAnalysisData`2<TKey, TValue> value1, DictionaryAnalysisData`2<TKey, TValue> value2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.DefaultPointsToValueGenerator : object {
    private TrackedEntitiesBuilder _trackedEntitiesBuilder;
    private Builder<AnalysisEntity, PointsToAbstractValue> _defaultPointsToValueMapBuilder;
    public bool HasAnyTrackedEntity { get; }
    public DefaultPointsToValueGenerator(TrackedEntitiesBuilder trackedEntitiesBuilder);
    public PointsToAbstractValue GetOrCreateDefaultValue(AnalysisEntity analysisEntity);
    public bool IsTrackedEntity(AnalysisEntity analysisEntity);
    public bool IsTrackedPointsToValue(PointsToAbstractValue value);
    public void AddTrackedPointsToValue(PointsToAbstractValue value);
    public bool get_HasAnyTrackedEntity();
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.NullAbstractValue : Enum {
    public int value__;
    public static NullAbstractValue Invalid;
    public static NullAbstractValue Undefined;
    public static NullAbstractValue Null;
    public static NullAbstractValue NotNull;
    public static NullAbstractValue MaybeNull;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValue : CacheBasedEquatable`1<PointsToAbstractValue> {
    private static int LocationThreshold;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <Undefined>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <Invalid>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <Unknown>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <UnknownNull>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <UnknownNotNull>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <NoLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private static PointsToAbstractValue <NullLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<AbstractLocation> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IOperation> <LValueCapturedOperations>k__BackingField;
    [CompilerGeneratedAttribute]
private PointsToAbstractValueKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private NullAbstractValue <NullState>k__BackingField;
    public static PointsToAbstractValue Undefined { get; }
    public static PointsToAbstractValue Invalid { get; }
    public static PointsToAbstractValue Unknown { get; }
    public static PointsToAbstractValue UnknownNull { get; }
    public static PointsToAbstractValue UnknownNotNull { get; }
    public static PointsToAbstractValue NoLocation { get; }
    public static PointsToAbstractValue NullLocation { get; }
    public ImmutableHashSet`1<AbstractLocation> Locations { get; }
    public ImmutableHashSet`1<IOperation> LValueCapturedOperations { get; }
    public PointsToAbstractValueKind Kind { get; }
    public NullAbstractValue NullState { get; }
    private PointsToAbstractValue(ImmutableHashSet`1<AbstractLocation> locations, NullAbstractValue nullState);
    private PointsToAbstractValue(ImmutableHashSet`1<IOperation> lValueCapturedOperations);
    private PointsToAbstractValue(PointsToAbstractValueKind kind, NullAbstractValue nullState);
    private static PointsToAbstractValue();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_Undefined();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_Invalid();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_Unknown();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_UnknownNull();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_UnknownNotNull();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_NoLocation();
    [CompilerGeneratedAttribute]
public static PointsToAbstractValue get_NullLocation();
    internal static PointsToAbstractValue Create(AbstractLocation location, bool mayBeNull);
    internal static PointsToAbstractValue Create(IOperation lValueCapturedOperation);
    internal static PointsToAbstractValue Create(ImmutableHashSet`1<AbstractLocation> locations, NullAbstractValue nullState);
    internal static PointsToAbstractValue Create(ImmutableHashSet`1<IOperation> lValueCapturedOperations);
    internal PointsToAbstractValue MakeNonNull();
    internal PointsToAbstractValue MakeNull();
    internal PointsToAbstractValue MakeMayBeNull();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<AbstractLocation> get_Locations();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<IOperation> get_LValueCapturedOperations();
    [CompilerGeneratedAttribute]
public PointsToAbstractValueKind get_Kind();
    [CompilerGeneratedAttribute]
public NullAbstractValue get_NullState();
    protected virtual void ComputeHashCodeParts(Action`1<int> addPart);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAbstractValueKind : Enum {
    public int value__;
    public static PointsToAbstractValueKind Invalid;
    public static PointsToAbstractValueKind Undefined;
    public static PointsToAbstractValueKind KnownLocations;
    public static PointsToAbstractValueKind KnownLValueCaptures;
    public static PointsToAbstractValueKind UnknownNull;
    public static PointsToAbstractValueKind UnknownNotNull;
    public static PointsToAbstractValueKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysis : ForwardDataFlowAnalysis`5<PointsToAnalysisData, PointsToAnalysisContext, PointsToAnalysisResult, PointsToBlockAnalysisResult, PointsToAbstractValue> {
    internal static AbstractValueDomain`1<PointsToAbstractValue> PointsToAbstractValueDomainInstance;
    private PointsToAnalysis(PointsToAnalysisDomain analysisDomain, PointsToDataFlowOperationVisitor operationVisitor);
    private static PointsToAnalysis();
    public static PointsToAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt, bool pessimisticAnalysis, bool performCopyAnalysis, bool exceptionPathsAnalysis);
    public static PointsToAnalysisResult TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, DataFlowAnalysisResult`2& copyAnalysisResultOpt, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt, bool pessimisticAnalysis, bool performCopyAnalysis, bool exceptionPathsAnalysis);
    private static PointsToAnalysisResult TryGetOrComputeResultForAnalysisContext(PointsToAnalysisContext analysisContext);
    internal static bool ShouldBeTracked(ITypeSymbol typeSymbol);
    internal static bool ShouldBeTracked(AnalysisEntity analysisEntity);
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidPointsToAnalysisData(PointsToAnalysisData data);
    protected virtual PointsToAnalysisResult ToResult(PointsToAnalysisContext analysisContext, DataFlowAnalysisResult`2<PointsToBlockAnalysisResult, PointsToAbstractValue> dataFlowAnalysisResult);
    protected virtual PointsToBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, PointsToAnalysisData blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisContext : AbstractDataFlowAnalysisContext`4<PointsToAnalysisData, PointsToAnalysisContext, PointsToAnalysisResult, PointsToAbstractValue> {
    private PointsToAnalysisContext(AbstractValueDomain`1<PointsToAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, Func`2<PointsToAnalysisContext, PointsToAnalysisResult> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraphOpt, InterproceduralAnalysisData`3<PointsToAnalysisData, PointsToAnalysisContext, PointsToAbstractValue> interproceduralAnalysisDataOpt, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    internal static PointsToAnalysisContext Create(AbstractValueDomain`1<PointsToAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, bool exceptionPathsAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, Func`2<PointsToAnalysisContext, PointsToAnalysisResult> tryGetOrComputeAnalysisResult, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    public virtual PointsToAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedControlFlowGraph, IOperation operation, PointsToAnalysisResult pointsToAnalysisResultOpt, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResultOpt, InterproceduralAnalysisData`3<PointsToAnalysisData, PointsToAnalysisContext, PointsToAbstractValue> interproceduralAnalysisData);
    protected virtual void ComputeHashCodePartsSpecific(Action`1<int> addPart);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisData : AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> {
    internal PointsToAnalysisData(IDictionary`2<AnalysisEntity, PointsToAbstractValue> fromData);
    internal PointsToAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, PointsToAbstractValue> mergedCoreAnalysisData, PredicatedAnalysisData`2<AnalysisEntity, PointsToAbstractValue> predicatedData1, PredicatedAnalysisData`2<AnalysisEntity, PointsToAbstractValue> predicatedData2, bool isReachableData, MapAbstractDomain`2<AnalysisEntity, PointsToAbstractValue> coreDataAnalysisDomain);
    private PointsToAnalysisData(PointsToAnalysisData fromData);
    private PointsToAnalysisData(PointsToAnalysisData data1, PointsToAnalysisData data2, MapAbstractDomain`2<AnalysisEntity, PointsToAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> Clone();
    public virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> other, MapAbstractDomain`2<AnalysisEntity, PointsToAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<PointsToAbstractValue> data, MapAbstractDomain`2<AnalysisEntity, PointsToAbstractValue> coreDataAnalysisDomain);
    public virtual void SetAbstractValue(AnalysisEntity key, PointsToAbstractValue value);
    public virtual void Reset(Func`3<AnalysisEntity, PointsToAbstractValue, PointsToAbstractValue> getResetValue);
    [ConditionalAttribute("DEBUG")]
internal void AssertNoFlowCaptureEntitiesTracked();
    [ConditionalAttribute("DEBUG")]
private static void AssertNoFlowCaptureEntitiesTracked(DictionaryAnalysisData`2<AnalysisEntity, PointsToAbstractValue> map);
    [ConditionalAttribute("DEBUG")]
internal void AssertValidPointsToAnalysisData();
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidPointsToAnalysisData(IDictionary`2<AnalysisEntity, PointsToAbstractValue> map);
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidPointsToAnalysisKeyValuePair(AnalysisEntity key, PointsToAbstractValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToAnalysisResult : DataFlowAnalysisResult`2<PointsToBlockAnalysisResult, PointsToAbstractValue> {
    private ImmutableDictionary`2<IOperation, ImmutableHashSet`1<AbstractLocation>> _escapedLocationsThroughOperationsMap;
    private ImmutableDictionary`2<IOperation, ImmutableHashSet`1<AbstractLocation>> _escapedLocationsThroughReturnValuesMap;
    private ImmutableDictionary`2<AnalysisEntity, ImmutableHashSet`1<AbstractLocation>> _escapedLocationsThroughEntitiesMap;
    private ImmutableHashSet`1<AnalysisEntity> _trackedEntities;
    private ImmutableHashSet`1<PointsToAbstractValue> _trackedPointsToValues;
    internal PointsToAnalysisResult(DataFlowAnalysisResult`2<PointsToBlockAnalysisResult, PointsToAbstractValue> corePointsToAnalysisResult, ImmutableDictionary`2<IOperation, ImmutableHashSet`1<AbstractLocation>> escapedLocationsThroughOperationsMap, ImmutableDictionary`2<IOperation, ImmutableHashSet`1<AbstractLocation>> escapedLocationsThroughReturnValuesMap, ImmutableDictionary`2<AnalysisEntity, ImmutableHashSet`1<AbstractLocation>> escapedLocationsThroughEntitiesMap, TrackedEntitiesBuilder trackedEntitiesAndPointsToValuesBuilder);
    public ImmutableHashSet`1<AbstractLocation> GetEscapedAbstractLocations(IOperation operation);
    public ImmutableHashSet`1<AbstractLocation> GetEscapedAbstractLocations(AnalysisEntity analysisEntity);
    private static ImmutableHashSet`1<AbstractLocation> GetEscapedAbstractLocations(TKey key, ImmutableDictionary`2<TKey, ImmutableHashSet`1<AbstractLocation>> map);
    internal bool IsTrackedEntity(AnalysisEntity analysisEntity);
    internal bool IsTrackedPointsToValue(PointsToAbstractValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.PointsToBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, PointsToAbstractValue> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReachable>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, PointsToAbstractValue> Data { get; }
    public bool IsReachable { get; }
    internal PointsToBlockAnalysisResult(BasicBlock basicBlock, PointsToAnalysisData blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, PointsToAbstractValue> get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PointsToAnalysis.TrackedEntitiesBuilder : object {
    [CompilerGeneratedAttribute]
private PooledHashSet`1<AnalysisEntity> <AllEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private PooledHashSet`1<PointsToAbstractValue> <PointsToValues>k__BackingField;
    private PooledHashSet`1<AnalysisEntity> AllEntities { get; }
    private PooledHashSet`1<PointsToAbstractValue> PointsToValues { get; }
    [CompilerGeneratedAttribute]
private PooledHashSet`1<AnalysisEntity> get_AllEntities();
    [CompilerGeneratedAttribute]
private PooledHashSet`1<PointsToAbstractValue> get_PointsToValues();
    public sealed virtual void Dispose();
    public void AddEntityAndPointsToValue(AnalysisEntity analysisEntity, PointsToAbstractValue value);
    public void AddTrackedPointsToValue(PointsToAbstractValue value);
    public IEnumerable`1<AnalysisEntity> EnumerateEntities();
    public bool IsTrackedPointsToValue(PointsToAbstractValue value);
    public ValueTuple`2<ImmutableHashSet`1<AnalysisEntity>, ImmutableHashSet`1<PointsToAbstractValue>> ToImmutable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisData`2 : AbstractAnalysisData {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> _lazyPredicateDataMap;
    [CompilerGeneratedAttribute]
private bool <IsReachableBlockData>k__BackingField;
    public bool IsReachableBlockData { get; public set; }
    public bool HasPredicatedData { get; }
    protected PredicatedAnalysisData`2(PredicatedAnalysisData`2<TKey, TValue> fromData);
    protected PredicatedAnalysisData`2(PredicatedAnalysisData`2<TKey, TValue> predicatedData1, PredicatedAnalysisData`2<TKey, TValue> predicatedData2, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData1, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData2, bool isReachableData, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain);
    [CompilerGeneratedAttribute]
public bool get_IsReachableBlockData();
    [CompilerGeneratedAttribute]
public void set_IsReachableBlockData(bool value);
    public bool get_HasPredicatedData();
    [ConditionalAttribute("DEBUG")]
private void AssertValidAnalysisData();
    private void EnsurePredicatedData();
    protected void StartTrackingPredicatedData(AnalysisEntity predicatedEntity, DictionaryAnalysisData`2<TKey, TValue> truePredicatedData, DictionaryAnalysisData`2<TKey, TValue> falsePredicatedData);
    public void StopTrackingPredicatedData(AnalysisEntity predicatedEntity);
    public bool HasPredicatedDataForEntity(AnalysisEntity predicatedEntity);
    public void TransferPredicatedData(AnalysisEntity fromEntity, AnalysisEntity toEntity);
    protected PredicateValueKind ApplyPredicatedDataForEntity(DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData, AnalysisEntity predicatedEntity, bool trueData);
    protected virtual void ApplyPredicatedData(DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData, DictionaryAnalysisData`2<TKey, TValue> predicatedData);
    protected void RemoveEntriesInPredicatedData(TKey key);
    protected virtual void RemoveEntryInPredicatedData(TKey key, DictionaryAnalysisData`2<TKey, TValue> predicatedData);
    private static DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> Clone(DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> fromData);
    private static DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> Merge(DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData1, DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData2, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData1, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData2, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain, Action`2<DictionaryAnalysisData`2<TKey, TValue>, DictionaryAnalysisData`2<TKey, TValue>> applyPredicatedData);
    private static DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> MergeForPredicatedDataInOneBranch(DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisDataForOtherBranch, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain);
    private static DictionaryAnalysisData`2<TKey, TValue> MergeForPredicatedDataInOneBranch(DictionaryAnalysisData`2<TKey, TValue> predicatedData, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisDataForOtherBranch, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain);
    private static DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> MergeForPredicatedDataInBothBranches(DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData1, DictionaryAnalysisData`2<AnalysisEntity, PerEntityPredicatedAnalysisData<TKey, TValue>> predicatedData2, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData1, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData2, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain, Action`2<DictionaryAnalysisData`2<TKey, TValue>, DictionaryAnalysisData`2<TKey, TValue>> applyPredicatedData);
    private static DictionaryAnalysisData`2<TKey, TValue> Merge(DictionaryAnalysisData`2<TKey, TValue> predicateTrueOrFalseData1, DictionaryAnalysisData`2<TKey, TValue> predicateTrueOrFalseData2, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData1, DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData2, MapAbstractDomain`2<TKey, TValue> coreDataAnalysisDomain, Action`2<DictionaryAnalysisData`2<TKey, TValue>, DictionaryAnalysisData`2<TKey, TValue>> applyPredicatedData);
    private static DictionaryAnalysisData`2<TKey, TValue> CloneAndApplyPredicatedData(DictionaryAnalysisData`2<TKey, TValue> coreAnalysisData, DictionaryAnalysisData`2<TKey, TValue> predicateTrueOrFalseData, Action`2<DictionaryAnalysisData`2<TKey, TValue>, DictionaryAnalysisData`2<TKey, TValue>> applyPredicatedData);
    protected int BaseCompareHelper(PredicatedAnalysisData`2<TKey, TValue> newData);
    protected bool Equals(PredicatedAnalysisData`2<TKey, TValue> other);
    protected static bool EqualsHelper(DictionaryAnalysisData`2<TKey, TValue> dict1, DictionaryAnalysisData`2<TKey, TValue> dict2);
    protected void ResetPredicatedData();
    [ConditionalAttribute("DEBUG")]
protected void AssertValidPredicatedAnalysisData(Action`1<DictionaryAnalysisData`2<TKey, TValue>> assertValidAnalysisData);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicatedAnalysisDataDomain`2 : AbstractAnalysisDomain`1<TAnalysisData> {
    [CompilerGeneratedAttribute]
private MapAbstractDomain`2<AnalysisEntity, TValue> <CoreDataAnalysisDomain>k__BackingField;
    protected MapAbstractDomain`2<AnalysisEntity, TValue> CoreDataAnalysisDomain { get; }
    public PredicatedAnalysisDataDomain`2(MapAbstractDomain`2<AnalysisEntity, TValue> coreDataAnalysisDomain);
    [CompilerGeneratedAttribute]
protected MapAbstractDomain`2<AnalysisEntity, TValue> get_CoreDataAnalysisDomain();
    public virtual TAnalysisData Clone(TAnalysisData value);
    public virtual int Compare(TAnalysisData oldValue, TAnalysisData newValue);
    public virtual bool Equals(TAnalysisData value1, TAnalysisData value2);
    public virtual TAnalysisData Merge(TAnalysisData value1, TAnalysisData value2);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.PredicateValueKind : Enum {
    public int value__;
    public static PredicateValueKind AlwaysTrue;
    public static PredicateValueKind AlwaysFalse;
    public static PredicateValueKind Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.SetAbstractDomain`1 : AbstractDomain`1<ImmutableHashSet`1<T>> {
    [CompilerGeneratedAttribute]
private static SetAbstractDomain`1<T> <Default>k__BackingField;
    public static SetAbstractDomain`1<T> Default { get; }
    public ImmutableHashSet`1<T> Bottom { get; }
    private static SetAbstractDomain`1();
    [CompilerGeneratedAttribute]
public static SetAbstractDomain`1<T> get_Default();
    public virtual ImmutableHashSet`1<T> get_Bottom();
    public virtual int Compare(ImmutableHashSet`1<T> oldValue, ImmutableHashSet`1<T> newValue, bool assertMonotonicity);
    public virtual ImmutableHashSet`1<T> Merge(ImmutableHashSet`1<T> value1, ImmutableHashSet`1<T> value2);
    public ImmutableHashSet`1<T> Intersect(ImmutableHashSet`1<T> value1, ImmutableHashSet`1<T> value2);
    private static ImmutableHashSet`1<T> MergeOrIntersect(ImmutableHashSet`1<T> value1, ImmutableHashSet`1<T> value2, bool merge);
}
internal static class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.StackGuard : object {
    public static int MaxUncheckedRecursionDepth;
    public static void EnsureSufficientExecutionStack(int recursionDepth);
    [NullableContextAttribute("1")]
public static bool IsInsufficientExecutionStackException(Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ThrownExceptionInfo : object {
    [CompilerGeneratedAttribute]
private int <BasicBlockOrdinal>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ControlFlowRegion <HandlingCatchRegionOpt>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ControlFlowRegion <ContainingFinallyRegionOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableStack`1<IOperation> <InterproceduralCallStack>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultExceptionForExceptionsPathAnalysis>k__BackingField;
    internal int BasicBlockOrdinal { get; }
    [NullableAttribute("2")]
internal ControlFlowRegion HandlingCatchRegionOpt { get; }
    [NullableAttribute("2")]
internal ControlFlowRegion ContainingFinallyRegionOpt { get; }
    internal INamedTypeSymbol ExceptionType { get; }
    internal ImmutableStack`1<IOperation> InterproceduralCallStack { get; }
    internal bool IsDefaultExceptionForExceptionsPathAnalysis { get; }
    private ThrownExceptionInfo(BasicBlock block, INamedTypeSymbol exceptionType, ImmutableStack`1<IOperation> interproceduralCallStackOpt, bool isDefaultExceptionForExceptionsPathAnalysis);
    internal static ThrownExceptionInfo Create(BasicBlock block, INamedTypeSymbol exceptionType, ImmutableStack`1<IOperation> interproceduralCallStackOpt);
    internal static ThrownExceptionInfo CreateDefaultInfoForExceptionsPathAnalysis(BasicBlock block, WellKnownTypeProvider wellKnownTypeProvider, ImmutableStack`1<IOperation> interproceduralCallStackOpt);
    private static ControlFlowRegion GetHandlerRegion(BasicBlock block, INamedTypeSymbol exceptionType);
    internal ThrownExceptionInfo With(BasicBlock block, ImmutableStack`1<IOperation> interproceduralCallStackOpt);
    [CompilerGeneratedAttribute]
internal int get_BasicBlockOrdinal();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ControlFlowRegion get_HandlingCatchRegionOpt();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ControlFlowRegion get_ContainingFinallyRegionOpt();
    [CompilerGeneratedAttribute]
internal INamedTypeSymbol get_ExceptionType();
    [CompilerGeneratedAttribute]
internal ImmutableStack`1<IOperation> get_InterproceduralCallStack();
    [CompilerGeneratedAttribute]
internal bool get_IsDefaultExceptionForExceptionsPathAnalysis();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ThrownExceptionInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContainsNonLiteralState : Enum {
    public int value__;
    public static ValueContainsNonLiteralState Invalid;
    public static ValueContainsNonLiteralState Undefined;
    public static ValueContainsNonLiteralState No;
    public static ValueContainsNonLiteralState Maybe;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAbstractValue : CacheBasedEquatable`1<ValueContentAbstractValue> {
    private static int LiteralsBound;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <UndefinedState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <InvalidState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <MayBeContainsNonLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <DoesNotContainLiteralOrNonLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsNullLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsEmptyStringLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsZeroIntergralLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsOneIntergralLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsTrueLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue <ContainsFalseLiteralState>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueContainsNonLiteralState <NonLiteralState>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableHashSet`1<object> <LiteralValues>k__BackingField;
    public static ValueContentAbstractValue UndefinedState { get; }
    public static ValueContentAbstractValue InvalidState { get; }
    public static ValueContentAbstractValue MayBeContainsNonLiteralState { get; }
    public static ValueContentAbstractValue DoesNotContainLiteralOrNonLiteralState { get; }
    public static ValueContentAbstractValue ContainsNullLiteralState { get; }
    public static ValueContentAbstractValue ContainsEmptyStringLiteralState { get; }
    public static ValueContentAbstractValue ContainsZeroIntergralLiteralState { get; }
    public static ValueContentAbstractValue ContainsOneIntergralLiteralState { get; }
    private static ValueContentAbstractValue ContainsTrueLiteralState { get; }
    private static ValueContentAbstractValue ContainsFalseLiteralState { get; }
    public ValueContainsNonLiteralState NonLiteralState { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableHashSet`1<object> LiteralValues { get; }
    public bool IsLiteralState { get; }
    private ValueContentAbstractValue(ImmutableHashSet`1<object> literalValues, ValueContainsNonLiteralState nonLiteralState);
    private static ValueContentAbstractValue();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_UndefinedState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_InvalidState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_MayBeContainsNonLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_DoesNotContainLiteralOrNonLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_ContainsNullLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_ContainsEmptyStringLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_ContainsZeroIntergralLiteralState();
    [CompilerGeneratedAttribute]
public static ValueContentAbstractValue get_ContainsOneIntergralLiteralState();
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue get_ContainsTrueLiteralState();
    [CompilerGeneratedAttribute]
private static ValueContentAbstractValue get_ContainsFalseLiteralState();
    internal static ValueContentAbstractValue Create(object literal, ITypeSymbol type);
    private static ValueContentAbstractValue Create(ImmutableHashSet`1<object> literalValues, ValueContainsNonLiteralState nonLiteralState);
    internal static bool IsSupportedType(ITypeSymbol type, ITypeSymbol& valueTypeSymbol);
    [CompilerGeneratedAttribute]
public ValueContainsNonLiteralState get_NonLiteralState();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<object> get_LiteralValues();
    protected virtual void ComputeHashCodeParts(Action`1<int> addPart);
    internal ValueContentAbstractValue Merge(ValueContentAbstractValue otherState);
    private static ValueContainsNonLiteralState Merge(ValueContainsNonLiteralState value1, ValueContainsNonLiteralState value2);
    public bool get_IsLiteralState();
    public bool TryGetSingleNonNullLiteral(T& literalValue);
    internal ValueContentAbstractValue IntersectLiteralValues(ValueContentAbstractValue value2);
    internal ValueContentAbstractValue MergeBinaryOperation(ValueContentAbstractValue otherState, BinaryOperatorKind binaryOperatorKind, ITypeSymbol leftType, ITypeSymbol rightType, ITypeSymbol resultType);
    public virtual string ToString();
    private static bool TryMerge(object value1, object value2, BinaryOperatorKind binaryOperatorKind, ITypeSymbol type1, ITypeSymbol type2, ITypeSymbol resultType, Object& result);
    [NullableContextAttribute("2")]
private static bool TryMerge(char value1, char value2, BinaryOperatorKind binaryOperatorKind, Object& result);
    private static bool TryMerge(string value1, string value2, BinaryOperatorKind binaryOperatorKind, Object& result);
    [NullableContextAttribute("2")]
private static bool TryMerge(bool value1, bool value2, BinaryOperatorKind binaryOperatorKind, Object& result);
    private static bool TryMerge(ulong value1, ulong value2, BinaryOperatorKind binaryOperatorKind, UInt64& result);
    private static bool TryMerge(double value1, double value2, BinaryOperatorKind binaryOperatorKind, Double& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysis : ForwardDataFlowAnalysis`5<ValueContentAnalysisData, ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>, ValueContentBlockAnalysisResult, ValueContentAbstractValue> {
    private ValueContentAnalysis(ValueContentAnalysisDomain analysisDomain, ValueContentDataFlowOperationVisitor operationVisitor);
    public static DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, CancellationToken cancellationToken, InterproceduralAnalysisKind interproceduralAnalysisKind, bool pessimisticAnalysis, bool performPointsToAnalysis);
    public static DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, WellKnownTypeProvider wellKnownTypeProvider, AnalyzerOptions analyzerOptions, DiagnosticDescriptor rule, CancellationToken cancellationToken, DataFlowAnalysisResult`2& copyAnalysisResultOpt, PointsToAnalysisResult& pointsToAnalysisResultOpt, InterproceduralAnalysisKind interproceduralAnalysisKind, bool pessimisticAnalysis, bool performPointsToAnalysis, bool performCopyAnalysisIfNotUserConfigured, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    internal static DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> TryGetOrComputeResult(ControlFlowGraph cfg, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, WellKnownTypeProvider wellKnownTypeProvider, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, DataFlowAnalysisResult`2& copyAnalysisResultOpt, PointsToAnalysisResult& pointsToAnalysisResultOpt, bool pessimisticAnalysis, bool performPointsToAnalysis, bool performCopyAnalysis, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    private static DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> TryGetOrComputeResultForAnalysisContext(ValueContentAnalysisContext analysisContext);
    protected virtual DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> ToResult(ValueContentAnalysisContext analysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> dataFlowAnalysisResult);
    protected virtual ValueContentBlockAnalysisResult ToBlockResult(BasicBlock basicBlock, ValueContentAnalysisData blockAnalysisData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysisContext : AbstractDataFlowAnalysisContext`4<ValueContentAnalysisData, ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>, ValueContentAbstractValue> {
    private ValueContentAnalysisContext(AbstractValueDomain`1<ValueContentAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, PointsToAnalysisResult pointsToAnalysisResultOpt, Func`2<ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>> tryGetOrComputeAnalysisResult, ControlFlowGraph parentControlFlowGraphOpt, InterproceduralAnalysisData`3<ValueContentAnalysisData, ValueContentAnalysisContext, ValueContentAbstractValue> interproceduralAnalysisDataOpt, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    internal static ValueContentAnalysisContext Create(AbstractValueDomain`1<ValueContentAbstractValue> valueDomain, WellKnownTypeProvider wellKnownTypeProvider, ControlFlowGraph controlFlowGraph, ISymbol owningSymbol, AnalyzerOptions analyzerOptions, InterproceduralAnalysisConfiguration interproceduralAnalysisConfig, bool pessimisticAnalysis, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, PointsToAnalysisResult pointsToAnalysisResultOpt, Func`2<ValueContentAnalysisContext, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue>> tryGetOrComputeAnalysisResult, InterproceduralAnalysisPredicate interproceduralAnalysisPredicateOpt);
    public virtual ValueContentAnalysisContext ForkForInterproceduralAnalysis(IMethodSymbol invokedMethod, ControlFlowGraph invokedControlFlowGraph, IOperation operation, PointsToAnalysisResult pointsToAnalysisResultOpt, DataFlowAnalysisResult`2<CopyBlockAnalysisResult, CopyAbstractValue> copyAnalysisResultOpt, DataFlowAnalysisResult`2<ValueContentBlockAnalysisResult, ValueContentAbstractValue> valueContentAnalysisResultOpt, InterproceduralAnalysisData`3<ValueContentAnalysisData, ValueContentAnalysisContext, ValueContentAbstractValue> interproceduralAnalysisData);
    protected virtual void ComputeHashCodePartsSpecific(Action`1<int> addPart);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentAnalysisData : AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> {
    internal ValueContentAnalysisData(IDictionary`2<AnalysisEntity, ValueContentAbstractValue> fromData);
    private ValueContentAnalysisData(ValueContentAnalysisData fromData);
    private ValueContentAnalysisData(ValueContentAnalysisData data1, ValueContentAnalysisData data2, MapAbstractDomain`2<AnalysisEntity, ValueContentAbstractValue> coreDataAnalysisDomain);
    internal ValueContentAnalysisData(DictionaryAnalysisData`2<AnalysisEntity, ValueContentAbstractValue> mergedCoreAnalysisData, PredicatedAnalysisData`2<AnalysisEntity, ValueContentAbstractValue> predicatedData1, PredicatedAnalysisData`2<AnalysisEntity, ValueContentAbstractValue> predicatedData2, bool isReachableData, MapAbstractDomain`2<AnalysisEntity, ValueContentAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> Clone();
    public virtual int Compare(AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> other, MapAbstractDomain`2<AnalysisEntity, ValueContentAbstractValue> coreDataAnalysisDomain);
    public virtual AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> WithMergedData(AnalysisEntityBasedPredicateAnalysisData`1<ValueContentAbstractValue> data, MapAbstractDomain`2<AnalysisEntity, ValueContentAbstractValue> coreDataAnalysisDomain);
    internal void Reset(ValueContentAbstractValue resetValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.FlowAnalysis.DataFlow.ValueContentAnalysis.ValueContentBlockAnalysisResult : AbstractBlockAnalysisResult {
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<AnalysisEntity, ValueContentAbstractValue> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReachable>k__BackingField;
    public ImmutableDictionary`2<AnalysisEntity, ValueContentAbstractValue> Data { get; }
    public bool IsReachable { get; }
    internal ValueContentBlockAnalysisResult(BasicBlock basicBlock, ValueContentAnalysisData blockAnalysisData);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<AnalysisEntity, ValueContentAbstractValue> get_Data();
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ReportDiagnosticExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToAnalyzerConfigString(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static Nullable`1<DiagnosticSeverity> ToDiagnosticSeverity(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static bool IsLessSevereThan(ReportDiagnostic current, ReportDiagnostic other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.RulesetToEditorconfig.Converter : object {
    private static string RuleSetNodeName;
    private static string RuleSetNameAttributeName;
    private static string RuleSetDescriptionAttributeName;
    private static string RulesNodeName;
    private static string RuleNodeName;
    private static string RuleIdAttributeName;
    public static void GenerateEditorconfig(string rulesetFilePath, string editorconfigFilePath);
    public static string GetEditorconfig(string rulesetFilePath);
    [CompilerGeneratedAttribute]
internal static XElement <GetEditorconfig>g__GetTopLevelRulesetNode|7_0(string rulesetFilePath);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__ProcessComments|7_1(RuleSet ruleset, HashSet`1<string> processedRulesetPaths, Dictionary`2<string, string> ruleIdToComments);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__PopulateRuleIdToComments|7_2(string rulesetFilePath, Dictionary`2<string, string> ruleIdToComments);
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__AppendComment|7_5(XComment comment, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__UpdateCurrentRuleIdPostCommentAndResetState|7_6(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static void <GetEditorconfig>g__AppendComment|7_3(StringBuilder builder, string comment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.WellKnownDiagnosticTagsExtensions : object {
    public static string Dataflow;
    public static String[] DataflowAndTelemetry;
    public static String[] Telemetry;
    private static WellKnownDiagnosticTagsExtensions();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Immutable.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static int Count(ImmutableArray`1<TSource> source);
    [ExtensionAttribute]
public static bool HasExactly(ImmutableArray`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasMoreThan(ImmutableArray`1<TSource> source, int count);
    [ExtensionAttribute]
public static bool HasFewerThan(ImmutableArray`1<TSource> source, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Immutable.ImmutableHashSetExtensions : object {
    [ExtensionAttribute]
public static ImmutableHashSet`1<T> AddRange(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
    [ExtensionAttribute]
public static ImmutableHashSet`1<T> IntersectSet(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
    [ExtensionAttribute]
public static bool IsSubsetOfSet(ImmutableHashSet`1<T> set1, ImmutableHashSet`1<T> set2);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
