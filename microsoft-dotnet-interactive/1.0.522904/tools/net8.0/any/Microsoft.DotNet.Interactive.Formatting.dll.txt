[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.CSharp.TypeExtensions : object {
    [ExtensionAttribute]
public static void WriteCSharpDeclarationTo(Type type, TextWriter writer, bool excludeNamespace);
}
internal class Microsoft.DotNet.Interactive.Formatting.AnonymousTypeFormatter`1 : TypeFormatter`1<T> {
    private FormatDelegate`1<T> _format;
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    public string MimeType { get; }
    public AnonymousTypeFormatter`1(FormatDelegate`1<T> format, string mimeType, Type type);
    public virtual bool Format(T instance, FormatContext context);
    [CompilerGeneratedAttribute]
public virtual string get_MimeType();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Formatting.Csv.CsvFormatter : object {
    public static string MimeType;
    internal static ITypeFormatter[] DefaultFormatters;
    internal static FormatterMapByType FormattersForAnyEnumerable;
    private static CsvFormatter();
    public static ITypeFormatter GetPreferredFormatterFor(Type type);
    public static ITypeFormatter`1<T> GetPreferredFormatterFor();
    [ExtensionAttribute]
internal static string EscapeCsvValue(string value);
    [CompilerGeneratedAttribute]
internal static bool <EscapeCsvValue>g__ShouldBeWrappedInQuotes|5_0(<>c__DisplayClass5_0& );
}
public class Microsoft.DotNet.Interactive.Formatting.Csv.CsvFormatter`1 : TypeFormatter`1<T> {
    private FormatDelegate`1<T> _format;
    public string MimeType { get; }
    public CsvFormatter`1(FormatDelegate`1<T> format);
    public virtual bool Format(T value, FormatContext context);
    public virtual string get_MimeType();
    internal static CsvFormatter`1<T> Create();
    internal static bool BuildTable(T value, Func`2<T, IEnumerable> getHeaderValues, Func`2<T, IEnumerable> getRowValues, FormatContext context);
}
public class Microsoft.DotNet.Interactive.Formatting.DataDictionaryConverter : JsonConverter`1<IDictionary`2<string, object>> {
    public virtual IDictionary`2<string, object> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private static object GetValue(Utf8JsonReader& reader, JsonSerializerOptions options);
    private static object ParseArray(Utf8JsonReader& reader, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
internal static object <GetValue>g__GetNumber|1_0(Utf8JsonReader& reader);
}
public static class Microsoft.DotNet.Interactive.Formatting.Destructurer : object {
    private static ConcurrentDictionary`2<Type, IDestructurer> _cache;
    private static Destructurer();
    private static void InitializeCache();
    public static IDestructurer GetOrCreate(Type type);
}
public class Microsoft.DotNet.Interactive.Formatting.Destructurer`1 : object {
    private static object _lockObj;
    private static IDictionary`2<string, Func`2<T, object>> _getters;
    internal IDictionary`2<string, Func`2<T, object>> _instanceGetters;
    public ICollection`1<string> Keys { get; }
    private static Destructurer`1();
    public sealed virtual ICollection`1<string> get_Keys();
    private static void EnsureInitialized();
    public object GetValue(T instance, string propertyName);
    public sealed virtual IDictionary`2<string, object> Destructure(T instance);
    private sealed virtual override IDictionary`2<string, object> Microsoft.DotNet.Interactive.Formatting.IDestructurer.Destructure(object instance);
    public static Destructurer`1<T> GetOrCreate();
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Formatting.EnumerableExtensions : object {
    [ExtensionAttribute]
public static ValueTuple`2<IReadOnlyList`1<T>, Nullable`1<int>> TakeAndCountRemaining(IEnumerable`1<T> source, int count, bool forceCountRemainder);
}
public class Microsoft.DotNet.Interactive.Formatting.FormatContext : object {
    private Dictionary`2<string, Action`1<FormatContext>> _requiredContent;
    private bool _disableRecursion;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TableDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStartingObjectWithinSequence>k__BackingField;
    public int Depth { get; private set; }
    internal int TableDepth { get; private set; }
    public TextWriter Writer { get; }
    internal bool AllowRecursion { get; }
    internal bool IsStartingObjectWithinSequence { get; internal set; }
    public FormatContext(TextWriter writer);
    [CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
private void set_Depth(int value);
    [CompilerGeneratedAttribute]
internal int get_TableDepth();
    [CompilerGeneratedAttribute]
private void set_TableDepth(int value);
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    internal void RequireOnComplete(string id, IHtmlContent content);
    internal IDisposable IncrementDepth();
    internal IDisposable IncrementTableDepth();
    internal bool get_AllowRecursion();
    internal bool DisableRecursion();
    internal bool EnableRecursion();
    [CompilerGeneratedAttribute]
internal bool get_IsStartingObjectWithinSequence();
    [CompilerGeneratedAttribute]
internal void set_IsStartingObjectWithinSequence(bool value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <IncrementDepth>b__15_0();
    [CompilerGeneratedAttribute]
private void <IncrementTableDepth>b__16_0();
}
public class Microsoft.DotNet.Interactive.Formatting.FormatDelegate`1 : MulticastDelegate {
    public FormatDelegate`1(object object, IntPtr method);
    public virtual bool Invoke(T value, FormatContext context);
    public virtual IAsyncResult BeginInvoke(T value, FormatContext context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Formatting.Formatter : object {
    private static int _defaultListExpansionLimit;
    private static int _recursionLimit;
    private static string _defaultMimeType;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentStack`1<ValueTuple`2<Type, HashSet`1<string>>> _preferredMimeTypes;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentStack`1<ValueTuple`2<Type, string>> _defaultPreferredMimeTypes;
    internal static ConcurrentStack`1<ITypeFormatter> _userTypeFormatters;
    internal static ConcurrentStack`1<ITypeFormatter> _defaultTypeFormatters;
    internal static ConcurrentDictionary`2<Type, bool> _typesThatHaveBeenCheckedForFormatters;
    private static ConcurrentDictionary`2<Type, HashSet`1<string>> _preferredMimeTypesTable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`2<Type, string>, ITypeFormatter> _typeFormattersTable;
    private static ConcurrentDictionary`2<Type, Action`3<FormatContext, object, string>> _genericFormattersTable;
    [CompilerGeneratedAttribute]
private static string <NullString>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action Clearing;
    internal static MethodInfo FormatReadOnlyMemoryMethod;
    public static int ListExpansionLimit { get; public set; }
    public static string NullString { get; public set; }
    public static int RecursionLimit { get; public set; }
    public static string DefaultMimeType { get; public set; }
    private static Formatter();
    internal static TextWriter CreateWriter();
    public static int get_ListExpansionLimit();
    public static void set_ListExpansionLimit(int value);
    [CompilerGeneratedAttribute]
public static string get_NullString();
    [CompilerGeneratedAttribute]
public static void set_NullString(string value);
    public static int get_RecursionLimit();
    public static void set_RecursionLimit(int value);
    [CompilerGeneratedAttribute]
internal static void add_Clearing(Action value);
    [CompilerGeneratedAttribute]
internal static void remove_Clearing(Action value);
    public static void ResetToDefault();
    internal static void ClearComputedState();
    public static void SetPreferredMimeTypesFor(Type type, String[] preferredMimeTypes);
    public static string get_DefaultMimeType();
    public static void set_DefaultMimeType(string value);
    public static IReadOnlyCollection`1<string> GetPreferredMimeTypesFor(Type type);
    private static string TryFindPreferredMimeType(Type type, IEnumerable`1<ValueTuple`2<Type, string>> mimeTypes);
    private static HashSet`1<string> TryFindPreferredMimeTypes(Type type, IEnumerable`1<ValueTuple`2<Type, HashSet`1<string>>> mimeTypes);
    private static HashSet`1<string> FindPreferredMimeTypes(Type type);
    [ExtensionAttribute]
public static string ToDisplayString(object obj, string mimeType);
    [ExtensionAttribute]
public static string ToDisplayString(object obj, ITypeFormatter formatter);
    [ExtensionAttribute]
public static void Format(ITypeFormatter formatter, object instance, TextWriter writer);
    [ExtensionAttribute]
public static void FormatTo(T obj, FormatContext context, string mimeType);
    [ExtensionAttribute]
internal static Action`3<FormatContext, object, string> GetGenericFormatterMethod(Type type);
    public static void Register(ITypeFormatter formatter);
    public static void Register(FormatDelegate`1<T> formatter, string mimeType);
    public static void Register(Type type, FormatDelegate`1<object> formatter, string mimeType);
    public static void Register(Type type, Action`2<object, TextWriter> formatter, string mimeType);
    public static void Register(Action`2<T, TextWriter> formatter, string mimeType);
    public static void Register(Func`2<T, string> formatter, string mimeType);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Formatting.Formatter/<RegisteredFormatters>d__48")]
public static IEnumerable`1<ITypeFormatter> RegisteredFormatters(bool includeDefaults);
    public static ITypeFormatter GetPreferredFormatterFor(Type actualType, string mimeType);
    private static ITypeFormatter FindPreferredFormatter(Type actualType, string mimeType);
    private static void TryRegisterFromFormatterSources(Type type);
    internal static ITypeFormatter TryFindPreferredFormatter(Type actualType, string mimeType, IEnumerable`1<ITypeFormatter> formatters);
    private static IReadOnlyCollection`1<T> ReadOnlyMemoryToArray(ReadOnlyMemory`1<T> mem);
    private static bool TryGetPropertyValue(object fromObject, string propertyName, T& value);
    [ExtensionAttribute]
internal static bool ShouldIncludePropertiesInOutput(Type type);
    [CompilerGeneratedAttribute]
internal static bool <TryRegisterFromFormatterSources>g__TryRegisterFromWellKnownFormatterSources|51_0(TypeFormatterSourceAttribute[] customAttributes, <>c__DisplayClass51_0& );
    [CompilerGeneratedAttribute]
internal static bool <TryRegisterFromFormatterSources>g__TryRegisterFromConventionBasedFormatterSources|51_1(<>c__DisplayClass51_0& );
}
public static class Microsoft.DotNet.Interactive.Formatting.Formatter`1 : object {
    internal static bool TypeIsAnonymous;
    internal static bool TypeIsTuple;
    internal static bool TypeIsValueTuple;
    internal static bool TypeIsTupleOfScalars;
    internal static bool TypeIsScalar;
    private static Nullable`1<int> _listExpansionLimit;
    public static int ListExpansionLimit { get; public set; }
    private static Formatter`1();
    public static void FormatTo(T obj, FormatContext context, string mimeType);
    public static int get_ListExpansionLimit();
    public static void set_ListExpansionLimit(int value);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__Initialize|6_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.DotNet.Interactive.Formatting.FormatterMapByType : object {
    private ConcurrentDictionary`2<Type, ITypeFormatter> _formatters;
    private Type _genericDef;
    private string _createFormatterMethodName;
    internal FormatterMapByType(Type genericDef, string createFormatterMethodName);
    internal ITypeFormatter GetOrCreateFormatterForType(Type type);
    [CompilerGeneratedAttribute]
private ITypeFormatter <GetOrCreateFormatterForType>b__4_0(Type t);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Formatting.Html : object {
    [ExtensionAttribute]
internal static IHtmlContent EnsureHtmlAttributeEncoded(object source);
    [ExtensionAttribute]
public static IHtmlContent HtmlEncode(string content);
    [ExtensionAttribute]
public static IHtmlContent HtmlAttributeEncode(string content);
    [ExtensionAttribute]
public static IHtmlContent ToHtmlContent(string value);
    [ExtensionAttribute]
public static TTag SelfClosing(TTag tag);
    [ExtensionAttribute]
public static TTag WithAttributes(TTag tag, IDictionary`2<string, object> htmlAttributes);
    [ExtensionAttribute]
public static TTag WithAttributes(TTag tag, string name, object value);
    [ExtensionAttribute]
public static HtmlTag Tag(string tagName);
    [ExtensionAttribute]
public static TTag Append(TTag toTag, IHtmlContent content);
    [ExtensionAttribute]
public static TTag Append(TTag toTag, IHtmlContent[] contents);
    [ExtensionAttribute]
public static TTag AppendTo(TTag appendTag, HtmlTag toTag);
    [ExtensionAttribute]
public static TTag Containing(TTag tag, string text);
    [ExtensionAttribute]
public static TTag Containing(TTag tag, IHtmlContent content);
    [ExtensionAttribute]
public static TTag Prepend(TTag toTag, IHtmlContent content);
    [ExtensionAttribute]
public static TTag PrependTo(TTag prependTag, HtmlTag toTag);
    [ExtensionAttribute]
public static TTag WrapInner(TTag tag, HtmlTag wrappingTag);
    internal static PocketView Table(IReadOnlyList`1<IHtmlContent> headers, IReadOnlyList`1<IHtmlContent> rows);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.DotNet.Interactive.Formatting.HtmlAttributes : DynamicObject {
    private Dictionary`2<string, object> _attributes;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public HtmlAttributes(IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    private void InitializeFrom(IEnumerable`1<KeyValuePair`2<string, object>> attributes);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public void AddCssClass(string value);
    public void RemoveCssClass(string value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public void MergeWith(IDictionary`2<string, object> htmlAttributes, bool replace);
    public virtual string ToString();
    public sealed virtual void WriteTo(TextWriter writer, HtmlEncoder encoder);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Formatting.HtmlAttributesExtensions : object {
    [ExtensionAttribute]
public static HtmlAttributes Class(HtmlAttributes attributes, string classes);
    [ExtensionAttribute]
public static HtmlAttributes Class(HtmlAttributes attributes, string classes, bool include);
    [ExtensionAttribute]
public static HtmlAttributes Disabled(HtmlAttributes attributes, bool value);
    [ExtensionAttribute]
public static HtmlAttributes Selected(HtmlAttributes attributes, bool value);
    [ExtensionAttribute]
public static bool HasClass(HtmlAttributes attributes, string class);
    [ExtensionAttribute]
internal static HtmlAttributes Attr(HtmlAttributes htmlAttributes, string name, object value);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Formatting.HtmlFormatter : object {
    public static string MimeType;
    internal static FormatterMapByType FormattersForAnyObject;
    internal static FormatterMapByType FormattersForAnyEnumerable;
    internal static ITypeFormatter[] DefaultFormatters;
    private static Lazy`1<IHtmlContent> _defaultStyles;
    private static HtmlFormatter();
    public static ITypeFormatter GetPreferredFormatterFor(Type type);
    public static ITypeFormatter GetPreferredFormatterFor();
    internal static ITypeFormatter GetDefaultFormatterForAnyObject(Type type);
    internal static ITypeFormatter GetDefaultFormatterForAnyEnumerable(Type type);
    internal static void FormatAndStyleAsPlainText(object value, FormatContext context, string mimeType);
    internal static PocketView TagWithPlainTextStyling(object value, string mimeType);
    internal static IHtmlContent DefaultStyles();
    [ExtensionAttribute]
public static void RequireDefaultStyles(FormatContext context);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__Initialize|0_0();
}
public class Microsoft.DotNet.Interactive.Formatting.HtmlFormatter`1 : TypeFormatter`1<T> {
    private FormatDelegate`1<T> _format;
    public string MimeType { get; }
    public HtmlFormatter`1(FormatDelegate`1<T> format);
    public HtmlFormatter`1(Action`2<T, FormatContext> format);
    public HtmlFormatter`1(Func`2<T, string> format);
    public virtual bool Format(T value, FormatContext context);
    public virtual string get_MimeType();
    internal static HtmlFormatter`1<T> CreateTreeViewFormatterForAnyEnumerable();
    internal static HtmlFormatter`1<T> CreateTreeViewFormatterForAnyObject();
    [CompilerGeneratedAttribute]
internal static bool <CreateTreeViewFormatterForAnyEnumerable>g__BuildTable|7_4(T source, FormatContext context, Func`2<T, IEnumerable> getKeys, Func`2<T, IEnumerable> getValues, bool summarize);
    [CompilerGeneratedAttribute]
internal static bool <CreateTreeViewFormatterForAnyObject>g__BuildTreeView|8_3(T source, FormatContext context, ValueTuple`2[] rows);
}
public class Microsoft.DotNet.Interactive.Formatting.HtmlTag : object {
    private HtmlAttributes _htmlAttributes;
    [CompilerGeneratedAttribute]
private Action`1<FormatContext> <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSelfClosing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Action`1<FormatContext> Content { get; public set; }
    public bool IsSelfClosing { get; public set; }
    public string Name { get; public set; }
    public HtmlAttributes HtmlAttributes { get; public set; }
    public HtmlTag(string name);
    public HtmlTag(string name, string text);
    public HtmlTag(string name, IHtmlContent content);
    public HtmlTag(string name, Action`1<FormatContext> content);
    [CompilerGeneratedAttribute]
public Action`1<FormatContext> get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(Action`1<FormatContext> value);
    [CompilerGeneratedAttribute]
public bool get_IsSelfClosing();
    [CompilerGeneratedAttribute]
public void set_IsSelfClosing(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public HtmlAttributes get_HtmlAttributes();
    public void set_HtmlAttributes(HtmlAttributes value);
    public virtual void WriteTo(TextWriter writer, HtmlEncoder encoder);
    public void WriteTo(FormatContext context);
    protected void WriteSelfClosingTag(TextWriter writer);
    protected void WriteEndTag(TextWriter writer);
    protected void WriteStartTag(TextWriter writer);
    protected virtual void WriteContentsTo(FormatContext context);
    public void MergeAttributes(IDictionary`2<string, object> htmlAttributes, bool replace);
    public virtual string ToString();
}
public interface Microsoft.DotNet.Interactive.Formatting.IDestructurer {
    public ICollection`1<string> Keys { get; }
    public abstract virtual IDictionary`2<string, object> Destructure(object instance);
    public abstract virtual ICollection`1<string> get_Keys();
}
public interface Microsoft.DotNet.Interactive.Formatting.IDestructurer`1 {
    public abstract virtual IDictionary`2<string, object> Destructure(T instance);
}
public interface Microsoft.DotNet.Interactive.Formatting.ITypeFormatter {
    public string MimeType { get; }
    public Type Type { get; }
    public abstract virtual string get_MimeType();
    public abstract virtual Type get_Type();
    public abstract virtual bool Format(object instance, FormatContext context);
}
public interface Microsoft.DotNet.Interactive.Formatting.ITypeFormatter`1 {
    public abstract virtual bool Format(T instance, FormatContext context);
}
public interface Microsoft.DotNet.Interactive.Formatting.ITypeFormatterSource {
    public abstract virtual IEnumerable`1<ITypeFormatter> CreateTypeFormatters();
}
public abstract class Microsoft.DotNet.Interactive.Formatting.JsonConverter`1 : JsonConverter`1<T> {
    protected void EnsureStartObject(Utf8JsonReader reader, Type typeToConvert);
    protected void EnsureStartArray(Utf8JsonReader reader, Type typeToConvert);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    protected virtual void OnWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Formatting.JsonExtensions : object {
    [ExtensionAttribute]
public static TabularDataResource ToTabularDataResource(JsonDocument document);
    [ExtensionAttribute]
public static TabularDataResource ToTabularDataResource(JsonElement jsonElement);
    [CompilerGeneratedAttribute]
internal static object <ToTabularDataResource>g__GetNumber|1_0(JsonElement propertyValue);
}
public static class Microsoft.DotNet.Interactive.Formatting.JsonFormatter : object {
    public static string MimeType;
    [CompilerGeneratedAttribute]
private static ITypeFormatter[] <DefaultFormatters>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonSerializerOptions <SerializerOptions>k__BackingField;
    internal static ITypeFormatter[] DefaultFormatters { get; }
    public static JsonSerializerOptions SerializerOptions { get; }
    private static JsonFormatter();
    public static ITypeFormatter GetPreferredFormatterFor(Type type);
    [CompilerGeneratedAttribute]
internal static ITypeFormatter[] get_DefaultFormatters();
    [CompilerGeneratedAttribute]
public static JsonSerializerOptions get_SerializerOptions();
}
public class Microsoft.DotNet.Interactive.Formatting.JsonFormatter`1 : TypeFormatter`1<T> {
    private FormatDelegate`1<T> _format;
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    public string MimeType { get; }
    public JsonFormatter`1(FormatDelegate`1<T> format);
    public JsonFormatter`1(Action`2<T, FormatContext> format);
    public virtual bool Format(T instance, FormatContext context);
    [CompilerGeneratedAttribute]
public virtual string get_MimeType();
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__FormatInstance|2_0(T instance, FormatContext context);
}
public class Microsoft.DotNet.Interactive.Formatting.JsonString : HtmlString {
    public JsonString(string json);
}
internal class Microsoft.DotNet.Interactive.Formatting.MemberAccessor`1 : object {
    private MemberInfo _member;
    private Func`2<T, object> _getter;
    public string MemberName { get; }
    public MemberAccessor`1(MemberInfo member);
    public string get_MemberName();
    public object GetValueOrException(T instance);
}
internal class Microsoft.DotNet.Interactive.Formatting.NonDestructurer : object {
    private static ICollection`1<string> _keys;
    [CompilerGeneratedAttribute]
private static IDestructurer <Instance>k__BackingField;
    public static IDestructurer Instance { get; }
    public ICollection`1<string> Keys { get; }
    private static NonDestructurer();
    [CompilerGeneratedAttribute]
public static IDestructurer get_Instance();
    public sealed virtual IDictionary`2<string, object> Destructure(object instance);
    public sealed virtual ICollection`1<string> get_Keys();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Formatting.PlainTextFormatter : object {
    public static string MimeType;
    private static int NumberOfSpacesToIndent;
    internal static FormatterMapByType FormattersForAnyObject;
    internal static FormatterMapByType FormattersForAnyEnumerable;
    internal static ITypeFormatter[] DefaultFormatters;
    private static PlainTextFormatter();
    public static ITypeFormatter GetPreferredFormatterFor(Type type);
    public static ITypeFormatter GetPreferredFormatterFor();
    internal static ITypeFormatter GetDefaultFormatterForAnyObject(Type type, bool includeInternals);
    internal static FormatDelegate`1<T> CreateFormatDelegate(MemberInfo[] forMembers);
    [ExtensionAttribute]
private static string IndentAtNewLines(string s, FormatContext context);
    internal static void WriteIndent(FormatContext context, string bonus);
    public static void WriteStartProperty(FormatContext context);
    internal static void Join(IEnumerable list, TextWriter writer, FormatContext context);
    internal static void JoinGeneric(IEnumerable`1<T> seq, TextWriter writer, FormatContext context);
    [CompilerGeneratedAttribute]
internal static bool <CreateFormatDelegate>g__FormatUsingToString|5_1(T target, FormatContext context);
}
public class Microsoft.DotNet.Interactive.Formatting.PlainTextFormatter`1 : TypeFormatter`1<T> {
    private FormatDelegate`1<T> _format;
    public static PlainTextFormatter`1<T> Default;
    public string MimeType { get; }
    public PlainTextFormatter`1(FormatDelegate`1<T> format);
    public PlainTextFormatter`1(Action`2<T, FormatContext> format);
    public PlainTextFormatter`1(Func`2<T, string> format);
    private static PlainTextFormatter`1();
    public virtual string get_MimeType();
    public virtual bool Format(T value, FormatContext context);
    internal static PlainTextFormatter`1<T> CreateForAnyObject();
    internal static PlainTextFormatter`1<T> CreateForAnyEnumerable();
}
public static class Microsoft.DotNet.Interactive.Formatting.PlainTextSummaryFormatter : object {
    public static string MimeType;
    [CompilerGeneratedAttribute]
private static ITypeFormatter[] <DefaultFormatters>k__BackingField;
    internal static FormatterMapByType FormattersForAnyEnumerable;
    internal static ITypeFormatter[] DefaultFormatters { get; }
    private static PlainTextSummaryFormatter();
    public static ITypeFormatter GetPreferredFormatterFor(Type type);
    [CompilerGeneratedAttribute]
internal static ITypeFormatter[] get_DefaultFormatters();
    private static string Truncate(object value);
}
public class Microsoft.DotNet.Interactive.Formatting.PocketView : DynamicObject {
    private Dictionary`2<string, TagTransform> _transforms;
    private TagTransform _transform;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<string, IHtmlContent>> _dependentContent;
    [CompilerGeneratedAttribute]
private HtmlTag <HtmlTag>k__BackingField;
    public HtmlTag HtmlTag { get; }
    public HtmlAttributes HtmlAttributes { get; }
    public PocketView(PocketView nested);
    public PocketView(string tagName, PocketView nested);
    [CompilerGeneratedAttribute]
public HtmlTag get_HtmlTag();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    private void ApplyTransform(InvokeBinder binder, Object[] args, FormatContext formatContext);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] values, Object& result);
    public void AddDependency(string id, IHtmlContent content);
    public virtual void SetContent(Object[] args);
    private void Write(IReadOnlyList`1<object> args, FormatContext context);
    public virtual string ToString();
    public HtmlAttributes get_HtmlAttributes();
    public sealed virtual void WriteTo(TextWriter writer, HtmlEncoder encoder);
    public void WriteTo(FormatContext context);
    public static object Transform(Action`2<HtmlTag, object> transform);
    private object ComposeContent(IReadOnlyCollection`1<string> argumentNames, Object[] args);
}
public static class Microsoft.DotNet.Interactive.Formatting.PocketViewTags : object {
    [DynamicAttribute]
[CompilerGeneratedAttribute]
private static object <_>k__BackingField;
    [DynamicAttribute]
public static object _ { get; }
    [DynamicAttribute]
public static object a { get; }
    [DynamicAttribute]
public static object area { get; }
    [DynamicAttribute]
public static object aside { get; }
    [DynamicAttribute]
public static object b { get; }
    [DynamicAttribute]
public static object body { get; }
    [DynamicAttribute]
public static object br { get; }
    [DynamicAttribute]
public static object button { get; }
    [DynamicAttribute]
public static object caption { get; }
    [DynamicAttribute]
public static object center { get; }
    [DynamicAttribute]
public static object circle { get; }
    [DynamicAttribute]
public static object code { get; }
    [DynamicAttribute]
public static object colgroup { get; }
    [DynamicAttribute]
public static object dd { get; }
    [DynamicAttribute]
public static object details { get; }
    [DynamicAttribute]
public static object div { get; }
    [DynamicAttribute]
public static object dl { get; }
    [DynamicAttribute]
public static object dt { get; }
    [DynamicAttribute]
public static object em { get; }
    [DynamicAttribute]
public static object figure { get; }
    [DynamicAttribute]
public static object font { get; }
    [DynamicAttribute]
public static object form { get; }
    [DynamicAttribute]
public static object g { get; }
    [DynamicAttribute]
public static object h1 { get; }
    [DynamicAttribute]
public static object h2 { get; }
    [DynamicAttribute]
public static object h3 { get; }
    [DynamicAttribute]
public static object h4 { get; }
    [DynamicAttribute]
public static object h5 { get; }
    [DynamicAttribute]
public static object h6 { get; }
    [DynamicAttribute]
public static object head { get; }
    [DynamicAttribute]
public static object header { get; }
    [DynamicAttribute]
public static object hgroup { get; }
    [DynamicAttribute]
public static object hr { get; }
    [DynamicAttribute]
public static object html { get; }
    [DynamicAttribute]
public static object i { get; }
    [DynamicAttribute]
public static object iframe { get; }
    [DynamicAttribute]
public static object img { get; }
    [DynamicAttribute]
public static object input { get; }
    [DynamicAttribute]
public static object label { get; }
    [DynamicAttribute]
public static object li { get; }
    [DynamicAttribute]
public static object line { get; }
    [DynamicAttribute]
public static object link { get; }
    [DynamicAttribute]
public static object main { get; }
    [DynamicAttribute]
public static object menu { get; }
    [DynamicAttribute]
public static object menuitem { get; }
    [DynamicAttribute]
public static object meta { get; }
    [DynamicAttribute]
public static object meter { get; }
    [DynamicAttribute]
public static object nav { get; }
    [DynamicAttribute]
public static object ol { get; }
    [DynamicAttribute]
public static object optgroup { get; }
    [DynamicAttribute]
public static object option { get; }
    [DynamicAttribute]
public static object p { get; }
    [DynamicAttribute]
public static object pre { get; }
    [DynamicAttribute]
public static object progress { get; }
    [DynamicAttribute]
public static object q { get; }
    [DynamicAttribute]
public static object script { get; }
    [DynamicAttribute]
public static object section { get; }
    [DynamicAttribute]
public static object select { get; }
    [DynamicAttribute]
public static object small { get; }
    [DynamicAttribute]
public static object source { get; }
    [DynamicAttribute]
public static object span { get; }
    [DynamicAttribute]
public static object strike { get; }
    [DynamicAttribute]
public static object style { get; }
    [DynamicAttribute]
public static object strong { get; }
    [DynamicAttribute]
public static object sub { get; }
    [DynamicAttribute]
public static object summary { get; }
    [DynamicAttribute]
public static object sup { get; }
    [DynamicAttribute]
public static object svg { get; }
    [DynamicAttribute]
public static object table { get; }
    [DynamicAttribute]
public static object tbody { get; }
    [DynamicAttribute]
public static object td { get; }
    [DynamicAttribute]
public static object text { get; }
    [DynamicAttribute]
public static object textarea { get; }
    [DynamicAttribute]
public static object tfoot { get; }
    [DynamicAttribute]
public static object th { get; }
    [DynamicAttribute]
public static object thead { get; }
    [DynamicAttribute]
public static object title { get; }
    [DynamicAttribute]
public static object tr { get; }
    [DynamicAttribute]
public static object u { get; }
    [DynamicAttribute]
public static object ul { get; }
    [DynamicAttribute]
public static object video { get; }
    private static PocketViewTags();
    [CompilerGeneratedAttribute]
public static object get__();
    public static object get_a();
    public static object get_area();
    public static object get_aside();
    public static object get_b();
    public static object get_body();
    public static object get_br();
    public static object get_button();
    public static object get_caption();
    public static object get_center();
    public static object get_circle();
    public static object get_code();
    public static object get_colgroup();
    public static object get_dd();
    public static object get_details();
    public static object get_div();
    public static object get_dl();
    public static object get_dt();
    public static object get_em();
    public static object get_figure();
    public static object get_font();
    public static object get_form();
    public static object get_g();
    public static object get_h1();
    public static object get_h2();
    public static object get_h3();
    public static object get_h4();
    public static object get_h5();
    public static object get_h6();
    public static object get_head();
    public static object get_header();
    public static object get_hgroup();
    public static object get_hr();
    public static object get_html();
    public static object get_i();
    public static object get_iframe();
    public static object get_img();
    public static object get_input();
    public static object get_label();
    public static object get_li();
    public static object get_line();
    public static object get_link();
    public static object get_main();
    public static object get_menu();
    public static object get_menuitem();
    public static object get_meta();
    public static object get_meter();
    public static object get_nav();
    public static object get_ol();
    public static object get_optgroup();
    public static object get_option();
    public static object get_p();
    public static object get_pre();
    public static object get_progress();
    public static object get_q();
    public static object get_script();
    public static object get_section();
    public static object get_select();
    public static object get_small();
    public static object get_source();
    public static object get_span();
    public static object get_strike();
    public static object get_style();
    public static object get_strong();
    public static object get_sub();
    public static object get_summary();
    public static object get_sup();
    public static object get_svg();
    public static object get_table();
    public static object get_tbody();
    public static object get_td();
    public static object get_text();
    public static object get_textarea();
    public static object get_tfoot();
    public static object get_th();
    public static object get_thead();
    public static object get_title();
    public static object get_tr();
    public static object get_u();
    public static object get_ul();
    public static object get_video();
}
internal static class Microsoft.DotNet.Interactive.Formatting.TabularData.DefaultTabularDataFormatterSet : object {
    internal static ITypeFormatter[] DefaultFormatters;
    private static DefaultTabularDataFormatterSet();
}
[DefaultMemberAttribute("Item")]
[JsonConverterAttribute("Microsoft.DotNet.Interactive.Formatting.TabularData.TableDataFieldDescriptorsJsonConverter")]
public class Microsoft.DotNet.Interactive.Formatting.TabularData.TableDataFieldDescriptors : object {
    private Dictionary`2<string, TableSchemaFieldDescriptor> _descriptors;
    public TableSchemaFieldDescriptor Item { get; }
    public int Count { get; }
    public TableSchemaFieldDescriptor get_Item(string name);
    public bool Contains(string name);
    public void Add(TableSchemaFieldDescriptor descriptor);
    public sealed virtual IEnumerator`1<TableSchemaFieldDescriptor> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
internal class Microsoft.DotNet.Interactive.Formatting.TabularData.TableDataFieldDescriptorsJsonConverter : JsonConverter`1<TableDataFieldDescriptors> {
    public virtual TableDataFieldDescriptors Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TableDataFieldDescriptors value, JsonSerializerOptions options);
}
[JsonConverterAttribute("Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchemaJsonConverter")]
public class Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchema : object {
    [CompilerGeneratedAttribute]
private List`1<string> <PrimaryKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TableDataFieldDescriptors <Fields>k__BackingField;
    [JsonPropertyNameAttribute("primaryKey")]
public List`1<string> PrimaryKey { get; public set; }
    [JsonPropertyNameAttribute("fields")]
public TableDataFieldDescriptors Fields { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_PrimaryKey();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PrimaryKey(List`1<string> value);
    [CompilerGeneratedAttribute]
public TableDataFieldDescriptors get_Fields();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Fields(TableDataFieldDescriptors value);
}
[JsonConverterAttribute("Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchemaFieldDescriptorJsonConverter")]
public class Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchemaFieldDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private TableSchemaFieldType <Type>k__BackingField;
    [JsonPropertyNameAttribute("name")]
public string Name { get; }
    [JsonPropertyNameAttribute("description")]
[JsonIgnoreAttribute]
public string Description { get; }
    [JsonPropertyNameAttribute("format")]
[JsonIgnoreAttribute]
public string Format { get; }
    [JsonPropertyNameAttribute("type")]
public TableSchemaFieldType Type { get; }
    public TableSchemaFieldDescriptor(string name, Nullable`1<TableSchemaFieldType> type, string description, string format);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public TableSchemaFieldType get_Type();
}
internal class Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchemaFieldDescriptorJsonConverter : JsonConverter`1<TableSchemaFieldDescriptor> {
    public virtual TableSchemaFieldDescriptor Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TableSchemaFieldDescriptor value, JsonSerializerOptions options);
}
[JsonConverterAttribute("Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchemaFieldTypeJsonConverter")]
public enum Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchemaFieldType : Enum {
    public int value__;
    public static TableSchemaFieldType Any;
    public static TableSchemaFieldType Object;
    public static TableSchemaFieldType Null;
    public static TableSchemaFieldType Number;
    public static TableSchemaFieldType Integer;
    public static TableSchemaFieldType Boolean;
    public static TableSchemaFieldType String;
    public static TableSchemaFieldType Array;
    public static TableSchemaFieldType DateTime;
    public static TableSchemaFieldType GeoPoint;
    public static TableSchemaFieldType GeoJson;
}
internal class Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchemaFieldTypeJsonConverter : JsonConverter`1<TableSchemaFieldType> {
    public virtual TableSchemaFieldType Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TableSchemaFieldType value, JsonSerializerOptions options);
}
internal class Microsoft.DotNet.Interactive.Formatting.TabularData.TableSchemaJsonConverter : JsonConverter`1<TableSchema> {
    public virtual TableSchema Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TableSchema value, JsonSerializerOptions options);
}
internal class Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataFormatterSource : object {
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataFormatterSource/<CreateTypeFormatters>d__0")]
public sealed virtual IEnumerable`1<ITypeFormatter> CreateTypeFormatters();
    internal static void FormatHtml(FormatContext context, TabularDataResource value);
}
[TypeFormatterSourceAttribute("Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataFormatterSource")]
[JsonConverterAttribute("Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResourceJsonConverter")]
public class Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResource : object {
    [CompilerGeneratedAttribute]
private string <Profile>k__BackingField;
    [CompilerGeneratedAttribute]
private TableSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IEnumerable`1<KeyValuePair`2<string, object>>> <Data>k__BackingField;
    public string Profile { get; }
    public TableSchema Schema { get; }
    public IEnumerable`1<IEnumerable`1<KeyValuePair`2<string, object>>> Data { get; }
    public TabularDataResource(TableSchema schema, IEnumerable`1<IEnumerable`1<KeyValuePair`2<string, object>>> data, string profile);
    [CompilerGeneratedAttribute]
public string get_Profile();
    [CompilerGeneratedAttribute]
public TableSchema get_Schema();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IEnumerable`1<KeyValuePair`2<string, object>>> get_Data();
    public TabularDataResourceJsonString ToJsonString();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResourceFormatter : object {
    public static string MimeType;
    [CompilerGeneratedAttribute]
private static JsonSerializerOptions <JsonSerializerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ITypeFormatter[] <DefaultFormatters>k__BackingField;
    public static JsonSerializerOptions JsonSerializerOptions { get; }
    internal static ITypeFormatter[] DefaultFormatters { get; }
    private static TabularDataResourceFormatter();
    [CompilerGeneratedAttribute]
public static JsonSerializerOptions get_JsonSerializerOptions();
    [CompilerGeneratedAttribute]
internal static ITypeFormatter[] get_DefaultFormatters();
    [ExtensionAttribute]
public static TabularDataResource ToTabularDataResource(IEnumerable`1<T> source);
    private static ValueTuple`2<TableSchema, IEnumerable`1<IEnumerable`1<KeyValuePair`2<string, object>>>> Generate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static TableSchemaFieldType ToTableSchemaFieldType(Type type);
    [CompilerGeneratedAttribute]
internal static void <Generate>g__EnsureFieldsAreInitializedFromKeyValuePairs|9_0(IEnumerable`1<KeyValuePair`2<string, object>> keyValuePairs, <>c__DisplayClass9_0`1& );
    [CompilerGeneratedAttribute]
internal static void <Generate>g__EnsureFieldsAreInitializedFromValueTuples|9_1(IEnumerable`1<ValueTuple`2<string, object>> valueTuples, <>c__DisplayClass9_0`1& );
    [CompilerGeneratedAttribute]
internal static Nullable`1<TableSchemaFieldType> <Generate>g__InferTableSchemaFieldTypeFromValue|9_2(object value);
}
public class Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResourceFormatter`1 : TypeFormatter`1<T> {
    private FormatDelegate`1<T> _format;
    public string MimeType { get; }
    public TabularDataResourceFormatter`1(FormatDelegate`1<T> format);
    public TabularDataResourceFormatter`1(Action`2<T, FormatContext> format);
    public virtual bool Format(T value, FormatContext context);
    public virtual string get_MimeType();
}
internal class Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResourceJsonConverter : JsonConverter`1<TabularDataResource> {
    public virtual TabularDataResource Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private List`1<List`1<KeyValuePair`2<string, object>>> DeserializeData(Utf8JsonReader& reader, JsonSerializerOptions options, TableSchema tableSchema);
    private List`1<KeyValuePair`2<string, object>> DeserializeDataEntry(Utf8JsonReader& reader, JsonSerializerOptions options, TableSchema tableSchema);
    private Object[] DeserializeArray(Utf8JsonReader& reader, JsonSerializerOptions options);
    private static object GetNumber(Utf8JsonReader& reader);
    private object DeserializeStringValueValue(string stringValue, TableSchemaFieldType dataType);
    public virtual void Write(Utf8JsonWriter writer, TabularDataResource value, JsonSerializerOptions options);
}
public class Microsoft.DotNet.Interactive.Formatting.TabularData.TabularDataResourceJsonString : JsonString {
    public TabularDataResourceJsonString(string json);
    public static TabularDataResourceJsonString Create(IReadOnlyDictionary`2<string, Type> fields, IReadOnlyList`1<IDictionary`2<string, object>> data);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Formatting.TypeExtensions : object {
    private static BindingFlags BindingFlagsForFormattedMembers;
    private static HashSet`1<Type> _typesToTreatAsScalar;
    private static TypeExtensions();
    [ExtensionAttribute]
public static string MemberName(Expression`1<Func`2<T, TValue>> expression);
    [ExtensionAttribute]
public static MemberAccessor`1[] GetMemberAccessors(IEnumerable`1<MemberInfo> forMembers);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetMembersToFormat(Type type);
    [ExtensionAttribute]
public static bool IsRelevantFormatterFor(Type type, Type actualType);
    [ExtensionAttribute]
public static bool IsAnonymous(Type type);
    [ExtensionAttribute]
public static bool IsScalar(Type type);
    [ExtensionAttribute]
public static bool IsValueTuple(Type type);
    [ExtensionAttribute]
public static bool IsTuple(Type type);
    public static bool ShouldDisplay(MemberInfo m);
    [ExtensionAttribute]
internal static Type GetElementTypeIfEnumerable(Type type);
    [ExtensionAttribute]
internal static bool IsEnumerable(Type type);
    [ExtensionAttribute]
public static bool IsDictionary(Type type, Func`2& getKeys, Func`2& getValues, Type& keyType, Type& valueType);
}
public abstract class Microsoft.DotNet.Interactive.Formatting.TypeFormatter`1 : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public string MimeType { get; }
    protected TypeFormatter`1(Type type);
    public abstract virtual bool Format(T value, FormatContext context);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    public abstract virtual string get_MimeType();
    private sealed virtual override bool Microsoft.DotNet.Interactive.Formatting.ITypeFormatter.Format(object instance, FormatContext context);
}
[AttributeUsageAttribute("12")]
public class Microsoft.DotNet.Interactive.Formatting.TypeFormatterSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <FormatterSourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PreferredMimeTypes>k__BackingField;
    public Type FormatterSourceType { get; }
    public String[] PreferredMimeTypes { get; public set; }
    public TypeFormatterSourceAttribute(Type formatterSourceType);
    [CompilerGeneratedAttribute]
public Type get_FormatterSourceType();
    [CompilerGeneratedAttribute]
public String[] get_PreferredMimeTypes();
    [CompilerGeneratedAttribute]
public void set_PreferredMimeTypes(String[] value);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Utility.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> getValue);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<string, object> dictionary, string key, Func`2<string, TValue> getValue);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> source, TKey key, TValue value);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> Merge(IDictionary`2<TKey, TValue> dictionary1, IDictionary`2<TKey, TValue> dictionary2, bool replace, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static void MergeWith(IDictionary`2<TKey, TValue> target, IDictionary`2<TKey, TValue> source, bool replace);
}
[DebuggerStepThroughAttribute]
internal class Pocket.CompositeDisposable : object {
    private bool isDisposed;
    private List`1<IDisposable> disposables;
    public void Add(IDisposable disposable);
    public void Add(Action dispose);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<IDisposable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerStepThroughAttribute]
internal static class Pocket.Disposable : object {
    private static IDisposable empty;
    [CompilerGeneratedAttribute]
private static IDisposable <Empty>k__BackingField;
    public static IDisposable Empty { get; }
    private static Disposable();
    public static IDisposable Create(Action dispose);
    [CompilerGeneratedAttribute]
public static IDisposable get_Empty();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[IsReadOnlyAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    [NullableContextAttribute("1")]
public static T[] GetSubArray(T[] array, Range range);
}
