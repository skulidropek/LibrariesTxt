internal class Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommandEventCommEnvelop : object {
    [CompilerGeneratedAttribute]
private string <CommandOrEventEnvelop>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IKernelEventEnvelope <EventEnvelope>k__BackingField;
    [CompilerGeneratedAttribute]
private IKernelCommandEnvelope <CommandEnvelope>k__BackingField;
    [JsonPropertyNameAttribute("commandOrEvent")]
public string CommandOrEventEnvelop { get; }
    [JsonPropertyNameAttribute("type")]
public string Type { get; }
    [JsonIgnoreAttribute]
public IKernelEventEnvelope EventEnvelope { get; }
    [JsonIgnoreAttribute]
public IKernelCommandEnvelope CommandEnvelope { get; }
    [JsonConstructorAttribute]
public CommandEventCommEnvelop(string commandOrEventEnvelop, string type);
    public CommandEventCommEnvelop(KernelCommand command);
    public CommandEventCommEnvelop(KernelEvent event);
    [CompilerGeneratedAttribute]
public string get_CommandOrEventEnvelop();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public IKernelEventEnvelope get_EventEnvelope();
    [CompilerGeneratedAttribute]
public IKernelCommandEnvelope get_CommandEnvelope();
    public virtual IReadOnlyDictionary`2<string, object> ToDictionary();
    public static CommandEventCommEnvelop FromDataDictionary(IReadOnlyDictionary`2<string, object> data);
}
internal class Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannel : object {
    private CommAgent _agent;
    public CommCommandEventChannel(CommAgent agent);
    public sealed virtual void Dispose();
    private FormattedValue FormatTabularDataResource(TabularDataResource table);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannel/<HandleAsync>d__4")]
public sealed virtual Task HandleAsync(SendValue command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannel/<HandleAsync>d__5")]
public sealed virtual Task HandleAsync(RequestValue command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannel/<HandleAsync>d__6")]
public sealed virtual Task HandleAsync(RequestValueInfos command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannel/<SendAsync>d__7")]
private Task`1<KernelEvent> SendAsync(KernelCommand command, CancellationToken token);
    private IObservable`1<Message> GetResponseObservable();
    private void ThrowIfAgentIsClosed();
}
internal class Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannelConfiguration : object {
    private static string TargetName;
    private static IReadOnlyDictionary`2<string, string> _commDefinitions;
    private CommsManager _commsManager;
    public CommCommandEventChannelConfiguration(CommsManager commsManager);
    private static CommCommandEventChannelConfiguration();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannelConfiguration/<ApplyAsync>d__4")]
public sealed virtual Task`1<bool> ApplyAsync(JupyterKernel kernel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannelConfiguration/<GetCommandEventChannelAsync>d__5")]
private Task`1<CommCommandEventChannel> GetCommandEventChannelAsync(JupyterKernel kernel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CommandEvents.CommCommandEventChannelConfiguration/<CreateCommandEventChannelAsync>d__6")]
private Task`1<CommCommandEventChannel> CreateCommandEventChannelAsync();
    private static IReadOnlyDictionary`2<string, string> GetCommDefinitions();
}
public class Microsoft.DotNet.Interactive.Jupyter.CompleteRequestHandler : RequestHandlerBase`1<CompleteRequest> {
    public CompleteRequestHandler(Kernel kernel, IScheduler scheduler);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CompleteRequestHandler/<Handle>d__1")]
public Task Handle(JupyterRequestContext context);
    protected virtual void OnKernelEventReceived(KernelEvent event, JupyterRequestContext context);
    private static void OnCompletionRequestCompleted(CompletionsProduced completionsProduced, IJupyterMessageResponseSender jupyterMessageSender);
}
internal class Microsoft.DotNet.Interactive.Jupyter.CondaEnvironment : object {
    public static string BASE_ENV;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static string CondaPath;
    private static IReadOnlyCollection`1<string> _environments;
    public string Name { get; public set; }
    private static CondaEnvironment();
    public CondaEnvironment(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public static IReadOnlyCollection`1<string> GetEnvironments();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CondaEnvironment/<GetEnvironmentsAsync>d__11")]
private static Task`1<IReadOnlyCollection`1<string>> GetEnvironmentsAsync();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CondaEnvironment/<Execute>d__12")]
private static Task`1<CommandLineResult> Execute(string command, string args, string environmentName, DirectoryInfo workingDir, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.CondaEnvironment/<Execute>d__13")]
public sealed virtual Task`1<CommandLineResult> Execute(string command, string args, DirectoryInfo workingDir, Nullable`1<TimeSpan> timeout);
    public sealed virtual Process StartProcess(string command, string args, DirectoryInfo workingDir, Action`1<string> output, Action`1<string> error);
    private static string GetCondaPath();
    private static string GetCondaExecutable();
}
public interface Microsoft.DotNet.Interactive.Jupyter.Connection.IJupyterConnection {
    public abstract virtual Task`1<IEnumerable`1<KernelSpec>> GetKernelSpecsAsync();
    public abstract virtual Task`1<IJupyterKernelConnection> CreateKernelConnectionAsync(string kernelSpecName);
}
public interface Microsoft.DotNet.Interactive.Jupyter.Connection.IJupyterKernelConnection {
    public Uri Uri { get; }
    public IMessageSender Sender { get; }
    public IMessageReceiver Receiver { get; }
    public abstract virtual Uri get_Uri();
    public abstract virtual Task StartAsync();
    public abstract virtual IMessageSender get_Sender();
    public abstract virtual IMessageReceiver get_Receiver();
}
public interface Microsoft.DotNet.Interactive.Jupyter.Connection.IJupyterKernelConnectionOptions {
    public abstract virtual IReadOnlyCollection`1<Option> GetOptions();
    public abstract virtual IJupyterConnection GetConnection(ParseResult connectionOptionsParseResult);
}
internal class Microsoft.DotNet.Interactive.Jupyter.Connection.KernelStartException : Exception {
    public KernelStartException(string kernelType, string reason);
}
public class Microsoft.DotNet.Interactive.Jupyter.ConnectionInformation : object {
    [CompilerGeneratedAttribute]
private int <StdinPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IP>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ControlPort>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HBPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignatureScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ShellPort>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Transport>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IOPubPort>k__BackingField;
    [JsonPropertyNameAttribute("stdin_port")]
public int StdinPort { get; public set; }
    [JsonPropertyNameAttribute("ip")]
public string IP { get; public set; }
    [JsonPropertyNameAttribute("control_port")]
public int ControlPort { get; public set; }
    [JsonPropertyNameAttribute("hb_port")]
public int HBPort { get; public set; }
    [JsonPropertyNameAttribute("signature_scheme")]
public string SignatureScheme { get; public set; }
    [JsonPropertyNameAttribute("key")]
public string Key { get; public set; }
    [JsonPropertyNameAttribute("shell_port")]
public int ShellPort { get; public set; }
    [JsonPropertyNameAttribute("transport")]
public string Transport { get; public set; }
    [JsonPropertyNameAttribute("iopub_port")]
public int IOPubPort { get; public set; }
    [CompilerGeneratedAttribute]
public int get_StdinPort();
    [CompilerGeneratedAttribute]
public void set_StdinPort(int value);
    [CompilerGeneratedAttribute]
public string get_IP();
    [CompilerGeneratedAttribute]
public void set_IP(string value);
    [CompilerGeneratedAttribute]
public int get_ControlPort();
    [CompilerGeneratedAttribute]
public void set_ControlPort(int value);
    [CompilerGeneratedAttribute]
public int get_HBPort();
    [CompilerGeneratedAttribute]
public void set_HBPort(int value);
    [CompilerGeneratedAttribute]
public string get_SignatureScheme();
    [CompilerGeneratedAttribute]
public void set_SignatureScheme(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public int get_ShellPort();
    [CompilerGeneratedAttribute]
public void set_ShellPort(int value);
    [CompilerGeneratedAttribute]
public string get_Transport();
    [CompilerGeneratedAttribute]
public void set_Transport(string value);
    [CompilerGeneratedAttribute]
public int get_IOPubPort();
    [CompilerGeneratedAttribute]
public void set_IOPubPort(int value);
    public static ConnectionInformation Load(FileInfo file);
}
public class Microsoft.DotNet.Interactive.Jupyter.ConnectJupyterKernelCommand : ConnectKernelCommand {
    private List`1<IJupyterKernelConnectionOptions> _connectionCreators;
    private KeyValuePair`2<int, IEnumerable`1<CompletionItem>> _mruKernelSpecSuggestions;
    [CompilerGeneratedAttribute]
private Option`1<string> <KernelSpecName>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<string> <InitScript>k__BackingField;
    public Option`1<string> KernelSpecName { get; }
    public Option`1<string> InitScript { get; }
    [CompilerGeneratedAttribute]
public Option`1<string> get_KernelSpecName();
    [CompilerGeneratedAttribute]
public Option`1<string> get_InitScript();
    public ConnectJupyterKernelCommand AddConnectionOptions(IJupyterKernelConnectionOptions connectionOptions);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.ConnectJupyterKernelCommand/<ConnectKernelsAsync>d__10")]
public virtual Task`1<IEnumerable`1<Kernel>> ConnectKernelsAsync(KernelInvocationContext context, InvocationContext commandLineContext);
    private IJupyterConnection GetJupyterConnection(ParseResult parseResult);
    private IEnumerable`1<CompletionItem> GetKernelSpecsCompletions(CompletionContext ctx);
    private IEnumerable`1<CompletionItem> GetKernelSpecsCompletions(IJupyterConnection connection);
    private int GetParseResultHash(ParseResult parseResult);
}
public static class Microsoft.DotNet.Interactive.Jupyter.Constants : object {
    public static string USERNAME;
    public static string MESSAGE_PROTOCOL_VERSION;
    public static string DELIMITER;
}
internal class Microsoft.DotNet.Interactive.Jupyter.DefaultJupyterEnvironment : object {
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.DefaultJupyterEnvironment/<Execute>d__0")]
public sealed virtual Task`1<CommandLineResult> Execute(string command, string args, DirectoryInfo workingDir, Nullable`1<TimeSpan> timeout);
    public sealed virtual Process StartProcess(string command, string args, DirectoryInfo workingDir, Action`1<string> output, Action`1<string> error);
}
public class Microsoft.DotNet.Interactive.Jupyter.ExecuteRequestHandler : RequestHandlerBase`1<ExecuteRequest> {
    private int _executionCount;
    public ExecuteRequestHandler(Kernel kernel, IScheduler scheduler);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.ExecuteRequestHandler/<Handle>d__2")]
public Task Handle(JupyterRequestContext context);
    protected virtual void OnKernelEventReceived(KernelEvent event, JupyterRequestContext context);
    private static Dictionary`2<string, object> CreateTransient(string displayId);
    private void OnDiagnosticsProduced(JupyterRequestContext context, Message request, DiagnosticsProduced diagnosticsProduced);
    private void OnCommandFailed(CommandFailed commandFailed, IJupyterMessageResponseSender jupyterMessageSender);
    private void OnDisplayEvent(DisplayEvent displayEvent, Message request, IJupyterMessageResponseSender jupyterMessageSender);
    private object PreserveJson(string mimeType, string formattedValue);
    private string GetPlainTextValueOrDefault(Dictionary`2<string, object> formattedValues, string defaultText);
    private void OnCommandHandled(IJupyterMessageResponseSender jupyterMessageSender);
}
public class Microsoft.DotNet.Interactive.Jupyter.Formatting.LaTeXString : object {
    private string _latexCode;
    public LaTeXString(string latexCode);
    public static LaTeXString op_Implicit(string source);
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Jupyter.Formatting.MathString : object {
    private string _math;
    public MathString(string latexCode);
    public static MathString op_Implicit(string source);
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Jupyter.Heartbeat : object {
    private string _address;
    private ResponseSocket _server;
    public Heartbeat(ConnectionInformation connectionInformation);
    public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    public sealed virtual Task StopAsync(CancellationToken cancellationToken);
}
internal static class Microsoft.DotNet.Interactive.Jupyter.Http.AuthorizationScheme : object {
    public static string Bearer;
    public static string Token;
    private static AuthorizationScheme();
}
internal class Microsoft.DotNet.Interactive.Jupyter.Http.HttpApiClient : object {
    private HttpClient _httpClient;
    private Uri _baseUri;
    private IAuthorizationProvider _authProvider;
    public Uri BaseUri { get; }
    public HttpApiClient(Uri baseUri, IAuthorizationProvider authProvider);
    public Uri get_BaseUri();
    public virtual HttpApiClient CreateClient(string relativeApiPath);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.HttpApiClient/<SendRequestAsync>d__8")]
public virtual Task`1<HttpResponseMessage> SendRequestAsync(string relativeApiPath, HttpContent content, HttpMethod method);
    public virtual HttpResponseMessage SendRequest(string relativeApiPath, HttpContent content, HttpMethod method);
    public Uri GetUri(string relativeApiPath);
    protected virtual HttpRequestMessage CreateRequest(string token, string relativeApiPath, HttpContent content, HttpMethod method);
}
internal interface Microsoft.DotNet.Interactive.Jupyter.Http.IAuthorizationProvider {
    public string AuthScheme { get; }
    public abstract virtual string GetToken();
    public abstract virtual Task`1<string> GetTokenAsync();
    public abstract virtual string get_AuthScheme();
}
internal class Microsoft.DotNet.Interactive.Jupyter.Http.JupyterHttpConnection : object {
    private HttpApiClient _apiClient;
    private IAuthorizationProvider _authProvider;
    private CompositeDisposable _disposables;
    private IEnumerable`1<KernelSpec> _availableKernels;
    private List`1<string> _activeSessions;
    public JupyterHttpConnection(Uri serverUri, IAuthorizationProvider authProvider);
    public JupyterHttpConnection(HttpApiClient apiClient, IAuthorizationProvider authProvider);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.JupyterHttpConnection/<GetKernelSpecsAsync>d__12")]
public sealed virtual Task`1<IEnumerable`1<KernelSpec>> GetKernelSpecsAsync();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.JupyterHttpConnection/<CreateKernelConnectionAsync>d__13")]
public sealed virtual Task`1<IJupyterKernelConnection> CreateKernelConnectionAsync(string kernelSpecName);
    private bool ShutdownJupyterSessions();
}
internal class Microsoft.DotNet.Interactive.Jupyter.Http.JupyterKernelHttpConnection : object {
    private HttpApiClient _apiClient;
    private IAuthorizationProvider _authProvider;
    private ClientWebSocket _socket;
    private Subject`1<Message> _subject;
    private CancellationTokenSource _cancellationTokenSource;
    private CompositeDisposable _disposables;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    public Uri Uri { get; }
    public IObservable`1<Message> Messages { get; }
    public IMessageSender Sender { get; }
    public IMessageReceiver Receiver { get; }
    public JupyterKernelHttpConnection(Uri serverUri, IAuthorizationProvider authProvider);
    public JupyterKernelHttpConnection(HttpApiClient apiClient, IAuthorizationProvider authProvider);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Uri();
    public sealed virtual IObservable`1<Message> get_Messages();
    public sealed virtual IMessageSender get_Sender();
    public sealed virtual IMessageReceiver get_Receiver();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.JupyterKernelHttpConnection/<StartAsync>d__18")]
public sealed virtual Task StartAsync();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.JupyterKernelHttpConnection/<ConnectSocketAsync>d__19")]
private Task ConnectSocketAsync();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.JupyterKernelHttpConnection/<SendAsync>d__20")]
public sealed virtual Task SendAsync(Message message);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.JupyterKernelHttpConnection/<SendToSocketAsync>d__21")]
private Task SendToSocketAsync(Byte[] payload);
    private Task StartListeningAsync(ClientWebSocket socket, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.JupyterKernelHttpConnection/<TryHandleAsync>d__23")]
private Task`1<bool> TryHandleAsync(Message message);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Http.JupyterKernelHttpConnection/<InterruptKernelAsync>d__24")]
private Task`1<bool> InterruptKernelAsync();
    private Uri GetWebSocketUri(Uri uri);
    private void PostMessage(Message message);
}
internal class Microsoft.DotNet.Interactive.Jupyter.Http.JupyterTokenProvider : object {
    private string _token;
    private string _authScheme;
    public string AuthScheme { get; }
    public JupyterTokenProvider(string token, string authScheme);
    public sealed virtual string get_AuthScheme();
    public sealed virtual Task`1<string> GetTokenAsync();
    public sealed virtual string GetToken();
}
public interface Microsoft.DotNet.Interactive.Jupyter.IJupyterEnvironment {
    public abstract virtual Task`1<CommandLineResult> Execute(string command, string args, DirectoryInfo workingDir, Nullable`1<TimeSpan> timeout);
    public abstract virtual Process StartProcess(string command, string args, DirectoryInfo workingDir, Action`1<string> output, Action`1<string> error);
}
internal interface Microsoft.DotNet.Interactive.Jupyter.IJupyterKernelConfiguration {
    public abstract virtual Task`1<bool> ApplyAsync(JupyterKernel kernel);
}
public interface Microsoft.DotNet.Interactive.Jupyter.IJupyterKernelSpecModule {
    public abstract virtual Task`1<CommandLineResult> InstallKernel(DirectoryInfo sourceDirectory);
    public abstract virtual DirectoryInfo GetDefaultKernelSpecDirectory();
    public abstract virtual Task`1<IReadOnlyDictionary`2<string, KernelSpec>> ListKernels();
    public abstract virtual IJupyterEnvironment GetEnvironment();
}
public interface Microsoft.DotNet.Interactive.Jupyter.IJupyterMessageResponseSender {
    public abstract virtual void Send(PubSubMessage message);
    public abstract virtual void Send(ReplyMessage message);
    public abstract virtual string Send(InputRequest message);
}
public class Microsoft.DotNet.Interactive.Jupyter.InterruptRequestHandler : RequestHandlerBase`1<InterruptRequest> {
    public InterruptRequestHandler(Kernel kernel, IScheduler scheduler);
    protected virtual void OnKernelEventReceived(KernelEvent event, JupyterRequestContext context);
    public Task Handle(JupyterRequestContext context);
}
public class Microsoft.DotNet.Interactive.Jupyter.IsCompleteRequestHandler : RequestHandlerBase`1<IsCompleteRequest> {
    public IsCompleteRequestHandler(Kernel kernel, IScheduler scheduler);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.IsCompleteRequestHandler/<Handle>d__1")]
public Task Handle(JupyterRequestContext context);
    protected virtual void OnKernelEventReceived(KernelEvent event, JupyterRequestContext context);
    private void Reply(bool isComplete, Message request, IJupyterMessageResponseSender jupyterMessageSender);
}
public class Microsoft.DotNet.Interactive.Jupyter.JupyterClientKernelExtension : object {
    public static Task LoadAsync(Kernel kernel);
}
internal static class Microsoft.DotNet.Interactive.Jupyter.JupyterCommonDirectories : object {
    private static string JUPYTER_DATA_DIR;
    private static string JUPYTER_PATH;
    private static JupyterCommonDirectories();
    public static DirectoryInfo GetRuntimeDirectory();
    public static IReadOnlyList`1<DirectoryInfo> GetDataDirectories();
    public static DirectoryInfo GetDataDirectory();
    private static DirectoryInfo GetDefaultDataDirectoryFromEnv();
    private static DirectoryInfo GetDefaultJupyterDataDirectory();
}
public class Microsoft.DotNet.Interactive.Jupyter.JupyterHttpKernelConnectionOptions : object {
    private IReadOnlyCollection`1<Option> _options;
    [CompilerGeneratedAttribute]
private Option`1<string> <TargetUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<string> <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<bool> <UseBearerAuth>k__BackingField;
    public Option`1<string> TargetUrl { get; }
    public Option`1<string> Token { get; }
    private Option`1<bool> UseBearerAuth { get; }
    [CompilerGeneratedAttribute]
public Option`1<string> get_TargetUrl();
    [CompilerGeneratedAttribute]
public Option`1<string> get_Token();
    [CompilerGeneratedAttribute]
private Option`1<bool> get_UseBearerAuth();
    public sealed virtual IJupyterConnection GetConnection(ParseResult connectionOptionsParseResult);
    public sealed virtual IReadOnlyCollection`1<Option> GetOptions();
}
internal class Microsoft.DotNet.Interactive.Jupyter.JupyterKernel : Kernel {
    private IMessageSender _sender;
    private IMessageReceiver _receiver;
    private IMessageReceiver Receiver { get; }
    private IMessageSender Sender { get; }
    protected JupyterKernel(string name, IMessageSender sender, IMessageReceiver receiver, string languageName, string languageVersion);
    private IMessageReceiver get_Receiver();
    private IMessageSender get_Sender();
    private Task`1<T> RunOnKernelAsync(RequestMessage content, CancellationToken token, string channel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<CreateAsync>d__8")]
public static Task`1<JupyterKernel> CreateAsync(string name, IMessageSender sender, IMessageReceiver receiver);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<RequestKernelInfo>d__9")]
private static Task`1<KernelInfoReply> RequestKernelInfo(IMessageSender sender, IMessageReceiver receiver);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<RunOnKernelAsync>d__10`1")]
private static Task`1<T> RunOnKernelAsync(RequestMessage content, IMessageSender sender, IMessageReceiver receiver, CancellationToken token, string channel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<HandleAsync>d__11")]
public sealed virtual Task HandleAsync(RequestHoverText command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<HandleAsync>d__12")]
public sealed virtual Task HandleAsync(RequestSignatureHelp command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<HandleAsync>d__13")]
public sealed virtual Task HandleAsync(RequestCompletions command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<HandleAsync>d__14")]
public sealed virtual Task HandleAsync(SubmitCode command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<HandleExecuteReplyMessageAsync>d__15")]
private Task HandleExecuteReplyMessageAsync(Message message, SubmitCode command, KernelInvocationContext context);
    private string GetDisplayIdFromTransientData(IReadOnlyDictionary`2<string, object> transientData);
    private IReadOnlyCollection`1<FormattedValue> GetFormattedValuesFromMimeBundle(IReadOnlyDictionary`2<string, object> data);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<GetInputAsync>d__18")]
private Task`1<string> GetInputAsync(InputRequest inputRequest, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<InterruptKernelExecutionAsync>d__19")]
private Task InterruptKernelExecutionAsync();
    private void CancelCommandOnKernelIfRequested(KernelInvocationContext context);
    [CompilerGeneratedAttribute]
internal static string <HandleAsync>g__GetCompletionKind|13_0(string type);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernel/<<CancelCommandOnKernelIfRequested>b__20_0>d")]
[CompilerGeneratedAttribute]
private void <CancelCommandOnKernelIfRequested>b__20_0();
}
internal class Microsoft.DotNet.Interactive.Jupyter.JupyterKernelConnector : object {
    private IJupyterConnection _jupyterConnection;
    private string _kernelSpecName;
    private string _initScript;
    public JupyterKernelConnector(IJupyterConnection jupyterConnection, string kernelSpecName, string initScript);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernelConnector/<CreateKernelAsync>d__4")]
public Task`1<Kernel> CreateKernelAsync(string kernelName);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Jupyter.JupyterKernelExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernelExtensions/<UseConfiguration>d__0")]
[ExtensionAttribute]
public static Task UseConfiguration(JupyterKernel kernel, IJupyterKernelConfiguration configuration);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernelExtensions/<RunOnKernelAsync>d__1")]
[ExtensionAttribute]
public static Task`1<bool> RunOnKernelAsync(JupyterKernel kernel, string code);
}
public class Microsoft.DotNet.Interactive.Jupyter.JupyterKernelSpecModule : object {
    private IJupyterEnvironment _environment;
    public JupyterKernelSpecModule(IJupyterEnvironment environment);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernelSpecModule/<ExecuteCommand>d__4")]
private Task`1<CommandLineResult> ExecuteCommand(string command, string args);
    public sealed virtual Task`1<CommandLineResult> InstallKernel(DirectoryInfo sourceDirectory);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterKernelSpecModule/<ListKernels>d__6")]
public sealed virtual Task`1<IReadOnlyDictionary`2<string, KernelSpec>> ListKernels();
    public sealed virtual DirectoryInfo GetDefaultKernelSpecDirectory();
    private IReadOnlyDictionary`2<string, KernelSpec> LookupInstalledKernels();
    private KernelSpec GetKernelSpec(DirectoryInfo directory);
    public sealed virtual IJupyterEnvironment GetEnvironment();
}
public class Microsoft.DotNet.Interactive.Jupyter.JupyterLocalKernelConnectionOptions : object {
    private IReadOnlyCollection`1<Option> _options;
    [CompilerGeneratedAttribute]
private Option`1<string> <CondaEnv>k__BackingField;
    public Option`1<string> CondaEnv { get; }
    [CompilerGeneratedAttribute]
public Option`1<string> get_CondaEnv();
    public sealed virtual IJupyterConnection GetConnection(ParseResult connectionOptionsParseResult);
    public sealed virtual IReadOnlyCollection`1<Option> GetOptions();
}
public class Microsoft.DotNet.Interactive.Jupyter.JupyterRequestContext : object {
    private TaskCompletionSource`1<Unit> _done;
    [CompilerGeneratedAttribute]
private static JupyterRequestContext <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private IJupyterMessageResponseSender <JupyterMessageSender>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <JupyterRequestMessageEnvelope>k__BackingField;
    internal static JupyterRequestContext Current { get; internal set; }
    public string Token { get; }
    public IJupyterMessageResponseSender JupyterMessageSender { get; }
    public Message JupyterRequestMessageEnvelope { get; }
    internal JupyterRequestContext(RequestReplyChannel serverChannel, PubSubChannel ioPubChannel, StdInChannel stdInChannel, Message request, string kernelIdentity);
    public JupyterRequestContext(IJupyterMessageResponseSender jupyterMessageSender, Message request);
    [CompilerGeneratedAttribute]
internal static JupyterRequestContext get_Current();
    [CompilerGeneratedAttribute]
internal static void set_Current(JupyterRequestContext value);
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public IJupyterMessageResponseSender get_JupyterMessageSender();
    [CompilerGeneratedAttribute]
public Message get_JupyterRequestMessageEnvelope();
    public T GetRequestContent();
    public void Complete();
    public Task Done();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Jupyter.JupyterRequestContextExtensions : object {
    [ExtensionAttribute]
public static string GetKernelName(JupyterRequestContext context);
}
public class Microsoft.DotNet.Interactive.Jupyter.JupyterRequestContextHandler : object {
    private ExecuteRequestHandler _executeHandler;
    private CompleteRequestHandler _completeHandler;
    private InterruptRequestHandler _interruptHandler;
    private IsCompleteRequestHandler _isCompleteHandler;
    private ShutdownRequestHandler _shutdownHandler;
    public JupyterRequestContextHandler(Kernel kernel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterRequestContextHandler/<Handle>d__6")]
public Task Handle(JupyterRequestContext context);
}
public class Microsoft.DotNet.Interactive.Jupyter.JupyterRequestContextScheduler : object {
    private Func`2<JupyterRequestContext, Task> handle;
    public JupyterRequestContextScheduler(Func`2<JupyterRequestContext, Task> handle);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.JupyterRequestContextScheduler/<Schedule>d__2")]
public Task Schedule(JupyterRequestContext context);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Jupyter.KernelExtensions : object {
    [ExtensionAttribute]
public static T UseDefaultMagicCommands(T kernel);
    [ExtensionAttribute]
public static CSharpKernel UseJupyterHelpers(CSharpKernel kernel);
    [ExtensionAttribute]
public static PowerShellKernel UseJupyterHelpers(PowerShellKernel kernel);
    [ExtensionAttribute]
private static T UseMarkdown(T kernel);
    [ExtensionAttribute]
private static T UseTime(T kernel);
    [ExtensionAttribute]
private static T UseLsMagic(T kernel);
    private static Command lsmagic(Kernel kernel);
    [CompilerGeneratedAttribute]
internal static Command <UseTime>g__time|4_0();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Jupyter.KernelFormattingExtensions : object {
    [ExtensionAttribute]
public static CSharpKernel UseMathAndLaTeX(CSharpKernel kernel);
    [ExtensionAttribute]
public static FSharpKernel UseMathAndLaTeX(FSharpKernel kernel);
}
public class Microsoft.DotNet.Interactive.Jupyter.KernelSpec : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <CommandArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InterruptMode>k__BackingField;
    [JsonIgnoreAttribute]
public string Name { get; public set; }
    [JsonPropertyNameAttribute("argv")]
public IReadOnlyList`1<string> CommandArguments { get; public set; }
    [JsonPropertyNameAttribute("display_name")]
public string DisplayName { get; public set; }
    [JsonPropertyNameAttribute("language")]
public string Language { get; public set; }
    [JsonPropertyNameAttribute("metadata")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Metadata { get; public set; }
    [JsonPropertyNameAttribute("env")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, string> EnvironmentVariables { get; public set; }
    [JsonPropertyNameAttribute("interrupt_mode")]
[JsonIgnoreAttribute]
public string InterruptMode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_CommandArguments();
    [CompilerGeneratedAttribute]
public void set_CommandArguments(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IReadOnlyDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(IReadOnlyDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_InterruptMode();
    [CompilerGeneratedAttribute]
public void set_InterruptMode(string value);
}
internal static class Microsoft.DotNet.Interactive.Jupyter.LocalizationResources : object {
    internal static string Magics_lsmagic_Description();
    internal static string Magics_markdown_Description();
    internal static string Magics_time_Description();
    private static string GetResourceString(string resourceString, Object[] formatArguments);
}
internal class Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.CommAgent : object {
    private IMessageSender _sender;
    private string _commId;
    private Subject`1<Message> _commChannel;
    private CompositeDisposable _disposables;
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    public string CommId { get; }
    public bool IsClosed { get; private set; }
    public IObservable`1<Message> Messages { get; }
    public CommAgent(string commId, IMessageSender messageSender, IMessageReceiver messageReceiver);
    public string get_CommId();
    [CompilerGeneratedAttribute]
public bool get_IsClosed();
    [CompilerGeneratedAttribute]
private void set_IsClosed(bool value);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.CommAgent/<SendAsync>d__12")]
public Task SendAsync(IReadOnlyDictionary`2<string, object> data);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.CommAgent/<CloseAsync>d__13")]
public Task CloseAsync(IReadOnlyDictionary`2<string, object> data);
    public IObservable`1<Message> get_Messages();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(Message message);
}
internal class Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.CommsManager : object {
    private Dictionary`2<string, ICommTarget> _targets;
    private Dictionary`2<string, CommAgent> _agents;
    private IMessageSender _sender;
    private IMessageReceiver _receiver;
    private CompositeDisposable _disposables;
    public CommsManager(IMessageSender messageSender, IMessageReceiver messageReceiver);
    public sealed virtual void Dispose();
    public void RegisterTarget(ICommTarget target);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.CommsManager/<OpenCommAsync>d__8")]
public Task`1<CommAgent> OpenCommAsync(string targetName, string commId, IReadOnlyDictionary`2<string, object> data);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.CommsManager/<CurrentCommsAsync>d__9")]
public Task`1<IReadOnlyDictionary`2<string, CommTarget>> CurrentCommsAsync();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.CommsManager/<HandleCommOpenRequestAsync>d__10")]
private Task HandleCommOpenRequestAsync(CommOpen commOpen);
    private CommAgent AddAgent(string commId);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.CommsManager/<<-ctor>b__5_0>d")]
[CompilerGeneratedAttribute]
private void <.ctor>b__5_0(Message message);
}
internal interface Microsoft.DotNet.Interactive.Jupyter.Messaging.Comms.ICommTarget {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void OnCommOpen(CommAgent commAgent, IReadOnlyDictionary`2<string, object> data);
}
public class Microsoft.DotNet.Interactive.Jupyter.Messaging.Header : object {
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [JsonPropertyNameAttribute("msg_id")]
public string MessageId { get; }
    [JsonPropertyNameAttribute("username")]
public string Username { get; }
    [JsonPropertyNameAttribute("session")]
public string Session { get; }
    [JsonPropertyNameAttribute("date")]
public string Date { get; }
    [JsonPropertyNameAttribute("msg_type")]
public string MessageType { get; }
    [JsonPropertyNameAttribute("version")]
public string Version { get; }
    public Header(string messageType, string messageId, string version, string session, string username, string date);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_Session();
    [CompilerGeneratedAttribute]
public string get_Date();
    [CompilerGeneratedAttribute]
public string get_MessageType();
    [CompilerGeneratedAttribute]
public string get_Version();
    public static Header Create(T messageContent, string session);
    public static Header Create(string session);
    private static Header Create(string messageType, string session);
}
public interface Microsoft.DotNet.Interactive.Jupyter.Messaging.IMessageReceiver {
    public IObservable`1<Message> Messages { get; }
    public abstract virtual IObservable`1<Message> get_Messages();
}
public interface Microsoft.DotNet.Interactive.Jupyter.Messaging.IMessageSender {
    public abstract virtual Task SendAsync(Message message);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Jupyter.Messaging.JsonElementExtensions : object {
    [ExtensionAttribute]
public static object ToObject(JsonElement source);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, object> ToReadOnlyDictionary(JsonElement source);
    [ExtensionAttribute]
public static IDictionary`2<string, object> ToDictionary(JsonElement source);
    [ExtensionAttribute]
public static Object[] ToArray(JsonElement source);
}
public class Microsoft.DotNet.Interactive.Jupyter.Messaging.Message : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyList`1<byte>> <Identifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Header <ParentHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyList`1<byte>> <Buffers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Channel>k__BackingField;
    [JsonIgnoreAttribute]
public IReadOnlyList`1<IReadOnlyList`1<byte>> Identifiers { get; }
    [JsonIgnoreAttribute]
public string Signature { get; }
    [JsonPropertyNameAttribute("header")]
public Header Header { get; }
    [JsonPropertyNameAttribute("parent_header")]
public Header ParentHeader { get; }
    [JsonPropertyNameAttribute("metadata")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> MetaData { get; }
    [JsonPropertyNameAttribute("content")]
[JsonIgnoreAttribute]
public Message Content { get; }
    [JsonPropertyNameAttribute("buffers")]
public IReadOnlyList`1<IReadOnlyList`1<byte>> Buffers { get; }
    [JsonPropertyNameAttribute("channel")]
[JsonIgnoreAttribute]
public string Channel { get; }
    public Message(Header header, Message content, Header parentHeader, string signature, IReadOnlyDictionary`2<string, object> metaData, IReadOnlyList`1<IReadOnlyList`1<byte>> identifiers, IReadOnlyList`1<IReadOnlyList`1<byte>> buffers, string channel);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyList`1<byte>> get_Identifiers();
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public Header get_Header();
    [CompilerGeneratedAttribute]
public Header get_ParentHeader();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_MetaData();
    [CompilerGeneratedAttribute]
public Message get_Content();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyList`1<byte>> get_Buffers();
    [CompilerGeneratedAttribute]
public string get_Channel();
    public static Message Create(T content, Header parentHeader, IReadOnlyList`1<IReadOnlyList`1<byte>> identifiers, IReadOnlyDictionary`2<string, object> metaData, string signature, string channel);
    public static Message CreateReply(T content, Message request, string channel);
    public static Message CreatePubSub(T content, Message request, string kernelIdentity);
    private static Byte[] Topic(T content, string kernelIdentity);
    [CompilerGeneratedAttribute]
internal static string <Topic>g__GenerateFullTopic|28_0(string topic, <>c__DisplayClass28_0`1& );
}
internal class Microsoft.DotNet.Interactive.Jupyter.Messaging.MessageChannelValues : object {
    public static string shell;
    public static string control;
    public static string iopub;
    public static string stdin;
}
internal class Microsoft.DotNet.Interactive.Jupyter.Messaging.MessageConverter : JsonConverter`1<Message> {
    public virtual Message Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Message value, JsonSerializerOptions options);
    private void Write(Utf8JsonWriter writer, T value, string propertyName, JsonSerializerOptions options);
}
public static class Microsoft.DotNet.Interactive.Jupyter.Messaging.MessageExtensions : object {
    public static bool IsEmptyJson(string source);
    public static T DeserializeFromJsonString(string source);
    private static Message DeserializeMessageContentFromJsonString(string source, string messageType);
    public static Message DeserializeMessage(string signature, string headerJson, string parentHeaderJson, string metadataJson, string contentJson, IReadOnlyList`1<IReadOnlyList`1<byte>> identifiers, JsonSerializerOptions options);
}
public static class Microsoft.DotNet.Interactive.Jupyter.Messaging.MessageFormatter : object {
    [CompilerGeneratedAttribute]
private static JsonSerializerOptions <SerializerOptions>k__BackingField;
    public static JsonSerializerOptions SerializerOptions { get; }
    private static MessageFormatter();
    [CompilerGeneratedAttribute]
public static JsonSerializerOptions get_SerializerOptions();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Jupyter.Messaging.MessageObservableExtensions : object {
    [ExtensionAttribute]
public static IObservable`1<Message> ResponseOf(IObservable`1<Message> observable, Message parentMessage);
    [ExtensionAttribute]
public static IObservable`1<Message> TakeUntilMessageType(IObservable`1<Message> observable, String[] messageTypes);
    [ExtensionAttribute]
public static IObservable`1<Message> Content(IObservable`1<Message> observable);
}
public static class Microsoft.DotNet.Interactive.Jupyter.Messaging.MetadataExtensions : object {
    public static Dictionary`2<string, object> DeserializeMetadataFromJsonString(string metadataJson);
}
[JupyterMessageTypeAttribute("clear_output")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ClearOutput : PubSubMessage {
    [CompilerGeneratedAttribute]
private bool <Wait>k__BackingField;
    [JsonPropertyNameAttribute("wait ")]
public bool Wait { get; }
    public ClearOutput(bool wait);
    [CompilerGeneratedAttribute]
public bool get_Wait();
}
[JsonConverterAttribute("Microsoft.DotNet.Interactive.Jupyter.Protocol.CommCloseConverter")]
[JupyterMessageTypeAttribute("comm_close")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CommClose : Message {
    [CompilerGeneratedAttribute]
private string <CommId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    [JsonPropertyNameAttribute("comm_id")]
public string CommId { get; }
    [JsonPropertyNameAttribute("data")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Data { get; }
    public CommClose(string commId, IReadOnlyDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_CommId();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CommCloseConverter : JsonConverter`1<CommClose> {
    public virtual CommClose Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, CommClose value, JsonSerializerOptions options);
}
[JupyterMessageTypeAttribute("comm_info_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CommInfoReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, CommTarget> <Comms>k__BackingField;
    [JsonPropertyNameAttribute("comms")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, CommTarget> Comms { get; }
    public CommInfoReply(IReadOnlyDictionary`2<string, CommTarget> comms);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, CommTarget> get_Comms();
}
[JupyterMessageTypeAttribute("comm_info_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CommInfoRequest : RequestMessage {
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [JsonPropertyNameAttribute("target_name")]
[JsonIgnoreAttribute]
public string TargetName { get; }
    public CommInfoRequest(string targetName);
    [CompilerGeneratedAttribute]
public string get_TargetName();
}
[JupyterMessageTypeAttribute("comm_msg")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CommMsg : Message {
    [CompilerGeneratedAttribute]
private string <CommId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    [JsonPropertyNameAttribute("comm_id")]
public string CommId { get; }
    [JsonPropertyNameAttribute("data")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Data { get; }
    public CommMsg(string commId, IReadOnlyDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_CommId();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
}
[JupyterMessageTypeAttribute("comm_open")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CommOpen : Message {
    [CompilerGeneratedAttribute]
private string <CommId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    [JsonPropertyNameAttribute("comm_id")]
public string CommId { get; }
    [JsonPropertyNameAttribute("target_name")]
public string TargetName { get; }
    [JsonPropertyNameAttribute("data")]
public IReadOnlyDictionary`2<string, object> Data { get; }
    public CommOpen(string commId, string targetName, IReadOnlyDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_CommId();
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CommTarget : object {
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [JsonPropertyNameAttribute("target_name")]
[JsonIgnoreAttribute]
public string TargetName { get; public set; }
    public CommTarget(string targetName);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public void set_TargetName(string value);
}
[JupyterMessageTypeAttribute("complete_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CompleteReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CursorStart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CursorEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<CompletionResultMetadata>> <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [JsonPropertyNameAttribute("matches")]
public IReadOnlyList`1<string> Matches { get; }
    [JsonPropertyNameAttribute("cursor_start")]
public int CursorStart { get; }
    [JsonPropertyNameAttribute("cursor_end")]
public int CursorEnd { get; }
    [JsonPropertyNameAttribute("metadata")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyList`1<CompletionResultMetadata>> MetaData { get; }
    [JsonPropertyNameAttribute("status")]
public string Status { get; }
    public CompleteReply(int cursorStart, int cursorEnd, IReadOnlyList`1<string> matches, IReadOnlyDictionary`2<string, IReadOnlyList`1<CompletionResultMetadata>> metaData, string status);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Matches();
    [CompilerGeneratedAttribute]
public int get_CursorStart();
    [CompilerGeneratedAttribute]
public int get_CursorEnd();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyList`1<CompletionResultMetadata>> get_MetaData();
    [CompilerGeneratedAttribute]
public string get_Status();
}
[JupyterMessageTypeAttribute("complete_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CompleteRequest : RequestMessage {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CursorPosition>k__BackingField;
    [JsonPropertyNameAttribute("code")]
public string Code { get; public set; }
    [JsonPropertyNameAttribute("cursor_pos")]
public int CursorPosition { get; public set; }
    public CompleteRequest(string code, int cursorPosition);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public int get_CursorPosition();
    [CompilerGeneratedAttribute]
public void set_CursorPosition(int value);
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CompletionResultMetadata : object {
    [JsonIgnoreAttribute]
public static string Experimental;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayText>k__BackingField;
    [JsonPropertyNameAttribute("end")]
public int End { get; }
    [JsonPropertyNameAttribute("start")]
public int Start { get; }
    [JsonPropertyNameAttribute("type")]
public string Type { get; }
    [JsonPropertyNameAttribute("text")]
public string Text { get; }
    [JsonPropertyNameAttribute("displayText")]
[JsonIgnoreAttribute]
public string DisplayText { get; }
    public CompletionResultMetadata(int start, int end, string text, string type, string displayText);
    private static CompletionResultMetadata();
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public string get_DisplayText();
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.CSharpLanguageInfo : LanguageInfo {
    public CSharpLanguageInfo(string version);
}
[JupyterMessageTypeAttribute("display_data")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.DisplayData : PubSubMessage {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Transient>k__BackingField;
    [JsonPropertyNameAttribute("source")]
[JsonIgnoreAttribute]
public string Source { get; }
    [JsonPropertyNameAttribute("data")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Data { get; }
    [JsonPropertyNameAttribute("metadata")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> MetaData { get; }
    [JsonPropertyNameAttribute("transient")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Transient { get; }
    public DisplayData(string source, IReadOnlyDictionary`2<string, object> data, IReadOnlyDictionary`2<string, object> metaData, IReadOnlyDictionary`2<string, object> transient);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_MetaData();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Transient();
}
[JupyterMessageTypeAttribute("error")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.Error : PubSubMessage {
    [CompilerGeneratedAttribute]
private string <EName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Traceback>k__BackingField;
    [JsonPropertyNameAttribute("ename")]
public string EName { get; }
    [JsonPropertyNameAttribute("evalue")]
public string EValue { get; }
    [JsonPropertyNameAttribute("traceback")]
public IReadOnlyList`1<string> Traceback { get; }
    public Error(string eValue, string eName, IReadOnlyList`1<string> traceback);
    [CompilerGeneratedAttribute]
public string get_EName();
    [CompilerGeneratedAttribute]
public string get_EValue();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Traceback();
}
[JupyterMessageTypeAttribute("execute_input")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ExecuteInput : PubSubMessage {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecutionCount>k__BackingField;
    [JsonPropertyNameAttribute("code")]
public string Code { get; }
    [JsonPropertyNameAttribute("execution_count")]
public int ExecutionCount { get; }
    public ExecuteInput(string code, int executionCount);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public int get_ExecutionCount();
}
[JupyterMessageTypeAttribute("execute_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ExecuteReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecutionCount>k__BackingField;
    [JsonPropertyNameAttribute("status")]
[JsonIgnoreAttribute]
public string Status { get; }
    [JsonPropertyNameAttribute("execution_count")]
public int ExecutionCount { get; }
    public ExecuteReply(string status, int executionCount);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public int get_ExecutionCount();
}
[JupyterMessageTypeAttribute("execute_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ExecuteReplyError : ExecuteReply {
    [CompilerGeneratedAttribute]
private string <EName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Traceback>k__BackingField;
    [JsonPropertyNameAttribute("ename")]
public string EName { get; }
    [JsonPropertyNameAttribute("evalue")]
public string EValue { get; }
    [JsonPropertyNameAttribute("traceback")]
public IReadOnlyList`1<string> Traceback { get; }
    [JsonConstructorAttribute]
public ExecuteReplyError(string eName, string eValue, int executionCount, IReadOnlyList`1<string> traceback);
    public ExecuteReplyError(Error error, int executionCount, IReadOnlyList`1<string> traceback);
    [CompilerGeneratedAttribute]
public string get_EName();
    [CompilerGeneratedAttribute]
public string get_EValue();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Traceback();
}
[JupyterMessageTypeAttribute("execute_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ExecuteReplyOk : ExecuteReply {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyDictionary`2<string, string>> <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <UserExpressions>k__BackingField;
    [JsonPropertyNameAttribute("payload")]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, string>> Payload { get; }
    [JsonPropertyNameAttribute("user_expressions")]
public IReadOnlyDictionary`2<string, string> UserExpressions { get; }
    public ExecuteReplyOk(IReadOnlyList`1<IReadOnlyDictionary`2<string, string>> payload, IReadOnlyDictionary`2<string, string> userExpressions, int executionCount);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyDictionary`2<string, string>> get_Payload();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_UserExpressions();
}
[JupyterMessageTypeAttribute("execute_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ExecuteRequest : RequestMessage {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Silent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StoreHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <UserExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowStdin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnError>k__BackingField;
    [JsonPropertyNameAttribute("code")]
public string Code { get; }
    [JsonPropertyNameAttribute("silent")]
public bool Silent { get; }
    [JsonPropertyNameAttribute("store_history")]
public bool StoreHistory { get; }
    [JsonPropertyNameAttribute("user_expressions")]
public IReadOnlyDictionary`2<string, string> UserExpressions { get; }
    [JsonPropertyNameAttribute("allow_stdin")]
public bool AllowStdin { get; }
    [JsonPropertyNameAttribute("stop_on_error")]
public bool StopOnError { get; }
    public ExecuteRequest(string code, bool silent, bool storeHistory, bool allowStdin, bool stopOnError, IReadOnlyDictionary`2<string, string> userExpressions);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public bool get_Silent();
    [CompilerGeneratedAttribute]
public bool get_StoreHistory();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_UserExpressions();
    [CompilerGeneratedAttribute]
public bool get_AllowStdin();
    [CompilerGeneratedAttribute]
public bool get_StopOnError();
}
[JupyterMessageTypeAttribute("execute_result")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ExecuteResult : PubSubMessage {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Transient>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecutionCount>k__BackingField;
    [JsonPropertyNameAttribute("source")]
[JsonIgnoreAttribute]
public string Source { get; }
    [JsonPropertyNameAttribute("data")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Data { get; }
    [JsonPropertyNameAttribute("metadata")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> MetaData { get; }
    [JsonPropertyNameAttribute("transient")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Transient { get; }
    [JsonPropertyNameAttribute("execution_count")]
public int ExecutionCount { get; }
    public ExecuteResult(int executionCount, string source, IReadOnlyDictionary`2<string, object> data, IReadOnlyDictionary`2<string, object> metaData, IReadOnlyDictionary`2<string, object> transient);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_MetaData();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Transient();
    [CompilerGeneratedAttribute]
public int get_ExecutionCount();
}
public static class Microsoft.DotNet.Interactive.Jupyter.Protocol.ExecutionStateValues : object {
    public static string Busy;
    public static string Idle;
    public static string Starting;
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.FSharpLanguageInfo : LanguageInfo {
    public FSharpLanguageInfo(string version);
}
public abstract class Microsoft.DotNet.Interactive.Jupyter.Protocol.HistoryElement : object {
    [CompilerGeneratedAttribute]
private int <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [JsonPropertyNameAttribute("session")]
public int Session { get; }
    [JsonPropertyNameAttribute("lineNumber")]
public int LineNumber { get; }
    protected HistoryElement(int session, int lineNumber);
    [CompilerGeneratedAttribute]
public int get_Session();
    [CompilerGeneratedAttribute]
public int get_LineNumber();
}
[JsonConverterAttribute("Microsoft.DotNet.Interactive.Jupyter.Protocol.HistoryReplyConverter")]
[JupyterMessageTypeAttribute("history_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.HistoryReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<HistoryElement> <History>k__BackingField;
    [JsonPropertyNameAttribute("history")]
public IReadOnlyList`1<HistoryElement> History { get; }
    public HistoryReply(IReadOnlyList`1<HistoryElement> history);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<HistoryElement> get_History();
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.HistoryReplyConverter : JsonConverter`1<HistoryReply> {
    public virtual HistoryReply Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private IReadOnlyList`1<HistoryElement> ReadHistoryElements(Utf8JsonReader& reader);
    public virtual void Write(Utf8JsonWriter writer, HistoryReply value, JsonSerializerOptions options);
    private static void Write(Utf8JsonWriter writer, InputHistoryElement inputHistoryElement);
    private static void Write(Utf8JsonWriter writer, InputOutputHistoryElement inputOutputHistoryElement);
}
[JupyterMessageTypeAttribute("history_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.HistoryRequest : RequestMessage {
    [CompilerGeneratedAttribute]
private bool <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Raw>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Stop>k__BackingField;
    [CompilerGeneratedAttribute]
private int <N>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unique>k__BackingField;
    [JsonPropertyNameAttribute("output")]
public bool Output { get; }
    [JsonPropertyNameAttribute("hist_access_type")]
public string AccessType { get; }
    [JsonPropertyNameAttribute("raw")]
public bool Raw { get; }
    [JsonPropertyNameAttribute("session")]
public int Session { get; }
    [JsonPropertyNameAttribute("start")]
public int Start { get; }
    [JsonPropertyNameAttribute("stop")]
public int Stop { get; }
    [JsonPropertyNameAttribute("n")]
public int N { get; }
    [JsonPropertyNameAttribute("pattern")]
public string Pattern { get; }
    [JsonPropertyNameAttribute("unique")]
public bool Unique { get; }
    public HistoryRequest(int session, string accessType, int start, int stop, int n, string pattern, bool unique, bool raw, bool output);
    [CompilerGeneratedAttribute]
public bool get_Output();
    [CompilerGeneratedAttribute]
public string get_AccessType();
    [CompilerGeneratedAttribute]
public bool get_Raw();
    [CompilerGeneratedAttribute]
public int get_Session();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Stop();
    [CompilerGeneratedAttribute]
public int get_N();
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public bool get_Unique();
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.InputHistoryElement : HistoryElement {
    [CompilerGeneratedAttribute]
private string <Input>k__BackingField;
    public string Input { get; }
    public InputHistoryElement(int session, int lineNumber, string input);
    [CompilerGeneratedAttribute]
public string get_Input();
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.InputOutputHistoryElement : InputHistoryElement {
    [CompilerGeneratedAttribute]
private string <Output>k__BackingField;
    public string Output { get; }
    public InputOutputHistoryElement(int session, int lineNumber, string input, string output);
    [CompilerGeneratedAttribute]
public string get_Output();
}
[JupyterMessageTypeAttribute("input_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.InputReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [JsonPropertyNameAttribute("value")]
public string Value { get; }
    public InputReply(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[JupyterMessageTypeAttribute("input_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.InputRequest : RequestMessage {
    [CompilerGeneratedAttribute]
private string <Prompt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Password>k__BackingField;
    [JsonPropertyNameAttribute("prompt")]
public string Prompt { get; }
    [JsonPropertyNameAttribute("password")]
public bool Password { get; public set; }
    public InputRequest(string prompt, bool password);
    [CompilerGeneratedAttribute]
public string get_Prompt();
    [CompilerGeneratedAttribute]
public bool get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(bool value);
}
[JupyterMessageTypeAttribute("inspect_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.InspectReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Found>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <MetaData>k__BackingField;
    [JsonPropertyNameAttribute("status")]
public string Status { get; }
    [JsonPropertyNameAttribute("found")]
public bool Found { get; }
    [JsonPropertyNameAttribute("data")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Data { get; }
    [JsonPropertyNameAttribute("metadata")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> MetaData { get; }
    public InspectReply(string status, bool found, IReadOnlyDictionary`2<string, object> data, IReadOnlyDictionary`2<string, object> metaData);
    public static InspectReply Ok(bool found, IReadOnlyDictionary`2<string, object> data, IReadOnlyDictionary`2<string, object> metaData);
    public static InspectReply Error(IReadOnlyDictionary`2<string, object> data, IReadOnlyDictionary`2<string, object> metaData);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public bool get_Found();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_MetaData();
}
[JupyterMessageTypeAttribute("inspect_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.InspectRequest : RequestMessage {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CursorPos>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DetailLevel>k__BackingField;
    [JsonPropertyNameAttribute("code")]
public string Code { get; }
    [JsonPropertyNameAttribute("cursor_pos")]
public int CursorPos { get; }
    [JsonPropertyNameAttribute("detail_level")]
public int DetailLevel { get; }
    public InspectRequest(string code, int cursorPos, int detailLevel);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public int get_CursorPos();
    [CompilerGeneratedAttribute]
public int get_DetailLevel();
}
[JupyterMessageTypeAttribute("interrupt_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.InterruptReply : ReplyMessage {
}
[JupyterMessageTypeAttribute("interrupt_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.InterruptRequest : RequestMessage {
}
[JupyterMessageTypeAttribute("is_complete_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.IsCompleteReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    [JsonPropertyNameAttribute("status")]
public string Status { get; }
    [JsonPropertyNameAttribute("indent")]
public string Indent { get; }
    public IsCompleteReply(string indent, string status);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public string get_Indent();
}
[JupyterMessageTypeAttribute("is_complete_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.IsCompleteRequest : RequestMessage {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [JsonPropertyNameAttribute("code")]
public string Code { get; public set; }
    public IsCompleteRequest(string code);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.JupyterMessageContentTypes : object {
    public static string ExecuteRequest;
    public static string ExecuteReply;
    public static string ExecuteResult;
    public static string ExecuteInput;
    public static string KernelInfoRequest;
    public static string KernelInfoReply;
    public static string KernelShutdownRequest;
    public static string KernelShutdownReply;
    public static string CompleteRequest;
    public static string CompleteReply;
    public static string IsCompleteRequest;
    public static string IsCompleteReply;
    public static string Status;
    public static string Stream;
    public static string Error;
    public static string DisplayData;
    public static string UpdateDisplayData;
    public static string InspectRequest;
    public static string InspectReply;
    public static string HistoryRequest;
    public static string HistoryReply;
    public static string ClearOutput;
    public static string InputRequest;
    public static string InputReply;
    public static string CommOpen;
    public static string CommClose;
    public static string CommMsg;
    public static string CommInfoRequest;
    public static string CommInfoReply;
    public static string InterruptRequest;
    public static string InterruptReply;
}
[AttributeUsageAttribute("4")]
internal class Microsoft.DotNet.Interactive.Jupyter.Protocol.JupyterMessageTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public string Type { get; }
    public JupyterMessageTypeAttribute(string messageType);
    [CompilerGeneratedAttribute]
public string get_Type();
}
[JupyterMessageTypeAttribute("kernel_info_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.KernelInfoReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private string <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Implementation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImplementationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private LanguageInfo <LanguageInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Banner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Link> <HelpLinks>k__BackingField;
    [JsonPropertyNameAttribute("protocol_version")]
public string ProtocolVersion { get; }
    [JsonPropertyNameAttribute("implementation")]
public string Implementation { get; }
    [JsonPropertyNameAttribute("implementation_version")]
public string ImplementationVersion { get; }
    [JsonPropertyNameAttribute("language_info")]
[JsonIgnoreAttribute]
public LanguageInfo LanguageInfo { get; }
    [JsonPropertyNameAttribute("banner")]
public string Banner { get; }
    [JsonPropertyNameAttribute("status")]
public string Status { get; }
    [JsonPropertyNameAttribute("help_links")]
public IReadOnlyList`1<Link> HelpLinks { get; }
    public KernelInfoReply(string protocolVersion, string implementation, string implementationVersion, LanguageInfo languageInfo, string banner, IReadOnlyList`1<Link> helpLinks);
    [CompilerGeneratedAttribute]
public string get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public string get_Implementation();
    [CompilerGeneratedAttribute]
public string get_ImplementationVersion();
    [CompilerGeneratedAttribute]
public LanguageInfo get_LanguageInfo();
    [CompilerGeneratedAttribute]
public string get_Banner();
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Link> get_HelpLinks();
}
[JupyterMessageTypeAttribute("kernel_info_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.KernelInfoRequest : RequestMessage {
}
[JupyterMessageTypeAttribute("shutdown_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.KernelShutdownReply : ReplyMessage {
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.LanguageInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PygmentsLexer>k__BackingField;
    [CompilerGeneratedAttribute]
private object <CodeMirrorMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NbConvertExporter>k__BackingField;
    [JsonPropertyNameAttribute("name")]
public string Name { get; }
    [JsonPropertyNameAttribute("version")]
public string Version { get; }
    [JsonPropertyNameAttribute("mimetype")]
public string MimeType { get; }
    [JsonPropertyNameAttribute("file_extension")]
public string FileExtension { get; }
    [JsonPropertyNameAttribute("pygments_lexer")]
public string PygmentsLexer { get; }
    [JsonPropertyNameAttribute("codemirror_mode")]
[JsonIgnoreAttribute]
public object CodeMirrorMode { get; public set; }
    [JsonPropertyNameAttribute("nbconvert_exporter")]
[JsonIgnoreAttribute]
public string NbConvertExporter { get; }
    public LanguageInfo(string name, string version, string mimeType, string fileExtension, string pygmentsLexer, object codeMirrorMode, string nbConvertExporter);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_MimeType();
    [CompilerGeneratedAttribute]
public string get_FileExtension();
    [CompilerGeneratedAttribute]
public string get_PygmentsLexer();
    [CompilerGeneratedAttribute]
public object get_CodeMirrorMode();
    [CompilerGeneratedAttribute]
public void set_CodeMirrorMode(object value);
    [CompilerGeneratedAttribute]
public string get_NbConvertExporter();
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.Link : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [JsonPropertyNameAttribute("text")]
public string Text { get; public set; }
    [JsonPropertyNameAttribute("url")]
public string Url { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
public abstract class Microsoft.DotNet.Interactive.Jupyter.Protocol.Message : object {
    private static IReadOnlyDictionary`2<string, Type> _messageTypeToClrType;
    private static IReadOnlyDictionary`2<Type, string> _clrTypeToMessageType;
    private string _messageType;
    [CompilerGeneratedAttribute]
private static Message <Empty>k__BackingField;
    [JsonIgnoreAttribute]
public string MessageType { get; }
    public static Message Empty { get; }
    private static Message();
    public string get_MessageType();
    public static Message FromJsonString(string jsonString, string messageType);
    public static Message TryFromJsonString(string jsonString, string messageType);
    [CompilerGeneratedAttribute]
public static Message get_Empty();
    public static string GetMessageType(Message source);
    public static string GetMessageType(Type type);
}
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.PowerShellLanguageInfo : LanguageInfo {
    public PowerShellLanguageInfo(string version);
}
public abstract class Microsoft.DotNet.Interactive.Jupyter.Protocol.PubSubMessage : Message {
}
public abstract class Microsoft.DotNet.Interactive.Jupyter.Protocol.ReplyMessage : Message {
}
public abstract class Microsoft.DotNet.Interactive.Jupyter.Protocol.RequestMessage : Message {
}
[JupyterMessageTypeAttribute("shutdown_reply")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ShutdownReply : ReplyMessage {
    [CompilerGeneratedAttribute]
private bool <Restart>k__BackingField;
    [JsonPropertyNameAttribute("restart")]
public bool Restart { get; }
    public ShutdownReply(bool restart);
    [CompilerGeneratedAttribute]
public bool get_Restart();
}
[JupyterMessageTypeAttribute("shutdown_request")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.ShutdownRequest : RequestMessage {
    [CompilerGeneratedAttribute]
private bool <Restart>k__BackingField;
    [JsonPropertyNameAttribute("restart")]
public bool Restart { get; }
    public ShutdownRequest(bool restart);
    [CompilerGeneratedAttribute]
public bool get_Restart();
}
[JupyterMessageTypeAttribute("status")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.Status : PubSubMessage {
    [CompilerGeneratedAttribute]
private string <ExecutionState>k__BackingField;
    [JsonPropertyNameAttribute("execution_state")]
public string ExecutionState { get; }
    public Status(string executionState);
    [CompilerGeneratedAttribute]
public string get_ExecutionState();
}
public static class Microsoft.DotNet.Interactive.Jupyter.Protocol.StatusValues : object {
    public static string Ok;
    public static string Error;
    public static string Abort;
    public static string Busy;
    public static string Idle;
    public static string Starting;
}
[JupyterMessageTypeAttribute("stream")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.Stream : PubSubMessage {
    [CompilerGeneratedAttribute]
private static string <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <StandardOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [JsonIgnoreAttribute]
public static string StandardError { get; }
    [JsonIgnoreAttribute]
public static string StandardOutput { get; }
    [JsonPropertyNameAttribute("name")]
public string Name { get; }
    [JsonPropertyNameAttribute("text")]
public string Text { get; }
    public Stream(string name, string text);
    private static Stream();
    [CompilerGeneratedAttribute]
public static string get_StandardError();
    [CompilerGeneratedAttribute]
public static string get_StandardOutput();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Text();
    public static Stream StdErr(string text);
    public static Stream StdOut(string text);
}
[JupyterMessageTypeAttribute("update_display_data")]
public class Microsoft.DotNet.Interactive.Jupyter.Protocol.UpdateDisplayData : PubSubMessage {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Transient>k__BackingField;
    [JsonPropertyNameAttribute("source")]
[JsonIgnoreAttribute]
public string Source { get; }
    [JsonPropertyNameAttribute("data")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Data { get; }
    [JsonPropertyNameAttribute("metadata")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> MetaData { get; }
    [JsonPropertyNameAttribute("transient")]
[JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, object> Transient { get; }
    public UpdateDisplayData(string source, IReadOnlyDictionary`2<string, object> data, IReadOnlyDictionary`2<string, object> metaData, IReadOnlyDictionary`2<string, object> transient);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_MetaData();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Transient();
}
public abstract class Microsoft.DotNet.Interactive.Jupyter.RequestHandlerBase`1 : object {
    private CompositeDisposable _disposables;
    [CompilerGeneratedAttribute]
private IObservable`1<KernelEvent> <KernelEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private Kernel <Kernel>k__BackingField;
    protected IObservable`1<KernelEvent> KernelEvents { get; }
    protected Kernel Kernel { get; }
    protected RequestHandlerBase`1(Kernel kernel, IScheduler scheduler);
    [CompilerGeneratedAttribute]
protected IObservable`1<KernelEvent> get_KernelEvents();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.RequestHandlerBase`1/<SendAsync>d__5")]
protected Task SendAsync(JupyterRequestContext jupyterContext, KernelCommand command);
    protected abstract virtual void OnKernelEventReceived(KernelEvent event, JupyterRequestContext context);
    protected static T GetJupyterRequest(JupyterRequestContext context);
    [CompilerGeneratedAttribute]
protected Kernel get_Kernel();
    public sealed virtual void Dispose();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.DotNet.Interactive.Jupyter.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Magics_lsmagic_Description { get; }
    internal static string Magics_markdown_Description { get; }
    internal static string Magics_time_Description { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Magics_lsmagic_Description();
    internal static string get_Magics_markdown_Description();
    internal static string get_Magics_time_Description();
}
public class Microsoft.DotNet.Interactive.Jupyter.Shell : object {
    private Kernel _kernel;
    private JupyterRequestContextScheduler _scheduler;
    private IHostApplicationLifetime _applicationLifetime;
    private RouterSocket _shell;
    private PublisherSocket _ioPubSocket;
    private string _shellAddress;
    private string _ioPubAddress;
    private CompositeDisposable _disposables;
    private RequestReplyChannel _shellChannel;
    private PubSubChannel _ioPubChannel;
    private StdInChannel _stdInChannel;
    private string _stdInAddress;
    private string _controlAddress;
    private RouterSocket _stdIn;
    private RouterSocket _control;
    private RequestReplyChannel _controlChannel;
    private string _kernelIdentity;
    public Shell(Kernel kernel, JupyterRequestContextScheduler scheduler, ConnectionInformation connectionInformation, IHostApplicationLifetime applicationLifetime);
    public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    private void ControlChannelLoop(CancellationToken cancellationToken);
    private void ShellChannelLoop(CancellationToken cancellationToken);
    private void SetBusy(Message request);
    private void SetIdle(Message request);
    public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    private void HandleKernelInfoRequest(Message request);
    private LanguageInfo GetLanguageInfo();
    private LanguageInfo GetLanguageInfo(string kernelName);
}
public class Microsoft.DotNet.Interactive.Jupyter.ShutdownRequestHandler : RequestHandlerBase`1<ShutdownRequest> {
    public ShutdownRequestHandler(Kernel kernel, IScheduler scheduler);
    protected virtual void OnKernelEventReceived(KernelEvent event, JupyterRequestContext context);
    public Task Handle(JupyterRequestContext context);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Jupyter.StringUtilities : object {
    [ExtensionAttribute]
public static string NormalizeLineEndings(string source);
    [ExtensionAttribute]
public static string StripUnsupportedTextFormats(string source);
}
public class Microsoft.DotNet.Interactive.Jupyter.SupportedDirectives : object {
    [CompilerGeneratedAttribute]
private string <KernelName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Command> <Commands>k__BackingField;
    public string KernelName { get; }
    public IReadOnlyList`1<Command> Commands { get; }
    public SupportedDirectives(string kernelName, IReadOnlyList`1<Command> commands);
    [CompilerGeneratedAttribute]
public string get_KernelName();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Command> get_Commands();
}
public static class Microsoft.DotNet.Interactive.Jupyter.TopLevelMethods : object {
    public static string input(string prompt);
    public static PasswordString password(string prompt);
}
internal class Microsoft.DotNet.Interactive.Jupyter.ZMQ.JupyterConnection : object {
    private IJupyterKernelSpecModule _kernelSpecModule;
    private Task`1<IReadOnlyDictionary`2<string, KernelSpec>> _getKernelSpecs;
    public JupyterConnection(IJupyterKernelSpecModule kernelSpecModule);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.ZMQ.JupyterConnection/<GetKernelSpecsAsync>d__3")]
public sealed virtual Task`1<IEnumerable`1<KernelSpec>> GetKernelSpecsAsync();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.ZMQ.JupyterConnection/<CreateKernelConnectionAsync>d__4")]
public sealed virtual Task`1<IJupyterKernelConnection> CreateKernelConnectionAsync(string kernelSpecName);
    private Process CreateKernelProcess(KernelSpec spec, string connectionFilePath);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Jupyter.ZMQ.JupyterConnection/<GetKernelSpecAsync>d__6")]
private Task`1<KernelSpec> GetKernelSpecAsync(string kernelSpecName);
}
internal class Microsoft.DotNet.Interactive.Jupyter.ZMQ.JupyterMessageResponseSender : object {
    private PubSubChannel _pubSubChannel;
    private RequestReplyChannel _shellChannel;
    private StdInChannel _stdInChannel;
    private string _kernelIdentity;
    private Message _request;
    public JupyterMessageResponseSender(PubSubChannel pubSubChannel, RequestReplyChannel shellChannel, StdInChannel stdInChannel, string kernelIdentity, Message request);
    public sealed virtual void Send(PubSubMessage message);
    public sealed virtual void Send(ReplyMessage message);
    public sealed virtual string Send(InputRequest message);
}
public class Microsoft.DotNet.Interactive.Jupyter.ZMQ.MessageReceiver : object {
    private NetMQSocket _socket;
    public MessageReceiver(NetMQSocket socket);
    public Message Receive();
}
public class Microsoft.DotNet.Interactive.Jupyter.ZMQ.MessageSender : object {
    private IOutgoingSocket _socket;
    private SignatureValidator _signatureValidator;
    private Encoding _enc;
    private object _lock;
    public MessageSender(IOutgoingSocket socket, SignatureValidator signatureValidator);
    public void Send(Message message);
    private Byte[] Encode(object val);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Jupyter.ZMQ.NetMQExtensions : object {
    [ExtensionAttribute]
public static Message GetMessage(NetMQSocket socket);
}
internal class Microsoft.DotNet.Interactive.Jupyter.ZMQ.PubSubChannel : object {
    private MessageSender _sender;
    public PubSubChannel(MessageSender sender);
    public void Publish(PubSubMessage message, Message request, string kernelIdentity);
}
internal class Microsoft.DotNet.Interactive.Jupyter.ZMQ.RequestReplyChannel : object {
    private MessageSender _sender;
    private string channel;
    public RequestReplyChannel(MessageSender sender, string channel);
    public void Reply(ReplyMessage message, Message request);
    public void Send(Message message);
}
public class Microsoft.DotNet.Interactive.Jupyter.ZMQ.SignatureValidator : object {
    private HMAC _signatureGenerator;
    private object _gate;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; }
    public SignatureValidator(string key, string algorithm);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    public string CreateSignature(Byte[][] data);
}
internal class Microsoft.DotNet.Interactive.Jupyter.ZMQ.StdInChannel : object {
    private MessageSender _sender;
    private MessageReceiver _receiver;
    public StdInChannel(MessageSender sender, MessageReceiver receiver);
    public string RequestInput(InputRequest message, Message request);
    public void Send(Message message);
}
internal class Microsoft.DotNet.Interactive.Jupyter.ZMQ.TcpPortReservations : object {
    private List`1<TcpListener> _reservations;
    private Int32[] _ports;
    public Int32[] Ports { get; }
    private TcpPortReservations(List`1<TcpListener> reservations);
    public sealed virtual void Dispose();
    public static TcpPortReservations ReserveFreePorts(int numberOfPortsToReserve);
    public void FreeReservations();
    public Int32[] get_Ports();
}
internal class Microsoft.DotNet.Interactive.Jupyter.ZMQ.ZMQKernelConnection : object {
    private DealerSocket _shell;
    private SubscriberSocket _ioSubSocket;
    private string _shellAddress;
    private string _ioSubAddress;
    private CompositeDisposable _disposables;
    private RequestReplyChannel _shellChannel;
    private RequestReplyChannel _controlChannel;
    private StdInChannel _stdInChannel;
    private string _stdInAddress;
    private string _controlAddress;
    private DealerSocket _stdIn;
    private DealerSocket _control;
    private Subject`1<Message> _subject;
    private CancellationTokenSource _cancellationTokenSource;
    private Process _kernelProcess;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    public Uri Uri { get; }
    public IObservable`1<Message> Messages { get; }
    public IMessageSender Sender { get; }
    public IMessageReceiver Receiver { get; }
    public ZMQKernelConnection(ConnectionInformation connectionInformation, Process kernelProcess, string kernelSpecName);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Uri();
    public sealed virtual IObservable`1<Message> get_Messages();
    public sealed virtual IMessageSender get_Sender();
    public sealed virtual IMessageReceiver get_Receiver();
    public sealed virtual void Dispose();
    public sealed virtual Task SendAsync(Message message);
    public sealed virtual Task StartAsync();
    private Task StartListening(NetMQSocket socket, CancellationToken cancellationToken);
    private bool TryHandle(Message message);
    private bool InterruptKernel();
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Utility.InvocationContextExtensions : object {
    [ExtensionAttribute]
public static T GetService(InvocationContext context);
}
[DebuggerStepThroughAttribute]
internal class Pocket.ConfirmationLogger : OperationLogger {
    public ConfirmationLogger(string operationName, string category, string message, Func`1<ValueTuple`2[]> exitArgs, bool logOnStart, Object[] args);
    public void Fail(Exception exception, string message, Object[] args);
    public void Succeed(string message, Object[] args);
    public virtual void Dispose();
}
[ExtensionAttribute]
internal static class Pocket.Format : object {
    [ExtensionAttribute]
public static ValueTuple`2<string, ValueTuple`2[]> Evaluate(ValueTuple`8& e);
    [ExtensionAttribute]
public static string ToLogString(ValueTuple`8& e);
    [ExtensionAttribute]
internal static string ToLogString(object value);
    [ExtensionAttribute]
private static string IfNotEmpty(string value, string prefix, string suffix);
    private static string LogLevelString(LogLevel logLevel, bool isStartOfOperation, bool isEndOfOperation, Nullable`1<bool> isOperationSuccessful, Nullable`1<TimeSpan> duration);
    [CompilerGeneratedAttribute]
internal static string <LogLevelString>g__symbol|5_0(<>c__DisplayClass5_0& );
}
[DebuggerStepThroughAttribute]
internal class Pocket.Formatter : object {
    private static ConcurrentDictionary`2<string, Formatter> cache;
    private static bool stopCaching;
    private static int cacheCount;
    private static Regex tokenRegex;
    private string template;
    private List`1<Action`2<StringBuilder, object>> argumentFormatters;
    private List`1<string> tokens;
    [CompilerGeneratedAttribute]
private static int <CacheLimit>k__BackingField;
    public IReadOnlyList`1<string> Tokens { get; }
    public static int CacheCount { get; }
    public static int CacheLimit { get; public set; }
    private static Formatter();
    public Formatter(string template);
    public IReadOnlyList`1<string> get_Tokens();
    public FormatterResult Format(IReadOnlyList`1<object> args, IList`1<ValueTuple`2<string, object>> knownProperties);
    public FormatterResult Format(Object[] args);
    public static int get_CacheCount();
    [CompilerGeneratedAttribute]
public static int get_CacheLimit();
    [CompilerGeneratedAttribute]
public static void set_CacheLimit(int value);
    public static Formatter Parse(string template);
    [CompilerGeneratedAttribute]
internal static void <Format>g__TryAppendComma|11_0(<>c__DisplayClass11_0& , <>c__DisplayClass11_1& );
    [CompilerGeneratedAttribute]
internal static Formatter <Parse>g__CreateFormatter|19_0(string t);
}
[DebuggerStepThroughAttribute]
internal class Pocket.LogEntry : object {
    [CompilerGeneratedAttribute]
private bool <IsStartOfOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsOperationSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEndOfOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationLogger <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimestampUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageTemplate>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`2<string, object>> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public bool IsStartOfOperation { get; }
    public Nullable`1<bool> IsOperationSuccessful { get; }
    public bool IsEndOfOperation { get; }
    public Nullable`1<TimeSpan> OperationDuration { get; }
    public string OperationName { get; }
    public string Category { get; }
    public OperationLogger Operation { get; }
    public DateTime TimestampUtc { get; }
    public LogLevel LogLevel { get; }
    public Exception Exception { get; }
    public string OperationId { get; }
    public string MessageTemplate { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<string, object>> Properties { get; public set; }
    public Object[] Args { get; public set; }
    public LogEntry(LogLevel logLevel, string messageTemplate, Exception exception, string category, string operationName, OperationLogger operation, Object[] args);
    [CompilerGeneratedAttribute]
public bool get_IsStartOfOperation();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsOperationSuccessful();
    [CompilerGeneratedAttribute]
public bool get_IsEndOfOperation();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationDuration();
    [CompilerGeneratedAttribute]
public string get_OperationName();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public OperationLogger get_Operation();
    [CompilerGeneratedAttribute]
public DateTime get_TimestampUtc();
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_OperationId();
    [CompilerGeneratedAttribute]
public string get_MessageTemplate();
    [CompilerGeneratedAttribute]
public void set_MessageTemplate(string value);
    [CompilerGeneratedAttribute]
public List`1<ValueTuple`2<string, object>> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(List`1<ValueTuple`2<string, object>> value);
    [CompilerGeneratedAttribute]
public Object[] get_Args();
    [CompilerGeneratedAttribute]
public void set_Args(Object[] value);
    public void AddProperty(ValueTuple`2<string, object> property);
}
[DebuggerStepThroughAttribute]
internal class Pocket.Logger : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Action`1<Action`1<ValueTuple`2<string, object>>> Enrich;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> Posted;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private static Logger <Log>k__BackingField;
    public string Category { get; }
    public static Logger Log { get; }
    public Logger(string category);
    private static Logger();
    [CompilerGeneratedAttribute]
public static void add_Enrich(Action`1<Action`1<ValueTuple`2<string, object>>> value);
    [CompilerGeneratedAttribute]
public static void remove_Enrich(Action`1<Action`1<ValueTuple`2<string, object>>> value);
    [CompilerGeneratedAttribute]
public static void add_Posted(Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> value);
    [CompilerGeneratedAttribute]
public static void remove_Posted(Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> value);
    public virtual void Post(LogEntry entry);
    protected internal void Post(string message, LogLevel logLevel, string operationName, Exception exception, Object[] args, ValueTuple`2[]& properties);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public static Logger get_Log();
}
[DebuggerStepThroughAttribute]
internal class Pocket.Logger`1 : Logger {
    [CompilerGeneratedAttribute]
private static Logger <Log>k__BackingField;
    public static Logger Log { get; }
    private static Logger`1();
    [CompilerGeneratedAttribute]
public static Logger get_Log();
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
internal static class Pocket.LoggerExtensions : object {
    [ExtensionAttribute]
public static TLogger Trace(TLogger logger, string message, Object[] args);
    [ExtensionAttribute]
public static TLogger Trace(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Info(TLogger logger, string message, Object[] args);
    [ExtensionAttribute]
public static TLogger Info(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, string message, Exception exception, Object[] args);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, Exception exception);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, string message, Exception exception, Object[] args);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, Exception exception);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static OperationLogger OnEnterAndExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static OperationLogger OnEnterAndExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static OperationLogger OnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static OperationLogger OnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static ConfirmationLogger ConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static ConfirmationLogger ConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static ConfirmationLogger OnEnterAndConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static ConfirmationLogger OnEnterAndConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static void Event(Logger logger, string name);
    [ExtensionAttribute]
public static void Event(Logger logger, string name, ValueTuple`2[] metrics);
    [ExtensionAttribute]
public static void Event(Logger logger, string name, ValueTuple`2[] properties);
    [ExtensionAttribute]
public static void Event(Logger logger, ValueTuple`2[]& metrics, ValueTuple`2[]& properties, string name);
}
internal enum Pocket.LogLevel : Enum {
    public byte value__;
    public static LogLevel Telemetry;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Information;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Critical;
}
[DebuggerStepThroughAttribute]
internal class Pocket.OperationLogger : Logger {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<ValueTuple`2[]> exitArgs;
    private LogEntry initialEntry;
    private bool disposed;
    private Activity activity;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStarting>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSuccessful>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public TimeSpan Duration { get; }
    public bool IsComplete { get; private set; }
    public bool IsStarting { get; }
    public Nullable`1<bool> IsSuccessful { get; protected set; }
    public OperationLogger(string operationName, string category, string message, Func`1<ValueTuple`2[]> exitArgs, bool logOnStart, Object[] args);
    public string get_Id();
    public string get_Name();
    public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
private void set_IsComplete(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStarting();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSuccessful();
    [CompilerGeneratedAttribute]
protected void set_IsSuccessful(Nullable`1<bool> value);
    public virtual void Post(LogEntry entry);
    protected void Complete(string message, Exception exception, Object[] args);
    public virtual void Dispose();
    protected virtual void Finalize();
}
internal class Recipes.BareObjectConverter : JsonConverter`1<object> {
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
}
[ExtensionAttribute]
internal static class Recipes.JsonSerializationExtensions : object {
    [CompilerGeneratedAttribute]
private static JsonSerializerOptions <SerializerOptions>k__BackingField;
    public static JsonSerializerOptions SerializerOptions { get; }
    private static JsonSerializationExtensions();
    [CompilerGeneratedAttribute]
public static JsonSerializerOptions get_SerializerOptions();
    [ExtensionAttribute]
public static string ToJson(object source);
    [ExtensionAttribute]
public static T FromJsonTo(string json);
    [ExtensionAttribute]
public static object FromJsonTo(string json, Type type, JsonSerializerOptions options);
}
