public class Microsoft.PackageManagement.Archivers.Internal.CabArchiver : object {
    private static Dictionary`2<string, String[]> _features;
    public string ArchiverName { get; }
    public string ProviderVersion { get; }
    private static CabArchiver();
    public void GetFeatures(Request request);
    public string get_ArchiverName();
    public string get_ProviderVersion();
    public IEnumerable`1<string> UnpackArchive(string localFilename, string destinationFolder, Request request);
    public bool IsSupportedFile(string localFilename);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.ArchiveException : IOException {
    public ArchiveException(string message, Exception innerException);
    public ArchiveException(string message);
}
public abstract class Microsoft.PackageManagement.Archivers.Internal.Compression.ArchiveFileInfo : FileSystemInfo {
    private ArchiveInfo archiveInfo;
    private string name;
    private string path;
    private bool initialized;
    private bool exists;
    private int archiveNumber;
    private FileAttributes attributes;
    private DateTime lastWriteTime;
    private long length;
    public string Name { get; }
    public string Path { get; }
    public string FullName { get; }
    public string FullNameExtension { get; }
    public ArchiveInfo Archive { get; internal set; }
    public string ArchiveName { get; }
    public int ArchiveNumber { get; }
    public bool Exists { get; }
    public long Length { get; }
    public FileAttributes Attributes { get; }
    public DateTime LastWriteTime { get; }
    protected ArchiveFileInfo(ArchiveInfo archiveInfo, string filePath);
    protected ArchiveFileInfo(string filePath, int archiveNumber, FileAttributes attributes, DateTime lastWriteTime, long length);
    public virtual string get_Name();
    public string get_Path();
    public virtual string get_FullName();
    public string get_FullNameExtension();
    public ArchiveInfo get_Archive();
    internal void set_Archive(ArchiveInfo value);
    public string get_ArchiveName();
    public int get_ArchiveNumber();
    public virtual bool get_Exists();
    public long get_Length();
    public FileAttributes get_Attributes();
    public DateTime get_LastWriteTime();
    public virtual string ToString();
    public virtual void Delete();
    public void Refresh();
    public void CopyTo(string destFileName);
    public void CopyTo(string destFileName, bool overwrite);
    public Stream OpenRead();
    public StreamReader OpenText();
    protected virtual void Refresh(ArchiveFileInfo newFileInfo);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.ArchiveFileStreamContext : object {
    private IList`1<string> archiveFiles;
    private string directory;
    private IDictionary`2<string, string> files;
    private bool extractOnlyNewerFiles;
    private bool enableOffsetOpen;
    public IList`1<string> ArchiveFiles { get; }
    public string Directory { get; }
    public IDictionary`2<string, string> Files { get; }
    public bool ExtractOnlyNewerFiles { get; public set; }
    public bool EnableOffsetOpen { get; public set; }
    public ArchiveFileStreamContext(string archiveFile);
    public ArchiveFileStreamContext(string archiveFile, string directory, IDictionary`2<string, string> files);
    public ArchiveFileStreamContext(IList`1<string> archiveFiles, string directory, IDictionary`2<string, string> files);
    public IList`1<string> get_ArchiveFiles();
    public string get_Directory();
    public IDictionary`2<string, string> get_Files();
    public bool get_ExtractOnlyNewerFiles();
    public void set_ExtractOnlyNewerFiles(bool value);
    public bool get_EnableOffsetOpen();
    public void set_EnableOffsetOpen(bool value);
    public virtual string GetArchiveName(int archiveNumber);
    public virtual Stream OpenArchiveWriteStream(int archiveNumber, string archiveName, bool truncate, CompressionEngine compressionEngine);
    public virtual void CloseArchiveWriteStream(int archiveNumber, string archiveName, Stream stream);
    public virtual Stream OpenFileReadStream(string path, FileAttributes& attributes, DateTime& lastWriteTime);
    public virtual void CloseFileReadStream(string path, Stream stream);
    public virtual object GetOption(string optionName, Object[] parameters);
    public virtual Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);
    public virtual void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);
    public virtual Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);
    public virtual void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
    private string TranslateFilePath(string path);
}
public abstract class Microsoft.PackageManagement.Archivers.Internal.Compression.ArchiveInfo : FileSystemInfo {
    public DirectoryInfo Directory { get; }
    public string DirectoryName { get; }
    public long Length { get; }
    public string Name { get; }
    public bool Exists { get; }
    protected ArchiveInfo(string path);
    public DirectoryInfo get_Directory();
    public string get_DirectoryName();
    public long get_Length();
    public virtual string get_Name();
    public virtual bool get_Exists();
    public virtual string ToString();
    public virtual void Delete();
    public void CopyTo(string destFileName);
    public void CopyTo(string destFileName, bool overwrite);
    public void MoveTo(string destFileName);
    public bool IsValid();
    public IList`1<ArchiveFileInfo> GetFiles();
    public IList`1<ArchiveFileInfo> GetFiles(string searchPattern);
    public void Unpack(string destDirectory);
    public void Unpack(string destDirectory, EventHandler`1<ArchiveProgressEventArgs> progressHandler);
    public void UnpackFile(string fileName, string destFileName);
    public void UnpackFiles(IList`1<string> fileNames, string destDirectory, IList`1<string> destFileNames);
    public void UnpackFiles(IList`1<string> fileNames, string destDirectory, IList`1<string> destFileNames, EventHandler`1<ArchiveProgressEventArgs> progressHandler);
    public void UnpackFileSet(IDictionary`2<string, string> fileNames, string destDirectory);
    public void UnpackFileSet(IDictionary`2<string, string> fileNames, string destDirectory, EventHandler`1<ArchiveProgressEventArgs> progressHandler);
    public Stream OpenRead(string fileName);
    public StreamReader OpenText(string fileName);
    public void Pack(string sourceDirectory);
    public void Pack(string sourceDirectory, bool includeSubdirectories, CompressionLevel compLevel, EventHandler`1<ArchiveProgressEventArgs> progressHandler);
    public void PackFiles(string sourceDirectory, IList`1<string> sourceFileNames, IList`1<string> fileNames);
    public void PackFiles(string sourceDirectory, IList`1<string> sourceFileNames, IList`1<string> fileNames, CompressionLevel compLevel, EventHandler`1<ArchiveProgressEventArgs> progressHandler);
    public void PackFileSet(string sourceDirectory, IDictionary`2<string, string> fileNames);
    public void PackFileSet(string sourceDirectory, IDictionary`2<string, string> fileNames, CompressionLevel compLevel, EventHandler`1<ArchiveProgressEventArgs> progressHandler);
    internal IList`1<string> GetRelativeFilePathsInDirectoryTree(string dir, bool includeSubdirectories);
    internal ArchiveFileInfo GetFile(string path);
    protected abstract virtual CompressionEngine CreateCompressionEngine();
    private static IDictionary`2<string, string> CreateStringDictionary(IList`1<string> keys, IList`1<string> values);
    private void RecursiveGetRelativeFilePathsInDirectoryTree(string dir, string relativeDir, bool includeSubdirectories, IList`1<string> fileList);
    private IList`1<ArchiveFileInfo> InternalGetFiles(Predicate`1<string> fileFilter);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.ArchiveProgressEventArgs : EventArgs {
    private ArchiveProgressType progressType;
    private string currentFileName;
    private int currentFileNumber;
    private int totalFiles;
    private long currentFileBytesProcessed;
    private long currentFileTotalBytes;
    private string currentArchiveName;
    private short currentArchiveNumber;
    private short totalArchives;
    private long currentArchiveBytesProcessed;
    private long currentArchiveTotalBytes;
    private long fileBytesProcessed;
    private long totalFileBytes;
    public ArchiveProgressType ProgressType { get; }
    public string CurrentFileName { get; }
    public int CurrentFileNumber { get; }
    public int TotalFiles { get; }
    public long CurrentFileBytesProcessed { get; }
    public long CurrentFileTotalBytes { get; }
    public string CurrentArchiveName { get; }
    public int CurrentArchiveNumber { get; }
    public int TotalArchives { get; }
    public long CurrentArchiveBytesProcessed { get; }
    public long CurrentArchiveTotalBytes { get; }
    public long FileBytesProcessed { get; }
    public long TotalFileBytes { get; }
    public ArchiveProgressEventArgs(ArchiveProgressType progressType, string currentFileName, int currentFileNumber, int totalFiles, long currentFileBytesProcessed, long currentFileTotalBytes, string currentArchiveName, int currentArchiveNumber, int totalArchives, long currentArchiveBytesProcessed, long currentArchiveTotalBytes, long fileBytesProcessed, long totalFileBytes);
    public ArchiveProgressType get_ProgressType();
    public string get_CurrentFileName();
    public int get_CurrentFileNumber();
    public int get_TotalFiles();
    public long get_CurrentFileBytesProcessed();
    public long get_CurrentFileTotalBytes();
    public string get_CurrentArchiveName();
    public int get_CurrentArchiveNumber();
    public int get_TotalArchives();
    public long get_CurrentArchiveBytesProcessed();
    public long get_CurrentArchiveTotalBytes();
    public long get_FileBytesProcessed();
    public long get_TotalFileBytes();
}
public enum Microsoft.PackageManagement.Archivers.Internal.Compression.ArchiveProgressType : Enum {
    public int value__;
    public static ArchiveProgressType StartFile;
    public static ArchiveProgressType PartialFile;
    public static ArchiveProgressType FinishFile;
    public static ArchiveProgressType StartArchive;
    public static ArchiveProgressType PartialArchive;
    public static ArchiveProgressType FinishArchive;
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.BasicUnpackStreamContext : object {
    private Stream archiveStream;
    private Stream fileStream;
    public Stream FileStream { get; }
    public BasicUnpackStreamContext(Stream archiveStream);
    public Stream get_FileStream();
    public sealed virtual Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);
    public sealed virtual void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);
    public sealed virtual Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);
    public sealed virtual void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.CabEngine : CompressionEngine {
    private CabPacker packer;
    private CabUnpacker unpacker;
    private CabPacker Packer { get; }
    private CabUnpacker Unpacker { get; }
    protected virtual void Dispose(bool disposing);
    private CabPacker get_Packer();
    private CabUnpacker get_Unpacker();
    public virtual void Pack(IPackStreamContext streamContext, IEnumerable`1<string> files, long maxArchiveSize);
    public virtual bool IsArchive(Stream stream);
    public virtual IList`1<ArchiveFileInfo> GetFileInfo(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    public virtual void Unpack(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    internal void ReportProgress(ArchiveProgressEventArgs e);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.CabException : ArchiveException {
    private static ResourceManager errorResources;
    private int error;
    private int errorCode;
    public int Error { get; }
    public int ErrorCode { get; }
    internal static ResourceManager ErrorResources { get; }
    public CabException(string message, Exception innerException);
    public CabException(string message);
    internal CabException(int error, int errorCode, string message, Exception innerException);
    internal CabException(int error, int errorCode, string message);
    public int get_Error();
    public int get_ErrorCode();
    internal static ResourceManager get_ErrorResources();
    internal static string GetErrorMessage(int error, int errorCode, bool extracting);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.CabFileInfo : ArchiveFileInfo {
    private int cabFolder;
    public CabInfo Cabinet { get; }
    public string CabinetName { get; }
    public int CabinetFolderNumber { get; }
    public CabFileInfo(CabInfo cabinetInfo, string filePath);
    internal CabFileInfo(string filePath, int cabFolder, int cabNumber, FileAttributes attributes, DateTime lastWriteTime, long length);
    public CabInfo get_Cabinet();
    public string get_CabinetName();
    public int get_CabinetFolderNumber();
    protected virtual void Refresh(ArchiveFileInfo newFileInfo);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.CabInfo : ArchiveInfo {
    public CabInfo(string path);
    protected virtual CompressionEngine CreateCompressionEngine();
    public IList`1<CabFileInfo> GetFiles();
    public IList`1<CabFileInfo> GetFiles(string searchPattern);
}
internal class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.CabPacker : CabWorker {
    private static string TempStreamName;
    private Handle fciHandle;
    private PFNALLOC fciAllocMemHandler;
    private PFNFREE fciFreeMemHandler;
    private PFNOPEN fciOpenStreamHandler;
    private PFNREAD fciReadStreamHandler;
    private PFNWRITE fciWriteStreamHandler;
    private PFNCLOSE fciCloseStreamHandler;
    private PFNSEEK fciSeekStreamHandler;
    private PFNFILEPLACED fciFilePlacedHandler;
    private PFNDELETE fciDeleteFileHandler;
    private PFNGETTEMPFILE fciGetTempFileHandler;
    private PFNGETNEXTCABINET fciGetNextCabinet;
    private PFNSTATUS fciCreateStatus;
    private PFNGETOPENINFO fciGetOpenInfo;
    private IPackStreamContext context;
    private FileAttributes fileAttributes;
    private DateTime fileLastWriteTime;
    private int maxCabBytes;
    private long totalFolderBytesProcessedInCurrentCab;
    private CompressionLevel compressionLevel;
    private bool dontUseTempFiles;
    private IList`1<Stream> tempStreams;
    public bool UseTempFiles { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public CabPacker(CabEngine cabEngine);
    public bool get_UseTempFiles();
    public void set_UseTempFiles(bool value);
    public CompressionLevel get_CompressionLevel();
    public void set_CompressionLevel(CompressionLevel value);
    private void CreateFci(long maxArchiveSize);
    public void Pack(IPackStreamContext streamContext, IEnumerable`1<string> files, long maxArchiveSize);
    internal virtual int CabOpenStreamEx(string path, int openFlags, int shareMode, Int32& err, IntPtr pv);
    internal virtual int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, Int32& err, IntPtr pv);
    internal virtual int CabCloseStreamEx(int streamHandle, Int32& err, IntPtr pv);
    protected virtual void Dispose(bool disposing);
    private static TCOMP GetCompressionType(CompressionLevel compLevel);
    private void AddFile(string name, Stream stream, FileAttributes attributes, DateTime lastWriteTime, bool execute, CompressionLevel compLevel);
    private void FlushFolder();
    private void FlushCabinet();
    private int CabGetOpenInfo(string path, Int16& date, Int16& time, Int16& attribs, Int32& err, IntPtr pv);
    private int CabFilePlaced(IntPtr pccab, string filePath, long fileSize, int continuation, IntPtr pv);
    private int CabGetNextCabinet(IntPtr pccab, UInt32 prevCabSize, IntPtr pv);
    private int CabCreateStatus(STATUS typeStatus, UInt32 cb1, UInt32 cb2, IntPtr pv);
    private int CabGetTempFile(IntPtr tempNamePtr, int tempNameSize, IntPtr pv);
    private int CabDeleteFile(string path, Int32& err, IntPtr pv);
}
internal class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.CabUnpacker : CabWorker {
    private Handle fdiHandle;
    private PFNALLOC fdiAllocMemHandler;
    private PFNFREE fdiFreeMemHandler;
    private PFNOPEN fdiOpenStreamHandler;
    private PFNREAD fdiReadStreamHandler;
    private PFNWRITE fdiWriteStreamHandler;
    private PFNCLOSE fdiCloseStreamHandler;
    private PFNSEEK fdiSeekStreamHandler;
    private IUnpackStreamContext context;
    private List`1<ArchiveFileInfo> fileList;
    private int folderId;
    private Predicate`1<string> filter;
    public CabUnpacker(CabEngine cabEngine);
    public bool IsArchive(Stream stream);
    public IList`1<ArchiveFileInfo> GetFileInfo(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    public void Unpack(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    internal virtual int CabOpenStreamEx(string path, int openFlags, int shareMode, Int32& err, IntPtr pv);
    internal virtual int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, Int32& err, IntPtr pv);
    internal virtual int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, Int32& err, IntPtr pv);
    internal virtual int CabCloseStreamEx(int streamHandle, Int32& err, IntPtr pv);
    protected virtual void Dispose(bool disposing);
    private static string GetFileName(NOTIFICATION notification);
    private bool IsCabinet(Stream cabStream, Int16& id, Int32& cabFolderCount, Int32& fileCount);
    private int CabListNotify(NOTIFICATIONTYPE notificationType, NOTIFICATION notification);
    private int CabExtractNotify(NOTIFICATIONTYPE notificationType, NOTIFICATION notification);
    private int CabExtractCopyFile(NOTIFICATION notification);
    private int CabExtractCloseFile(NOTIFICATION notification);
}
internal abstract class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.CabWorker : object {
    internal static string CabStreamName;
    private CabEngine cabEngine;
    private HandleManager`1<Stream> streamHandles;
    private Stream cabStream;
    private Stream fileStream;
    private ERF erf;
    private GCHandle erfHandle;
    private IDictionary`2<string, short> cabNumbers;
    private string nextCabinetName;
    private bool suppressProgressEvents;
    private Byte[] buf;
    protected string currentFileName;
    protected int currentFileNumber;
    protected int totalFiles;
    protected long currentFileBytesProcessed;
    protected long currentFileTotalBytes;
    protected short currentFolderNumber;
    protected long currentFolderTotalBytes;
    protected string currentArchiveName;
    protected short currentArchiveNumber;
    protected short totalArchives;
    protected long currentArchiveBytesProcessed;
    protected long currentArchiveTotalBytes;
    protected long fileBytesProcessed;
    protected long totalFileBytes;
    public CabEngine CabEngine { get; }
    internal ERF Erf { get; }
    internal GCHandle ErfHandle { get; }
    internal HandleManager`1<Stream> StreamHandles { get; }
    internal bool SuppressProgressEvents { get; internal set; }
    internal IDictionary`2<string, short> CabNumbers { get; }
    internal string NextCabinetName { get; internal set; }
    internal Stream CabStream { get; internal set; }
    internal Stream FileStream { get; internal set; }
    protected CabWorker(CabEngine cabEngine);
    protected virtual override void Finalize();
    public CabEngine get_CabEngine();
    internal ERF get_Erf();
    internal GCHandle get_ErfHandle();
    internal HandleManager`1<Stream> get_StreamHandles();
    internal bool get_SuppressProgressEvents();
    internal void set_SuppressProgressEvents(bool value);
    internal IDictionary`2<string, short> get_CabNumbers();
    internal string get_NextCabinetName();
    internal void set_NextCabinetName(string value);
    internal Stream get_CabStream();
    internal void set_CabStream(Stream value);
    internal Stream get_FileStream();
    internal void set_FileStream(Stream value);
    public sealed virtual void Dispose();
    protected void ResetProgressData();
    protected void OnProgress(ArchiveProgressType progressType);
    internal IntPtr CabAllocMem(int byteCount);
    internal void CabFreeMem(IntPtr memPointer);
    internal int CabOpenStream(string path, int openFlags, int shareMode);
    internal virtual int CabOpenStreamEx(string path, int openFlags, int shareMode, Int32& err, IntPtr pv);
    internal int CabReadStream(int streamHandle, IntPtr memory, int cb);
    internal virtual int CabReadStreamEx(int streamHandle, IntPtr memory, int cb, Int32& err, IntPtr pv);
    internal int CabWriteStream(int streamHandle, IntPtr memory, int cb);
    internal virtual int CabWriteStreamEx(int streamHandle, IntPtr memory, int cb, Int32& err, IntPtr pv);
    internal int CabCloseStream(int streamHandle);
    internal virtual int CabCloseStreamEx(int streamHandle, Int32& err, IntPtr pv);
    internal int CabSeekStream(int streamHandle, int offset, int seekOrigin);
    internal virtual int CabSeekStreamEx(int streamHandle, int offset, int seekOrigin, Int32& err, IntPtr pv);
    protected virtual void Dispose(bool disposing);
    protected void CheckError(bool extracting);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.HandleManager`1 : object {
    private List`1<T> handles;
    public T Item { get; }
    public T get_Item(int handle);
    public int AllocHandle(T obj);
    public void FreeHandle(int handle);
}
internal static class Microsoft.PackageManagement.Archivers.Internal.Compression.Cab.NativeMethods : object {
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.CargoStream : Stream {
    private Stream source;
    private List`1<IDisposable> cargo;
    public Stream Source { get; }
    public IList`1<IDisposable> Cargo { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CargoStream(Stream source, IDisposable[] cargo);
    public Stream get_Source();
    public IList`1<IDisposable> get_Cargo();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
}
public abstract class Microsoft.PackageManagement.Archivers.Internal.Compression.CompressionEngine : object {
    private CompressionLevel compressionLevel;
    private bool dontUseTempFiles;
    [CompilerGeneratedAttribute]
private EventHandler`1<ArchiveProgressEventArgs> Progress;
    public bool UseTempFiles { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public void add_Progress(EventHandler`1<ArchiveProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Progress(EventHandler`1<ArchiveProgressEventArgs> value);
    public bool get_UseTempFiles();
    public void set_UseTempFiles(bool value);
    public CompressionLevel get_CompressionLevel();
    public void set_CompressionLevel(CompressionLevel value);
    public sealed virtual void Dispose();
    public void Pack(IPackStreamContext streamContext, IEnumerable`1<string> files);
    public abstract virtual void Pack(IPackStreamContext streamContext, IEnumerable`1<string> files, long maxArchiveSize);
    public abstract virtual bool IsArchive(Stream stream);
    public virtual long FindArchiveOffset(Stream stream);
    public IList`1<ArchiveFileInfo> GetFileInfo(Stream stream);
    public abstract virtual IList`1<ArchiveFileInfo> GetFileInfo(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    public IList`1<string> GetFiles(Stream stream);
    public IList`1<string> GetFiles(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    public Stream Unpack(Stream stream, string path);
    public abstract virtual void Unpack(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    protected void OnProgress(ArchiveProgressEventArgs e);
    protected virtual void Dispose(bool disposing);
    public static void DosDateAndTimeToDateTime(short dosDate, short dosTime, DateTime& dateTime);
    public static void DateTimeToDosDateAndTime(DateTime dateTime, Int16& dosDate, Int16& dosTime);
}
public enum Microsoft.PackageManagement.Archivers.Internal.Compression.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel None;
    public static CompressionLevel Min;
    public static CompressionLevel Normal;
    public static CompressionLevel Max;
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.DuplicateStream : Stream {
    private Stream source;
    private long position;
    public Stream Source { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DuplicateStream(Stream source);
    public Stream get_Source();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static Stream OriginalStream(Stream stream);
    public virtual void Flush();
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
}
public interface Microsoft.PackageManagement.Archivers.Internal.Compression.IPackStreamContext {
    public abstract virtual string GetArchiveName(int archiveNumber);
    public abstract virtual Stream OpenArchiveWriteStream(int archiveNumber, string archiveName, bool truncate, CompressionEngine compressionEngine);
    public abstract virtual void CloseArchiveWriteStream(int archiveNumber, string archiveName, Stream stream);
    public abstract virtual Stream OpenFileReadStream(string path, FileAttributes& attributes, DateTime& lastWriteTime);
    public abstract virtual void CloseFileReadStream(string path, Stream stream);
    public abstract virtual object GetOption(string optionName, Object[] parameters);
}
public interface Microsoft.PackageManagement.Archivers.Internal.Compression.IUnpackStreamContext {
    public abstract virtual Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);
    public abstract virtual void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);
    public abstract virtual Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);
    public abstract virtual void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.OffsetStream : Stream {
    private Stream source;
    private long sourceOffset;
    public Stream Source { get; }
    public long Offset { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OffsetStream(Stream source, long offset);
    public Stream get_Source();
    public long get_Offset();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
internal static class Microsoft.PackageManagement.Archivers.Internal.Compression.SafeNativeMethods : object {
    internal static bool DosDateTimeToFileTime(short wFatDate, short wFatTime, Int64& fileTime);
    internal static bool FileTimeToDosDateTime(Int64& fileTime, Int16& wFatDate, Int16& wFatTime);
}
internal class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ConcatStream : Stream {
    private Stream source;
    private long position;
    private long length;
    private Action`1<ConcatStream> nextStreamHandler;
    public Stream Source { get; public set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ConcatStream(Action`1<ConcatStream> nextStreamHandler);
    public Stream get_Source();
    public void set_Source(Stream value);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.CrcStream : Stream {
    private Stream source;
    private UInt32 crc;
    private static UInt32[] crcTable;
    public UInt32 Crc { get; }
    public Stream Source { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcStream(Stream source);
    private static CrcStream();
    public UInt32 get_Crc();
    public Stream get_Source();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    private void UpdateCrc(Byte[] buffer, int offset, int count);
    private static UInt32[] MakeCrcTable();
    private static UInt32 Reflect(UInt32 value, int bits);
}
internal class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.Zip64EndOfCentralDirectoryLocator : object {
    public static UInt32 EOCDL64SIG;
    public static UInt32 EOCDL64_SIZE;
    public UInt32 dirStartDiskNumber;
    public long dirOffset;
    public UInt32 totalDisks;
    public bool Read(Stream stream);
    public void Write(Stream stream);
}
public enum Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipCompressionMethod : Enum {
    public int value__;
    public static ZipCompressionMethod Store;
    public static ZipCompressionMethod Shrink;
    public static ZipCompressionMethod Reduce1;
    public static ZipCompressionMethod Reduce2;
    public static ZipCompressionMethod Reduce3;
    public static ZipCompressionMethod Reduce4;
    public static ZipCompressionMethod Implode;
    public static ZipCompressionMethod Deflate;
    public static ZipCompressionMethod Deflate64;
    public static ZipCompressionMethod BZip2;
    public static ZipCompressionMethod Lzma;
    public static ZipCompressionMethod Ppmd;
}
internal class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipEndOfCentralDirectory : object {
    public static UInt32 EOCDSIG;
    public static UInt32 EOCD64SIG;
    public static UInt32 EOCD_RECORD_FIXEDSIZE;
    public static UInt32 EOCD64_RECORD_FIXEDSIZE;
    public ushort versionMadeBy;
    public ushort versionNeeded;
    public UInt32 diskNumber;
    public UInt32 dirStartDiskNumber;
    public long entriesOnDisk;
    public long totalEntries;
    public long dirSize;
    public long dirOffset;
    public string comment;
    public bool zip64;
    public bool Read(Stream stream);
    public void Write(Stream stream);
    public int GetSize(bool zip64Size);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipEngine : CompressionEngine {
    private static Dictionary`2<ZipCompressionMethod, Func`2<Stream, Stream>> compressionStreamCreators;
    private static Dictionary`2<ZipCompressionMethod, Func`2<Stream, Stream>> decompressionStreamCreators;
    private string currentFileName;
    private int currentFileNumber;
    private int totalFiles;
    private long currentFileBytesProcessed;
    private long currentFileTotalBytes;
    private string mainArchiveName;
    private string currentArchiveName;
    private short currentArchiveNumber;
    private short totalArchives;
    private long currentArchiveBytesProcessed;
    private long currentArchiveTotalBytes;
    private long fileBytesProcessed;
    private long totalFileBytes;
    private string comment;
    public string ArchiveComment { get; public set; }
    private static void InitCompressionStreamCreators();
    public static void RegisterCompressionStreamCreator(ZipCompressionMethod compressionMethod, CompressionMode compressionMode, Func`2<Stream, Stream> creator);
    public string get_ArchiveComment();
    public void set_ArchiveComment(string value);
    public virtual bool IsArchive(Stream stream);
    public virtual long FindArchiveOffset(Stream stream);
    public virtual IList`1<ArchiveFileInfo> GetFileInfo(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    private IList`1<ZipFileHeader> GetCentralDirectory(IUnpackStreamContext streamContext);
    private ZipEndOfCentralDirectory GetEOCD(IUnpackStreamContext streamContext, Stream archiveStream);
    private void ResetProgressData();
    private void OnProgress(ArchiveProgressType progressType);
    public virtual void Pack(IPackStreamContext streamContext, IEnumerable`1<string> files, long maxArchiveSize);
    private void CheckArchiveWriteStream(IPackStreamContext streamContext, long maxArchiveSize, long requiredSize, Stream& archiveStream);
    private ZipFileHeader PackOneFile(IPackStreamContext streamContext, string file, long maxArchiveSize, bool forceZip64, Stream& archiveStream);
    private long PackFileBytes(IPackStreamContext streamContext, Stream fileStream, long maxArchiveSize, Func`2<Stream, Stream> compressionStreamCreator, Stream& archiveStream, UInt32& crc);
    public virtual void Unpack(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    private void UnpackOneFile(IUnpackStreamContext streamContext, ZipFileHeader header, Stream& archiveStream);
    private static bool AreFilePathsEqual(string path1, string path2);
    private Stream OpenArchive(IUnpackStreamContext streamContext, int archiveNumber);
    private void UnpackFileBytes(IUnpackStreamContext streamContext, string fileName, long compressedSize, long uncompressedSize, UInt32 crc, Stream fileStream, Func`2<Stream, Stream> compressionStreamCreator, Stream& archiveStream);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipException : ArchiveException {
    public ZipException(string message, Exception innerException);
    public ZipException(string message);
}
internal class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipExtraFileField : object {
    public ZipExtraFileFieldType fieldType;
    public Byte[] data;
    public bool Read(Stream stream, Int32& bytesRemaining);
    public void Write(Stream stream);
    public bool GetZip64Data(Int64& compressedSize, Int64& uncompressedSize, Int64& localHeaderOffset, Int32& diskStart);
    public bool SetZip64Data(long compressedSize, long uncompressedSize, long localHeaderOffset, int diskStart);
}
internal enum Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipExtraFileFieldType : Enum {
    public ushort value__;
    public static ZipExtraFileFieldType ZIP64;
    public static ZipExtraFileFieldType NTFS_TIMES;
    public static ZipExtraFileFieldType NTFS_ACLS;
    public static ZipExtraFileFieldType EXTIME;
}
[FlagsAttribute]
internal enum Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipFileFlags : Enum {
    public ushort value__;
    public static ZipFileFlags None;
    public static ZipFileFlags Encrypt;
    public static ZipFileFlags CompressOption1;
    public static ZipFileFlags CompressOption2;
    public static ZipFileFlags DataDescriptor;
    public static ZipFileFlags StrongEncrypt;
    public static ZipFileFlags UTF8;
}
internal class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipFileHeader : object {
    public static UInt32 LFHSIG;
    public static UInt32 CFHSIG;
    public static UInt32 SPANSIG;
    public static UInt32 SPANSIG2;
    public static UInt32 LFH_FIXEDSIZE;
    public static UInt32 CFH_FIXEDSIZE;
    public ushort versionMadeBy;
    public ushort versionNeeded;
    public ZipFileFlags flags;
    public ZipCompressionMethod compressionMethod;
    public short lastModTime;
    public short lastModDate;
    public UInt32 crc32;
    public UInt32 compressedSize;
    public UInt32 uncompressedSize;
    public ushort diskStart;
    public ushort internalFileAttrs;
    public UInt32 externalFileAttrs;
    public UInt32 localHeaderOffset;
    public string fileName;
    public ZipExtraFileField[] extraFields;
    public string fileComment;
    public bool zip64;
    public bool IsDirectory { get; }
    public ZipFileHeader(ZipFileInfo fileInfo, bool zip64);
    public void Update(long compressedSize, long uncompressedSize, UInt32 crc32, long localHeaderOffset, int archiveNumber);
    public bool Read(Stream stream, bool central);
    public void Write(Stream stream, bool central);
    public void GetZip64Fields(Int64& compressedSize, Int64& uncompressedSize, Int64& localHeaderOffset, Int32& archiveNumber, UInt32& crc);
    public ZipFileInfo ToZipFileInfo();
    public bool get_IsDirectory();
    public int GetSize(bool central);
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipFileInfo : ArchiveFileInfo {
    private long compressedLength;
    private ZipCompressionMethod compressionMethod;
    public long CompressedLength { get; }
    public ZipCompressionMethod CompressionMethod { get; }
    public ZipFileInfo(ZipInfo zipInfo, string filePath);
    internal ZipFileInfo(string filePath, int zipNumber, FileAttributes attributes, DateTime lastWriteTime, long length, long compressedLength, ZipCompressionMethod compressionMethod);
    public long get_CompressedLength();
    public ZipCompressionMethod get_CompressionMethod();
}
public class Microsoft.PackageManagement.Archivers.Internal.Compression.Zip.ZipInfo : ArchiveInfo {
    public ZipInfo(string path);
    protected virtual CompressionEngine CreateCompressionEngine();
    public IList`1<ZipFileInfo> GetFiles();
    public IList`1<ZipFileInfo> GetFiles(string searchPattern);
}
public class Microsoft.PackageManagement.Archivers.Internal.ZipArchiver : object {
    private static Dictionary`2<string, String[]> _features;
    public string ArchiverName { get; }
    public string ProviderVersion { get; }
    private static ZipArchiver();
    public void InitializeProvider(Request request);
    public void GetFeatures(Request request);
    public string get_ArchiverName();
    public string get_ProviderVersion();
    public void OnUnhandledException(string methodName, Exception exception);
    public IEnumerable`1<string> UnpackArchive(string localFilename, string destinationFolder, Request request);
    private IEnumerable`1<string> _UnpackArchive(string localFilename, string destinationFolder, Request request);
    public bool IsSupportedFile(string localFilename);
}
