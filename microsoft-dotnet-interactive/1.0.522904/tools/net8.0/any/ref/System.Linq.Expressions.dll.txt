[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.BinaryOperationBinder : DynamicMetaObjectBinder {
    public ExpressionType Operation { get; }
    public Type ReturnType { get; }
    protected BinaryOperationBinder(ExpressionType operation);
    public ExpressionType get_Operation();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg);
    public abstract virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.BindingRestrictions : object {
    public static BindingRestrictions Empty;
    public static BindingRestrictions Combine(IList`1<DynamicMetaObject> contributingObjects);
    public static BindingRestrictions GetExpressionRestriction(Expression expression);
    public static BindingRestrictions GetInstanceRestriction(Expression expression, object instance);
    public static BindingRestrictions GetTypeRestriction(Expression expression, Type type);
    public BindingRestrictions Merge(BindingRestrictions restrictions);
    public Expression ToExpression();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Dynamic.CallInfo : object {
    public int ArgumentCount { get; }
    public ReadOnlyCollection`1<string> ArgumentNames { get; }
    public CallInfo(int argCount, IEnumerable`1<string> argNames);
    public CallInfo(int argCount, String[] argNames);
    public int get_ArgumentCount();
    public ReadOnlyCollection`1<string> get_ArgumentNames();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.ConvertBinder : DynamicMetaObjectBinder {
    public bool Explicit { get; }
    public Type ReturnType { get; }
    public Type Type { get; }
    protected ConvertBinder(Type type, bool explicit);
    public bool get_Explicit();
    public sealed virtual Type get_ReturnType();
    public Type get_Type();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackConvert(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.CreateInstanceBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected CreateInstanceBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.DeleteIndexBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected DeleteIndexBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.DeleteMemberBinder : DynamicMetaObjectBinder {
    public bool IgnoreCase { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    protected DeleteMemberBinder(string name, bool ignoreCase);
    public bool get_IgnoreCase();
    public string get_Name();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Dynamic.DynamicMetaObject : object {
    public static DynamicMetaObject[] EmptyMetaObjects;
    public Expression Expression { get; }
    public bool HasValue { get; }
    public Type LimitType { get; }
    public BindingRestrictions Restrictions { get; }
    [NullableAttribute("2")]
public Type RuntimeType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions);
    public DynamicMetaObject(Expression expression, BindingRestrictions restrictions, object value);
    public Expression get_Expression();
    public bool get_HasValue();
    public Type get_LimitType();
    public BindingRestrictions get_Restrictions();
    [NullableContextAttribute("2")]
public Type get_RuntimeType();
    [NullableContextAttribute("2")]
public object get_Value();
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public static DynamicMetaObject Create(object value, Expression expression);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.DynamicMetaObjectBinder : CallSiteBinder {
    public Type ReturnType { get; }
    public virtual Type get_ReturnType();
    public abstract virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public sealed virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public DynamicMetaObject Defer(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject Defer(DynamicMetaObject[] args);
    public Expression GetUpdateExpression(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Dynamic.DynamicObject : object {
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public virtual DynamicMetaObject GetMetaObject(Expression parameter);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    [NullableContextAttribute("2")]
public virtual bool TryCreateInstance(CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryDeleteIndex(DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    [NullableContextAttribute("2")]
public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    [NullableContextAttribute("2")]
public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryUnaryOperation(UnaryOperationBinder binder, Object& result);
}
public class System.Dynamic.ExpandoObject : object {
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    [NullableAttribute("1")]
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.GetIndexBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected GetIndexBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes);
    public abstract virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.GetMemberBinder : DynamicMetaObjectBinder {
    public bool IgnoreCase { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    protected GetMemberBinder(string name, bool ignoreCase);
    public bool get_IgnoreCase();
    public string get_Name();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackGetMember(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
public interface System.Dynamic.IDynamicMetaObjectProvider {
    public abstract virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
public interface System.Dynamic.IInvokeOnGetBinder {
    public bool InvokeOnGet { get; }
    public abstract virtual bool get_InvokeOnGet();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.InvokeBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected InvokeBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.InvokeMemberBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public bool IgnoreCase { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    protected InvokeMemberBinder(string name, bool ignoreCase, CallInfo callInfo);
    public CallInfo get_CallInfo();
    public bool get_IgnoreCase();
    public string get_Name();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args);
    public abstract virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.SetIndexBinder : DynamicMetaObjectBinder {
    public CallInfo CallInfo { get; }
    public Type ReturnType { get; }
    protected SetIndexBinder(CallInfo callInfo);
    public CallInfo get_CallInfo();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.SetMemberBinder : DynamicMetaObjectBinder {
    public bool IgnoreCase { get; }
    public string Name { get; }
    public Type ReturnType { get; }
    protected SetMemberBinder(string name, bool ignoreCase);
    public bool get_IgnoreCase();
    public string get_Name();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value);
    public abstract virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Dynamic.UnaryOperationBinder : DynamicMetaObjectBinder {
    public ExpressionType Operation { get; }
    public Type ReturnType { get; }
    protected UnaryOperationBinder(ExpressionType operation);
    public ExpressionType get_Operation();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target);
    public abstract virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.BinaryExpression : Expression {
    public bool CanReduce { get; }
    [NullableAttribute("2")]
public LambdaExpression Conversion { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    public Expression Left { get; }
    [NullableAttribute("2")]
public MethodInfo Method { get; }
    public Expression Right { get; }
    public virtual bool get_CanReduce();
    [NullableContextAttribute("2")]
public LambdaExpression get_Conversion();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    public Expression get_Left();
    [NullableContextAttribute("2")]
public MethodInfo get_Method();
    public Expression get_Right();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.BlockExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public ExpressionType NodeType { get; }
    public Expression Result { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Result();
    public virtual Type get_Type();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public BlockExpression Update(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.CatchBlock : object {
    public Expression Body { get; }
    [NullableAttribute("2")]
public Expression Filter { get; }
    public Type Test { get; }
    [NullableAttribute("2")]
public ParameterExpression Variable { get; }
    public Expression get_Body();
    [NullableContextAttribute("2")]
public Expression get_Filter();
    public Type get_Test();
    [NullableContextAttribute("2")]
public ParameterExpression get_Variable();
    public virtual string ToString();
    public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.ConditionalExpression : Expression {
    public Expression IfFalse { get; }
    public Expression IfTrue { get; }
    public ExpressionType NodeType { get; }
    public Expression Test { get; }
    public Type Type { get; }
    public Expression get_IfFalse();
    public Expression get_IfTrue();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Test();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.ConstantExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    [NullableContextAttribute("2")]
public object get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.DebugInfoExpression : Expression {
    public SymbolDocumentInfo Document { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public bool IsClear { get; }
    public ExpressionType NodeType { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public Type Type { get; }
    public SymbolDocumentInfo get_Document();
    public virtual int get_EndColumn();
    public virtual int get_EndLine();
    public virtual bool get_IsClear();
    public sealed virtual ExpressionType get_NodeType();
    public virtual int get_StartColumn();
    public virtual int get_StartLine();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.DefaultExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.DynamicExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public CallSiteBinder Binder { get; }
    public Type DelegateType { get; }
    public ExpressionType NodeType { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public CallSiteBinder get_Binder();
    public sealed virtual Type get_DelegateType();
    public sealed virtual ExpressionType get_NodeType();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    private sealed virtual override object System.Linq.Expressions.IDynamicExpression.CreateCallSite();
    private sealed virtual override Expression System.Linq.Expressions.IDynamicExpression.Rewrite(Expression[] args);
    public DynamicExpression Update(IEnumerable`1<Expression> arguments);
}
public abstract class System.Linq.Expressions.DynamicExpressionVisitor : ExpressionVisitor {
    [NullableContextAttribute("1")]
protected internal virtual Expression VisitDynamic(DynamicExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.ElementInit : object {
    public MethodInfo AddMethod { get; }
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public MethodInfo get_AddMethod();
    public ReadOnlyCollection`1<Expression> get_Arguments();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public virtual string ToString();
    public ElementInit Update(IEnumerable`1<Expression> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Linq.Expressions.Expression : object {
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")]
protected Expression(ExpressionType nodeType, Type type);
    public virtual bool get_CanReduce();
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public static BinaryExpression Add(Expression left, Expression right);
    public static BinaryExpression Add(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression AddChecked(Expression left, Expression right);
    public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression And(Expression left, Expression right);
    public static BinaryExpression And(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAlso(Expression left, Expression right);
    public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static IndexExpression ArrayAccess(Expression array, IEnumerable`1<Expression> indexes);
    public static IndexExpression ArrayAccess(Expression array, Expression[] indexes);
    public static MethodCallExpression ArrayIndex(Expression array, IEnumerable`1<Expression> indexes);
    public static BinaryExpression ArrayIndex(Expression array, Expression index);
    public static MethodCallExpression ArrayIndex(Expression array, Expression[] indexes);
    public static UnaryExpression ArrayLength(Expression array);
    public static BinaryExpression Assign(Expression left, Expression right);
    public static MemberAssignment Bind(MemberInfo member, Expression expression);
    [RequiresUnreferencedCodeAttribute("The Property metadata or other accessor may be trimmed.")]
public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression);
    public static BlockExpression Block(IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Expression arg0, Expression arg1);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static BlockExpression Block(Expression[] expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, IEnumerable`1<Expression> expressions);
    public static BlockExpression Block(Type type, IEnumerable`1<ParameterExpression> variables, Expression[] expressions);
    public static BlockExpression Block(Type type, Expression[] expressions);
    public static GotoExpression Break(LabelTarget target);
    public static GotoExpression Break(LabelTarget target, Expression value);
    public static GotoExpression Break(LabelTarget target, Expression value, Type type);
    public static GotoExpression Break(LabelTarget target, Type type);
    public static MethodCallExpression Call(Expression instance, MethodInfo method);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression[] arguments);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, Expression[] arguments);
    public static MethodCallExpression Call(MethodInfo method, IEnumerable`1<Expression> arguments);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4);
    public static MethodCallExpression Call(MethodInfo method, Expression[] arguments);
    [RequiresUnreferencedCodeAttribute("Calling a generic method cannot be statically analyzed. It's not possible to guarantee the availability of requirements of the generic method. This can be suppressed if the method is not generic.")]
public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, Expression[] arguments);
    public static CatchBlock Catch(ParameterExpression variable, Expression body);
    public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter);
    public static CatchBlock Catch(Type type, Expression body);
    public static CatchBlock Catch(Type type, Expression body, Expression filter);
    public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document);
    public static BinaryExpression Coalesce(Expression left, Expression right);
    public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse);
    public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type);
    public static ConstantExpression Constant(object value);
    public static ConstantExpression Constant(object value, Type type);
    public static GotoExpression Continue(LabelTarget target);
    public static GotoExpression Continue(LabelTarget target, Type type);
    public static UnaryExpression Convert(Expression expression, Type type);
    public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method);
    public static UnaryExpression ConvertChecked(Expression expression, Type type);
    public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method);
    public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn);
    public static UnaryExpression Decrement(Expression expression);
    public static UnaryExpression Decrement(Expression expression, MethodInfo method);
    public static DefaultExpression Default(Type type);
    public static BinaryExpression Divide(Expression left, Expression right);
    public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable`1<Expression> arguments);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression[] arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable`1<Expression> arguments);
    public static ElementInit ElementInit(MethodInfo addMethod, Expression[] arguments);
    public static DefaultExpression Empty();
    public static BinaryExpression Equal(Expression left, Expression right);
    public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right);
    public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static MemberExpression Field(Expression expression, FieldInfo field);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static MemberExpression Field(Expression expression, string fieldName);
    public static MemberExpression Field(Expression expression, Type type, string fieldName);
    public static Type GetActionType(Type[] typeArgs);
    public static Type GetDelegateType(Type[] typeArgs);
    public static Type GetFuncType(Type[] typeArgs);
    public static GotoExpression Goto(LabelTarget target);
    public static GotoExpression Goto(LabelTarget target, Expression value);
    public static GotoExpression Goto(LabelTarget target, Expression value, Type type);
    public static GotoExpression Goto(LabelTarget target, Type type);
    public static BinaryExpression GreaterThan(Expression left, Expression right);
    public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right);
    public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static ConditionalExpression IfThen(Expression test, Expression ifTrue);
    public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse);
    public static UnaryExpression Increment(Expression expression);
    public static UnaryExpression Increment(Expression expression, MethodInfo method);
    public static InvocationExpression Invoke(Expression expression, IEnumerable`1<Expression> arguments);
    public static InvocationExpression Invoke(Expression expression, Expression[] arguments);
    public static UnaryExpression IsFalse(Expression expression);
    public static UnaryExpression IsFalse(Expression expression, MethodInfo method);
    public static UnaryExpression IsTrue(Expression expression);
    public static UnaryExpression IsTrue(Expression expression, MethodInfo method);
    public static LabelTarget Label();
    public static LabelExpression Label(LabelTarget target);
    public static LabelExpression Label(LabelTarget target, Expression defaultValue);
    public static LabelTarget Label(string name);
    public static LabelTarget Label(Type type);
    public static LabelTarget Label(Type type, string name);
    public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, ParameterExpression[] parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, bool tailCall, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, ParameterExpression[] parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, bool tailCall, IEnumerable`1<ParameterExpression> parameters);
    public static Expression`1<TDelegate> Lambda(Expression body, string name, IEnumerable`1<ParameterExpression> parameters);
    public static BinaryExpression LeftShift(Expression left, Expression right);
    public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression LessThan(Expression left, Expression right);
    public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right);
    public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static MemberListBinding ListBind(MemberInfo member, IEnumerable`1<ElementInit> initializers);
    public static MemberListBinding ListBind(MemberInfo member, ElementInit[] initializers);
    [RequiresUnreferencedCodeAttribute("The Property metadata or other accessor may be trimmed.")]
public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable`1<ElementInit> initializers);
    [RequiresUnreferencedCodeAttribute("The Property metadata or other accessor may be trimmed.")]
public static MemberListBinding ListBind(MethodInfo propertyAccessor, ElementInit[] initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable`1<Expression> initializers);
    public static ListInitExpression ListInit(NewExpression newExpression, ElementInit[] initializers);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static ListInitExpression ListInit(NewExpression newExpression, Expression[] initializers);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable`1<Expression> initializers);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, Expression[] initializers);
    public static LoopExpression Loop(Expression body);
    public static LoopExpression Loop(Expression body, LabelTarget break);
    public static LoopExpression Loop(Expression body, LabelTarget break, LabelTarget continue);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion);
    public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable`1<Expression> arguments);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3);
    public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression[] arguments);
    public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type);
    public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member);
    [NullableContextAttribute("2")]
public static TryExpression MakeTry(Type type, Expression body, Expression finally, Expression fault, IEnumerable`1<CatchBlock> handlers);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type);
    public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method);
    public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable`1<MemberBinding> bindings);
    public static MemberMemberBinding MemberBind(MemberInfo member, MemberBinding[] bindings);
    [RequiresUnreferencedCodeAttribute("The Property metadata or other accessor may be trimmed.")]
public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable`1<MemberBinding> bindings);
    [RequiresUnreferencedCodeAttribute("The Property metadata or other accessor may be trimmed.")]
public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, MemberBinding[] bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
    public static MemberInitExpression MemberInit(NewExpression newExpression, MemberBinding[] bindings);
    public static BinaryExpression Modulo(Expression left, Expression right);
    public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression Multiply(Expression left, Expression right);
    public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right);
    public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method);
    public static UnaryExpression Negate(Expression expression);
    public static UnaryExpression Negate(Expression expression, MethodInfo method);
    public static UnaryExpression NegateChecked(Expression expression);
    public static UnaryExpression NegateChecked(Expression expression, MethodInfo method);
    public static NewExpression New(ConstructorInfo constructor);
    public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments);
    [RequiresUnreferencedCodeAttribute("The Property metadata or other accessor may be trimmed.")]
public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, IEnumerable`1<MemberInfo> members);
    [RequiresUnreferencedCodeAttribute("The Property metadata or other accessor may be trimmed.")]
public static NewExpression New(ConstructorInfo constructor, IEnumerable`1<Expression> arguments, MemberInfo[] members);
    public static NewExpression New(ConstructorInfo constructor, Expression[] arguments);
    public static NewExpression New(Type type);
    [RequiresDynamicCodeAttribute("Creating arrays at runtime requires dynamic code generation.")]
public static NewArrayExpression NewArrayBounds(Type type, IEnumerable`1<Expression> bounds);
    [RequiresDynamicCodeAttribute("Creating arrays at runtime requires dynamic code generation.")]
public static NewArrayExpression NewArrayBounds(Type type, Expression[] bounds);
    [RequiresDynamicCodeAttribute("Creating arrays at runtime requires dynamic code generation.")]
public static NewArrayExpression NewArrayInit(Type type, IEnumerable`1<Expression> initializers);
    [RequiresDynamicCodeAttribute("Creating arrays at runtime requires dynamic code generation.")]
public static NewArrayExpression NewArrayInit(Type type, Expression[] initializers);
    public static UnaryExpression Not(Expression expression);
    public static UnaryExpression Not(Expression expression, MethodInfo method);
    public static BinaryExpression NotEqual(Expression left, Expression right);
    public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method);
    public static UnaryExpression OnesComplement(Expression expression);
    public static UnaryExpression OnesComplement(Expression expression, MethodInfo method);
    public static BinaryExpression Or(Expression left, Expression right);
    public static BinaryExpression Or(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression OrElse(Expression left, Expression right);
    public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method);
    public static ParameterExpression Parameter(Type type);
    public static ParameterExpression Parameter(Type type, string name);
    public static UnaryExpression PostDecrementAssign(Expression expression);
    public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PostIncrementAssign(Expression expression);
    public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method);
    public static BinaryExpression Power(Expression left, Expression right);
    public static BinaryExpression Power(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static UnaryExpression PreDecrementAssign(Expression expression);
    public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method);
    public static UnaryExpression PreIncrementAssign(Expression expression);
    public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method);
    [RequiresUnreferencedCodeAttribute("The Property metadata or other accessor may be trimmed.")]
public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor);
    public static MemberExpression Property(Expression expression, PropertyInfo property);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable`1<Expression> arguments);
    public static IndexExpression Property(Expression instance, PropertyInfo indexer, Expression[] arguments);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static MemberExpression Property(Expression expression, string propertyName);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static IndexExpression Property(Expression instance, string propertyName, Expression[] arguments);
    public static MemberExpression Property(Expression expression, Type type, string propertyName);
    [RequiresUnreferencedCodeAttribute("Creating Expressions requires unreferenced code because the members being referenced by the Expression may be trimmed.")]
public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName);
    public static UnaryExpression Quote(Expression expression);
    public virtual Expression Reduce();
    public Expression ReduceAndCheck();
    public Expression ReduceExtensions();
    public static BinaryExpression ReferenceEqual(Expression left, Expression right);
    public static BinaryExpression ReferenceNotEqual(Expression left, Expression right);
    public static UnaryExpression Rethrow();
    public static UnaryExpression Rethrow(Type type);
    public static GotoExpression Return(LabelTarget target);
    public static GotoExpression Return(LabelTarget target, Expression value);
    public static GotoExpression Return(LabelTarget target, Expression value, Type type);
    public static GotoExpression Return(LabelTarget target, Type type);
    public static BinaryExpression RightShift(Expression left, Expression right);
    public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static RuntimeVariablesExpression RuntimeVariables(IEnumerable`1<ParameterExpression> variables);
    public static RuntimeVariablesExpression RuntimeVariables(ParameterExpression[] variables);
    public static BinaryExpression Subtract(Expression left, Expression right);
    public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method);
    public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion);
    public static BinaryExpression SubtractChecked(Expression left, Expression right);
    public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchExpression Switch(Expression switchValue, SwitchCase[] cases);
    [NullableContextAttribute("2")]
public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable`1<SwitchCase> cases);
    [NullableContextAttribute("2")]
public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, SwitchCase[] cases);
    public static SwitchCase SwitchCase(Expression body, IEnumerable`1<Expression> testValues);
    public static SwitchCase SwitchCase(Expression body, Expression[] testValues);
    public static SymbolDocumentInfo SymbolDocument(string fileName);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor);
    public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType);
    public static UnaryExpression Throw(Expression value);
    public static UnaryExpression Throw(Expression value, Type type);
    public virtual string ToString();
    public static TryExpression TryCatch(Expression body, CatchBlock[] handlers);
    public static TryExpression TryCatchFinally(Expression body, Expression finally, CatchBlock[] handlers);
    public static TryExpression TryFault(Expression body, Expression fault);
    public static TryExpression TryFinally(Expression body, Expression finally);
    public static bool TryGetActionType(Type[] typeArgs, Type& actionType);
    public static bool TryGetFuncType(Type[] typeArgs, Type& funcType);
    public static UnaryExpression TypeAs(Expression expression, Type type);
    public static TypeBinaryExpression TypeEqual(Expression expression, Type type);
    public static TypeBinaryExpression TypeIs(Expression expression, Type type);
    public static UnaryExpression UnaryPlus(Expression expression);
    public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method);
    public static UnaryExpression Unbox(Expression expression, Type type);
    public static ParameterExpression Variable(Type type);
    public static ParameterExpression Variable(Type type, string name);
    protected internal virtual Expression VisitChildren(ExpressionVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.Expression`1 : LambdaExpression {
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TDelegate Compile();
    public TDelegate Compile(bool preferInterpretation);
    public TDelegate Compile(DebugInfoGenerator debugInfoGenerator);
    public Expression`1<TDelegate> Update(Expression body, IEnumerable`1<ParameterExpression> parameters);
}
public enum System.Linq.Expressions.ExpressionType : Enum {
    public int value__;
    public static ExpressionType Add;
    public static ExpressionType AddChecked;
    public static ExpressionType And;
    public static ExpressionType AndAlso;
    public static ExpressionType ArrayLength;
    public static ExpressionType ArrayIndex;
    public static ExpressionType Call;
    public static ExpressionType Coalesce;
    public static ExpressionType Conditional;
    public static ExpressionType Constant;
    public static ExpressionType Convert;
    public static ExpressionType ConvertChecked;
    public static ExpressionType Divide;
    public static ExpressionType Equal;
    public static ExpressionType ExclusiveOr;
    public static ExpressionType GreaterThan;
    public static ExpressionType GreaterThanOrEqual;
    public static ExpressionType Invoke;
    public static ExpressionType Lambda;
    public static ExpressionType LeftShift;
    public static ExpressionType LessThan;
    public static ExpressionType LessThanOrEqual;
    public static ExpressionType ListInit;
    public static ExpressionType MemberAccess;
    public static ExpressionType MemberInit;
    public static ExpressionType Modulo;
    public static ExpressionType Multiply;
    public static ExpressionType MultiplyChecked;
    public static ExpressionType Negate;
    public static ExpressionType UnaryPlus;
    public static ExpressionType NegateChecked;
    public static ExpressionType New;
    public static ExpressionType NewArrayInit;
    public static ExpressionType NewArrayBounds;
    public static ExpressionType Not;
    public static ExpressionType NotEqual;
    public static ExpressionType Or;
    public static ExpressionType OrElse;
    public static ExpressionType Parameter;
    public static ExpressionType Power;
    public static ExpressionType Quote;
    public static ExpressionType RightShift;
    public static ExpressionType Subtract;
    public static ExpressionType SubtractChecked;
    public static ExpressionType TypeAs;
    public static ExpressionType TypeIs;
    public static ExpressionType Assign;
    public static ExpressionType Block;
    public static ExpressionType DebugInfo;
    public static ExpressionType Decrement;
    public static ExpressionType Dynamic;
    public static ExpressionType Default;
    public static ExpressionType Extension;
    public static ExpressionType Goto;
    public static ExpressionType Increment;
    public static ExpressionType Index;
    public static ExpressionType Label;
    public static ExpressionType RuntimeVariables;
    public static ExpressionType Loop;
    public static ExpressionType Switch;
    public static ExpressionType Throw;
    public static ExpressionType Try;
    public static ExpressionType Unbox;
    public static ExpressionType AddAssign;
    public static ExpressionType AndAssign;
    public static ExpressionType DivideAssign;
    public static ExpressionType ExclusiveOrAssign;
    public static ExpressionType LeftShiftAssign;
    public static ExpressionType ModuloAssign;
    public static ExpressionType MultiplyAssign;
    public static ExpressionType OrAssign;
    public static ExpressionType PowerAssign;
    public static ExpressionType RightShiftAssign;
    public static ExpressionType SubtractAssign;
    public static ExpressionType AddAssignChecked;
    public static ExpressionType MultiplyAssignChecked;
    public static ExpressionType SubtractAssignChecked;
    public static ExpressionType PreIncrementAssign;
    public static ExpressionType PreDecrementAssign;
    public static ExpressionType PostIncrementAssign;
    public static ExpressionType PostDecrementAssign;
    public static ExpressionType TypeEqual;
    public static ExpressionType OnesComplement;
    public static ExpressionType IsTrue;
    public static ExpressionType IsFalse;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Linq.Expressions.ExpressionVisitor : object {
    public ReadOnlyCollection`1<Expression> Visit(ReadOnlyCollection`1<Expression> nodes);
    [NullableContextAttribute("2")]
public virtual Expression Visit(Expression node);
    public ReadOnlyCollection`1<T> VisitAndConvert(ReadOnlyCollection`1<T> nodes, string callerName);
    [NullableContextAttribute("2")]
public T VisitAndConvert(T node, string callerName);
    protected internal virtual Expression VisitBinary(BinaryExpression node);
    protected internal virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected internal virtual Expression VisitConditional(ConditionalExpression node);
    protected internal virtual Expression VisitConstant(ConstantExpression node);
    protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node);
    protected internal virtual Expression VisitDefault(DefaultExpression node);
    protected internal virtual Expression VisitDynamic(DynamicExpression node);
    protected virtual ElementInit VisitElementInit(ElementInit node);
    protected internal virtual Expression VisitExtension(Expression node);
    protected internal virtual Expression VisitGoto(GotoExpression node);
    protected internal virtual Expression VisitIndex(IndexExpression node);
    protected internal virtual Expression VisitInvocation(InvocationExpression node);
    protected internal virtual Expression VisitLabel(LabelExpression node);
    [NullableContextAttribute("2")]
protected virtual LabelTarget VisitLabelTarget(LabelTarget node);
    protected internal virtual Expression VisitLambda(Expression`1<T> node);
    protected internal virtual Expression VisitListInit(ListInitExpression node);
    protected internal virtual Expression VisitLoop(LoopExpression node);
    protected internal virtual Expression VisitMember(MemberExpression node);
    protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected internal virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node);
    protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node);
    protected internal virtual Expression VisitMethodCall(MethodCallExpression node);
    protected internal virtual Expression VisitNew(NewExpression node);
    protected internal virtual Expression VisitNewArray(NewArrayExpression node);
    protected internal virtual Expression VisitParameter(ParameterExpression node);
    protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected internal virtual Expression VisitSwitch(SwitchExpression node);
    protected virtual SwitchCase VisitSwitchCase(SwitchCase node);
    protected internal virtual Expression VisitTry(TryExpression node);
    protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node);
    protected internal virtual Expression VisitUnary(UnaryExpression node);
    public static ReadOnlyCollection`1<T> Visit(ReadOnlyCollection`1<T> nodes, Func`2<T, T> elementVisitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.GotoExpression : Expression {
    public GotoExpressionKind Kind { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Type Type { get; }
    [NullableAttribute("2")]
public Expression Value { get; }
    public GotoExpressionKind get_Kind();
    public sealed virtual ExpressionType get_NodeType();
    public LabelTarget get_Target();
    public sealed virtual Type get_Type();
    [NullableContextAttribute("2")]
public Expression get_Value();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public GotoExpression Update(LabelTarget target, Expression value);
}
public enum System.Linq.Expressions.GotoExpressionKind : Enum {
    public int value__;
    public static GotoExpressionKind Goto;
    public static GotoExpressionKind Return;
    public static GotoExpressionKind Break;
    public static GotoExpressionKind Continue;
}
[NullableContextAttribute("1")]
public interface System.Linq.Expressions.IArgumentProvider {
    public int ArgumentCount { get; }
    public abstract virtual int get_ArgumentCount();
    public abstract virtual Expression GetArgument(int index);
}
[NullableContextAttribute("1")]
public interface System.Linq.Expressions.IDynamicExpression {
    public Type DelegateType { get; }
    public abstract virtual Type get_DelegateType();
    public abstract virtual object CreateCallSite();
    public abstract virtual Expression Rewrite(Expression[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.IndexExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    [NullableAttribute("2")]
public PropertyInfo Indexer { get; }
    public ExpressionType NodeType { get; }
    [NullableAttribute("2")]
public Expression Object { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    [NullableContextAttribute("2")]
public PropertyInfo get_Indexer();
    public sealed virtual ExpressionType get_NodeType();
    [NullableContextAttribute("2")]
public Expression get_Object();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public IndexExpression Update(Expression object, IEnumerable`1<Expression> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.InvocationExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public Expression get_Expression();
    public sealed virtual ExpressionType get_NodeType();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public InvocationExpression Update(Expression expression, IEnumerable`1<Expression> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.LabelExpression : Expression {
    [NullableAttribute("2")]
public Expression DefaultValue { get; }
    public ExpressionType NodeType { get; }
    public LabelTarget Target { get; }
    public Type Type { get; }
    [NullableContextAttribute("2")]
public Expression get_DefaultValue();
    public sealed virtual ExpressionType get_NodeType();
    public LabelTarget get_Target();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LabelExpression Update(LabelTarget target, Expression defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.LabelTarget : object {
    [NullableAttribute("2")]
public string Name { get; }
    public Type Type { get; }
    [NullableContextAttribute("2")]
public string get_Name();
    public Type get_Type();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Linq.Expressions.LambdaExpression : Expression {
    public Expression Body { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public ExpressionType NodeType { get; }
    public ReadOnlyCollection`1<ParameterExpression> Parameters { get; }
    public Type ReturnType { get; }
    public bool TailCall { get; }
    public Type Type { get; }
    public Expression get_Body();
    [NullableContextAttribute("2")]
public string get_Name();
    public sealed virtual ExpressionType get_NodeType();
    public ReadOnlyCollection`1<ParameterExpression> get_Parameters();
    public Type get_ReturnType();
    public bool get_TailCall();
    public sealed virtual Type get_Type();
    public Delegate Compile();
    public Delegate Compile(bool preferInterpretation);
    public Delegate Compile(DebugInfoGenerator debugInfoGenerator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.ListInitExpression : Expression {
    public bool CanReduce { get; }
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    public NewExpression NewExpression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public virtual bool get_CanReduce();
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public NewExpression get_NewExpression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public ListInitExpression Update(NewExpression newExpression, IEnumerable`1<ElementInit> initializers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.LoopExpression : Expression {
    public Expression Body { get; }
    [NullableAttribute("2")]
public LabelTarget BreakLabel { get; }
    [NullableAttribute("2")]
public LabelTarget ContinueLabel { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression get_Body();
    [NullableContextAttribute("2")]
public LabelTarget get_BreakLabel();
    [NullableContextAttribute("2")]
public LabelTarget get_ContinueLabel();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.MemberAssignment : MemberBinding {
    public Expression Expression { get; }
    public Expression get_Expression();
    public MemberAssignment Update(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Linq.Expressions.MemberBinding : object {
    public MemberBindingType BindingType { get; }
    public MemberInfo Member { get; }
    [ObsoleteAttribute("This constructor has been deprecated and is not supported.")]
protected MemberBinding(MemberBindingType type, MemberInfo member);
    public MemberBindingType get_BindingType();
    public MemberInfo get_Member();
    public virtual string ToString();
}
public enum System.Linq.Expressions.MemberBindingType : Enum {
    public int value__;
    public static MemberBindingType Assignment;
    public static MemberBindingType MemberBinding;
    public static MemberBindingType ListBinding;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.MemberExpression : Expression {
    [NullableAttribute("2")]
public Expression Expression { get; }
    public MemberInfo Member { get; }
    public ExpressionType NodeType { get; }
    [NullableContextAttribute("2")]
public Expression get_Expression();
    public MemberInfo get_Member();
    public sealed virtual ExpressionType get_NodeType();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public MemberExpression Update(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.MemberInitExpression : Expression {
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    public bool CanReduce { get; }
    public NewExpression NewExpression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public virtual bool get_CanReduce();
    public NewExpression get_NewExpression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public MemberInitExpression Update(NewExpression newExpression, IEnumerable`1<MemberBinding> bindings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.MemberListBinding : MemberBinding {
    public ReadOnlyCollection`1<ElementInit> Initializers { get; }
    public ReadOnlyCollection`1<ElementInit> get_Initializers();
    public MemberListBinding Update(IEnumerable`1<ElementInit> initializers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.MemberMemberBinding : MemberBinding {
    public ReadOnlyCollection`1<MemberBinding> Bindings { get; }
    public ReadOnlyCollection`1<MemberBinding> get_Bindings();
    public MemberMemberBinding Update(IEnumerable`1<MemberBinding> bindings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.MethodCallExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    public MethodInfo Method { get; }
    public ExpressionType NodeType { get; }
    [NullableAttribute("2")]
public Expression Object { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    public MethodInfo get_Method();
    public sealed virtual ExpressionType get_NodeType();
    [NullableContextAttribute("2")]
public Expression get_Object();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public MethodCallExpression Update(Expression object, IEnumerable`1<Expression> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresDynamicCodeAttribute("Creating arrays at runtime requires dynamic code generation.")]
public class System.Linq.Expressions.NewArrayExpression : Expression {
    public ReadOnlyCollection`1<Expression> Expressions { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Expressions();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public NewArrayExpression Update(IEnumerable`1<Expression> expressions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.NewExpression : Expression {
    public ReadOnlyCollection`1<Expression> Arguments { get; }
    [NullableAttribute("2")]
public ConstructorInfo Constructor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyCollection`1<MemberInfo> Members { get; }
    public ExpressionType NodeType { get; }
    private int System.Linq.Expressions.IArgumentProvider.ArgumentCount { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<Expression> get_Arguments();
    [NullableContextAttribute("2")]
public ConstructorInfo get_Constructor();
    public ReadOnlyCollection`1<MemberInfo> get_Members();
    public sealed virtual ExpressionType get_NodeType();
    private sealed virtual override int System.Linq.Expressions.IArgumentProvider.get_ArgumentCount();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    private sealed virtual override Expression System.Linq.Expressions.IArgumentProvider.GetArgument(int index);
    public NewExpression Update(IEnumerable`1<Expression> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.ParameterExpression : Expression {
    public bool IsByRef { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool get_IsByRef();
    [NullableContextAttribute("2")]
public string get_Name();
    public sealed virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.RuntimeVariablesExpression : Expression {
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<ParameterExpression> Variables { get; }
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public ReadOnlyCollection`1<ParameterExpression> get_Variables();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public RuntimeVariablesExpression Update(IEnumerable`1<ParameterExpression> variables);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.SwitchCase : object {
    public Expression Body { get; }
    public ReadOnlyCollection`1<Expression> TestValues { get; }
    public Expression get_Body();
    public ReadOnlyCollection`1<Expression> get_TestValues();
    public virtual string ToString();
    public SwitchCase Update(IEnumerable`1<Expression> testValues, Expression body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.SwitchExpression : Expression {
    public ReadOnlyCollection`1<SwitchCase> Cases { get; }
    [NullableAttribute("2")]
public MethodInfo Comparison { get; }
    [NullableAttribute("2")]
public Expression DefaultBody { get; }
    public ExpressionType NodeType { get; }
    public Expression SwitchValue { get; }
    public Type Type { get; }
    public ReadOnlyCollection`1<SwitchCase> get_Cases();
    [NullableContextAttribute("2")]
public MethodInfo get_Comparison();
    [NullableContextAttribute("2")]
public Expression get_DefaultBody();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_SwitchValue();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public SwitchExpression Update(Expression switchValue, IEnumerable`1<SwitchCase> cases, Expression defaultBody);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.SymbolDocumentInfo : object {
    public Guid DocumentType { get; }
    public string FileName { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public virtual Guid get_DocumentType();
    public string get_FileName();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.TryExpression : Expression {
    public Expression Body { get; }
    [NullableAttribute("2")]
public Expression Fault { get; }
    [NullableAttribute("2")]
public Expression Finally { get; }
    public ReadOnlyCollection`1<CatchBlock> Handlers { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Expression get_Body();
    [NullableContextAttribute("2")]
public Expression get_Fault();
    [NullableContextAttribute("2")]
public Expression get_Finally();
    public ReadOnlyCollection`1<CatchBlock> get_Handlers();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TryExpression Update(Expression body, IEnumerable`1<CatchBlock> handlers, Expression finally, Expression fault);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.TypeBinaryExpression : Expression {
    public Expression Expression { get; }
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public Type TypeOperand { get; }
    public Expression get_Expression();
    public sealed virtual ExpressionType get_NodeType();
    public sealed virtual Type get_Type();
    public Type get_TypeOperand();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public TypeBinaryExpression Update(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Linq.Expressions.UnaryExpression : Expression {
    public bool CanReduce { get; }
    public bool IsLifted { get; }
    public bool IsLiftedToNull { get; }
    [NullableAttribute("2")]
public MethodInfo Method { get; }
    public ExpressionType NodeType { get; }
    public Expression Operand { get; }
    public Type Type { get; }
    public virtual bool get_CanReduce();
    public bool get_IsLifted();
    public bool get_IsLiftedToNull();
    [NullableContextAttribute("2")]
public MethodInfo get_Method();
    public sealed virtual ExpressionType get_NodeType();
    public Expression get_Operand();
    public sealed virtual Type get_Type();
    protected internal virtual Expression Accept(ExpressionVisitor visitor);
    public virtual Expression Reduce();
    public UnaryExpression Update(Expression operand);
}
public interface System.Linq.IOrderedQueryable {
}
public interface System.Linq.IOrderedQueryable`1 {
}
[NullableContextAttribute("1")]
public interface System.Linq.IQueryable {
    public Type ElementType { get; }
    public Expression Expression { get; }
    public IQueryProvider Provider { get; }
    public abstract virtual Type get_ElementType();
    public abstract virtual Expression get_Expression();
    public abstract virtual IQueryProvider get_Provider();
}
public interface System.Linq.IQueryable`1 {
}
[NullableContextAttribute("1")]
public interface System.Linq.IQueryProvider {
    public abstract virtual IQueryable CreateQuery(Expression expression);
    public abstract virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public abstract virtual object Execute(Expression expression);
    public abstract virtual TResult Execute(Expression expression);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.CallSite : object {
    public CallSiteBinder Binder { get; }
    public CallSiteBinder get_Binder();
    [NullableContextAttribute("1")]
public static CallSite Create(Type delegateType, CallSiteBinder binder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.CallSite`1 : CallSite {
    public T Target;
    public T Update { get; }
    public T get_Update();
    public static CallSite`1<T> Create(CallSiteBinder binder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Runtime.CompilerServices.CallSiteBinder : object {
    public static LabelTarget UpdateLabel { get; }
    public static LabelTarget get_UpdateLabel();
    public abstract virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
    public virtual T BindDelegate(CallSite`1<T> site, Object[] args);
    protected void CacheTarget(T target);
}
public static class System.Runtime.CompilerServices.CallSiteHelpers : object {
    [NullableContextAttribute("1")]
public static bool IsInternalFrame(MethodBase mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Runtime.CompilerServices.DebugInfoGenerator : object {
    [ObsoleteAttribute("The CreatePdbGenerator API is not supported and throws PlatformNotSupportedException.")]
public static DebugInfoGenerator CreatePdbGenerator();
    public abstract virtual void MarkSequencePoint(LambdaExpression method, int ilOffset, DebugInfoExpression sequencePoint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10636")]
public class System.Runtime.CompilerServices.DynamicAttribute : Attribute {
    public IList`1<bool> TransformFlags { get; }
    public DynamicAttribute(Boolean[] transformFlags);
    public IList`1<bool> get_TransformFlags();
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.IRuntimeVariables {
    public int Count { get; }
    public object Item { get; public set; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1 : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollectionBuilder`1(IEnumerable`1<T> collection);
    public ReadOnlyCollectionBuilder`1(int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public void Reverse();
    public void Reverse(int index, int count);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public T[] ToArray();
    public ReadOnlyCollection`1<T> ToReadOnlyCollection();
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.RuleCache`1 : object {
}
