[NullableContextAttribute("1")]
[NullableAttribute("0")]
[GeneratedCodeAttribute("Microsoft.Extensions.Options.SourceGeneration", "8.0.10.6711")]
[AttributeUsageAttribute("2432")]
internal class __OptionValidationGeneratedAttributes.<Validators_g>F13085F2124107554156A65CD7C686C502E3E7A207041FB28CD7A2CF9D73438AE____SourceGen__RangeAttribute : ValidationAttribute {
    [CompilerGeneratedAttribute]
private object <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MinimumIsExclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MaximumIsExclusive>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OperandType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParseLimitsInInvariantCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConvertValueInInvariantCulture>k__BackingField;
    private bool _needToConvertMinMax;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initialized;
    private object _lock;
    private static string MinMaxError;
    public object Minimum { get; private set; }
    public object Maximum { get; private set; }
    public bool MinimumIsExclusive { get; public set; }
    public bool MaximumIsExclusive { get; public set; }
    public Type OperandType { get; }
    public bool ParseLimitsInInvariantCulture { get; public set; }
    public bool ConvertValueInInvariantCulture { get; public set; }
    public <Validators_g>F13085F2124107554156A65CD7C686C502E3E7A207041FB28CD7A2CF9D73438AE____SourceGen__RangeAttribute(int minimum, int maximum);
    public <Validators_g>F13085F2124107554156A65CD7C686C502E3E7A207041FB28CD7A2CF9D73438AE____SourceGen__RangeAttribute(double minimum, double maximum);
    public <Validators_g>F13085F2124107554156A65CD7C686C502E3E7A207041FB28CD7A2CF9D73438AE____SourceGen__RangeAttribute(Type type, string minimum, string maximum);
    [CompilerGeneratedAttribute]
public object get_Minimum();
    [CompilerGeneratedAttribute]
private void set_Minimum(object value);
    [CompilerGeneratedAttribute]
public object get_Maximum();
    [CompilerGeneratedAttribute]
private void set_Maximum(object value);
    [CompilerGeneratedAttribute]
public bool get_MinimumIsExclusive();
    [CompilerGeneratedAttribute]
public void set_MinimumIsExclusive(bool value);
    [CompilerGeneratedAttribute]
public bool get_MaximumIsExclusive();
    [CompilerGeneratedAttribute]
public void set_MaximumIsExclusive(bool value);
    [CompilerGeneratedAttribute]
public Type get_OperandType();
    [CompilerGeneratedAttribute]
public bool get_ParseLimitsInInvariantCulture();
    [CompilerGeneratedAttribute]
public void set_ParseLimitsInInvariantCulture(bool value);
    [CompilerGeneratedAttribute]
public bool get_ConvertValueInInvariantCulture();
    [CompilerGeneratedAttribute]
public void set_ConvertValueInInvariantCulture(bool value);
    public virtual string FormatErrorMessage(string name);
    [NullableContextAttribute("2")]
public virtual bool IsValid(object value);
    private string GetValidationErrorMessage();
    [NullableContextAttribute("2")]
private object ConvertValue(object value, CultureInfo formatProvider);
}
[GeneratedCodeAttribute("Microsoft.Extensions.Options.SourceGeneration", "8.0.10.6711")]
internal static class __OptionValidationStaticInstances.<Validators_g>F13085F2124107554156A65CD7C686C502E3E7A207041FB28CD7A2CF9D73438AE____Attributes : object {
    [NullableAttribute("1")]
internal static <Validators_g>F13085F2124107554156A65CD7C686C502E3E7A207041FB28CD7A2CF9D73438AE____SourceGen__RangeAttribute A1;
    private static <Validators_g>F13085F2124107554156A65CD7C686C502E3E7A207041FB28CD7A2CF9D73438AE____Attributes();
}
[GeneratedCodeAttribute("Microsoft.Extensions.Options.SourceGeneration", "8.0.10.6711")]
internal static class __OptionValidationStaticInstances.<Validators_g>F13085F2124107554156A65CD7C686C502E3E7A207041FB28CD7A2CF9D73438AE____Validators : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Configuration.Binder.SourceGeneration", "8.0.9.3103")]
internal static class Microsoft.Extensions.Configuration.Binder.SourceGeneration.<BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__BindingExtensions : object {
    private static Lazy`1<HashSet`1<string>> s_configKeys_ApplicationLogEnricherOptions;
    private static Lazy`1<HashSet`1<string>> s_configKeys_ProcessLogEnricherOptions;
    private static Lazy`1<HashSet`1<string>> s_configKeys_LatencyConsoleOptions;
    private static Lazy`1<HashSet`1<string>> s_configKeys_LatencyContextOptions;
    private static Lazy`1<HashSet`1<string>> s_configKeys_LoggerEnrichmentOptions;
    private static Lazy`1<HashSet`1<string>> s_configKeys_LoggerRedactionOptions;
    private static <BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__BindingExtensions();
    [ExtensionAttribute]
[<BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__InterceptsLocationAttribute("/_/src/Libraries/Microsoft.Extensions.Telemetry/Logging/LoggingEnrichmentExtensions.cs", "56", "121")]
[<BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__InterceptsLocationAttribute("/_/src/Libraries/Microsoft.Extensions.Telemetry/Logging/LoggingRedactionExtensions.cs", "55", "67")]
public static OptionsBuilder`1<TOptions> Bind(OptionsBuilder`1<TOptions> optionsBuilder, IConfiguration config);
    [ExtensionAttribute]
public static OptionsBuilder`1<TOptions> Bind(OptionsBuilder`1<TOptions> optionsBuilder, IConfiguration config, Action`1<BinderOptions> configureBinder);
    [ExtensionAttribute]
[<BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__InterceptsLocationAttribute("/_/src/Libraries/Microsoft.Extensions.Telemetry/Enrichment/ApplicationEnricherServiceCollectionExtensions.cs", "61", "14")]
[<BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__InterceptsLocationAttribute("/_/src/Libraries/Microsoft.Extensions.Telemetry/Enrichment/ProcessEnricherServiceCollectionExtensions.cs", "63", "14")]
[<BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__InterceptsLocationAttribute("/_/src/Libraries/Microsoft.Extensions.Telemetry/Latency/LatencyConsoleExtensions.cs", "63", "22")]
[<BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__InterceptsLocationAttribute("/_/src/Libraries/Microsoft.Extensions.Telemetry/Latency/LatencyContextExtensions.cs", "61", "22")]
public static IServiceCollection Configure(IServiceCollection services, IConfiguration config);
    [ExtensionAttribute]
public static IServiceCollection Configure(IServiceCollection services, string name, IConfiguration config, Action`1<BinderOptions> configureOptions);
    public static void BindCoreMain(IConfiguration configuration, object instance, Type type, Action`1<BinderOptions> configureOptions);
    public static void BindCore(IConfiguration configuration, ApplicationLogEnricherOptions& instance, bool defaultValueIfNotFound, BinderOptions binderOptions);
    public static void BindCore(IConfiguration configuration, ProcessLogEnricherOptions& instance, bool defaultValueIfNotFound, BinderOptions binderOptions);
    public static void BindCore(IConfiguration configuration, LatencyConsoleOptions& instance, bool defaultValueIfNotFound, BinderOptions binderOptions);
    public static void BindCore(IConfiguration configuration, LatencyContextOptions& instance, bool defaultValueIfNotFound, BinderOptions binderOptions);
    public static void BindCore(IConfiguration configuration, LoggerEnrichmentOptions& instance, bool defaultValueIfNotFound, BinderOptions binderOptions);
    public static void BindCore(IConfiguration configuration, LoggerRedactionOptions& instance, bool defaultValueIfNotFound, BinderOptions binderOptions);
    public static void ValidateConfigurationKeys(Type type, Lazy`1<HashSet`1<string>> keys, IConfiguration configuration, BinderOptions binderOptions);
    public static bool HasValueOrChildren(IConfiguration configuration);
    public static IConfiguration AsConfigWithChildren(IConfiguration configuration);
    [NullableContextAttribute("2")]
public static BinderOptions GetBinderOptions(Action`1<BinderOptions> configureOptions);
    public static bool ParseBool(string value, Func`1<string> getPath);
    public static int ParseInt(string value, Func`1<string> getPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ApplicationEnricherServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddServiceLogEnricher(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddServiceLogEnricher(IServiceCollection services, Action`1<ApplicationLogEnricherOptions> configure);
    [ExtensionAttribute]
public static IServiceCollection AddServiceLogEnricher(IServiceCollection services, IConfigurationSection section);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.LatencyConsoleExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddConsoleLatencyDataExporter(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddConsoleLatencyDataExporter(IServiceCollection services, Action`1<LatencyConsoleOptions> configure);
    [ExtensionAttribute]
public static IServiceCollection AddConsoleLatencyDataExporter(IServiceCollection services, IConfigurationSection section);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.LatencyContextExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddLatencyContext(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddLatencyContext(IServiceCollection services, Action`1<LatencyContextOptions> configure);
    [ExtensionAttribute]
public static IServiceCollection AddLatencyContext(IServiceCollection services, IConfigurationSection section);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.DependencyInjection.ProcessEnricherServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddProcessLogEnricher(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddProcessLogEnricher(IServiceCollection services, Action`1<ProcessLogEnricherOptions> configure);
    [ExtensionAttribute]
public static IServiceCollection AddProcessLogEnricher(IServiceCollection services, IConfigurationSection section);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.Extensions.Diagnostics.Enrichment.ApplicationEnricherTags : object {
    public static string ApplicationName;
    public static string EnvironmentName;
    public static string DeploymentRing;
    public static string BuildVersion;
    [CompilerGeneratedAttribute]
private static IReadOnlyList`1<string> <DimensionNames>k__BackingField;
    public static IReadOnlyList`1<string> DimensionNames { get; }
    private static ApplicationEnricherTags();
    [CompilerGeneratedAttribute]
public static IReadOnlyList`1<string> get_DimensionNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Enrichment.ApplicationLogEnricher : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyValuePair`2[] _tags;
    public ApplicationLogEnricher(IOptions`1<ApplicationLogEnricherOptions> options, IOptions`1<ApplicationMetadata> metadata);
    public sealed virtual void Enrich(IEnrichmentTagCollector collector);
    private static KeyValuePair`2[] Initialize(ApplicationLogEnricherOptions enricherOptions, ApplicationMetadata applicationMetadata);
}
public class Microsoft.Extensions.Diagnostics.Enrichment.ApplicationLogEnricherOptions : object {
    [CompilerGeneratedAttribute]
private bool <EnvironmentName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeploymentRing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildVersion>k__BackingField;
    public bool EnvironmentName { get; public set; }
    public bool ApplicationName { get; public set; }
    public bool DeploymentRing { get; public set; }
    public bool BuildVersion { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnvironmentName();
    [CompilerGeneratedAttribute]
public void set_EnvironmentName(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplicationName();
    [CompilerGeneratedAttribute]
public void set_ApplicationName(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeploymentRing();
    [CompilerGeneratedAttribute]
public void set_DeploymentRing(bool value);
    [CompilerGeneratedAttribute]
public bool get_BuildVersion();
    [CompilerGeneratedAttribute]
public void set_BuildVersion(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.Extensions.Diagnostics.Enrichment.ProcessEnricherTagNames : object {
    public static string ProcessId;
    public static string ThreadId;
    [CompilerGeneratedAttribute]
private static IReadOnlyList`1<string> <DimensionNames>k__BackingField;
    public static IReadOnlyList`1<string> DimensionNames { get; }
    private static ProcessEnricherTagNames();
    [CompilerGeneratedAttribute]
public static IReadOnlyList`1<string> get_DimensionNames();
}
internal class Microsoft.Extensions.Diagnostics.Enrichment.ProcessLogEnricher : object {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static string _threadId;
    private bool _threadIdEnabled;
    [NullableContextAttribute("1")]
public ProcessLogEnricher(IOptions`1<ProcessLogEnricherOptions> options);
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(IEnrichmentTagCollector collector);
}
public class Microsoft.Extensions.Diagnostics.Enrichment.ProcessLogEnricherOptions : object {
    [CompilerGeneratedAttribute]
private bool <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThreadId>k__BackingField;
    public bool ProcessId { get; public set; }
    public bool ThreadId { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(bool value);
}
internal class Microsoft.Extensions.Diagnostics.Enrichment.StaticProcessLogEnricher : object {
    [NullableAttribute("2")]
private string _processId;
    [NullableContextAttribute("1")]
public StaticProcessLogEnricher(IOptions`1<ProcessLogEnricherOptions> options);
    [NullableContextAttribute("1")]
public sealed virtual void Enrich(IEnrichmentTagCollector collector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.CheckpointTracker : object {
    internal TimeProvider TimeProvider;
    private Registry _checkpointNames;
    private Int32[] _checkpointAdded;
    private Checkpoint[] _checkpoints;
    private long _timestamp;
    private int _numCheckpoints;
    public long Elapsed { get; }
    public long Frequency { get; }
    [NullableAttribute("0")]
public ArraySegment`1<Checkpoint> Checkpoints { get; }
    public CheckpointTracker(Registry registry);
    public long get_Elapsed();
    public long get_Frequency();
    public sealed virtual bool TryReset();
    public CheckpointToken GetToken(string name);
    public void Add(CheckpointToken token);
    [NullableContextAttribute("0")]
public ArraySegment`1<Checkpoint> get_Checkpoints();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.LatencyConsoleExporter : object {
    private static int MillisPerSecond;
    private static CompositeFormat _title;
    private static Func`2<int, CompositeFormat> _rows;
    private static Func`2<int, string> _dashes;
    private bool _outputCheckpoints;
    private bool _outputTags;
    private bool _outputMeasures;
    private long _sampleCount;
    public LatencyConsoleExporter(IOptions`1<LatencyConsoleOptions> options);
    private static LatencyConsoleExporter();
    public sealed virtual Task ExportAsync(LatencyData latencyData, CancellationToken cancellationToken);
    private static CompositeFormat StartTable(StringBuilder sb, string nameHeader, string valueHeader, int nameColumnWidth, Boolean& needBlankLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.LatencyContext : object {
    internal bool IsDisposed;
    internal bool IsRunning;
    private ObjectPool`1<LatencyContext> _poolToReturnTo;
    private CheckpointTracker _checkpointTracker;
    private TagCollection _tagCollection;
    private MeasureTracker _measureTracker;
    private long _duration;
    public LatencyData LatencyData { get; }
    private long Duration { get; }
    public LatencyContext(LatencyContextPool latencyContextPool);
    public sealed virtual LatencyData get_LatencyData();
    private long get_Duration();
    public sealed virtual void AddCheckpoint(CheckpointToken token);
    public sealed virtual void SetTag(TagToken token, string value);
    public sealed virtual void AddMeasure(MeasureToken token, long value);
    public sealed virtual void RecordMeasure(MeasureToken token, long value);
    public sealed virtual void Freeze();
    public sealed virtual void Dispose();
    public sealed virtual bool TryReset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.LatencyContextPool : object {
    [CompilerGeneratedAttribute]
private ObjectPool`1<LatencyContext> <Pool>k__BackingField;
    internal LatencyInstrumentProvider LatencyInstrumentProvider;
    internal ObjectPool`1<LatencyContext> Pool { get; internal set; }
    public LatencyContextPool(LatencyInstrumentProvider latencyInstrumentProvider);
    [CompilerGeneratedAttribute]
internal ObjectPool`1<LatencyContext> get_Pool();
    [CompilerGeneratedAttribute]
internal void set_Pool(ObjectPool`1<LatencyContext> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.LatencyContextProvider : object {
    private LatencyContextPool _latencyInstrumentPool;
    public LatencyContextProvider(LatencyInstrumentProvider latencyInstrumentProvider);
    public sealed virtual ILatencyContext CreateContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.LatencyContextRegistrySet : object {
    [CompilerGeneratedAttribute]
private Registry <CheckpointNameRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private Registry <TagNameRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private Registry <MeasureNameRegistry>k__BackingField;
    public Registry CheckpointNameRegistry { get; }
    public Registry TagNameRegistry { get; }
    public Registry MeasureNameRegistry { get; }
    public LatencyContextRegistrySet(IOptions`1<LatencyContextOptions> latencyContextOptions, IOptions`1<LatencyContextRegistrationOptions> registrationOptions);
    [CompilerGeneratedAttribute]
public Registry get_CheckpointNameRegistry();
    [CompilerGeneratedAttribute]
public Registry get_TagNameRegistry();
    [CompilerGeneratedAttribute]
public Registry get_MeasureNameRegistry();
    private static Registry CreateRegistry(IEnumerable`1<string> names, bool throwOnUnregisteredNames);
    private static String[] GetRegistryKeys(IEnumerable`1<string> names);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.LatencyContextTokenIssuer : object {
    private CheckpointTracker _checkpointTracker;
    private MeasureTracker _measureTracker;
    private TagCollection _tagCollection;
    public LatencyContextTokenIssuer(LatencyInstrumentProvider latencyInstrumentProvider);
    public sealed virtual CheckpointToken GetCheckpointToken(string name);
    public sealed virtual TagToken GetTagToken(string name);
    public sealed virtual MeasureToken GetMeasureToken(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.LatencyInstrumentProvider : object {
    private LatencyContextRegistrySet _latencyContextRegistrySet;
    public LatencyInstrumentProvider(LatencyContextRegistrySet latencyContextRegistrySet);
    public CheckpointTracker CreateCheckpointTracker();
    public MeasureTracker CreateMeasureTracker();
    public TagCollection CreateTagCollection();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.MeasureTracker : object {
    private Registry _registeredMeasureNames;
    private String[] _measureNames;
    private Int64[] _measureValues;
    private Measure[] _measures;
    private Int32[] _measurePosition;
    private object _measurePositionLock;
    private int _numMeasures;
    [NullableAttribute("0")]
public ArraySegment`1<Measure> Measures { get; }
    public MeasureTracker(Registry registry);
    public sealed virtual bool TryReset();
    public MeasureToken GetToken(string name);
    public void AddLong(MeasureToken token, long value);
    public void SetLong(MeasureToken token, long value);
    private int GetPositionOfMeasure(MeasureToken measureToken);
    [NullableContextAttribute("0")]
public ArraySegment`1<Measure> get_Measures();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.Registry : object {
    private FrozenDictionary`2<string, int> _keyOrder;
    private bool _throwOnUnregisteredKeyLookup;
    [CompilerGeneratedAttribute]
private String[] <OrderedKeys>k__BackingField;
    public String[] OrderedKeys { get; }
    public int KeyCount { get; }
    public Registry(String[] keys, bool throwOnUnregisteredKeyLookup);
    [CompilerGeneratedAttribute]
public String[] get_OrderedKeys();
    public int get_KeyCount();
    public int GetRegisteredKeyIndex(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.ResetOnGetObjectPool`1 : ObjectPool`1<T> {
    private ObjectPool`1<T> _objectPool;
    public ResetOnGetObjectPool`1(PooledObjectPolicy`1<T> policy);
    public virtual T Get();
    public virtual void Return(T obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Diagnostics.Latency.Internal.TagCollection : object {
    private Registry _tagNames;
    private int _numTags;
    private Tag[] _tags;
    [NullableAttribute("0")]
public ArraySegment`1<Tag> Tags { get; }
    public TagCollection(Registry registry);
    public sealed virtual bool TryReset();
    public TagToken GetToken(string name);
    public void Set(TagToken token, string value);
    [NullableContextAttribute("0")]
public ArraySegment`1<Tag> get_Tags();
}
public class Microsoft.Extensions.Diagnostics.Latency.LatencyConsoleOptions : object {
    [CompilerGeneratedAttribute]
private bool <OutputCheckpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputTags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputMeasures>k__BackingField;
    public bool OutputCheckpoints { get; public set; }
    public bool OutputTags { get; public set; }
    public bool OutputMeasures { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_OutputCheckpoints();
    [CompilerGeneratedAttribute]
public void set_OutputCheckpoints(bool value);
    [CompilerGeneratedAttribute]
public bool get_OutputTags();
    [CompilerGeneratedAttribute]
public void set_OutputTags(bool value);
    [CompilerGeneratedAttribute]
public bool get_OutputMeasures();
    [CompilerGeneratedAttribute]
public void set_OutputMeasures(bool value);
}
public class Microsoft.Extensions.Diagnostics.Latency.LatencyContextOptions : object {
    [CompilerGeneratedAttribute]
private bool <ThrowOnUnregisteredNames>k__BackingField;
    public bool ThrowOnUnregisteredNames { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ThrowOnUnregisteredNames();
    [CompilerGeneratedAttribute]
public void set_ThrowOnUnregisteredNames(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Http.Diagnostics.HttpRouteFormatter : object {
    private static char ForwardSlashSymbol;
    private static char ForwardSlash;
    private IHttpRouteParser _httpRouteParser;
    private IRedactorProvider _redactorProvider;
    public HttpRouteFormatter(IHttpRouteParser httpRouteParser, IRedactorProvider redactorProvider);
    public sealed virtual string Format(string httpRoute, string httpPath, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact);
    public string Format(ParsedRouteSegments& routeSegments, string httpPath, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact);
    private static bool IsRedactionRequired(ParsedRouteSegments& routeSegments, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact);
    private static void RemoveTrailingForwardSlash(StringBuilder formattedHttpPath);
    private void FormatParameter(ReadOnlySpan`1<char> httpPath, Segment& segment, int startIndex, int length, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, StringBuilder outputBuffer);
    private void FormatParameterInStrictMode(ReadOnlySpan`1<char> httpPath, Segment httpRouteSegment, int startIndex, int length, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, StringBuilder outputBuffer);
    private void FormatParameterInLooseMode(ReadOnlySpan`1<char> httpPath, Segment httpRouteSegment, int startIndex, int length, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, StringBuilder outputBuffer);
    private sealed virtual override string Microsoft.Extensions.Http.Diagnostics.IHttpRouteFormatter.Format(ParsedRouteSegments& modreq(System.Runtime.InteropServices.InAttribute) routeSegments, string httpPath, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Http.Diagnostics.HttpRouteParameter : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRedacted>k__BackingField;
    public string Name { get; }
    public string Value { get; }
    public bool IsRedacted { get; }
    public HttpRouteParameter(string name, string value, bool isRedacted);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public bool get_IsRedacted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Http.Diagnostics.HttpRouteParser : object {
    private static char ForwardSlash;
    private IRedactorProvider _redactorProvider;
    private ConcurrentDictionary`2<string, ParsedRouteSegments> _routeTemplateSegmentsCache;
    public HttpRouteParser(IRedactorProvider redactorProvider);
    public bool TryExtractParameters(string httpPath, ParsedRouteSegments& routeSegments, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, HttpRouteParameter[]& httpRouteParameters);
    public sealed virtual ParsedRouteSegments ParseRoute(string httpRoute);
    private static Segment GetParameterSegment(string httpRoute, Int32& pos);
    private static string GetSegmentContent(string httpRoute, int start, int end);
    private string GetRedactedParameterValue(ReadOnlySpan`1<char> httpPath, Segment& segment, int startIndex, int length, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, Boolean& isRedacted);
    private string GetRedactedParameterInStrictMode(ReadOnlySpan`1<char> httpPathAsSpan, Segment segment, int startIndex, int length, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, Boolean& isRedacted);
    private string GetRedactedParameterInLooseMode(ReadOnlySpan`1<char> httpPathAsSpan, Segment segment, int startIndex, int length, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, Boolean& isRedacted);
    private sealed virtual override bool Microsoft.Extensions.Http.Diagnostics.IHttpRouteParser.TryExtractParameters(string httpPath, ParsedRouteSegments& modreq(System.Runtime.InteropServices.InAttribute) routeSegments, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, HttpRouteParameter[]& httpRouteParameters);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Extensions.Http.Diagnostics.IHttpRouteFormatter {
    public abstract virtual string Format(string httpRoute, string httpPath, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact);
    public abstract virtual string Format(ParsedRouteSegments& modreq(System.Runtime.InteropServices.InAttribute) routeSegments, string httpPath, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Extensions.Http.Diagnostics.IHttpRouteParser {
    public abstract virtual ParsedRouteSegments ParseRoute(string httpRoute);
    public abstract virtual bool TryExtractParameters(string httpPath, ParsedRouteSegments& modreq(System.Runtime.InteropServices.InAttribute) routeSegments, HttpRouteParameterRedactionMode redactionMode, IReadOnlyDictionary`2<string, DataClassification> parametersToRedact, HttpRouteParameter[]& httpRouteParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Http.Diagnostics.ParsedRouteSegments : ValueType {
    [CompilerGeneratedAttribute]
private string <RouteTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private Segment[] <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParameterCount>k__BackingField;
    public string RouteTemplate { get; }
    public Segment[] Segments { get; }
    public int ParameterCount { get; }
    public ParsedRouteSegments(string routeTemplate, Segment[] segments);
    [CompilerGeneratedAttribute]
public string get_RouteTemplate();
    [CompilerGeneratedAttribute]
public Segment[] get_Segments();
    [CompilerGeneratedAttribute]
public int get_ParameterCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Http.Diagnostics.Segment : ValueType {
    private static string ControllerParameter;
    private static string ActionParameter;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParam>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParamName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    public int Start { get; }
    public int End { get; }
    public string Content { get; }
    public bool IsParam { get; }
    public string ParamName { get; }
    public string DefaultValue { get; }
    public Segment(int start, int end, string content, bool isParam, string paramName, string defaultValue);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public bool get_IsParam();
    [CompilerGeneratedAttribute]
public string get_ParamName();
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
    internal static bool IsKnownUnredactableParameter(string parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.Http.Diagnostics.TelemetryCommonExtensions : object {
    internal static string UnsupportedEnumValueExceptionMessage;
    [ExtensionAttribute]
public static IServiceCollection AddHttpRouteProcessor(IServiceCollection services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Extensions.Logging.ActivityExtensions : object {
    [ExtensionAttribute]
public static string GetSpanId(Activity activity);
    [ExtensionAttribute]
public static string GetTraceId(Activity activity);
    [ExtensionAttribute]
public static string GetParentId(Activity activity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Logging.ExtendedLogger : object {
    private static string ExceptionType;
    private static string ExceptionMessage;
    private static string ExceptionStackTrace;
    private ExtendedLoggerFactory _factory;
    [CompilerGeneratedAttribute]
private LoggerInformation[] <Loggers>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageLogger[] <MessageLoggers>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopeLogger[] <ScopeLoggers>k__BackingField;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static ModernTagJoiner _modernJoiner;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static LegacyTagJoiner _legacyJoiner;
    public LoggerInformation[] Loggers { get; public set; }
    public MessageLogger[] MessageLoggers { get; public set; }
    public ScopeLogger[] ScopeLoggers { get; public set; }
    private static ModernTagJoiner ModernJoiner { get; }
    private static LegacyTagJoiner LegacyJoiner { get; }
    public ExtendedLogger(ExtendedLoggerFactory factory, LoggerInformation[] loggers);
    [CompilerGeneratedAttribute]
public LoggerInformation[] get_Loggers();
    [CompilerGeneratedAttribute]
public void set_Loggers(LoggerInformation[] value);
    [CompilerGeneratedAttribute]
public MessageLogger[] get_MessageLoggers();
    [CompilerGeneratedAttribute]
public void set_MessageLoggers(MessageLogger[] value);
    [CompilerGeneratedAttribute]
public ScopeLogger[] get_ScopeLoggers();
    [CompilerGeneratedAttribute]
public void set_ScopeLoggers(ScopeLogger[] value);
    [NullableContextAttribute("2")]
public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public sealed virtual IDisposable BeginScope(TState state);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    private static void HandleExceptions(IEnumerable`1<Exception> exceptions);
    private static void RecordException(Exception exception, EnrichmentTagCollector tags, LoggerConfig config);
    private static string GetExceptionStackTrace(Exception exception, LoggerConfig config);
    private void ModernPath(LogLevel logLevel, EventId eventId, LoggerMessageState msgState, Exception exception, Func`3<LoggerMessageState, Exception, string> formatter);
    [NullableContextAttribute("2")]
private void LegacyPath(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    private static ModernTagJoiner get_ModernJoiner();
    private static LegacyTagJoiner get_LegacyJoiner();
    [CompilerGeneratedAttribute]
internal static void <GetExceptionStackTrace>g__HandleException|22_0(Exception exception, int indent, <>c__DisplayClass22_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Logging.ExtendedLoggerFactory : object {
    private Dictionary`2<string, ExtendedLogger> _loggers;
    private List`1<ProviderRegistration> _providerRegistrations;
    private object _sync;
    [NullableAttribute("2")]
private IDisposable _filterOptionsChangeTokenRegistration;
    private LoggerFactoryOptions _factoryOptions;
    [NullableAttribute("2")]
private IDisposable _enrichmentOptionsChangeTokenRegistration;
    [NullableAttribute("2")]
private IDisposable _redactionOptionsChangeTokenRegistration;
    private Action`1[] _enrichers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyValuePair`2[] _staticTags;
    private Func`2<DataClassificationSet, Redactor> _redactorProvider;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private LoggerFilterOptions _filterOptions;
    [NullableAttribute("2")]
private IExternalScopeProvider _scopeProvider;
    [CompilerGeneratedAttribute]
private LoggerConfig <Config>k__BackingField;
    internal LoggerConfig Config { get; private set; }
    public ExtendedLoggerFactory(IEnumerable`1<ILoggerProvider> providers, IEnumerable`1<ILogEnricher> enrichers, IEnumerable`1<IStaticLogEnricher> staticEnrichers, IOptionsMonitor`1<LoggerFilterOptions> filterOptions, IOptions`1<LoggerFactoryOptions> factoryOptions, IExternalScopeProvider scopeProvider, IOptionsMonitor`1<LoggerEnrichmentOptions> enrichmentOptions, IOptionsMonitor`1<LoggerRedactionOptions> redactionOptions, IRedactorProvider redactorProvider);
    public sealed virtual void Dispose();
    public sealed virtual ILogger CreateLogger(string categoryName);
    public sealed virtual void AddProvider(ILoggerProvider provider);
    [MemberNotNullAttribute("_filterOptions")]
private void RefreshFilters(LoggerFilterOptions filterOptions);
    private void AddProviderRegistration(ILoggerProvider provider, bool dispose);
    private LoggerInformation[] CreateLoggers(string categoryName);
    private ValueTuple`2<MessageLogger[], ScopeLogger[]> ApplyFilters(LoggerInformation[] loggers);
    private bool CheckDisposed();
    [CompilerGeneratedAttribute]
internal LoggerConfig get_Config();
    [CompilerGeneratedAttribute]
private void set_Config(LoggerConfig value);
    [NullableContextAttribute("2")]
private LoggerConfig ComputeConfig(LoggerEnrichmentOptions enrichmentOptions, LoggerRedactionOptions redactionOptions);
    private void UpdateEnrichmentOptions(LoggerEnrichmentOptions enrichmentOptions);
    private void UpdateRedactionOptions(LoggerRedactionOptions redactionOptions);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Logging.JustInTimeRedactor : object {
    private static int MaxStackAllocation;
    private static int MaxDayOfYearLength;
    [NullableAttribute("1")]
private static string DiscriminatorSeparator;
    private Redactor _redactor;
    [NullableAttribute("1")]
private string _discriminator;
    private object _value;
    [CompilerGeneratedAttribute]
private JustInTimeRedactor <Next>k__BackingField;
    [NullableAttribute("1")]
private static ObjectPool`1<JustInTimeRedactor> _pool;
    public JustInTimeRedactor Next { get; public set; }
    private static JustInTimeRedactor();
    [NullableContextAttribute("1")]
public static JustInTimeRedactor Get(object value, Redactor redactor, string discriminator);
    public void Return();
    [CompilerGeneratedAttribute]
public JustInTimeRedactor get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(JustInTimeRedactor value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [SkipLocalsInitAttribute]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [NullableContextAttribute("0")]
public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private sealed virtual override bool Microsoft.Extensions.ObjectPool.IResettable.TryReset();
    [NullableContextAttribute("0")]
[SkipLocalsInitAttribute]
private bool TryRedactWithDiscriminator(object value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, String& result, bool generateResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Logging.LoggerConfig : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private KeyValuePair`2[] <StaticTags>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1[] <Enrichers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaptureStackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseFileInfoForStackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStackTraceLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<DataClassificationSet, Redactor> <GetRedactor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddRedactionDiscriminator>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2[] StaticTags { get; }
    public Action`1[] Enrichers { get; }
    public bool CaptureStackTraces { get; }
    public bool UseFileInfoForStackTraces { get; }
    public bool IncludeExceptionMessage { get; }
    public int MaxStackTraceLength { get; }
    public Func`2<DataClassificationSet, Redactor> GetRedactor { get; }
    public bool AddRedactionDiscriminator { get; }
    public LoggerConfig(KeyValuePair`2[] staticTags, Action`1[] enrichers, bool captureStackTraces, bool useFileInfoForStackTraces, bool includeExceptionMessage, int maxStackTraceLength, Func`2<DataClassificationSet, Redactor> getRedactor, bool addRedactionDiscriminator);
    [CompilerGeneratedAttribute]
public KeyValuePair`2[] get_StaticTags();
    [CompilerGeneratedAttribute]
public Action`1[] get_Enrichers();
    [CompilerGeneratedAttribute]
public bool get_CaptureStackTraces();
    [CompilerGeneratedAttribute]
public bool get_UseFileInfoForStackTraces();
    [CompilerGeneratedAttribute]
public bool get_IncludeExceptionMessage();
    [CompilerGeneratedAttribute]
public int get_MaxStackTraceLength();
    [CompilerGeneratedAttribute]
public Func`2<DataClassificationSet, Redactor> get_GetRedactor();
    [CompilerGeneratedAttribute]
public bool get_AddRedactionDiscriminator();
}
public class Microsoft.Extensions.Logging.LoggerEnrichmentOptions : object {
    private static int MaxDefinedStackTraceLength;
    private static int MinDefinedStackTraceLength;
    private static int DefaultStackTraceLength;
    [CompilerGeneratedAttribute]
private bool <CaptureStackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseFileInfoForStackTraces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxStackTraceLength>k__BackingField;
    public bool CaptureStackTraces { get; public set; }
    public bool UseFileInfoForStackTraces { get; public set; }
    public bool IncludeExceptionMessage { get; public set; }
    [RangeAttribute("2048", "32768")]
public int MaxStackTraceLength { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CaptureStackTraces();
    [CompilerGeneratedAttribute]
public void set_CaptureStackTraces(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseFileInfoForStackTraces();
    [CompilerGeneratedAttribute]
public void set_UseFileInfoForStackTraces(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_IncludeExceptionMessage(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxStackTraceLength();
    [CompilerGeneratedAttribute]
public void set_MaxStackTraceLength(int value);
}
[OptionsValidatorAttribute]
internal class Microsoft.Extensions.Logging.LoggerEnrichmentOptionsValidator : object {
    [NullableContextAttribute("1")]
[GeneratedCodeAttribute("Microsoft.Extensions.Options.SourceGeneration", "8.0.10.6711")]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026:RequiresUnreferencedCode")]
public sealed virtual ValidateOptionsResult Validate(string name, LoggerEnrichmentOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Logging.LoggerFactoryScopeProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLocal`1<Scope> _currentScope;
    private ActivityTrackingOptions _activityTrackingOption;
    public LoggerFactoryScopeProvider(ActivityTrackingOptions activityTrackingOption);
    public sealed virtual void ForEachScope(Action`2<object, TState> callback, TState state);
    private static ActivityBaggageLogScopeWrapper GetOrCreateActivityBaggageLogScopeWrapper(Activity activity, IEnumerable`1<KeyValuePair`2<string, string>> items);
    public sealed virtual IDisposable Push(object state);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <ForEachScope>g__Report|3_0(Scope current, <>c__DisplayClass3_0`1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Logging.LoggerInformation : ValueType {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ProviderType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExternalScope>k__BackingField;
    public ILogger Logger { get; }
    public string Category { get; }
    public Type ProviderType { get; }
    public bool ExternalScope { get; }
    public LoggerInformation(ILoggerProvider provider, string category);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public Type get_ProviderType();
    [CompilerGeneratedAttribute]
public bool get_ExternalScope();
}
public class Microsoft.Extensions.Logging.LoggerRedactionOptions : object {
    [CompilerGeneratedAttribute]
private bool <ApplyDiscriminator>k__BackingField;
    public bool ApplyDiscriminator { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ApplyDiscriminator();
    [CompilerGeneratedAttribute]
public void set_ApplyDiscriminator(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Extensions.Logging.LoggerRuleSelector : object {
    public static void Select(LoggerFilterOptions options, Type providerType, string category, Nullable`1& minLevel, Func`4& filter);
    private static bool IsBetter(LoggerFilterRule rule, LoggerFilterRule current, string logger, string category);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.Logging.LoggingEnrichmentExtensions : object {
    [ExtensionAttribute]
public static ILoggingBuilder EnableEnrichment(ILoggingBuilder builder);
    [ExtensionAttribute]
public static ILoggingBuilder EnableEnrichment(ILoggingBuilder builder, Action`1<LoggerEnrichmentOptions> configure);
    [ExtensionAttribute]
public static ILoggingBuilder EnableEnrichment(ILoggingBuilder builder, IConfigurationSection section);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EventSourceAttribute]
internal class Microsoft.Extensions.Logging.LoggingEventSource : EventSource {
    public static LoggingEventSource Instance;
    private static LoggingEventSource();
    [NonEventAttribute]
internal void LoggingException(Exception ex);
    [EventAttribute("1")]
private void LoggingException(string exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Extensions.Logging.LoggingRedactionExtensions : object {
    [ExtensionAttribute]
public static ILoggingBuilder EnableRedaction(ILoggingBuilder builder);
    [ExtensionAttribute]
public static ILoggingBuilder EnableRedaction(ILoggingBuilder builder, Action`1<LoggerRedactionOptions> configure);
    [ExtensionAttribute]
public static ILoggingBuilder EnableRedaction(ILoggingBuilder builder, IConfigurationSection section);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Logging.MessageLogger : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Func`2<LogLevel, bool> <LoggerIsEnabled>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`5<LogLevel, EventId, ModernTagJoiner, Exception, Func`3<ModernTagJoiner, Exception, string>> <LoggerLog>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderTypeFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LogLevel> <MinLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<string, string, LogLevel, bool> <Filter>k__BackingField;
    [NullableAttribute("1")]
public Func`2<LogLevel, bool> LoggerIsEnabled { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`5<LogLevel, EventId, ModernTagJoiner, Exception, Func`3<ModernTagJoiner, Exception, string>> LoggerLog { get; }
    [NullableAttribute("1")]
public ILogger Logger { get; }
    public string Category { get; }
    private string ProviderTypeFullName { get; }
    public Nullable`1<LogLevel> MinLevel { get; }
    public Func`4<string, string, LogLevel, bool> Filter { get; }
    public MessageLogger(ILogger logger, string category, string providerTypeFullName, Nullable`1<LogLevel> minLevel, Func`4<string, string, LogLevel, bool> filter);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Func`2<LogLevel, bool> get_LoggerIsEnabled();
    [CompilerGeneratedAttribute]
public Action`5<LogLevel, EventId, ModernTagJoiner, Exception, Func`3<ModernTagJoiner, Exception, string>> get_LoggerLog();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
private string get_ProviderTypeFullName();
    [CompilerGeneratedAttribute]
public Nullable`1<LogLevel> get_MinLevel();
    [CompilerGeneratedAttribute]
public Func`4<string, string, LogLevel, bool> get_Filter();
    public bool IsNotFilteredOut(LogLevel level);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Extensions.Logging.NullScope : object {
    [CompilerGeneratedAttribute]
private static NullScope <Instance>k__BackingField;
    public static NullScope Instance { get; }
    private static NullScope();
    [CompilerGeneratedAttribute]
public static NullScope get_Instance();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Extensions.Logging.ProviderAliasUtilities : object {
    private static string AliasAttributeTypeFullName;
    internal static string GetAlias(Type providerType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.Extensions.Logging.ScopeLogger : ValueType {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IExternalScopeProvider <ExternalScopeProvider>k__BackingField;
    public ILogger Logger { get; }
    public IExternalScopeProvider ExternalScopeProvider { get; }
    public ScopeLogger(ILogger logger, IExternalScopeProvider externalScopeProvider);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public IExternalScopeProvider get_ExternalScopeProvider();
    [NullableContextAttribute("1")]
public IDisposable CreateScope(TState state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[AttributeUsageAttribute("2432")]
internal class Microsoft.Shared.Data.Validation.LengthAttribute : ValidationAttribute {
    [CompilerGeneratedAttribute]
private int <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclusive>k__BackingField;
    public int MinimumLength { get; }
    public Nullable`1<int> MaximumLength { get; }
    public bool Exclusive { get; public set; }
    [RequiresUnreferencedCodeAttribute("Uses reflection to get the 'Count' property on types that don't implement ICollection. This 'Count' property may be trimmed. Ensure it is preserved.")]
public LengthAttribute(int minimumLength);
    [RequiresUnreferencedCodeAttribute("Uses reflection to get the 'Count' property on types that don't implement ICollection. This 'Count' property may be trimmed. Ensure it is preserved.")]
public LengthAttribute(int minimumLength, int maximumLength);
    [CompilerGeneratedAttribute]
public int get_MinimumLength();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public bool get_Exclusive();
    [CompilerGeneratedAttribute]
public void set_Exclusive(bool value);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
protected virtual ValidationResult IsValid(object value, ValidationContext validationContext);
    [RequiresUnreferencedCodeAttribute("Uses reflection to get the 'Count' property on types that don't implement ICollection. This 'Count' property may be trimmed. Ensure it is preserved.")]
private static PropertyInfo GetCountProperty(object value);
    private ValidationResult Validate(int count, ValidationContext validationContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[AttributeUsageAttribute("2432")]
internal class Microsoft.Shared.Data.Validation.TimeSpanAttribute : ValidationAttribute {
    [CompilerGeneratedAttribute]
private bool <Exclusive>k__BackingField;
    private Nullable`1<int> _minMs;
    private Nullable`1<int> _maxMs;
    private string _min;
    private string _max;
    public TimeSpan Minimum { get; }
    public Nullable`1<TimeSpan> Maximum { get; }
    public bool Exclusive { get; public set; }
    public TimeSpanAttribute(int minMs);
    public TimeSpanAttribute(int minMs, int maxMs);
    [NullableContextAttribute("1")]
public TimeSpanAttribute(string min);
    [NullableContextAttribute("1")]
public TimeSpanAttribute(string min, string max);
    public TimeSpan get_Minimum();
    public Nullable`1<TimeSpan> get_Maximum();
    [CompilerGeneratedAttribute]
public bool get_Exclusive();
    [CompilerGeneratedAttribute]
public void set_Exclusive(bool value);
    protected virtual ValidationResult IsValid(object value, ValidationContext validationContext);
}
[ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static class Microsoft.Shared.Data.Validation.ValidationContextExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static String[] GetMemberName(ValidationContext validationContext);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetDisplayName(ValidationContext validationContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal static class Microsoft.Shared.Diagnostics.Throw : object {
    public static T IfNull(T argument, string paramName);
    public static TMember IfNullOrMemberNull(TParameter argument, TMember member, string paramName, string memberName);
    public static TMember IfMemberNull(TParameter argument, TMember member, string paramName, string memberName);
    public static string IfNullOrWhitespace(string argument, string paramName);
    public static string IfNullOrEmpty(string argument, string paramName);
    public static void IfBufferTooSmall(int bufferSize, int requiredSize, string paramName);
    [NullableContextAttribute("0")]
public static T IfOutOfRange(T argument, string paramName);
    [ExcludeFromCodeCoverageAttribute]
public static IEnumerable`1<T> IfNullOrEmpty(IEnumerable`1<T> argument, string paramName);
    [DoesNotReturnAttribute]
public static void ArgumentNullException(string paramName);
    [DoesNotReturnAttribute]
public static void ArgumentNullException(string paramName, string message);
    [DoesNotReturnAttribute]
public static void ArgumentOutOfRangeException(string paramName);
    [DoesNotReturnAttribute]
public static void ArgumentOutOfRangeException(string paramName, string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public static void ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    [DoesNotReturnAttribute]
public static void ArgumentException(string paramName, string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public static void ArgumentException(string paramName, string message, Exception innerException);
    [DoesNotReturnAttribute]
public static void InvalidOperationException(string message);
    [DoesNotReturnAttribute]
public static void InvalidOperationException(string message, Exception innerException);
    public static int IfLessThan(int argument, int min, string paramName);
    public static int IfGreaterThan(int argument, int max, string paramName);
    public static int IfLessThanOrEqual(int argument, int min, string paramName);
    public static int IfGreaterThanOrEqual(int argument, int max, string paramName);
    public static int IfOutOfRange(int argument, int min, int max, string paramName);
    public static int IfZero(int argument, string paramName);
    public static UInt32 IfLessThan(UInt32 argument, UInt32 min, string paramName);
    public static UInt32 IfGreaterThan(UInt32 argument, UInt32 max, string paramName);
    public static UInt32 IfLessThanOrEqual(UInt32 argument, UInt32 min, string paramName);
    public static UInt32 IfGreaterThanOrEqual(UInt32 argument, UInt32 max, string paramName);
    public static UInt32 IfOutOfRange(UInt32 argument, UInt32 min, UInt32 max, string paramName);
    public static UInt32 IfZero(UInt32 argument, string paramName);
    public static long IfLessThan(long argument, long min, string paramName);
    public static long IfGreaterThan(long argument, long max, string paramName);
    public static long IfLessThanOrEqual(long argument, long min, string paramName);
    public static long IfGreaterThanOrEqual(long argument, long max, string paramName);
    public static long IfOutOfRange(long argument, long min, long max, string paramName);
    public static long IfZero(long argument, string paramName);
    public static ulong IfLessThan(ulong argument, ulong min, string paramName);
    public static ulong IfGreaterThan(ulong argument, ulong max, string paramName);
    public static ulong IfLessThanOrEqual(ulong argument, ulong min, string paramName);
    public static ulong IfGreaterThanOrEqual(ulong argument, ulong max, string paramName);
    public static ulong IfOutOfRange(ulong argument, ulong min, ulong max, string paramName);
    public static ulong IfZero(ulong argument, string paramName);
    public static double IfLessThan(double argument, double min, string paramName);
    public static double IfGreaterThan(double argument, double max, string paramName);
    public static double IfLessThanOrEqual(double argument, double min, string paramName);
    public static double IfGreaterThanOrEqual(double argument, double max, string paramName);
    public static double IfOutOfRange(double argument, double min, double max, string paramName);
    public static double IfZero(double argument, string paramName);
}
[ExcludeFromCodeCoverageAttribute]
internal static class Microsoft.Shared.Memoization.Memoize : object {
    [NullableContextAttribute("1")]
public static Func`2<TParameter, TResult> Function(Func`2<TParameter, TResult> f);
    [NullableContextAttribute("2")]
public static Func`3<TParameter1, TParameter2, TResult> Function(Func`3<TParameter1, TParameter2, TResult> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerDisplayAttribute("{_values.Count} memoized values")]
internal class Microsoft.Shared.Memoization.MemoizedFunction`2 : object {
    private static int Concurrency;
    private static int Capacity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<Arg<TParameter, TResult>, Lazy`1<TResult>> _values;
    private Func`2<TParameter, TResult> _function;
    public MemoizedFunction`2(Func`2<TParameter, TResult> function);
    internal TResult Function(TParameter arg1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerDisplayAttribute("{_values.Count} memoized values")]
internal class Microsoft.Shared.Memoization.MemoizedFunction`3 : object {
    private static int Concurrency;
    private static int Capacity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<Args<TParameter1, TParameter2, TResult>, Lazy`1<TResult>> _values;
    private Func`3<TParameter1, TParameter2, TResult> _function;
    public MemoizedFunction`3(Func`3<TParameter1, TParameter2, TResult> function);
    internal TResult Function(TParameter1 arg1, TParameter2 arg2);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Shared.Pools.NoopPooledObjectPolicy`1 : PooledObjectPolicy`1<T> {
    [CompilerGeneratedAttribute]
private static NoopPooledObjectPolicy`1<T> <Instance>k__BackingField;
    public static NoopPooledObjectPolicy`1<T> Instance { get; }
    private static NoopPooledObjectPolicy`1();
    [CompilerGeneratedAttribute]
public static NoopPooledObjectPolicy`1<T> get_Instance();
    public virtual T Create();
    public virtual bool Return(T obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Shared.Pools.PooledCancellationTokenSourcePolicy : PooledObjectPolicy`1<CancellationTokenSource> {
    [CompilerGeneratedAttribute]
private static PooledCancellationTokenSourcePolicy <Instance>k__BackingField;
    public static PooledCancellationTokenSourcePolicy Instance { get; }
    private static PooledCancellationTokenSourcePolicy();
    [CompilerGeneratedAttribute]
public static PooledCancellationTokenSourcePolicy get_Instance();
    public virtual CancellationTokenSource Create();
    public virtual bool Return(CancellationTokenSource obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Shared.Pools.PooledDictionaryPolicy`2 : PooledObjectPolicy`1<Dictionary`2<TKey, TValue>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<TKey> _comparer;
    public PooledDictionaryPolicy`2(IEqualityComparer`1<TKey> comparer);
    public virtual Dictionary`2<TKey, TValue> Create();
    public virtual bool Return(Dictionary`2<TKey, TValue> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Shared.Pools.PooledListPolicy`1 : PooledObjectPolicy`1<List`1<T>> {
    [CompilerGeneratedAttribute]
private static PooledListPolicy`1<T> <Instance>k__BackingField;
    public static PooledListPolicy`1<T> Instance { get; }
    private static PooledListPolicy`1();
    [CompilerGeneratedAttribute]
public static PooledListPolicy`1<T> get_Instance();
    public virtual List`1<T> Create();
    public virtual bool Return(List`1<T> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Shared.Pools.PooledSetPolicy`1 : PooledObjectPolicy`1<HashSet`1<T>> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<T> _comparer;
    public PooledSetPolicy`1(IEqualityComparer`1<T> comparer);
    public virtual HashSet`1<T> Create();
    public virtual bool Return(HashSet`1<T> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
internal static class Microsoft.Shared.Pools.PoolFactory : object {
    internal static int DefaultCapacity;
    private static int DefaultMaxStringBuilderCapacity;
    private static int InitialStringBuilderCapacity;
    private static IPooledObjectPolicy`1<StringBuilder> _defaultStringBuilderPolicy;
    [CompilerGeneratedAttribute]
private static ObjectPool`1<StringBuilder> <SharedStringBuilderPool>k__BackingField;
    public static ObjectPool`1<StringBuilder> SharedStringBuilderPool { get; }
    private static PoolFactory();
    public static ObjectPool`1<T> CreatePool(int maxCapacity);
    public static ObjectPool`1<T> CreatePool(IPooledObjectPolicy`1<T> policy, int maxCapacity);
    public static ObjectPool`1<T> CreateResettingPool(int maxCapacity);
    public static ObjectPool`1<StringBuilder> CreateStringBuilderPool(int maxCapacity, int maxStringBuilderCapacity);
    public static ObjectPool`1<List`1<T>> CreateListPool(int maxCapacity);
    public static ObjectPool`1<Dictionary`2<TKey, TValue>> CreateDictionaryPool(IEqualityComparer`1<TKey> comparer, int maxCapacity);
    public static ObjectPool`1<HashSet`1<T>> CreateHashSetPool(IEqualityComparer`1<T> comparer, int maxCapacity);
    public static ObjectPool`1<CancellationTokenSource> CreateCancellationTokenSourcePool(int maxCapacity);
    [CompilerGeneratedAttribute]
public static ObjectPool`1<StringBuilder> get_SharedStringBuilderPool();
    private static DefaultObjectPool`1<T> MakePool(IPooledObjectPolicy`1<T> policy, int maxRetained);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
internal class Microsoft.Shared.Pools.RentedSpan`1 : ValueType {
    internal static int MinimumRentalSpace;
    private int _length;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private T[] _rentedBuffer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    public bool Rented { get; }
    public RentedSpan`1(int length);
    public void Dispose();
    public Span`1<T> get_Span();
    public bool get_Rented();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static class Microsoft.Shared.Text.NumericExtensions : object {
    [ExtensionAttribute]
public static string ToInvariantString(int value);
    [ExtensionAttribute]
public static string ToInvariantString(long value);
}
[GeneratedCodeAttribute("Microsoft.Extensions.Configuration.Binder.SourceGeneration", "8.0.9.3103")]
[AttributeUsageAttribute("64")]
internal class System.Runtime.CompilerServices.<BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__InterceptsLocationAttribute : Attribute {
    [NullableContextAttribute("1")]
public <BindingExtensions_g>F35BBFB29C4BBAA0795A1AD3821A65A32A165DD4C7411915DB45791072CCA5287__InterceptsLocationAttribute(string filePath, int line, int column);
}
